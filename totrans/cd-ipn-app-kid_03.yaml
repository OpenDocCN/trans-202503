- en: '**2**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LEARNING TO CODE IN A PLAYGROUND
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A “[Hello, world!](text00011.html#ch01) ” app is no small accomplishment, but
    now it’s time to really learn how to write some code. Xcode provides a special
    type of document called a *playground* , which is a great place to learn how to
    program. In a playground, you can write and run code immediately to see the results,
    without going through the trouble of writing a whole app, as we did in [Chapter
    1](text00011.html#ch01) .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s open a playground. Open Xcode and select **Get started with a playground**
    , as shown in the Welcome to Xcode dialog in [Figure 2-1](text00012.html#ch02fig1)
    . If this window doesn’t automatically open, select **Welcome to Xcode** from
    the Window option in the menu or press ⌘ -SHIFT -1.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: Getting started with a playground*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  prefs: []
  type: TYPE_NORMAL
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: LEARNING TO CODE IN A PLAYGROUND
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A “[Hello, world!](text00011.html#ch01) ” app is no small accomplishment, but
    now it’s time to really learn how to write some code. Xcode provides a special
    type of document called a *playground* , which is a great place to learn how to
    program. In a playground, you can write and run code immediately to see the results,
    without going through the trouble of writing a whole app, as we did in [Chapter
    1](text00011.html#ch01) .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s open a playground. Open Xcode and select **Get started with a playground**
    , as shown in the Welcome to Xcode dialog in [Figure 2-1](text00012.html#ch02fig1)
    . If this window doesn’t automatically open, select **Welcome to Xcode** from
    the Window option in the menu or press ⌘ -SHIFT -1.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: Getting started with a playground*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  prefs: []
  type: TYPE_NORMAL
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A “[Hello, world!](text00011.html#ch01) ” app is no small accomplishment, but
    now it’s time to really learn how to write some code. Xcode provides a special
    type of document called a *playground* , which is a great place to learn how to
    program. In a playground, you can write and run code immediately to see the results,
    without going through the trouble of writing a whole app, as we did in [Chapter
    1](text00011.html#ch01) .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s open a playground. Open Xcode and select **Get started with a playground**
    , as shown in the Welcome to Xcode dialog in [Figure 2-1](text00012.html#ch02fig1)
    . If this window doesn’t automatically open, select **Welcome to Xcode** from
    the Window option in the menu or press ⌘ -SHIFT -1.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: Getting started with a playground*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  prefs: []
  type: TYPE_NORMAL
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: A “[Hello, world!](text00011.html#ch01) ” app is no small accomplishment, but
    now it’s time to really learn how to write some code. Xcode provides a special
    type of document called a *playground* , which is a great place to learn how to
    program. In a playground, you can write and run code immediately to see the results,
    without going through the trouble of writing a whole app, as we did in [Chapter
    1](text00011.html#ch01) .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s open a playground. Open Xcode and select **Get started with a playground**
    , as shown in the Welcome to Xcode dialog in [Figure 2-1](text00012.html#ch02fig1)
    . If this window doesn’t automatically open, select **Welcome to Xcode** from
    the Window option in the menu or press ⌘ -SHIFT -1.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: Getting started with a playground*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  prefs: []
  type: TYPE_NORMAL
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s open a playground. Open Xcode and select **Get started with a playground**
    , as shown in the Welcome to Xcode dialog in [Figure 2-1](text00012.html#ch02fig1)
    . If this window doesn’t automatically open, select **Welcome to Xcode** from
    the Window option in the menu or press ⌘ -SHIFT -1.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: Getting started with a playground*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  prefs: []
  type: TYPE_NORMAL
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: Getting started with a playground*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  prefs: []
  type: TYPE_NORMAL
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-1: Getting started with a playground*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  prefs: []
  type: TYPE_NORMAL
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  prefs: []
  type: TYPE_NORMAL
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  prefs: []
  type: TYPE_NORMAL
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  prefs: []
  type: TYPE_NORMAL
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-3: Playground editor and results sidebar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**DATA TYPES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECLARING DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**TYPE INFERENCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'And sometimes we do not include the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: The results sidebar shows that days is still equal to 365.25 .
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: This code works because we’re multiplying two Double data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
