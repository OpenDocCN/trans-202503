<html><head></head><body>
<section aria-labelledby="ch9" epub:type="chapter" role="doc-chapter">
<span aria-label="195" epub:type="pagebreak" id="pg_195" role="doc-pagebreak"/>
<hgroup>

<h1 class="CHAPTER" id="ch9">
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp></span>
<span class="CT1"><samp class="SANS_Dogma_OT_Bold_B_11">PREPROCESSOR</samp></span>
</h1>
</hgroup>
<p class="CAU"><i>with Aaron Ballman</i></p>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">The preprocessor is the part of the C compiler that runs at an early phase of compilation and transforms the source code before it’s translated, such as inserting code from one file (typically a header) into another (typically a source file). The preprocessor also allows you to specify that an identifier should be automatically substituted by a source code segment during macro expansion. In this chapter, you’ll learn how to use the preprocessor to include files, define object- and function-like macros, conditionally include code based on implementation-specific features, and embed binary resources into your program.</p>
<section aria-labelledby="sec1" epub:type="division">
<span aria-label="196" epub:type="pagebreak" id="pg_196" role="doc-pagebreak"/>
<h2 class="H1" id="sec1"><span id="h1-79"/><samp class="SANS_Futura_Std_Bold_B_11">The Compilation Process</samp></h2>
<p class="TNI">Conceptually, the compilation process consists of a pipeline of eight phases, as shown in <a href="chapter9.xhtml#fig9-1">Figure 9-1</a>. We call these <i>translation phases</i> because each phase translates the code for processing by the next phase.</p>
<figure class="IMG"><img alt="" class="img1" id="fig9-1" src="../images/f09001.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: Translation phases</samp></p></figcaption>
</figure>
<p class="TX">The preprocessor runs before the translator translates the source code into object code, which allows the preprocessor to modify the source code the user wrote <i>before</i> the translator operates on it. Consequently, the preprocessor has a limited amount of semantic information about the program being compiled. It doesn’t understand functions, variables, or types. Only basic elements, such as header names, identifiers, literals, and punctuation characters like <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> are meaningful to the preprocessor. These basic elements, called <i>tokens</i>, are the smallest elements of a computer program that have meaning to a compiler.</p>
<p class="TX">The preprocessor operates on <i>preprocessing directives</i> that you include in the source code to program the behavior of the preprocessor. You spell preprocessing directives with a leading <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp> token followed by a directive name, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">#if</samp>. Each preprocessing directive is terminated by a newline character. You can indent directives by including whitespace between the beginning of the line and the <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp></p>

<pre><code>  #define THIS_IS_FINE 1</code></pre>
<p class="Continued">or between the <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp> and the directive:</p>

<pre><code>#  define SO_IS_THIS 1</code></pre>
<p class="TX">Preprocessing directives instruct the preprocessor to alter the resulting translation unit. If your program contains preprocessing directives, the code the translator consumes is not the same code you wrote. Compilers usually provide a way to view the preprocessor output, called a <i>translation unit</i>, passed to the translator. Viewing the preprocessor output is unnecessary, but you may find it informative to see the actual code given to the translator. <a href="chapter9.xhtml#tab9-1">Table 9-1</a> lists flags that common compilers use to output a translation unit.</p>
<p class="TT" id="tab9-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-1:</samp> <samp class="SANS_Futura_Std_Book_11">Outputting a Translation Unit</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Compiler</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Example command line</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Clang</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">clang</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">other-options</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-E -o</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tu.i tu.c</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">GCC</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">other-options</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-E -o</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tu.i tu.c</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Visual C++</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">cl</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">other-options</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/P /Fi</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tu.i tu.c</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Preprocessed output files are commonly given a <i>.i</i> file extension.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<span aria-label="197" epub:type="pagebreak" id="pg_197" role="doc-pagebreak"/>
<h2 class="H1" id="sec2"><span id="h1-80"/><samp class="SANS_Futura_Std_Bold_B_11">File Inclusion</samp></h2>
<p class="TNI">A powerful feature of the preprocessor is the ability to insert the contents of one source file into the contents of another source file by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> preprocessing directive. The included files are called <i>headers</i> to distinguish them from other source files. Headers typically contain declarations for use by other programs. This is the most common way to share external declarations of functions, objects, and data types with other parts of the program.</p>
<p class="TX">You’ve already seen many examples of including the headers for C standard library functions in the examples in this book. For instance, the program in <a href="chapter9.xhtml#tab9-2">Table 9-2</a> is separated into a header named <i>bar.h</i> and a source file named <i>foo.c</i>. The source file <i>foo.c</i> does not directly contain a declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp>, yet the function is successfully referenced by name within <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. During preprocessing, the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directive inserts the contents of <i>bar.h</i> into <i>foo.c</i> in the place of the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directive itself.</p>
<p class="TT" id="tab9-2"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-2:</samp> <samp class="SANS_Futura_Std_Book_11">Header Inclusion</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF1"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">bar.h</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp></p></td>
<td class="TBFL" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>
</tr>
<tr>
<td class="TBL1"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#include "bar.h"</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The preprocessor executes <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directives as it encounters them. Therefore, inclusion has transitive properties: if a source file includes a header that itself includes another header, the preprocessed output will contain the contents of both headers. For example, given the <i>baz.h</i> and <i>bar.h</i> headers and the <i>foo.c</i> source file, the output after running the preprocessor on the <i>foo.c</i> source code is shown in <a href="chapter9.xhtml#tab9-3">Table 9-3</a>.</p>
<p class="TT" id="tab9-3"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-3:</samp> <samp class="SANS_Futura_Std_Book_11">Transitive Header Inclusion</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF1"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">baz.h</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int other_func(void);</samp></p></td>
<td class="TBL" rowspan="3"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int other_func(void);</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>
</tr>
<tr>
<td class="TB1"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">bar.h</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#include "baz.h"</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp></p></td>
</tr>
<tr>
<td class="TBL1"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#include "bar.h"</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">   return func();</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX"><span aria-label="198" epub:type="pagebreak" id="pg_198" role="doc-pagebreak"/>Compiling the <i>foo.c</i> source file causes the preprocessor to include the <samp class="SANS_TheSansMonoCd_W5Regular_11">"bar.h"</samp> header. The preprocessor then finds the include directive for the <samp class="SANS_TheSansMonoCd_W5Regular_11">"baz.h"</samp> header and includes it as well, bringing the declaration for <samp class="SANS_TheSansMonoCd_W5Regular_11">other_func</samp> into the resulting translation unit.</p>
<p class="TX">A best practice is to avoid relying on transitive includes because they make your code brittle. Consider using tools like include-what-you-use (<i><a href="https://include-what-you-use.org">https://<wbr/>include<wbr/>-what<wbr/>-you<wbr/>-use<wbr/>.org</a></i>) to automatically remove reliance on transitive includes.</p>
<p class="TX">Starting with C23, you can test for the presence of an include file before the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directive is executed with the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp> preprocessor operator. It takes a header name as the only operand. The operator returns true if the specified file can be found and false otherwise. You can use it with conditional inclusion to provide an alternative implementation if a file cannot be included. For example, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp> preprocessor operator to test for C standard library threading or POSIX threads support as follows:</p>

<pre><code>#if __has_include(&lt;threads.h&gt;)
#  include &lt;threads.h&gt;
   typedef thrd_t thread_handle;
#elif __has_include(&lt;pthread.h&gt;)
   typedef pthread_t thread_handle;
#endif</code></pre>
<p class="TX">You can use either a quoted include string (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">#include "foo.h"</samp>) or an angle-bracketed include string (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">#include &lt;foo.h&gt;</samp>) to specify the file to include. The difference between these syntaxes is implementation defined, but they typically influence the search path used to find the included files. For example, both Clang and GCC attempt to find files included with:</p>
<ul class="ul">
<li class="ListBullet">Angle brackets on the <i>system include path</i>, specified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-isystem</samp> flag</li>
<li class="ListBullet">Quoted strings on the <i>quoted include path</i>, specified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-iquote</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-isystem</samp> flags</li>
</ul>
<p class="TX">Refer to your compiler’s documentation for the specific differences between these two syntaxes. Normally, headers for standard or system libraries are found on the default system include path, and your own project headers are found on the quoted include path.</p>
<p class="TX">The header operand passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp> preprocessor operator is specified with either quotes or angle brackets. The operator uses the same search path heuristics as the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directive. Consequently, you should use the same form for both the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directive and corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp> operator to ensure a consistent result.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">

<h2 class="H1" id="sec3"><span id="h1-81"/><samp class="SANS_Futura_Std_Bold_B_11">Conditional Inclusion</samp></h2>
<p class="TNI">Frequently, you’ll need to write different code to support different implementations. For example, you may want to provide alternative implementations <span aria-label="199" epub:type="pagebreak" id="pg_199" role="doc-pagebreak"/>of a function for different target architectures. One solution to this problem is to maintain two files with slight variations between them and compile the appropriate file for a particular implementation. A better solution is to either translate or refrain from translating the target-specific code based on a preprocessor definition.</p>
<p class="TX">You can conditionally include source code using a preprocessing directive such as <samp class="SANS_TheSansMonoCd_W5Regular_11">#if</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp> with a predicate condition. A <i>predicate condition</i> is the controlling constant expression that’s evaluated to determine which branch of the program the preprocessor should take. They’re typically used along with the preprocessor <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> operator, which determines whether a given identifier is the name of a defined macro.</p>
<p class="TX">The conditional inclusion directives are similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statements. When the predicate condition is evaluated to a nonzero preprocessor value, the <samp class="SANS_TheSansMonoCd_W5Regular_11">#if</samp> branch is processed, and all other branches are not. When the predicate condition evaluates to zero, the next <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp> branch, if any, has its predicate tested for inclusion. If none of the predicate conditions evaluate to nonzero, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp> branch, if there is one, is processed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">#endif</samp> preprocessing directive indicates the end of the conditionally included code.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> operator evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> if the given identifier is defined as a macro or <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> otherwise. For example, the preprocessing directives shown in <a href="chapter9.xhtml#Lis9-1">Listing 9-1</a> conditionally determine which header contents to include in the resulting translation unit. The preprocessed output depends on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">_WIN32</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">__ANDROID__</samp> is a defined macro. If neither is a defined macro, the preprocessor output will be empty.</p>
<span id="Lis9-1"/>
<pre><code>#if defined(_WIN32)
#  include &lt;Windows.h&gt;
#elif defined(__ANDROID__)
#  include &lt;android/log.h&gt;
#endif</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: An example of conditional inclusion</samp></p>
<p class="TX">Unlike with the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> keywords, preprocessor conditional inclusion cannot use braces to denote the block of statements controlled by the predicate. Instead, preprocessor conditional inclusion will include all the tokens from the <samp class="SANS_TheSansMonoCd_W5Regular_11">#if</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp> directive (following the predicate) to the next balanced <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">#endif</samp> token found, while skipping any tokens in a conditional inclusion branch not taken. Conditional inclusion directives can be nested. You can write</p>

<pre><code>#ifdef <var>identifier</var></code></pre>
<p class="Continued">as shorthand for:</p>

<pre><code>#if defined <var>identifier</var></code></pre>
<p class="TX"><span aria-label="200" epub:type="pagebreak" id="pg_200" role="doc-pagebreak"/>Similarly, you can write</p>

<pre><code>#ifndef <var>identifier</var></code></pre>
<p class="Continued">as shorthand for:</p>

<pre><code>#if !defined <var>identifier</var></code></pre>
<p class="TX">Starting in C23, you can write</p>

<pre><code>#elifdef <var>identifier</var></code></pre>
<p class="Continued">as shorthand for</p>

<pre><code>#elif defined <var>identifier</var></code></pre>
<p class="Continued">and you can write</p>

<pre><code>#elifndef <var>identifier</var></code></pre>
<p class="Continued">as shorthand for</p>

<pre><code>#elif !defined <var>identifier</var></code></pre>
<p class="Continued">or, equivalently:</p>

<pre><code>#elif !defined(<var>identifier</var>)</code></pre>
<p class="Continued">The parentheses around the identifier are optional.</p>
<section aria-labelledby="sec4" epub:type="division">

<h3 class="H2" id="sec4"><span id="h2-104"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Diagnostics</samp></h3>
<p class="TNI">A conditional inclusion directive may need to generate an error if the preprocessor can’t take any of the conditional branches because no reasonable fallback behavior exists. Consider the example in <a href="chapter9.xhtml#Lis9-2">Listing 9-2</a>, which uses conditional inclusion to select between including the C standard library header <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;threads.h&gt;</samp> or the POSIX threading library header <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;pthread.h&gt;</samp>. If neither option is available, you should alert the programmer porting the system that the code must be repaired.</p>
<span id="Lis9-2"/>
<pre><code>#if __STDC__ &amp;&amp; __STDC_NO_THREADS__ != 1
#  include &lt;threads.h&gt;
#elif POSIX_THREADS == 200809L
#  include &lt;pthread.h&gt;
#else
  int compile_error[-1]; // induce a compilation error
#endif</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: Inducing a compilation error</samp></p>
<p class="TX"><span aria-label="201" epub:type="pagebreak" id="pg_201" role="doc-pagebreak"/>Here, the code generates a diagnostic but doesn’t describe the actual problem. For this reason, C has the <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> preprocessing directive, which causes the implementation to produce a compile-time diagnostic message. You can optionally follow this directive with one or more preprocessor tokens to include in the resulting diagnostic message. Using these, we can replace the erroneous array declaration from <a href="chapter9.xhtml#Lis9-2">Listing 9-2</a> with an <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> directive such as the one shown in <a href="chapter9.xhtml#Lis9-3">Listing 9-3</a>.</p>
<span id="Lis9-3"/>
<pre><code>#if __STDC__ &amp;&amp; __STDC_NO_THREADS__ != 1
#  include &lt;threads.h&gt;
#elif POSIX_THREADS == 200809L
#  include &lt;pthread.h&gt;
#else
#  error "Neither &lt;threads.h&gt; nor &lt;pthread.h&gt; is available"
#endif</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: An</samp> <samp class="I">#error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">directive</samp></p>
<p class="TX">This code generates the following error message if neither threading library header is available:</p>

<pre><code>Neither &lt;threads.h&gt; nor &lt;pthread.h&gt; is available</code></pre>
<p class="TX">In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> directive, C23 added the <samp class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp> directive. This directive is like the <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> directive in that they both cause the implementation to generate a diagnostic. However, instead of terminating compilation, the diagnostic message is generated, and compilation continues as normal (unless other command line options disable the warnings or upgrade them into errors). The <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> directive should be used for <i>fatal</i> problems such as a missing library with no fallback implementation, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp> directive should be used for <i>nonfatal</i> problems such as a missing library with a low-quality fallback implementation.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">

<h3 class="H2" id="sec5"><span id="h2-105"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Header Guards</samp></h3>
<p class="TNI">One problem you’ll encounter when writing headers is preventing programmers from including the same file twice in a translation unit. Given that you can transitively include headers, you could easily include the same header multiple times by accident (possibly even leading to infinite recursion between headers).</p>
<p class="TX"><i>Header guards</i> ensure that a header is included only once per translation unit. A header guard is a design pattern that conditionally includes the contents of a header based on whether a header-specific macro is defined. If the macro is not already defined, you define it so that a subsequent test of the header guard won’t conditionally include the code. In the program shown in <a href="chapter9.xhtml#tab9-4">Table 9-4</a>, <i>bar.h</i> uses a header guard (shown in bold) to prevent its (accidental) duplicate inclusion from <i>foo.c</i>.</p>
<p class="TT" id="tab9-4"><span aria-label="202" epub:type="pagebreak" id="pg_202" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-4:</samp> <samp class="SANS_Futura_Std_Book_11">A Header Guard</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF1"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">bar.h</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">#ifndef BAR_H</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">#define BAR_H</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">inline</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int func() { return 1; }</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">#endif /* BAR_H */</samp></p></td>
<td class="TBL" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">inline</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int func() { return 1; }</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">extern inline int func();</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">int main() {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>
</tr>
<tr>
<td class="TBL1"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#include "bar.h"</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#include "bar.h" // repeated inclusion is</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">                 // usually not this obvious</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">extern inline int func();</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">int main() {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The first time that <samp class="SANS_TheSansMonoCd_W5Regular_11">"bar.h"</samp> is included, the <samp class="SANS_TheSansMonoCd_W5Regular_11">#ifndef</samp> test to see that <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR_H</samp> is not defined will return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. We then define the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR_H</samp> with an empty replacement list, which is sufficient to define <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR_H</samp>, and the function definition for <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp> is included. The second time that <samp class="SANS_TheSansMonoCd_W5Regular_11">"bar.h"</samp> is included, the preprocessor won’t generate any tokens because the conditional inclusion test will return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>. Consequently, <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp> is defined only once in the resulting translation unit.</p>
<p class="TX">A common practice when picking the identifier to use as a header guard is to use the salient parts of the file path, filename, and extension, separated by an underscore and written in all capital letters. For example, if you had a header that would be included with <samp class="SANS_TheSansMonoCd_W5Regular_11">#include "foo/bar/baz.h"</samp>, you might choose <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO_BAR_BAZ_H</samp> as the header guard identifier.</p>
<p class="TX">Some IDEs will automatically generate the header guard for you. Avoid using a reserved identifier as your header guard’s identifier, which could introduce undefined behavior. Identifiers that begin with an underscore followed by a capital letter are reserved. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">_FOO_H</samp> is a reserved identifier and a bad choice for a user-chosen header guard identifier, even if you’re including a file named <i>_foo.h</i>. Using a reserved identifier can result in a collision with a macro defined by the implementation, leading to a compilation error or incorrect code.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">

<h2 class="H1" id="sec6"><span id="h1-82"/><samp class="SANS_Futura_Std_Bold_B_11">Macro Definitions</samp></h2>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> preprocessing directive defines a macro. You can use <i>macros</i> to define constant values or function-like constructs with generic parameters. The macro definition contains a (possibly empty) <i>replacement list</i>—a code pattern that’s injected into the translation unit when the preprocessor expands the macro:</p>

<pre><code><span aria-label="203" epub:type="pagebreak" id="pg_203" role="doc-pagebreak"/>#define <var>identifier</var> <var>replacement-list</var></code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> preprocessing directive is terminated with a newline. In the following example, the replacement list for <samp class="SANS_TheSansMonoCd_W5Regular_11">ARRAY_SIZE</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>:</p>

<pre><code>#define ARRAY_SIZE 100
int array[ARRAY_SIZE];</code></pre>
<p class="TX">Here the <samp class="SANS_TheSansMonoCd_W5Regular_11">ARRAY_SIZE</samp> identifier is replaced by <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>. If no replacement list is specified, the preprocessor simply removes the macro name. You can typically specify a macro definition on your compiler’s command line—for example, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-D</samp> flag in Clang and GCC or the <samp class="SANS_TheSansMonoCd_W5Regular_11">/D</samp> flag in Visual C++. For Clang and GCC, the command line option <samp class="SANS_TheSansMonoCd_W5Regular_11">-DARRAY_SIZE=100</samp> specifies that the macro identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">ARRAY_SIZE</samp> is replaced by <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, producing the same result as the <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> preprocessing directive from the previous example. If you don’t specify the macro replacement list on the command line, compilers will typically provide a replacement list. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">-DFOO</samp> is typically identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">#define FOO 1</samp>.</p>
<p class="TX">The scope of a macro lasts until the preprocessor encounters either an <samp class="SANS_TheSansMonoCd_W5Regular_11">#undef</samp> preprocessing directive specifying that macro or the end of the translation unit. Unlike variable or function declarations, a macro’s scope is independent of any block structure.</p>
<p class="TX">You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> directive to define either an object-like macro or a function-like macro. A <i>function-like</i> macro is parameterized and requires passing a (possibly empty) set of arguments when you invoke it, similar to how you would invoke a function. Unlike functions, macros let you perform operations using the program’s symbols, which means you can create a new variable name or reference the source file and line number at which the macro is being invoked. An <i>object-like</i> macro is a simple identifier that will be replaced by a code fragment.</p>
<p class="TX"><a href="chapter9.xhtml#tab9-5">Table 9-5</a> illustrates the difference between function-like and object-like macros. <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO</samp> is an object-like macro that is replaced by the tokens <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1)</samp> during macro expansion, and <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR</samp> is a function-like macro that is replaced by the tokens <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(x))</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is whatever parameter is specified when invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR</samp>.</p>
<p class="TT" id="tab9-5"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-5:</samp> <samp class="SANS_Futura_Std_Book_11">Macro Definition</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBL1"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#define FOO (1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp><samp class="SANS_Futura_Std_Book_11">)</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#define BAR(x) (1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(x))</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">int i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO;</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int j</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR(10);</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int k</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR(2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2);</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1);</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int j</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(10));</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int k</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2));</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX"><span aria-label="204" epub:type="pagebreak" id="pg_204" role="doc-pagebreak"/>The opening parenthesis of a function-like macro definition must immediately follow the macro name, with no intervening whitespace. If a space appears between the macro name and the opening parenthesis, the parenthesis simply becomes part of the replacement list, as is the case with the object-like <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO</samp> macro. The macro replacement list terminates with the first newline character in the macro definition. However, you can join multiple source lines with the backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) character followed by a newline to make your macro definitions easier to understand. For example, consider the following definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">cbrt</samp> type-generic macro that computes the cube root of its floating-point argument:</p>

<pre><code>#define cbrt(X) _Generic((X), \
  long double: cbrtl(X),      \
  default: cbrt(X),           \
  float: cbrtf(X)             \
)</code></pre>
<p class="Continued">That definition is equivalent to, but easier to read, than the following:</p>

<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">#define cbrt(X) _Generic((X), long double: cbrtl(X), default: cbrt(X), float: cbrtf(X))</samp></code></pre>
<p class="TX">One danger when defining a macro is you can no longer use the macro’s identifier in the rest of the program without inducing a macro replacement. For example, because of macro expansion, the following invalid program won’t compile:</p>

<pre><code>#define foo (1 + 1)
void foo(int i);</code></pre>
<p class="TX">This is because the tokens the preprocessor receives from the translator result in the following invalid code:</p>

<pre><code>void (1 + 1)(int i);</code></pre>
<p class="TX">You can solve this problem by consistently adhering to an idiom throughout your program, such as defining macro names with all uppercase letters or prefixing all macro names with a mnemonic, as you might find in some styles of Hungarian notation.</p>
<blockquote>
<p class="Note"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><span class="note">Hungarian notation</span> <i>is an identifier-naming convention in which the name of a variable or function indicates its intention or kind and, in some dialects, its type.</i></p>
<p class="TX">After you’ve defined a macro, the only way to redefine it is to invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">#undef</samp> directive for the macro. Once you’ve undefined it, the named identifier no longer represents a macro. For example, the program shown in <a href="chapter9.xhtml#tab9-6">Table 9-6</a> defines a function-like macro, includes a header that uses the macro, and then undefines the macro so that it can be redefined later.</p>
<p class="TT" id="tab9-6"><span aria-label="205" epub:type="pagebreak" id="pg_205" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-6:</samp> <samp class="SANS_Futura_Std_Book_11">Undefining Macros</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF1"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">header.h</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">NAME(first)</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">NAME(second)</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">NAME(third)</samp></p></td>
<td class="TBL" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">enum Names {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  first,</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  second,</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  third,</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">void func(enum Names Name) {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  switch (Name){</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">    case first:</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">    case second:</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">    case third:</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  }</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>
</tr>
<tr>
<td class="TBL1"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">file.c</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">enum Names {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#define NAME(X) X,</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#include "header.h"</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#undef NAME</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">void func(enum Names Name) {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  switch (Name) {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#define NAME(X) case X:</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#include "header.h"</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#undef NAME</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  }</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The first use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp> macro declares the names of enumerators within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Names</samp> enumeration. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp> macro is undefined and then redefined to generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> labels in a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement.</p>
<p class="TX">Undefining a macro is safe even when the named identifier isn’t the name of a macro. This macro definition works regardless of whether <samp class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp> is already defined. To keep examples short, we don’t normally follow this practice in this book.</p>
<section aria-labelledby="sec7" epub:type="division">

<h3 class="H2" id="sec7"><span id="h2-106"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Macro Replacement</samp></h3>
<p class="TNI">Function-like macros look like functions but behave differently. When the preprocessor encounters a macro identifier, it invokes the macro, which expands the identifier to replace it with the tokens from the replacement list, if any, specified in the macro’s definition.</p>
<p class="TX">For function-like macros, the preprocessor replaces all parameters in the replacement list with the corresponding arguments in the macro invocation after expanding them. Any parameter in the replacement list preceded by a <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp> token is replaced with a string literal preprocessing token that contains the text of the argument preprocessing tokens (a process sometimes called <i>stringizing</i>). The <samp class="SANS_TheSansMonoCd_W5Regular_11">STRINGIZE</samp> macro in <a href="chapter9.xhtml#tab9-7">Table 9-7</a> stringizes the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.</p>
<p class="TT" id="tab9-7"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-7:</samp> <samp class="SANS_Futura_Std_Book_11">Stringizing</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBL1"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#define STRINGIZE(x) #x</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">const char *str</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">STRINGIZE(12);</samp></p></td>
<td class="TBFL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">const char *str</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"12";</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX"><span aria-label="206" epub:type="pagebreak" id="pg_206" role="doc-pagebreak"/>The preprocessor also deletes all instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">##</samp> preprocessing token in the replacement list, concatenating the preceding preprocessing token with the following token, which is called <i>token pasting</i>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">PASTE</samp> macro in <a href="chapter9.xhtml#tab9-8">Table 9-8</a> is used to create a new identifier by concatenating <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>, the underscore character (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>), and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>.</p>
<p class="TT" id="tab9-8"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-8:</samp> <samp class="SANS_Futura_Std_Book_11">Token Pasting</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBL1"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#define PASTE(x, y) x ## _ ## y</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int PASTE(foo, bar)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">12;</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int foo_bar</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">12;</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">After expanding the macro, the preprocessor rescans the replacement list to expand additional macros within it. If the preprocessor finds the name of the macro being expanded while rescanning—including the rescanning of nested macro expansions within the replacement list—it won’t expand the name again. Furthermore, if macro expansion results in a fragment of program text that’s identical to a preprocessing directive, that fragment won’t be treated as a preprocessing directive.</p>
<p class="TX">During macro expansion, a repeated parameter name in the replacement list will be replaced multiple times by the argument given in the invocation. This can have surprising effects if the argument to the macro invocation involves side effects, as shown in <a href="chapter9.xhtml#tab9-9">Table 9-9</a>. This problem is explained in detail in CERT C rule PRE31-C, “Avoid side effects in arguments to unsafe macros.”</p>
<p class="TT" id="tab9-9"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-9:</samp> <samp class="SANS_Futura_Std_Book_11">Unsafe Macro Expansion</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBL1"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#define bad_abs(x) (x &gt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0 ? x : -x)</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">int func(int i) {</samp><samp class="SANS_Futura_Std_Book_11">  </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  return bad_abs(i++);</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int func(int i) {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  return (i++</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0 ? i++</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">: -i++);</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">In the macro definition in <a href="chapter9.xhtml#tab9-9">Table 9-9</a>, each instance of the macro parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is replaced by the macro invocation argument <samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp>, causing <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> to be incremented twice in a way that a programmer or reviewer reading the original source code can easily overlook. Parameters like <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in the replacement list, as well as the replacement list itself, should usually be fully parenthesized as in <samp class="SANS_TheSansMonoCd_W5Regular_11">((x) &gt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0 ? (x) : -(x))</samp> to prevent portions of the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> from associating with other elements of the replacement list in unexpected ways.</p>
<p class="TX">GNU <i>statement expressions</i> allow you to use loops, switches, and local variables within an expression. Statement expressions are a nonstandard compiler extension supported by GCC, Clang, and other compilers. Using statement expressions, you can rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">bad_abs(x)</samp> as follows:</p>

<pre><code><span aria-label="207" epub:type="pagebreak" id="pg_207" role="doc-pagebreak"/>#define abs(x) ({               \
  auto x_tmp = x;               \
  x_tmp &gt;= 0 ? x_tmp : x_tmp;   \
})</code></pre>
<p class="TX">You can safely invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">abs(x)</samp> macro with side-effecting operands.</p>
<p class="TX">Another potential surprise is that a comma in a function-like macro invocation is always interpreted as a macro argument delimiter. The C standard <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT</samp> macro (removed in C23) demonstrates the danger (<a href="chapter9.xhtml#tab9-10">Table 9-10</a>).</p>
<p class="TT" id="tab9-10"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-10:</samp> <samp class="SANS_Futura_Std_Book_11">The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT</samp> <samp class="SANS_Futura_Std_Book_11">Macro</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF1"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">stdatomic.h</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#define ATOMIC_VAR_INIT(value) (value)</samp></p></td>
<td class="TBL" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;error&gt;</samp></p></td>
</tr>
<tr>
<td class="TBL1"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#include &lt;stdatomic.h&gt;</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">struct S {</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">  int x, y;</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp></p>
<p class="TBS"><samp class="SANS_TheSansMonoCd_W5Regular_11">Atomic struct S val</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT({1, 2});</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">This code fails to translate because the comma in <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT({1, 2})</samp> is treated as a function-like macro argument delimiter, causing the preprocessor to interpret the macro as having two syntactically invalid arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">{1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">2}</samp> instead of a single valid argument <samp class="SANS_TheSansMonoCd_W5Regular_11">{1, 2}</samp>. This usability issue is one of the reasons the <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT</samp> macro was deprecated in C17 and removed in C23.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">

<h3 class="H2" id="sec8"><span id="h2-107"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type-Generic Macros</samp></h3>
<p class="TNI">The C programming language doesn’t allow you to overload functions based on the types of the parameters passed to the function, as you can in other languages such as Java and C++. However, you might sometimes need to alter the behavior of an algorithm based on the argument types. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</samp> has three <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp> functions (<samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sinf</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp>) because each of the three floating-point types (<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>, respectively) has a different precision. Using generic selection expressions, you can define a single function-like identifier that delegates to the correct underlying implementation based on the argument type when called.</p>
<p class="TX">A <i>generic selection expression</i> maps the type of its unevaluated operand expression to an associated expression. If none of the associated types match, it can optionally map to a default expression. You can use <i>type-generic macros</i> (macros that include generic selection expressions) to make your code more readable. In <a href="chapter9.xhtml#tab9-11">Table 9-11</a>, we define a type-generic macro to select the correct variant of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp> function from <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</samp>.</p>
<p class="TT" id="tab9-11"><span aria-label="208" epub:type="pagebreak" id="pg_208" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-11:</samp> <samp class="SANS_Futura_Std_Book_11">A Generic Selection Expression as a Macro</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">_Generic</samp> <samp class="SANS_Futura_Std_Heavy_B_11">resolution</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF1"><pre class="pre0"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">#define singen(X) _Generic((X), \</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">  float: sinf,                  \</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">  double: sin                   \</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">  long double: sinl             \</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">)(X)</samp>

<samp class="SANS_TheSansMonoCd_W5Regular_11">int main() {</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">  printf("%f, %Lf\n",</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">    singen(3.14159),</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">    singen(1.5708L)</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">  );</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></code></pre></td>
<td class="TBL"><pre class="pre0"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">int main() {</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">  printf("%f, %Lf\n",</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">    sin(3.14159),</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">    sinl(1.5708L)   </samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">);</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></code></pre></td>
</tr>
</tbody>
</table>
<p class="TX">The controlling expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(X)</samp> of the generic selection expression is unevaluated; the type of the expression selects a function from the list of <samp class="SANS_TheSansMonoCd_W5Regular_11">type : expr</samp> mappings. The generic selection expression picks one of these function designators (either <samp class="SANS_TheSansMonoCd_W5Regular_11">sinf</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp>) and then executes it. In this example, the argument type in the first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, so the generic selection resolves to <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>, and the argument type in the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>, so this resolves to <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp>. Because this generic selection expression has no <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> association, an error occurs if the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">(X)</samp> doesn’t match any of the associated types. If you include a default association for a generic selection expression, it will match every type not already used as an association, including types you might not expect, such as pointers or structure types.</p>
<p class="TX">Type-generic macro expansion can be difficult to use when the resulting value type depends on the type of an argument to the macro, as with the <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp> example in <a href="chapter9.xhtml#tab9-11">Table 9-11</a>. For instance, it can be a mistake to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp> macro and assign the result to an object of a specific type or pass its result as an argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> because the necessary object type or format specifier will depend on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sinf</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp> is called. You can find examples of type-generic macros for math functions in the C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;tgmath.h&gt;</samp> header.</p>
<p class="TX">C23 partially addressed this problem with the introduction of automatic type inference using the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> type specifier, described in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>. Consider using automatic type inference when initializing an object with a type-generic macro to avoid unintentional conversions on initialization. For example, the following file scope definitions</p>

<pre><code>static auto a = sin(3.5f);
static auto p = &amp;a;</code></pre>
<p class="Continued">are interpreted as if they had been written as:</p>

<pre><code>static float a = sinf(3.5f);
static float *p = &amp;a;</code></pre>
<p class="Continued">Effectively, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is a float and <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is a float <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>.</p>
<p class="TX"><span aria-label="209" epub:type="pagebreak" id="pg_209" role="doc-pagebreak"/>In <a href="chapter9.xhtml#tab9-12">Table 9-12</a>, we replace the types of the two variables declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> from <a href="chapter9.xhtml#tab9-11">Table 9-11</a> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> type specifier. This makes it easier to invoke a type-generic macro, although it is not strictly necessary as the programmer can also deduce the types. The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> type specifier is useful when invoking a type-generic function-like macro where the type of the resulting value depends on a macro parameter to avoid accidental type conversion on initialization.</p>
<p class="TT" id="tab9-12"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-12:</samp> <samp class="SANS_Futura_Std_Book_11">Type-Generic Macros with Automatic Type Inference</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">_Generic</samp> <samp class="SANS_Futura_Std_Heavy_B_11">resolution</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF1"><pre class="pre0"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">#define singen(X) _Generic((X), \</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">  float: sinf,                  \</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">  double: sin,                  \</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">  long double: sinl             \</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">)(X)</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">auto f</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">singen(1.5708f);</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">auto d</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">singen(3.14159);</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></code></pre></td>
<td class="TBL"><pre class="pre0"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">  auto f</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sinf(1.5708f);</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">  auto d</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sin(3.14159);</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></code></pre></td>
</tr>
</tbody>
</table>
<p class="TX">You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> type specifier for declaring variables in type-generic macros where you don’t know the type of the arguments.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">

<h3 class="H2" id="sec9"><span id="h2-108"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Embedded Binary Resources</samp></h3>
<p class="TNI">You may find that you need to dynamically load digital resources, such as images, sounds, video, text files, or other binary data, at runtime. It may instead be beneficial to load those resources at compile time so they can be stored as part of the executable rather than dynamically loaded.</p>
<p class="TX">Prior to C23, there were two common approaches to embedding binary resources into your program. For limited amounts of binary data, the data could be specified as an initializer for a constant-size array. However, for larger binary resources, this approach could introduce significant compile-time overhead, so the use of a linker script or other postprocessing was necessary to keep compile times reasonable.</p>
<p class="TX">C23 added the <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> preprocessor directive to embed a digital resource directly into source code as if it were a comma-delimited list of integer constants. The new directive allows an implementation to optimize for better compile time efficiency when using the embedded constant data as an array initializer. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp>, the implementation does not need to parse each integer constant and comma token separately; it can inspect the bytes directly and use a more efficient mapping of the resource.</p>
<p class="TX"><a href="chapter9.xhtml#tab9-13">Table 9-13</a> shows an example of embedding the binary resource <i>file.txt</i> as the initializer for the <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp> array declaration. For this example, <i>file.txt</i> contains the ASCII text <samp class="SANS_TheSansMonoCd_W5Regular_11">meow</samp> to keep the code listing short. Significantly larger binary resources are typically embedded.</p>
<p class="TT" id="tab9-13"><span aria-label="210" epub:type="pagebreak" id="pg_210" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-13:</samp> <samp class="SANS_Futura_Std_Book_11">Embedding Binary Resources</samp></p>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBL1"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char buffer[]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">#embed &lt;file.txt&gt;</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char buffer[]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">109, 101, 111, 119</samp></p>
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Like <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>, the filename specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> directive can be listed within either angle brackets or double quotes. Unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>, there is no notion of <i>system</i> or <i>user</i> embedded resources, so the only difference between the two forms is that the double-quoted form will start searching for the resource from the same directory as the source file before trying other search paths. Compilers have a command line option to specify search paths for embedded resources; see your compiler documentation for more details.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> directive supports several parameters to control what data is embedded into the source file: <samp class="SANS_TheSansMonoCd_W5Regular_11">limit</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">suffix</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">prefix</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">if_empty</samp>. The most useful of those parameters is the <samp class="SANS_TheSansMonoCd_W5Regular_11">limit</samp> parameter, which specifies how much data to embed (in bytes). This can be helpful if the only data needed at compile time is in the header of the file or if the file is an <i>infinite</i> resource like <i>/dev/urandom</i> in some operating systems. The <samp class="SANS_TheSansMonoCd_W5Regular_11">prefix</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">suffix</samp> parameters insert tokens before or after the embedded resource, respectively, if the resource is found and is not empty. The <samp class="SANS_TheSansMonoCd_W5Regular_11">if_empty</samp> parameter inserts tokens if the embedded resource is found but has no content (including when the <samp class="SANS_TheSansMonoCd_W5Regular_11">limit</samp> parameter is explicitly set to 0).</p>
<p class="TX">Like <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>, you can test whether an embedded resource can be found using the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_embed</samp> preprocessor operator. This operator returns:</p>
<ul class="ul">
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_EMBED_FOUND__</samp> if the resource can be found and isn’t empty</li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_EMBED_EMPTY__</samp> if the resource can be found and is empty</li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_EMBED_NOT_FOUND__</samp> if the resource cannot be found</li>
</ul>
</section>
<section aria-labelledby="sec10" epub:type="division">

<h3 class="H2" id="sec10"><span id="h2-109"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Predefined Macros</samp></h3>
<p class="TNI">The implementation defines some macros without requiring you to include a header. These macros are called <i>predefined macros</i> because they’re implicitly defined by the preprocessor rather than explicitly defined by the programmer. For example, the C standard defines various macros that you can use to interrogate the compilation environment or provide basic functionality. Some other aspects of the implementation (such as the compiler or the compilation target operating system) also automatically define macros. <a href="chapter9.xhtml#tab9-14">Table 9-14</a> lists some of the common macros the C standard defines. You can obtain a full list of predefined macros from Clang or GCC by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">-E -dM</samp> flags to those compilers. Check your compiler documentation for more information.</p>
<p class="TT" id="tab9-14"><span aria-label="211" epub:type="pagebreak" id="pg_211" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-14:</samp> <samp class="SANS_Futura_Std_Book_11">Predefined Macros</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Macro name</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Replacement and purpose</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__DATE__</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">A string literal of the date of translation of the preprocessing translation unit in the form</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Mmm dd yyyy</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__TIME__</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">A string literal of the time of translation for the preprocessing translation unit in the form</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">hh:mm:ss</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__FILE__</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">A string literal representing the presumed filename of the current source file.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__LINE__</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">An integer constant representing the presumed line number of the current source line.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC__</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation conforms to the C standard.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_HOSTED__</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation is a hosted implementation or the integer constant 0 if it is stand-alone. This macro is conditionally defined by the implementation.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_VERSION__</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The integer constant representing the version of the C standard the compiler is targeting, such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">202311L</samp> <samp class="SANS_Futura_Std_Book_11">for the C23 standard.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The integer constant 1 if values of type</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> <samp class="SANS_Futura_Std_Book_11">are UTF-16</samp> <samp class="SANS_Futura_Std_Book_11">encoded. This macro is conditionally defined by the</samp> <samp class="SANS_Futura_Std_Book_11">implementation.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The integer constant 1 if values of type</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> <samp class="SANS_Futura_Std_Book_11">are UTF-32</samp> <samp class="SANS_Futura_Std_Book_11">encoded. This macro is conditionally defined by the</samp> <samp class="SANS_Futura_Std_Book_11">implementation.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_ATOMICS__</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation doesn’t support atomic types, including the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">_Atomic</samp> <samp class="SANS_Futura_Std_Book_11">type qualifier, and the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdatomic.h&gt;</samp> <samp class="SANS_Futura_Std_Book_11">header. This macro is conditionally defined by the implementation.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_COMPLEX__</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation doesn’t support complex types or the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;complex.h&gt;</samp> <samp class="SANS_Futura_Std_Book_11">header. This macro is conditionally defined by the implementation.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_THREADS__</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation doesn’t support the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;threads.h&gt;</samp> <samp class="SANS_Futura_Std_Book_11">header. This macro is conditionally defined by the implementation.</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_VLA__</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation doesn’t support variable-length arrays. This macro is conditionally defined by the implementation.</samp></p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">

<h2 class="H1" id="sec11"><span id="h1-83"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI">In this chapter, you learned about some of the features provided by the preprocessor. You learned how to include fragments of program text in a translation unit, conditionally compile code, embed binary resources into your program, and generate diagnostics on demand. You then learned how <span aria-label="212" epub:type="pagebreak" id="pg_212" role="doc-pagebreak"/>to define and undefine macros, how macros are invoked, and about macros that are predefined by the implementation. The preprocessor is popular in C language programming but shunned in C++ programming. Use of the preprocessor can be error prone, so it is best to follow the recommendations and rules from <i>The CERT C Coding Standard</i>.</p>
<p class="TX">In the next chapter, you’ll learn how to structure your program into more than one translation unit to create more maintainable programs.</p>
</section>
</section>
</body></html>