<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_317" aria-label="317"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch14">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">14</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">HEAPS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In the last chapter, we worked with binary trees, and we’ll continue doing so in this chapter, but with a variant that is stored without the need for dynamic memory: heaps. Heaps allow for easy implementation of a new abstract data type (ADT), a good performance sorting method, and a new structure for an enhanced version of binary search trees. We’ll consider implementing heaps (in particular, binary max heaps, but other types too), and we’ll look at using heaps for priority queues, sorting arrays with heapsort, and searching with another new structure called treaps<i>.</i></p>&#13;
<p class="TX">In the next chapter, we’ll follow with another representation for heaps that uses dynamic memory and allows for more freedom and better performance for some new operations.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_318" aria-label="318"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-68"/><span class="SANS_Futura_Std_Bold_B_11">Binary</span> <span class="SANS_Futura_Std_Bold_B_11">Heaps</span></h3>&#13;
<p class="TNI1">A <i>binary heap</i>, usually referred to simply as a <i>heap</i>, is a type of binary tree with two particular properties: a <i>structure property</i> that determines the shape of the tree and a <i>heap property</i> that specifies the relationship between the key of a parent node and those of its children.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-116"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">The Structure Property</span></h4>&#13;
<p class="TNI1">Heaps are a subset of binary trees, and the structure property requires that the tree must be complete and that all leaves on the last level must be located on the left. Consider the trees in <a href="chapter14.xhtml#fig14-1">Figure 14-1</a>. Only one qualifies as a heap while the other two fail. Can you tell which is which?</p>&#13;
<figure class="IMG"><img class="img1" id="fig14-1" src="../images/Figure14-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-1: Of these three heap candidates, which is the right one?</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The tree on the left in <a href="chapter14.xhtml#fig14-1">Figure 14-1</a> is the only heap. The tree in the middle has an incomplete middle level, and in the tree on the right, the bottom children are not all on the left.</p>&#13;
<p class="TX">Given this rule, you can store a heap in a common array without dynamic memory or pointers to simplify implementation. (See question 14.18 to consider an alternative.) Place the root at the first position of the array, followed by the nodes at the second level from left to right, then the nodes at the third level (also from left to right), and so on. <a href="chapter14.xhtml#fig14-2">Figure 14-2</a> shows how the array looks for a sample case. The numbers in the nodes correspond to indices in the array.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-2" src="../images/Figure14-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-2: Storing a heap’s nodes in an array</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this representation, the heap’s root is always at position 0. The left and right children of the node at position <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> are placed in consecutive adjacent positions, <span class="SANS_TheSansMonoCd_W5Regular_11">2*p+1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">2*p+2</span>, respectively—unless they fall beyond the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_319" aria-label="319"/>end of the heap, in which case the node has fewer children. The parent of a non-root node at position <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> is found at the <span class="SANS_TheSansMonoCd_W5Regular_11">Math.floor((p-1)/2)</span> position.</p>&#13;
<p class="TX">You can verify those rules with a few examples. The children of the root (at position 0) are at positions <span class="SANS_TheSansMonoCd_W5Regular_11">2*0</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+ 1=1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">2*0</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+ 2=2</span>. Node 4 has a single child at position <span class="SANS_TheSansMonoCd_W5Regular_11">2*4</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+ 1=9</span>, because the other child would be beyond the heap size. The parent of node 9 is at position <span class="SANS_TheSansMonoCd_W5Regular_11">Math.floor((9-1)/2)=4</span>. The parent of node 2 is at position <span class="SANS_TheSansMonoCd_W5Regular_11">Math.floor((2-1)/2)=1</span>.</p>&#13;
<p class="TX">These rules let you implement algorithms without needing any pointers; a simple array suffices. As with complete trees in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, if a heap has up to <i>n</i> = 2<i><sup>h</sup></i><sup>–1</sup> nodes, its height will be <i>h</i>, so its height is bounded by log <i>n</i>, a result that will feature in order calculations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-117"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">The Heap Property</span></h4>&#13;
<p class="TNI1">The second property of heaps is simple: the key of a node must be greater than or equal to the keys of its children. This is an important contrast from binary search trees: in heaps, there’s no difference between a left child and a right child (either could be greater than the other), although they both will be smaller than or equal to their parent. Any tree that follows both the structure property and the heap property is called a <i>binary max heap</i> or, more simply, a <i>heap</i>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Why do I say the word heap means “max heap” by default? The song “New York, New York” may give us a clue: Frank Sinatra describes wanting to be “king of the hill” or “top of the heap.” This suggests the root (top) of the heap should be the greatest value, doesn’t it?</i></p>&#13;
<p class="TX">You can reverse the condition and specify that the parent’s key be smaller than or equal to those of its children, meaning the root would be the minimum value of the heap. This variant is called a <i>min heap</i>, and you can use it (among other scenarios) to merge several linked lists, which requires finding the minimum of many elements repeatedly (see question 14.5). The heap shown in <a href="chapter14.xhtml#fig14-3">Figure 14-3</a> satisfies both the structure and heap properties.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-3" src="../images/Figure14-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-3: A valid heap</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As mentioned previously, this tree also could be represented by an array where 60 (the root) is at position 0 of the array, as shown in <a href="chapter14.xhtml#fig14-4">Figure 14-4</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_320" aria-label="320"/>&#13;
<figure class="IMG"><img class="img5" id="fig14-4" src="../images/Figure14-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-4: The same heap shown in <a href="chapter14.xhtml#fig14-3">Figure 14-3</a>, as stored in an array</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The heap property has an immediate consequence: the highest value in the heap will necessarily be at its root; can you see why? Where in the heap will you find its second highest value? The third highest? The fourth? (See question 14.13.) This result will be key for a sorting algorithm called <i>heapsort</i>, which we’ll study later in this chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-118"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Heap Implementation</span></h4>&#13;
<p class="TNI1">To implement a heap, you need only a simple array. A heap is a data structure with a few operations, as shown in <a href="chapter14.xhtml#tab14-1">Table 14-1</a>.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab14-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 14-1:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Heaps</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">H</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new heap.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">H</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Determine whether the heap is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">H</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">key</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a heap, produce its top value.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">H × key</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">H</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a new value, add it to the heap.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">H</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">H × key</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a heap, extract its top value and update the structure correspondingly.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The functions you’ll implement for those operations are:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>newHeap() </b>Creates a new heap</p>&#13;
<p class="RunInPara"><b>isEmpty(heap) </b>Determines whether the heap is empty</p>&#13;
<p class="RunInPara"><b>top(heap) </b>Gets the value of the topmost (maximum) element of the heap</p>&#13;
<p class="RunInPara"><b>add(heap, value) </b>Adds a new element to the heap</p>&#13;
<p class="RunInPara"><b>remove(heap) </b>Removes the topmost element of the heap</p>&#13;
</div>&#13;
<p class="TX">The first three functions are very short:</p>&#13;
<pre id="pre-272"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const newHeap = () =&gt; [];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const isEmpty = (heap) =&gt; heap.length === 0;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const top = (heap) =&gt; {&#13;
  if (isEmpty(heap)) {&#13;
    return undefined;&#13;
  } else {&#13;
    return heap[0];&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_321" aria-label="321"/>Creating a new empty heap is the same as returning an empty array <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The size of the heap is <span class="SANS_TheSansMonoCd_W5Regular_11">heap.length</span>, so checking it for <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> tells you whether the heap is empty <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Also, the top of the heap (unless the heap is empty, in which case this code returns <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>) is at the first position of the array <span class="CodeAnnotation" aria-label="annotation3">❸</span>, so the implementation details are straightforward.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h5 class="H3" id="sec5"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding to a Heap</span></h5>&#13;
<p class="TNI1">To add a new value to the heap, follow these steps:</p>&#13;
<p class="ListNumberF">	1.	Add the new value at the end of the array.</p>&#13;
<p class="ListNumber">	2.	If the value is greater than its parent, exchange places with it repeatedly.</p>&#13;
<p class="ListNumberL">	3.	When the value is smaller than its parent or when it gets to the top of the heap, stop.</p>&#13;
<p class="TX">Let’s see how this works. Start with the heap shown in <a href="chapter14.xhtml#fig14-5">Figure 14-5</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-5" src="../images/Figure14-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-5: An initial</span> <span class="SANS_Futura_Std_Book_Oblique_11">heap, before adding a new value</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you want to insert a new value of 56, the first step is to add it at the end of the heap, so you’d get the result shown in <a href="chapter14.xhtml#fig14-6">Figure 14-6</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-6" src="../images/Figure14-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-6: The new value (56) starts at the end of the heap.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Let’s see if the new value should bubble up. Comparing 56 with its parent (24) shows that they need to be swapped, resulting in a new heap configuration (see <a href="chapter14.xhtml#fig14-7">Figure 14-7</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_322" aria-label="322"/>&#13;
<figure class="IMG"><img class="img5" id="fig14-7" src="../images/Figure14-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-7: If the new value is greater than its parent, it has to “bubble” up.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After bubbling up, keep checking recursively, and a new upward movement is required (see <a href="chapter14.xhtml#fig14-8">Figure 14-8</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-8" src="../images/Figure14-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-8: Bubbling up continues until the added value is not greater than its parent or at the root of the heap.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The last step led to a situation where the inserted value is not greater than its parent, so the algorithm stops.</p>&#13;
<p class="TX">Our version of <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> is short and to the point:</p>&#13;
<pre id="pre-273"><code>const add = (heap, keyToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> heap.push(keyToAdd);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> _bubbleUp(heap, heap.length – 1);&#13;
  return heap;&#13;
};</code></pre>&#13;
<p class="TX">As described, the new value was added at the end of the heap <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and it was forced to bubble up to its final position <span class="CodeAnnotation" aria-label="annotation2">❷</span> by using the <span class="SANS_TheSansMonoCd_W5Regular_11">_bubbleUp()</span> auxiliary function.</p>&#13;
<p class="TX">As before, a recursive implementation is easiest. If the element has moved up, apply <span class="SANS_TheSansMonoCd_W5Regular_11">_bubbleUp()</span> recursively to keep it moving:</p>&#13;
<pre id="pre-274"><code>const _bubbleUp = (heap, i) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (i &gt; 0) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const p = Math.floor((i - 1) / 2);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (heap[i] &gt; heap[p]) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> [heap[p], heap[i]] = [heap[i], heap[p]];&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_323" aria-label="323"/>    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> _bubbleUp(heap, p);&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the element is not already at the top of the heap <span class="CodeAnnotation" aria-label="annotation1">❶</span>, use math (as in <span class="Xref">“The Structure Property”</span> on page <span class="Xref">318</span>) to determine the parent <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> of position <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If you need to swap elements <span class="CodeAnnotation" aria-label="annotation3">❸</span>, destructuring makes it easy <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and you can keep bubbling up (if needed) by using recursion <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h5 class="H3" id="sec6"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing from a Heap</span></h5>&#13;
<p class="TNI1">Next you need the <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> method. Remember that the whole heap must become one element smaller, so what happens after removing the top of the heap? If the heap is empty, there’s nothing to remove; throw an exception, and you’re done. Otherwise, pick the last element of the heap, place it at the top, and then reduce the heap size by one. If the element doesn’t have any children, stop. If the element is greater than the greatest of its children, also stop. Otherwise, exchange the element with its greatest child and keep moving it down.</p>&#13;
<p class="TX">Here is an example of how this works. Start with the heap in <a href="chapter14.xhtml#fig14-9">Figure 14-9</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-9" src="../images/Figure14-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-9: An initial heap before removing its top</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first step involves removing the top value (60), replacing it with the last value in the heap (22), and shortening the heap by one, which leads to the situation shown in <a href="chapter14.xhtml#fig14-10">Figure 14-10</a>. The value that needs to be moved downward to restore the heap is highlighted.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-10" src="../images/Figure14-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-10: After removing the top, replace it with the last element of the heap (22).</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now start sifting down. Comparing 22 with its children, it needs to be swapped with 56, which results in the new situation shown in <a href="chapter14.xhtml#fig14-11">Figure 14-11</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_324" aria-label="324"/>&#13;
<figure class="IMG"><img class="img5" id="fig14-11" src="../images/Figure14-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-11: If the new top isn’t greater than its children, it must “sink” down.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Recursively, compare 22 with its new children, and again, it needs to sink down, as shown in <a href="chapter14.xhtml#fig14-12">Figure 14-12</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-12" src="../images/Figure14-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-12: Sinking down proceeds until the value is greater than its children or reaches a leaf.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this situation, 22 is now greater than its children, so the sinking-down procedure ends. If the value 40 had been a 20, the 22 would have been exchanged with the 24, and the shifting-down procedure would have finished as well, since 22 would have no children.</p>&#13;
<p class="TX">Take a look at the following code, which uses a recursive <span class="SANS_TheSansMonoCd_W5Regular_11">_sinkDown()</span> auxiliary function to push a value down the heap:</p>&#13;
<pre id="pre-275"><code>const _sinkDown = (heap, i, h) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const l = 2 * i + 1;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const r = l + 1;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> let g = i;&#13;
  if (l &lt; h &amp;&amp; heap[l] &gt; heap[g]) {&#13;
    g = l;&#13;
  }&#13;
  if (r &lt; h &amp;&amp; heap[r] &gt; heap[g]) {&#13;
    g = r;&#13;
  }&#13;
  if (g !== i) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> [heap[g], heap[i]] = [heap[i], heap[g]];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> _sinkDown(heap, g, h);&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_325" aria-label="325"/>Calculate <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">r</span>, the children of the parent at <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>; you can use the formula discussed earlier in <span class="Xref">“The Structure Property”</span> section on page <span class="Xref">318</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and find <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> just by adding 1 <span class="CodeAnnotation" aria-label="annotation2">❷</span>, since <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> follows <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> in the array. Use <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> to determine the greatest value at positions <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">l</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the value at <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> isn’t greater than its children, swap it <span class="CodeAnnotation" aria-label="annotation4">❹</span> and keep sinking it down recursively <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">At this point, you can finally write the <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> function:</p>&#13;
<pre id="pre-276"><code>const remove = (heap) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const topKey = top(heap);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (!isEmpty(heap)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> heap[0] = heap[heap.length – 1];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> heap.length--;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> _sinkDown(heap, 0, heap.length);&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> return [heap, topKey];&#13;
};</code></pre>&#13;
<p class="TX">This code closely follows the description in the previous example. When you get the top (which may be undefined, if the heap is empty) <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and if the heap isn’t empty <span class="CodeAnnotation" aria-label="annotation2">❷</span>, place its last value at the top <span class="CodeAnnotation" aria-label="annotation3">❸</span>, reduce the heap’s length by one <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and sink the new top down <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Finally, return the top value and the updated heap <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3" id="sec7"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering Performance for Heaps</span></h5>&#13;
<p class="TNI1"><a href="chapter14.xhtml#tab14-2">Table 14-2</a> shows the performance of the algorithms just explored.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab14-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 14-2:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Heaps</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log n)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log n)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Three operations work in constant time: creating a heap, testing whether it’s empty, and getting the top value. The other two operations, adding and removing, are more complex. Adding an element may make it bubble up from the bottom of the heap all the way up to the top. Since you know that the heap’s height is log <i>n</i>, this operation requires logarithmic time. Similarly, removing an element implies placing a new one at the top and possibly sinking it down to the bottom. It’s the same number of operations as in adding a value, but in reverse (also logarithmic time).</p>&#13;
<p class="TX">Let’s move on to consider a new ADT, and compare the performance of heaps versus the other structures already discussed.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_326" aria-label="326"/>&#13;
<h3 class="H1" id="sec8"><span id="h1-69"/><span class="SANS_Futura_Std_Bold_B_11">Priority Queues and Heaps</span></h3>&#13;
<p class="TNI1"><i>Priority queues (PQs)</i> are different from the queues discussed in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, because each element has an associated priority, which determines what element is removed first. In a PQ, the first element to be removed is the one with the highest priority, not the first one that was added, as in a first in, first out (FIFO) strategy.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>There’s a problem with the English language! The term</i> priority one <i>implies the highest priority, but 1 is the lowest-priority number. If you order tasks by priority and the lowest numbered task is the one you should tackle first, then lower numbers have a higher priority. However, some tools (like Microsoft Project) assume that 0 is the lowest priority and higher numbers are higher priority, so there’s no clear-cut case. Regardless, if you actually need a min heap instead of a max heap, see question 14.4.</i></p>&#13;
<p class="TX">PQs are used in multiple algorithms and many different situations. Operating system schedulers use priorities to select what process will be the next to run. Discrete event simulations decide the next step to apply based on a timestamp (and in this case, lower timestamps equal higher priorities). Dijkstra’s shortest path algorithm (which we’ll consider in <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span>) requires finding the vertex with the minimum distance to another given vertex. Prim’s algorithm for finding a minimum spanning tree for a graph also needs to find the vertex with the smallest (cheapest) connection to another vertex. Huffman’s coding algorithm builds a tree and repeatedly needs to find the two nodes with the smallest probabilities to replace them with a new node with the sum of those probabilities. All of these things require PQs.</p>&#13;
<p class="TX">In terms of an ADT, the description for a PQ then requires the following operations shown in <a href="chapter14.xhtml#tab14-3">Table 14-3</a> (other versions that add more operations are considered later).</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab14-3"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 14-3:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Priority Queues</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">PQ</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new PQ.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">PQ</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Determine whether the PQ is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">PQ</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">key</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a PQ, produce its top value.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">PQ × key</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">PQ</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a new key, add it to a PQ.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">PQ</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">PQ × key</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a PQ, extract its top value and update the PQ correspondingly.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">In terms of the provided operations, a heap matches the requirements of a PQ, so implementation is straightforward. For the sake of variety, though, take a look at other simple ways of implementing PQs and compare their performances:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">With an unordered array or list, getting the top value would be <i>O</i>(<i>n</i>). Removing it would also be <i>O</i>(<i>n</i>), because you have to go through all the values to find it, and adding a new element would be <i>O</i>(1).</li>&#13;
<li class="ListBullet"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_327" aria-label="327"/>With an ordered array (the top value at the last position), getting and removing the top would be <i>O</i>(1), but adding a new element would be <i>O</i>(<i>n</i>); after finding where the element goes, which is <i>O</i>(log <i>n</i>) with binary search, you have to move the elements physically to make space, and that’s <i>O</i>(<i>n</i>).</li>&#13;
<li class="ListBullet">With an ordered list (the top value in the first place), the results are the same as with an ordered array.</li>&#13;
<li class="ListBullet">With a balanced binary search tree, all three operations would be <i>O</i>(log <i>n</i>). If you have an extra pointer to the maximum value, getting the top value becomes <i>O</i>(1), but insertions and deletions will be a tad slower because they have to maintain the added pointer.</li>&#13;
</ul>&#13;
<p class="TX">This list of possible implementations for PQs isn’t complete, but it should be enough to show how the heap is one of the best ways of implementing them, with extra points for low complexity. In the following chapter, we’ll consider some extra operations you may need, which will lead to other implementations of PQs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-70"/><span class="SANS_Futura_Std_Bold_B_11">Heapsort</span></h3>&#13;
<p class="TNI1">Heaps can be used to create a well-performing sorting method. Given a set of values, with a heap, you can easily find the highest value of the set. After removing it and restoring the heap, you can find the second-highest value of the set, and so on. The basic algorithm structure is as follows:</p>&#13;
<p class="ListNumberF">	1.	Build a heap out of the values to be sorted.</p>&#13;
<p class="ListNumberL">	2.	Then, until no more values are left, swap the heap’s top element with its last, reduce the heap size by one, and restore the heap condition.</p>&#13;
<p class="TX">Take a look at how this algorithm works and then consider an enhancement.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-119"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Williams’ Original Heapsort</span></h4>&#13;
<p class="TNI1">First, here is an example implementation of the heapsort algorithm, invented by John W. J. Williams in 1964. You can reuse the <span class="SANS_TheSansMonoCd_W5Regular_11">_bubbleUp()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">_sinkDown()</span> functions from earlier without any change (so I won’t list them here), and what’s added is just the following:</p>&#13;
<pre id="pre-277"><code>function heapsort_original(v) {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> for (let i = 1; i &lt; v.length; i++) {&#13;
    _bubbleUp(v, i);&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> for (let i = v.length - 1; i &gt; 0; i--) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> [v[i], v[0]] = [v[0], v[i]];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> _sinkDown(v, 0, i);&#13;
  }&#13;
&#13;
  return v;&#13;
}</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_328" aria-label="328"/>The first stage of heapsort goes from the beginning to the end of the array, making each element bubble up to its correct place <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The second stage <span class="CodeAnnotation" aria-label="annotation2">❷</span> swaps the top element with the last one of the (current) heap <span class="CodeAnnotation" aria-label="annotation3">❸</span> and sinks it down, using the second argument to <span class="SANS_TheSansMonoCd_W5Regular_11">_sinkDown()</span> to limit how far it can sink <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Here is the algorithm in action. The building phase goes through the stages shown in <a href="chapter14.xhtml#fig14-13">Figure 14-13</a>. The highlighted area corresponds to the heap that’s being built, and the rest are the values that haven’t yet been added to the heap.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-13" src="../images/Figure14-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-13: The first phase of</span> <span class="SANS_Futura_Std_Book_Oblique_11">heapsort is to build up the heap (highlighted area) one value at a time.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In every step of the algorithm, a new value is added to the heap as it is so far, bubbling up as needed, until you get a heap with one more element than before. After the building phase is done, the second part of the algorithm starts. The top element of the heap is swapped with the last value of the heap, which shrinks down in size by one, and the new value at the top sinks down to restore the heap, as shown in <a href="chapter14.xhtml#fig14-14">Figure 14-14</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-14" src="../images/Figure14-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-14: In the second phase of heapsort, the top value is repeatedly removed to build up the sorted array.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_329" aria-label="329"/>In the first step, the top value (60) is exchanged with the last value of the heap (11). The 11 sinks down, and 56 moves up to the top. In the next step, 56 is exchanged with the last value (again 11), and 11 sinks down as 40 goes to the top. This continues step by step, and when the heap is at size 1, the array is sorted.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-120"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Heapsort Analysis</span></h4>&#13;
<p class="TNI1">What’s the order of heapsort? Without going too deep into mathematical details, if you are sorting <i>n</i> items, you call the <span class="SANS_TheSansMonoCd_W5Regular_11">_bubbleUp()</span> function <i>n</i> times, and each time, an element may bubble up to the top of the heap, which is log <i>n</i> high, so that’s <i>O</i>(<i>n</i> log <i>n</i>). Similarly, when removing elements from the heap to produce the ordered array, call <span class="SANS_TheSansMonoCd_W5Regular_11">_sinkDown()</span> <i>n</i> times, and elements may sink down to the bottom of the heap, so that’s <i>O</i>(<i>n</i> log <i>n</i>) again; the conclusion is that the algorithm is <i>O</i>(<i>n</i> log <i>n</i>).</p>&#13;
<p class="TX">An interesting property is that this behavior is guaranteed. No set of data will lead to a worse case, as in quicksort, which could become <i>O</i>(<i>n</i><sup>²</sup>). Also, since we’ve established that <i>O</i>(<i>n</i> log <i>n</i>) is the best possible order for comparison-based sorting algorithms, you can see that heapsort is a solid algorithm with consistent performance, often used in libraries and in other algorithms that may require sorting.</p>&#13;
<p class="TX">Finally, heapsort isn’t a stable sort in the sense shown in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> (see question 14.12 for an example).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-121"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Floyd’s Heap-Building Enhancement</span></h4>&#13;
<p class="TNI1">Williams’ version of the algorithm is quite efficient, but a possible enhancement, thanks to Robert Floyd, speeds up the heap-building part to O(<i>n</i>), although we won’t go into the math here. The reason for this result is that most of the elements are near the bottom, so sinking them down is much faster than bubbling them up. Very few are near the top, where sinking them is slower than bubbling up, all of which is enough to change the order of heap building. Since the second part of the procedure is still <i>O</i>(<i>n</i> log <i>n</i>), the algorithm’s total order won’t change, but it will run faster in any case.</p>&#13;
<p class="TX">Instead of making each element bubble up to its position, the algorithm builds small heaps, which are then made larger by joining them together, until you get the complete heap. Initially, you can consider all the leaves of the tree to be small one-sized heaps. Then, take two leaves and their parent and reorganize them (if needed) so that those three values form a heap. Keep doing this, and eventually, you’ll get to the top of the heap and be done.</p>&#13;
<p class="TX">Take a look at the code first and then at an example. The code for this new heapsort version will depend on the previous <span class="SANS_TheSansMonoCd_W5Regular_11">_sinkDown()</span> code, which you’ll use unchanged. The rest of the algorithm is as follows:</p>&#13;
<pre id="pre-278"><code>function heapsort_enhanced(v) {&#13;
<b>  for (let i = Math.floor((v.length - 1) / 2); i &gt;= 0; i--) {</b>&#13;
<b>    _sinkDown(v, i, v.length);</b>&#13;
<b>  }</b>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_330" aria-label="330"/>  for (let i = v.length - 1; i &gt; 0; i--) {&#13;
    [v[i], v[0]] = [v[0], v[i]];&#13;
    _sinkDown(v, 0, i);&#13;
  }&#13;
  return v;&#13;
}</code></pre>&#13;
<p class="TX">The code for the second part of the algorithm (exchanging and restructuring) is the same; the only difference is where you build up the heap using <span class="SANS_TheSansMonoCd_W5Regular_11">_sinkDown()</span>. <a href="chapter14.xhtml#fig14-15">Figure 14-15</a> shows just the heap-building part of this code in action—specifically, how more parts of the array successively become a heap. At each step, the part of the array that becomes a “mini heap” is highlighted.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-15" src="../images/Figure14-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-15: The enhanced heap-building algorithm creates the heap out of smaller, previously created ones.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To better understand <a href="chapter14.xhtml#fig14-15">Figure 14-15</a>, look at the heap at different stages. Initially, the array looks like <a href="chapter14.xhtml#fig14-16">Figure 14-16</a> and obviously isn’t a heap.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-16" src="../images/Figure14-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-16: An initial array, which doesn’t fulfill the</span> <span class="SANS_Futura_Std_Book_Oblique_11">heap property</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After two steps, subheaps out of 11 and 24 are built (which were left as they were) as well as 12, 34, and 56 (where 34 sifted down and 56 took its place).</p>&#13;
<p class="TX"><a href="chapter14.xhtml#fig14-17">Figure 14-17</a> shows two more steps.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_331" aria-label="331"/>&#13;
<figure class="IMG"><img class="img5" id="fig14-17" src="../images/Figure14-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-17: After some rotations, a few subheaps are built.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The heap is practically done with root 56 (the 22 value sank down and 56 took its place) and another with root 60 (where no changes were needed). You are just one step away from finishing, as shown in <a href="chapter14.xhtml#fig14-18">Figure 14-18</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-18" src="../images/Figure14-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-18: More and more subheaps are built, reaching to the top.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The last step completes the heap; the 9 value sinks down to its place, being replaced by 60. <a href="chapter14.xhtml#fig14-19">Figure 14-19</a> shows the finished heap.</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-19" src="../images/Figure14-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-19: Upon reaching the top, the array has become a heap.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Floyd’s enhanced algorithm has two advantages: a faster first phase (the second phase, which generates the sorted result, is the same) and shorter code. You can take advantage of this method for your heap logic and modify the <span class="SANS_TheSansMonoCd_W5Regular_11">newHeap()</span> function (see question 14.8).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_332" aria-label="332"/>&#13;
<h3 class="H1" id="sec13"><span id="h1-71"/><span class="SANS_Futura_Std_Bold_B_11">Treaps</span></h3>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, we discussed binary search trees and several ways to try to keep them balanced in order to avoid slow searches. In 1989, a new structure was invented that mixes the characteristics of trees and heaps: treaps. These trees are balanced, although their heights are not guaranteed to be <i>O</i>(log <i>n</i>); rather, randomization and the heap property are used to maintain balance with high probability.</p>&#13;
<p class="TX">The (invented) term <i>treap</i> is a portmanteau of the words <i>tree</i> and <i>heap</i>. How does this mix come about? Basically, every key is associated with a random priority, and when you build the binary search tree, take care to satisfy the heap property, so a parent node always will have a priority greater than those of its children. (The structure property will not be satisfied; nodes are linked by pointers, not an array.) Note that instead of using a random number generator, you can apply a hash function to the key, and thus produce its “random” priority. Mathematical analysis of treaps depends on truly random numbers, but the form of randomness generated by hashing also works. And in terms of testing algorithms, hashing has the advantage of determinacy.</p>&#13;
<p class="TX">Let’s think about this a bit more. If you happened to order the keys by priority and insert them in the tree in decreasing order of priority, the resulting tree would satisfy the heap property. (Can you see why?) This means that assigning random priorities is equivalent to taking a random permutation of the keys before inserting them in the tree, which will probabilistically provide a good shape for the resulting tree, with an expected height that is <i>O</i>(log <i>n</i>), as with balanced trees.</p>&#13;
<p class="TX">Given a set of distinct keys and their corresponding (also distinct) priorities, the resulting treap is unique, and we can construct a recursive proof for this. First, the root of the treap must be the key with the highest priority. Then, all the smaller keys will go into the root’s left subtree and the greater keys will go into the right subtree, and we can apply the same reasoning recursively to prove that those two subtrees will also be unique.</p>&#13;
<p class="TX">You can also modify the binary search tree algorithms from <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span> to create treaps. The code is simpler than code for AVL or red-black trees, yet it provides competitive performance, often better than that of its more complex alternatives.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-122"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Creating and Searching a Treap</span></h4>&#13;
<p class="TNI1">Given that treaps are just binary search trees at heart, most of the code discussed in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span> will still work. Start coding treaps as follows:</p>&#13;
<pre id="pre-279"><code>const {&#13;
  find,&#13;
  inOrder,&#13;
  isEmpty,&#13;
  maxKey,&#13;
  minKey,&#13;
  postOrder,&#13;
  preOrder&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_333" aria-label="333"/><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>} = require("../binary_trees/binary_search_tree.func.js");&#13;
&#13;
const newTreap = () =&gt; null;&#13;
&#13;
const newNode = (key) =&gt; ({&#13;
  key,&#13;
  left: null,&#13;
  right: null,&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> <b>priority: Math.random()</b>&#13;
});</code></pre>&#13;
<p class="TX">The treap is based on the previous binary search tree <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and many of the functions written there are still valid. When creating a new node, add a random priority <span class="CodeAnnotation" aria-label="annotation2">❷</span>, but that’s all that will change here.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you want to test your code and need deterministic results, you could compute priority as a hash of the key; as long as the results are random enough, it will do.</i></p>&#13;
<p class="TX">Let’s move on to adding a new key, which requires some extra coding.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-123"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Key to a</span> <span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Treap</span></h4>&#13;
<p class="TNI1">Insertion into a treap requires basically the same logic as for binary search trees, except that after having added the node in its place, you may need to do some rotations to maintain the heap property. Adding new keys to a treap is possible using the <span class="SANS_TheSansMonoCd_W5Regular_11">_rotate()</span> method introduced in previous chapters. The basic idea is first to place the new node in the tree according to its value and then rotate it, if needed, in a way that the binary search tree condition is kept but that also satisfies the heap condition. <a href="chapter14.xhtml#fig14-20">Figure 14-20</a> shows the basic rotations.</p>&#13;
<figure class="IMG"><img class="img1" id="fig14-20" src="../images/Figure14-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-20: Rotations also make the binary search tree become a heap.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The minus sign represents a smaller key value than the plus sign. If the node placed lower (the minus) has a higher priority than its parent (the plus), which is shown in the left side of the figure, you can apply a <i>right rotation</i> and produce the situation on the right, which would satisfy the heap property. Conversely, if you have the situation on the right and the lower node (plus) has a higher priority than its parent (minus), you can apply a <i>left rotation</i> to get the situation on the left. In both cases, the resulting tree is <span role="doc-pagebreak" epub:type="pagebreak" id="pg_334" aria-label="334"/>still a binary search tree, but the nodes are shifted around so that the final parent node has a greater priority than its children.</p>&#13;
<p class="TX">Here is an example of how the <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> algorithm should work. Start with the treap shown in <a href="chapter14.xhtml#fig14-21">Figure 14-21</a>, where priorities are shown to the right of nodes.</p>&#13;
<figure class="IMG"><img class="img7" id="fig14-21" src="../images/Figure14-21.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-21: In a treap, keys form a binary search tree and priorities form a heap.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you want to add a 12 node with a (random) priority of 0.8, the first step is to insert the new node, without worrying about priorities and the heap property, which will be sorted out later. This insertion (done in the standard way for binary search trees, as described in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>) leads to the tree shown in <a href="chapter14.xhtml#fig14-22">Figure 14-22</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig14-22" src="../images/Figure14-22.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-22: After standard insertion, the resulting binary search tree may no longer be a heap.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The treap works for searches, but the heap property isn’t satisfied, because the priority for the 12 node is higher than the priority of its parent. You can fix that problem by doing a left rotation, leading to the tree shown in <a href="chapter14.xhtml#fig14-23">Figure 14-23</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_335" aria-label="335"/>&#13;
<figure class="IMG"><img class="img7" id="fig14-23" src="../images/Figure14-23.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-23: Rotations are applied until the heap property is satisfied, but this tree is still wrong.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The rotation still leaves a valid binary search tree, but the process hasn’t ended, because the heap property isn’t yet fully satisfied. The 12 node has a higher priority than its parent; perform a right rotation to solve this, which leads to the tree shown in <a href="chapter14.xhtml#fig14-24">Figure 14-24</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig14-24" src="../images/Figure14-24.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-24: Now the</span> <span class="SANS_Futura_Std_Book_Oblique_11">heap property is satisfied.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After this second rotation, you can check that the heap property is satisfied, thus the addition to the treap was done correctly.</p>&#13;
<p class="TX">The final code follows, and there’s a single line that’s different from common binary search trees:</p>&#13;
<pre id="pre-280"><code>const add = (tree, keyToAdd) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    return newNode(keyToAdd);&#13;
  } else {&#13;
    const side = keyToAdd &lt;= tree.key ? "left" : "right";&#13;
    tree[side] = add(tree[side], keyToAdd);&#13;
    <b>return tree[side].priority &lt;= tree.priority ? tree : _rotate(tree, side);</b>&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_336" aria-label="336"/>The line in bold makes sure that the heap property is satisfied. After adding the new key on <span class="SANS_TheSansMonoCd_W5Regular_11">tree[side]</span>, if the priority of that subtree is not greater than the priority of the root, you’re done; otherwise, apply a rotation on that side to bring up the greater priority.</p>&#13;
<p class="TX">The last method needed is to remove a key from a treap.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-124"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing a Key from a Treap</span></h4>&#13;
<p class="TNI1">The algorithm for removing a key from a binary search tree involves finding it first, possibly finding its successor, and putting it in the removed node’s place. With treaps, given that you must maintain the heap property, it’s a tad more complex, but just as with insertions, you can use rotations to make things come out right. To remove a node, use a different logic from earlier with binary search trees:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">If you search for a key to remove in an empty tree, there’s nothing to be done.</li>&#13;
<li class="ListBullet">If the key to remove is lower than the key at the root, delete the key from the tree at the root’s left child.</li>&#13;
<li class="ListBullet">Otherwise, if the key to remove is greater than the key at the root, delete the key from the tree at the root’s right child.</li>&#13;
<li class="ListBullet">Otherwise, if the key has neither a left child nor a right child, just delete it.</li>&#13;
<li class="ListBullet">Otherwise, if it has a right child but no left child, set it to the right child.</li>&#13;
<li class="ListBullet">Otherwise, if it has a left child but no right child, set it to the left child.</li>&#13;
<li class="ListBullet">Finally, if it has both left and right children, apply a rotation to move the key lower in the tree and attempt to delete it again.</li>&#13;
</ul>&#13;
<p class="TX">The last step is the one that may be surprising, and it’s certainly different from binary search trees. With the rotations shown earlier when inserting in a treap, it’s possible to rotate a node with one of its children, and the rotated node will be lower in the treap. If you carefully choose what rotation to use, you can keep satisfying the heap property; so if you had a valid treap before the rotation, you’ll still have a valid one after it. And finally, as the key to delete moves lower and lower, it can’t always keep having two children. At some point, it will have one or none, and then you can finish the job quickly.</p>&#13;
<p class="TX">Consider a more complex case. Start with the treap shown in <a href="chapter14.xhtml#fig14-25">Figure 14-25</a> and remove the 9 node (as in the section “<span class="Xref">Adding a Key to a Treap</span>” on page <span class="Xref">333</span>, the priorities are shown to the right of the nodes).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_337" aria-label="337"/>&#13;
<figure class="IMG"><img class="img5" id="fig14-25" src="../images/Figure14-25.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-25: An initial treap, with a node to be removed</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After finding the node, it happens that it has two children, so you need to do a rotation. The right child of 9 has greater priority, so apply a left rotation, leaving the intermediate situation shown in <a href="chapter14.xhtml#fig14-26">Figure 14-26</a> (notice that the heap property is not satisfied, but it will be after you remove the 9 node).</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-26" src="../images/Figure14-26.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-26: A left rotation brings down the node to be removed.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The 9 node again has two children, so do a new rotation. This time, the child with the greater priority is the left one, so you can do a right rotation, resulting in a new situation (<a href="chapter14.xhtml#fig14-27">Figure 14-27</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_338" aria-label="338"/>&#13;
<figure class="IMG"><img class="img5" id="fig14-27" src="../images/Figure14-27.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-27: A new rotation moves the node to be deleted further down the treap.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now you’ve reached a simple case, since the 9 node has only one child, which allows you to remove it, resulting in the final treap (<a href="chapter14.xhtml#fig14-28">Figure 14-28</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig14-28" src="../images/Figure14-28.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-28: The final treap after removing the node you want to delete</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The code for removing a key is as follows (notice that the implementation closely follows the previous bulleted list):</p>&#13;
<pre id="pre-281"><code>const remove = (tree, keyToRemove) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    // nothing to do&#13;
  } else if (keyToRemove &lt; tree.key) {&#13;
    tree.left = remove(tree.left, keyToRemove);&#13;
  } else if (keyToRemove &gt; tree.key) {&#13;
    tree.right = remove(tree.right, keyToRemove);&#13;
  } else if (isEmpty(tree.left) &amp;&amp; isEmpty(tree.right)) {&#13;
    tree = null;&#13;
  } else if (isEmpty(tree.left)) {&#13;
    tree = tree.right;&#13;
  } else if (isEmpty(tree.right)) {&#13;
    tree = tree.left;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span>} else {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_339" aria-label="339"/><b>  </b><span class="Code_CodeAnnotation" aria-label="annotation2">❷</span><b> const [side, other] =</b>&#13;
<b>      tree.left.priority &lt; tree.right.priority</b>&#13;
<b>        ? ["right", "left"]</b>&#13;
<b>        : ["left", "right"];</b>&#13;
<b>  </b><span class="Code_CodeAnnotation" aria-label="annotation3">❸</span><b> tree = _rotate(tree, side);</b>&#13;
<b>  </b><span class="Code_CodeAnnotation" aria-label="annotation4">❹</span><b> tree[other] = remove(tree[other], keyToRemove);</b>&#13;
  }&#13;
  return tree;&#13;
};</code></pre>&#13;
<p class="TX">The code is the same as for common binary search trees, except that when a key is found that has two children <span class="CodeAnnotation" aria-label="annotation1">❶</span>, you decide which rotation you need <span class="CodeAnnotation" aria-label="annotation2">❷</span>, apply it <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and go down recursively to attempt deleting the key <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If you had done a left rotation, the original root (with the key you wanted to delete) would be displaced to the left subtree, so the removal process continues there. With a right rotation, the process would continue at the right subtree.</p>&#13;
<p class="TX">You’ve now used heaps to extend binary search trees. Let’s look at the results of this change.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-125"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering the Performance of Treaps</span></h4>&#13;
<p class="TNI1">As mentioned earlier, the expected height of treaps is <i>O</i>(log <i>n</i>), which means that adding, removing, and finding keys all have that same expected order. The randomization implied by the assignment of priorities does not ensure, however, that there won’t be bad cases, and in fact, the worst-case scenario is the same as with binary search trees: trees having <i>O</i>(<i>n</i>) depth and an effect on the algorithms’ performance.</p>&#13;
<p class="TX">A main difference with common binary search trees is that in practice, getting a “bad” sequence of data may not be unexpected, always leading to bad trees. However, in a treap, because of the random priorities, the probability of building a “bad” treap is very low, no matter the order of the original data. In fact, to get a badly balanced treap, priorities would have to be correlated with the key values, which is very unlikely to happen with random numbers. Thus, the average performance of algorithms will be independent of the sequence of key insertions (see <a href="chapter14.xhtml#tab14-4">Table 14-4</a>).</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab14-4"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 14-4:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for</span> <span class="SANS_Futura_Std_Book_11">Treaps</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Average performance</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Worst case</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Traverse</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The key to treaps is that randomization makes it highly probable that some balance will be achieved, thus providing high performance. (This was <span role="doc-pagebreak" epub:type="pagebreak" id="pg_340" aria-label="340"/>the same argument for randomized binary search trees.) In addition, treaps allow you to implement other methods, like partitioning a treap into two or rejoining two treaps to make one. We won’t discuss those methods directly here, but see questions 14.15 and 14.16 at the end of the chapter.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span id="h1-72"/><span class="SANS_Futura_Std_Bold_B_11">Ternary and D-ary Heaps</span></h3>&#13;
<p class="TNI1">If binary heaps are a good structure for priority queues, the logical generalization is that as with B-trees, having more children at each level makes for a shorter tree and faster algorithms, such as with <i>ternary</i> (also known as <i>trinary</i>) heaps, in which each node has three children, or <i>quaternary</i> heaps with four children, and in general <i>d-ary</i> heaps with <i>d</i> children for each node.</p>&#13;
<p class="TX">Basically, all the differences are in the <span class="SANS_TheSansMonoCd_W5Regular_11">_bubbleUp()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">_sinkDown()</span> methods, which now have to deal with more than two children, as shown:</p>&#13;
<pre id="pre-282"><code>const {newHeap, isEmpty, top} = require("./heap.func.js");&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span><b> const ORDER = 3;</b> // with ORDER===2, we get classic heaps&#13;
&#13;
const _bubbleUp = (heap, i) =&gt; {&#13;
  if (i &gt; 0) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> <b>const p = Math.floor((i - 1) / ORDER);</b>&#13;
    if (heap[i] &gt; heap[p]) {&#13;
      [heap[p], heap[i]] = [heap[i], heap[p]];&#13;
      _bubbleUp(heap, p);&#13;
    }&#13;
  }&#13;
};&#13;
&#13;
const _sinkDown = (heap, i, h) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span><b> const first = ORDER * i + 1;</b>&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span><b> const last = first + ORDER;</b>&#13;
  let g = i;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> <b>for (let j = first; j &lt; last &amp;&amp; j &lt; h; j++)</b> {&#13;
    if (heap[j] &gt; heap[g]) {&#13;
      g = j;&#13;
    }&#13;
  }&#13;
  if (g !== i) {&#13;
    [heap[g], heap[i]] = [heap[i], heap[g]];&#13;
    _sinkDown(heap, g, h);&#13;
  }&#13;
};&#13;
&#13;
const add = (heap, keyToAdd) =&gt; {...exactly as before...}&#13;
&#13;
const remove = (heap) =&gt; {...exactly as before...}</code></pre>&#13;
<p class="TX">Take a look at the changes in the code. We added an <span class="SANS_TheSansMonoCd_W5Regular_11">ORDER</span> variable (here set to <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>) to store the order of the new heap <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Calculating the <i>parent</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_341" aria-label="341"/>of a node requires using a corrected formula; instead of dividing by 2 as in binary heaps, divide by the heap order <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then make the same change (substituting the heap order for the 2) to find the children of an element <span class="CodeAnnotation" aria-label="annotation3">❸</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Since you may have any number of children for a node, loop over them to find the greatest <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">If you create a new heap (ternary, in this case) and add values 22, 9, 60, 34, 24, 40, 11, 12, 56, 4, and 58, in that order, you’ll get the heap in <a href="chapter14.xhtml#fig14-29">Figure 14-29</a> (shown as both a tree and an array).</p>&#13;
<figure class="IMG"><img class="img7" id="fig14-29" src="../images/Figure14-29.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-29: In a ternary heap, the implementation is similar to binary heaps.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">What about the order of <i>d</i>-ary heaps in general? Since the height of the tree is always <i>O</i>(log <i>n</i>), the order for all operations is the same. However, some operations may have better or worse performance. For instance, bubbling up becomes faster (because the tree is flatter), but sinking down is slower (because you have to find the largest out of more values).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H1" id="sec19"><span id="h1-73"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">This chapter introduced a new data structure, a heap in several variants: binary and <i>d</i>-ary, as well as min and max heaps. We saw how heaps could be used to implement a new ADT: priority queues. Another usage of heaps was a sorting algorithm with good constant performance. Finally, we applied the heap concept to create a randomized binary search tree: a treap. In the next chapter, we’ll continue exploring related concepts and consider some variants of heaps that allow for new operations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h3 class="H1" id="sec20"><span id="h1-74"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>14.1  Is It a Heap?</b></p>&#13;
<p class="ListPlainFirst">Given an array, write a function that returns whether the array is a max heap. You don’t need to build a heap; just answer whether it already is one.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_342" aria-label="342"/><b>14.2  Making Do with Queues</b></p>&#13;
<p class="ListPlainFirst">Suppose you could work only with priority queues but not with stacks or queues. How could you emulate those two ADTs with a priority queue? (Hint: since stacks and queues do not use a priority field, you can assign them whichever values you want.)</p>&#13;
<p class="ListHead"><b>14.3  Max to Min</b></p>&#13;
<p class="ListPlainFirst">Suppose you have a max heap; can you convert it into a min heap in linear <i>O</i>(<i>n</i>) time?</p>&#13;
<p class="ListHead"><b>14.4  Max or Min</b></p>&#13;
<p class="ListPlainFirst">What changes would you have to apply to your max heaps in order to get min heaps instead?</p>&#13;
<p class="ListHead"><b>14.5  Merge Away!</b></p>&#13;
<p class="ListPlainFirst">Suppose you are given several ordered lists and want to merge them into a single list. Implement this algorithm using a min heap to decide what node to choose at each step.</p>&#13;
<p class="ListHead"><b>14.6  Searching a Heap</b></p>&#13;
<p class="ListPlainFirst">Even though it makes little sense (because the heap isn’t structured for it), how could you implement a <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> function to search for a value in a heap?</p>&#13;
<p class="ListHead"><b>14.7  Removing from the Middle of a Heap</b></p>&#13;
<p class="ListPlainFirst">In a heap, you always remove the value at the top, and if you want to remove the last value of a heap, it’s trivial, but can you write an algorithm that allows you to remove any element whatsoever from a heap?</p>&#13;
<p class="ListHead"><b>14.8  Faster Build</b></p>&#13;
<p class="ListPlainFirst">Floyd’s enhancement builds a heap in <i>O</i>(<i>n</i>) time. Modify <span class="SANS_TheSansMonoCd_W5Regular_11">newHeap()</span> so if given an array of values, it will use Floyd’s method to initialize the heap.</p>&#13;
<p class="ListHead"><b>14.9  Another Way of Looping</b></p>&#13;
<p class="ListPlainFirst">In the <span class="SANS_TheSansMonoCd_W5Regular_11">heapsort_original</span> function, you could have easily used <span class="SANS_TheSansMonoCd_W5Regular_11">forEach()</span> to build up the heap; can you see how?</p>&#13;
<p class="ListHead"><b>14.10  Extra Looping?</b></p>&#13;
<p class="ListPlainFirst">In the <span class="SANS_TheSansMonoCd_W5Regular_11">heapsort_enhanced</span> function, what would have happened if you had done a complete loop when building up the heap? More specifically, what if that code had been written as follows:</p>&#13;
<pre class="pre" id="pre-283"><code><span class="SANS_TheSansMonoCd_W5Regular_11">for (let i = </span><b>v.length - 1</b><span class="SANS_TheSansMonoCd_W5Regular_11">; i &gt;= 0; i--) {</span>&#13;
  sinkDown(i, v.length);&#13;
}</code></pre>&#13;
<p class="ListHead"><b>14.11  Maximum Equality</b></p>&#13;
<p class="ListPlainFirst">What’s the order of heapsort if you use it to sort an array filled with the same value?</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_343" aria-label="343"/><b>14.12  Unstable Heap?</b></p>&#13;
<p class="ListPlainFirst">Heapsort isn’t stable, and trying to sort a short array is enough to verify this. Can you produce such an example and show the lack of stability? Tip: you won’t need a very large array.</p>&#13;
<p class="ListHead"><b>14.13  Trimmed Selection</b></p>&#13;
<p class="ListPlainFirst">You can use a heap to select the <i>k</i> greatest values out of <i>n</i> by removing the top of the heap <i>k</i> times. However, if <i>k</i> &lt;&lt; <i>n</i>, you may speed up things a bit. Show that the <i>k</i> greatest values must be found in level 1 (the root) up to level <i>k</i> (but not beyond), and use this finding to prune the heap before doing the selection.</p>&#13;
<p class="ListHead"><b>14.14  Is It a Treap?</b></p>&#13;
<p class="ListPlainFirst">Given a binary tree whose nodes have <span class="SANS_TheSansMonoCd_W5Regular_11">key</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">priority</span> fields, can you write a function that will check whether that tree is actually a treap?</p>&#13;
<p class="ListHead"><b>14.15  Splitting a Treap</b></p>&#13;
<p class="ListPlainFirst">Given a treap and a limit value, partition it into two separate treaps: one with all the keys smaller than the limit value and the other with all the keys larger than the limit. Assume that the limit value isn’t in the treap.</p>&#13;
<p class="ListHead"><b>14.16  Rejoining Two Treaps</b></p>&#13;
<p class="ListPlainFirst">Consider the inverse to question 14.15: assume that you have two separate treaps, such that all keys in the first are smaller than all keys in the second. Can you find a way to join those two treaps to form a single one?</p>&#13;
<p class="ListHead"><b>14.17  Removing from a Treap</b></p>&#13;
<p class="ListPlainFirst">If in the <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> method for a treap you changed the line</p>&#13;
<pre class="pre" id="pre-284"><code>tree[other] = remove(tree[other], keyToRemove);</code></pre>&#13;
<p class="ListContinued">to</p>&#13;
<pre class="pre" id="pre-285"><code>tree = remove(tree, keyToRemove);</code></pre>&#13;
<p class="ListContinued">would it still work? For reference, this is how the code would look (the changed line is in bold):</p>&#13;
<pre class="pre" id="pre-286"><code>const remove = (tree, keyToRemove) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    // nothing to do&#13;
  } else if (keyToRemove &lt; tree.key) {&#13;
    tree.left = remove(tree.left, keyToRemove);&#13;
  } else if (keyToRemove &gt; tree.key) {&#13;
    tree.right = remove(tree.right, keyToRemove);&#13;
  } else if (isEmpty(tree.left) &amp;&amp; isEmpty(tree.right)) {&#13;
    tree = null;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_344" aria-label="344"/>  } else if (isEmpty(tree.left)) {&#13;
    tree = tree.right;&#13;
  } else if (isEmpty(tree.right)) {&#13;
    tree = tree.left;&#13;
  } else {&#13;
    const [side, other] =&#13;
      tree.left.priority &lt; tree.right.priority&#13;
        ? ["right", "left"]&#13;
        : ["left", "right"];&#13;
    tree = _rotate(tree, side);&#13;
    <b>tree = remove(tree, keyToRemove);</b>&#13;
  }&#13;
&#13;
  return tree;&#13;
};</code></pre>&#13;
<p class="ListHead"><b>14.18  Trees as Heaps</b></p>&#13;
<p class="ListPlainFirst">What would happen if you used binary search trees to represent heaps? What would the performance be of the three basic operations: <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">top()</span>? Can you think of ways to make <span class="SANS_TheSansMonoCd_W5Regular_11">top()</span> faster?</p>&#13;
</section>&#13;
</section>&#13;
</body></html>