- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Scaffolded Code Exercises
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支架代码练习
- en: Once you select a development environment, you can start setting up more involved
    code exercises for your students. In this chapter, we’ll learn three coding activities
    of increasing complexity that address multiple computer science standards, such
    as evaluating and enhancing algorithms, learning to talk about code, using encryption,
    and debugging. Each exercise will require you to provide students with prewritten
    code in your chosen development environment as a scaffolding for student understanding.
    This way, students will continue to learn from existing code but be given specific
    direction for engaging with that code to better understand it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了开发环境，你可以开始为学生设置更复杂的代码练习。在本章中，我们将学习三种逐渐增加复杂度的编码活动，涵盖多个计算机科学标准，比如评估和优化算法、学习如何讨论代码、使用加密和调试。每个练习都需要你为学生提供在所选开发环境中预编写的代码，作为学生理解的支架。这样，学生将继续从现有的代码中学习，但会给他们特定的方向，引导他们更好地理解这些代码。
- en: Evaluating Algorithms
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估算法
- en: The computer science standards have students practice evaluating and comparing
    algorithms. In this evaluation exercise, which is from the organization freeCodeCamp,
    you’ll present your students with many different algorithms to test for *palindromes,*
    text strings that read the same forward as backward. One technique for finding
    palindromes would be to choose a string input, reverse it, and see whether the
    reversed string equals the original string. When this possible solution is abstracted,
    one component of this function would likely take a string of characters and return
    that string with the character order reversed. Edd Mann, a blogger and developer,
    documented 10 ways to do this in JavaScript (*[https://eddmann.com/posts/ten-ways-to-reverse-a-string-in-javascript/](https://eddmann.com/posts/ten-ways-to-reverse-a-string-in-javascript/)*).
    We’ll review three of the solutions he developed, but the full exercise should
    include many more examples.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学标准要求学生练习评估和比较算法。在这个评估练习中，来自免费编程网站 freeCodeCamp，你将给学生们提供许多不同的算法，用来测试 *回文*，即正着读和反着读都相同的文本字符串。一种寻找回文的技巧是选择一个字符串输入，将其反转，并检查反转后的字符串是否等于原字符串。当这个可能的解决方案被抽象化时，函数的一个组成部分可能会接受一个字符字符串，并返回字符顺序被反转后的字符串。博客作者兼开发者
    Edd Mann 记录了 10 种用 JavaScript 实现这一点的方法（*[https://eddmann.com/posts/ten-ways-to-reverse-a-string-in-javascript/](https://eddmann.com/posts/ten-ways-to-reverse-a-string-in-javascript/)*）。我们将回顾他开发的三种解决方案，但完整的练习应该包括更多的例子。
- en: for Loop
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环
- en: The first example in Listing 7-1 is a simple for loop. It takes the string input,
    loops backward through each character in the string via the i = stringToReverse.length
    - 1; i >= 0; i-- arguments, and appends the last character in the string to the
    new string.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-1 中的第一个例子是一个简单的 for 循环。它接受字符串输入，通过 i = stringToReverse.length - 1; i >=
    0; i-- 这些参数，从字符串的最后一个字符开始反向循环，通过循环将字符串中的每个字符附加到新字符串中。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: Using a for loop to reverse a string'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-1：使用 for 循环反转字符串
- en: Students can see the output of the reverseString function in Listing 7-2 where
    the word “aibohphobia,” the fear of palindromes, is the input.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 学生可以在清单 7-2 中查看 reverseString 函数的输出，输入为“aibohphobia”（回文恐惧症）。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-2: Code to execute the reverseString function'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-2：执行 reverseString 函数的代码
- en: When evaluating this algorithm, you have an excellent opportunity to introduce
    your students to the debugging tools built into the web browser. Have your students
    open this code in the browser, launch the web development tools, and then click
    **Sources** or **Debugger** from the top menu depending on the browser they’re
    using. Figure 7-1 shows a screen similar to what they’ll see.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估这个算法时，你有一个极好的机会向学生们介绍内置于网页浏览器中的调试工具。让学生们在浏览器中打开这段代码，启动网页开发工具，然后根据他们使用的浏览器，点击顶部菜单中的
    **Sources** 或 **Debugger**。图 7-1 显示了他们将看到的类似屏幕。
- en: '![](image/CitC07_01_debugger_labeled_new.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](image/CitC07_01_debugger_labeled_new.png)'
- en: 'Figure 7-1: Debugging options in the browser’s web development tools'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：浏览器网页开发工具中的调试选项
- en: Three main panels are in this screenshot. The *File Navigator* ❶ is where every
    file used in the web page is listed. Clicking these files displays their contents
    in the *Code Editor *❷. Clicking the line numbers in this panel will set *breakpoints*,
    places where we want the browser to pause code execution so we can review variable
    values or begin stepping through the code. The *JavaScript Debugging* panel ❸
    is where the current program state and other tools for troubleshooting code reside.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该截图中有三个主要面板。*文件导航器* ❶ 列出了网页中使用的每个文件。点击这些文件会在 *代码编辑器* ❷ 中显示其内容。点击此面板中的行号将设置*断点*，即我们希望浏览器暂停代码执行的位置，以便查看变量值或开始逐步执行代码。*JavaScript
    调试* 面板 ❸ 则显示当前程序状态和其他调试工具。
- en: When evaluating an algorithm, students click the line number at the function’s
    start and trigger the code execution by manually refreshing the page in the browser.
    The browser pauses processing the code at the breakpoint. Students should then
    begin stepping through the code using the navigation controls at the top of the
    Debugging panel. As they step through the code, they’ll see how the browser highlights
    each executed step in the algorithm and how the variables change values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估算法时，学生点击函数开始处的行号，并通过手动刷新浏览器页面触发代码执行。浏览器在断点处暂停代码处理。然后，学生应该使用调试面板顶部的导航控件逐步执行代码。随着他们逐步执行代码，他们将看到浏览器如何高亮显示算法中每个已执行的步骤，以及变量值如何变化。
- en: 'Figure 7-1 shows a set breakpoint at line five of the code. From there, the
    figure shows that the developer has stepped to line six. The mouse is hovering
    over the i variable, so we can see its value of 5 hovering above it. Alongside
    the reversedString variable is the value aibhop: six letters are now appended
    in reverse to the string at this iteration. The Debugging panel shows the variable
    values listed under Scope, a list of the breakpoints, and the *call stack*, which
    is the list of functions currently being called. In this case, the code is only
    calling one function. But as we dive into more complex code, following the stack
    and seeing what functions are calling other functions becomes more important.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1 显示了在代码的第五行设置了断点。从那里，图示显示开发者已经执行到第六行。鼠标悬停在 i 变量上，因此我们可以看到它的值 5 显示在其上方。与
    reversedString 变量一起的是值 aibhop：此迭代中，六个字母已按相反顺序附加到字符串上。调试面板显示了作用域下列出的变量值、断点列表以及*调用栈*，即当前正在调用的函数列表。在这种情况下，代码只调用了一个函数。但随着我们深入研究更复杂的代码，跟踪栈并查看哪些函数正在调用其他函数变得更加重要。
- en: Recursion
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归
- en: Once your students have had the chance to play with the Debugger and understand
    the loop strategy for reversing the string, you can introduce a more complex algorithm.
    The example in Listing 7-3 uses *recursion*, a technique where a function calls
    itself, which creates a loop similar to a while loop. Here the function first
    checks whether the ­stringToReverse input variable is empty; if not, the function
    returns every character after the first using the .substr(1) command and appends
    the first character in the string to the end via the .charAt(0) command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦学生有机会使用调试器并理解反转字符串的循环策略，你可以引入一个更复杂的算法。列表 7-3 中的示例使用了*递归*，这是一种函数调用自身的技术，创建了类似于
    while 循环的循环。在这里，函数首先检查输入变量­stringToReverse 是否为空；如果不为空，函数通过 .substr(1) 命令返回第一个字符之后的每个字符，并通过
    .charAt(0) 命令将字符串中的第一个字符附加到末尾。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 7-3: Reversing a string using recursion'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-3：使用递归反转字符串
- en: Although the concept of recursion is easy to define, your students might find
    it difficult to follow and understand this example, and they’re not alone. Many
    developers express difficulty following along with some recursive algorithms.
    To help them, direct your students to the call stack as they step through the
    function’s execution. Have them watch the list of function calls grow and eventually
    shrink with each iteration. Additionally, have them compare this function to a
    while loop because both controls iterate until a condition is met. It’s worth
    noting that a recursive function is not the same as a while loop, although there
    are some similarities.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管递归的概念很容易定义，但学生可能会发现很难理解和跟随这个示例，他们并不孤单。许多开发者在跟踪某些递归算法时也表达过困难。为了帮助他们，在他们逐步执行函数时，引导学生查看调用栈。让他们观察函数调用列表如何在每次迭代时增长并最终缩小。此外，让他们将此函数与
    while 循环进行比较，因为两者都控制迭代直到满足某个条件。值得注意的是，递归函数并不等同于 while 循环，尽管它们有一些相似之处。
- en: Despite being a bit difficult to follow, recursion can be an ideal solution
    for certain tasks. For example, the *minimax algorithm* is a popular function
    used in making AI opponents for games like chess and tic-tac-toe. Minimax iterates
    and evaluates all possible moves to determine the best reply to each possible
    player move. Figure 7-2 shows how each point in a tic-tac-toe game can branch
    out into several possibilities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管递归有时较难理解，但它在某些任务中可以是一个理想的解决方案。例如，*极小极大算法*是一个常用函数，广泛用于为像国际象棋和井字棋这样的游戏中的AI对手提供决策。极小极大算法通过迭代和评估所有可能的走法，来确定对每个可能的玩家走法的最佳回应。图7-2展示了在井字棋游戏中，每个点如何分支成多个可能性。
- en: Each branch potentially has more branches. Although navigating a one-dimensional
    array of characters only needs a single loop, navigating this data tree would
    require loops within loops. With 255,168 different possible games in tic-tac-toe
    alone, writing enough loops to explore them all would be unfeasible, which is
    why Figure 7-2 only illustrates a few branches. Recursion allows us to more easily
    explore complex data structures without needing to know all their dimensions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分支可能还有更多的分支。虽然在一个一维字符数组中遍历只需要一个循环，但在这个数据树中导航则需要在循环中嵌套循环。仅井字棋中就有255,168种不同的可能游戏，要写足够的循环来探索它们是不现实的，这也是为什么图7-2只展示了几个分支。递归使得我们能够更轻松地探索复杂的数据结构，而不需要了解它们的所有维度。
- en: '![](image/CitC07_02_tictactoe_new.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](image/CitC07_02_tictactoe_new.png)'
- en: 'Figure 7-2: Sample tic-tac-toe game possibility branches'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-2：井字棋游戏可能性分支示例
- en: Array Manipulation
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组操作
- en: A third way to reverse the string, as shown in Listing 7-4, uses array manipulation
    and array functions built into JavaScript. The .split("") function splits all
    the characters in the string into an array, which is then flipped using the .reverse()
    command, and then appended back together into a string again via .join(""). Although
    it’s one line of code, the array manipulation approach executes three steps we
    can see and many steps we can’t see because they’re abstracted behind the function
    calls.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表7-4所示，第三种反转字符串的方法使用了数组操作和JavaScript内置的数组函数。`.split("")`函数将字符串中的所有字符拆分成一个数组，然后使用`.reverse()`命令将其翻转，再通过`.join("")`将它们重新拼接成一个字符串。虽然这只是一行代码，但数组操作方法执行了我们可以看到的三个步骤，以及许多我们看不见的步骤，因为它们被抽象在函数调用背后。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-4: Reversing a string using array manipulation'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-4：使用数组操作反转字符串
- en: After reviewing many ways to accomplish the same task, ask your students for
    their opinions on the different methods. What do they like and dislike about them?
    Ask them to justify their answers in terms of implementation, code readability,
    and performance to practice appraising code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在审视了多种完成同一任务的方法后，向学生询问他们对不同方法的看法。他们喜欢和不喜欢这些方法的哪些方面？让他们从实现、代码可读性和性能的角度来阐述他们的答案，以此来练习评估代码。
- en: An important point to make is that there aren’t explicitly right and wrong answers.
    But in some cases, for instance when iterating over data in a tree structure,
    recursion will feel more natural, and a loop will feel bulkier. At times, the
    coder might break a chain of functions out of one line of code and into multiple
    lines to improve readability or will add extensive comments to a single code line
    to explain what’s going on to their peers and future selves. The point of this
    exercise isn’t to tell students what the best practices are, but to practice thinking
    about the different solutions and articulating why they might prefer one technique
    over another.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点是，并没有明确的对错答案。但在某些情况下，例如在遍历树结构中的数据时，递归会显得更自然，而循环则会显得笨重。有时，程序员可能会将一行代码中的函数链分解成多行，以提高可读性，或者会为某行代码添加详细的注释，以向同事和未来的自己解释发生了什么。这个练习的目的是让学生思考不同的解决方案，并清楚地表达他们为什么偏好某种技术，而不是告诉他们最佳实践是什么。
- en: There are many other ways to extend the exercise to cover computer science standards
    beyond evaluating and comparing algorithms. For example, when covering the recursion
    example, you could challenge your students to rewrite it as a while loop as an
    exercise in modifying an existing algorithm. We’ve also covered computer science
    standards such as recursion as a control structure, tree structures for data and
    the minimax algorithm, and debugging tools as a means of reading algorithms step-by-step
    for deeper understanding.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他方法可以扩展练习，涵盖超出评估和比较算法的计算机科学标准。例如，在讲解递归示例时，你可以挑战学生将其重写为while循环，作为修改现有算法的练习。我们还涉及了计算机科学标准，如递归作为控制结构、数据的树结构、最小最大算法以及调试工具，作为逐步阅读算法以深入理解的手段。
- en: In the function execution example provided, we used a palindrome for the input.
    Ask your students, using this input, whether we’re verifying that the functions
    are working correctly. How do we know the output string is really reversed? What
    argument should we use to properly test these functions? By doing so, we’re also
    introducing quality assurance and testing aspects to the exercise.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的函数执行示例中，我们使用了一个回文作为输入。请问学生们，使用这个输入，我们是否在验证函数是否正常工作？我们怎么知道输出的字符串真的被反转了？我们应该使用什么参数来正确测试这些函数？通过这样做，我们也将质量保证和测试方面的内容引入了这个练习。
- en: Once students are familiar with systematically stepping through and evaluating
    code, comparing algorithms, and learning about the different ways to accomplish
    the same task, we can introduce them to extending those algorithms. Next, we’ll
    introduce them to an engaging exercise that involves extending existing code iteratively
    and making it increasingly complex by design.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦学生们熟悉了系统地逐步执行和评估代码、比较算法，并了解完成同一任务的不同方法，我们就可以向他们介绍扩展这些算法的概念。接下来，我们将向他们介绍一个有趣的练习，涉及通过迭代扩展现有代码，并通过设计使其变得越来越复杂。
- en: Enhancing Algorithms
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强算法
- en: In addition to evaluating and comparing algorithms, computer science standards
    also require students to refine or enhance them. We’ll use this exercise as an
    opportunity to bring some basic cybersecurity concepts into the mix. Here students
    will learn about a simple algorithm for encrypting messages, explore a code sample
    to execute this process, figure out how to crack the encryption, and determine
    how to make their original encryption harder to crack.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了评估和比较算法外，计算机科学标准还要求学生对算法进行改进或增强。我们将利用这个练习的机会，引入一些基本的网络安全概念。在这里，学生将学习一种简单的加密消息的算法，探索一个代码示例来执行这一过程，弄清楚如何破解加密，并确定如何让他们的原始加密更难被破解。
- en: Huge advances in computing originated from wartime necessities. One computational
    arms race centered on *cryptography*, keeping communications secure against third
    parties reading them. The *Caesar cipher*, named for the fact that Julius Caesar
    used it in correspondence, is a very basic encryption algorithm. In it, each letter
    in a string is shifted a specific number of characters along the alphabet. For
    example, input “A” with a shift of one to output “B,” or input “A” with a shift
    of two to output “C.” Figure 7-3 shows a Federal Bureau of Investigations, Cryptanalysis
    and Racketeering Records Unit challenge coin featuring a cipher wheel in its design.
    In this example, the computational device is shifted three places so the input
    “TOP SECRET” would output “WRS VHFUHW.” The Confederate Army used ciphers like
    this during the Civil War.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学的巨大进步源自于战争期间的需求。一个计算竞赛集中在*密码学*上，旨在保护通信免受第三方窃听。*凯撒密码*因尤利乌斯·凯撒在通信中使用而得名，是一种非常基础的加密算法。在这种算法中，字符串中的每个字母都按字母表中的特定字符数进行偏移。例如，输入“A”并偏移一个位置得到“B”，或者输入“A”并偏移两个位置得到“C”。图7-3展示了联邦调查局密码分析和勒索犯罪记录单位的挑战币，其设计中包含了一个密码轮。在这个例子中，计算设备向右偏移了三个位置，因此输入“TOP
    SECRET”会输出“WRS VHFUHW”。南北战争期间，南方联盟军队也使用了类似的密码。
- en: '![](image/CitC07_03_cipherwheel.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](image/CitC07_03_cipherwheel.png)'
- en: 'Figure 7-3: Federal Bureau of Investigations, Cryptanalysis and Racketeering
    Records Unit challenge coin showing a Caesar cipher. Photo by David Oranchak.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-3：联邦调查局密码分析和勒索犯罪记录单位的挑战币，展示了凯撒密码。照片由David Oranchak提供。
- en: The function in Listing 7-5 contains an algorithm that takes a string input,
    makes a shift, and outputs the string with each character transposed according
    to the defined shift. Provide this function to your students in your chosen development
    environment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-5中的函数包含一个算法，它接收一个字符串输入，进行偏移，然后输出根据定义的偏移规则转换过的字符串。将这个函数提供给你的学生，在你选择的开发环境中使用。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-5: Caesar cipher function by Evan Hahn, released to the public domain'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-5：由Evan Hahn编写的凯撒密码函数，已发布为公有领域
- en: Students can test this function using the line of code in Listing 7-6 to see
    the output.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 学生们可以使用列表7-6中的代码行来测试这个函数，查看输出结果。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 7-6: Executing the Caesar cipher'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-6：执行凯撒密码
- en: Have your students take some time to decompose this code. They should try out
    some of the bits and pieces in the browser console to understand the parts and
    search the web for some of the functions. Have them add comments to the code for
    practice in communicating with other developers and documenting code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让学生花些时间分析这段代码。他们应该在浏览器控制台中尝试一些代码片段，理解各个部分，并在网上查找一些函数。让他们为代码添加注释，练习与其他开发人员沟通和文档编写。
- en: To keep the code compact and concise, the author has used a few somewhat advanced
    techniques. For example, the /[a-z]/i portion in the str.match() function is a
    *regular expression*, a powerful search pattern syntax. In this case, it checks
    for letters a through z. The .charCodeAt() function returns the Unicode value
    for the first letter in a string, so executing 'A'.charCodeAt() in the console
    will return “65.” Conversely, the String .fromCharCode() function converts a Unicode
    number identifier for a character into the character, so String.fromCharCode(65)
    will output “A.” Using these two functions, the author cleverly uses Unicode to
    shift the inputs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码简洁和紧凑，作者使用了一些相对高级的技术。例如，str.match()函数中的/[a-z]/i部分是一个*正则表达式*，这是一种强大的搜索模式语法。在这个案例中，它检查字母a到z。函数.charCodeAt()返回字符串中第一个字母的Unicode值，因此在控制台中执行'A'.charCodeAt()将返回“65”。相反，String.fromCharCode()函数将Unicode数字标识符转换为字符，因此String.fromCharCode(65)将输出“A”。通过这两个函数，作者巧妙地使用Unicode来对输入进行偏移。
- en: With comments, this procedure might look something like Listing 7-7.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 带有注释的话，这个过程可能看起来像列表7-7。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-7: Caesar cipher function with explanatory comments'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-7：带有注释的凯撒密码函数
- en: Now that students hopefully have a firm understanding of this procedure, ask
    them how they would, assuming the sender and receiver share the shift value, use
    this function to decode a message. How do we shift the encrypted message backward?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设学生已经对这个过程有了扎实的理解，问问他们，如果发送方和接收方共享偏移值，他们将如何使用这个函数解码一条信息。我们如何将加密信息向后移动？
- en: The answer is to make the shift negative, so 11 becomes −11, but your students
    shouldn’t expect their user decoders to know this. So let’s abstract away this
    finding into a function like the one in Listing 7-8\. Then users can invoke the
    more intuitive caesarCipherDecode('SPWWZ NWLDDXLEP',11) to decode the message.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是将偏移量设为负数，因此11变为−11，但你的学生不应该指望他们的用户解码器知道这一点。让我们把这个发现抽象成一个像列表7-8中的函数。然后用户可以调用更直观的caesarCipherDecode('SPWWZ
    NWLDDXLEP',11)来解码信息。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-8: Caesar cipher decode function'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-8：凯撒密码解码函数
- en: Cryptography in wartime and peacetime is a computational arms race. So next,
    have your students take the perspective of someone who wants to crack the cipher.
    Let’s say the code cracker has the encoded string but doesn’t know the shift to
    unlock it. What steps could they execute to find the shift value?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 战时与和平时期的密码学是一个计算的军备竞赛。所以接下来，让你的学生从想要破解密码的人的角度来思考。假设破解者有编码后的字符串，但不知道解锁它的偏移量。他们可以执行哪些步骤来找到偏移值？
- en: Because the alphabet has 26 letters, there are only 26 possible shifts if we
    include the zero shift. Cracking the code means taking an encoded string and methodically
    testing each of the possibilities. Once students have explained the algorithm
    for cracking the cipher, you can provide them with the code in Listing 7-9, which
    will execute it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字母表有26个字母，所以如果包括零偏移，共有26种可能的偏移方式。破解密码意味着获取一个编码后的字符串，并有条不紊地测试每一种可能性。一旦学生解释了破解密码的算法，你可以提供给他们列表7-9中的代码，这样他们就可以执行它。
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 7-9: The caesarCipherCracker function'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-9：caesarCipherCracker函数
- en: This code snippet is a *brute force search*, an algorithm that systematically
    tests every possibility. When your students execute the command in Listing 7-10,
    the function will output 26 rows of text showing the result of each shift value
    on the string input. When students find a row with a legible message, they’ve
    found the shift value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是一个*暴力破解搜索*，是一种系统性测试所有可能性的算法。当你的学生执行示例 7-10 中的命令时，函数将输出 26 行文本，显示每个移位值对输入字符串的结果。当学生找到一行可读的消息时，他们就找到了移位值。
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-10: Executing the caesarCipherCracker function'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-10：执行 caesarCipherCracker 函数
- en: The cryptographic arms race continues. With our Caesar cipher cracked, we need
    to make our algorithm more complex. There are lots of ways to do this, and you’ll
    have fun seeing what algorithms your students come up with. Listing 7-11 shows
    an example that adds a rotate variable to the mix, so the shift variable changes
    for each character in the string.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学的军备竞赛仍在继续。随着我们的凯撒密码被破解，我们需要使算法变得更复杂。有很多方法可以做到这一点，学生们会乐于看到他们自己提出的算法。示例 7-11
    显示了一个例子，添加了一个旋转变量，这样每个字符的移位变量都会有所不同。
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-11: Adding a rotating shift to the Caesar cipher'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-11：为凯撒密码添加旋转移位
- en: With a shift of 11 and a rotate of 3, the first character will shift 14, the
    second 17, the third 20, and so forth. With 26 possible shift values and 26 possible
    rotate values, a brute force cracker function would need to iterate over 625 possible
    combinations to find the two keys. In just one iteration, we’ve squared the number
    of steps in our algorithm as well as the processing power to execute our code.
    Thinking about code breaking efforts in World War II, we can see how so many innovations
    in computational techniques and advances in computing power emerged from this
    conflict. If we can exponentially increase the complexity of our encryption over
    a few coding lessons, think of how complex the art of cryptography has become
    over decades of iterations between those keeping data secure and those trying
    to access it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在移位 11 和旋转 3 的情况下，第一个字符将移位 14，第二个字符移位 17，第三个移位 20，依此类推。由于有 26 种可能的移位值和 26 种可能的旋转值，暴力破解函数将需要迭代
    625 种可能的组合来找到两个密钥。在一次迭代中，我们不仅增加了算法的步骤数量，也增加了执行代码所需的处理能力。回顾第二次世界大战中的密码破译工作，我们可以看到计算技术的诸多创新以及计算能力的进步正是在这一冲突中涌现出来的。如果我们能够在几节编程课中指数级增加加密的复杂性，想象一下，几十年来那些保护数据安全的人和试图访问数据的人之间反复的迭代，密码学艺术已经变得多么复杂。
- en: Computer science standards involving documentation, algorithm analysis and enhancement,
    iterative development, and cryptography were all covered in this one extensive
    exercise. The small code snippets used in this section are just a launching point.
    Students can continue to extend this code, adding layers of complexity to make
    their messages more secure. We can also use game-based incentives as students
    figure out how to crack those messages. Now that your students have iteratively
    developed a relatively simple code example into a more complex version, we can
    introduce them to an even more complicated and engaging example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及文档编制、算法分析与增强、迭代开发和密码学的计算机科学标准都在这一个广泛的练习中得到了涵盖。本节使用的小代码片段只是一个起点。学生们可以继续扩展这些代码，增加复杂性，使他们的信息更加安全。我们还可以通过基于游戏的激励措施来鼓励学生破解这些消息。现在，学生们已经将一个相对简单的代码示例逐步发展成更复杂的版本，我们可以向他们介绍一个更加复杂和引人入胜的例子。
- en: Adding an Interface
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加界面
- en: The exercise in this section builds on the concepts covered in the previous
    two exercises and adds a user interface to the mix. The interface offers ideal
    opportunities to visualize code outputs. The interface also adds event-driven
    triggers behind graphical elements, such as buttons, where users click these abstractions
    to execute functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的练习是在前两个练习的基础上构建的，并且增加了用户界面。这个界面提供了理想的机会来可视化代码输出。界面还增加了图形元素背后的事件驱动触发器，例如按钮，用户通过点击这些抽象元素来执行函数。
- en: In this exercise, students work with a function that generates random mazes.
    There are many kinds of maze-generation algorithms to explore. Each produces distinct
    maze styles. In this example, we’ll use a *randomized depth-first search* algorithm.
    Listing 7-12 shows the steps for this algorithm.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，学生将使用一个生成随机迷宫的函数。迷宫生成算法有很多种，每种算法产生不同风格的迷宫。在这个例子中，我们将使用一个*随机化深度优先搜索*算法。示例
    7-12 显示了该算法的步骤。
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 7-12: Steps in a randomized depth-first search algorithm'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-12：随机深度优先搜索算法的步骤
- en: The steps for this algorithm are simple to follow, but translating them into
    code can get very elaborate. The JavaScript code in Listing 7-13 is from the Rosetta
    Code website (*[https://rosettacode.org/wiki/Maze_generation](https://rosettacode.org/wiki/Maze_generation)*),
    which offers GNU Free Documentation Licensed examples of various algorithms in
    as many different programming languages as possible. This is just one of many
    code snippets you can use in your lesson.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的步骤很简单，但将它们转化为代码可能会变得非常复杂。列表 7-13 中的 JavaScript 代码来自 Rosetta Code 网站（* [https://rosettacode.org/wiki/Maze_generation](https://rosettacode.org/wiki/Maze_generation)
    *），该网站提供了多种编程语言中各种算法的 GNU 免费文档许可证示例。这只是你可以在课程中使用的许多代码片段之一。
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-13: The depth-first search algorithm JavaScript example from Rosetta
    Code'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-13：来自 Rosetta Code 的深度优先搜索算法 JavaScript 示例
- en: Depending on your students’ knowledge, you could have them read and document
    this code snippet to explain how it executes the depth-first search algorithm.
    Your students should take a moment to realize that this algorithm doesn’t draw
    the maze. It only returns the x, y dimensions of the maze and two arrays of horizontal
    and vertical Boolean values, so every true value in the array is where a wall
    is removed. The maze(x,y) function is UI independent. It will take another function
    to loop through the horizontal and vertical arrays, and to draw the lines as needed.
    As a result, you can reuse the code from the maze(x,y) function if you decide
    to switch out your UI. By separating the functions’ responsibilities so changes
    to one don’t impact the other, the code is modular and decoupled. Listing 7-14
    provides an example of taking the output of the maze(x,y) function and drawing
    it using characters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据学生的知识水平，你可以让他们阅读并记录这段代码，解释它是如何执行深度优先搜索算法的。你的学生应该花点时间意识到，这个算法并不绘制迷宫。它只返回迷宫的
    x、y 尺寸以及两个水平和垂直的布尔值数组，因此数组中的每个 true 值都是墙被移除的地方。maze(x, y) 函数与 UI 无关。它需要另一个函数来遍历水平和垂直数组，并根据需要绘制线条。因此，如果你决定更换
    UI，可以重用 maze(x, y) 函数中的代码。通过将函数的职责分开，使得对一个函数的修改不会影响另一个函数，代码变得模块化且解耦。列表 7-14 提供了一个示例，展示如何将
    maze(x, y) 函数的输出使用字符绘制。
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 7-14: Function that converts the output of the maze() function into
    text'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-14：将 maze() 函数的输出转换为文本的函数
- en: Students can then execute this code using the HTML <pre> tag in Listing 7-15
    and the JavaScript following it. The <pre> tag is for “preformatted text” and
    tells the browser to render everything between the opening and closing tags exactly
    as it’s typed with all spaces included.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 学生们可以使用列表 7-15 中的 HTML <pre> 标签和随后的 JavaScript 代码来执行这段代码。<pre> 标签表示“预格式化文本”，它告诉浏览器将开闭标签之间的内容按原样渲染，包括所有空格。
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7-15: Executing the display() function to output in the web page body'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-15：执行 display() 函数以在网页正文中输出
- en: Figure 7-4 shows sample output for this code. For the first line, the horizontal
    array values are [true, true, true, true, true, true, true, empty, true] and the
    vertical array values are [empty, empty, empty, empty, true, empty, true, true,
    true, true,].
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4 显示了此代码的示例输出。对于第一行，水平数组的值为 [true, true, true, true, true, true, true, empty,
    true]，垂直数组的值为 [empty, empty, empty, empty, true, empty, true, true, true, true]。
- en: '![](image/CitC07_04_textmaze.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](image/CitC07_04_textmaze.png)'
- en: 'Figure 7-4: Maze displayed with characters from the maze() function output'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：使用 maze() 函数输出的字符显示的迷宫
- en: This example uses pipes, plus signs, and minus signs to draw the maze in text.
    But it could just as well be drawn in the HTML <canvas> element, which allows
    for drawing images into an area of the browser window. Figure 7-5 shows a maze
    generated on an HTML canvas. The modularity of the maze-generating and maze-rendering
    functions allows for easily swapping out how we render the maze visually.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用管道符、加号和减号来绘制文本中的迷宫。但它同样可以绘制在 HTML <canvas> 元素中，该元素允许在浏览器窗口的一个区域内绘制图像。图
    7-5 显示了在 HTML canvas 上生成的迷宫。迷宫生成和渲染函数的模块化使得我们可以轻松更换渲染迷宫的方式。
- en: '![](image/CitC07_05_canvasmaze.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](image/CitC07_05_canvasmaze.png)'
- en: 'Figure 7-5: Maze rendered on an HTML canvas'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-5：在 HTML canvas 上渲染的迷宫
- en: The example maze generator in Listing 7-13 has the entire algorithm wrapped
    in one function, but other examples you find might break it up further. Perhaps
    using functions named getNeighbors(), removeWall(), and getRandomCell() to further
    decompose rendering the maze into many smaller problems. A powerful advantage
    to breaking up the algorithm this way is that it provides students with the ability
    to call each step in the maze-generating process individually and render the creation
    of the maze at each step in the process. Doing so animates the creation of the
    maze, and they can see the algorithm in action.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: As the educator, you should provide the code for students to play with and learn
    from. That includes the maze-generation algorithm, the maze-rendering algorithm
    in text, an algorithm rendering the maze on an HTML canvas, and the many functions
    to animate rendering the maze. Your students won’t need to write any code from
    scratch, just as you won’t; you’ll build code from the endless code samples other
    developers around the world provide online for everyone to learn from.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: You will provide this scaffolding code for the next iteration in the exercise,
    adding an avatar to the maze so students can navigate it in real time. Providing
    students with a set of functions like right(), left(), up(), and down() will challenge
    them to find the right combination of function calls to reach the exit. Once students
    write the functions to navigate the maze, they could add buttons to the interface,
    like those in Figure 7-6\. Then they would attach the navigation functions to
    these buttons using the JavaScript onclick() event handler, which triggers an
    assigned function when the user clicks the object with their mouse or touchpad.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/CitC07_06_navbuttons.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-6: Navigation buttons'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Just as the maze(x,y) function abstracts away the algorithm for generating a
    random maze, these buttons abstract away having to know the names of the left(),
    right(), up(), and down() functions to simple mouse clicks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: As students iteratively add functionality and interactivity to their mazes,
    they begin to make this microworld their own. They could add animation and sound
    effects to the interface for when the user bumps into a wall or reaches the goal.
    They could add an animated GIF image representing the player’s avatar. On a more
    advanced level, students could write the process mentioned in “Algorithms” on
    [page 64](CitC_c04.xhtml#_idTextAnchor061) to solve the maze automatically. Once
    they know how to automate solving the maze, they can use that knowledge to add
    an AI enemy to chase the player through the maze.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The options for extending this example are endless for you as the educator as
    well. Having students show off and share the code they use to enhance their projects
    allows them to document, communicate, and collaborate on extending the base application.
    Asking students for features to make their mazes more accessible to the visually
    impaired can further challenge them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你作为教育者来说，扩展这个例子的选项也是无穷无尽的。让学生展示并分享他们用来增强项目的代码，能够让他们记录、沟通并合作扩展基础应用程序。要求学生提供让迷宫对视障者更易接触的功能，能进一步挑战他们。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The three exercises we covered in this chapter involve you, the educator, providing
    code for students to understand, experiment with, and extend. In the first exercise,
    you provide students with as many examples as possible to show different ways
    to solve the same problem. Students compare, contrast, and form opinions on each
    of these methods and learn to articulate which they prefer and justify their preferences.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖的三个练习，涉及你作为教育者提供代码，让学生理解、实验并扩展。在第一个练习中，你为学生提供尽可能多的示例，展示解决同一问题的不同方法。学生们对这些方法进行比较、对比，并形成对每种方法的看法，学习表达他们的偏好，并为自己的选择提供理由。
- en: In our second exercise, you give students a simple encryption function. From
    this starting point, they alternate between figuring out how to crack the encryption
    and iteratively enhance the function to make it harder to crack. Cryptography
    and computational complexity are additional concepts tangential to this lesson.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个练习中，你会给学生一个简单的加密功能。从这个起点开始，他们在破解加密和迭代增强功能之间交替进行，以使其更难破解。密码学和计算复杂性是与本课相关的额外概念。
- en: Our third exercise includes understanding an existing function and adds a user
    interface where students can see the output of this function. From this starter
    code, students experiment with animating their algorithm’s maze output, adding
    a player to navigate the maze, and abstracting away the navigation function names
    behind clickable arrows. From here, students can follow their passions, adding
    functionality, collaborating with peers on their innovations, and making the code
    their own.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个练习包括理解一个现有的功能，并增加一个用户界面，学生可以在其中查看该功能的输出。从这段起始代码开始，学生们可以通过动画效果实验算法迷宫的输出，增加一个玩家来导航迷宫，并将导航功能的名称抽象化，通过可点击的箭头来实现。从这里开始，学生们可以根据自己的兴趣，添加功能，与同伴合作创新，并使代码成为自己的。
- en: Much of software development involves asking the right questions and finding
    the right existing solutions rather than writing new code from scratch. When students
    feel comfortable working with other people’s code, they have the power to assemble
    applications from prewritten functions. Having students practice working with
    existing code gives them a foundation for launching their own projects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分软件开发的工作都涉及提出正确的问题，并找到合适的现有解决方案，而不是从零开始编写新代码。当学生们能够熟练地使用他人的代码时，他们就有能力从预先编写好的功能中组装应用程序。让学生练习使用现有代码为他们启动自己的项目奠定了基础。
- en: In the next chapter, we’ll learn about projects that can benefit your school
    while students learn to work independently.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习那些可以让学生在独立工作的同时，也能为学校带来益处的项目。
