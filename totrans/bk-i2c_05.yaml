- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tools for Analyzing and Debugging I²C Transmissions
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: When designing I²C hardware and writing software to work with I²C hardware,
    you will often discover that software-based debuggers and `printf` statements
    are insufficient for quickly tracking down problems in the hardware and software.
    If you’re going to program I²C devices regularly, you will want to invest in some
    proper hardware tools to reduce debugging and testing effort.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses several of those tools, including multimeters, oscilloscopes,
    logic analyzers, bus monitors, and protocol analyzers. Although such tools cost
    money, using them will reduce the time you spend debugging code.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Generic Hardware Testing and Debugging Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re working with hardware devices (generic, not just I²C), there are
    a few tools you should have available in your tool chest:'
  prefs: []
  type: TYPE_NORMAL
- en: A digital multimeter (DMM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An oscilloscope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5-V, 3.3-V, and variable power supplies (0 V to 10 V, at the very least)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DMM comes in handy for checking the power supply pins on I²C devices, as
    well as any other DC signals. Most DMMs are worthless for measuring signals on
    pins whose voltage is changing, such as the SDA and SCL lines, because the DMM
    will average the voltage over a relatively long time frame, producing an inaccurate
    picture if the signal is not stable.
  prefs: []
  type: TYPE_NORMAL
- en: DMMs are also useful for measuring the pullup resistance on the I²C lines. In
    theory, you should be able to read the color codes or SMT resistor codes and figure
    out the resistance on the bus. However, if multiple pullups are scattered around
    the system, the resistor might be lower than what you expect. A quick ohm check
    between Vcc and the SDA or SCL lines could prove handy.
  prefs: []
  type: TYPE_NORMAL
- en: Some DMMs have a capacitance meter built into them. These are rarely good enough
    to measure the bus capacitance. Unless you have a *really expensive* DMM, don’t
    even bother trying to make such a measurement. The capacitance is usually too
    low for your average meter. On the other hand, capacitance meters that can handle
    low capacitances, and that might give you an idea of how bad the bus capacitance
    is in your system, are available for as little as $100\. Fortunately, you can
    observe the signals with an oscilloscope and determine if there is too much bus
    capacitance, so a capacitance meter isn’t necessary. It’s not worth buying one
    if you don’t already have one and can’t justify the purchase for other reasons.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, an oscilloscope isn’t absolutely necessary for debugging I²C signals,
    but it’s still a useful device for quickly determining whether signals are active
    and what the voltage levels are on those signals. As just noted, however, one
    useful reason for having an oscilloscope is that it allows you to monitor the
    analog condition of the signals appearing on the I²C bus. You can easily see if
    the voltage levels are reasonable—that is, not too high—and whether you’re getting
    huge voltage drops. An oscilloscope will also let you determine whether the bus
    capacitance has gotten out of control by showing you the rise times of the SCL
    and SDA signals. If it’s taking too long for these signals to rise, the devices
    on the bus might not register those signals as a logic 1\. For example, [Figure
    4-1](#figure4-1) shows the SCL line in a reasonable system. This image is on a
    100-kHz system with a Teensy 3.2 acting as the controller and an Adafruit ADS1115
    as the peripheral. It was wired together on a “wireless” breadboard (which are
    famous for having a high capacitance).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c04/f04001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: Oscilloscope image of the SCL line'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-2](#figure4-2) shows a really bad version of the clock signal, with
    a very slow rise time. In this particular case I attached a 470-pF capacitor across
    the SCL and Gnd lines to simulate an excessive bus capacitance. As you can see,
    the signal suffers considerable degradation. By the time the signal has risen
    enough to register as high, around 2 µsec have passed. This doesn’t leave the
    device that is putting a bit on the SDA line much time to do its job. These types
    of issues are most easily spotted using an oscilloscope, so oscilloscopes are
    handy to have around.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c04/f04002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: Oscilloscope image of the SCL line with high bus capacitance'
  prefs: []
  type: TYPE_NORMAL
- en: A “decent” oscilloscope, one that is good enough for debugging I²C signals,
    will probably cost you around $300 to $600\. Of course, a good, brand-name oscilloscope
    will cost you several thousand dollars. However, such devices are probably overkill
    for observing I²C bus signals. Unless you have other projects requiring the speed
    and features of such devices—or you really want to impress your friends—you can
    stick with one of the “advanced hobbyist” devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some really cheap devices (sub-$100 to around $200) use a low-end LCD display
    or connect to your computer. They might work for someone on an extreme budget,
    but at some point or another you’ll wind up buying a real oscilloscope if you
    actually use it regularly. As they say: “buy once, cry once.”'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Logic Analyzers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without question, the most important tool you should obtain when working with
    I²C hardware and software is a logic analyzer. Like oscilloscopes, logic analyzers
    come in all different shapes and sizes, with widely varying feature lists, and
    ranging in price from less than $30 to thousands of dollars.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the low end are two interesting devices that, despite their low price, are
    actually quite useful: the I²C Driver and the Bus Pirate. These two devices are
    probably more correctly called *bus monitors* or *bus drivers* rather than logic
    analyzers. While they have some of the features of an actual logic analyzer, the
    software support attached to these (open hardware or open software) projects isn’t
    quite up to par with that you would find on true logic analyzers.'
  prefs: []
  type: TYPE_NORMAL
- en: In the $300 to $500 range, things start to get more interesting. Total Phase
    offers several different I²C and SPI debugging modules. These devices connect
    to a PC (Windows, Linux, or macOS), and software running on those machines allows
    you to capture and manipulate the I²C data. (See “For More Information” at the
    end of this chapter for links to the Total Phase and other debugging modules this
    section describes.)
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting device, from Analog Devices (the IC manufacturer, which
    makes several I²C ICs), is the ADALM2000 Active Learning Module. This device is
    intended for student laboratories and supports a wide range of measurement and
    control options, I²C monitoring among them.
  prefs: []
  type: TYPE_NORMAL
- en: If you really want to spend some money, the BusPro-I from Corelis is a professional-level
    I²C bus analyzer available for around $1,700\. Corelis also has an advanced version
    (at greater cost, no doubt) that can emulate I²C controller and peripheral devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The devices I’ve described up to this point have been tools that were largely
    built for I²C and SPI measurement. For the most part, these devices are simple
    versions of what is known as a logic analyzer. A *logic analyzer* is similar to
    an oscilloscope insofar as it takes a sequence of readings over time and displays
    the state of those readings (typically on some sort of LCD display, which is either
    built into the logic analyzer or on a PC to which the logic analyzer connects).
    There are a couple of major differences between oscilloscopes and logic analyzers,
    however:'
  prefs: []
  type: TYPE_NORMAL
- en: Logic analyzers are inherently *digital* devices, whereas oscilloscopes are
    *analog* devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic analyzers tend to store data and display it after the fact, whereas oscilloscopes
    tend to be more real time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic analyzers often interpret the digital information they record according
    to some protocol (such as the I²C protocol), whereas oscilloscopes tend to display
    just raw analog data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic analyzers tend to capture many pieces (bits) of data simultaneously (often
    4 to 16 channels), whereas oscilloscopes are generally limited to 1 to 4 channels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all of these differences are absolute; for example, some storage oscilloscopes
    can also store data, and certain logic analyzers can display their data and analysis
    in real time. It is even possible to get a logic analyzer and oscilloscope built
    into the same box. For example, the Siglent SDS1104X-E is a 100-MHz scope with
    a 4-channel logic analyzer, and the Owon MSO8102T and Rigol MSO1104Z-S offer 16
    channels along with oscilloscope functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you’re spending someone else’s money, you can get some really
    fancy logic analyzers from Tektronix, Keysight Technologies, NCI Logic Analyzers,
    National Instruments, and other high-end professional instrumentation companies.
    However, if you don’t need gigahertz sampling rates, scores of input channels,
    and a fancy name, or if you’re having to foot the bill for this device from your
    own pocket, then you’ll probably need to look at something a little lower end.
  prefs: []
  type: TYPE_NORMAL
- en: In the $100 to $1,000 range, a wide variety of decent logic analyzers that are
    USB-based and connect to a PC are available; see “For More Information” for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, you’ll want to ask the following questions when looking for a logic
    analyzer:'
  prefs: []
  type: TYPE_NORMAL
- en: Does it support the protocols you’re interested in (I²C for the time being,
    but you’ll probably use it to debug SPI, CAN, and other bus protocols, too)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the software high quality, and does it run on your development machine?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it well documented?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there ongoing support (for example, software updates)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I own a Saleae Logic 8 and can vouch for the fact that it is a high-quality
    unit with great support. That is not to say that these other units I’ve listed
    aren’t also excellent (I don’t know, I’ve never used them) or that some other
    unit not listed here would also work out well for you. However, the Saleae units
    have been well-received by the engineering community. Perhaps the only complaint
    is that they are a bit pricey ($400 to $1,000), but that’s the price associated
    with high-quality hardware and software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of this chapter will concentrate on three of the devices mentioned
    to this point: the I²C Driver, the Bus Pirate, and the Saleae Logic 8.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 The I²C Driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The I²C Driver is a small board with a small-format color LCD display. It has
    three sets of I²C probes coming off the board; I’m not sure why it has more than
    one set, as the connectors all have the same signals and are wired together. It
    has a micro-USB port to connect to a Linux, Mac, or Windows PC.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the unit comes up, it displays any I²C activity on the little LCD display.
    While this is pretty, it’s not all that useful: I²C data transfer may be slow
    compared to other protocols, but it is still much faster than you can see on a
    display in real time.'
  prefs: []
  type: TYPE_NORMAL
- en: The real functionality lies in the software that runs on the PC at the other
    end of the USB cable. Excamera Labs, the outfit that developed the I²C Driver,
    supplies some Python code to support the I²C Driver. The software is crude and
    bare bones but about what you can expect for $30.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main Python software provides an interface like a command line (within
    Python). You perform various activities by manually calling Python functions.
    For example, if you want to do a bus scan to see what peripheral devices respond
    on the bus, enter the command `i2c.scan()` after the Python `>` prompt. The `i2c.scan()`
    function call displays something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: where `--` indicates that a device did not respond at the particular I²C address
    and a hexadecimal numeric value (48 being the only example here that corresponds
    to a responsive device address). In this case, I have a single Adafruit ADS1115
    ADC breakout board configured for address 0x48 installed on the I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'The I²C Driver Python software provides many additional commands you can execute
    or call from Python code you write. The call `help(i2cdriver)` displays the Python
    application programming interface (API). Some useful commands you can execute
    directly include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setspeed(speed)` Argument is 100 or 400 (corresponding to 100 kHz or 400 kHz,
    respectively)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setpullups(bitmask)` Argument is a 6-bit value specifying pullup values for
    the three I²C connectors (2 bits each, for SCL and SDA) on the I²C Driver'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reset()` Sends a bus reset (general call address)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`scan()` Scans the bus and displays addresses that respond'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`monitor(flag)` Turns on monitor mode if `flag` is true (nonzero); turns it
    off if `flag` is false (0)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getstatus()` Displays status information'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are also commands for starting an I²C bus transaction, writing data to
    the bus, reading data from the bus, and sending a stop command. However, those
    are operations you’d normally do within a Python program.
  prefs: []
  type: TYPE_NORMAL
- en: The I²C Driver software also has a GUI application that brings up the window
    shown in [Figure 4-3](#figure4-3). Click the **Monitor mode** button to activate
    monitor mode on the I²C Driver’s built-in LCD. Click the button again to turn
    monitor mode off. While not in monitor mode, select one of the addresses (if there
    is a device attached at that address) and read or write data to that device using
    the edit boxes at the bottom of the window.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c04/f04003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: I²C Driver GUI display on a Mac'
  prefs: []
  type: TYPE_NORMAL
- en: 'While there is activity on the I²C bus, click the **Capture mode** button to
    redirect I²C to a comma-separated values (*.csv*) file. Here’s a small sample
    of the data from one such file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While the I²C Driver was capturing data on the bus, I had a Teensy 3.2 talking
    to an Adafruit ADS1115 breakout board. Sadly, all the numbers this program displays
    are in decimal format, rather than the more useful hexadecimal format. The value
    72[10] is 0x48—the address of the ADS1115.
  prefs: []
  type: TYPE_NORMAL
- en: It would be easy enough to write some software to parse each of these lines
    and display the data in a more appropriate fashion. Unfortunately, timing information
    is missing from this display. However, it’s open source software, so feel free
    to go in and modify it if you would like a different output.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most interesting use of the I²C Driver capture mode is for generating
    test result data. You can run some tests with your I²C software for a controller
    or peripheral, capture the output, and then compare the output against known data
    or run the output through a filter program that examines it for correctness. This
    way of generating test results is a useful tool for semi-automating complex test
    procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Because the I²C Driver also lets you read and write data to an I²C peripheral,
    it’s also useful for checking the operation of a peripheral device you’ve created.
    You can manually write bytes to the device, read the response from the device,
    and verify the results are what you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Although the I²C Driver is not the be-all and end-all of I²C debugging tools,
    it’s an interesting tool. Furthermore, it provides a USB interface to the I²C
    bus, which you can program from your PC; see their website for details (link provided
    in “For More Information”). For less than $30, having this device in your toolbox
    is a no-brainer.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 The Bus Pirate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Bus Pirate is another open-hardware, less-than-$30 device you can use to
    analyze signals on the I²C bus. Whereas the I²C Driver is basically a USB-to-I²C
    device with a display bolted to it, the Bus Pirate is actually a small microcontroller
    (a PIC) that is programmed to read and write various digital I/O pins. Using bit-banging
    software, it emulates (slowly) the I²C protocol. Because it’s open hardware and
    software, is low cost, and has been around forever, the Bus Pirate has gained
    a tremendous following for people who want low-cost hardware hacking, analyzing,
    or testing capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The Bus Pirate is different from most of the other devices mentioned in this
    chapter because it doesn’t really have any PC-related software. The Bus Pirate
    looks like a serial device (USB-to-serial), so you operate the Bus Pirate using
    a serial terminal emulation program. You enter commands into the terminal and
    the Bus Pirate responds appropriately. In operation, this is similar to the command-line
    mode of the I²C Driver.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the Bus Pirate commands are single character inputs. The most important
    command for you to know is the `?` command. This is the help command that displays
    a list of all the commands to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Bus Pirate comes up in a special *Hi-Z* (high-impedance) mode,
    which basically turns all the outputs off to prevent any damage to the Bus Pirate
    or to any device connected to the Bus Pirate. You switch to a new mode by pressing
    **M**. This will present you with a menu to select the new operation mode (such
    as I²C mode). If you select I²C, it will ask you to input a bus frequency.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Bus Pirate is running in I²C mode, you can write data to the bus, read
    data from the bus, or monitor data on the bus (similar to the I²C Driver). See
    the Bus Pirate documentation for more details (link provided in “For More Information”).
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 The Saleae Logic Analyzers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the I²C Driver and Bus Pirate are useful devices for certain types
    of I²C monitoring, testing, and debugging, they aren’t true logic analyzers. They
    aren’t great at monitoring and displaying I²C information in near real time. Furthermore,
    although both devices can monitor—and to a certain extent, capture—data on the
    bus, they’re nearly useless for timing analysis like, for example, verifying each
    bit happens within a certain amount of time. This is where a real logic analyzer
    excels.
  prefs: []
  type: TYPE_NORMAL
- en: The Saleae Logic 8, Logic 8 Pro, and Logic 16 Pro devices are fully featured
    logic analyzers with 8 or 16 channels. The Logic 8 unit operates at 100 million
    samples per second (Msps), and the Logic 8 Pro or Logic 16 Pro units operate at
    500 Msps. Generally, you want your logic analyzer to run five to ten times faster
    than the fastest signal you need to capture, so the Logic 8 (100 Msps) is easily
    good for signals in the 10 MHz to 20 MHz range. This certainly covers all I²C
    frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: The devices themselves provide 8 or 16 probes to connect to your circuitry.
    For standard I²C measurements, you really need to connect only two of these probes,
    plus a ground wire. Having additional channels is useful because they let you
    check the status of other pins in your system during an I²C transmission. For
    example, if you’re sending data to a GPIO expander, you can connect some of the
    probes to input or output pins to see their levels change before, during, and
    after the I²C transmissions.
  prefs: []
  type: TYPE_NORMAL
- en: The Logic software that runs on a PC looks something like that appearing in
    [Figure 4-4](#figure4-4) (macOS version). The left side of the screen defines
    the signals; you can specify the names appearing here. The middle section of the
    screen displays the timing and protocol information, and the right side of the
    screen lets you choose the protocols to decode.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c04/f04004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: Logic software running on macOS'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **Start** button on the left side of the window initiates a capture
    operation. You can specify how much data to capture; I have my personal copy set
    up to capture data for two seconds. [Figure 4-5](#figure4-5) shows a typical data
    capture. As usual for this chapter, the logic analyzer is capturing the communication
    between a Teensy 3.2 and an ADS1115.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c04/f04005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: Logic software timing display'
  prefs: []
  type: TYPE_NORMAL
- en: Logic has been programmed to analyze an I²C data stream. As such, it displays
    the address byte and R/W command and each data byte passing on the bus. It’s not
    clear in this black-and-white image, but the display also marks the start and
    stop conditions with green and red dots on the data waveforms.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve shrunk this timing diagram so you can see a complete I²C transmission.
    However, Logic allows you to expand or shrink the timing diagram so you can adjust
    the level of detail. [Figure 4-6](#figure4-6) shows the expansion of the first
    (address) byte transmission from [Figure 4-5](#figure4-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c04/f04006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: A timing expansion in Logic'
  prefs: []
  type: TYPE_NORMAL
- en: Another nice feature in Logic is that you can move the cursor over a section
    of one of the timing signals and get timing information. [Figure 4-7](#figure4-7)
    shows what happened when I moved the cursor over one of the SCL clock pulses.
    Logic responded by displaying the width of the pulse and the frequency (5.12 µsec
    and 96.9 kHz). I made considerable use of this feature when working on the software-based
    I²C controller and peripheral implementations in the previous chapter. This is
    how I fine-tuned the delays to get the software I²C emulation running close to
    100 kHz.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c04/f04007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-7: Extracting timing information from Logic'
  prefs: []
  type: TYPE_NORMAL
- en: Logic also lets you set cursors within the timing diagrams so you can measure
    the time between any two arbitrary points, not just the width of some signal pulse.
    This comes in handy, for example, when measuring the time of a whole transmission
    rather than a single bit of a transmission.
  prefs: []
  type: TYPE_NORMAL
- en: At just under $400, the least expensive Saleae unit isn’t super cheap, but having
    one of these devices is a sound investment if you’re going to be debugging lots
    of I²C code and hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 A Final Comment on I²C Monitors and Logic Analyzers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because this is *The Book of I*^(*2*)*C*, the discussion of the analyzers in
    this chapter has centered on their use for debugging and analyzing I²C signals.
    In fact, most of the devices in this chapter support several other protocols as
    well, including SPI, CANBUS, MIDI, DMX, 1-Wire, and just about any typical protocol
    you can imagine. (The I²C Driver is the exception to this; it supports only I²C
    monitoring.) Therefore, the purchase of a device such as the Saleae Logic 8 is
    actually a good investment because you can use it for testing and debugging all
    kinds of hardware, not just I²C signals.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Chapter Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing software to work with I²C devices invariably requires testing and debugging
    said software. Such work is much easier accomplished using hardware testing and
    debugging tools. This chapter discussed several types of devices you can use for
    this purpose, including oscilloscopes, logic analyzers, and bus sniffers. It highlighted
    several commercially available options, including the I²C Driver, the Bus Pirate,
    and the Salae Logic Analyer. It also mentioned various combination oscilloscope
    and logic analyzer options and concluded by noting that these devices are useful
    for debugging other protocols, not just I²C devices, which makes them more universally
    applicable.
  prefs: []
  type: TYPE_NORMAL
