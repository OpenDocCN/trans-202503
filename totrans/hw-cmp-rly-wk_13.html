<html><head></head><body>
<span epub:type="pagebreak" id="page_291"/>&#13;
<h2 class="h2"><strong><span class="big">13</span><br/>MODERN COMPUTING</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindents">This chapter provides an overview of a few select areas of modern computing. Given the diversity and breadth in computing, I had a wide range of topics to choose from. The areas I chose are by no means an exhaustive list of the interesting things happening in computing today. Instead, they represent a handful of topics that I believe are worth your consideration. In this chapter we cover apps, virtualization, cloud computing, Bitcoin, and more. We wrap up with a final project that brings together many of the topics covered in this book.</p>&#13;
<h3 class="h3" id="lev1_95"><strong><span epub:type="pagebreak" id="page_292"/>Apps</strong></h3>&#13;
<p class="noindent">Since the early days of computing, people have referred to software programs that are used directly by users as <em>applications</em>. This term was shortened to <em>app</em> as a convenience, and in the past, the two terms were interchangeable. However, since Apple opened the iPhone <em>App Store</em> in 2008, the word <em>app</em> has taken on a distinct meaning. Although there is no standard technical definition for what makes a software program an app, apps tend to share a number of common characteristics.</p>&#13;
<p class="indent">Apps are designed for end users. Apps often target a mobile device, such as a smartphone or tablet. Apps are typically distributed through an internet-based digital storefront (an <em>app store</em>), such as Apple’s App Store, the Google Play Store, or the Microsoft Store. Apps have limited access to the system on which they run, and often must declare what specific capabilities they require to operate. Apps tend to use touchscreens as their primary means of user input. The term <em>app</em>, when used alone, usually implies software installed on a device that makes direct use of the operating system’s API. In other words, the term <em>app</em> usually means a <em>native app</em>, an app built for a particular operating system. In contrast, <em>web apps</em> are apps designed with web technology (HTML, CSS, and JavaScript), and are not tied to a particular OS. <a href="ch13.xhtml#ch13fig1">Figure 13-1</a> provides a high-level look at native apps and web apps.</p>&#13;
<div class="image" id="ch13fig1"><img src="../images/fig13-1.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-1: Native apps are built for a particular OS. Web apps are built using web technology.</em></p>&#13;
<p class="indent">As shown in <a href="ch13.xhtml#ch13fig1">Figure 13-1</a>, native apps are typically installed from an app store and are designed to utilize the capabilities of a specific operating system. Web apps typically run from a website and are designed to use web technologies. Web apps run in a browser or another process that renders web content. Let’s now look at both native apps and web apps in more detail.</p>&#13;
<h4 class="h4" id="lev2_49"><strong><em>Native Apps</em></strong></h4>&#13;
<p class="noindent">As mentioned earlier, native apps are built for a particular operating system. Apple’s App Store and the similar app stores that followed it ushered in a new era of native software development, giving developers new platforms to target, new methods of distributing their software, and new ways <span epub:type="pagebreak" id="page_293"/>to make money with software. The current state of native app development is largely focused on two platforms: iOS and Android. Software is certainly still developed for other operating systems, but often that software doesn’t have the typical characteristics of an app (mobile-friendly, touch-input based, distributed via an app store, and so forth).</p>&#13;
<p class="indent">Android and iOS differ in their programming languages, APIs, and more. Therefore, writing an app that runs on both iOS and Android requires either maintaining separate codebases or the use of a <em>cross-platform framework</em> like Xamarin, React Native, Flutter, or Unity. These cross-platform solutions abstract the underlying details of each operating system API, making it possible for developers to write code that can be built to run on multiple platforms. Many native apps also rely on web services, meaning that app developers must not only write and maintain code for iOS and Android, but they must also build or integrate with web services.</p>&#13;
<p class="indent">Developing a cross-platform, web-connected app requires a good deal of work and expertise! In the past, developers would often focus on just one platform, such as Windows PCs or Macs. Things are certainly more complicated today for the developer targeting multiple platforms and the web. Platform competition is generally a good thing for users, but it does mean more work for developers.</p>&#13;
<p class="indent">Interestingly, the current state of app development could have turned out quite differently. When the iPhone was announced in January 2007, Steve Jobs (Apple’s CEO at the time) had this to say about third-party app development on the iPhone:</p>&#13;
<p class="blockquote">The full Safari engine is inside of iPhone. And so, you can write amazing Web 2.0 and Ajax apps that look exactly and behave exactly like apps on the iPhone. And these apps can integrate perfectly with iPhone services. They can make a call, they can send an email, they can look up a location on Google Maps. And guess what? There’s no SDK that you need!</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>An</em> SDK (software development kit) <em>is a collection of software used by developers to build applications for a particular platform</em>.</p>&#13;
</div>&#13;
<p class="indent">Based on this quote, Apple’s original plan for third-party app development was to simply let developers build app-like websites that could make use of the iPhone’s capabilities. Native app development would be limited to the apps that Apple developed and included with the iPhone, such as the Camera, Mail, and Calendar apps.</p>&#13;
<p class="indent">At the time, using the web as a platform for application development wasn’t common. Apple’s position was forward-looking. Unfortunately, the underlying technologies of the web in 2007 were arguably not mature enough to position the web as a true app platform. By October 2007, Apple changed its message, announcing that Apple would allow developers to build native apps for the iPhone. Apple opened the App Store in 2008 as the only supported mechanism for distributing native iPhone apps to users.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_294"/>Apple’s policy reversal benefited the company, as the App Store became a source of revenue for Apple. There is a fee to register as an App Store developer, plus Apple takes a percentage of every sale. The App Store and native iPhone development also opened the door for exclusive content, apps that only worked on Apple devices.</p>&#13;
<p class="indent">The App Store also presents benefits to end users. A curated list of apps with ratings is helpful, and the store provides a measure of consumer trust. Apps that make it into the App Store must meet certain quality guidelines. A centralized payment service means users don’t have to give their payment information to multiple companies. Apps are automatically updated, an advantage over traditional PC software, although not an advantage over the web, since web apps are also updated without user involvement.</p>&#13;
<p class="indent">With the success of Apple’s App Store, other companies created similar digital storefronts for distributing software. The Google Play Store, Microsoft Store, and Amazon Appstore all operate on a similar model to Apple’s store and provide similar benefits. Although this system has generally worked well for these companies and for end users, it has also created a complex environment for developers: multiple stores, multiple platforms, and varying technologies. Each digital marketplace has its own requirements that app developers must meet, and each store takes a percentage of sales revenue.</p>&#13;
<h4 class="h4" id="lev2_50"><strong><em>Web Apps</em></strong></h4>&#13;
<p class="noindent">Alongside the rise of native apps, the web matured into a platform that’s quite capable of running apps. A mature version of HTML known as HTML5 was introduced, and web browsers became more capable and consistent in their handling of content. Browser developers made their implementations of JavaScript compliant with the ECMAScript 5 standard, providing a better foundation for JavaScript code. Outside of browser updates, the web developer community embraced (and continues to embrace) a concept known as <em>responsive web design</em>, an approach that ensures web content renders well no matter the size of screen on which it’s displayed. Using responsive design techniques, web developers can maintain a single website that works well across diverse devices, rather than creating separate websites that target different devices. Also, multiple <em>web development frameworks</em>, such as Angular and React, have been released in recent years. These frameworks make it easier for developers to write and maintain <em>web apps</em>—websites that behave like apps.</p>&#13;
<p class="indent">Developers have realized that modern web technology can be used to build experiences that closely resemble native apps, and many developers build websites that function as apps. Some developers have chosen to forgo native apps altogether and only build web apps. The advantages of this approach are that a web app will run on any device with a modern web browser, and the code only has to be written once. However, web apps also have some disadvantages. Web apps don’t have access to the full range of device capabilities, tend to be slower than native apps, require the user to be online, and generally aren’t listed in app stores.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_295"/>To address some of the disadvantages of web apps, <em>Progressive Web Apps (PWAs)</em> offer a set of technologies and guidelines that help bridge the gap between native apps and web apps. A PWA is just a website with a few extra features that help it be more app-like. A Progressive Web App must be served over HTTPS, render appropriately on mobile devices, be able to load while offline once downloaded, provide a manifest to the browser that describes the app, and transition quickly between pages. To the end user, running a PWA should feel as responsive and natural as running a native app. If a website meets the criteria for a PWA, modern web browsers give users the option of adding an icon for the PWA to their home screen or desktop. Doing so means that users can launch the web app just like they would launch a native app. The app opens in its own window, rather than in a browser window, and generally behaves like a native app.</p>&#13;
<p class="indent">PWAs can potentially offer great benefits to developers who wish to use web technologies for their apps but don’t want to build multiple apps for different platforms. However, there are still some drawbacks to PWAs. A significant one is that PWAs don’t appear in app stores. Mobile operating systems have been training users for years that apps should be obtained through app stores. Users aren’t accustomed to browsing to a web page to get an app. At the time of this writing, only the Microsoft Store allows PWAs to be published directly to the store. Other platforms expect PWAs to be installed from the browser or repackaged as a native app that renders the web content. This repackaged app can then be submitted to the store. Another potential drawback is that PWAs may not look like native apps; they will usually look essentially the same on all platforms, although some might consider this a good thing. PWAs still don’t have the performance of a native app or access to all the capabilities of the underlying platform, but depending on the needs of the app, this isn’t necessarily an issue.</p>&#13;
<h3 class="h3" id="lev1_96"><strong>Virtualization and Emulation</strong></h3>&#13;
<p class="noindent">When is a computer not a physical device? When it’s a virtual computer, of course! <em>Virtualization</em> is the process of using software to create a virtual representation of a computer. A related technology, <em>emulation</em>, allows applications designed for a certain type of device to run on a totally different type of device. In this section we explore both virtualization and emulation.</p>&#13;
<h4 class="h4" id="lev2_51"><strong><em>Virtualization</em></strong></h4>&#13;
<p class="noindent">A virtual computer, known as a <em>virtual machine (VM)</em>, runs an operating system just like a physical computer. In turn, applications run on that operating system. From the perspective of the application, the virtualized hardware acts like a physical computer. Virtualization enables several useful scenarios. A computer running one operating system can run another operating system in a virtual machine. For example, a computer running Windows can run an instance of Linux in a virtual machine. Virtual machines also allow datacenters to host multiple virtual servers on a single physical server. <span epub:type="pagebreak" id="page_296"/>This provides a way for internet hosting companies to easily and quickly provide dedicated servers to their customers, as long as the customer is fine with a virtual server. VMs can be easily backed up, restored, and deployed.</p>&#13;
<p class="indent">A <em>hypervisor</em> is a software platform that runs virtual machines. There are two types of hypervisors, as illustrated in <a href="ch13.xhtml#ch13fig2">Figure 13-2</a>.</p>&#13;
<div class="image" id="ch13fig2"><img src="../images/fig13-2.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-2: Type 1 and type 2 hypervisors</em></p>&#13;
<p class="indent">As shown on the left side of <a href="ch13.xhtml#ch13fig2">Figure 13-2</a>, a hypervisor can interact directly with underlying hardware, actually placing the hypervisor below the kernel in the technology stack. The hypervisor talks to the physical hardware and presents virtualized hardware to the OS kernel. This is known as a <em>type 1 hypervisor</em>. In contrast, <em>type 2 hypervisors</em>, shown on the right in <a href="ch13.xhtml#ch13fig2">Figure 13-2</a>, run as an application on an operating system. Microsoft’s Hyper-V and VMware ESX are type 1 hypervisors, whereas VMware Player and VirtualBox are examples of type 2 hypervisors.</p>&#13;
<p class="indent">Another popular approach for virtualization is the use of containers. A <em>container</em> provides an isolated user mode environment in which to run applications. Unlike a virtual machine, a container shares a kernel with the host OS and with other containers running on the same computer. A process running in a container can only see a subset of the resources available on the physical machine. For example, every container can be granted its own isolated filesystem. Containers provide the isolation of a VM without the overhead of running a separate kernel for each VM. In general, containers are limited to running the same operating system as the host since the kernel is shared. Some container technologies, like OpenVZ, are used to virtualize the entire user mode portion of operating systems, whereas others, like Docker, are used to run individual applications in isolated containers.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You may recall that an operating system process was also described as a “container” in <a href="ch10.xhtml">Chapter 10</a>—this isn’t the same thing as a virtualization container</em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_52"><strong><em><span epub:type="pagebreak" id="page_297"/>Emulation</em></strong></h4>&#13;
<p class="noindent">Emulation is the use of software to make one type of device behave like another type of device. Emulation and virtualization are similar in that they both provide a virtual environment for running software, but whereas virtualization offers up a slice of the underlying hardware, emulation presents virtual hardware that’s <em>unlike</em> the physical hardware in use. For example, a virtual machine or container running on an x86 processor runs software compiled for x86, directly making use of the physical CPU. In contrast, an <em>emulator</em> (a program that performs emulation) running on x86 hardware can run software compiled for a completely different processor. Emulators often also provide other virtual hardware besides the processor.</p>&#13;
<p class="indent">For example, a complete emulator for the Sega Genesis (a video game system from the 1990s) will emulate a Motorola 68000 processor, a Yamaha YM2612 sound chip, input controllers, and every other piece of hardware found in a Sega Genesis. At runtime, such an emulator translates CPU instructions originally designed to run on a Sega Genesis to capabilities implemented in x86 code. This introduces significant overhead, since each CPU instruction must be translated, but a sufficiently fast modern computer can still emulate the much slower Sega Genesis at full speed. The result is the ability to run software intended for one platform on a completely different platform, as shown in <a href="ch13.xhtml#ch13fig3">Figure 13-3</a>.</p>&#13;
<div class="image" id="ch13fig3"><img src="../images/fig13-3.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-3: Code compiled for System A can run on an emulator for System A</em></p>&#13;
<p class="indent">Emulation plays an important role in preserving software designed for obsolete platforms. As computing platforms age, it becomes increasingly difficult to find working hardware. Emulation is commonly used by software developers who want to bring old software to a modern platform. The original source code may be lost, or the task of modernizing it may be burdensome. In such cases, investing in an emulator allows the original compiled code to run on a new platform without modification.</p>&#13;
<span epub:type="pagebreak" id="page_298"/>&#13;
<div class="sidebar">&#13;
<p class="exercise"><strong>PROCESS VIRTUAL MACHINES</strong></p>&#13;
<p class="exercise-para">There’s another type of virtual machine that shares some traits with emulators. A <em>process virtual machine</em> runs an application within an execution environment that abstracts the details of the underlying operating system. It’s similar to an emulator in that it provides a platform for execution that’s decoupled from the hardware and OS on which it runs. However, unlike an emulator, a process VM isn’t trying to simulate real hardware. Rather, it provides an environment designed for running platform-independent software. As we discussed in <a href="ch09.xhtml">Chapter 9</a>, Java and .NET make use of process virtual machines that run bytecode.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_97"><strong>Cloud Computing</strong></h3>&#13;
<p class="noindent"><em>Cloud computing</em> is the delivery of computing services over the internet. In this section, we’ll look at various types of cloud computing, but first let’s quickly review the history of remote computing.</p>&#13;
<h4 class="h4" id="lev2_53"><strong><em>The History of Remote Computing</em></strong></h4>&#13;
<p class="noindent">Since the beginning of computing, we can observe a pendulum swing from remote, centralized computing (servers accessed from terminals), to local computing (desktop computers), and now back to remote computing (the web) accessed from smart, local devices (such as smartphones). Many applications today rely on a combination of remote computing and local computing. In the case of the web, some code runs in a browser and some code runs on a web server. The devices we carry in our pockets today are significantly more powerful than the room-sized computers from the early days of computing, yet much of what we want to do on those devices involves communicating with other computers, so it makes sense that the responsibility of processing should be shared between local devices and remote servers.</p>&#13;
<p class="indent">With this reemergence of remote computing came a need for organizations to maintain servers. In the past, this meant purchasing a physical server, configuring it as needed, connecting it to the network, and letting it run in a closet somewhere. The organization had physical access to the machine and complete control over its configuration. However, maintaining a server (or a fleet of servers) can be a complex and costly endeavor. This includes the costs of purchasing and maintaining hardware, keeping up with software updates, dealing with security concerns and capacity planning concerns, managing the networking configuration, and so forth. Often the skillset and expertise required for this work doesn’t align well with the purpose of an organization. Even a technology-focused company doesn’t necessarily want to be in the business of maintaining servers. This is where cloud computing comes in.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_299"/><em>Cloud computing</em> delivers remote computing capabilities over the internet (the <em>cloud</em>). Underlying hardware is maintained by a cloud services company (the <em>cloud provider</em>), freeing the organization or user in need of such capabilities (the <em>cloud consumer</em>) from maintaining servers. Cloud computing allows for the purchase of computing services on demand, as needed. For the cloud consumer, this means releasing control of certain things and trusting a third party to deliver reliable service. Cloud computing takes many forms; let’s look at some of those forms here.</p>&#13;
<h4 class="h4" id="lev2_54"><strong><em>The Categories of Cloud Computing</em></strong></h4>&#13;
<p class="noindent">The various categories of cloud computing are typically defined by the line that divides the responsibility between the cloud provider and the cloud consumer. <a href="ch13.xhtml#ch13fig4">Figure 13-4</a> provides an overview of four categories of cloud computing (IaaS, PaaS, FaaS, and SaaS) and their respective divisions of responsibility. We’ll look at each of these categories momentarily.</p>&#13;
<div class="image" id="ch13fig4"><img src="../images/fig13-4.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-4: Distribution of responsibility in various types of cloud offerings</em></p>&#13;
<p class="indent">The vertical stacks in <a href="ch13.xhtml#ch13fig4">Figure 13-4</a> represent the components needed to run an application. No matter which category of cloud computing is used, all the components need to be present—the difference across categories lies in whether the cloud provider or the cloud consumer is responsible for managing each component. The various components in each stack should look familiar, since we’ve covered these topics already. However, <em>runtime</em> requires an explanation. A <em>runtime environment</em> is the environment in which an application executes, including any needed libraries, interpreters, process virtual machines, and so forth. Let’s now cover the four categories of cloud computing shown in <a href="ch13.xhtml#ch13fig4">Figure 13-4</a>, progressing from left to right.</p>&#13;
<p class="indent"><em>Infrastructure as a Service (IaaS)</em> is a cloud computing scenario in which a cloud provider manages hardware and virtualization only, allowing the consumer to manage the operating system, runtime environment, application code, and data. A consumer of IaaS typically gets an internet-connected, <span epub:type="pagebreak" id="page_300"/>virtual computer to use as they see fit, typically as a server of some sort. This virtual computer is usually implemented as a hypervisor-based virtual machine or a container of the user mode portion of a Linux distribution. The consumer of an IaaS virtual server has access to the virtual computer’s operating system and is able to configure it however they wish. This gives the consumer maximum flexibility, but it also means that the responsibility of maintaining the system’s software (including the operating system, third-party software, and so forth) sits squarely on the shoulders of the consumer. IaaS provides a virtual computer, and the consumer is responsible for everything that runs on that computer. Here are some examples of IaaS: Amazon Elastic Compute Cloud (EC2), Microsoft Azure Virtual Machines, and Google Compute Engine.</p>&#13;
<p class="indent"><em>Platform as a Service (PaaS)</em> gives the cloud provider more responsibility. In a PaaS scenario, the cloud provider manages not only hardware and virtualization, but also the operating system and runtime environment that the consumer wishes to use. A PaaS consumer develops an application that’s targeted to run on their chosen cloud platform, taking advantage of the various capabilities that are unique to that platform. Cloud consumers of PaaS offerings don’t need to concern themselves with maintaining the underlying OS or runtime environment. The cloud consumer can just focus on their application code. Although the provider does abstract away the details of the underlying system, the consumer still needs to manage what resources are provisioned by the provider to handle their application. This includes the amount of storage required and the type of allocated virtual machines. PaaS provides a managed platform for running code, and the consumer is responsible for the application that runs on that platform. Here are some examples of PaaS: Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, and Google App Engine.</p>&#13;
<p class="indent"><em>Function as a Service (FaaS)</em> takes the PaaS model one step further. It does not require the consumer to deploy a full application or to provision platform instances ahead of time. Instead, a consumer only needs to deploy their code (a function) that runs in response to certain events. For example, a developer could write a function that returns the distance to the nearest grocery store. This function could run in response to a web browser sending its current GPS coordinates to a URL. This event-driven model means that the cloud provider is responsible for an on-demand invocation of the consumer’s code. The consumer no longer needs to have application code running all the time, waiting for requests. This can simplify things for the consumer and reduce costs, although it can mean a slower response time when a request comes in if the function code isn’t already running.</p>&#13;
<p class="indent">FaaS is a type of <em>serverless computing</em>, a cloud computing model where consumers do not have to deal with managing servers or virtual machines. Of course, the term is a misnomer; servers are actually required to run the code, it’s just that the consumer doesn’t have to think about them! FaaS provides an event-driven platform for running code, and the consumer is responsible for the code that runs in response to events. Some examples of FaaS include Amazon Web Services Lambda, Microsoft Azure Functions, and Google Cloud Functions.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_301"/><em>Software as a Service (SaaS)</em> is a fundamentally different type of cloud service. SaaS delivers an application to the consumer that’s fully managed in the cloud. Whereas IaaS, PaaS, and FaaS are for software engineering teams who want to run their own code in the cloud, SaaS delivers a complete cloud application to end users or organizations, already written. So much software runs in the cloud today that this may seem unremarkable, but it stands in contrast to a user or organization installing and maintaining software on their local devices and network. SaaS provides a complete application managed in the cloud, and the consumer is only responsible for the data they store in that application. Even management of data is partially handled by the provider, including the details of how the data is stored, backed up, and so forth. Some examples of SaaS include Microsoft 365, Google G Suite, and Dropbox.</p>&#13;
<p class="indent">Some of the major players in the cloud provider space are Amazon Web Services, Microsoft Azure, Google Cloud Platform, IBM Cloud, Oracle Cloud, and Alibaba Cloud.</p>&#13;
<h3 class="h3" id="lev1_98"><strong>The Deep Web and Dark Web</strong></h3>&#13;
<p class="noindent">You have probably read news about nefarious happenings on the dark web or the deep web. Unfortunately, the two terms are often confused, but they have distinct meanings. The web can be divided into three broad segments: the surface web, the deep web, and the dark web, as illustrated in <a href="ch13.xhtml#ch13fig5">Figure 13-5</a>.</p>&#13;
<div class="image" id="ch13fig5"><img src="../images/fig13-5.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-5: The surface web, deep web, and dark web</em></p>&#13;
<p class="indent">Content that’s freely available for anyone to access is part of the <em>surface web</em>. Public blogs, news sites, and public Twitter posts are all examples of surface web content. The surface web is indexed by search engines, and sometimes the surface web is defined as content that can be found with a search engine.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_302"/>The <em>deep web</em> is web content that cannot be accessed without logging in to a website or web service. Most internet users access deep web content on a regular basis. Checking your bank balance, reading your email through a website like Gmail, logging in to Facebook, looking at your personal shopping history on Amazon—these are all examples of deep web activities. The deep web is simply content that’s not publicly available and generally requires a password of some sort to access. Most users don’t want their email or bank balances to be publicly available, so there’s a good reason why this type of content isn’t public and cannot be indexed by search engines.</p>&#13;
<p class="indent">The <em>dark web</em> is web content that requires specialized software to access. You cannot access the dark web using only a standard web browser. The most prevalent dark web technology is <em>Tor (the onion router)</em>. Through a system of encryption and relays, Tor allows for anonymous access to the web, preventing a user’s ISP from monitoring which sites are accessed, and preventing sites from knowing their visitor’s IP address. Additionally, Tor allows users to access websites known as <em>onion services</em> that cannot be accessed at all without Tor—these sites are part of the dark web. Tor hides the IP addresses of onion services, making them anonymous as well. As you might expect, the anonymity of the dark web is sometimes exploited for criminal purposes. However, there are legitimate uses for the privacy afforded by the dark web, such as whistleblowing and political discussion. I recommend caution when accessing content on the dark web.</p>&#13;
<h3 class="h3" id="lev1_99"><strong>Bitcoin</strong></h3>&#13;
<p class="noindent">A <em>cryptocurrency</em> is a digital asset intended to be used for financial transactions, as a substitute for a traditional currency like the US dollar. Users of cryptocurrencies maintain a balance of that currency, much like at a traditional bank, and can spend their currency on goods and services. Some users treat cryptocurrencies primarily as an investment rather than a means of commerce, making it more akin to something like gold for those users. Unlike traditional currencies, cryptocurrencies are typically decentralized, with no single organization controlling their use.</p>&#13;
<h4 class="h4" id="lev2_55"><strong><em>Bitcoin Basics</em></strong></h4>&#13;
<p class="noindent">Introduced in 2009, <em>Bitcoin</em> was the first decentralized cryptocurrency, and it’s the most well-known today. Since then, a large number of alternate cryptocurrencies (known as <em>altcoins</em>) have sprung up, but none have challenged the dominance of Bitcoin. Bitcoin’s main unit of currency is also simply called <em>bitcoin</em>, abbreviated <em>BTC</em>.</p>&#13;
<p class="indent">Bitcoin and similar cryptocurrencies are based on <em>blockchain</em> technology. In a blockchain, information is grouped into data structures called <em>blocks</em>, and blocks are linked together chronologically. That is, when a new block is created, it’s added to the end of a blockchain. In the case of Bitcoin, blocks hold transaction records, tracking the movement of bitcoins. <a href="ch13.xhtml#ch13fig6">Figure 13-6</a> illustrates the Bitcoin blockchain.</p>&#13;
<span epub:type="pagebreak" id="page_303"/>&#13;
<div class="image" id="ch13fig6"><img src="../images/fig13-6.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-6: Bitcoin’s blockchain links chronological blocks of transaction records.</em></p>&#13;
<p class="indent">Blockchains operate over a network such as the internet, with multiple computers working together to process transactions and update the blockchain. The computers that work together to process Bitcoin transactions are known as the <em>Bitcoin network</em>. A computer that connects to the Bitcoin network is called a <em>node</em>, and certain nodes hold a copy of the blockchain; there is no single master copy. Encryption and decryption are employed to ensure the integrity of transactions and prevent tampering with the data in the blockchain. Once written, blockchain data is immutable—it can’t be changed. Bitcoin’s blockchain is a public, decentralized, immutable ledger of transactions. This ledger is used to record all events that occur on the Bitcoin network, such as the transfer of bitcoins.</p>&#13;
<h4 class="h4" id="lev2_56"><strong><em>Bitcoin Wallets</em></strong></h4>&#13;
<p class="noindent">An end user’s bitcoins are stored in a <em>Bitcoin wallet</em>. However, more accurately, a Bitcoin wallet holds a collection of cryptographic key pairs, as illustrated in <a href="ch13.xhtml#ch13fig7">Figure 13-7</a>.</p>&#13;
<div class="image" id="ch13fig7"><img src="../images/fig13-7.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-7: A Bitcoin wallet contains key pairs. A Bitcoin address is derived from a public key.</em></p>&#13;
<p class="indent">As shown in <a href="ch13.xhtml#ch13fig7">Figure 13-7</a>, each key pair in a wallet consists of two numbers—a private key and a public key. The <em>private key</em> is a randomly generated 256-bit number. This number must be kept secret; anyone who knows the private key can spend the bitcoins associated with the key pair. The <em>public key</em>, which is used to receive bitcoins, is derived from the private key. When <span epub:type="pagebreak" id="page_304"/>receiving bitcoins, the public key is represented as a <em>Bitcoin address</em>, a text string generated from the public key. Here’s an example Bitcoin address: <span class="literal">13pB1brJqea4DYXkUKv5n44HCgBkJHa2v1</span>.</p>&#13;
<p class="indent">Let’s say I have one bitcoin that I want to send you. This bitcoin is associated with an address that I control. That is, I have the private key for this address. If you give me the text string representation of a Bitcoin address that you control, I can send my bitcoin to your address. You don’t need to (and shouldn’t) send me your private key. I’m able to send my bitcoin to you because I have the private key for my address, which allows me to spend my bitcoin. Conversely, I can’t transfer any bitcoins out of your address because I don’t have your private key.</p>&#13;
<h4 class="h4" id="lev2_57"><strong><em>Bitcoin Transactions</em></strong></h4>&#13;
<p class="noindent">Let’s take a closer look at how this works. A transfer of bitcoins is known as a <em>transaction</em>. To send bitcoins, wallet software constructs a transaction specifying the details of the transfer, digitally signs it with a private key, and broadcasts the transaction to the Bitcoin network. The computers in the Bitcoin network verify the transaction and add it to a new block on the blockchain. <a href="ch13.xhtml#ch13fig8">Figure 13-8</a> illustrates a Bitcoin transaction.</p>&#13;
<div class="image" id="ch13fig8"><img src="../images/fig13-8.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-8: A Bitcoin transaction moves 0.5 bitcoin to address B (ignoring any transaction fee).</em></p>&#13;
<p class="indent">As shown in <a href="ch13.xhtml#ch13fig8">Figure 13-8</a>, a transaction contains inputs and outputs, representing where the bitcoin is coming from and going to. On the left of this figure we have a previous transaction, where only the output is shown; the input of the previous transaction isn’t relevant to our discussion. In the previous transaction, 0.5 BTC was sent to address A.</p>&#13;
<p class="indent">On the right side of <a href="ch13.xhtml#ch13fig8">Figure 13-8</a> we have a new transaction, which moves 0.5 BTC from address A to address B. For simplicity, this transaction has only a single input and single output. The input represents the source of the bitcoin to be transferred. You might expect this to be a Bitcoin address, but it isn’t. Instead, the input is the previous transaction’s output. Let’s say that address A is my address, and I want to send 0.5 bitcoin to your address, address B. Now, I know that previously 0.5 BTC was sent to my address, so I <span epub:type="pagebreak" id="page_305"/>can use that previous transaction’s output as an input to a new transaction, allowing me to send that 0.5 bitcoin to you. The output portion of a transaction contains the address where the bitcoin is sent.</p>&#13;
<p class="indent">Although you can think of an address as having a balance of bitcoin, the amount of bitcoin associated with an address isn’t stored in a Bitcoin wallet, nor is the balance directly stored in the blockchain. Instead, the history of transactions association with that address is stored in the blockchain, and from that history the balance for a certain address may be calculated. As a reminder, Bitcoin wallets simply contain the keys that enable Bitcoin transactions.</p>&#13;
<h4 class="h4" id="lev2_58"><strong><em>Bitcoin Mining</em></strong></h4>&#13;
<p class="noindent">The process of maintaining the Bitcoin blockchain is known as <em>Bitcoin mining</em>. Computers from around the globe add blocks of transactions to the blockchain—these computers are called <em>miners</em>. <a href="ch13.xhtml#ch13fig9">Figure 13-9</a> illustrates the process of mining bitcoins.</p>&#13;
<div class="image" id="ch13fig9"><img src="../images/fig13-9.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-9: Bitcoin mining</em></p>&#13;
<p class="indent">In order to add a block of transactions to the blockchain, a miner must verify the transactions included in the block (ensuring that each transaction is syntactically correct, that the input coins haven’t already been spent, and so forth), and it must also complete a computationally difficult problem. Requiring miners to solve such a problem prevents tampering with the blockchain, since altering a block would require solving the problem for the altered block and for every block that comes after it in the blockchain. This system of solving a difficult problem as a means of deterring unwanted behavior is known as <em>proof of work</em>.</p>&#13;
<p class="indent">Arriving at a solution to the computational problem involves a significant number of trial-and-error calculations. The solution is hard to produce <span epub:type="pagebreak" id="page_306"/>but easy to verify. The first miner to complete the problem is awarded a sum of bitcoins. This is how new bitcoins are generated and introduced into the system. In this way, Bitcoin mining is similar to traditional mining—miners perform work and may “strike gold” under the right circumstances. In addition to being awarded newly minted bitcoins, the miner is also able to claim a <em>fee</em> for each transaction included in the block, which is deducted from the total amount of bitcoins sent in the transaction. Bitcoin is designed to only allow for 21 million coins to be mined in total. Once this number is reached, Bitcoin miners will no longer be awarded bitcoins, and will instead rely on transaction fees to fund their operations.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise"><strong>BITCOIN BEGINNINGS</strong></p>&#13;
<p class="exercise-para">The Bitcoin blockchain began when the first block, known as the <em>genesis block</em>, was mined in 2009. This block was mined by Satoshi Nakamoto, who is credited with inventing Bitcoin. “Satoshi Nakamoto” is presumed to be a pseudonym; this person’s identity is disputed at the time of this writing.</p>&#13;
</div>&#13;
<p class="indent">For Bitcoin mining to be profitable, the costs of operating mining hardware must not exceed the value of bitcoins awarded. Bitcoin mining hardware tends to be power-hungry, and so the electricity bill for people mining Bitcoin can be high. Bitcoin was originally mined on regular computers, but today specialized, costly hardware is used to mine as quickly as possible (remember, the award goes to the first computer to solve the problem). These costs, plus the highly volatile price of bitcoins, mean that Bitcoin mining is not a guaranteed path to profit!</p>&#13;
<p class="indent">The Bitcoin blockchain is public—all transactions can be viewed by anyone. However, the blockchain contains no records of the personal identity of the people transferring bitcoins. So while an address’s balance and transaction history are public, there’s no easy way to tie that address to a human. For that reason, Bitcoin is attractive to those who wish to remain anonymous, such as those who run commerce sites on the dark web.</p>&#13;
<p class="indent">Blockchain technology is closely associated with cryptocurrencies, where it’s used as a financial ledger, but blockchains can be used for other purposes as well. Any system that needs a tamper-resistant history of records could make use of a blockchain. Time will tell if Bitcoin or other cryptocurrencies are successful in the long run, but regardless, we may see blockchain technology leveraged in other novel ways.</p>&#13;
<h3 class="h3" id="lev1_100"><strong>Virtual Reality and Augmented Reality</strong></h3>&#13;
<p class="noindent">Two technologies that have the potential to fundamentally change how we interact with computers are virtual reality (VR) and augmented reality (AR). <em>Virtual reality</em> is a form of computing that immerses a user in a three-dimensional virtual space, typically displayed by a headset. VR allows the <span epub:type="pagebreak" id="page_307"/>user to interface with virtual objects via a variety of input methods, including the user’s gaze, voice commands, and specialized handheld controllers. In contrast, <em>augmented reality</em> overlays virtual elements onto the real world, either through a headset or by the user looking “through” a handheld portable device, like a smartphone or tablet. VR immerses the user in another world; AR alters the real world.</p>&#13;
<p class="indent">Although various attempts at VR have been made for several decades, it wasn’t until the 2010s that VR became more mainstream. Google helped popularize VR in 2014 with <em>Google Cardboard</em>, named for the idea that a VR headset can be constructed from cardboard, lenses, and a smartphone. Specially-designed Cardboard apps present VR content to the user by rendering content for the left eye on half of the smartphone screen and content for the right eye on the other half of the screen, shown in <a href="ch13.xhtml#ch13fig10">Figure 13-10</a>.</p>&#13;
<div class="image" id="ch13fig10"><img src="../images/fig13-10.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-10: An app designed for Google Cardboard presenting in VR mode</em></p>&#13;
<p class="indent">Apps designed for Cardboard rely on the smartphone’s ability to detect gyroscopic movement, allowing the display to update as the user moves their head. Such a headset is said to have <em>3 degrees of freedom (3DoF)</em>; the headset can track limited head movement, but it cannot otherwise track movement in space. This allows a user to <em>look</em> around, but not <em>move</em> around using the headset. Cardboard also supports a basic one-button input. Cardboard is simple, but effective. It introduced VR to many users who probably wouldn’t have tried it otherwise.</p>&#13;
<p class="indent">A more immersive experience requires <em>6 degrees of freedom (6DoF)</em>; where the user can move around in VR by physically moving their body in real space. Some VR headsets support 6DoF, and VR controllers can have either 3DoF or 6DoF. A 6DoF controller, held in the user’s hand, can track the position of the controller in VR space, allowing for more natural interactions with the VR environment.</p>&#13;
<p class="indent">The consumer market has seen a number of VR solutions released since Google Cardboard. Some rely on smartphones (Samsung Gear VR, Google <span epub:type="pagebreak" id="page_308"/>Daydream). Others use a personal computer for processing, with a connected VR headset and controllers (Oculus Rift, HTC Vive, Windows Mixed Reality). Still others are standalone devices, not requiring a smartphone or PC (Oculus Go, Oculus Quest, Lenovo Mirage Solo). In general, the PC-connected solutions provide the highest graphical fidelity, and are also the most expensive, particularly when considering the cost of the required computer.</p>&#13;
<p class="indent">As mentioned earlier, augmented reality, or AR, is a similar but distinct technology. While VR attempts to completely immerse the user in a virtual world, AR overlays virtual elements onto the real world. This can be accomplished using a mobile device, where a rear-facing camera is used to observe the real world while simulated elements are overlaid on what is seen by the camera. Advanced AR techniques allow software to understand the physical elements in a room so that overlaid virtual elements can interact seamlessly with the environment. AR is implemented in basic form in mobile apps, but it’s more fully realized in dedicated devices such as Google Glass, Magic Leap’s headset, and Microsoft HoloLens. Such AR devices are worn on the head and superimpose computer generated graphics on a user’s field of view. Users are able to interact with virtual elements using various methods, such as voice commands or hand tracking.</p>&#13;
<p class="indent">The various VR and AR technologies (referred to together as <em>XR</em>) present multiple platforms for software developers to target. Many VR developers rely on existing game engines that are typically used for building 3D games, such as the Unity game engine or the Unreal game engine. These engines are familiar to game developers already, and they make it relatively easy for the developers to build their software for multiple VR platforms. Web developers can develop VR and AR content using JavaScript APIs known as <em>WebVR</em> and <em>WebXR</em>. Of the two, WebVR came first and was focused on VR specifically. WebXR followed, with support for both AR and VR.</p>&#13;
<h3 class="h3" id="lev1_101"><strong>The Internet of Things</strong></h3>&#13;
<p class="noindent">Traditionally we think of servers as providing services on the internet, and users interacting with those servers via internet-connected personal computing devices, such as PCs, laptops, and smartphones. In recent years we’ve seen the growth of new types of devices connecting to the internet—speakers, televisions, thermostats, doorbells, cars, lightbulbs, you name it! This concept of connecting all kinds of devices to the internet is known as the <em>Internet of Things (IoT)</em>.</p>&#13;
<p class="indent">Costs and physical size of electronic components are decreasing, Wi-Fi and cellular internet access are widespread, and consumers expect their devices to be “smarter.” All of this has contributed to the trend of connecting everything to the internet. IoT devices typically don’t operate without some kind of web service supporting them, so the rise of cloud computing has also furthered the spread of the Internet of Things. For consumers, IoT devices are prominent in the “smart home,” where all types of home appliances can be monitored and controlled. In business, IoT devices can be found in manufacturing, healthcare, transportation, and more.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_309"/>Although these types of connected devices bring clear benefits, these devices also introduce risks. Security of such devices is a particular area of concern. Not every IoT device is well secured against attacks from malicious parties. Even if the data on the device isn’t of interest to an attacker, the device can act as a foothold in an otherwise well-defended network, or it can be used as a launch point for a remote attack against a different target. Particularly for consumers, an IoT device seems innocuous enough, and security concerns often aren’t top of mind when connecting such a device to a home network.</p>&#13;
<p class="indent">Privacy is another risk presented by IoT devices. Many of these devices, by their nature, collect data. That data is often sent to a cloud service for processing. How much should end users trust the organizations that operate these services with their personal data? Even a well-intentioned organization can be a victim of a data breach, and user data may be exposed in unexpected ways. Devices like smart speakers must be listening all the time, waiting for verbal commands. This presents a risk of accidental recording of private conversations. Modern day readers of George Orwell’s novel <em>1984</em> may find a certain irony in seeing consumers of today willingly trading privacy for convenience.</p>&#13;
<p class="indent">Another risk with IoT devices is that their full functionality often depends on a cloud service. If a device’s internet connection goes down, that device may temporarily become less useful. A greater concern is that a device’s manufacturer will likely someday permanently turn off the service that supports the device. At that point, the smart device will revert to a dumb device!</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch13.xhtml#proj41">Project #41</a> on <a href="ch13.xhtml#page_311">page 311</a>, where you can use what you’ve learned about hardware, software, and the web to build a network-connected “vending machine” IoT device</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_102"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter we covered a variety of topics related to modern computing. You learned about apps, both native and web-based. You explored how virtualization and emulation allow computers to run software on virtualized hardware. You saw how cloud computing provides new platforms for running software. You learned how the surface web, deep web, and dark web differ, and how cryptocurrencies like Bitcoin enable decentralized payment systems. We touched on virtual reality and augmented reality and how they enable unique user interfaces for computing. You learned about IoT, and had an opportunity to build an internet-connected “vending machine.”</p>&#13;
<p class="indent">As we near the end of this book, let’s review some major computing concepts and see how they fit together. Computers are binary digital devices, where everything is represented as a 0 or 1, on or off. Binary logic, also known as Boolean logic, provides the foundation for computing operations. Computers are implemented using digital electrical circuits where voltage levels represent binary states—a low voltage is 0, and a high voltage <span epub:type="pagebreak" id="page_310"/>is 1. Digital logic gates are transistor-based circuits that enable Boolean operations such as AND and OR. Such logic gates can be arranged to create more complex circuits, such as counters, memory devices, and addition circuits. These types of circuits provide a conceptual foundation for computer hardware: a central processing unit (CPU) that executes instructions, random access memory (RAM) that stores instructions and data while powered, and input/output (I/O) devices that interact with the outside world.</p>&#13;
<p class="indent">Computers are programmable; they can perform new tasks without changing their hardware. Instructions that tell a computer what to do are known as software or code. CPUs execute machine code, whereas software developers typically write source code in a higher-level programming language. Computer programs typically run on an operating system—software that communicates with computer hardware and provides an environment for the execution of programs. Computers communicate using the internet, a globally connected set of computer networks that all use the TCP/IP protocol suite. A popular use of the internet is the World Wide Web, a set of distributed, addressable, linked resources, delivered by HTTP over the internet. All of these technologies provide an environment where modern computing innovations can flourish.</p>&#13;
<p class="indent">I hope this book has given you a fuller understanding of how computers work. We covered a great deal of ground, and yet we only scratched the surface of most topics. If some particular area grabbed your attention, I’d encourage you to continue learning about that subject—read about it online, take a class, watch videos, or buy another book! There’s a wealth of knowledge about computing to be discovered.</p>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_311"/>&#13;
<p class="exercise" id="proj41"><strong><span class="black1">PROJECT #41: USE PYTHON TO CONTROL A VENDING MACHINE CIRCUIT</span></strong></p>&#13;
<p class="exercise-para">Prerequisites: <a href="ch06.xhtml#proj7">Project #7</a> (on <a href="ch06.xhtml#page_105">page 105</a>) and #8 (on <a href="ch06.xhtml#page_107">page 107</a>) where you built a vending machine circuit. A Raspberry Pi, running Raspberry Pi OS. I recommend that you flip to <a href="appb.xhtml">Appendix B</a> and read the entire “Raspberry Pi” section on <a href="appb.xhtml#page_341">page 341</a> if you haven’t already.</p>&#13;
<p class="exercise-parai">In this project, you’ll use what you’ve learned about hardware, software, and the web to build a network-connected “vending machine” IoT device. Back in <a href="ch06.xhtml">Chapter 6</a> you built a vending machine circuit using push buttons, an LED, and digital logic gates. For this project, you’ll update that device. You’ll keep the buttons and LED, but you’ll replace the logic gates with Python code running on a Raspberry Pi. This will allow you to add capabilities in software easily, such as the ability to connect to the device over the network.</p>&#13;
<p class="exercise-parai">For this project, you’ll need the following components:</p>&#13;
<ul>&#13;
<li class="noindent_sidebar">Breadboard</li>&#13;
<li class="noindent_sidebar">LED</li>&#13;
<li class="noindent_sidebar">Current-limiting resistor to use with your LED; approximately 220Ω</li>&#13;
<li class="noindent_sidebar">Two switches or pushbuttons that fit a breadboard</li>&#13;
<li class="noindent_sidebar">Jumper wires, including 4 male-to-female wires</li>&#13;
<li class="noindent_sidebar">Raspberry Pi</li>&#13;
</ul>&#13;
<p class="exercise-parac"><strong><em>GPIO</em></strong></p>&#13;
<p class="exercise-para">Besides its tiny size and low cost, the Raspberry Pi has another feature that sets it apart from a typical computer—its GPIO pins. Each <em>general-purpose input/output (GPIO)</em> pin can be designated as an electrical input or output. When a pin acts as an input, code running on the Raspberry Pi can read the pin as high at 3.3V, or as low at 0V. The Raspberry Pi even has internal pull-up and pull-down resistors, enabled through software, so you no longer have to add such resistors to your input buttons. When a pin acts as an output, it can be set to high (3.3V) or low (0V), all controlled through software. Some pins are always set to ground, 5V, or 3.3V. The pins are referenced in software by number. <a href="ch13.xhtml#ch13fig11">Figure 13-11</a> shows the GPIO pin designations.</p>&#13;
<p class="exercise-parai">As you can see in <a href="ch13.xhtml#ch13fig11">Figure 13-11</a>, the GPIO numbers don’t correspond to the pin numbers. The pins, shown in the gray box, are simply numbered 1 through 40, starting in the upper left and ending in the lower right. For example, the second pin down on the left side is GPIO 2 and pin number 3. When you reference these GPIO pins in code, you need to use the GPIO number rather than the pin number.</p>&#13;
<span epub:type="pagebreak" id="page_312"/>&#13;
<div class="image" id="ch13fig11"><img src="../images/fig13-11.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-11: Raspberry Pi GPIO pins</em></p>&#13;
<p class="exercise-parac"><strong><em>BUILD THE CIRCUIT</em></strong></p>&#13;
<p class="exercise-para">Before writing any code, connect your circuit components to a breadboard and to the Raspberry Pi GPIO pins as shown in <a href="ch13.xhtml#ch13fig12">Figure 13-12</a>.</p>&#13;
<div class="image" id="ch13fig12"><img src="../images/fig13-12.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-12: Raspberry Pi vending machine circuit diagram</em></p>&#13;
<p class="exercise-parai">I’d recommend powering off your Raspberry Pi before connecting anything to the GPIO pins. For the connections between the GPIO pins and the breadboard, use a male-to-female jumper wire. You can connect the female end of the wire to the GPIO pin, and the male end of the wire to the breadboard.</p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_313"/>If you use the pin numbers shown in <a href="ch13.xhtml#ch13fig12">Figure 13-12</a>, the VEND LED, VEND button, and COIN button are connected to three consecutive GPIO pins on the Raspberry Pi. You also need to connect one of the GND pins (I’d recommend pin 9) to the breadboard’s negative power column, so you can easily connect the buttons and LED to ground.</p>&#13;
<p class="exercise-parai">You may have noticed that this circuit’s input switches are wired differently from the switches you used in <a href="ch06.xhtml#proj7">Project #7</a> (on <a href="ch06.xhtml#page_105">page 105</a>) and #8 (on <a href="ch06.xhtml#page_107">page 107</a>). In those projects, you connected a switch to 5V on one side and to a pull-down resistor/input pin on the other side. The circuit was designed so that an open switch was expected to be a low voltage, whereas a closed switch was expected to be a high voltage. Here, things are just the opposite—a closed switch is low, and an open switch is high. Internally, the Raspberry Pi pulls the GPIO pin high when the switch is open (or nothing is connected).</p>&#13;
<p class="exercise-parai"><a href="ch13.xhtml#ch13fig13">Figure 13-13</a> shows this circuit built on a breadboard.</p>&#13;
<div class="image" id="ch13fig13"><img src="../images/fig13-13.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 13-13: Raspberry Pi vending machine circuit on a breadboard</em></p>&#13;
<p class="exercise-parai">Once your circuit is connected and you have verified your connections, power on your Raspberry Pi. You may see the LED turn on, and that’s fine, since you haven’t run any code yet to set the LED to a particular state.</p>&#13;
<span epub:type="pagebreak" id="page_314"/>&#13;
<p class="exercise-parac"><strong><em>TEST YOUR CIRCUIT</em></strong></p>&#13;
<p class="exercise-para">Before entering the vending machine code, let’s write a simple program to test that the circuit is properly connected and to give you a feel for working with GPIO in Python. For interacting with the GPIO pins, we’re going to use <em>GPIO Zero</em>, a Python library that makes it easy to work with physical devices such as buttons and LEDs. Use the text editor of your choice to create a new file named <em>gpiotest.py</em> in the root of your home folder. Enter the following Python code into your text editor. Indentation matters in Python, so make sure you indent appropriately.</p>&#13;
<p class="programs">from time import sleep<span class="ent">❶</span><br/>&#13;
from gpiozero import LED, Button<span class="ent">❷</span><br/><br/>&#13;
button = Button(3)<span class="ent">❸</span><br/>&#13;
led = LED(2)<span class="ent">❹</span><br/><br/>&#13;
while True:<span class="ent">❺</span><br/>&#13;
    led.off()<br/>&#13;
    button.wait_for_press()<br/>&#13;
    led.on()<br/>&#13;
    sleep(1)</p>&#13;
<p class="exercise-parai">This simple program imports the <span class="literal">sleep</span> function <span class="ent">❶</span> and the <span class="literal">LED</span> and <span class="literal">Button</span> classes from the GPIO Zero library <span class="ent">❷</span>. It then creates a variable named <span class="literal">button</span> that represents the physical button on GPIO 3 <span class="ent">❸</span>. Similarly, an <span class="literal">led</span> variable is created to represent the LED connected to GPIO 2 <span class="ent">❹</span>. The program then enters an infinite loop <span class="ent">❺</span> that turns the LED off, waits for the button to be pressed, and then turns the LED on for one second before going through the loop again.</p>&#13;
<p class="exercise-parai">Once the file is saved, you can run it using the Python interpreter like so:</p>&#13;
<p class="programs">$ <span class="codestrong1">python3 gpiotest.py</span></p>&#13;
<p class="exercise-parai">When you start the program, nothing should happen at first, except perhaps the LED may turn off if it was previously on. If you press the button connected to GPIO 3, the LED should turn on for one second, and then turn off. You can repeat this as long as the program is running.</p>&#13;
<p class="exercise-parai">Our simple program didn’t include any graceful way to exit, so to end the program, press <small>CTRL</small>-C on the keyboard. When you exit the program in this way, the Python interpreter shows you a “Traceback” of the recent function calls—this is normal.</p>&#13;
<p class="exercise-parai">If the program doesn’t work as expected, double-check the code you entered and review “<a href="appb.xhtml#lev1_105">Troubleshooting Circuits</a>” on <a href="appb.xhtml#page_340">page 340</a>.</p>&#13;
<p class="exercise-parac"><strong><em>A VENDING MACHINE PROGRAM</em></strong></p>&#13;
<p class="exercise-para">In <a href="ch06.xhtml#proj7">Project #7</a> (on <a href="ch06.xhtml#page_105">page 105</a>) and #8 (on <a href="ch06.xhtml#page_107">page 107</a>), the vending machine’s logic was controlled by an SR latch, an AND gate, and a capacitor. You can now replace all of that with a program on the Raspberry Pi. This new design also gets rid of the COIN LED. Previously, the COIN LED turned on if a coin had been inserted. With this new design, the program instead prints the count of coin credits. Each time a coin is inserted, the credit count should go up one, and each time a vend operation occurs the credit count should go down by one.</p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_315"/>The requirements for this device are the following:</p>&#13;
<ul>&#13;
<li class="noindent_sidebar">Pressing the COIN button increases the credit count by one.</li>&#13;
<li class="noindent_sidebar">Pressing the VEND button simulates vending an item. If the credit count is greater than 0, the VEND LED briefly turns on and the credit count decreases by one. If the credit count is 0, nothing happens when the VEND button is pressed.</li>&#13;
<li class="noindent_sidebar">Every actionable button press, whether COIN or VEND, causes the program to print the current number of credits.</li>&#13;
</ul>&#13;
<p class="exercise-parai">Use the text editor of your choice to create a new file named <em>vending.py</em> in the root of your home folder. Enter the following Python code into your text editor:</p>&#13;
<p class="programs">from time import sleep<span class="ent">❶</span><br/>&#13;
from gpiozero import LED, Button<br/><br/>&#13;
vend_led = LED(2)<span class="ent">❷</span><br/>&#13;
vend_button = Button(3)<br/>&#13;
coin_button = Button(4)<br/>&#13;
coin_count = 0<span class="ent">❸</span><br/>&#13;
vend_count = 0<br/><br/>&#13;
def print_credits():<span class="ent">❹</span><br/>&#13;
    print('Credits: {0}'.format(coin_count - vend_count))<br/><br/>&#13;
def coin_button_pressed():<span class="ent">❺</span><br/>&#13;
    global coin_count<br/>&#13;
    coin_count += 1<br/>&#13;
    print_credits()<br/><br/>&#13;
def vend_button_pressed():<span class="ent">❻</span><br/>&#13;
    global vend_count<br/>&#13;
    if coin_count &gt; vend_count:<br/>&#13;
        vend_count += 1<br/>&#13;
        print_credits()<br/>&#13;
        vend_led.on()<br/>&#13;
        sleep(0.3)<br/>&#13;
        vend_led.off()<br/><br/>&#13;
coin_button.when_pressed = coin_button_pressed<span class="ent">❼</span><br/>&#13;
vend_button.when_pressed = vend_button_pressed<br/><br/>&#13;
input('Press Enter to exit the program.\n')<span class="ent">❽</span></p>&#13;
<p class="exercise-parai">First, the code imports the <span class="literal">sleep</span> function, <span class="literal">LED</span> class, and <span class="literal">Button</span> class <span class="ent">❶</span>, all of which are used later in the program. Next, three variables are declared that represent the physical components attached to GPIO pins—<span class="literal">vend_led</span> on GPIO 2, <span class="literal">vend_button</span> on GPIO 3, and <span class="literal">coin_button</span> on GPIO 4 <span class="ent">❷</span>. The variable <span class="literal">coin_count</span> is declared to track the number of times the COIN button has been pressed, and the variable <span class="literal">vend_count</span> tracks the number of times that a vending operation has occurred <span class="ent">❸</span>. These two variables are used to calculate the number of credits.</p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_316"/>The <span class="literal">print_credits</span> function <span class="ent">❹</span> prints the number of available credits, which is simply the difference between <span class="literal">coin_count</span> and <span class="literal">vend_count</span>.</p>&#13;
<p class="exercise-parai">The <span class="literal">coin_button_pressed</span> function <span class="ent">❺</span> is the code that runs when the COIN button is pressed. It increments <span class="literal">coin_count</span> and prints the number of credits. The <span class="literal">global coin_count</span> statement allows the global variable <span class="literal">coin_count</span> to be modified within the <span class="literal">coin_button_pressed</span> function.</p>&#13;
<p class="exercise-parai">The <span class="literal">vend_button_pressed</span> function <span class="ent">❻</span> is the code that runs when the VEND button is pressed. If there are credits remaining (<span class="literal">coin_count &gt; vend_count</span>), then the function increments <span class="literal">vend_count</span>, prints the number of credits, and turns the LED on for 0.3 seconds.</p>&#13;
<p class="exercise-parai">Setting <span class="literal">coin_button.when_pressed = coin_button_pressed</span> <span class="ent">❼</span> associates the <span class="literal">coin_button_pressed</span> function with <span class="literal">coin_button</span> on GPIO 4 so that the function runs when the button is pressed. Similarly, <span class="literal">vend_button_pressed</span> is associated with <span class="literal">vend_button</span>.</p>&#13;
<p class="exercise-parai">Finally, we call the <span class="literal">input</span> function <span class="ent">❽</span>. This function prints a message to the screen and waits for the user to press the <small>ENTER</small> key. This is a simple way to the keep the program running. Without this line of code, the program would reach its end and stop running before the user had a chance to interact with the buttons.</p>&#13;
<p class="exercise-parai">Once the file is saved, you can run it using the Python interpreter like so:</p>&#13;
<p class="programs">$ <span class="codestrong1">python3 vending.py</span></p>&#13;
<p class="exercise-parai">When you start the program, you should immediately see <span class="literal">Press Enter to exit the program</span> displayed to the terminal window. At this point try pressing the COIN button, which is connected to GPIO 4. You should see the program print <span class="literal">Credits: 1</span>. Next try pressing the VEND button. The LED should briefly light up, and the program should print <span class="literal">Credits: 0</span>. Try pressing the VEND button again—nothing should happen. Try pressing COIN and VEND multiple times and make sure the program works as expected. When you’re finished testing the program, press <small>ENTER</small> to end the program.</p>&#13;
<p class="exercise-parai">As you can see, a Raspberry Pi, or similar device, can replicate in software the same logic that we previously implemented in hardware. However, a software-based solution is much easier to modify. New features can be added by changing a few lines of code rather than adding new chips and wiring. A Raspberry Pi is actually overkill for what we wanted to do here; the same thing could be accomplished with a less capable computing device at even lower cost, but the principle is the same.</p>&#13;
<p class="exercise-parac"><strong><em>AN IOT VENDING MACHINE</em></strong></p>&#13;
<p class="exercise-para">Let’s say that the operator of the vending machine wants to be able to check the machine’s status remotely, over the internet. Since you’re using a Raspberry Pi for your vending machine’s logic, you can take things a step further and make this an IoT vending machine! You can add a simple web server to the program, allowing someone to connect to the device’s IP address from a web browser and see how many times a coin has been inserted and how many times a vending operation occurred.</p>&#13;
<p class="exercise-parai">Python makes this relatively easy, because it includes a simple web server library, <span class="literal">http.server</span>. You just need to construct some HTML that includes the data you want to send and write a handler for incoming <span class="literal">GET</span> requests. You also need to start the web server when the program begins.</p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_317"/>Use the text editor of your choice to edit your existing <em>vending.py</em> file in the root of your home folder. Start by inserting the following import statement as the first line of the file (leaving all the existing code intact, just shifted down a line):</p>&#13;
<p class="programs">from http.server import BaseHTTPRequestHandler, HTTPServer</p>&#13;
<p class="exercise-parai">Next, remove the entire <span class="literal">input</span> line at the bottom of the file and add this code to the end of the file:</p>&#13;
<p class="programs">HTML_CONTENT = """<br/>&#13;
&lt;!DOCTYPE html&gt;<br/>&#13;
&lt;html&gt;<br/>&#13;
  &lt;head&gt;&lt;title&gt;Vending Info&lt;/title&gt;&lt;/head&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
    &lt;h1&gt;Vending Info&lt;/h1&gt;<br/>&#13;
    &lt;p&gt;Total Coins Inserted: {0}&lt;/p&gt;<br/>&#13;
    &lt;p&gt;Total Vending Operations: {1}&lt;/p&gt;<br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;<br/>&#13;
"""<br/>&#13;
<br/>&#13;
class WebHandler(BaseHTTPRequestHandler):<span class="ent">❶</span><br/>&#13;
    def do_GET(self):<span class="ent">❷</span><br/>&#13;
        self.send_response(200)<span class="ent">❸</span><br/>&#13;
        self.send_header('Content-type', 'text/html')<span class="ent">❹</span><br/>&#13;
        self.end_headers()<br/>&#13;
        response_body = HTML_CONTENT.format(coin_count, vend_count).encode()<span class="ent">❺</span><br/>&#13;
        self.wfile.write(response_body)<br/><br/>&#13;
print('Press CTRL-C to exit program.')<br/>&#13;
server = HTTPServer(('', 8080), WebHandler)<span class="ent">❻</span><br/>&#13;
try:<span class="ent">❼</span><br/>&#13;
    server.serve_forever()<span class="ent">❽</span><br/>&#13;
except KeyboardInterrupt:<br/>&#13;
    pass<br/>&#13;
finally:<br/>&#13;
    server.server_close()<span class="ent">❾</span></p>&#13;
<p class="exercise-parai"><span class="literal">HTML_CONTENT</span> is a multiline string that defines the HTML code that the program sends over the network. This block of HTML code represents a simple web page with a <span class="literal">&lt;title&gt;</span>, a <span class="literal">&lt;h1&gt;</span> heading, and two <span class="literal">&lt;p&gt;</span> paragraphs that describe the state of the vending machine. Specific values in these paragraphs are represented as placeholders <span class="literal">{0}</span> and <span class="literal">{1}</span>. These values are filled in by the program when it runs. Since this is HTML, the spacing and line breaks within this string don’t matter.</p>&#13;
<p class="exercise-parai">The <span class="literal">WebHandler</span> class <span class="ent">❶</span> describes how the web server handles incoming HTTP requests. It inherits from the <span class="literal">BaseHTTPRequestHandler</span> class, meaning that it has the same methods and fields as <span class="literal">BaseHTTPRequestHandler</span>. However, this just gives you a generic HTTP request handler; you still <span epub:type="pagebreak" id="page_318"/>need to specify how your program will respond to specific HTTP requests. In this case, the program only needs to respond to HTTP <span class="literal">GET</span> requests, so the code defines the <span class="literal">do_GET</span> method <span class="ent">❷</span>. This method is invoked when a <span class="literal">GET</span> request comes to the server, and it replies with the following:</p>&#13;
<ul>&#13;
<li class="noindent_sidebar">A <span class="literal">200</span> status code indicating success <span class="ent">❸</span></li>&#13;
<li class="noindent_sidebar">A <span class="literal">Content-type: text/html</span> header that tells the browser to expect the response to be HTML <span class="ent">❹</span></li>&#13;
<li class="noindent_sidebar">The HTML string that was defined earlier, but with the two placeholders replaced by the values of <span class="literal">coin_count</span> and <span class="literal">vend_count</span> <span class="ent">❺</span></li>&#13;
</ul>&#13;
<p class="exercise-parai">A web server instance is created using the <span class="literal">HTTPServer</span> class <span class="ent">❻</span>. Here you specify that the server name can be anything and that the HTTP server listens on port 8080 <span class="literal">('', 8080)</span>. This is also where you specify to use the <span class="literal">WebHandler</span> class for inbound HTTP requests.</p>&#13;
<p class="exercise-parai">The web server starts with <span class="literal">server.serve_forever()</span> <span class="ent">❽</span>. This is placed in a <span class="literal">try/except/finally</span> block <span class="ent">❼</span> so that the server continues running until a <span class="literal">KeyboardInterrupt</span> exception occurs (generated by <small>CTRL</small>-C). When this happens, <span class="literal">server.server_close()</span> is called to clean up, and the program ends <span class="ent">❾</span>.</p>&#13;
<p class="exercise-parai">Once the file is saved, you can run the file using the Python interpreter like so:</p>&#13;
<p class="programs">$ <span class="codestrong1">python3 vending.py</span></p>&#13;
<p class="exercise-parai">The program should behave as it did before when you press the COIN or VEND buttons. However, now you can also connect to the device from a web browser and see data about the vending machine. To do this, you need a device on the same local network as the Raspberry Pi, unless your Pi is directly connected to the internet with a public IP address, in which case any device on the internet should be able to connect to it. If you don’t have another device, you can launch a web browser on the Raspberry Pi itself and let the Raspberry Pi act as both the client and server.</p>&#13;
<p class="exercise-parai">You need to find the IP address of your Raspberry Pi. We did this in <a href="ch11.xhtml#proj30">Project #30</a> on <a href="ch11.xhtml#page_255">page 255</a> if you want to review the details, but this is the command you want to use:</p>&#13;
<p class="programs">$ <span class="codestrong1">ifconfig</span></p>&#13;
<p class="exercise-parai">Once you have the IP address of your Raspberry Pi, open a web browser on the device you want to use as your client. In the address bar, enter the following: <span class="literal">http://IP:8080</span>, replacing <span class="literal">IP</span> with your Raspberry Pi’s IP address. The end result should look something like this: <span class="literal">http://192.168.1.41:8080</span>. Once you’ve entered this into the browser’s address bar, you should see the web page load with the count of coins and vending operations. Each time you request this page, you should see the Python program print information about the request to the terminal. Once the web page is loaded, it won’t automatically reload, so if you press the COIN or VEND buttons additional times and want to see the latest values, you need to refresh your browser’s view of the page. To stop this program, use <small>CTRL</small>-C on the keyboard.</p>&#13;
<p class="exercise-parai">Recall from <a href="ch12.xhtml">Chapter 12</a> that websites are either static or dynamic. The site you ran in the <a href="ch12.xhtml">Chapter 12</a> projects was static—it served content that was built ahead of time. In contrast, the vending machine site in this chapter is dynamic. It generates an HTML response when a request comes in. Specifically, it updates the coin and vending values in the HTML content before responding.</p>&#13;
<p class="exercise-parai">As a bonus challenge, try modifying the program to also display the “credits” value on the web page. This value should match the last credits value that was printed to the terminal.</p>&#13;
</div>&#13;
</body></html>