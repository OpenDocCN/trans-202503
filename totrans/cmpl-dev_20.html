<html><head></head><body>
<section epub:type="appendix" role="doc-appendix" aria-labelledby="appB">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="appB">&#13;
<span class="CN" id="appendix-B"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_263" aria-label=" Page 263. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">B</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">THE NEXT.JS APP DIRECTORY</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In version 13, Next.js introduced a new routing paradigm that uses an <i>app</i> directory instead of the <i>pages</i> directory. This appendix discusses this new feature so that you can explore 		it further on your own. As there are no plans to deprecate the <i>pages</i> directory, you can continue using the routing approach you learned in <span class="chapterintro_Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. You can even use both directories simultaneously; just be careful not to add to both directories folders and files that would create the same route, as this could cause errors.</p>&#13;
<p class="TX">Both the <i>app</i> and <i>pages</i> directories use folders and files to create routes. However, the <i>app</i> directory distinguishes between server and client components. In the <i>pages</i> folder, everything is a <i>client component</i>, meaning that all the code is part of the JavaScript bundle Next.js sends to the client. But <span role="doc-pagebreak" epub:type="pagebreak" id="pg_264" aria-label=" Page 264. "/>every file in the <i>app</i> directory is a <i>server component</i> by default, and its code is never sent to the client.</p>&#13;
<p class="TX">This appendix takes a look at the basic concepts of the new approach and then initializes a Next.js application using the new structure.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-98"/><samp class="SANS_Futura_Std_Bold_B_11">Server Components vs. Client Components</samp></h3>&#13;
<p class="TNI">The terms <i>client</i> and <i>server</i> in this context refer to the environments in which the Next.js runtime renders a component. The client environment is the user’s environment (usually the browser), whereas the server refers to the Next.js server that receives the request from the client, whether it runs on your local host or in a remote location.</p>&#13;
<p class="TX">With the introduction of server components, Next.js no longer purely uses client-side routing. In <i>server-centric</i> routing, the server renders components and then sends the rendered code to the client. This means the client doesn’t download a routing map, which reduces the initial page size. Additionally, the user doesn’t have to wait until all resources have loaded before the page becomes interactive. Next.js server components leverage React’s streaming architecture to progressively render each component’s content. With this model, the page becomes interactive before it has finished loading.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-172"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Server Components</samp></h4>&#13;
<p class="TNI">Next.js server components build upon the React server components that have been available since React version 18. Because the server renders these components, they don’t add anything to the JavaScript sent to the client, reducing the overall page size and increasing page performance scores. Also, the JavaScript bundle is cacheable, so the client won’t redownload it when we add new additional server components, only when we add new client-side scripts through additional client components.</p>&#13;
<p class="TX">In addition, because these components are rendered completely on the server, they can contain sensitive server information, such as access tokens and API keys. (To add an additional layer of protection, Next.js’s rendering engine replaces with an empty string all environment variables that are not explicitly prefixed with <samp class="SANS_TheSansMonoCd_W5Regular_11">NEXT_PUBLIC</samp>.) Finally, we can use large-scale dependencies and additional frameworks without bloating the client-side scripts and access backend resources directly, increasing the application’s performance.</p>&#13;
<p class="TX"><a href="appendix-B.xhtml#LisB-1">Listing B-1</a> shows the basic structure of a server component.</p>&#13;
<span id="LisB-1"/>&#13;
<pre class="pre-275"><code>export default async function ServerComponent(props: WeatherProps): Promise&lt;JSX.Element&gt; {&#13;
&#13;
    return (&#13;
      &lt;h1&gt;The weather is {props.weather}&lt;/h1&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-1: A basic server component</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_265" aria-label=" Page 265. "/>In <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, you learned that a React component is a JavaScript function that returns a React element; Next.js server components follow that same structure, except that they’re asynchronous functions, so we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> pattern with <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>. Thus, instead of returning the React element, it returns a promise of it. The code in <a href="appendix-B.xhtml#LisB-1">Listing B-1</a> should remind you of the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp> created in the previous chapters, except it doesn’t contain any client-side code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-173"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Client Components</samp></h4>&#13;
<p class="TNI">By contrast, a client component is a component rendered by the browser rather than by the server. You already know how to write client components, because all React and Next.js components were traditionally client components.</p>&#13;
<p class="TX">To render these components, the client needs to receive all required scripts and their dependencies. Each component increases the bundle size, decreasing the application’s performance. For that reason, Next.js offers options to optimize the application’s performance, such as server-side rendering (SSR), which pre-renders the pages on the server, then lets the client add interactive elements to the page.</p>&#13;
<p class="TX">All components in the <i>app</i> directory are server components by default. Client components, however, can reside anywhere (for example, in the <i>components</i> directory we’ve used previously). <a href="appendix-B.xhtml#LisB-2">Listing B-2</a> shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp> created in <a href="chapter5.xhtml#Lis5-4">Listing 5-4</a> refactored into a client component that works with the <i>app</i> directory.</p>&#13;
<span id="LisB-2"/>&#13;
<pre class="pre-276"><code>"use client";&#13;
&#13;
import React, {useState, useEffect} from "react";&#13;
&#13;
export default function ClientComponent (props: WeatherProps): JSX.Element {&#13;
&#13;
    const [count, setCount] = useState(0);&#13;
    useEffect(() =&gt; {setCount(1);}, []);&#13;
&#13;
    return (&#13;
        &lt;h1&#13;
          onClick={() =&gt; setCount(count + 1)} &gt;&#13;
          The weather is {props.weather},&#13;
          and the counter shows {count}&#13;
        &lt;/h1&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-2: A basic client component that is similar to the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WeatherComponent</samp> <span class="Futura_Std_Book_Oblique_BI_11">created in <a href="chapter5.xhtml#Lis5-4">Listing 5-4</a></span></p>&#13;
<p class="TX">We export the component as the default function with the name <samp class="SANS_TheSansMonoCd_W5Regular_11">ClientComponent</samp>. Because we’re using the client-side hooks <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp> event handler, we need to declare the component as a client component with the <samp class="SANS_TheSansMonoCd_W5Regular_11">"use client"</samp> directive at the top of the file. Otherwise, Next.js will throw an error.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H1" id="sec4"><span id="h1-99"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_266" aria-label=" Page 266. "/><samp class="SANS_Futura_Std_Bold_B_11">Rendering Components</samp></h3>&#13;
<p class="TNI">In <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, we performed server-side rendering with the <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp> function and used static site generation (SSG) with the <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp> function. In the <i>app</i> directory, both functions are obsolete. If we want to optimize an application, we can instead use Next.js’s built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API, which controls data retrieval and rendering at the component level.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-174"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fetching Data</samp></h4>&#13;
<p class="TNI">The new asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API extends the native fetch web API and returns a promise. Because server components are just exported functions that return a JSX element, we can declare them as asynchronous functions and then use <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> pattern.</p>&#13;
<p class="TX">This pattern is beneficial because it allows us to fetch data for only the segment that uses the data rather than for an entire page. This lets us leverage React features to automatically display loading states and gracefully catch errors, as discussed in <span class="Xref">“Exploring the Project Structure” on page 269</span>. If we follow this pattern, a loading state will block the rendering of only a particular server component and its user interface; the rest of the page will be fully functional and interactive.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Client components shouldn’t be asynchronous functions, because the way JavaScript handles asynchronous calls can easily lead to multiple re-renders and slow down the whole application. Next.js developers have discussed adding a generic use hook that lets us use asynchronous functions in client components by caching the results, but this hook is not yet finalized. If you absolutely need client-side data fetching, I recommend using a specialized library such as SWR, which you can find at</i> <a href="https://swr.vercel.app"><span class="note_LinkURL_Italic">https://<wbr/>swr<wbr/>.vercel<wbr/>.app</span></a><i>.</i></p>&#13;
<p class="TX">You might worry that, when each server component loads its own data, you’ll end up with a massive number of requests. How do these numbers impact the overall page performance? Well, Next.js’s <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> comes with multiple optimizations to speed up the application. For example, it automatically caches the response data for GET requests sent from a server component to the same API, reducing the number of requests.</p>&#13;
<p class="TX">However, POST requests aren’t usually cacheable, as the data they contain might change, so <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> won’t automatically cache them. This is a problem for us because GraphQL typically uses POST requests. Fortunately, React exposes a <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp> function that memorizes the result of the function it wraps. <a href="appendix-B.xhtml#LisB-3">Listing B-3</a> shows an example of using <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp> with a GraphQL API.</p>&#13;
<span id="LisB-3"/>&#13;
<pre class="pre-277"><code>import {cache} from 'react';&#13;
&#13;
export const getUserFromGraphQL = cache(<b>async</b> (id:string) =&gt; {&#13;
    <b>return await fetch</b>("/graphql," {method: "POST", body: "query":" "});&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-3: A simple outline of a cached POST API call</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_267" aria-label=" Page 267. "/>We wrap the API call in the <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp> function we imported from React and return the API’s response object. Note that the cached arguments can use only primitive values because the <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp> function doesn’t perform a deep comparison for the arguments.</p>&#13;
<p class="TX">Another optimization we can implement is to leverage the asynchronous nature of <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> to request data for the server component in a parallel fashion instead of sequentially. Here, the most common pattern is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp> to start all requests at the same time and block the rendering until all requests have been completed. <a href="appendix-B.xhtml#LisB-4">Listing B-4</a> shows us the relevant code for this pattern.</p>&#13;
<span id="LisB-4"/>&#13;
<pre class="pre-278"><code>const userPromiseOne = getUserFromGraphQL ("0001");&#13;
const userPromiseTwo = getUserFromGraphQL ("0002");&#13;
&#13;
const [userDataOne, userDataTwo] = await Promise.all([userPromiseOne, userPromiseTwo]);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-4: Two parallel API calls with</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Promise.all</samp></p>&#13;
<p class="TX">We set up two requests, both of which return a promise user object. Then we await the result of both promises and call <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp> with an array of the previously created asynchronous API calls. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp> function resolves as soon as both promises return their data, and then the server component’s code continues.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-175"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Rendering</samp></h4>&#13;
<p class="TNI">Static rendering is the default setting for both server and client components. It resembles static site generation, which we used with <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp> in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. This rendering option pre-renders both client and server components in the server environment at build time. As a result, requests will always return the same HTML, which remains static and is never re-created.</p>&#13;
<p class="TX">Each component type is rendered slightly differently. For client components, the server pre-renders the HTML and JSON data; the client then receives the pre-rendered data, including the client-side script, to add interactivity to the HTML. For server components, the browser receives only the rendered payload to hydrate the component. They neither have client-side JavaScript nor use JavaScript for hydration; hence they do not send any JavaScript to the client and, in turn, don’t bloat the bundled scripts.</p>&#13;
<p class="TX"><a href="appendix-B.xhtml#LisB-5">Listing B-5</a> shows how to statically render the <i>utils/fetch-names.ts</i> file from <a href="chapter5.xhtml#Lis5-8">Listing 5-8</a>.</p>&#13;
<span id="LisB-5"/>&#13;
<pre class="pre-279"><code>export default async function ServerComponentUserList(): Promise&lt;JSX.Element&gt; {&#13;
    const url = "https://www.usemodernfullstack.dev/api/v1/users";&#13;
    let data: responseItemType[] | [] = [];&#13;
    let names: responseItemType[] | [];&#13;
    try {&#13;
<b>        const response = await fetch(url, {cache: "force-cache"});</b>&#13;
        data = (await response.json()) as responseItemType[];&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_268" aria-label=" Page 268. "/>    } catch (err) {&#13;
        throw new Error("Failed to fetch data");&#13;
    }&#13;
    names = data.map((item) =&gt; {&#13;
        return {id: item.id, name: item.name};&#13;
    });&#13;
&#13;
    return (&#13;
        &lt;ul&gt;&#13;
            {names.map((item) =&gt; (&#13;
                &lt;li key="{item.id}"&gt;{item.name}&lt;/li&gt;&#13;
            ))}&#13;
        &lt;/ul&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-5: A server component that uses static rendering</span></p>&#13;
<p class="TX">First we define a server component as an asynchronous function that directly returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp> wrapped in a promise.</p>&#13;
<p class="TX">In <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, we returned the page’s data and then used the page <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> to pass it the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> function, where we generated the element. Here, after setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">url</samp>, we use the asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> function to get the data from the remote API. Next.js will cache the results of the API call and the rendered component, and the server will reuse the generated code and never re-create it.</p>&#13;
<p class="TX">If you use <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> without an explicit cache setting, it will use <samp class="SANS_TheSansMonoCd_W5Regular_11">force-cache</samp> as the default to perform static rendering. To switch to incremental static regeneration instead, replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> call from <a href="appendix-B.xhtml#LisB-5">Listing B-5</a> with the one in <a href="appendix-B.xhtml#LisB-6">Listing B-6</a>.</p>&#13;
<span id="LisB-6"/>&#13;
<pre class="pre-280"><code>    const response = await fetch(url, {<b>next: {revalidate: 20}</b>});</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-6: The modified</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fetch</samp> <span class="Futura_Std_Book_Oblique_BI_11">call for ISR-like rendering</span></p>&#13;
<p class="TX">We simply add the <samp class="SANS_TheSansMonoCd_W5Regular_11">revalidate</samp> property with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">30</samp>. The server will then render the component statically but invalidate the current HTML 30 seconds after the first page request and re-render it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-176"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic Rendering</samp></h4>&#13;
<p class="TNI">Dynamic rendering replaces Next.js’s traditional server-side rendering (SSR), which we used by exporting the <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp> function from a page route in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. Because Next.js uses static rendering by default, we must actively opt in to using dynamic rendering in one of two ways: by disabling the cache in our fetch requests or by using a dynamic function. In <a href="appendix-B.xhtml#LisB-7">Listing B-7</a>, we disable the cache.</p>&#13;
<span id="LisB-7"/>&#13;
<pre class="pre-281"><code>export default async function ServerComponentUserList(): Promise&lt;JSX.Element&gt; {&#13;
    const url = "https://www.usemodernfullstack.dev/api/v1/users";&#13;
    let data: responseItemType[] | [] = [];&#13;
    let names: responseItemType[] | [];&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_269" aria-label=" Page 269. "/>    try {&#13;
<b>            const response = await fetch(url, {cache: "no-cache"});</b>&#13;
        data = (await response.json()) as responseItemType[];&#13;
    } catch (err) {&#13;
        throw new Error("Failed to fetch data");&#13;
    }&#13;
    names = data.map((item) =&gt; {&#13;
        return {id: item.id, name: item.name};&#13;
    });&#13;
&#13;
    return (&#13;
        &lt;ul&gt;&#13;
            {names.map((item) =&gt; (&#13;
                &lt;li key="{item.id}"&gt;{item.name}&lt;/li&gt;&#13;
            ))}&#13;
        &lt;/ul&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-7: A server component that uses dynamic rendering by disabling the cache</span></p>&#13;
<p class="TX">We explicitly set the <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp> property to <samp class="SANS_TheSansMonoCd_W5Regular_11">no-cache</samp>. Now the server will re-fetch the data for the component upon each request.</p>&#13;
<p class="TX">Instead of disabling the cache, we could use dynamic functions, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">header</samp> function or the <samp class="SANS_TheSansMonoCd_W5Regular_11">cookies</samp> function in server components and the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSearchParams</samp> hook in client components. These functions use dynamic data such as request headers, cookies, and search parameters that are unknown during build time and are part of the request object we pass to the function. The server needs to run these functions for each request because the required data depends on the request.</p>&#13;
<p class="TX">Keep in mind that dynamic rendering affects the whole route. If one server component in a route opts for dynamic rendering, Next.js will render the whole route dynamically at request time.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H1" id="sec8"><span id="h1-100"/><samp class="SANS_Futura_Std_Bold_B_11">Exploring the Project Structure</samp></h3>&#13;
<p class="TNI">Let’s set up a new Next.js application to explore the features we’ve discussed. First, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">npx create-next-app@latest</samp> command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--typescript --use-npm</samp> flags to create a sample application. When answering the setup wizard’s questions, choose to use the <i>app</i> directory instead of the <i>pages</i> directory.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can also use the online playground at</i> <a href="https://codesandbox.io/s/"><span class="note_LinkURL_Italic">https://<wbr/>codesandbox<wbr/>.io<wbr/>/s<wbr/>/</span></a> <i>to run the Next.js code examples in this appendix. Search for the official</i> <span class="note_Italic">Next.js (App router)</span> <i>template when creating a new code sandbox there.</i></p>&#13;
<p class="TX">Now enter the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">npm run dev</samp> command to start the application in development mode. You should see a Next.js welcome screen in your browser at <i>http://localhost:3000</i>. Unlike the welcome screen you saw in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_270" aria-label=" Page 270. "/>which encouraged us to edit the <i>pages/index.tsx</i> file, here the welcome screen directs us to the <i>app/page.tsx</i> file.</p>&#13;
<p class="TX">Take a look at the files and folders the wizard created and compare them with the ones from <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. You should see that the <i>pages</i> and <i>styles</i> directories are not part of the new structure. Instead, the router replaces both with the <i>app</i> directory. Inside it, you should see neither the <i>_app.tsx</i> file nor the <i>_document.tsx</i> file. Instead, it uses the root layout file <i>layout.tsx</i> to define the HTML wrapper for all rendered pages and the <i>page.tsx</i> file to render the root segment (the home page).</p>&#13;
<p class="TX">The <i>pages</i> directory uses only one file to create the final content of the page route. By contrast, the <i>app</i> directory uses multiple files to create a page route and add additional behavior.</p>&#13;
<p class="TX">The <i>page.tsx</i> file generates the user interface and the content for the route, and its parent folder defines the leaf segment. Without a <i>page.tsx</i> file, the URL path won’t be accessible. We can then add other special files to the page’s folder. Next.js will automatically apply them to this URL segment and its children. The most important of these special files are <i>layout.tsx</i>, which creates a general user interface; <i>loading.tsx</i>, which uses a React suspense boundary to automatically create a “loading” user interface while the page loads; and <i>error.tsx</i>, which uses a React error boundary to catch errors and then show the user a custom error interface.</p>&#13;
<p class="TX"><a href="appendix-B.xhtml#figB-1">Figure B-1</a> compares the files and folders for the <i>components/weather</i> page route when using the <i>pages</i> directory and the <i>app</i> directory.</p>&#13;
<figure class="IMG"><img class="img1" id="figB-1" src="../images/FigureB-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-1: Comparing the page route</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">in the pages and app directory structures</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_271" aria-label=" Page 271. "/>When the <i>app</i> directory is the root folder, its subfolders still correspond to URL segments, but now the folder that contains the <i>page.tsx</i> file defines the URL’s final leaf segment. The optional special files next to it affect only the contents of the <i>components/weather</i> page.</p>&#13;
<p class="TX">Let’s rebuild the <i>components/weather</i> page route you created in <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a> with the <i>app</i> directory. Create the <i>components</i> folder and <i>weather</i> subfolder inside the <i>app</i> directory and then copy the <i>custom.d.ts</i> file from the previous code exercises into the root folder.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h4 class="H2" id="sec9"><span id="h2-177"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating the CSS</samp></h4>&#13;
<p class="TNI">Begin by opening the existing <i>app/globals.css</i> file and replacing its content with the code from <a href="appendix-B.xhtml#LisB-8">Listing B-8</a>. We’ll need to make some modifications to use special files in our component.</p>&#13;
<span id="LisB-8"/>&#13;
<pre class="pre-282"><code>html,&#13;
body {&#13;
    background-color: rgb(230, 230, 230);&#13;
    font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,&#13;
        Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;&#13;
    margin: 0;&#13;
    padding: 0;&#13;
}&#13;
&#13;
a {&#13;
    color: inherit;&#13;
    text-decoration: none;&#13;
}&#13;
&#13;
* {&#13;
    box-sizing: border-box;&#13;
}&#13;
&#13;
nav {&#13;
    align-items: center;&#13;
    background-color: #fff;&#13;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.25);&#13;
    display: flex;&#13;
    height: 3rem;&#13;
    justify-content: space-evenly;&#13;
    padding: 0 25%;&#13;
}&#13;
&#13;
main {&#13;
    display: flex;&#13;
    justify-content: center;&#13;
}&#13;
&#13;
main .content {&#13;
    height: 300px;&#13;
    padding-top: 1.5rem;&#13;
    width: 400px;&#13;
}&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_272" aria-label=" Page 272. "/>main .content li {&#13;
    height: 1.25rem;&#13;
    margin: 0.25rem;&#13;
}&#13;
&#13;
main .loading {&#13;
    animation: 1s loading linear infinite;&#13;
    background: #ddd linear-gradient(110deg, #eeeeee 0%, #f5f5f5 15%, #eeeeee 30%);&#13;
    background-size: 200% 100%;&#13;
    min-height: 1.25rem;&#13;
    width: 90%;&#13;
}&#13;
&#13;
@keyframes loading {&#13;
    to {&#13;
        background-position-x: -200%;&#13;
    }&#13;
}&#13;
main .error {&#13;
    background: #ff5656;&#13;
    color: #fff;&#13;
}&#13;
&#13;
section {&#13;
    background: #fff;&#13;
    border: 1px dashed #888;&#13;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.25);&#13;
    margin: 2rem;&#13;
    padding: 0.5rem;&#13;
    position: relative;&#13;
}&#13;
&#13;
section .flag {&#13;
    background: #888;&#13;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.25);&#13;
    color: #fff;&#13;
    font-family: monospace;&#13;
    left: 0;&#13;
    padding: 0.25rem;&#13;
    position: absolute;&#13;
    top: 0;&#13;
    white-space: nowrap;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-8: The</span> <span class="Futura_Std_Book_11">app/globals.css</span> <span class="Futura_Std_Book_Oblique_BI_11">file with basic styles for our code examples</span></p>&#13;
<p class="TX">We create one <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp> element for the navigation with a <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> content area below it. Then we add styles for the loading and error states we’ll create later. In addition, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">section</samp> element to outline the boundaries of the files and <samp class="SANS_TheSansMonoCd_W5Regular_11">flag</samp> styles to add labels to the sections.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-178"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_273" aria-label=" Page 273. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining a Layout</samp></h4>&#13;
<p class="TNI">Layouts are server components that define the user interface for a particular route segment. Next.js renders this layout when this segment is active. Layouts are shared across all pages, so they can be nested into each other, and all layouts for a specific route and its children will be rendered when this route segment is active. <a href="appendix-B.xhtml#figB-2">Figure B-2</a> shows the relationship between the URL, the files, and the component hierarchy for the <i>components/weather</i> route.</p>&#13;
<figure class="IMG"><img class="img1" id="figB-2" src="../images/FigureB-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-2: The simplified layout component hierarchy</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this example, each folder contains a <i>layout.tsx</i> file. Next.js will render these in a nested fashion and make the page’s content the final rendered component.</p>&#13;
<p class="TX">Although we can fetch data in a layout, we can’t share data between a parent layout and its children. Instead, we can leverage the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API’s automatic deduplication to reuse data in each child segment or component. When we navigate from one page to another, only the layouts that change are re-rendered. Shared layouts won’t be re-rendered when their child segments change.</p>&#13;
<p class="TX">The root layout, which returns the skeleton structure with the <samp class="SANS_TheSansMonoCd_W5Regular_11">html</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp> elements for the page, is required, while all other layouts we create are optional. Let’s create a root layout. First, add a new interface to the end of the <i>custom.d.ts</i> file, which we copied from the previous exercise. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp> interface to type the layout’s properties object:</p>&#13;
&#13;
<pre class="pre-283"><code>interface LayoutProps {&#13;
    children: React.ReactNode;&#13;
}&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_274" aria-label=" Page 274. "/>Now open the <i>app/layout.tsx</i> file and replace its content with the code from <a href="appendix-B.xhtml#LisB-9">Listing B-9</a>.</p>&#13;
<span id="LisB-9"/>&#13;
<pre class="pre-284"><code>import "./globals.css";&#13;
&#13;
export const metadata = {&#13;
    title: "Appendix C",&#13;
    description: "The Example Code",&#13;
};&#13;
&#13;
export default function RootLayout(props: LayoutProps): JSX.Element {&#13;
    return (&#13;
        &lt;html lang="en"&gt;&#13;
            &lt;body&gt;&#13;
                &lt;section&gt;&#13;
                    &lt;span className="flag"&gt;app/layout(.tsx)&lt;/span&gt;&#13;
                    {props.children}&#13;
                &lt;/section&gt;&#13;
            &lt;/body&gt;&#13;
        &lt;/html&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-9: The file</span> <span class="Futura_Std_Book_11">app/layout.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">defines the root layout.</span></p>&#13;
<p class="TX">We import the <i>global.css</i> file that we created earlier and then define the default SEO metadata, the page title, and the page description through the <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp> object. This replaces the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp> component we used in the <i>pages</i> directory for all pages in the <i>app</i> directory.</p>&#13;
<p class="TX">Then we define the <samp class="SANS_TheSansMonoCd_W5Regular_11">RootLayout</samp> component, which accepts an object of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp> type and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>. We also create the <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>, explicitly adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">html</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp> elements, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">section</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">span</samp> with the CSS class <samp class="SANS_TheSansMonoCd_W5Regular_11">flag</samp> to outline the page structure. We add the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp> property from the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp> object to wrap them with our root HTML structure.</p>&#13;
<p class="TX">Now let’s add optional layouts to the <i>app/components</i> and <i>app/components/weather</i> folders. Create a <i>layout.tsx</i> file in each and then place the code from <a href="appendix-B.xhtml#LisB-10">Listing B-10</a> to the <i>app/components/layout.tsx</i> file.</p>&#13;
<span id="LisB-10"/>&#13;
<pre class="pre-285"><code>export default function ComponentsLayout(props: LayoutProps): JSX.Element {&#13;
    return (&#13;
        &lt;section&gt;&#13;
            &lt;span className="flag"&gt;app/components/layout(.tsx)&lt;/span&gt;&#13;
            &lt;nav&gt;Navigation Placeholder&lt;/nav&gt;&#13;
            &lt;main&gt;{props.children}&lt;/main&gt;&#13;
        &lt;/section&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-10: The file</span> <span class="Futura_Std_Book_11">app/components/layout.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">defines the segment layout.</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_275" aria-label=" Page 275. "/>This segment layout file follows the same basic structure as the root layout. We define a layout component that receives the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp> object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp> property and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>. Unlike in the root layout, we set only the inner structure, the <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp> element with the navigation placeholder, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> content area where we render the child elements from the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp> object, representing this segment’s child content (the leaf).</p>&#13;
<p class="TX">Lastly, create the leaf’s layout by adding the code from <a href="appendix-B.xhtml#LisB-11">Listing B-11</a> to the <i>app/components/weather/layout.tsx</i> file.</p>&#13;
<span id="LisB-11"/>&#13;
<pre class="pre-286"><code>export default function WeatherLayout(props: LayoutProps): JSX.Element {&#13;
    return (&#13;
        &lt;section&gt;&#13;
            &lt;span className="flag"&gt;app/components/weather/layout(.tsx)&lt;/span&gt;&#13;
            {props.children}&#13;
        &lt;/section&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-11: The file</span> <span class="Futura_Std_Book_11">app/components/weather/layout.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">defines the leaf layout.</span></p>&#13;
<p class="TX">The leaf’s layout resembles the segment layout from <a href="appendix-B.xhtml#LisB-10">Listing B-10</a>, but it returns a more straightforward HTML structure, as the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp> property does not contain another layout; instead, it contains the page’s content (in <i>page.tsx</i>), and the suspense boundary and error boundary from <i>loading.tsx</i> and <i>error.tsx</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-179"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Content and Route</samp></h4>&#13;
<p class="TNI">To expose the page route, we need to create the <i>page.tsx</i> file; otherwise, if we tried to visit the <i>components/weather</i> page route at <i>http://localhost:3000/components/weather</i>, we’d see Next.js’s default <i>404</i> error page. To re-create the page content from <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a>, we’ll create two files. One is <i>component .tsx</i>, which contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>, and the other is <i>page.tsx</i>, which resembles the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> wrapper we used in <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a>. Of course, pages could contain additional components located in other folders.</p>&#13;
<p class="TX">Let’s start by creating the <i>component.tsx</i> file inside the <i>apps/components/weather</i> folder and adding the code from <a href="appendix-B.xhtml#LisB-12">Listing B-12</a> into it.</p>&#13;
<span id="LisB-12"/>&#13;
<pre class="pre-287"><code>"use client";&#13;
&#13;
import {useState, useEffect} from "react";&#13;
&#13;
export default function WeatherComponent(props: WeatherProps): JSX.Element {&#13;
&#13;
    const [count, setCount] = useState(0);&#13;
&#13;
    useEffect(() =&gt; {&#13;
        setCount(1);&#13;
    }, []);&#13;
    return (&#13;
        &lt;h1 onClick={() =&gt; {setCount(count + 1)}} &gt;&#13;
            The weather is {props.weather}, and the counter shows {count}&#13;
        &lt;/h1&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-12: The file</span> <span class="Futura_Std_Book_11">app/components/weather/component.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">defines the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WeatherComponent</samp><span class="Futura_Std_Book_Oblique_BI_11">.</span></p>&#13;
<p class="TX">This code is similar to the code in <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp> constant, except we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">"use client"</samp> statement to explicitly set it as a client component and export it as the default function instead of storing it in a constant. The component itself has the same functionality as before: we create a headline that shows the weather string and a counter we can increase by clicking the headline.</p>&#13;
<p class="TX">Now we add the <i>page.tsx</i> file and the code from <a href="appendix-B.xhtml#LisB-13">Listing B-13</a> to create the page route and expose the route to the user.</p>&#13;
<span id="LisB-13"/>&#13;
<pre class="pre-288"><code>import WeatherComponent from "./component";&#13;
&#13;
export const metadata = {&#13;
    title: "Appendix C - The Weather Component (Weather &amp; Count)",&#13;
    description: "The Example Code For The Weather Component (Weather &amp; Count)",&#13;
};&#13;
&#13;
export default async function WeatherPage() {&#13;
    return (&#13;
        &lt;section className="content"&gt;&#13;
            &lt;span className="flag"&gt;app/components/weather/page(.tsx)&lt;/span&gt;&#13;
            &lt;WeatherComponent weather="sunny" /&gt;&#13;
        &lt;/section&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-13: The file</span> <span class="Futura_Std_Book_11">app/components/weather/page.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">defines the page route.</span></p>&#13;
<p class="TX">We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp> we just created and then set the SEO metadata on the page level. Then we export the page route as the default async function. When we compare it to <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a>, which contains a similar page, we see that we no longer need to export a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>; instead, we use a basic function. The <i>app</i> directory simplifies the structure of the code.</p>&#13;
<p class="TX">Now visit our <i>components/weather</i> page route at <i>http://localhost:3000/components/weather</i> in the browser. You should see a page that looks similar to <a href="appendix-B.xhtml#figB-3">Figure B-3</a>.</p>&#13;
<p class="TX">Notice two things here. First, you should recognize the component from <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, whose counter increases when we click the headline. In addition, the combination of the styles and the <samp class="SANS_TheSansMonoCd_W5Regular_11">span</samp> elements we added to each <i>.tsx</i> file visualizes the relations between the files. We see that the nested layout files resemble the simplified component hierarchy from <a href="appendix-B.xhtml#figB-3">Figure B-3</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_277" aria-label=" Page 277. "/>&#13;
&#13;
<figure class="IMG"><img class="img1" id="figB-3" src="../images/FigureB-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-3: The</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page showing the nested components</samp></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H2" id="sec12"><span id="h2-180"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Catching Errors</samp></h4>&#13;
<p class="TNI">As soon as we add an <i>error.tsx</i> file to the folder, Next.js wraps our page’s content with a React error boundary. <a href="appendix-B.xhtml#figB-4">Figure B-4</a> shows the simplified component hierarchy of the <i>components/weather</i> route with an added <i>error.tsx</i> file.</p>&#13;
<figure class="IMG"><img class="img1" id="figB-4" src="../images/FigureB-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-4: The simplified layout component hierarchy includes the error boundary.</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_278" aria-label=" Page 278. "/>We see that the <i>error.tsx</i> file automatically creates an error boundary around the page’s content. By doing so, Next.js enables us to catch errors on a page level and gracefully handle those instead of freezing the whole user interface or redirecting the user to a generic error page. Think about it as a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> block on a component level. We can now show a tailored error message and display a button that lets the user re-render the page content in a previously working state without reloading the whole application.</p>&#13;
<p class="TX">The <i>error.tsx</i> file exports a client component that the error boundary uses as the fallback interface. In other words, this component replaces the content when the code throws an error and activates the error boundary. As soon as it is active, it contains the error, ensuring that the layouts above the boundary remain active and maintain their internal state. The error component receives the <samp class="SANS_TheSansMonoCd_W5Regular_11">error</samp> object and the <samp class="SANS_TheSansMonoCd_W5Regular_11">reset</samp> function as parameters.</p>&#13;
<p class="TX">Let’s add an error boundary to the <i>components/weather</i> route. Start by adding a new <samp class="SANS_TheSansMonoCd_W5Regular_11">ErrorProps</samp> interface to type the component’s properties into the <i>customs.d.ts</i> file:</p>&#13;
&#13;
<pre class="pre-289"><code>interface ErrorProps {&#13;
    error: Error;&#13;
    reset: () =&gt; void;&#13;
}&#13;
</code></pre>&#13;
<p class="TX">Next, create the <i>error.tsx</i> file next to <i>page.tsx</i> in the <i>app/components/weather</i> directory and add the code from <a href="appendix-B.xhtml#LisB-14">Listing B-14</a>.</p>&#13;
<span id="LisB-14"/>&#13;
<pre class="pre-290"><code>"use client";&#13;
&#13;
export default function WeatherError(props: ErrorProps): JSX.Element {&#13;
    return (&#13;
        &lt;section className="content error"&gt;&#13;
            &lt;span className="flag"&gt;app/components/weather/error(.tsx)&lt;/span&gt;&#13;
            &lt;h2&gt;Something went wrong!&lt;/h2&gt;&#13;
            &lt;blockquote&gt;{props.error?.toString()}&lt;/blockquote&gt;&#13;
            &lt;button onClick={() =&gt; props.reset()}&gt;Try again (re-render)&lt;/button&gt;&#13;
        &lt;/section&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-14: The file</span> <span class="Futura_Std_Book_11">app/components/weather/error.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">adds the error boundary and the fallback UI.</span></p>&#13;
<p class="TX">Because we know that the error component needs to be a client component, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">"use client"</samp> directive to the top of the file and then define and export the component. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ErrorProps</samp> interface we just created to type the component’s properties. We then convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">error</samp> property to a string and display it to inform the user of the type of error that occurred. Finally, we render a button that calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">reset</samp> function that the component received through the properties object. The user can re-render the component into a previous working state by clicking the button.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_279" aria-label=" Page 279. "/>Now, with the error boundary in place, we’ll modify <i>component.tsx</i> to throw an error if the counter hits 4 or more. Open the file and add the code from <a href="appendix-B.xhtml#LisB-15">Listing B-15</a> below the first <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hook.</p>&#13;
<span id="LisB-15"/>&#13;
<pre class="pre-291"><code>    useEffect(() =&gt; {&#13;
        if (count &amp;&amp; count &gt;= 4) {&#13;
            throw new Error("Count &gt;= 4! ");&#13;
        }&#13;
    }, [count]);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-15: The additional</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">useEffect</samp> <span class="Futura_Std_Book_Oblique_BI_11">hook for</span> <span class="Futura_Std_Book_11">app/components/weather/component.tsx</span></p>&#13;
<p class="TX">The additional <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hook we add to the component is straightforward; as soon as the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> variable changes, we verify the error condition, and as soon as the variable’s value is 4 or more, we throw an error with the message <samp class="SANS_TheSansMonoCd_W5Regular_11">Count</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4!</samp>, which the error boundary catches and gracefully handles by showing the fallback user interface that the <i>error.tsx</i> file exports.</p>&#13;
<p class="TX">To test this feature, open <i>http://localhost:3000/components/weather</i> in the browser and click the headline until you trigger the error. You should see the error component instead of the weather component, as in <a href="appendix-B.xhtml#figB-5">Figure B-5</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="figB-5" src="../images/FigureB-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-5: The</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page in the error state</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The layout markers show us that <i>error.tsx</i> has replaced <i>page.tsx</i>. We also see the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Error: Count</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;=4!</samp>, which we passed to the error constructor. As soon as we click the re-render button, <i>page.tsx</i> should replace <i>error.tsx</i>, and the screen will look like <a href="appendix-B.xhtml#figB-4">Figure B-4</a> previously.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-181"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Showing an Optional Loading Interface</samp></h4>&#13;
<p class="TNI">Now we’ll create the <i>loading.tsx</i> file. With this feature in place, Next.js automatically wraps the page content with a React suspense component, creating a component hierarchy that looks similar to <a href="appendix-B.xhtml#figB-6">Figure B-6</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_280" aria-label=" Page 280. "/>&#13;
&#13;
<figure class="IMG"><img class="img1" id="figB-6" src="../images/FigureB-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-6: The simplified layout component hierarchy with the loading interface</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <i>loading.tsx</i> file is a basic server component that returns the pre-rendered loading user interface. When we load a page or navigate between pages, Next.js will instantly display this component while loading the new segment’s content. Once rendering is complete, the runtime will swap the loading state with the new content. In this way, we can easily display meaningful loading states, such as skeletons or custom animations.</p>&#13;
<p class="TX">Let’s add a basic loading user interface to the weather component route by adding the code from <a href="appendix-B.xhtml#LisB-16">Listing B-16</a> to the <i>loading.tsx</i> file.</p>&#13;
<span id="LisB-16"/>&#13;
<pre class="pre-292"><code>export default function WeatherLoading(): JSX.Element {&#13;
    return (&#13;
        &lt;section className="content"&gt;&#13;
            &lt;span className="flag"&gt;app/components/weather/loading(.tsx)&lt;/span&gt;&#13;
            &lt;h1 className="loading"&gt;&lt;/h1&gt;&#13;
        &lt;/section&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-16: The file</span> <span class="Futura_Std_Book_11">app/components/weather/loading.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">adds a suspense boundary with the loading user interface.</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_281" aria-label=" Page 281. "/>We define and export the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLoading</samp> component, which returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>. In the HTML, we add a headline element similar to the one in <i>page.tsx</i>, except this one adds the loading class we created in the <i>global.css</i> file to the headline and shows an animated placeholder.</p>&#13;
<p class="TX">When we open <i>http://localhost:3000/components/weather</i> in the browser, we should see a loading interface similar to <a href="appendix-B.xhtml#figB-7">Figure B-7</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="figB-7" src="../images/FigureB-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-7: The</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page while loading the page’s content</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you don’t see the animated placeholder, this means Next.js has already cached your segment’s content.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-182"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding a Server Component That Fetches Remote Data</samp></h4>&#13;
<p class="TNI">Now that you understand the folders and files in the <i>app</i> directory, let’s add a server component that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API to receive the list of users from the remote API <i>https://www.usemodernfullstack.dev/api/v1/users</i> and renders it to the browser. We wrote a version of this code in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>.</p>&#13;
<p class="TX">Create the folder <i>app/components/server-component</i> and add the special files <i>component.tsx</i>, <i>loading.tsx</i>, <i>error.tsx</i>, <i>layout.tsx</i>, and <i>page.tsx</i> to it. Then set up the component’s functionality by adding the code from <a href="appendix-B.xhtml#LisB-17">Listing B-17</a> to the <i>component.tsx</i> file.</p>&#13;
<span id="LisB-17"/>&#13;
<pre class="pre-293"><code>export default async function ServerComponentUserList(): Promise&lt;JSX.Element|Error&gt; {&#13;
    const url = "https://www.usemodernfullstack.dev/api/v1/users";&#13;
    let data: responseItemType[] | [] = [];&#13;
    let names: responseItemType[] | [];&#13;
    try {&#13;
        const response = await fetch(url, {cache: "force-cache"});&#13;
        data = (await response.json()) as responseItemType[];&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_282" aria-label=" Page 282. "/>    } catch (err) {&#13;
        throw new Error("Failed to fetch data");&#13;
    }&#13;
    names = data.map((item) =&gt; {&#13;
        return {id: item.id, name: item.name};&#13;
    });&#13;
&#13;
    return (&#13;
        &lt;ul&gt;&#13;
            {names.map((item) =&gt; (&#13;
                &lt;li id="{item.id}" key="{item.id}"&gt;&#13;
                    {item.name}&#13;
                &lt;/li&gt;&#13;
            ))}&#13;
        &lt;/ul&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-17: The</span> <span class="Futura_Std_Book_11">app/components/server-component/component.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">Here we create a default server component that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API to <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> the API response. To be able to do so, we define it as an asynchronous function that returns a promise of a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp> or an <samp class="SANS_TheSansMonoCd_W5Regular_11">Error</samp>. Then we store the API endpoint in a constant and define the variables we’ll need later on. We wrap the API call in a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> statement to activate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Error Boundary</samp> if the API request fails. We then transform the data in a manner similarly to the way we did in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> and return a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp> that displays a list of users.</p>&#13;
<p class="TX">Now we add the loading user interface that Next.js automatically displays while we await the API’s response and the component’s JSX response. Place the code from <a href="appendix-B.xhtml#LisB-18">Listing B-18</a> into the <i>loading.tsx</i> file.</p>&#13;
<span id="LisB-18"/>&#13;
<pre class="pre-294"><code>export default function ServerComponentLoading(): JSX.Element {&#13;
    return (&#13;
        &lt;section className="content"&gt;&#13;
            &lt;span className="flag"&gt;&#13;
                app/components/server-component/loading(.tsx)&#13;
            &lt;/span&gt;&#13;
            &lt;ul id="load"&gt;&#13;
                {[...new Array(10)].map((item, i) =&gt; (&#13;
                    &lt;li className="loading"&gt;&lt;/li&gt;&#13;
                ))}&#13;
            &lt;/ul&gt;&#13;
        &lt;/section&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-18: The</span> <span class="Futura_Std_Book_11">app/components/server-component/loading.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">As before, the loading component is a server component that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>. This time, the loading skeleton is a list with 10 items resembling the component’s rendered HTML structure. You’ll see that this gives the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_283" aria-label=" Page 283. "/>user a good impression of the expected content and should improve the user’s experience.</p>&#13;
<p class="TX">Next, we create the error boundary by adding the code from <a href="appendix-B.xhtml#LisB-19">Listing B-19</a> to the <i>error.tsx</i> file.</p>&#13;
<span id="LisB-19"/>&#13;
<pre class="pre-295"><code>"use client"; // Error components must be Client components&#13;
&#13;
export default function ServerComponentError(props: ErrorProps): JSX.Element {&#13;
    return (&#13;
        &lt;section className="content"&gt;&#13;
            &lt;span className="flag"&gt;app/components/server-component/error(.tsx)&lt;/span&gt;&#13;
            &lt;h2&gt;Something went wrong!&lt;/h2&gt;&#13;
            &lt;code&gt;{props.error?.toString()}&lt;/code&gt;&#13;
            &lt;button onClick={() =&gt; props.reset()}&gt;Try again (re-render)&lt;/button&gt;&#13;
        &lt;/section&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-19: The</span> <span class="Futura_Std_Book_11">app/components/server-component/error.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">Except for the flag outlining the file structure, the error boundary is similar to the one we used in the weather component.</p>&#13;
<p class="TX">Then we add the code from <a href="appendix-B.xhtml#LisB-20">Listing B-20</a> to the <i>layout.tsx</i> file.</p>&#13;
<span id="LisB-20"/>&#13;
<pre class="pre-296"><code>export default function ServerComponentLayout(props: LayoutProps): JSX.Element {&#13;
    return (&#13;
        &lt;section&gt;&#13;
            &lt;span className="flag"&gt;app/components/server-component/layout(.tsx)&lt;/span&gt;&#13;
            {props.children}&#13;
        &lt;/section&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-20: The</span> <span class="Futura_Std_Book_11">app/components/server-component/layout.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">Again, the code is similar to the code we used for the weather component. We adjust only the flag outlining the component hierarchy.</p>&#13;
<p class="TX">Finally, with all the parts in place, we add the code from <a href="appendix-B.xhtml#LisB-21">Listing B-21</a> to the <i>page.tsx</i> file to expose the page route.</p>&#13;
<span id="LisB-21"/>&#13;
<pre class="pre-297"><code>import ServerComponentUserList from "./component";&#13;
&#13;
export const metadata = {&#13;
    title: "Appendix C - Server Side Component (User API)",&#13;
    description: "The Example Code For A Server Side Component (User API)",&#13;
};&#13;
&#13;
export default async function ServerComponentUserListPage(): JSX.Element {&#13;
    return (&#13;
        &lt;section className="content"&gt;&#13;
            &lt;span className="flag"&gt;app/components/server-component/page(.tsx)&lt;/span&gt;&#13;
            {/* @ts-expect-error Async Server Component */}&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_284" aria-label=" Page 284. "/>            &lt;ServerComponentUserList /&gt;&#13;
        &lt;/section&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-21: The</span> <span class="Futura_Std_Book_11">app/components/server-component/page.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-183"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Completing the Application with the Navigation</samp></h4>&#13;
<p class="TNI">With two pages in the application, we can now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> component to replace the navigation placeholder in the <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp> element. This should create a fully functional application prototype that lets us navigate between the pages. Open the <i>app/components/layout.tsx</i> file and replace the code in the file with the code from <a href="appendix-B.xhtml#LisB-22">Listing B-22</a>.</p>&#13;
<span id="LisB-22"/>&#13;
<pre class="pre-298"><code>import Link from "next/link";&#13;
&#13;
export default function ComponentsLayout(props: LayoutProps): JSX.Element {&#13;
    return (&#13;
        &lt;section&gt;&#13;
            &lt;span className="flag"&gt;app/components/layout(.tsx)&lt;/span&gt;&#13;
            <b>&lt;nav&gt;</b>&#13;
<b>                &lt;Link href="/components/server-component"&gt;</b>&#13;
<b>                    User API &lt;br /&gt;</b>&#13;
<b>                    (Server Component)</b>&#13;
<b>                &lt;/Link&gt;</b><b>{" "}</b>&#13;
<b>                |</b>&#13;
<b>                &lt;Link href="/components/weather"&gt;</b>&#13;
<b>                    Weather Component &lt;br /&gt;</b>&#13;
<b>                    (Client Component)</b>&#13;
<b>                </b><b>&lt;/Link&gt;</b>&#13;
<b>            &lt;/nav&gt;</b>&#13;
            &lt;main&gt;{props.children}&lt;/main&gt;&#13;
        &lt;/section&gt;&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-22: The updated</span> <span class="Futura_Std_Book_11">app/components/layout.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> component and then add two links to our navigation, one pointing to the user list server component we just created and the other pointing to the weather client component.</p>&#13;
<p class="TX">Let’s visit the application’s weather component page at <i>http://localhost:3000/components/weather</i>. You should see an application that looks similar to the screenshot in <a href="appendix-B.xhtml#figB-8">Figure B-8</a>.</p>&#13;
<p class="TX">As soon as you navigate between the pages, you should see the loading user interface. With the outlines we’ve added to all the files, we easily keep track of which files Next.js uses to render the current page.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_285" aria-label=" Page 285. "/>&#13;
&#13;
<figure class="IMG"><img class="img1" id="figB-8" src="../images/FigureB-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-8: The</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page with the functional navigation</samp></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H2" id="sec16"><span id="h2-184"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing API Routes with Route Handlers</samp></h4>&#13;
<p class="TNI">If you look at the folder structure Next.js created for you, you should see that the <i>app</i> directory contains an <i>api</i> subfolder. You probably already guessed that we use this folder to define APIs. But unlike the API routes discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, which were regular functions, the <i>app</i> directory uses <i>route handlers</i>, which are functions that require a particular naming convention.</p>&#13;
<p class="TX">These route handlers belong in special files named <i>route.ts</i> that usually reside in a subfolder of the <i>app/api</i> folder. They are asynchronous functions that receive a <samp class="SANS_TheSansMonoCd_W5Regular_11">Request</samp> object and an optional context object as parameters. We name each function after the HTTP method it should react to. For example, the code in <a href="appendix-B.xhtml#LisB-23">Listing B-23</a> shows how to define route handlers that handle GET and POST requests for the same API.</p>&#13;
<span id="LisB-23"/>&#13;
<pre class="pre-299"><code>import {NextRequest, NextResponse} from 'next/server';&#13;
export async function GET(request: NextRequest): Promise&lt;NextResponse&gt; {&#13;
    return NextResponse.json({});&#13;
}&#13;
&#13;
export async function POST(request: NextRequest): Promise&lt;NextResponse {&#13;
    return NextResponse.json({});&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-23: A skeleton structure of a</span> <span class="Futura_Std_Book_11">route.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file defining route handlers</span></p>&#13;
<p class="TX">To create the route handlers, we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp> objects from Next.js’s server package. Next.js adds additional convenience <span role="doc-pagebreak" epub:type="pagebreak" id="pg_286" aria-label=" Page 286. "/>methods for cookie handling, redirects, and rewrites. You can read more about them in the official documentation at <a href="https://nextjs.org"><i>https://<wbr/>nextjs<wbr/>.org</i></a>.</p>&#13;
<p class="TX">We then define two asynchronous functions, both of which receive a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp> and return a promise of a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp>. The function names correspond to the HTTP method they should respond to. Next.js supports using the GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS methods as function names.</p>&#13;
<p class="TX">When defining page routes and route handlers, remember that these files take over all requests for a given segment. This means that a <i>route.ts</i> file cannot be in the same folder as a <i>page.tsx</i> file. Also, route handlers are the only way to define APIs if you use the <i>app</i> directory: you can’t have an <i>api</i> folder in both the <i>pages</i> directory and <i>app</i> directory.</p>&#13;
<p class="TX">Next.js has statically and dynamically evaluated route handlers. Statically evaluated route handlers will be cached and reused for every request, whereas dynamically evaluated route handlers must request the data upon each request. By default, the runtime statically evaluates all GET route handlers that don’t use a dynamic function or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp> object. As soon as we use a different HTTP method, the dynamic <samp class="SANS_TheSansMonoCd_W5Regular_11">cookies</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">headers</samp> function, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp> object, the route handler becomes dynamically evaluated. The same applies to APIs with dynamic segments, which receive the dynamic parameters through the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> object.</p>&#13;
<p class="TX">Let’s re-create the API route <i>api/v1/weather/[zipcode].ts</i> from <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a> as a route handler that we can use in the <i>app</i> directory. Add the code from <a href="appendix-B.xhtml#LisB-24">Listing B-24</a> to a <i>route.ts</i> file in the folder structure <i>app/api/v1/weather/[zipcode]</i>.</p>&#13;
<span id="LisB-24"/>&#13;
<pre class="pre-300"><code>import {NextResponse, NextRequest} from "next/server";&#13;
&#13;
interface ReqContext {&#13;
    params: {&#13;
        zipcode: number;&#13;
    }&#13;
}&#13;
&#13;
export async function GET(req: NextRequest, context: ReqContext): Promise&lt;NextResponse&gt; {&#13;
    return NextResponse.json(&#13;
        {&#13;
            zipcode: context.params.zipcode,&#13;
            weather: "sunny",&#13;
            temp: 35,&#13;
        },&#13;
        {status: 200}&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing B-24: The route handler in</span> <span class="Futura_Std_Book_11">app/api/v1/weather/[zipcode]/route.ts</span></p>&#13;
<p class="TX">Notice that we’ve used the square brackets pattern on the folder structure to access the dynamic segment through the function’s second parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> object.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_287" aria-label=" Page 287. "/>Within the file, we import the Next.js <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp> objects from the server package and then define the interfaces for the route handler. On the <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestContext</samp> interface, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> property to <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp>, representing the API’s dynamic segment. Finally, we export the asynchronous GET function, the API route handler that reacts to all GET requests for this API endpoint. It receives the request object and the request context as parameters and uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp>’s <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> function to return the response data. We access the URL parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> through the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> object and then add it to the response data. We set additional response options through the <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> function’s second parameter, explicitly setting the HTTP status code to <i>200</i>.</p>&#13;
<p class="TX">Now try querying the API with <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>:</p>&#13;
&#13;
<pre class="pre-301"><code>$ <b>curl -i \</b>&#13;
<b>    -X GET \</b>&#13;
<b>    -H "Accept: application/json" \</b>&#13;
<b>    http://localhost:3000/api/v1/weather/12345</b>&#13;
</code></pre>&#13;
<p class="TX">You should receive this JSON response:</p>&#13;
&#13;
<pre class="pre-302"><code>HTTP/1.1 200 OK&#13;
content-type: application/json&#13;
<var>--snip--</var>&#13;
{"zipcode":"12345","weather":"sunny","temp":35}&#13;
</code></pre>&#13;
<p class="TX">This is the same response received in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, where we accessed the API through the browser.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
</body></html>