- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 4 CONDITIONALS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn about *conditional* elements of the PHP language,
    including if...else statements, switch statements, and match statements. These
    structures, along with language features such as the ternary operator, the null-coalescing
    operator, and logical operators, make it possible to write dynamic code that decides
    what to do based on a set of conditions. The conditions might depend on certain
    inputs (for example, from a user or from a software system such as a database
    or API) or on other varying data (such as the current date or time, or whether
    a file exists).
  prefs: []
  type: TYPE_NORMAL
- en: '### Conditions Are True or False'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the core of any decision-making logic is a *Boolean expression*, or code
    that is either true or false. The simplest Boolean expression is a literal value
    of true or false. In almost all cases, though, we instead write an expression
    containing some kind of test. The test might examine the values of variables,
    or perhaps call a function and check the value it returns. Either way, the test
    ultimately evaluates to true or false. Examples of tests include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Does a variable contain a particular value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does a variable have any value assigned at all?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does a file or folder exist?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the value in one variable greater or less than another value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does a function return true or false based on the arguments provided?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the length of a string greater than a certain minimum?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does a variable contain a value of a particular data type?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are two expressions both true, or just one, or neither?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests such as these all evaluate to true or false. They form the conditions
    of the choice statements you can use in your code.
  prefs: []
  type: TYPE_NORMAL
- en: if Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perhaps the most common conditional statement in any programming language is
    the if statement. It allows you to execute a statement only if a certain condition
    is true. Otherwise, that statement is simply skipped. In PHP, if statements are
    written in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Start with the if keyword, followed in parentheses by the condition you want
    to check. This condition is the Boolean expression that evaluates to true or false.
    It’s common practice to add a space after the if keyword, before the opening parenthesis.
    Next comes the statement that should be executed if the condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-1](#lis4-1) shows an example of an if statement. It prints the message
    Good morning if the hour of the day is before 12 (assuming a 24-hour clock).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: An if statement'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set the $hourNumber variable to 10. Then we use an if statement to
    test our condition: whether the value in $hourNumber is less than 12. Since 10
    is less than 12, the condition is true, so the statement after the condition is
    executed, printing out the message Good morning.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we had only one statement that we wanted to execute if the
    condition was true. But what if we want to execute multiple statements? We need
    a way to group the statements so it’s clear that they’re all part of the if statement.
    For this, enclose the sequence of statements in curly brackets (braces) immediately
    after the condition. The curly brackets delineate a *statement group*, a PHP construction
    that can contain zero, one, or many statements, and that PHP treats as a single
    statement. [Listing 4-2](#lis4-2) shows an example of a conditional with a statement
    group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-2: A refactored if statement featuring a statement group'
  prefs: []
  type: TYPE_NORMAL
- en: This if statement produces the same result as [Listing 4-1](#lis4-1), but we’ve
    rewritten it to consist of multiple print statements, one for each word in the
    message. The statements are enclosed in curly brackets to group them together.
    It’s customary to write the opening bracket on the same line as the condition,
    followed on separate lines by each statement in the group, followed by the closing
    bracket, also on a separate line. By convention, each statement in the statement
    group is indented.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Even if you have only a single conditional statement to be executed, enclosing
    that statement in curly brackets to form a statement group is common practice.
    This way, all* if *statements follow the same style, no matter how many statements
    are involved.*'
  prefs: []
  type: TYPE_NORMAL
- en: if...else Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many situations require a program to perform one set of actions if a condition
    is true or another set of actions if the condition is false. For these situations,
    use an if...else statement. [Listing 4-3](#lis4-3) shows an example where we choose
    between printing Good morning and Good day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-3: An if...else statement'
  prefs: []
  type: TYPE_NORMAL
- en: This code once again checks whether the value of $hourNumber is less than 12.
    If it is, the condition is true, so we execute the if branch of the statement,
    printing Good morning as before. If the condition is false, however, and $hourNumber
    isn’t less than 12, we execute the else branch of the statement instead, printing
    the message Good day. Notice that the else keyword appears after the closing curly
    bracket of the if branch’s statement group. Then the else branch is given its
    own statement group enclosed in curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, $hourNumber is 14 (2 PM), so the condition evaluates to false
    and the else branch’s statement is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Nested if...else Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An if...else statement chooses between two courses of action. If you have more
    than two courses of action to choose from, you have a few options. One is to nest
    further if...else statements inside the original else branch. [Listing 4-4](#lis4-4)
    shows an example. This script encodes the logic that if the hour is before 12,
    we print Good morning; if the hour is between 12 and 17 (5 PM), we print Good
    afternoon; or otherwise, we print Good day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-4: Nested if...else statements'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have an if statement testing whether the hour is less than 12 ❶. If
    this condition isn’t true, the else statement will be executed. The statement
    group for the else statement is a second (nested) if...else statement. The condition
    for this second if...else statement is whether the hour is less than 17 ❷. (If
    we’re at this point, we’ve already determined that the hour isn’t less than 12,
    so in effect we’re testing whether the hour is between 12 and 17.) If this new
    test passes, Good afternoon will be printed. Otherwise, we get to the else portion
    of the nested if...else statement, where Good day is printed. Try playing with
    different values of $hourNumber to see how it affects the output of the script.
  prefs: []
  type: TYPE_NORMAL
- en: if...elseif...else Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Choosing between three or more actions is such a common pattern in programming
    that PHP provides a simpler syntax for it that avoids the need for nesting: between
    an if statement and its else statement, place one or more elseif statements. The
    PHP engine will first test the condition for the if statement. If the statement
    is false, the engine will then test the condition for the first elseif statement,
    then the next elseif statement, and so on. When PHP finds a true condition, that
    branch’s statements are executed, and the remaining condition checks are skipped.
    If none of the if or elseif conditions are true, the else statement at the end
    will be executed, if there is one.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-5](#lis4-5) shows the same logic from [Listing 4-4](#lis4-4), but
    it’s rewritten using if...elseif...else.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-5: Simplifying the nested if...else statements with if...elseif...else'
  prefs: []
  type: TYPE_NORMAL
- en: Our second condition now appears in sequence as an elseif statement ❶ after
    the if statement, rather than having to be nested inside the else statement. You
    can add as many elseif statements as you want between the if and the else.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Syntax
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PHP offers an alternative syntax for if, if...else, and if...elseif...else statements
    that uses colons rather than curly brackets to set off the various parts of the
    code. This syntax is illustrated in [Listing 4-6](#lis4-6), which reproduces the
    if...else statement from [Listing 4-3](#lis4-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-6: The alternative syntax for conditional statements'
  prefs: []
  type: TYPE_NORMAL
- en: In this alternative syntax, the condition for the if statement is followed by
    a colon (:). This line acts like an opening curly bracket, so any statements between
    it and the else (or elseif) keyword are considered part of the statement group
    to be executed if the condition is true. The else keyword is similarly followed
    by a colon rather than an opening curly bracket. The statement group for the else
    branch ends with the endif keyword signaling that the whole if...else structure
    is over.
  prefs: []
  type: TYPE_NORMAL
- en: This alternative syntax is particularly useful for web applications, where HTML
    template text could appear between the if statement and the else statement, and
    the use of indented curly brackets could be hard to follow in the code. Likewise,
    the endif keyword clearly indicates that the overall conditional is ending.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP’s *logical operators* manipulate or combine Boolean expressions, producing
    a single true or false value. This way, you can write more sophisticated tests
    for conditional statements than simply comparing two values, as we’ve done so
    far (for example, testing whether two conditions are true). These logical operators
    perform operations such as AND, OR, and NOT. The operators are summarized in [Table
    4-1](#tab4-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-1: PHP Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Operator | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT | ! | !$a | true if $a is false |'
  prefs: []
  type: TYPE_TB
- en: '| AND | and&& | $a and $b$a && $b | true if both $a and $b are true |'
  prefs: []
  type: TYPE_TB
- en: '| OR | or&#124;&#124; | $a or $b$a &#124;&#124; $b | true if either $a or $b
    is true, or if both are true |'
  prefs: []
  type: TYPE_TB
- en: '| XOR | xor | $a xor $b | true if either $a or $b, but not both, is true |'
  prefs: []
  type: TYPE_TB
- en: 'Notice that AND and OR operations can be written two ways: with words (and
    or or) or with symbols (&& or ||). The two versions perform the same function,
    but the symbol versions have a higher precedence than the word versions when an
    expression is evaluated. (We discussed operator order of precedence in [Chapter
    1](chapter1.xhtml), in the context of arithmetic operators.)'
  prefs: []
  type: TYPE_NORMAL
- en: NOT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An exclamation mark (!) represents the NOT operator. This operator negates a
    Boolean expression or tests whether the expression is not true. For example, [Listing
    4-7](#lis4-7) uses the NOT operator to test a driver’s age. In Ireland, you have
    to be at least 17 years old to drive a car.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-7: An if statement using the NOT (!) operator'
  prefs: []
  type: TYPE_NORMAL
- en: 'The if statement checks whether it is *not* true that the value of $age is
    greater than or equal to 17. Since 15 is not 17 or more, you should see the following
    message printed out when you run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we’ve placed $age >= 17 in parentheses to separate it from the NOT
    operator. This is because the NOT operator normally takes higher precedence than
    the >= operator, but we want to check whether $age is greater than or equal to
    17 before using ! to negate that result. If we had written if (!$age >= 17) instead,
    without the inner parentheses, PHP would try to evaluate !$age first. The NOT
    operator requires a Boolean operand, so the value of 15 inside $age would be juggled
    to true (as would any other nonzero value). Then, since !true is false, we would
    have the expression false >= 17.
  prefs: []
  type: TYPE_NORMAL
- en: Next, PHP would try to evaluate the >= comparison, and since one of the operands
    is a Boolean, it would try to make the second operand a Boolean too. The integer
    17 would thus be juggled to true (since it’s nonzero), giving us the expression
    false >= true, which evaluates to false. Ultimately, without those extra parentheses,
    !$age >= 17 would evaluate to false for any nonzero integer value of $age.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid all this type juggling and potential for error due to missing parentheses,
    I often create a temporary Boolean variable for use in an if statement before
    introducing the NOT operator. For example, [Listing 4-8](#lis4-8) shows an alternate
    version of the code from [Listing 4-7](#lis4-7), with an extra variable to avoid
    any chance of mixing integers and Booleans.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-8: A cleaner version of [Listing 4-7](#lis4-7), with an extra Boolean
    variable'
  prefs: []
  type: TYPE_NORMAL
- en: We use the $seventeenAndOlder variable to store the true or false value of the
    $age >= 17 test. Then the if statement uses the NOT operator to test whether $seventeenAndOlder
    is not true. While this adds an extra line of code compared to [Listing 4-7](#lis4-7),
    it’s much clearer to understand since we’ve separated the age test Boolean expression
    from the if statement condition.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Placing expressions like* $age >= 17 *inside parentheses isn’t necessary when
    assigning their value to a variable. [Listing 4-8](#lis4-8) uses parentheses to
    help make the code clearer to read.*'
  prefs: []
  type: TYPE_NORMAL
- en: AND
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An expression with the AND operator is true when both operands are true. You
    can use either the keyword and or a double ampersand (&&) to create an AND operation.
    For example, the if...else statement in [Listing 4-9](#lis4-9) uses the AND operator
    to determine whether a driver meets both conditions to be allowed to take a driving
    test. In Ireland, you have to pass a theory test and hold a learner’s license
    for at least six months before you’re allowed to apply for a driving test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-9: An if...else statement using the AND operator'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the $passedTheoryTest variable as true, and $monthsHeldLearnersLicense
    with value 10. Then we test whether $monthsHeldLearnersLicense is greater than
    or equal to 6 and store the resulting Boolean (true, in this case) in the $heldLearnersLicenseEnough
    variable. Next, we declare an if...else statement with the condition $passedTheoryTest
    and $heldLearnersLicenseEnough. Since both values are true, the AND operation
    is true as well, so the message You may apply for a driving test will be printed
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Try changing $passedTheoryTest to false or setting $monthsHeldLearnersLicense
    to a value less than 6. The AND operation should then evaluate as false, and the
    message in the else branch of the statement should print out.
  prefs: []
  type: TYPE_NORMAL
- en: OR
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An OR operation is true when either or both operands are true. You can use either
    the keyword or or a double vertical pipe (||) to write an OR operation. [Listing
    4-10](#lis4-10) illustrates an if statement that uses the OR operator to determine
    whether a password fails basic security rules (by including the string 'password'
    or being less than six characters long).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-10: An if statement using the OR operator'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the $password variable storing the string '1234'. Then we declare
    two Boolean variables to help with our test. First, $passwordContainsPassword
    is assigned the result of passing variable $password and string 'password' to
    the built-in str_contains() function. This function returns true if the second
    string argument (the “needle”) is found anywhere inside the first string argument
    (the “haystack”), or false otherwise. Since in this case the $password variable
    doesn’t contain the string 'password', $passwordContainsPassword will contain
    false. The other Boolean variable, $passwordTooShort, will be true if the length
    of $password is less than 6, tested with the built-in strlen() function. Since
    the string '1234' in $password is less than six characters long, this variable
    will be assigned the value true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we declare an if statement, using the OR operator (||) to create the
    condition based on the two Boolean variables ❶. Since at least one of the variables
    is true, the if statement condition passes, and a message prints indicating the
    password is insecure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Try changing the value of $password to be a string six characters or longer
    (other than 'password')—for example, "red$99poppy". Then neither $passwordContainsPassword
    nor $passwordTooShort will be true, so the logical OR test in the if statement
    will be false and no message will be printed out.
  prefs: []
  type: TYPE_NORMAL
- en: XOR
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An XOR operation (short for *exclusive OR*) is true when only one of the operands
    is true but not both. We use keyword xor to create an XOR expression. [Listing
    4-11](#lis4-11) illustrates an if...else statement using an XOR operation. The
    code determines whether a dessert is creamy but not too creamy. (Custard *and*
    ice cream would be too much!)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-11: An if...else statement with the xor operator'
  prefs: []
  type: TYPE_NORMAL
- en: We declare two Boolean variables, $containsIceCream and $containsCustard, setting
    one to true and the other to false. Then we declare an if...else statement with
    the condition $containsIceCream xor $containsCustard. Thanks to the XOR operator,
    if one but not both of these variables is true, the condition will evaluate to
    true, and a nice creamy dessert will be printed out. If neither variable is true,
    or if both variables are true, then the XOR expression will be false, and either
    too creamy or not creamy enough! will be printed instead.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, since only one variable is true, we should get the nice creamy
    dessert message. Try playing with the values of the two Boolean variables and
    see how the result of the XOR expression is affected.
  prefs: []
  type: TYPE_NORMAL
- en: switch Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A switch statement is a conditional structure that tests a variable against
    several possible values, or *cases*. Each case has one or more statements to be
    executed if its value matches the variable’s (after type juggling, so it performs
    equality tests like ==). You can also provide a default case if none of the values
    match. If you need to choose from three or more possible paths, a switch statement
    is a convenient alternative to an if...elseif...else statement, as long as the
    decision hinges on the value of a single variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-12](#lis4-12) shows a switch statement that prints an appropriate
    message about the local currency based on the value of the $country variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-12: Using a switch statement to print the currency based on the value
    of $country'
  prefs: []
  type: TYPE_NORMAL
- en: First, we assign $country the value 'Ireland'. Then we begin a switch statement
    with the keyword switch followed by the variable to be tested in parentheses ($country)
    ❶. The remainder of the switch statement is enclosed in a set of curly brackets.
    Within the switch statement, we declare the values of $country to check, each
    in its own indented case clause. Each case clause is defined using the keyword
    case, followed by the value to be tested, followed by a colon (:). Then come the
    statements to execute if that case is a match on new, further indented lines.
    For example, if the value of $country is 'UK' ❷, the message The pound is the
    currency of UK will print.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the same set of actions to apply to multiple cases, list those cases
    one after the other, followed just once by the statement(s) to execute. For example,
    Ireland, France, and Spain all use the euro, so we’ve listed those cases in sequence
    ❸. The print statement after those cases ❹ will apply to any of them; you don’t
    need to repeat it for each case.
  prefs: []
  type: TYPE_NORMAL
- en: Our script features an additional case for when $country has the value 'USA'.
    Then the final part of the switch statement declares a default case using the
    default keyword rather than case ❺. This default will be executed if none of the
    other cases match the variable being tested. Given that we set $country to 'Ireland',
    the script should output the message The euro is the currency of Ireland.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we’ve included the break keyword in each case’s statement group,
    after each print statement. This interrupts, or *breaks out of*, the switch statement,
    preventing any further code in that statement from being executed. The role of
    break statements is essential to understand. Once a matching case has been found,
    all remaining statements in the body of the switch statement are executed, even
    statements from other, nonmatching cases, unless a break statement is encountered
    to interrupt the execution. If we removed all the break statements from [Listing
    4-12](#lis4-12), for example, we’d end up with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The value of $country is 'Ireland', not 'UK', so the first case isn’t a match,
    and the first print statement is skipped. Once we encounter the 'Ireland' case,
    however, the remaining three print statements execute, since there aren’t any
    break statements to interrupt the switch statement. This is rarely the behavior
    you’ll want from a switch statement, so in almost every situation, you’ll need
    to add a break statement to the end of each case (or set of cases), as we’ve done
    in [Listing 4-12](#lis4-12).
  prefs: []
  type: TYPE_NORMAL
- en: match Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A match statement chooses a value for a variable based on the value of another
    variable. You could accomplish the same task with a switch statement, but match
    statements are written much more compactly. Also, match statements rely on strict
    comparisons (the equivalent to testing for identity with ===), whereas switch
    statements make comparisons after any relevant type juggling (the equivalent to
    testing for equality with ==). Therefore, the time to use a match statement over
    a switch statement is when a variable needs to be tested against multiple values
    of the same type, and when the action to perform based on that test is to assign
    a value to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-13](#lis4-13) shows the same logic as [Listing 4-12](#lis4-12)’s
    switch statement, implemented with a match statement instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-13: Using a match statement to set $currency based on the value of
    $country'
  prefs: []
  type: TYPE_NORMAL
- en: We write the match statement as part of the assignment of the $currency variable
    ❶. It consists of the match keyword, followed by the variable to check in parentheses,
    followed by a comma-separated sequence of *arms* enclosed in curly brackets. Each
    arm is written in the form x => y, where y is the value to assign to $currency
    if the value of $country matches x. As with the switch statement, we provide a
    default arm in case none of the values match ❷. After the match statement, we
    print out a message including the values of $country and $currency.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the switch statement in [Listing 4-12](#lis4-12), this match statement
    is more concise. After assigning a value to $currency, we have to write only a
    single print statement, as opposed to including a separate print statement for
    each case of the switch statement. We also no longer need all the break statements;
    with a match statement, once a match has been found, the rest of the statement
    is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The match statement is a relative newcomer to the PHP language. Many experienced
    programmers still use switch where match would be more efficient. (I’m guilty
    of this myself sometimes.) In general, if you’re testing a variable against multiple
    values, I recommend trying a match statement first. Only if that solution is found
    inadequate should you change to a switch statement.
  prefs: []
  type: TYPE_NORMAL
- en: The Ternary Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PHP’s *ternary operator* (or *three-part operator*) selects one of two values,
    depending on whether a test is true or false. The operator consists of two separate
    symbols, a question mark (?) and a colon (:), and is written in the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To the left of the question mark, you write a Boolean expression that evaluates
    to true or false (for example, comparing two values). To the right of the question
    mark, you write two values separated by a colon. If the Boolean expression is
    true, the value to the left of the colon is chosen (valueIfTrue). If the Boolean
    expression is false, the value to the right of the colon is chosen (valueIfFalse).
    Usually, the result is assigned to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, the ternary operator provides a more succinct way to write an
    if...else statement, as long as the purpose of the if...else statement is to assign
    a value to a variable (as opposed to performing another sequence of actions).
    To illustrate, [Listing 4-14](#lis4-14) shows two ways to choose between two values
    for $currency based on the value of $region: first using an if...else statement
    and then using the ternary operator.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-14: Comparing if...else and ternary operator statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'We assign $region the value ''Europe''. Then we declare an if...else statement
    that sets the value of $currency to ''euro'' if the region is ''Europe'' or to
    ''dollar'' otherwise ❶. We print out a message to verify the result. Next, we
    change $region to ''USA'' and reassign $currency by using the ternary operator
    ❷. The ternary operator expression follows the same logic as the if...else statement:
    if $region equals ''Europe'', the code sets $currency to ''euro'', and if not,
    the code sets $currency to ''dollar''. Again, we print a message to check the
    result. Here’s the output of running the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The second line shows that the ternary operator has worked as expected, assigning
    'dollar' as the value of $currency because the value in $region wasn’t 'Europe'.
    As you can see, in a case like this that requires a straightforward decision between
    two possible values, the ternary operator is concise, using just one line of code
    compared to the four lines of the if...else statement.
  prefs: []
  type: TYPE_NORMAL
- en: The Null-Coalescing Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another operator that chooses between two values is the *null-coalescing operator*,
    indicated with a double question mark (??). This operator makes its choice depending
    on whether a variable is NULL. The general form of an expression using the null-coalescing
    operator is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, the null-coalescing operator checks value, the expression on the left
    of the ?? operator. This could be a variable, or perhaps a function that returns
    a value. If this expression isn’t NULL, then value is assigned to $variable. Otherwise,
    the value to the right of the null-coalescing operator (valueIfNull) is assigned
    to the variable instead. This provides a fallback in case a variable hasn’t been
    defined (or contains NULL), without raising a warning or error. This mechanism
    is especially useful when you’re expecting a value from a user but none has been
    provided, or when you’re looking for a record in a database and the record doesn’t
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-15](#lis4-15) shows the null-coalescing operator in action. We use
    it to test the $lastname_from_user variable twice, first before it’s been assigned
    any value (and therefore is NULL), then a second time after it’s been given a
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-15: Testing for NULL with the null-coalescing operator'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we use the null-coalescing operator to set the value of $lastname ❶.
    The operator tests the $lastname_from_user variable, which hasn’t been assigned
    a value yet, and so is NULL. Therefore, $lastname should be assigned the value
    to the right of the ?? operator (the string ''Anonymous''). We print out a message
    to check the result. Then, after assigning a value to $lastname_from_user, we
    use the same null-coalescing operator expression to again set the value of $lastname
    ❷. This time, since $lastname_from_user contains a non-NULL value, that value
    should be passed along to $lastname. Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first line shows that, since variable $lastname_from_user is NULL, $lastname
    is assigned the string 'Anonymous'. The second time around, however, the string
    'Smith' inside $lastname_from_user is successfully stored in the $lastname variable
    and printed out.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned about the keywords and operators for writing
    code that makes decisions. Much of the power of computers and programming languages
    is built upon the kinds of operators and choice statements we’ve discussed. You
    saw how if and if...else statements make a choice based on a single test, although
    that test may itself combine Boolean expressions with logical operators such as
    AND or OR. You also saw how to incorporate multiple tests by adding elseif branches
    between the if and the else. Then you learned about other conditional structures,
    including switch and match statements, that test a variable for different possible
    values. These structures let you define one or more statements to be executed
    when a particular value is found. Closely related to these are the ternary and
    null-coalescing operators, which both choose between two possible values.
  prefs: []
  type: TYPE_NORMAL
- en: '### Exercises'
  prefs: []
  type: TYPE_NORMAL
- en: 1.   Write a script that assigns a name to the $name variable and then prints
    the message That is a short name if the length of the string is less than four
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Write a script that determines the size of the machine you need for your
    laundry. The script should check the value of the $laundryWeightKg variable and
    print Fits in standard machine if the value is less than 9, or print Needs medium
    to large machine otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Use a switch statement or a match statement to test the value of the $vehicle
    variable and print an appropriate message based on that value. Use the following
    value/message combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: bus   "Beep beep"
  prefs: []
  type: TYPE_NORMAL
- en: train   "Runs on tracks"
  prefs: []
  type: TYPE_NORMAL
- en: car   "Has at least three wheels"
  prefs: []
  type: TYPE_NORMAL
- en: helicopter   "Can fly"
  prefs: []
  type: TYPE_NORMAL
- en: bicycle   "You never forget once you've learned"
  prefs: []
  type: TYPE_NORMAL
- en: '**(None of the above)**   "You''ve chosen the road less traveled"'
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Write a script that prints the message You are now logged in if both $userNameCorrect
    and $passwordCorrect are true. Otherwise, print Invalid credentials, please try
    again.
  prefs: []
  type: TYPE_NORMAL
