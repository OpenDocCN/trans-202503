<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch4"><span epub:type="pagebreak" id="page_35"/><span class="big">4</span><br/>DESCRIBING MOTION</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">The description of the motion of an object in terms of its position, velocity, and acceleration is called <em>kinematics</em>. In this chapter, we’ll give a succinct review of one-dimensional kinematics while showing how the Haskell language naturally encodes its ideas and equations. We’ll use the Haskell functions introduced in <a href="ch02.xhtml">Chapter 2</a> and the types we introduced in <a href="ch03.xhtml">Chapter 3</a>. The equations of kinematics, being largely definitional, have an almost one-to-one correspondence with Haskell functions.</p>&#13;
<h3 class="h3" id="ch4lev1">Position and Velocity on an Air Track</h3>&#13;
<p class="noindent">Have you ever seen an air track? An air track is a fun toy, or, if you’re feeling more serious, a piece of experimental equipment. It consists of a long horizontal rail (maybe 2 or 3 meters long) with little holes that allow air to shoot upward out of the rail. A small car (maybe 5 cm wide and 10 cm long) with no wheels rides atop this air track. The air eliminates most of the friction that would exist between the car and the rail as the car slides along the rail, so the car can slide freely along the air track. The cross section of the rail is <span epub:type="pagebreak" id="page_36"/>shaped so that the car can only slide back and forth along the length of the rail; the car cannot slide sideways or move up or down.</p>&#13;
<p class="indent">We can make marks on the air track to allow us to talk about the <em>position</em> of the car. Let’s imagine that we have an air track that has already been carefully marked in meters. For a particular motion of the car on the air track, we define <em>x</em> to be the function that associates each time <em>t</em> with the position of the car at that time. We say that <em>x</em>(<em>t</em>) is the position of the car at time <em>t</em>.</p>&#13;
<p class="indent"><em>Velocity</em> is defined to be the rate at which position changes. The <em>average velocity</em> over the time interval that starts at time <em>t</em><sub>0</sub> and ends at time <em>t</em><sub>1</sub> is</p>&#13;
<div class="imagec"><img src="Images/036equ01.jpg" alt="Image" width="435" height="48"/></div>&#13;
<p class="indent">Average velocity is change in position divided by change in time.</p>&#13;
<p class="indent">One of the advantages of using the Haskell programming language is that there is almost a one-to-one correspondence between the equations of physics and the code we write to describe them. In Haskell, the following lines, which could appear in a source code file, have the same meaning as Equation 4.1:</p>&#13;
<pre>averageVelocity :: Time -&gt; Time -&gt; PositionFunction -&gt; Velocity&#13;
averageVelocity t0 t1 x = (x t1 - x t0) / (t1 - t0)</pre>&#13;
<p class="indent">The first line of Haskell code is a type signature saying that <code>averageVelocity</code> is a function that takes a time, a second time, and a position function as input and gives a velocity as output. We can use the arrow (<code>-&gt;</code>) to chain together inputs. The last term is the output type, and all of the other terms are input types. There is a deeper reason for this notation that we will explore in <a href="ch06.xhtml">Chapters 6</a> and <a href="ch09.xhtml">9</a>.</p>&#13;
<p class="indent">The second line of Haskell code above is the definition for the function <code>averageVelocity</code>. The definition says that if we call <code>t0</code> the first time, <code>t1</code> the second time, and <code>x</code> the position function, the velocity will be given by the expression on the right of the equal sign. The inputs <code>t0</code> and <code>t1</code> are numbers, but the input <code>x</code> is a function. The practice of using functions as inputs to other functions is common in Haskell; we will discuss this in much more detail in <a href="ch06.xhtml">Chapter 6</a>.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4tab1">Table 4-1</a> shows a comparison of mathematical notation and Haskell notation.</p>&#13;
<p class="tabcap" id="ch4tab1"><strong>Table 4-1:</strong> Comparison of Mathematical Notation and Haskell Notation</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Mathematical notation</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Haskell notation</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>t</em><sub>0</sub></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>t0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>t</em><sub>1</sub></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>t1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>x</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>x</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>x</em>(<em>t</em><sub>0</sub>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>x t0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>x</em>(<em>t</em><sub>1</sub>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>x t1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"> <img class="inline" src="Images/036equ02.jpg" alt="Image" width="9" height="12"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>averageVelocity</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_37"/>As we saw in <a href="ch01.xhtml">Chapter 1</a>, parentheses are not required to apply a function to an argument. The <code>x</code> in the code is a function, just like the <em>x</em> in Equation 4.1. When we write <em>x</em>(<em>t</em><sub>0</sub>), we mean the function <em>x</em> applied to (or evaluated at) the time <em>t</em><sub>0</sub>. Similarly, when we write <code>x t0</code>, we mean the function <code>x</code> applied to (or evaluated at) the time <code>t0</code>. Functions play such a central role in Haskell that juxtaposition of names implies that the first is a function and the second is an argument, and that the function is to be applied to the argument.</p>&#13;
<p class="indent">The notation <img class="inline" src="Images/037equ01.jpg" alt="Image" width="50" height="21"/> explicitly shows that average velocity depends on the initial time <em>t</em><sub>0</sub> and the final time <em>t</em><sub>1</sub> of the time interval, but the dependence on the position function is implicit and not shown in Equation 4.1. Haskell code shows all dependencies explicitly.</p>&#13;
<h3 class="h3" id="ch4lev2">Types for Physical Quantities</h3>&#13;
<p class="noindent">It makes our thinking simpler if we can talk about velocity at a single time rather than over a time interval. We can take a step in this direction by labeling the average velocity with the time at the center of the interval and the length of the interval, rather than with the beginning and ending times.</p>&#13;
<div class="imagec"><img src="Images/037equ02.jpg" alt="Image" width="496" height="44"/></div>&#13;
<p class="indent">In Haskell, Equation 4.2 looks like the following:</p>&#13;
<pre>averageVelocity2 :: Time -&gt; TimeInterval -&gt; PositionFunction&#13;
                 -&gt; Velocity&#13;
averageVelocity2 t dt x = (x (t + dt/2) - x (t - dt/2)) / dt</pre>&#13;
<p class="indent">Here, we do need to enclose <code>t + dt/2</code> in parentheses so that adding <code>t</code> to <code>dt/2</code> takes place before the function <code>x</code> is applied.</p>&#13;
<p class="indent">Notice that in the code above, the types from the type signature match up with the arguments in the definition in the same order, as emphasized in <a href="ch04.xhtml#ch4tab2">Table 4-2</a>.</p>&#13;
<p class="tabcap" id="ch4tab2"><strong>Table 4-2:</strong> Matching of Arguments and Types for the Function <code>average Velocity2</code></p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Argument</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>t</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Time</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>dt</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>TimeInterval</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>x</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>PositionFunction</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">At this point, we’re only dealing with motion in one dimension, so time, position, and velocity are all represented by numbers. We tell the Haskell compiler this with the following lines, which are called <em>type synonyms</em>.</p>&#13;
<span epub:type="pagebreak" id="page_38"/>&#13;
<pre>type R = Double&#13;
&#13;
type Time         = R&#13;
type TimeInterval = R&#13;
type Position     = R&#13;
type Velocity     = R&#13;
&#13;
type PositionFunction = Time -&gt; Position&#13;
type VelocityFunction = Time -&gt; Velocity</pre>&#13;
<p class="indent">The only type in the lines above that Haskell understands by default is <code>Double</code>. I prefer to think of this as the type of real numbers (not every real number can be represented by a <code>Double</code>, but we are willing to do approximate calculation), so I like the name <code>R</code> better than <code>Double</code>.</p>&#13;
<p class="indent">The first line says that whenever I use the type <code>R</code>, it means the same thing as <code>Double</code>. The next four lines say that time, time interval, position, and velocity are all just real numbers at this point. Finally, the last two lines define function types. The type <code>PositionFunction</code> is the type of a function that takes time as input and gives position as output. Recall that the argument <code>x</code> above was a function with this type. Since <code>Time</code> is the same as <code>R</code> and <code>Position</code> is the same as <code>R</code>, the type <code>PositionFunction</code> is the same as <code>R -&gt; R</code>, which takes a real number as input and produces a real number as output. For a similar reason, the type <code>VelocityFunction</code> is also the same as the function type <code>R -&gt; R</code>.</p>&#13;
<p class="indent">A type synonym merely gives an additional name to an existing type. The compiler sees <code>Double</code>, <code>R</code>, <code>Position</code>, and <code>Velocity</code> as identical and is unable to warn us if we attempt to use a <code>Velocity</code> where a <code>Position</code> is called for. In <a href="ch10.xhtml">Chapter 10</a>, we will introduce a way to define a new type that is distinct from all existing types and allows the compiler to check that we haven’t confused one type with another. There is also a Haskell package called <code>units</code> (<a href="https://hackage.haskell.org/package/units"><em>https://hackage.haskell.org/package/units</em></a>) specifically designed to allow physical units such as meters per second to be attached to numerical quantities.</p>&#13;
<h3 class="h3" id="ch4lev3">Introducing Derivatives</h3>&#13;
<p class="noindent">If in making the time interval Δ<em>t</em> shorter and shorter we find that the average velocity converges to a particular value, we call this value the <em>instantaneous velocity</em>.</p>&#13;
<div class="imagec"><img src="Images/038equ01.jpg" alt="Image" width="504" height="45"/></div>&#13;
<p class="indent">A limit of a ratio of differences occurs often enough that it gets awarded the name <em>derivative</em>. Given a function <em>x</em> of one variable, the derivative of <em>x</em>, denoted <em>Dx</em>, <em>x</em>’, or <img class="inline" src="Images/xdot.jpg" alt="Image" width="10" height="15"/>, is the function of one variable defined as follows:</p>&#13;
<div class="imagec"><img src="Images/038equ02.jpg" alt="Image" width="491" height="44"/></div>&#13;
<div class="box5">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_39"/><strong>HANDLING CONTINUOUS TIME</strong></p>&#13;
<p class="sb-noindent">The mathematical definitions of limit and derivative require a continuity of real numbers that may not be present in the physical world. There’s a bit of idealization when we imagine time to be continuous. Time certainly seems to be continuous, and no one has made any direct measurements that suggest a discreteness to time, but there are quantum theoretical reasons to believe that at some very short scale, time may not behave as a perfect continuum.</p>&#13;
<p class="sb-noindent">To make a guess at a time scale when quantum effects are likely to disturb the continuity of time, we can use <em>dimensional analysis</em>, which means combining parameters that are relevant to the situation to construct a quantity with dimensions of time. We haven’t said anything at all about the situation, so all we have to work with are fundamental constants of physics, namely the Newtonian constant of gravitation <em>G</em>, Planck’s constant <img class="inline" src="Images/hbar.jpg" alt="Image" width="5" height="6"/>, and the speed of light in a vacuum <em>c</em>. There is only one way to multiply powers of these fundamental constants to produce a result with dimensions of time. The resulting time is called the <em>Planck time</em>, and it looks like this:</p>&#13;
<div class="imagec"><img src="Images/039equ01.jpg" alt="Image" width="205" height="50"/></div>&#13;
<p class="sb-noindent">The Planck time is many, many orders of magnitude smaller than the smallest time scales that can currently be probed. For the physics that is experimentally accessible today, time appears continuous, and the derivative is in no danger of becoming obsolete.</p>&#13;
</div>&#13;
<p class="indent">We can say that instantaneous velocity is the derivative of position.</p>&#13;
<div class="imagec"><img src="Images/039equ02.jpg" alt="Image" width="374" height="20"/></div>&#13;
<p class="indent">Note that Equation 4.5 is an equality of functions: the instantaneous velocity function is on the left of the equality and the derivative of the position function is on the right. When two functions are equal, they give equal results for equal inputs, so we can also write</p>&#13;
<div class="imagec"><img src="Images/039equ03.jpg" alt="Image" width="394" height="20"/></div>&#13;
<p class="noindent">for any time <em>t</em>. The right-hand side is the function <em>Dx</em> evaluated at the time <em>t</em>. We can think of the derivative operator as taking the entire position function as input and returning the velocity function as output.</p>&#13;
<p class="indent">It’s more common to see the notation</p>&#13;
<div class="imagec"><img src="Images/039equ04.jpg" alt="Image" width="394" height="44"/></div>&#13;
<p class="noindent">to define velocity. Equation 4.5 is more succinct, but Equations 4.5, 4.6, and 4.7 all mean the same thing. We say that <em>v</em>(<em>t</em>) is the velocity of the car at time <em>t</em>. Note that the velocity of the car on the air track can be negative (meaning the position is decreasing) or positive (meaning the position is increasing).</p>&#13;
<h3 class="h3" id="ch4lev4"><span epub:type="pagebreak" id="page_40"/>Derivatives in Haskell</h3>&#13;
<p class="noindent">A derivative takes a function as input and gives a function as output. In other words, a derivative is a function from functions to functions. A function that takes another function as input or returns a function as output is called a <em>higher-order function</em>. If the idea of functions as inputs and outputs of other functions is new to you, it will take some practice and examples to get used to, but I assure you that it is worth the effort. There are many ideas in physics, the derivative being just one, that are naturally expressed as higher-order functions. <a href="ch06.xhtml">Chapter 6</a> is entirely devoted to such higher-order functions.</p>&#13;
<p class="indent">One possible type synonym for a derivative looks like this:</p>&#13;
<pre>type Derivative = (R -&gt; R) -&gt; R -&gt; R</pre>&#13;
<p class="indent">Since arrows are right associative, with the rightmost arrow having highest precedence, the type <code>(R -&gt; R) -&gt; R -&gt; R</code> is the same as <code>(R -&gt; R) -&gt; (R -&gt; R)</code>.</p>&#13;
<p class="indent">We can write a numerical derivative in Haskell like this:</p>&#13;
<pre>derivative :: R -&gt; Derivative&#13;
derivative dt x t = (x (t + dt/2) - x (t - dt/2)) / dt</pre>&#13;
<p class="indent">This numerical derivative does not take a limit but instead uses a small interval, <code>dt</code>, supplied by the user. If the interval is small enough, the result should be a good approximation to the derivative.</p>&#13;
<p class="indent">Let’s play the matching game with arguments and types for the function <code>derivative</code> like we did for the function <code>averageVelocity2</code>. At first glance, it seems that <code>dt</code> has type <code>R</code>, <code>x</code> has type <code>Derivative</code>, and <code>t</code> is left with no type at all. This does not make any sense; the trouble is that we need to expand the <code>Derivative</code> type. When fully expanded, <code>derivative</code> has the following type:</p>&#13;
<pre>derivative :: R -&gt; (R -&gt; R) -&gt; R -&gt; R</pre>&#13;
<p class="indent">Now, <code>dt</code> has type <code>R</code>, <code>x</code> has type <code>R -&gt; R</code>, <code>t</code> has type <code>R</code>, and the final <code>R</code> is the return type.</p>&#13;
<p class="indent">In playing the matching game, we are thinking of <code>derivative</code> as a function with three inputs and one output. The arrow notation may seem a strange way to specify a function with three inputs. There is a deeper meaning to the notation that we will discuss briefly now and treat more fully in <a href="ch06.xhtml">Chapter 6</a>.</p>&#13;
<p class="indent">Since arrows associate to the right, the following three types are the same to the compiler:</p>&#13;
<ul class="bull">&#13;
<li class="noindent"><code>R -&gt; (R -&gt; R)  -&gt;  R -&gt; R</code></li>&#13;
<li class="noindent"><code>R -&gt; (R -&gt; R)  -&gt; (R -&gt; R)</code></li>&#13;
<li class="noindent"><code>R -&gt; ((R -&gt; R) -&gt; (R -&gt; R))</code></li>&#13;
</ul>&#13;
<p class="indentt">Using the thinking from the matching game, it appears that the first type takes three inputs, the second type takes two inputs, and the third type takes one input.</p>&#13;
<p class="indent">There are three ways to think about the function <code>derivative</code>:</p>&#13;
<ul class="bull">&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_41"/><code>derivative</code> takes three inputs, with types <code>R</code>, <code>R -&gt; R</code>, and <code>R</code>, and produces one output with type <code>R</code>. In this way of thinking, <code>derivative</code> takes a time interval, a position function, and a time and returns the numeric velocity at that time. This was our thinking in the matching game.</li>&#13;
<li class="noindent"><code>derivative</code> takes two inputs, with types <code>R</code> and <code>R -&gt; R</code>, and produces one output with type <code>R -&gt; R</code>. In this way of thinking, <code>derivative</code> takes a time interval and a position function and returns a velocity function.</li>&#13;
<li class="noindent"><code>derivative</code> takes one input with type <code>R</code> (namely <code>dt</code>) and produces one output with type <code>(R -&gt; R) -&gt; R -&gt; R</code> (or type <code>Derivative</code>). This is the way the compiler thinks of it.</li>&#13;
</ul>&#13;
<p class="indentt">These three ways of thinking are mathematically equivalent, but they seem to sit differently with the brain. The second way of thinking is my favorite because I like to think of a derivative as something that takes a function as input and gives a function as output.</p>&#13;
<p class="indent">Transforming a function with two inputs into a function with one input whose output is a function is called <em>currying</em>, named after the logician Haskell Curry (who donates his first name to the programming language we are using). Currying is discussed more fully in <a href="ch06.xhtml">Chapters 6</a> and <a href="ch09.xhtml">9</a>. Currying allows the compiler to treat all functions as having a single input and a single output, with the understanding that the input and/or the output might be a function.</p>&#13;
<h3 class="h3" id="ch4lev5">Modeling the Car’s Position and Velocity</h3>&#13;
<p class="noindent">Suppose we have a car position function</p>&#13;
<div class="imagec"><img src="Images/041equ01.jpg" alt="Image" width="387" height="20"/></div>&#13;
<p class="noindent">in which <em>t</em> is in seconds and <em>x<sub>C</sub></em> is in meters. The corresponding Haskell code is as follows:</p>&#13;
<pre>carPosition :: Time -&gt; Position&#13;
carPosition t = cos t</pre>&#13;
<p class="indent">Using Equation 4.5, we can find the velocity function for the car.</p>&#13;
<div class="imagec"><img src="Images/041equ02.jpg" alt="Image" width="386" height="20"/></div>&#13;
<p class="indent">The corresponding Haskell code could be something like the following:</p>&#13;
<pre>carVelocity :: Time -&gt; Velocity&#13;
carVelocity = derivative 0.01 carPosition</pre>&#13;
<p class="indent">In the Haskell code, <code>derivative 0.01</code> is playing the role of the derivative operator <em>D</em> in the mathematical expression. These are not exactly the same thing because <em>D</em> is a true mathematical derivative and <code>derivative 0.01</code> is only a numerical derivative, but we can get decent approximate results by using <span epub:type="pagebreak" id="page_42"/>it, and we can improve our results to the degree that we like by using a number smaller than <code>0.01</code>. Moreover, <code>derivative 0.01 sin</code> is a perfectly valid function with type <code>R -&gt; R</code> in the Haskell language and is every bit as legitimate as the function <code>cos</code> (also type <code>R -&gt; R</code>) that it approximates. It can be evaluated, graphed, differentiated, integrated, or used anywhere that a function with type <code>R -&gt; R</code> can be used.</p>&#13;
<p class="indent">Equation 4.9 is an equality of functions, and the corresponding Haskell code defines the function <code>carVelocity</code> without using any function arguments. This is the point-free style introduced in <a href="ch02.xhtml">Chapter 2</a>.</p>&#13;
<p class="indent">It’s just as valid to write Haskell code based on Equation 4.6. The mathematical equation would then look like the following:</p>&#13;
<div class="imagec"><img src="Images/042equ01.jpg" alt="Image" width="406" height="20"/></div>&#13;
<p class="indent">And the Haskell code would look like this:</p>&#13;
<pre>carVelocity' :: Time -&gt; Velocity&#13;
carVelocity' t = derivative 0.01 carPosition t</pre>&#13;
<p class="indent">We use a prime to denote an alternate way of writing the function. As far as the computer is concerned, <code>carVelocity</code> and <code>carVelocity'</code> mean the same thing. The difference is one of notational preference. We’ll often use primes in code to indicate an alternate way of writing something. This prime has nothing to do with the derivative.</p>&#13;
<p class="indent">The position function for the car is given analytically, so we can take the derivative analytically and write an explicit equation for the velocity of the car.</p>&#13;
<div class="imagec"><img src="Images/042equ02.jpg" alt="Image" width="402" height="20"/></div>&#13;
<p class="noindent">We can also write this in Haskell as</p>&#13;
<pre>carVelocityAnalytic :: Time -&gt; Velocity&#13;
carVelocityAnalytic t = -sin t</pre>&#13;
<p class="noindent">but in this book we’re not asking the computer to do symbolic algebra or to take derivatives analytically. The function <code>carVelocityAnalytic</code> is <em>not</em> the same function as <code>carVelocity</code> or <code>carVelocity'</code>. The numeric value of <code>carVelocity 2</code> is close to, but not exactly the same as, the numeric value of <code>carVelocityAnalytic</code> <code>2</code>. In this book, we’ll only ask the computer to do things that a scientific calculator can do. Nevertheless, we’ll find that Haskell’s notation will aid our thinking through attention to the types of expressions, through the concision allowed by higher-order functions and through the simplicity of writing language that avoids mutable state.</p>&#13;
<p class="indent">There is an even better way to express Equation 4.5 in Haskell. The function <code>velFromPos</code> accepts any position function as input and supplies the corresponding velocity function as output.</p>&#13;
<pre>velFromPos :: R                   -- dt&#13;
           -&gt; (Time -&gt; Position)  -- position function&#13;
           -&gt; (Time -&gt; Velocity)  -- velocity function&#13;
velFromPos dt x = derivative dt x</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_43"/>We see that the function to find velocity from position is none other than the derivative function we defined earlier. Note also that we can split a type signature across multiple lines. This is often good practice, and it gives the code writer the opportunity to give a short comment about the meaning of each type in the signature.</p>&#13;
<p class="indent">If the velocity happens to be constant, say <em>v</em><sub>0</sub>, we can integrate both sides of Equation 4.5 or 4.7 to obtain</p>&#13;
<div class="equationc"><em>v</em><sub>0</sub><em>t</em> = <em>x</em>(<em>t</em>) – <em>x</em>(0)</div>&#13;
<p class="indent">If velocity is constant, position is a linear function of time.</p>&#13;
<div class="equationc"><em>x</em>(<em>t</em>) = <em>v</em><sub>0</sub><em>t</em> + <em>x</em>(0)</div>&#13;
<p class="indent">Here is the corresponding Haskell code:</p>&#13;
<pre>positionCV :: Position -&gt; Velocity -&gt; Time -&gt; Position&#13;
positionCV x0 v0 t = v0 * t + x0</pre>&#13;
<p class="indent">The <code>CV</code> at the end of the name is an abbreviation for constant velocity. Notice again the different ways to read the type: we can think of <code>positionCV</code> as a function that takes three arguments and returns a <code>Position</code>, as a function that takes two arguments and returns a function <code>Time -&gt; Position</code>, or as a function that takes one argument and returns a function <code>Velocity -&gt; Time -&gt;</code> <code>Position</code>. The expression <code>positionCV 5 10 2</code> is the <code>Position</code> of an object at time 2 s, if it moves with a constant velocity of 10 m/s and started at a position of 5 m when time was 0. The expression <code>positionCV 5 10</code> is the <code>PositionFunction</code> that describes an object moving with a constant velocity of 10 m/s that started at a position of 5 m when time was 0.</p>&#13;
<p class="indent">In everyday speech we often use the terms <em>velocity</em> and <em>speed</em> interchangeably. The language of physics makes a technical distinction between these two terms. <em>Speed</em> is the magnitude (absolute value) of velocity. Speed is never negative. Although speed (that is, how fast something is going) is the simpler idea to understand, velocity is much more important to the theory of motion. Velocity contains more information than speed because it tells the direction of travel as well as the speed. The velocity of a rock thrown straight upward makes a continuous regular change, both while the rock travels upward and while it travels downward. Speed, on the other hand, decreases on the way up and increases on the way down, unnecessarily making it seem like the situation needs to be thought of as two processes. There will be times when it is convenient to speak about speed, and it is certainly worth having a concept and a word for it. When we discuss motion in more than one dimension, velocity will require a vector for its description, while speed will remain a number.</p>&#13;
<h3 class="h3" id="ch4lev6"><span epub:type="pagebreak" id="page_44"/>Modeling Acceleration</h3>&#13;
<p class="noindent"><em>Acceleration</em> is defined to be the rate at which velocity changes. We define <em>a</em> to be the function that associates with each time <em>t</em> the rate at which the velocity is changing at time <em>t</em>. In the language of calculus, we can write</p>&#13;
<div class="imagec"><img src="Images/044equ01.jpg" alt="Image" width="375" height="20"/></div>&#13;
<p class="noindent">or</p>&#13;
<div class="imagec"><img src="Images/044equ02.jpg" alt="Image" width="395" height="44"/></div>&#13;
<p class="noindent">to define acceleration. Equation 4.12 is more succinct, but the two equations mean the same thing. We say that <em>a</em>(<em>t</em>) is the acceleration of the car at time <em>t</em>.</p>&#13;
<p class="indent">We’re only dealing with one-dimensional motion in this chapter, so we represent acceleration with a number.</p>&#13;
<pre>type Acceleration = R</pre>&#13;
<p class="indent">Equation 4.12 can be encoded in a function <code>accFromVel</code> that produces an acceleration function from a velocity function.</p>&#13;
<pre>accFromVel :: R                       -- dt&#13;
           -&gt; (Time -&gt; Velocity)      -- velocity function&#13;
           -&gt; (Time -&gt; Acceleration)  -- acceleration function&#13;
accFromVel = derivative</pre>&#13;
<p class="indent">Again, this function is just the derivative. Here, we use point-free style to emphasize the equality of the two functions.</p>&#13;
<p class="indent">If the acceleration happens to be constant, say <em>a</em><sub>0</sub>, we can integrate both sides of Equation 4.12 or 4.13 to obtain</p>&#13;
<div class="equationc"><em>a</em><sub>0</sub><em>t</em> = <em>v</em>(<em>t</em>) – <em>v</em>(0)</div>&#13;
<p class="indent">If acceleration is constant, velocity is a linear function of time.</p>&#13;
<div class="imagec"><img src="Images/044equ03.jpg" alt="Image" width="412" height="20"/></div>&#13;
<p class="indent">Here is the Haskell code for Equation 4.14:</p>&#13;
<pre>velocityCA :: Velocity -&gt; Acceleration -&gt; Time -&gt; Velocity&#13;
velocityCA v0 a0 t = a0 * t + v0</pre>&#13;
<p class="indent">The <code>CA</code> at the end of the name is an abbreviation for constant acceleration.</p>&#13;
<p class="indent">To believe that we really know what is happening with an object in motion, we want an expression that gives the position of the object as a function of time. Since position is the antiderivative or integral of velocity, we can obtain such a relationship by integrating both sides of Equation 4.14 to obtain</p>&#13;
<div class="imagec"><img src="Images/044equ04.jpg" alt="Image" width="219" height="44"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_45"/>If acceleration is constant, position is a quadratic function of time.</p>&#13;
<div class="imagec"><img src="Images/045equ01.jpg" alt="Image" width="456" height="44"/></div>&#13;
<p class="indent">Here is the Haskell code for Equation 4.15:</p>&#13;
<pre>positionCA :: Position -&gt; Velocity -&gt; Acceleration&#13;
           -&gt; Time -&gt; Position&#13;
positionCA x0 v0 a0 t = a0 * t**2 / 2 + v0 * t + x0</pre>&#13;
<p class="indent">Equations 4.14 and 4.15 are known as <em>constant acceleration equations</em>. They are used over and over again in a typical introductory physics course. Later we will learn some techniques to deal with situations in which acceleration is not constant.</p>&#13;
<p class="indent">The relationships between time, position, velocity, and acceleration are known as <em>kinematics</em>, or the description of motion. These are the quantities required to give a description of how a car on an air track is moving. We will need to introduce additional ideas, like force and mass, before we have a theory that can account for the causes of motion.</p>&#13;
<h3 class="h3" id="ch4lev7">Approximate Algorithms and Finite Precision</h3>&#13;
<p class="noindent">In mathematics, the derivative is defined by the limit in Equation 4.4. In many cases, a mathematical derivative of an explicitly specified function can be calculated exactly. The numerical <code>derivative</code> we defined in this chapter does not take a limit, relying instead on a small but finite <em>ϵ</em>. For this reason, the numerical derivative calculates an approximation to the derivative of a function. We call the rule for computing the derivative from a finite value of <em>ϵ</em> an <em>approximate algorithm</em>.</p>&#13;
<p class="indent">The use of approximate algorithms is the second source of inexactness in our computations. In <a href="ch01.xhtml">Chapter 1</a>, we saw that numbers with type <code>R</code>, or <code>Double</code>, are generally not represented exactly by the computer. Some numbers can be represented exactly, but even a number as seemingly innocent as 0.1 is not represented exactly as an <code>R</code>. This is because, like the number 0.2 in <a href="ch01.xhtml#ch1tab4">Table 1-4</a>, 0.1 requires an infinite binary expansion (0.0001100110011. . .), which the computer truncates at some point. This is usually not a problem because an <code>R</code> provides about 15 significant figures of precision, which is enough for our purposes but still <em>finite precision</em>. If we add a very small number to a very big number,</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">1e9 + 1e-9</span>&#13;
1.0e9</pre>&#13;
<p class="noindent">the computer just throws away the very small number.</p>&#13;
<p class="indent">Even if the computer doesn’t go to the extreme of throwing away a small number, the relative precision with which the small number is represented gets worse when it is added to a big number. For example, each of the numbers from 1/3 down to 1/3 × 10<sup>18</sup> in <a href="ch04.xhtml#ch4tab3">Table 4-3</a> has about 15 decimal digits of precision, as indicated by the number of threes in its expression.</p>&#13;
<p class="tabcap" id="ch4tab3"><span epub:type="pagebreak" id="page_46"/><strong>Table 4-3:</strong> Fractions Evaluated to About 15 Decimal Digits of Precision</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expression</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Evaluates to</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1/3</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>0.3333333333333333</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1/3000</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>3.333333333333333e-4</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1/3e6</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>3.3333333333333335e-7</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1/3e9</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>3.333333333333333e-10</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1/3e12</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>3.3333333333333334e-13</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1/3e15</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>3.333333333333333e-16</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>1/3e18</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>3.3333333333333334e-19</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">However, when each of these numbers is added to the relatively large number 1, a different number of threes is kept, as shown in <a href="ch04.xhtml#ch4tab4">Table 4-4</a>, depending on the relative size of the two numbers being added. When adding 1/3 × 10<sup>9</sup>, for example, only 6 of its 15 threes are retained.</p>&#13;
<p class="tabcap" id="ch4tab4"><strong>Table 4-4:</strong> How Adding a Small Number to a Relatively Big Number Reduces the Relative Precision of the Small Number</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expression</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Evaluates to</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1 + 1/3</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1.3333333333333333</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1 + 1/3000</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1.0003333333333333</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1 + 1/3e6</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1.0000003333333334</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1 + 1/3e9</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1.0000000003333334</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1 + 1/3e12</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1.0000000000003333</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1 + 1/3e15</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1.0000000000000004</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>1 + 1/3e18</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>1.0</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The process of adding a small number to a big number is central to the idea of a derivative. We would like <em>ϵ</em> to be small, but the fact that an <code>R</code> is only an approximation to a real number means we don’t want it to be too small.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4tab5">Table 4-5</a> shows the relative error in a numerical derivative of the function <em>f</em>, where <em>f</em> (<em>x</em>) = <em>x</em><sup>4</sup>/4. The exact derivative is <em>Df</em> (<em>x</em>) = <em>x</em><sup>3</sup>. The derivative is evaluated at <em>x</em> = 1, so the exact result is 1. Each row of the table shows the relative error for values of <em>ϵ</em> that range from 1 down to 10<sup>–18</sup>.</p>&#13;
<p class="tabcap" id="ch4tab5"><strong>Table 4-5:</strong> Relative Error of a Numerical Derivative That Decreases as <em>ϵ</em> Gets Smaller and Increases as <em>ϵ</em> Gets Smaller Still</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expression</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Evaluates to</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>derivative 1 (\x -&gt; x**4 / 4) 1 - 1</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>0.25</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>derivative 1e-3 (\x -&gt; x**4 / 4) 1 - 1</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>2.499998827953931e-7</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>derivative 1e-6 (\x -&gt; x**4 / 4) 1 - 1</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1.000088900582341e-12</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>derivative 1e-9 (\x -&gt; x**4 / 4) 1 - 1</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>8.274037099909037e-8</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>derivative 1e-12 (\x -&gt; x**4 / 4) 1 - 1</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>8.890058234101161e-5</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>derivative 1e-15 (\x -&gt; x**4 / 4) 1 - 1</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>-7.992778373592246e-4</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>derivative 1e-18 (\x -&gt; x**4 / 4) 1 - 1</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>-1.0</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_47"/>As <em>ϵ</em> decreases from 1 down to 10<sup>–6</sup>, the error gets smaller. For these values of <em>ϵ</em>, the approximate nature of the derivative algorithm is a larger contribution to the error than the finite precision used by the computer. But as <em>ϵ</em> continues to decrease, the error in the table gets larger. For these values of <em>ϵ</em>, the finite precision used in the calculation and representation of numbers is a larger contribution to the error than the approximate algorithm for computing the derivative.</p>&#13;
<p class="indent">In the case of the numerical derivative, finite precision wants <em>ϵ</em> to be large so its relative precision is maintained, but the algorithm wants <em>ϵ</em> to be small to approach the true derivative. The best results are obtained somewhere in the middle, around <em>ϵ</em> = 10<sup>–6</sup> for the situation in <a href="ch04.xhtml#ch4tab5">Table 4-5</a>.</p>&#13;
<p class="indent">These two sources of inaccuracy, finite precision and approximate algorithms, are going to be with us throughout our journey in computational physics. The algorithms for solving differential equations that we introduce later are also approximate algorithms, relying on small but finite steps to solve differential equations that are continuous. We will introduce rules of thumb for choosing such small finite parameters. Our attitude in this book is not to deeply study the interesting subject of numerical analysis, or to take an alarmist view toward inaccuracy, but rather simply to be aware of the nature of approximate calculation so we can produce meaningful results.</p>&#13;
<h3 class="h3" id="ch4lev8">Summary</h3>&#13;
<p class="noindent">This chapter introduced the notions of position, velocity, acceleration, and time, as well as their relationships, which are articulated by the mathematical idea of a derivative. We saw how various kinematic equations can be encoded in Haskell. In the next chapter, we take a look at lists, which play a role almost as central as functions in functional programming because they are the basis of most of our iteration.</p>&#13;
<h3 class="h3" id="ch4lev9">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 4.1.</strong> Consider the following function:</p>&#13;
<div class="imagec"><img src="Images/047equ01.jpg" alt="Image" width="88" height="45"/></div>&#13;
<p class="indent">The derivative of this function is <em>Df</em> (<em>x</em>) = <em>x</em>. In this case, <em>Df</em> is the identity function on real numbers. Because</p>&#13;
<div class="imagec"><img src="Images/047equ02.jpg" alt="Image" width="617" height="49"/></div>&#13;
<p class="noindentts">even before we take the limit, our numerical <code>derivative</code> should give exact results for any <em>ϵ</em> that we use. Write Haskell code to take the derivative of <em>f</em> using <code>derivative 10</code>, <code>derivative 1</code>, and <code>derivative 0.1</code>. You should find that <code>derivative 10</code> and <code>derivative 1</code> produce the identity function exactly and that <code>derivative 0.1</code> comes very close but is not exact. Why does <code>derivative 0.1</code> not produce exactly the identity function on real numbers?</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_48"/><strong>Exercise 4.2.</strong> Consider the following function:</p>&#13;
<div class="equationc"><em>f</em>(<em>x</em>) = <em>x</em><sup>3</sup></div>&#13;
<p class="indent">The derivative of this function is <em>Df</em> (<em>x</em>) = 3<em>x</em><sup>2</sup>. The error introduced by the numerical derivative at a particular value of <em>x</em> is the absolute value of the difference between the numerical derivative evaluated at <em>x</em> and the exact derivative evaluated at <em>x</em>. Write Haskell code to take the derivative of <em>f</em> using <code>derivative 1</code>. By evaluating the derivative at different values of <em>x</em>, see if you can find a pattern for the error introduced by the numerical derivative. After you find the pattern for this error, extend your exploration to <code>derivative a</code> for different values of <code>a</code>. Can you give an expression for the error in terms of <code>a</code>?</p>&#13;
<p class="indent">When <em>x</em> = 4, <em>Df</em> (4) = 48. What value of <code>a</code> produces an error of 1 percent at <em>x</em> = 4? When <em>x</em> = 0.1, <em>Df</em> (0.1) = 0.03. What value of <code>a</code> produces an error of 1 percent at <em>x</em> = 0.1?</p>&#13;
<p class="noindentts"><strong>Exercise 4.3.</strong> Find a function and a value of its independent variable so that <code>derivative 0.01</code> produces at least a 10 percent error compared to the exact derivative.</p>&#13;
<p class="noindentts"><strong>Exercise 4.4.</strong> Consider the cosine function, <code>cos</code>, and its numerical derivative <code>derivative a cos</code>. For what values of the independent variable (let’s call it <code>t</code>) is the numerical derivative most sensitive to the value of <code>a</code>? For what values is it least sensitive? You should be able to find some values of <code>t</code> where <code>a</code> can be made very large and the numerical derivative is still a good approximation.</p>&#13;
<p class="noindentts"><strong>Exercise 4.5.</strong> Consider the following position function:</p>&#13;
<pre>pos1 :: Time -&gt; Position&#13;
pos1 t = if t &lt; 0&#13;
         then 0&#13;
         else 5 * t**2</pre>&#13;
<p class="indent">Write functions</p>&#13;
<pre>vel1Analytic :: Time -&gt; Velocity&#13;
vel1Analytic t = undefined</pre>&#13;
<p class="noindentts">and</p>&#13;
<pre>acc1Analytic :: Time -&gt; Acceleration&#13;
acc1Analytic t = undefined</pre>&#13;
<p class="noindentts">for the corresponding velocity and acceleration functions by taking an analytic derivative of the position function.</p>&#13;
<p class="indent">The <code>undefined</code> function can be used as a placeholder for code not yet written. The compiler will accept <code>undefined</code> and happily compile the code, but if you try to use a function based on <code>undefined</code>, you will get a runtime error.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_49"/>Write functions</p>&#13;
<pre>vel1Numerical :: Time -&gt; Velocity&#13;
vel1Numerical t = undefined</pre>&#13;
<p class="noindentts">and</p>&#13;
<pre>acc1Numerical :: Time -&gt; Acceleration&#13;
acc1Numerical t = undefined</pre>&#13;
<p class="noindentts">for the corresponding velocity and acceleration functions by taking a numerical derivative of the position function using <code>derivative 0.01</code>. Can you find any values of <code>t</code> where <code>vel1Analytic t</code> and <code>vel1Numerical t</code> differ substantially? Can you find any values of <code>t</code> where <code>acc1Analytic t</code> and <code>acc1Numerical t</code> differ substantially?<span epub:type="pagebreak" id="page_50"/></p>&#13;
</div></body></html>