- en: '**7**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DIGITAL CPU DESIGN**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/f0155-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ve been building up larger and larger components of digital electronic computers,
    from transistors, to logic gates, to simple machines such as decoders and adders.
    Now it’s time to put everything together at the top level to make a digital electronic
    CPU. At least until very recently, the CPU has been the heart of digital electronic
    computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of this chapter is to overcome your fear of digital electronic CPUs.
    Modern CPUs are probably the second most complex device known to humanity, after
    the human brain. If you look at a CPU circuit under a microscope and see all the
    wiring without first preparing your mind, you’ll likely go crazy. As with driving,
    you don’t study a modern, state-of-the-art machine immediately; you start with
    a bicycle, then an old beat-up car, and then, as you get a feel for the systems,
    you progress to more powerful and modern machines. Likewise, we’ll use one of
    the first and simplest digital electronic CPU systems as our example for this
    chapter: the Manchester Baby. Contemporary CPUs are much more complicated and
    may vary or break many or all of the design principles covered here, but they’re
    still based on classical ideas. Seeing how they play out in a historical machine
    like the Baby will help us understand the basics.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already seen and understood the basic structure of a CPU from Babbage’s
    Analytical Engine, so here we’ll focus on the digital electronic implementations
    of the same overall design. As with Babbage, we’ll play a bit fast and loose with
    the actual details and history of the Manchester Baby; the point is to use it
    to get a flavor of digital CPUs in general. The original Baby’s digital electronics
    were built from vacuum tubes rather than transistors, and didn’t necessarily use
    the same structures that we’d use today to re-implement its functionality. Nonetheless,
    the simple machines that we’ve studied can be used to build a modernized implementation
    of the Baby. We’ll build such an implementation here, capable of running real
    programs, using LogiSim. But first, we’ll learn what the Baby needs to be capable
    of by programming it as a user.
  prefs: []
  type: TYPE_NORMAL
- en: The Baby’s Programmer Interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the Analytical Engine, von Neumann architectures such as the Baby store
    their instructions and data in the same RAM space. A program is thus a list of
    lines that are all copied into RAM. Each line has a number, and it gets copied
    to the RAM address of that same number. Like the Analytical Engine, a program
    is made up of binary *machine code* corresponding to a series of instructions
    from its instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the Baby’s complete instruction set. We’ll discuss each instruction in
    more detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: HLT Halt the Baby and light the stop lamp
  prefs: []
  type: TYPE_NORMAL
- en: LDN Load the negated content of the specified address
  prefs: []
  type: TYPE_NORMAL
- en: STO Store the latest result to the specified address
  prefs: []
  type: TYPE_NORMAL
- en: SUB Subtract the content of the specified address from the result
  prefs: []
  type: TYPE_NORMAL
- en: JMP Jump to the line number stored in the given address
  prefs: []
  type: TYPE_NORMAL
- en: JRP Jump forward by the number of lines stored in the given address
  prefs: []
  type: TYPE_NORMAL
- en: 'SKN Compare the result: if less than 0, skip the next instruction'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Baby’s designers really wanted to have a regular load instruction, as
    in the Analytical Engine and most modern computers, to load a copy of the data
    stored at the address. But due to technical limitations of the time, they were
    forced to replace this with `LDN`, “load negated,” which also inverts each of
    the bits from the data as they are loaded. This is a famous quirk of the Baby
    that gives its programming a distinctive problem-solving flavor.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Halting*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `HLT` instruction stops the machine. This prevents execution of any further
    instructions and turns on a light bulb to tell the user that the work has finished,
    so they know when to inspect the results. The simplest Baby program is thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The line number 01 on the left of the instruction is also the RAM address where
    the instruction will be stored. When this program is loaded into the Baby’s RAM,
    address 1 of RAM will contain the binary machine code for `HLT`. After loading
    the program, it can be run. The Baby begins execution from address 1 (not address
    0, because the program counter is incremented just before each fetch) so the `HLT`
    will be executed, causing the Baby to halt.
  prefs: []
  type: TYPE_NORMAL
- en: '*Constants*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Lines with `NUM` aren’t true instructions but are used to place *data* at their
    address when the code is first loaded into RAM. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When this is loaded into RAM, the constants 10, 5, and 0 will be placed into
    addresses 2, 3, and 4, respectively, as well as the `HLT` instruction being placed
    into address 1.
  prefs: []
  type: TYPE_NORMAL
- en: If you actually run the program it will begin at line 1, execute the `HLT` instruction,
    and immediately halt. The `HLT` instruction here is very important; the CPU tries
    to read and execute the instructions in order, starting from address 1, but the
    values that we’ve placed into addresses 2, 3, and 4 are intended to be used as
    data, not instructions. The `HLT` instruction stops the CPU from getting to address
    2 and beyond, preventing the data values from being treated as instructions.
  prefs: []
  type: TYPE_NORMAL
- en: This method of writing the program and data together, and storing them in the
    same RAM together, is the defining characteristic of von Neumann architectures.
    When programming von Neumann machines, it’s very important that we only ever execute
    instruction lines, and that we don’t try to execute data lines. It’s a programming
    error—that is, a bug—to write code that ends up trying to execute data as if it
    were part of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Execution of data can have unpredictable and dangerous behavior. That’s why
    it’s often used as a security attack technique: if you want to break into someone
    else’s program and have it execute your own code, you can sometimes do this by
    entering your code as data to that program, then somehow trick the program into
    executing it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Load and Store*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The constants in the above code never enter the CPU; rather, the whole code
    is loaded into the RAM locations given as the line numbers by some other mechanism
    before the CPU is even turned on. To make use of data from RAM in actual computations,
    we need to execute load and store instructions, which copy data from RAM into
    the CPU, and from the CPU to RAM.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following Baby program loads the (negation of the) number
    in address 20, then stores a copy of it into address 21:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the number –10 is initially placed at address 20, but it gets
    loaded into the CPU as +10, its inverse, due to the Baby’s automatic negation
    of loaded data. This number 10 is then stored to address 21, overwriting the 0
    initially placed there. Note that the executable program is stored in addresses
    01 through 03, and is terminated with `HLT`; higher addresses are used for data
    storage to avoid the risk of executing data.
  prefs: []
  type: TYPE_NORMAL
- en: '*Arithmetic*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Baby has one arithmetic instruction: subtraction. It works like Pascal’s
    calculator: you first load one number into the CPU with a load instruction, then
    you give a `SUB` instruction that subtracts a second number from it. For example,
    the following program computes 10 – 3 = 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The integers –10 and 3 are placed in addresses 20 and 21 by lines 20 and 21
    when the whole program is first loaded into memory. Line 1 loads the (negated)
    integer from address 20 into the CPU. Line 2 subtracts the integer from address
    21 from it. Line 3 stores the result in address 22, overwriting the 0 initially
    placed there.
  prefs: []
  type: TYPE_NORMAL
- en: '*Jumps*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `JMP` instruction makes program execution jump to the line whose address
    is one plus the number stored at the address given in the instruction. This operation
    is called an *indirect jump*, as opposed to a *direct jump*, which would encode
    the target address itself as part of the instruction, instead of, as in this case,
    the *location* of the target address. For example, consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `JMP 23` instruction at line 05 will cause a jump to line 01, because
    the integer 0 is stored at address 23, and 1 is the number after 0\. This program
    loops and runs forever as a result of the `JMP` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '*Branches*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Branching in the Baby is performed by the `SKN` instruction (skip next), which
    has no operand. `SKN` tests whether the current result is negative. If so, it
    skips the next instruction, moving to the one after it. `SKN` is usually paired
    with a jump (`JMP`) in the next instruction to create something similar to an
    if statement. If the result is negative, then `SKN` skips over the `JMP` instruction
    in the next line, and the program continues running from the line after it. If
    the result is positive, the jump is made and we continue running somewhere else
    in the program. For example, consider the following Baby program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This program computes the absolute value of an integer input from address 20
    and stores the result in address 23\. That is, if the input is either –10 or 10,
    then the output will be 10; any negative sign is removed. Lines 03 and 04 are
    the `SKN-JMP` pair.
  prefs: []
  type: TYPE_NORMAL
- en: Assemblers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The programs we’ve been looking at for the Baby—and those seen previously for
    the Analytical Engine—are written using human-readable ASCII symbols spelling
    out mnemonics such as `LDN` for “load negated,” and decimal or hex numerals. Such
    notations are known as *assembly languages* or just *assembly*. CPUs don’t understand
    such symbols; they require binary encodings of them, the *machine code*.
  prefs: []
  type: TYPE_NORMAL
- en: For the Analytical Engine, machine code takes the form of punches on punch cards,
    and the human programmer needs to manually translate their human-readable mnemonics
    into these binary punches before running their program. Similarly, for von Neumann
    machines such as the Baby, programs need to be translated into binary machine
    code and then placed into RAM before the CPU can execute them. The original Baby
    programmers had to do this by hand, using a pencil to work out the machine code,
    then a system of electronic switches to copy the machine code into RAM before
    turning on the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re programming a modern implementation of the Baby—or any other computer—in
    assembly today, you don’t need to do the translation manually; there are other
    programs, called *assemblers*, that automate the process, translating human-readable
    assembly programs into machine code for you. A file of 0s and 1s corresponding
    to machine code is called an *executable*, as it can be executed directly by the
    CPU once copied into RAM. Multiple assembly languages are possible for the same
    target machine. For example, they could use different mnemonics for the instructions
    (as we have in this book compared to other implementations of the Baby).
  prefs: []
  type: TYPE_NORMAL
- en: The Baby’s machine code uses one 32-bit word per instruction. The lowest 13
    bits are called the *operand* and encode the numerical value used by the instruction
    (or are ignored for instructions that don’t come with a number). The next 3 bits
    are known as the *opcode* and encode the type of instruction, obtained by direct
    translation of the assembler mnemonics, as in [Table 7-1](ch07.xhtml#ch07tab1).
    The remaining 16 bits are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** The Manchester Baby Opcodes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Opcode** | **Mnemonic** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | `JMP` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `JRP` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `LDN` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `STO` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `SUB` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `SUB` |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `SKN` |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `HLT` |'
  prefs: []
  type: TYPE_TB
- en: The following listing is an assembler for the Baby written in Python. If you
    know Python, you’ll see how a dictionary is used to translate the instructions
    to opcodes, and how conversions between decimal, hex, and binary are used on the
    operands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a Baby program for long division, written by Alan Turing during
    his work testing and documenting the Baby at Manchester:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the machine code for Turing’s program, as generated by
    the Python assembler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this display of the binary machine code, the bit positions are printed with
    the zeroth bit on the left (contrary to modern convention), so the opcodes appear
    in the three bits just to the left of the middle of each word, with the operands
    to their left. This was the format used by the historical Baby, so our machine
    code could be entered using this convention.
  prefs: []
  type: TYPE_NORMAL
- en: The test program and the machine code each have 32 lines so that they exactly
    and unambiguously fill the Baby’s 32 addresses of memory. The programmer needs
    to put something in all 32 addresses so those that aren’t in use are explicitly
    filled with zeros. Note that the line numbers aren’t encoded in the machine code;
    rather, they specify which address the machine code will be placed at. Also note
    that the data lines are translated as single 32-bit numbers, as `NUM` isn’t an
    instruction but rather just a comment to tell the assembler that the line contains
    raw data. The Baby uses two’s complement, so hex values such as `ffff0000` represent
    negative integers.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Until the mid-1990s, many large applications and games were written by human
    programmers in assembly language, including* Street Fighter II *and the RISC OS
    operating system. Most modern programming isn’t done in assembly language, but
    rather in a higher-level language such as C, C++, or Python. Programs written
    in these languages are first converted to assembly code by a compiler, before
    being assembled by an assembler.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Baby’s Internal Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll turn to the Baby’s internal structures. As we did for the Analytical
    Engine, we’ll first introduce the subcomponents within the digital CPU, and then
    consider the dynamics of how they behave and interact to execute programs. The
    main digital CPU substructures are exactly the same as for the Analytical Engine:
    registers, an arithmetic logic unit (ALU), and a control unit (CU). They have
    the same functions as in the Analytical Engine but are built from the digital
    logic simple machines we studied in the previous chapter, rather than from Babbage’s
    mechanical simple machines.'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t follow the exact implementation of the original Manchester Baby here;
    rather, I’ll show general digital logic implementations that *could* be used to
    implement the Baby’s programmer interface in a more modern style. These implementations
    are built from simple machines of digital logic, which in turn are built from
    logic gates that could be implemented equally well using modern transistors or
    the Baby’s original vacuum tubes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Registers*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Registers are fast word-length memory, usually made today as arrays of D-type
    flip-flops, which live inside the CPU and are readable and writable by the CU
    and ALU. Most CPUs include several types of register used for different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The sizes of the registers in a CPU are usually taken to define the CPU’s word
    length; for example, an 8-bit machine uses 8-bit words that are stored in 8-bit
    registers, and a 32-bit machine uses 32-bit words that are stored in 32-bit registers.
    The Baby is a 32-bit machine in this sense. The words use the data representations
    seen in [Chapter 2](ch02.xhtml), which require an array of bits to store numbers,
    text, and other data.
  prefs: []
  type: TYPE_NORMAL
- en: Like the individual flip-flops that compose them, registers must be timed to
    enable correct synchronization of reads and writes. An update signal can be sent
    to the clock inputs of all the flip-flops making up the register. Usually writes
    to the register are performed on the rising edge of this signal. Each register
    also continually outputs its latest stored value for reading as a set of parallel
    wires, regardless of the updates. The register structure is shown in [Figure 7-1](ch07.xhtml#ch07fig1).
    The write is triggered when you press the button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0164-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: A 3-bit register made from flip-flops*'
  prefs: []
  type: TYPE_NORMAL
- en: Registers can also be notated using a single symbol suggesting a pile of flip-flops,
    as in [Figure 7-2](ch07.xhtml#ch07fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0165-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: A 4-bit register as a single symbol, connected to input switches,
    write update button, and output LEDs*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the D input and Q output are each groups of wires, shown as thick lines,
    then split into single wires.
  prefs: []
  type: TYPE_NORMAL
- en: '**User Registers**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*User registers* are usually the only registers that are visible to the assembly
    language programmer, who can give instructions to act on their contents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An *accumulator* is a user register that functions both as an input and to
    store the results of calculations in the same place. As we’ve seen, Pascal’s calculator
    is one big accumulator because it stores both one of the inputs to an addition
    and also its result, destroying the original representation of the input in the
    process. Your desktop calculator is also an accumulator: it only ever stores one
    number, the current result seen on the screen, which you can add to or multiply
    by, and which is updated to store the result. For example, if you enter 2, this
    is stored in the accumulator. If you then enter +3 the accumulator stores and
    shows the result 5\. The original value 2 and the operation +3 are lost, and only
    the accumulated result is available.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Accumulator architectures* are those that have only a single user register
    that acts as an accumulator. The Baby uses this simple style of architecture.
    This forces all computation to be done in the accumulator style because there
    are no other registers in which to keep inputs separate from outputs. By contrast,
    more complex CPUs may have other user registers, in addition to or instead of
    an accumulator.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal Registers**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the user registers, most CPUs require further registers for their
    own internal operations. These *internal registers* may be invisible to the user,
    so you can’t write assembly programs that access or modify them. Rather, they’re
    used to make the CPU itself work, and to enable it to read and execute user programs.
    Let’s look at the two most important internal registers.
  prefs: []
  type: TYPE_NORMAL
- en: A CPU needs to keep track of where it currently is in the execution of its program.
    In the Analytical Engine, the current line of the program was stored using the
    mechanical state of the program card reader. Like typewriter paper, the program
    was mechanically fast-forwarded and rewound so that the current line was positioned
    on the reader. In an electronic CPU, there is no mechanically moving state, so
    we must instead keep track of where we are in the program by storing the current
    line number in a register, called the *program counter* (*PC* in the listings
    in this chapter). As we’ve seen, von Neumann architectures—such as the Baby and
    most modern computers—store the program in main memory, along with other data,
    so these “line numbers” are actually memory addresses that store the instructions
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: The *instruction register (IR)* stores a copy of the current instruction, copied
    in from its address (as kept in the program counter) in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Arithmetic Logic Unit*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just like the Analytical Engine’s ALU, a digital logic–based ALU consists of
    a collection of simple machines, each performing one kind of arithmetic operation.
    Due to a quirk in its hardware, the original Baby had only a subtractor, but here
    we’ll build a more general and powerful ALU that also includes addition, multiplication,
    and division. [Figure 7-3](ch07.xhtml#ch07fig3) shows a 32-bit ALU with these
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0166-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: A 32-bit, four-operation ALU*'
  prefs: []
  type: TYPE_NORMAL
- en: Here there are two data inputs, *a* and *b*, each containing a 32-bit, two’s
    complement integer. They’re both sent to all four simple arithmetic machines,
    a subtractor, adder, multiplier, and divider, each of which calculates an output.
    Just one of these outputs is then selected and passed to the ALU’s output, *r*.
    To choose which arithmetic operation you want to do, place its 2-bit code on the
    *c* input. The decoder then activates one of the four 32-bit multiplexers, enabling
    the desired operation’s output to be passed to and through the 32-bit OR gate
    array. A copy of the final output from the OR gate array is passed into a *comparator*,
    which tests if the number is zero and outputs a single status flag with this Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: The comparator can be implemented simply by NOR gating together all of the bits
    in the number. More advanced ALUs often test for other interesting properties
    of the result, such as being positive or negative, having created an overflow
    (which can be seen on the carry out lines of the simple machines), or division
    by zero; they then output a set of flags rather than just this zero test.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could build this ALU with less silicon by using a single multiplexer
    with 2-bit input to select directly between the four arithmetic machines. Duplication
    of digital logic could be reduced by sharing structures between operations—for
    example, using two’s complement enables adders to be reused as subtractors. You
    might also be concerned about the waste of energy from running all of the arithmetic
    options on each set of inputs but throwing all but one result away. You could
    find ways to redesign the network to reduce this energy usage. However, I’ve chosen
    the present structure for educational reasons, as it will help you to more easily
    understand CUs in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '*Control Unit*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Digital logic CUs implement the same concept as Babbage’s timing barrel, acting
    like a musical conductor to trigger all of the other CPU components at the right
    times. There are many ways to do this, so CUs vary far more than registers and
    ALUs. They’re usually considered to be the hardest and most central part of CPU
    design. We’ll choose a particular style here for ease of understanding rather
    than for computational or energy efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'This style is based on two structures: first, a counter that, like Babbage’s
    barrel, rotates regularly, and whose value is used to time the required events;
    second, a switching mechanism that determines the type of event to be triggered
    and makes temporary connections between components—such as registers, the ALU,
    and RAM—in response. In Babbage’s machine, these connections were made and broken
    using mechanical levers. For our digital logic version, we’ll use multiplexers,
    as we did in the ALU. These multiplexers have two data inputs, each of word length—32
    bits for the Baby. One is hardwired to zeros and the other is from the temporary
    input source. They have a single-bit switch that switches between relaying the
    temporary input onto the output and sending all zeros to the output. [Figure 7-4](ch07.xhtml#ch07fig4)
    shows how this works.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0168-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: A multiplexer used to enable or disable a connection of 32 wires*'
  prefs: []
  type: TYPE_NORMAL
- en: As in the ALU, where multiple sources can potentially connect to a destination,
    they each get their own multiplexer. Then an OR array combines the multiplexer
    outputs, allowing the non-zero output to pass through.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a sequence of temporary connections between components. Some of
    these connections can be triggered simply by the time shown on the counter. This
    can be done with a decoder, taking the time as input and activating a particular
    trigger wire as output. Other connections need to be triggered by a combination
    of a time and some other value, such as the identity of the current instruction.
    These can be done by AND gating the appropriate trigger wire to signals representing
    the other required conditions. [Figure 7-5](ch07.xhtml#ch07fig5) shows an example
    of this structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0168-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: A minimal CU based on a 3-bit counter, a decoder, and multiplexer
    switches*'
  prefs: []
  type: TYPE_NORMAL
- en: The 3-bit counter and decoder on the left form the sequencer. Using 3 bits gives
    us 2³ = 8 times, from 0 to 7, looping back to 0 after each 7\. The figure shows
    triggers only at ticks 0, 1, and 7\. The triggers at ticks 0 and 1 (the upper
    two outputs from the decoder) depend only on the time and make connections between
    32-bit wire groups. At tick 7, there are two possible triggers, which depend on
    conditions cond1 and cond2 being met, respectively, represented by the two switches
    near the bottom-left of the figure. Note that either, neither, or both of these
    conditions (and thus triggers) could be active at this time. The OR symbol here
    represents an array of 32 OR gates. It allows two different inputs to be connected
    to the same shared output (SO) on different triggers. (Triggers from times 2 through
    6 inclusive are omitted in this figure, but you can imagine those wires from the
    decoder connecting to similar triggers.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s introduce a little extra notation at this point to help make our diagrams
    more readable. [Figure 7-6](ch07.xhtml#ch07fig6) shows exactly the same minimal
    CU, but introduces *tunnels*, which are named points (t0 to t7 and c0 to c1) taking
    the place of wires. All tunnels having the same name are assumed to be connected
    to one another. For example, the t0 tunnel coming out of the decoder connects
    to the t0 tunnel going into the multiplexer near the top right of the figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0169-01.jpg)![Image](../images/f0169-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The same minimal CU as in [Figure 7-5](ch07.xhtml#ch07fig5), redrawn
    using tunnel notation*'
  prefs: []
  type: TYPE_NORMAL
- en: This tunnel notation avoids the need to draw the rat’s nest of wires formed
    as the CU sends its triggers all over the rest of the CPU. We’ve also encapsulated
    the 3-bit counter into a single block, CTR3, as provided off-the-shelf by LogiSim.
    (This block has some additional inputs and features that we don’t use here.)
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve seen each of the basic ingredients of a Baby implementation,
    let’s put them all together—along with suitably timed CU dynamics—to build a complete,
    functioning Baby. We’ll do this by considering the three main stages of operation—fetch,
    decode, and execution—in turn, just as we did when we discussed the Analytical
    Engine in [Chapter 3](ch03.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '*Fetch*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The aim of the fetch stage is to bring a copy of the next instruction from RAM
    into the IR in the CPU. Fetching assumes that the address of the next instruction
    is already in the program counter. When the CPU is first turned on, the program
    counter—like all registers—is initialized to 0, but is immediately incremented
    to 1, so the first instruction must be stored at address 1 and will be fetched.
  prefs: []
  type: TYPE_NORMAL
- en: To perform a fetch, the program counter is temporarily connected to the address
    lines of RAM, on tick 1\. The data out lines of RAM can be permanently connected
    to the IR data in, but the IR takes only a copy of the word from these lines when
    write-enabled and clocked at tick 2\. The network in [Figure 7-7](ch07.xhtml#ch07fig7)
    is set to perform fetch for the Baby’s 32×32 RAM (32 = 2⁵ addresses, each containing
    one 32-bit word) by making these connections on ticks 1 and 2 of its eight-count
    control cycle, and breaking them on the other steps. In our Baby, the program
    counter is a 5-bit register and the IR is a 32-bit register.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0170-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: A fetch, triggered on ticks 1 and 2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the fetch sequence as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This style of notation is a form of *register transfer language (RTL)*. The
    symbols before the colon on each line are the triggers, which in this case are
    ticks 1 and 2\. The arrows denote that a temporary connection from a source to
    a destination is made only when the trigger is active. The arrows thus correspond
    to the multiplexers used in our implementation style, with the triggers corresponding
    to the switching inputs of these multiplexers.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*RTL is not assembly language or machine code. It’s a lower-level description
    of how the CPU works, whose function is ultimately to execute the machine code
    program written by the user and stored in RAM.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Decode*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now have a copy of the next instruction sitting in the IR. It consists of
    a word of machine code, with some bits specifying the opcode and the other bits
    possibly containing zero, one, or more operands. In the Baby, bits 13 to 15 are
    the opcode, bits 0 to 12 are a single operand for some instructions, and the remaining
    16 bits aren’t used. This encoding now needs to be decoded. We need to split up
    the opcode and operand, then convert the opcode into an activation signal. [Figure
    7-8](ch07.xhtml#ch07fig8) shows our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0171-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: Decoding, triggered at tick 2*'
  prefs: []
  type: TYPE_NORMAL
- en: The IR output is first split into three sets of wires, for the first 13, next
    3, and remaining 16 bits. The middle 3 bits, containing the opcode, are connected
    to a 3-bit decoder. The decoder activates one of its 2³ = 8 output lines, which
    is connected to a tunnel and will be used as a condition to trigger multiplexers
    in other steps. These tunnels are named as their corresponding assembly mnemonics.
    The 13 operand bits of the IR are further split into the 5 lower-order bits, which
    are used for address selection and will have wires connected to them later, and
    the 8 higher-order bits, which have nothing to address and are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no sequential logic used here, so decoding happens roughly instantaneously
    once the IR content is updated on tick 2.
  prefs: []
  type: TYPE_NORMAL
- en: '*Execute*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unlike fetching and decoding, what happens during the execute stage depends
    on the instruction that has been fetched and decoded. Different instructions specify
    the activation of different structures that do different things: load, store,
    arithmetic, and program flow control. We’ll look at how to execute each of these
    possible actions in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To execute a load, we temporarily connect the operand to the RAM’s address
    input at tick 3, and then temporarily connect the RAM’s data output to the accumulator
    (Acc) at tick 4\. These tick numbers are chosen to take place after the previous
    fetch and decode. We can write this in RTL style as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the triggers before the colon now include both a tick and the `LDN`
    condition. The square brackets in `IR[operand]` indicate that only the operand
    bits of IR are to be used, rather than the entire register content.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-9](ch07.xhtml#ch07fig9) shows the digital logic for our Baby implementation’s
    load. (As the Baby’s load operation also negates the loaded values, we pass the
    RAM data out through a negator on its way to the accumulator. This would not usually
    be done on a modern machine.)'
  prefs: []
  type: TYPE_NORMAL
- en: In an accumulator architecture such as the Baby, the load always places the
    data from RAM into the accumulator register. In more complex architectures with
    more user registers, an additional operand is needed to specify the target, and
    more digital logic is needed to connect the right register to the data line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Store**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Storing a value from the CPU into memory is similar but opposite to loading.
    In the Baby, the value to be stored is always taken from the accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'At tick 3, we temporarily connect the STO instruction’s operand (the address
    to store at) to the RAM’s address lines. The accumulator output can be permanently
    connected to the RAM data input, but only write-enabled at tick 3\. The RTL for
    this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 7-10](ch07.xhtml#ch07fig10) shows the digital logic implementing this
    for our Baby.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0173-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: Executing a load, triggered at ticks 3 and 4*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0173-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: Executing a store, triggered at tick 3*'
  prefs: []
  type: TYPE_NORMAL
- en: In architectures with more user registers, another operand can be used to specify
    which register’s contents are to be stored, and more switching logic is then needed
    to connect the right register to the data line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To execute an ALU operation, the CU makes temporary connections to the ALU’s
    inputs from CPU registers, and creates and sends an ALU command to the ALU’s command
    inputs. The ALU output is then temporarily connected to a destination register.
  prefs: []
  type: TYPE_NORMAL
- en: The Baby’s ALU is especially simple, as it contains only a subtractor. The `SUB`
    instruction triggers a read from RAM, similar to a load instruction, but the RAM
    data is sent to the subtractor rather than to the accumulator. The subtractor
    takes its other input from the accumulator and writes its output back to the accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-11](ch07.xhtml#ch07fig11) shows our Baby ALU implementation. The
    RAM read is triggered on tick 3, and the accumulator update on tick 4\. The subtractor
    is on the far left of the figure.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0174-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Executing an ALU operation, triggered at ticks 3 and 4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can also be described in RTL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: More complex architectures having more arithmetic operations than just subtraction
    would package them up into a single ALU structure, with select lines to specify
    which to activate, as you saw in [Figure 7-3](ch07.xhtml#ch07fig3). The decoder
    would then need to recognize multiple different arithmetic opcodes, and route
    each one through some logic to activate the corresponding selection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow Control**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the start of each instruction, the Baby moves to the next address (line)
    of the program. This can be done by incrementing (adding 1 to) the program counter
    at tick 0.
  prefs: []
  type: TYPE_NORMAL
- en: If the current instruction is a flow control instruction—that is, a jump or
    branch—then its execution step also needs to update the program counter to get
    it ready for the next instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Modern (direct) jump instructions contain the line number to jump to in their
    operand, so they can be implemented by copying the operand directly into the program
    counter. As we’ve seen, however, the Baby uses an indirect jump instruction, `JMP`,
    in which the operand contains the *address* that in turn contains the actual jump
    target. To implement this indirect jump we thus first attach the operand to the
    RAM address lines at tick 4, then attach the RAM data lines to the program counter
    at tick 5.
  prefs: []
  type: TYPE_NORMAL
- en: The Baby also has a relative jump, `JRP`, which works similarly to `JMP` except
    that the address in the operand contains a number of lines to advance the program
    counter, rather than an absolute address.
  prefs: []
  type: TYPE_NORMAL
- en: For the branch instruction, `SKN`, we check its condition and behave as normal
    if it’s false, or increment the program counter an extra time if it’s true, to
    skip over one line of code. (Usually the skipped line will be chosen by the programmer
    to be a jump to another part of the code.) To implement this, we send the output
    of the accumulator to a comparator that tests if it’s less than zero. The truth
    or falsehood of this condition is then used (thanks to Boole) as an integer 0
    or 1, which is added to the program counter at tick 5 when the branch instruction
    is active.
  prefs: []
  type: TYPE_NORMAL
- en: If the current instruction isn’t a control flow instruction (that is, if it’s
    `SUB`, `LDN`, or `STO`), then no further changes are made to the program counter.
    This is implemented simply by wiring the program counter’s output directly to
    its input at tick 5.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-12](ch07.xhtml#ch07fig12) shows our Baby implementation of flow control.
    In RTL notation, this corresponds to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once the program counter has been updated by any of the means described here,
    the fetch-decode-execute cycle is complete, and everything is set up for the next
    cycle to begin.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0176-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Program flow control, triggered at ticks 0, 4, and 5*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Complete Baby Implementation*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 7-13](ch07.xhtml#ch07fig13) shows our complete, working Baby CPU, with
    all of the above systems shown together. In the lower-left it adds a register
    and lamp that activate when the halt instruction is executed, preventing any further
    execution. If you get tired of manually triggering the clock, it also adds a switch
    connecting the clock signal to an oscillator.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0177-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: A complete, working Baby implementation, including sequencer,
    fetch, decode, execute, and control flow logic. The RAM contents are now shown
    in full.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We now have a complete computer in digital logic, able to execute machine code
    programs in RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of a digital logic CPU is to execute machine code programs, which
    can be assembled from human-readable assembly language. These programs need to
    be placed into memory before the CPU starts its work. They consist of a series
    of instructions that are in turn read into the CPU and executed.
  prefs: []
  type: TYPE_NORMAL
- en: CPUs can initially scare those trying to understand them. Even a minimal example
    such as our Baby might take thousands of transistors; modern CPU chips can contain
    billions. But you’ve seen in this chapter that the basic structure isn’t so complex
    if you think hierarchically, like an architect. From this perspective, you already
    saw how to build a variety of simple machines that each perform a basic task;
    a basic CPU then just connects a small number of these simple machines.
  prefs: []
  type: TYPE_NORMAL
- en: The CU can be built from a sequencer, which triggers the fetch, decode, and
    execute stages. The execute stage is the hardest one to implement, as it involves
    different actions depending on what instruction was decoded. The sub-steps of
    the execute stage therefore need some additional logic to activate the different
    options.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has shown roughly how the Manchester Baby was and can be put together.
    The architecture we built still forms the basic plan for many modern CPUs. Pressures
    from Moore’s law have complicated this plan, however. They prevent modern machines
    from simply being clocked faster, but they allow them to use many more transistors.
    In the next chapter you’ll see some of the more complex uses that modern CPUs
    can make of these extra transistors.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Build a Baby**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Build the Baby design from [Figure 7-13](ch07.xhtml#ch07fig13) in LogiSim Evolution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you start working at this level of complexity with sequential logic, it’s
    very easy and common to create hardware bugs around trigger timing. Working architects
    spend a lot of their time debugging timing issues. The hardware equivalent of
    a debugger is a *chronogram* ([Figure 7-14](ch07.xhtml#ch07fig14)), a diagram
    that plots the state of several wires in the system over time. LogiSim Evolution
    has a built-in tool for generating these (**Simulate ▸ Timing diagram**). Find
    out how to use it to test some of the sequential subcircuits from the Baby. Recall
    that sequential logic—write enables for RAM and registers, and RAM read addresses—is
    usually triggered at the *instant* the clock signal rises from 0 to 1, while combinatorial
    logic is active at all times. There are also hardware logic analyzers that will
    capture and display similar data from breadboards, either standalone or sending
    the data to your PC for analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Image](../images/f0179-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: A LogiSim chronogram*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming the Baby**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Assemble the test programs—including Turing’s division program—discussed in
    this chapter, and run them in your LogiSim Baby. Use the Python assembler provided,
    with the `for_logisim` flag on line 3 set to True. Save the output in a text file
    and load it as a RAM image in LogiSim by right-clicking the RAM and selecting
    **Load Image**. You can step through CPU cycles manually by clicking the clock,
    or by setting it to tick automatically with **Simulate ▸ Auto-tick** in the menu
    bar. Turing’s program divides 36 by 5, to give result 7 (111[2]), which gets stored—padded
    with zeros—in address 28, so it appears as E000000[16]. Try editing lines 29 to
    31 to perform different divisions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you explain how Turing’s code works? Remember that the Baby’s two main quirks
    are that it negates values when loading them, and it has only a subtractor rather
    than an adder. These lead to a few programming idioms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Challenging**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve used several layers of notational abstraction in our CPU designs: packaging
    up transistors, gates, and simple machines into boxes. Estimate how many logic
    gates, then how many transistors are used in our final design. How does the number
    of transistors compare with those used in the actual historical designs in [Chapter
    1](ch01.xhtml)? How could these be reduced if we preferred an implementation using
    less silicon rather than an educationally easy-to-understand design?'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Challenging**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Baby is a very small, simple computer, but it’s possible to extend it into
    a fairly serious modern machine by modifying our design. Try doing this using
    the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Increase the RAM size. To do this, you’ll need to increase the size of the addresses
    throughout the design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the Baby’s LDN with a more normal LOAD instruction, which just loads
    without negation. Or retain LDN and create a new LOAD in addition to it, if you
    want to retain back-compatibility with old code. This will lead to more complexity
    and silicon, but will keep existing users happy, so is representative of a typical
    dilemma architects face.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the single subtraction module with a full two’s complement integer ALU,
    including add, subtract, multiply, and divide. Create extra instructions to trigger
    these operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at the later Manchester Mark I and Ferranti Mark I machines to see how
    the original Baby was actually extended to commercialization. Try to emulate them
    in LogiSim.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the nearest we have to an official modern manual for the Manchester Baby,
    see the University of Manchester’s current web page, *[http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/mark1/prog98/ssemref.html](http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/mark1/prog98/ssemref.html)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the original publication describing the real Baby, see F.C. Williams, T.
    Kilburn, and G.C. Tootill, “Universal High-Speed Digital Computers: A Small-Scale
    Experimental Machine,” *Proceedings of the IEE [Part II](part02.xhtml): Power
    Engineering* 98, no. 61 (1951): 13–28.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For details of the later Manchester Mark I, see R.B.E. Napper, “The Manchester
    Mark 1 Computers,” in *The First Computers: History and Architectures*, ed. Raúl
    Rojas and Ulf Hashagen (Cambridge, MA: MIT Press, 2000), 365–377.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
