- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DIGITAL CPU DESIGN**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/f0155-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: We’ve been building up larger and larger components of digital electronic computers,
    from transistors, to logic gates, to simple machines such as decoders and adders.
    Now it’s time to put everything together at the top level to make a digital electronic
    CPU. At least until very recently, the CPU has been the heart of digital electronic
    computers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of this chapter is to overcome your fear of digital electronic CPUs.
    Modern CPUs are probably the second most complex device known to humanity, after
    the human brain. If you look at a CPU circuit under a microscope and see all the
    wiring without first preparing your mind, you’ll likely go crazy. As with driving,
    you don’t study a modern, state-of-the-art machine immediately; you start with
    a bicycle, then an old beat-up car, and then, as you get a feel for the systems,
    you progress to more powerful and modern machines. Likewise, we’ll use one of
    the first and simplest digital electronic CPU systems as our example for this
    chapter: the Manchester Baby. Contemporary CPUs are much more complicated and
    may vary or break many or all of the design principles covered here, but they’re
    still based on classical ideas. Seeing how they play out in a historical machine
    like the Baby will help us understand the basics.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already seen and understood the basic structure of a CPU from Babbage’s
    Analytical Engine, so here we’ll focus on the digital electronic implementations
    of the same overall design. As with Babbage, we’ll play a bit fast and loose with
    the actual details and history of the Manchester Baby; the point is to use it
    to get a flavor of digital CPUs in general. The original Baby’s digital electronics
    were built from vacuum tubes rather than transistors, and didn’t necessarily use
    the same structures that we’d use today to re-implement its functionality. Nonetheless,
    the simple machines that we’ve studied can be used to build a modernized implementation
    of the Baby. We’ll build such an implementation here, capable of running real
    programs, using LogiSim. But first, we’ll learn what the Baby needs to be capable
    of by programming it as a user.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The Baby’s Programmer Interface
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the Analytical Engine, von Neumann architectures such as the Baby store
    their instructions and data in the same RAM space. A program is thus a list of
    lines that are all copied into RAM. Each line has a number, and it gets copied
    to the RAM address of that same number. Like the Analytical Engine, a program
    is made up of binary *machine code* corresponding to a series of instructions
    from its instruction set.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the Baby’s complete instruction set. We’ll discuss each instruction in
    more detail in the following sections.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: HLT Halt the Baby and light the stop lamp
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: LDN Load the negated content of the specified address
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: STO Store the latest result to the specified address
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: SUB Subtract the content of the specified address from the result
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: JMP Jump to the line number stored in the given address
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: JRP Jump forward by the number of lines stored in the given address
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'SKN Compare the result: if less than 0, skip the next instruction'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '*The Baby’s designers really wanted to have a regular load instruction, as
    in the Analytical Engine and most modern computers, to load a copy of the data
    stored at the address. But due to technical limitations of the time, they were
    forced to replace this with `LDN`, “load negated,” which also inverts each of
    the bits from the data as they are loaded. This is a famous quirk of the Baby
    that gives its programming a distinctive problem-solving flavor.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '*Halting*'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `HLT` instruction stops the machine. This prevents execution of any further
    instructions and turns on a light bulb to tell the user that the work has finished,
    so they know when to inspect the results. The simplest Baby program is thus:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The line number 01 on the left of the instruction is also the RAM address where
    the instruction will be stored. When this program is loaded into the Baby’s RAM,
    address 1 of RAM will contain the binary machine code for `HLT`. After loading
    the program, it can be run. The Baby begins execution from address 1 (not address
    0, because the program counter is incremented just before each fetch) so the `HLT`
    will be executed, causing the Baby to halt.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '*Constants*'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Lines with `NUM` aren’t true instructions but are used to place *data* at their
    address when the code is first loaded into RAM. For example, consider the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When this is loaded into RAM, the constants 10, 5, and 0 will be placed into
    addresses 2, 3, and 4, respectively, as well as the `HLT` instruction being placed
    into address 1.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: If you actually run the program it will begin at line 1, execute the `HLT` instruction,
    and immediately halt. The `HLT` instruction here is very important; the CPU tries
    to read and execute the instructions in order, starting from address 1, but the
    values that we’ve placed into addresses 2, 3, and 4 are intended to be used as
    data, not instructions. The `HLT` instruction stops the CPU from getting to address
    2 and beyond, preventing the data values from being treated as instructions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: This method of writing the program and data together, and storing them in the
    same RAM together, is the defining characteristic of von Neumann architectures.
    When programming von Neumann machines, it’s very important that we only ever execute
    instruction lines, and that we don’t try to execute data lines. It’s a programming
    error—that is, a bug—to write code that ends up trying to execute data as if it
    were part of the program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '*Execution of data can have unpredictable and dangerous behavior. That’s why
    it’s often used as a security attack technique: if you want to break into someone
    else’s program and have it execute your own code, you can sometimes do this by
    entering your code as data to that program, then somehow trick the program into
    executing it.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '*Load and Store*'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The constants in the above code never enter the CPU; rather, the whole code
    is loaded into the RAM locations given as the line numbers by some other mechanism
    before the CPU is even turned on. To make use of data from RAM in actual computations,
    we need to execute load and store instructions, which copy data from RAM into
    the CPU, and from the CPU to RAM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following Baby program loads the (negation of the) number
    in address 20, then stores a copy of it into address 21:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the number –10 is initially placed at address 20, but it gets
    loaded into the CPU as +10, its inverse, due to the Baby’s automatic negation
    of loaded data. This number 10 is then stored to address 21, overwriting the 0
    initially placed there. Note that the executable program is stored in addresses
    01 through 03, and is terminated with `HLT`; higher addresses are used for data
    storage to avoid the risk of executing data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '*Arithmetic*'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Baby has one arithmetic instruction: subtraction. It works like Pascal’s
    calculator: you first load one number into the CPU with a load instruction, then
    you give a `SUB` instruction that subtracts a second number from it. For example,
    the following program computes 10 – 3 = 7:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The integers –10 and 3 are placed in addresses 20 and 21 by lines 20 and 21
    when the whole program is first loaded into memory. Line 1 loads the (negated)
    integer from address 20 into the CPU. Line 2 subtracts the integer from address
    21 from it. Line 3 stores the result in address 22, overwriting the 0 initially
    placed there.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '*Jumps*'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `JMP` instruction makes program execution jump to the line whose address
    is one plus the number stored at the address given in the instruction. This operation
    is called an *indirect jump*, as opposed to a *direct jump*, which would encode
    the target address itself as part of the instruction, instead of, as in this case,
    the *location* of the target address. For example, consider the following program:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `JMP 23` instruction at line 05 will cause a jump to line 01, because
    the integer 0 is stored at address 23, and 1 is the number after 0\. This program
    loops and runs forever as a result of the `JMP` instruction.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '*Branches*'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Branching in the Baby is performed by the `SKN` instruction (skip next), which
    has no operand. `SKN` tests whether the current result is negative. If so, it
    skips the next instruction, moving to the one after it. `SKN` is usually paired
    with a jump (`JMP`) in the next instruction to create something similar to an
    if statement. If the result is negative, then `SKN` skips over the `JMP` instruction
    in the next line, and the program continues running from the line after it. If
    the result is positive, the jump is made and we continue running somewhere else
    in the program. For example, consider the following Baby program:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This program computes the absolute value of an integer input from address 20
    and stores the result in address 23\. That is, if the input is either –10 or 10,
    then the output will be 10; any negative sign is removed. Lines 03 and 04 are
    the `SKN-JMP` pair.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Assemblers
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The programs we’ve been looking at for the Baby—and those seen previously for
    the Analytical Engine—are written using human-readable ASCII symbols spelling
    out mnemonics such as `LDN` for “load negated,” and decimal or hex numerals. Such
    notations are known as *assembly languages* or just *assembly*. CPUs don’t understand
    such symbols; they require binary encodings of them, the *machine code*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: For the Analytical Engine, machine code takes the form of punches on punch cards,
    and the human programmer needs to manually translate their human-readable mnemonics
    into these binary punches before running their program. Similarly, for von Neumann
    machines such as the Baby, programs need to be translated into binary machine
    code and then placed into RAM before the CPU can execute them. The original Baby
    programmers had to do this by hand, using a pencil to work out the machine code,
    then a system of electronic switches to copy the machine code into RAM before
    turning on the CPU.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: If you’re programming a modern implementation of the Baby—or any other computer—in
    assembly today, you don’t need to do the translation manually; there are other
    programs, called *assemblers*, that automate the process, translating human-readable
    assembly programs into machine code for you. A file of 0s and 1s corresponding
    to machine code is called an *executable*, as it can be executed directly by the
    CPU once copied into RAM. Multiple assembly languages are possible for the same
    target machine. For example, they could use different mnemonics for the instructions
    (as we have in this book compared to other implementations of the Baby).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The Baby’s machine code uses one 32-bit word per instruction. The lowest 13
    bits are called the *operand* and encode the numerical value used by the instruction
    (or are ignored for instructions that don’t come with a number). The next 3 bits
    are known as the *opcode* and encode the type of instruction, obtained by direct
    translation of the assembler mnemonics, as in [Table 7-1](ch07.xhtml#ch07tab1).
    The remaining 16 bits are ignored.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** The Manchester Baby Opcodes'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '| **Opcode** | **Mnemonic** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| 0 | `JMP` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| 1 | `JRP` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| 2 | `LDN` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| 3 | `STO` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| 4 | `SUB` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| 5 | `SUB` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| 6 | `SKN` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| 7 | `HLT` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: The following listing is an assembler for the Baby written in Python. If you
    know Python, you’ll see how a dictionary is used to translate the instructions
    to opcodes, and how conversions between decimal, hex, and binary are used on the
    operands.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is a Baby program for long division, written by Alan Turing during
    his work testing and documenting the Baby at Manchester:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following shows the machine code for Turing’s program, as generated by
    the Python assembler:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this display of the binary machine code, the bit positions are printed with
    the zeroth bit on the left (contrary to modern convention), so the opcodes appear
    in the three bits just to the left of the middle of each word, with the operands
    to their left. This was the format used by the historical Baby, so our machine
    code could be entered using this convention.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The test program and the machine code each have 32 lines so that they exactly
    and unambiguously fill the Baby’s 32 addresses of memory. The programmer needs
    to put something in all 32 addresses so those that aren’t in use are explicitly
    filled with zeros. Note that the line numbers aren’t encoded in the machine code;
    rather, they specify which address the machine code will be placed at. Also note
    that the data lines are translated as single 32-bit numbers, as `NUM` isn’t an
    instruction but rather just a comment to tell the assembler that the line contains
    raw data. The Baby uses two’s complement, so hex values such as `ffff0000` represent
    negative integers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '*Until the mid-1990s, many large applications and games were written by human
    programmers in assembly language, including* Street Fighter II *and the RISC OS
    operating system. Most modern programming isn’t done in assembly language, but
    rather in a higher-level language such as C, C++, or Python. Programs written
    in these languages are first converted to assembly code by a compiler, before
    being assembled by an assembler.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The Baby’s Internal Structures
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll turn to the Baby’s internal structures. As we did for the Analytical
    Engine, we’ll first introduce the subcomponents within the digital CPU, and then
    consider the dynamics of how they behave and interact to execute programs. The
    main digital CPU substructures are exactly the same as for the Analytical Engine:
    registers, an arithmetic logic unit (ALU), and a control unit (CU). They have
    the same functions as in the Analytical Engine but are built from the digital
    logic simple machines we studied in the previous chapter, rather than from Babbage’s
    mechanical simple machines.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: We won’t follow the exact implementation of the original Manchester Baby here;
    rather, I’ll show general digital logic implementations that *could* be used to
    implement the Baby’s programmer interface in a more modern style. These implementations
    are built from simple machines of digital logic, which in turn are built from
    logic gates that could be implemented equally well using modern transistors or
    the Baby’s original vacuum tubes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '*Registers*'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Registers are fast word-length memory, usually made today as arrays of D-type
    flip-flops, which live inside the CPU and are readable and writable by the CU
    and ALU. Most CPUs include several types of register used for different purposes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The sizes of the registers in a CPU are usually taken to define the CPU’s word
    length; for example, an 8-bit machine uses 8-bit words that are stored in 8-bit
    registers, and a 32-bit machine uses 32-bit words that are stored in 32-bit registers.
    The Baby is a 32-bit machine in this sense. The words use the data representations
    seen in [Chapter 2](ch02.xhtml), which require an array of bits to store numbers,
    text, and other data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 中寄存器的大小通常用来定义 CPU 的字长；例如，8 位机器使用 8 位字，它们存储在 8 位寄存器中，而 32 位机器使用 32 位字，它们存储在
    32 位寄存器中。从这个角度看，Baby 是一台 32 位机器。字使用在 [第 2 章](ch02.xhtml) 中看到的数据表示方法，需要一个比特数组来存储数字、文本和其他数据。
- en: Like the individual flip-flops that compose them, registers must be timed to
    enable correct synchronization of reads and writes. An update signal can be sent
    to the clock inputs of all the flip-flops making up the register. Usually writes
    to the register are performed on the rising edge of this signal. Each register
    also continually outputs its latest stored value for reading as a set of parallel
    wires, regardless of the updates. The register structure is shown in [Figure 7-1](ch07.xhtml#ch07fig1).
    The write is triggered when you press the button.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像组成寄存器的各个触发器一样，寄存器必须同步时序，以确保读写的正确同步。一个更新信号可以发送到构成寄存器的所有触发器的时钟输入。通常对寄存器的写入是在该信号的上升沿进行的。每个寄存器还会持续输出其最新存储的值，供读取，作为一组并行电线，无论是否有更新。寄存器结构如
    [图 7-1](ch07.xhtml#ch07fig1) 所示。写入操作是在按下按钮时触发的。
- en: '![Image](../images/f0164-01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0164-01.jpg)'
- en: '*Figure 7-1: A 3-bit register made from flip-flops*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：由触发器组成的 3 位寄存器*'
- en: Registers can also be notated using a single symbol suggesting a pile of flip-flops,
    as in [Figure 7-2](ch07.xhtml#ch07fig2).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器也可以使用单个符号表示，暗示由触发器堆叠而成，如 [图 7-2](ch07.xhtml#ch07fig2) 所示。
- en: '![Image](../images/f0165-01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0165-01.jpg)'
- en: '*Figure 7-2: A 4-bit register as a single symbol, connected to input switches,
    write update button, and output LEDs*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：作为单个符号的 4 位寄存器，连接到输入开关、写入更新按钮和输出 LED*'
- en: Here, the D input and Q output are each groups of wires, shown as thick lines,
    then split into single wires.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，D 输入和 Q 输出是各自的一组电线，显示为粗线条，然后分成单根电线。
- en: '**User Registers**'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**用户寄存器**'
- en: '*User registers* are usually the only registers that are visible to the assembly
    language programmer, who can give instructions to act on their contents.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户寄存器* 通常是汇编语言程序员可以看到的唯一寄存器，他们可以向其内容发出指令。'
- en: 'An *accumulator* is a user register that functions both as an input and to
    store the results of calculations in the same place. As we’ve seen, Pascal’s calculator
    is one big accumulator because it stores both one of the inputs to an addition
    and also its result, destroying the original representation of the input in the
    process. Your desktop calculator is also an accumulator: it only ever stores one
    number, the current result seen on the screen, which you can add to or multiply
    by, and which is updated to store the result. For example, if you enter 2, this
    is stored in the accumulator. If you then enter +3 the accumulator stores and
    shows the result 5\. The original value 2 and the operation +3 are lost, and only
    the accumulated result is available.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*累加器* 是一个既作为输入又用于存储计算结果的用户寄存器。如我们所见，Pascal 的计算器就是一个大型累加器，因为它既存储加法的输入之一，也存储其结果，在此过程中销毁输入的原始表示。你的桌面计算器也是一个累加器：它只存储一个数字，即当前显示在屏幕上的结果，你可以将其加上或乘以，并更新存储结果。例如，如果你输入
    2，它会被存储在累加器中。如果你再输入 +3，累加器会存储并显示结果 5。原始值 2 和操作 +3 会丢失，只有累加的结果可用。'
- en: '*Accumulator architectures* are those that have only a single user register
    that acts as an accumulator. The Baby uses this simple style of architecture.
    This forces all computation to be done in the accumulator style because there
    are no other registers in which to keep inputs separate from outputs. By contrast,
    more complex CPUs may have other user registers, in addition to or instead of
    an accumulator.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*累加器架构* 是指只有一个用户寄存器作为累加器的架构。Baby 就使用这种简单的架构风格。这迫使所有计算都必须在累加器样式中进行，因为没有其他寄存器来将输入与输出分开。相反，更复杂的
    CPU 可能除了累加器外，还会有其他用户寄存器。'
- en: '**Internal Registers**'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**内部寄存器**'
- en: In addition to the user registers, most CPUs require further registers for their
    own internal operations. These *internal registers* may be invisible to the user,
    so you can’t write assembly programs that access or modify them. Rather, they’re
    used to make the CPU itself work, and to enable it to read and execute user programs.
    Let’s look at the two most important internal registers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: A CPU needs to keep track of where it currently is in the execution of its program.
    In the Analytical Engine, the current line of the program was stored using the
    mechanical state of the program card reader. Like typewriter paper, the program
    was mechanically fast-forwarded and rewound so that the current line was positioned
    on the reader. In an electronic CPU, there is no mechanically moving state, so
    we must instead keep track of where we are in the program by storing the current
    line number in a register, called the *program counter* (*PC* in the listings
    in this chapter). As we’ve seen, von Neumann architectures—such as the Baby and
    most modern computers—store the program in main memory, along with other data,
    so these “line numbers” are actually memory addresses that store the instructions
    of the program.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The *instruction register (IR)* stores a copy of the current instruction, copied
    in from its address (as kept in the program counter) in memory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '*Arithmetic Logic Unit*'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just like the Analytical Engine’s ALU, a digital logic–based ALU consists of
    a collection of simple machines, each performing one kind of arithmetic operation.
    Due to a quirk in its hardware, the original Baby had only a subtractor, but here
    we’ll build a more general and powerful ALU that also includes addition, multiplication,
    and division. [Figure 7-3](ch07.xhtml#ch07fig3) shows a 32-bit ALU with these
    operations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0166-01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: A 32-bit, four-operation ALU*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Here there are two data inputs, *a* and *b*, each containing a 32-bit, two’s
    complement integer. They’re both sent to all four simple arithmetic machines,
    a subtractor, adder, multiplier, and divider, each of which calculates an output.
    Just one of these outputs is then selected and passed to the ALU’s output, *r*.
    To choose which arithmetic operation you want to do, place its 2-bit code on the
    *c* input. The decoder then activates one of the four 32-bit multiplexers, enabling
    the desired operation’s output to be passed to and through the 32-bit OR gate
    array. A copy of the final output from the OR gate array is passed into a *comparator*,
    which tests if the number is zero and outputs a single status flag with this Boolean.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The comparator can be implemented simply by NOR gating together all of the bits
    in the number. More advanced ALUs often test for other interesting properties
    of the result, such as being positive or negative, having created an overflow
    (which can be seen on the carry out lines of the simple machines), or division
    by zero; they then output a set of flags rather than just this zero test.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could build this ALU with less silicon by using a single multiplexer
    with 2-bit input to select directly between the four arithmetic machines. Duplication
    of digital logic could be reduced by sharing structures between operations—for
    example, using two’s complement enables adders to be reused as subtractors. You
    might also be concerned about the waste of energy from running all of the arithmetic
    options on each set of inputs but throwing all but one result away. You could
    find ways to redesign the network to reduce this energy usage. However, I’ve chosen
    the present structure for educational reasons, as it will help you to more easily
    understand CUs in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '*Control Unit*'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Digital logic CUs implement the same concept as Babbage’s timing barrel, acting
    like a musical conductor to trigger all of the other CPU components at the right
    times. There are many ways to do this, so CUs vary far more than registers and
    ALUs. They’re usually considered to be the hardest and most central part of CPU
    design. We’ll choose a particular style here for ease of understanding rather
    than for computational or energy efficiency.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'This style is based on two structures: first, a counter that, like Babbage’s
    barrel, rotates regularly, and whose value is used to time the required events;
    second, a switching mechanism that determines the type of event to be triggered
    and makes temporary connections between components—such as registers, the ALU,
    and RAM—in response. In Babbage’s machine, these connections were made and broken
    using mechanical levers. For our digital logic version, we’ll use multiplexers,
    as we did in the ALU. These multiplexers have two data inputs, each of word length—32
    bits for the Baby. One is hardwired to zeros and the other is from the temporary
    input source. They have a single-bit switch that switches between relaying the
    temporary input onto the output and sending all zeros to the output. [Figure 7-4](ch07.xhtml#ch07fig4)
    shows how this works.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0168-01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: A multiplexer used to enable or disable a connection of 32 wires*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: As in the ALU, where multiple sources can potentially connect to a destination,
    they each get their own multiplexer. Then an OR array combines the multiplexer
    outputs, allowing the non-zero output to pass through.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a sequence of temporary connections between components. Some of
    these connections can be triggered simply by the time shown on the counter. This
    can be done with a decoder, taking the time as input and activating a particular
    trigger wire as output. Other connections need to be triggered by a combination
    of a time and some other value, such as the identity of the current instruction.
    These can be done by AND gating the appropriate trigger wire to signals representing
    the other required conditions. [Figure 7-5](ch07.xhtml#ch07fig5) shows an example
    of this structure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0168-02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: A minimal CU based on a 3-bit counter, a decoder, and multiplexer
    switches*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The 3-bit counter and decoder on the left form the sequencer. Using 3 bits gives
    us 2³ = 8 times, from 0 to 7, looping back to 0 after each 7\. The figure shows
    triggers only at ticks 0, 1, and 7\. The triggers at ticks 0 and 1 (the upper
    two outputs from the decoder) depend only on the time and make connections between
    32-bit wire groups. At tick 7, there are two possible triggers, which depend on
    conditions cond1 and cond2 being met, respectively, represented by the two switches
    near the bottom-left of the figure. Note that either, neither, or both of these
    conditions (and thus triggers) could be active at this time. The OR symbol here
    represents an array of 32 OR gates. It allows two different inputs to be connected
    to the same shared output (SO) on different triggers. (Triggers from times 2 through
    6 inclusive are omitted in this figure, but you can imagine those wires from the
    decoder connecting to similar triggers.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Let’s introduce a little extra notation at this point to help make our diagrams
    more readable. [Figure 7-6](ch07.xhtml#ch07fig6) shows exactly the same minimal
    CU, but introduces *tunnels*, which are named points (t0 to t7 and c0 to c1) taking
    the place of wires. All tunnels having the same name are assumed to be connected
    to one another. For example, the t0 tunnel coming out of the decoder connects
    to the t0 tunnel going into the multiplexer near the top right of the figure.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0169-01.jpg)![Image](../images/f0169-02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The same minimal CU as in [Figure 7-5](ch07.xhtml#ch07fig5), redrawn
    using tunnel notation*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: This tunnel notation avoids the need to draw the rat’s nest of wires formed
    as the CU sends its triggers all over the rest of the CPU. We’ve also encapsulated
    the 3-bit counter into a single block, CTR3, as provided off-the-shelf by LogiSim.
    (This block has some additional inputs and features that we don’t use here.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve seen each of the basic ingredients of a Baby implementation,
    let’s put them all together—along with suitably timed CU dynamics—to build a complete,
    functioning Baby. We’ll do this by considering the three main stages of operation—fetch,
    decode, and execution—in turn, just as we did when we discussed the Analytical
    Engine in [Chapter 3](ch03.xhtml).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '*Fetch*'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The aim of the fetch stage is to bring a copy of the next instruction from RAM
    into the IR in the CPU. Fetching assumes that the address of the next instruction
    is already in the program counter. When the CPU is first turned on, the program
    counter—like all registers—is initialized to 0, but is immediately incremented
    to 1, so the first instruction must be stored at address 1 and will be fetched.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: To perform a fetch, the program counter is temporarily connected to the address
    lines of RAM, on tick 1\. The data out lines of RAM can be permanently connected
    to the IR data in, but the IR takes only a copy of the word from these lines when
    write-enabled and clocked at tick 2\. The network in [Figure 7-7](ch07.xhtml#ch07fig7)
    is set to perform fetch for the Baby’s 32×32 RAM (32 = 2⁵ addresses, each containing
    one 32-bit word) by making these connections on ticks 1 and 2 of its eight-count
    control cycle, and breaking them on the other steps. In our Baby, the program
    counter is a 5-bit register and the IR is a 32-bit register.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0170-01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: A fetch, triggered on ticks 1 and 2*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the fetch sequence as:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This style of notation is a form of *register transfer language (RTL)*. The
    symbols before the colon on each line are the triggers, which in this case are
    ticks 1 and 2\. The arrows denote that a temporary connection from a source to
    a destination is made only when the trigger is active. The arrows thus correspond
    to the multiplexers used in our implementation style, with the triggers corresponding
    to the switching inputs of these multiplexers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '*RTL is not assembly language or machine code. It’s a lower-level description
    of how the CPU works, whose function is ultimately to execute the machine code
    program written by the user and stored in RAM.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '*Decode*'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now have a copy of the next instruction sitting in the IR. It consists of
    a word of machine code, with some bits specifying the opcode and the other bits
    possibly containing zero, one, or more operands. In the Baby, bits 13 to 15 are
    the opcode, bits 0 to 12 are a single operand for some instructions, and the remaining
    16 bits aren’t used. This encoding now needs to be decoded. We need to split up
    the opcode and operand, then convert the opcode into an activation signal. [Figure
    7-8](ch07.xhtml#ch07fig8) shows our implementation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0171-01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: Decoding, triggered at tick 2*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The IR output is first split into three sets of wires, for the first 13, next
    3, and remaining 16 bits. The middle 3 bits, containing the opcode, are connected
    to a 3-bit decoder. The decoder activates one of its 2³ = 8 output lines, which
    is connected to a tunnel and will be used as a condition to trigger multiplexers
    in other steps. These tunnels are named as their corresponding assembly mnemonics.
    The 13 operand bits of the IR are further split into the 5 lower-order bits, which
    are used for address selection and will have wires connected to them later, and
    the 8 higher-order bits, which have nothing to address and are ignored.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: There’s no sequential logic used here, so decoding happens roughly instantaneously
    once the IR content is updated on tick 2.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '*Execute*'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unlike fetching and decoding, what happens during the execute stage depends
    on the instruction that has been fetched and decoded. Different instructions specify
    the activation of different structures that do different things: load, store,
    arithmetic, and program flow control. We’ll look at how to execute each of these
    possible actions in turn.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Load**'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To execute a load, we temporarily connect the operand to the RAM’s address
    input at tick 3, and then temporarily connect the RAM’s data output to the accumulator
    (Acc) at tick 4\. These tick numbers are chosen to take place after the previous
    fetch and decode. We can write this in RTL style as:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the triggers before the colon now include both a tick and the `LDN`
    condition. The square brackets in `IR[operand]` indicate that only the operand
    bits of IR are to be used, rather than the entire register content.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-9](ch07.xhtml#ch07fig9) shows the digital logic for our Baby implementation’s
    load. (As the Baby’s load operation also negates the loaded values, we pass the
    RAM data out through a negator on its way to the accumulator. This would not usually
    be done on a modern machine.)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In an accumulator architecture such as the Baby, the load always places the
    data from RAM into the accumulator register. In more complex architectures with
    more user registers, an additional operand is needed to specify the target, and
    more digital logic is needed to connect the right register to the data line.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**Store**'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Storing a value from the CPU into memory is similar but opposite to loading.
    In the Baby, the value to be stored is always taken from the accumulator.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'At tick 3, we temporarily connect the STO instruction’s operand (the address
    to store at) to the RAM’s address lines. The accumulator output can be permanently
    connected to the RAM data input, but only write-enabled at tick 3\. The RTL for
    this is:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Figure 7-10](ch07.xhtml#ch07fig10) shows the digital logic implementing this
    for our Baby.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0173-01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: Executing a load, triggered at ticks 3 and 4*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0173-02.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: Executing a store, triggered at tick 3*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: In architectures with more user registers, another operand can be used to specify
    which register’s contents are to be stored, and more switching logic is then needed
    to connect the right register to the data line.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic**'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To execute an ALU operation, the CU makes temporary connections to the ALU’s
    inputs from CPU registers, and creates and sends an ALU command to the ALU’s command
    inputs. The ALU output is then temporarily connected to a destination register.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The Baby’s ALU is especially simple, as it contains only a subtractor. The `SUB`
    instruction triggers a read from RAM, similar to a load instruction, but the RAM
    data is sent to the subtractor rather than to the accumulator. The subtractor
    takes its other input from the accumulator and writes its output back to the accumulator.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-11](ch07.xhtml#ch07fig11) shows our Baby ALU implementation. The
    RAM read is triggered on tick 3, and the accumulator update on tick 4\. The subtractor
    is on the far left of the figure.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0174-01.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Executing an ALU operation, triggered at ticks 3 and 4*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'This can also be described in RTL as:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: More complex architectures having more arithmetic operations than just subtraction
    would package them up into a single ALU structure, with select lines to specify
    which to activate, as you saw in [Figure 7-3](ch07.xhtml#ch07fig3). The decoder
    would then need to recognize multiple different arithmetic opcodes, and route
    each one through some logic to activate the corresponding selection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow Control**'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the start of each instruction, the Baby moves to the next address (line)
    of the program. This can be done by incrementing (adding 1 to) the program counter
    at tick 0.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: If the current instruction is a flow control instruction—that is, a jump or
    branch—then its execution step also needs to update the program counter to get
    it ready for the next instruction.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Modern (direct) jump instructions contain the line number to jump to in their
    operand, so they can be implemented by copying the operand directly into the program
    counter. As we’ve seen, however, the Baby uses an indirect jump instruction, `JMP`,
    in which the operand contains the *address* that in turn contains the actual jump
    target. To implement this indirect jump we thus first attach the operand to the
    RAM address lines at tick 4, then attach the RAM data lines to the program counter
    at tick 5.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The Baby also has a relative jump, `JRP`, which works similarly to `JMP` except
    that the address in the operand contains a number of lines to advance the program
    counter, rather than an absolute address.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: For the branch instruction, `SKN`, we check its condition and behave as normal
    if it’s false, or increment the program counter an extra time if it’s true, to
    skip over one line of code. (Usually the skipped line will be chosen by the programmer
    to be a jump to another part of the code.) To implement this, we send the output
    of the accumulator to a comparator that tests if it’s less than zero. The truth
    or falsehood of this condition is then used (thanks to Boole) as an integer 0
    or 1, which is added to the program counter at tick 5 when the branch instruction
    is active.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: If the current instruction isn’t a control flow instruction (that is, if it’s
    `SUB`, `LDN`, or `STO`), then no further changes are made to the program counter.
    This is implemented simply by wiring the program counter’s output directly to
    its input at tick 5.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-12](ch07.xhtml#ch07fig12) shows our Baby implementation of flow control.
    In RTL notation, this corresponds to:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the program counter has been updated by any of the means described here,
    the fetch-decode-execute cycle is complete, and everything is set up for the next
    cycle to begin.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0176-01.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Program flow control, triggered at ticks 0, 4, and 5*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '*Complete Baby Implementation*'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 7-13](ch07.xhtml#ch07fig13) shows our complete, working Baby CPU, with
    all of the above systems shown together. In the lower-left it adds a register
    and lamp that activate when the halt instruction is executed, preventing any further
    execution. If you get tired of manually triggering the clock, it also adds a switch
    connecting the clock signal to an oscillator.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0177-01.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: A complete, working Baby implementation, including sequencer,
    fetch, decode, execute, and control flow logic. The RAM contents are now shown
    in full.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We now have a complete computer in digital logic, able to execute machine code
    programs in RAM.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of a digital logic CPU is to execute machine code programs, which
    can be assembled from human-readable assembly language. These programs need to
    be placed into memory before the CPU starts its work. They consist of a series
    of instructions that are in turn read into the CPU and executed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: CPUs can initially scare those trying to understand them. Even a minimal example
    such as our Baby might take thousands of transistors; modern CPU chips can contain
    billions. But you’ve seen in this chapter that the basic structure isn’t so complex
    if you think hierarchically, like an architect. From this perspective, you already
    saw how to build a variety of simple machines that each perform a basic task;
    a basic CPU then just connects a small number of these simple machines.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The CU can be built from a sequencer, which triggers the fetch, decode, and
    execute stages. The execute stage is the hardest one to implement, as it involves
    different actions depending on what instruction was decoded. The sub-steps of
    the execute stage therefore need some additional logic to activate the different
    options.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has shown roughly how the Manchester Baby was and can be put together.
    The architecture we built still forms the basic plan for many modern CPUs. Pressures
    from Moore’s law have complicated this plan, however. They prevent modern machines
    from simply being clocked faster, but they allow them to use many more transistors.
    In the next chapter you’ll see some of the more complex uses that modern CPUs
    can make of these extra transistors.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Build a Baby**'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Build the Baby design from [Figure 7-13](ch07.xhtml#ch07fig13) in LogiSim Evolution.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you start working at this level of complexity with sequential logic, it’s
    very easy and common to create hardware bugs around trigger timing. Working architects
    spend a lot of their time debugging timing issues. The hardware equivalent of
    a debugger is a *chronogram* ([Figure 7-14](ch07.xhtml#ch07fig14)), a diagram
    that plots the state of several wires in the system over time. LogiSim Evolution
    has a built-in tool for generating these (**Simulate ▸ Timing diagram**). Find
    out how to use it to test some of the sequential subcircuits from the Baby. Recall
    that sequential logic—write enables for RAM and registers, and RAM read addresses—is
    usually triggered at the *instant* the clock signal rises from 0 to 1, while combinatorial
    logic is active at all times. There are also hardware logic analyzers that will
    capture and display similar data from breadboards, either standalone or sending
    the data to your PC for analysis.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Image](../images/f0179-01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: A LogiSim chronogram*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming the Baby**'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Assemble the test programs—including Turing’s division program—discussed in
    this chapter, and run them in your LogiSim Baby. Use the Python assembler provided,
    with the `for_logisim` flag on line 3 set to True. Save the output in a text file
    and load it as a RAM image in LogiSim by right-clicking the RAM and selecting
    **Load Image**. You can step through CPU cycles manually by clicking the clock,
    or by setting it to tick automatically with **Simulate ▸ Auto-tick** in the menu
    bar. Turing’s program divides 36 by 5, to give result 7 (111[2]), which gets stored—padded
    with zeros—in address 28, so it appears as E000000[16]. Try editing lines 29 to
    31 to perform different divisions.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you explain how Turing’s code works? Remember that the Baby’s two main quirks
    are that it negates values when loading them, and it has only a subtractor rather
    than an adder. These lead to a few programming idioms.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Challenging**'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve used several layers of notational abstraction in our CPU designs: packaging
    up transistors, gates, and simple machines into boxes. Estimate how many logic
    gates, then how many transistors are used in our final design. How does the number
    of transistors compare with those used in the actual historical designs in [Chapter
    1](ch01.xhtml)? How could these be reduced if we preferred an implementation using
    less silicon rather than an educationally easy-to-understand design?'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**More Challenging**'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Baby is a very small, simple computer, but it’s possible to extend it into
    a fairly serious modern machine by modifying our design. Try doing this using
    the following steps.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Increase the RAM size. To do this, you’ll need to increase the size of the addresses
    throughout the design.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the Baby’s LDN with a more normal LOAD instruction, which just loads
    without negation. Or retain LDN and create a new LOAD in addition to it, if you
    want to retain back-compatibility with old code. This will lead to more complexity
    and silicon, but will keep existing users happy, so is representative of a typical
    dilemma architects face.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the single subtraction module with a full two’s complement integer ALU,
    including add, subtract, multiply, and divide. Create extra instructions to trigger
    these operations.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at the later Manchester Mark I and Ferranti Mark I machines to see how
    the original Baby was actually extended to commercialization. Try to emulate them
    in LogiSim.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the nearest we have to an official modern manual for the Manchester Baby,
    see the University of Manchester’s current web page, *[http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/mark1/prog98/ssemref.html](http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/mark1/prog98/ssemref.html)*.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the original publication describing the real Baby, see F.C. Williams, T.
    Kilburn, and G.C. Tootill, “Universal High-Speed Digital Computers: A Small-Scale
    Experimental Machine,” *Proceedings of the IEE [Part II](part02.xhtml): Power
    Engineering* 98, no. 61 (1951): 13–28.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For details of the later Manchester Mark I, see R.B.E. Napper, “The Manchester
    Mark 1 Computers,” in *The First Computers: History and Architectures*, ed. Raúl
    Rojas and Ulf Hashagen (Cambridge, MA: MIT Press, 2000), 365–377.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
