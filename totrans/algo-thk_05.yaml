- en: '5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GRAPHS AND BREADTH-FIRST SEARCH
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll study three problems in which we’re asked to solve puzzles
    in the minimum number of moves. How quickly can a knight catch a pawn? How quickly
    can a student climb a rope in gym class? How cheaply can we translate a book written
    in one language to other target languages? Breadth-first search (BFS) is the unifying
    algorithm here. BFS dispatches these problems, and it applies more generally whenever
    we want to solve a puzzle with the minimum number of moves. Along the way, we’ll
    learn about graphs, a powerful way to model and solve problems that involve objects
    and connections between those objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 1: Knight Chase'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is DMOJ problem `ccc99s4`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This problem concerns two players, a pawn and a knight, playing a board game.
    (Don’t worry: you don’t need to know anything about chess.)'
  prefs: []
  type: TYPE_NORMAL
- en: The board has *r* rows, with row 1 at the bottom and row *r* at the top. The
    board has *c* columns, with column 1 at the left and column *c* at the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pawn and knight each start on their own square of the board. The pawn moves
    first, then the knight moves, then the pawn, then the knight, and so on, until
    the game ends. For each turn, a move must be made: remaining at the current square
    is not an option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pawn has no choice on what move to make: for each of its turns, it moves
    up one square.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The knight, by contrast, has up to eight choices for each move:'
  prefs: []
  type: TYPE_NORMAL
- en: Up 1, right 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up 1, left 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Down 1, right 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Down 1, left 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up 2, right 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up 2, left 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Down 2, right 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Down 2, left 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I say “up to eight choices,” not “exactly eight choices,” because moves that
    bring the knight outside of the board are not allowed. For example, if the board
    has 10 columns and the knight is in column 9, then no move that takes the knight
    two columns to the right is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the knight’s available moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | f |  | e |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | b |  |  |  | a |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | K |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | d |  |  |  | c |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | h |  | 9 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: Here, the knight is represented as `K`, and each letter from `a` to `h` represents
    one of its possible moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game ends when one of three things happens: the knight wins, the game is
    a stalemate (that is, a tie), or the knight loses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Win**   The knight wins if the knight makes a move and lands on the same
    square as the pawn before the pawn reaches the top row. To win, the knight has
    to be the one to make the move; if the pawn makes a move and lands on the knight,
    this doesn’t count as the knight winning.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stalemate**   The game is a stalemate if the knight makes a move and lands
    on the square above the pawn before the pawn reaches the top row. Again, the knight
    has to be the one to make this move; the only exception is that the game can start
    as a stalemate if the knight starts one square above the pawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loss**   The knight loses if the pawn reaches the top row before the game
    otherwise ends. That is, if the pawn gets to the top row before the knight lands
    on the pawn or lands on the square above it, then the knight loses. Once the pawn
    reaches the top row, the knight is not allowed to move anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to determine the best-case outcome for the knight and the number
    of knight moves required to produce that outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first line of input gives the number of test cases that will follow. Each
    test case consists of six lines:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of rows in the board, between 3 and 99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of columns in the board, between 2 and 99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The starting row of the pawn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The starting column of the pawn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The starting row of the knight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The starting column of the knight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s guaranteed that the pawn and knight will have different starting positions
    and that the knight starts at a position where it has at least one available move.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For each test case, output a line with one of three messages:'
  prefs: []
  type: TYPE_NORMAL
- en: If the knight can win, output `Win in *m* knight move(s).`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the knight cannot win but can cause a stalemate, output `Stalemate in *m*
    knight move(s).`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the knight cannot win or cause a stalemate, output `Loss in *m* knight move(s).`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, m is the minimum number of moves made by the knight.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test cases is one second.
  prefs: []
  type: TYPE_NORMAL
- en: '*Moving Optimally*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A true two-player game, such as tic-tac-toe or chess, gives each player a choice
    of what move to make next. However, here, only the knight has a choice. The pawn’s
    moves are all fixed, and we’ll know exactly where the pawn is at all times. It’s
    a good thing, too, because this problem would be significantly more difficult
    if both players had choices.
  prefs: []
  type: TYPE_NORMAL
- en: There may be various ways for the knight to win or cause a stalemate. Suppose
    that the knight can win. Each way that the knight can win requires some number
    of moves; we want to identify the minimum number of moves.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Board
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s explore a little through this input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The board for this test case has seven rows and seven columns. The pawn starts
    at row 1, column 1, and the knight starts at row 4, column 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving optimally, the knight can win here in three moves. The following diagram
    shows how the knight can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **6** |  | K2 |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **5** |  |  |  | K1 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | K3 P3 |  |  |  |  | K |  |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | P2 |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | P1 |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | P |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  prefs: []
  type: TYPE_TB
- en: Here, `K` is used for the knight’s starting position and `P` for the pawn’s
    starting position. `K1`, `K2`, and `K3` give the location of the knight after
    move 1, move 2, and move 3, respectively; `P1`, `P2`, and `P3` do likewise for
    the pawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates (*x*, *y*) refer to row *x*, column *y*. As expected, the pawn
    simply marches up its column, from (1, 1), to (2, 1), to (3, 1), and finally to
    (4, 1). The knight, however, moves as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting at (4, 6), it moves up one and left two to (5, 4). The pawn is at (2,
    1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From (5, 4), it moves up one and left two to (6, 2). The pawn is at (3, 1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From (6, 2), it moves down two and left one to (4, 1). That’s where the pawn
    is!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are other ways for the knight to win. For example, here’s what can happen
    if the knight goofs off a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **6** |  | K2 |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **5** | K4 P4 |  |  | K1 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | P3 |  | K3 |  |  | K |  |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | P2 |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | P1 |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | P |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  prefs: []
  type: TYPE_TB
- en: The knight catches the pawn after four moves, not three. Though the knight still
    wins, this is *not* the fastest way that it can do so. We need to report a minimum
    of three moves here, not four.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we had an algorithm to determine the minimum number of moves that
    the knight can take from its starting point to some destination. We could then
    determine the number of knight moves required to get to each pawn location; if
    the knight can get there at the same time as the pawn, then the knight wins. If
    the knight cannot win, then we could do similarly for stalemates. That is, we
    could determine the number of knight moves required to get to the square above
    each pawn location; if at any point the knight can land on the square above the
    pawn, we have a stalemate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To design such an algorithm, we can explore the board from the knight’s starting
    point. There’s only one square on the board that is reachable in zero moves: the
    knight’s starting point itself. From there, we can discover those squares that
    are reachable in one move. From those squares that are one move away, we can discover
    those squares that are reachable in two moves. We can use those squares reachable
    in two moves to find those reachable in three moves, and so on. We stop when we
    find the desired destination; at that point, we’ll know the minimum number of
    moves that it takes to get there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate this procedure using the same test case as before: seven
    rows and seven columns, with the knight starting at (4, 6). (We’ll ignore the
    pawn for now.) To confirm our answer of three moves that we arrived at by hand,
    we’ll calculate the minimum number of moves for the knight to get from (4, 6)
    to (4, 1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagrams, numbers in the squares indicate the minimum distance
    from the knight’s starting point. As mentioned above, the only square reachable
    in zero moves is the knight’s starting point itself, (4, 6). We’ll call this round
    0 of the exploration:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **6** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **5** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **4** |  |  |  |  |  | 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| **3** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **2** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **1** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  prefs: []
  type: TYPE_TB
- en: 'From (4, 6), we try all eight possible moves to identify the squares reachable
    in one move. We can’t move up one and right two or down one and right two, because
    those would take us beyond the right edge of the board. That leaves six squares
    that are one move away. This is round 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **6** |  |  |  |  | 1 |  | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **5** |  |  |  | 1 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **4** |  |  |  |  |  | 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| **3** |  |  |  | 1 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **2** |  |  |  |  | 1 |  | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  prefs: []
  type: TYPE_TB
- en: 'We haven’t found (4, 1) yet, so we keep going. We explore from each of those
    six new squares that we discovered in round 1; that will yield the squares that
    are two moves away. For example, consider square (6, 5); the squares reachable
    from there are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Up 1, right 2: (7, 7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Up 1, left 2: (7, 3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Down 1, right 2: (5, 7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Down 1, left 2: (5, 3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Up 2, right 1: (which is not valid)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Up 2, left 1: (which is not valid)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Down 2, right 1: (4, 6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Down 2, left 1: (4, 4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These squares are two moves away from the starting point—except for (4, 6),
    whose value (0) we filled in before! Looking at all valid moves from all squares
    that are one move away brings us to round 2, the squares that are two moves away.
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  |  | 2 |  | 2 |  | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| **6** |  | 2 |  |  | 1 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **5** |  |  | 2 | 1 | 2 |  | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| **4** |  | 2 |  | 2 |  | 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| **3** |  |  | 2 | 1 | 2 |  | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** |  | 2 |  |  | 1 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** |  |  | 2 |  | 2 |  | 2 |'
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  prefs: []
  type: TYPE_TB
- en: Notice that there cannot be any other squares that are two moves away. Every
    square that is two moves away must emanate from a square that is one move away,
    and we explored all possible moves from all possible squares that are one move
    away.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still no (4, 1), so we keep going. Exploring from all squares that
    are two moves away gives us round 3, the squares that are three moves away:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  | 3 | 2 | 3 | 2 | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| **6** | 3 | 2 | 3 |  | 1 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **5** |  | 3 | 2 | 1 | 2 | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | 3 | 2 | 3 | 2 | 3 | 0 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** |  | 3 | 2 | 1 | 2 | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 3 | 2 | 3 |  | 1 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** |  | 3 | 2 | 3 | 2 | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  prefs: []
  type: TYPE_TB
- en: 'There we have it: square (4, 1) is filled in with a value of 3\. It therefore
    takes a minimum of three moves to get from (4, 6) to (4, 1). Had we not found
    (4, 1) here, we’d continue: we could proceed to find squares that are four moves
    away, then five moves away, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: This technique—finding all squares that are zero moves away, then one move away,
    then two moves away, and so on—is called *breadth-first search*, or BFS for short.
    The word *breadth* refers to a full range. BFS is so named because we explore
    the full range of what is reachable from each square before moving on to other
    squares. BFS is fast, memory efficient, and clean to implement. It’s an absolute
    power move to invoke BFS whenever you want the minimum distance from one location
    to another location. Let’s go for it!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Breadth-First Search
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s start with a couple of type definitions that clean up our code a little.
    First, each board position is composed of a row and a column, so let’s package
    those together using a struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A board is a two-dimensional array, and we can make a type definition for that
    too. We’ll let it hold integers, which will correspond to numbers of moves. We
    have a maximum of 99 rows and 99 columns, but we allocate one extra row and column
    so we can start indexing rows and columns at `1`, not `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s make an array type for holding the positions that we discover
    during the BFS. We’ll make it big enough that it can hold every possible square
    on the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re ready for the BFS itself. We need a function to determine the minimum
    number of knight moves to get from its starting point to some destination that
    we specify. (Recall that our plan is to find the minimum number of moves needed
    to catch the pawn at each pawn location.) Here’s the signature for the function
    we’ll implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The parameters `knight_row` and `knight_col` give the starting location of the
    knight, and `dest_row` and `dest_col` give the desired destination. The parameters
    `num_rows` and `num_cols` give, respectively, the number of rows and columns in
    the board; we’ll need those to determine whether a move is valid. The function
    returns the minimum number of moves for the knight to go from its starting location
    to the destination. If there’s no way for the knight to get to the destination,
    then we return `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two key arrays that drive the BFS:'
  prefs: []
  type: TYPE_NORMAL
- en: cur_positions   This array holds the positions discovered from the current round
    of BFS. For example, it might be all of the positions discovered in round 3.
  prefs: []
  type: TYPE_NORMAL
- en: new_positions   This array holds the positions discovered in the next round
    of BFS. For example, if `cur_positions` holds the positions discovered in round
    3, then `new_positions` will hold those positions discovered in round 4.
  prefs: []
  type: TYPE_NORMAL
- en: The code is given in [Listing 5-1](ch05.xhtml#ch05ex01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-1: The minimum number of knight moves using BFS*'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is clear out the `min_moves` array by setting all values
    to `-1`; this means that we have not yet computed the number of moves. The only
    square for which we know the minimum number of moves is the knight’s starting
    square, so we initialize that to `0` ➊. That starting square is also the square
    that jump-starts the BFS ➋. The `while` loop then runs as long as the most-recent
    round of BFS has discovered at least one new square ➌. Inside the `while` loop,
    we look at each such square. If we discover the destination square ➍, then we
    return its minimum number of moves. Otherwise, we keep exploring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exploring all eight moves from a given square is accomplished by eight calls
    to a helper function called `add_position`, which adds new squares to `new_positions`
    and updates `num_new_positions` accordingly. Focus on the first four arguments:
    those give the current row and column and the new row and column resulting from
    one of the eight moves. For example, the first call ➎ is for the move that goes
    up two and right one. We’ll look at the code for `add_position` shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve gone through each square in `cur_positions` and found new squares that
    are one more move away. That completes one round of BFS. To prepare for the next
    round, we keep track of the number of new squares ➏ and copy all of the new squares
    from `new_positions` to `cur_positions`. That way, the next iteration of the `while`
    loop uses those new squares and finds further new squares from there.
  prefs: []
  type: TYPE_NORMAL
- en: If we reach the bottom of the code and haven’t found the destination square,
    then we return `-1`—that destination square is not reachable from the knight’s
    starting location.
  prefs: []
  type: TYPE_NORMAL
- en: Now for that `add_position` helper function; see [Listing 5-2](ch05.xhtml#ch05ex02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-2: Adding a position*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statement has five conditions, all of which must be true for `to_row`
    and `to_col` to be a valid position: the row must be at least one, the column
    must be at least one, the row must be at most the number of rows, the column must
    be at most the number of columns, and . . . hmm, that last one, `min_moves[to_row][to_col]
    == -1`, what’s that doing?'
  prefs: []
  type: TYPE_NORMAL
- en: That final condition is there to determine whether we’ve already seen this square.
    If we haven’t, then it will have a value of `-1` and we can go ahead and set its
    number of moves now. If it already has some other value, then it must have been
    discovered in an *earlier* round of BFS, and therefore it already has a smaller
    number of moves than what we could give it now. That is, a value other than `-1`
    means that the minimum number of moves is already set, and we shouldn’t mess with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: If all five conditions pass, then we’ve discovered a new square. We discovered
    (`from_row`, `from_col`) in the previous round of BFS and `(to_row`, `to_col`)
    in the current round. Therefore, the minimum number of moves to (`to_row`, `to_col`)
    is one more than the minimum moves to (`from_row`, `from_col`) ➊. By virtue of
    (`from_row`, `from_col`) coming from the previous round of BFS, we already have
    its value stored in `min_moves`, and so we can simply look up its value without
    recalculating it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may see shades of memoization and dynamic programming here. It’s true:
    BFS uses the same trick of looking stuff up rather than recomputing it. However,
    there’s not really a notion of maximizing or minimizing a solution based on subproblem
    solutions or combining smaller solutions to form a larger solution. Algorithm
    developers therefore generally don’t refer to BFS as a dynamic-programming algorithm,
    instead classifying it as a search or exploration algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Best Knight Outcome*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve got BFS bottled up nicely as the `find_distance` function. Now let’s
    count the number of moves as the pawn marches up its column and use `find_distance`
    to determine whether the knight can ever land on the pawn. For example, if the
    pawn takes three moves to get somewhere, and the knight can take exactly three
    moves to get there too, then the knight wins in three moves. If the knight can’t
    win, then we can try a similar technique for stalemates: let the pawn march up
    its column again, this time checking whether the knight can cause a stalemate.
    If no stalemates are possible, well, then the knight loses. I’ve got this logic
    coded up in [Listing 5-3](ch05.xhtml#ch05ex03). The function `solve` takes six
    parameters: the starting row and column of the pawn, the starting row and column
    of the knight, and the numbers of rows and columns in the board. It prints one
    line of output corresponding to whether the knight wins, stalemates, or loses.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-3: The best outcome for the knight (bugged!)*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get a grip on this code by studying it in three chunks.
  prefs: []
  type: TYPE_NORMAL
- en: The first chunk is the code that checks whether the knight can win. We begin
    by saving the pawn’s row in a new variable ➊—we’ll mess with the pawn’s row to
    move the pawn up the board, so we need to remember the row in which it originally
    started. The `while` loop keeps going as long as the pawn hasn’t reached the top
    row. On each iteration, we calculate the number of moves that the knight needs
    to get to the same location as the pawn. If the knight can get there at the same
    time as the pawn ➋, then the knight can win. If the knight can’t win, then the
    pawn will reach the top of the board and we’ll continue below the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: That’s where the second chunk of code begins ➌. Its task is to determine whether
    the knight can cause a stalemate. The code is the same as the first chunk, except
    that in the `while` loop it checks the number of moves required for the knight
    to land on the row above the pawn rather than the row of the pawn.
  prefs: []
  type: TYPE_NORMAL
- en: The third chunk is a single line ➍, and it only executes if the knight cannot
    win or stalemate. This chunk simply outputs the loss message.
  prefs: []
  type: TYPE_NORMAL
- en: That’s how we process a single test case. To read and process all of the test
    cases, we need a little `main` function; it’s as simple as [Listing 5-4](ch05.xhtml#ch05ex04).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-4: The* main *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Feeling good? We’ve now got a complete solution. We’re using BFS to optimize
    the number of moves taken by the knight. We’re checking for knight wins, stalemates,
    and losses. Now submit this solution to the judge. Are you still feeling good?
  prefs: []
  type: TYPE_NORMAL
- en: '*The Knight Flip-Flop*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In earlier chapters, I hit you with some solutions that were correct but too
    slow to pass the test cases. In contrast, what I’ve provided here for the Knight
    Chase problem is *incorrect*: there are test cases for which we produce the wrong
    output. Our code happens to be unnecessarily slow, too.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s fix it all!
  prefs: []
  type: TYPE_NORMAL
- en: Making Our Code Correct
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Our code is incorrect because it does not consider that the knight can sometimes
    be too fast! That is, it can get to a pawn’s location before the pawn gets there.
    Testing for exactly the same number of pawn and knight moves is therefore too
    stringent.
  prefs: []
  type: TYPE_NORMAL
- en: 'A test case will clear this up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a board with five rows and three columns; the pawn starts at row 1,
    column 1 and the knight starts at row 3, column 1\. Here’s what our current code
    outputs for this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: (The output is `3`, not `4`, because the knight is not allowed to move once
    the pawn reaches the top row.) This means that there is no win or stalemate location
    for which the minimum number of knight moves is the same as the number of pawn
    moves. That, at least, is true. However, it’s still possible for the knight to
    win here and to do so in two moves. Take some time to try to identify how the
    knight can do this!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s no way for the knight to win in one move if the pawn is at (2, 1).
    However, after two moves, the pawn is at (3, 1), and it’s possible for the knight
    to land on (3, 1) after two moves, too. Here’s what the knight can do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Move 1: go from (3, 1) to (5, 2).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Move 2: go from (5, 2) back to (3, 1).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimum number of moves for the knight to get to (3, 1) is zero— it’s the
    knight’s starting point, after all. By going to some other square and returning,
    the knight can land on (3, 1) not only after zero moves but after two moves as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a self-check: change the knight’s starting point from (3, 1) to (5,
    3). Can you figure out how the knight can win now in three moves?'
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing, we can say that if the knight can get to a square in a minimum
    of *m* moves, then it can also get to that square in *m* + 2 moves, or *m* + 4
    moves, and so on. All it has to do is keep going to some other square and returning.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means for our solution is that, at each step, there are two ways
    for the knight to win or stalemate: it can do so because its minimum number of
    moves matches the number of pawn moves or because its minimum number of moves
    is an even number larger than the number of pawn moves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'we need this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re testing whether the difference between the number of pawn moves
    and the number of knight moves is a multiple of two.
  prefs: []
  type: TYPE_NORMAL
- en: There are two instances of the incorrect code in [Listing 5-3](ch05.xhtml#ch05ex03);
    changing both yields the (correct!) code in [Listing 5-5](ch05.xhtml#ch05ex05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-5: The best outcome for the knight*'
  prefs: []
  type: TYPE_NORMAL
- en: As promised, all we’ve done is change two conditions ➊ ➋. Now the code passes
    the judge.
  prefs: []
  type: TYPE_NORMAL
- en: A Correctness Argument
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re suitably convinced of correctness, feel free to skip this section.
    Otherwise, I’d now like to address a possible concern that you may have at this
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that the knight gets to a square an even number of moves ahead of the
    pawn and that this takes *m* moves. Also suppose that the knight leaves and revisits
    this square as many times as it likes, returning to this square after *m* + 2
    moves, *m* + 4 moves, and so on, eventually catching the pawn here. It would be
    scary if the knight could use some other sequence of moves to catch the pawn in
    *m* + 1 moves, or *m* + 3 moves, and so on, because then adding an odd number
    of moves could provide us a better minimum than adding an even number of moves.
    Fortunately, that can’t happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try this little experiment: choose a starting point and destination for the
    knight, and find the minimum number of moves that it takes for the knight to move
    from the starting point to the destination. That number of moves is *m*. Now try
    to find a way for the knight to get from that same starting point to that same
    destination using exactly one more move, or three more moves, and so on. For example,
    if the fastest way takes two moves, try to find a way to take three moves. You
    won’t be able to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: Each knight move changes the row or column number by two and the other by one.
    For example, it might change the row number from six to four and the column number
    from four to five. Changing a number by two does not change whether that number
    is even or odd, but changing a number by one *does* change that number from even
    to odd or vice versa. That is, in terms of being even or odd, each move leaves
    one of the two numbers (row or column) alone, and it changes the other one. When
    a number changes from even to odd or vice versa, we say that its *parity* changes.
  prefs: []
  type: TYPE_NORMAL
- en: Let *k* be an odd integer. Now we’re ready to see why the knight can’t take
    both *m* moves and *m* + *k* moves to get to the same destination. Suppose that
    the knight can take *m* moves to get to square *s*, that *m*[1] of those moves
    change whether the row is even or odd, and that *m*[2] of those moves change whether
    the column is even or odd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that *m*[1] and *m*[2] are both even. As such, the moves don’t change
    the parity of the row or column: if we start with some number and flip its parity
    an even number of times, its parity doesn’t change. If we make some other sequence
    of moves, and it flips the parity of the row an odd number of times or flips the
    parity of the column an odd number of times, then that sequence cannot land at
    *s*, because it will land on a square with different row or column parity than
    *s*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, *m*, the total number of moves *m*[1] + *m*[2], is even: adding two even
    numbers gives an even number. But, *m* + *k* is odd, because it’s the sum of an
    even number and an odd number. And, since *m* + *k* is odd, it cannot be built
    from an even number of moves that change the row and an even number of moves that
    change the column; at least one of them must be odd and therefore change the parity
    of the row or column. This is why these *m* + *k* moves cannot result in the knight
    landing on *s*! (There are three other cases—*m*[1] even and *m*[2] odd, *m*[1]
    odd and *m*[2] even, and *m*[1] odd and *m*[2] odd—but I’ll skip those. Their
    analysis is similar.)'
  prefs: []
  type: TYPE_NORMAL
- en: '*A Time Optimization*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our current solution ([Listing 5-5](ch05.xhtml#ch05ex05)) can make a lot of
    BFS calls. Each time the pawn moves up a row, we use BFS (by calling `find_distance`)
    to determine whether it can be caught there by the knight.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that the pawn starts at (1, 1). We run a BFS from the knight’s starting
    point to (1, 1), and that explores some of the squares. Suppose that the knight
    can’t catch the pawn here. We then have to run a BFS from the knight’s starting
    point to (2, 1). This explores some of the squares, too. However, (1, 1) and (2,
    1) are very close together, to the point that the second BFS probably re-explores
    many of the squares whose shortest distances were discovered in the first BFS
    call. Unfortunately, each of our BFS calls is independent, so that second BFS
    call redoes a lot of the work that the first BFS call did. The third call then
    duplicates a lot of what the prior two BFS calls did, and on and on.
  prefs: []
  type: TYPE_NORMAL
- en: It’s true that BFS is fast, and I’ll give more details on why in the next section.
    Still, it pays to try to reduce the number of invocations of BFS.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have good news: we can reduce the number of BFS calls to just . . . one!
    Recall our BFS code in [Listing 5-1](ch05.xhtml#ch05ex01). We had code ➍ to cut
    our BFS short if we found the target position. However, if this code is removed,
    then the BFS will explore the entire board, calculating the shortest distance
    to each square. Making that change means that we can make one call to BFS and
    then be done with it. From then on, we just look up what we need in the `min_moves`
    array.'
  prefs: []
  type: TYPE_NORMAL
- en: Do it! Make the required changes to the code so that BFS is called only one
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The code we worked through together takes 0.1 seconds when I submit to the judge.
    With the “only one invocation of BFS” optimization, the code takes only 0.02 seconds,
    a speedup of 500 percent. More importantly, this optimization shows that BFS can
    be used not only to find the shortest distance from a starting position to some
    other position, but also to find the distance from the starting position to *all*
    other positions. I’ll discuss BFS a little more in the next section. And keep
    reading after that, because I think the flexibility of BFS is going to surprise
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs and BFS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BFS is a powerful search algorithm, as we saw in the solution to the Knight
    Chase problem. To run a BFS, we need what’s called a *graph*. We didn’t think
    about graphs when solving the Knight Chase problem—or perhaps didn’t know what
    they were!—but there was indeed a graph underlying the BFS.
  prefs: []
  type: TYPE_NORMAL
- en: '*What Are Graphs?*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 5-1](ch05.xhtml#ch05fig01) is our first example of a graph.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: A graph of knight moves*'
  prefs: []
  type: TYPE_NORMAL
- en: Like a tree, a graph consists of *nodes* (the boxes) and *edges* between nodes
    (the lines). In this graph, the edges represent valid knight moves. For example,
    from the (5, 1) node, the knight can move on an edge to (4, 3) or on an edge to
    (3, 2). There are no other edges involving (5, 1), so there are no other knight
    moves from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I can explain how we implicitly used a graph to solve the Knight Chase
    problem. Suppose that (5, 1) is the knight’s starting position. Our BFS tries
    all eight moves from there, but six of them lead to a position that is outside
    of the board; in graph terminology, six of them are not edges from (5, 1). The
    BFS discovers the two nodes that *are* reachable on an edge from (5, 1): (4, 3)
    and (3, 2). The exploration then continues with the nodes reachable from each
    of these two nodes, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: I laid the graph out as a grid to reflect the underlying board, but the way
    that a graph is drawn carries no meaning. All that matters are the nodes and edges.
    I could have drawn the graph with the nodes chaotically spread around, and it
    would have conveyed the same meaning. However, when the graph is rooted in some
    underlying geometry, it makes sense to display the graph in a corresponding way
    for easier interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the Knight Chase problem, we didn’t need to explicitly represent the
    graph in code, because we figured out the available moves (edges) from each node
    as we explored the board. Sometimes, though, we do need to represent a graph explicitly
    in code, along the lines of our tree representations in [Chapter 2](ch02.xhtml).
    We’ll see how to do that in Problem 3.
  prefs: []
  type: TYPE_NORMAL
- en: '*Graphs vs. Trees*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Graphs and trees have a lot in common. They’re both used to represent relationships
    between nodes. In fact, every tree is a graph, but there are graphs that are not
    trees. Graphs are more general, and they can express more than what trees can
    express.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, graphs (but not trees) allow cycles. We have a *cycle* in a graph if
    we can start from a node and get back to it without using any repeated edges or
    nodes. (The first and last nodes in the cycle are the only ones that repeat.)
    Look back at [Figure 5-1](ch05.xhtml#ch05fig01). Here’s a cycle in that graph:
    (5, 3) → (4, 5) → (3, 3) → (4, 1) → (5, 3).'
  prefs: []
  type: TYPE_NORMAL
- en: Second, graphs (but not trees) can be *directed*. The trees and graph we’ve
    seen so far are *undirected*, meaning that if two nodes *a* and *b* are connected
    by an edge, then we can travel both from *a* to *b* and from *b* to *a*. The graph
    in [Figure 5-1](ch05.xhtml#ch05fig01) is undirected; for example, we can move
    from (5, 3) on an edge to (4, 5) and use that same edge to move from (4, 5) to
    (5, 3). Sometimes, though, we want to allow travel in only one direction, not
    the other. A *directed* graph is a graph in which each edge indicates the allowed
    direction of travel. [Figure 5-2](ch05.xhtml#ch05fig02) depicts a directed graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: A directed graph*'
  prefs: []
  type: TYPE_NORMAL
- en: Note, in [Figure 5-2](ch05.xhtml#ch05fig02), how it’s possible to move from
    E to each of the other nodes, but it is not possible to move from any of those
    nodes to E. The edges are one-way edges.
  prefs: []
  type: TYPE_NORMAL
- en: Directed graphs are useful whenever an undirected graph would lead to loss of
    information. In my Computer Science department, each course has one or more prerequisite
    courses. For example, we have a C Programming course, which requires that students
    have already taken our Software Design course. A directed edge Software Design
    → C Programming captures this relationship. Had we used an undirected edge, we’d
    still know that the courses were related, but we wouldn’t know the order in which
    the courses must be taken. [Figure 5-3](ch05.xhtml#ch05fig03) shows a small prerequisite
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: A graph of course prerequisites*'
  prefs: []
  type: TYPE_NORMAL
- en: The third thing that makes graphs more general than trees is that graphs can
    be *disconnected*. All trees and graphs we have seen to this point are *connected*,
    which means that you can get from any node to any other node. Now check out the
    disconnected graph in [Figure 5-4](ch05.xhtml#ch05fig04).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: A graph of disconnected course prerequisites*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s disconnected because, for example, you can’t follow a path from *Intro
    to Programming* to *World Prehistory*. Disconnected graphs are useful whenever
    a graph is naturally composed of separate pieces.
  prefs: []
  type: TYPE_NORMAL
- en: '*BFS on Graphs*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can run BFS on an undirected graph (as we did for the Knight Chase problem)
    or a directed graph. The algorithm is the same: we go through the possible moves
    from the current node and explore them. BFS is known as a *shortest-path* algorithm:
    among all paths between a starting node and some other node, BFS gives us the
    shortest one in terms of the number of edges. As long as what we care about is
    minimizing the number of edges, it solves the *single-source shortest-paths* problem,
    since it finds shortest paths from a single source (or starting) node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to control to make BFS fast is not whether the graph is undirected
    or directed, but the number of times we invoke BFS and the number of edges in
    the graph. The runtime of a BFS call is proportional to the number of edges reachable
    from the starting node. That’s because BFS looks at each edge once to determine
    whether it leads to the discovery of a new node. We call BFS a linear-time algorithm,
    since it does work linear in the number of edges: if 5 edges takes 5 steps for
    BFS to explore it, then 10 edges will take 10 steps. We’ll use the number of edges
    to estimate the number of steps performed by BFS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Knight Chase problem, we had a board with *r* rows and *c* columns.
    Each node has at most eight edges, so the board has at most 8*rc* edges in total.
    Therefore, running one BFS takes 8*rc* steps. For the biggest board, 99×99, this
    is fewer than 80,000 steps. If we call BFS on the order of *r* times, as can happen
    in [Listing 5-5](ch05.xhtml#ch05ex05), then we’re looking at 8*r*²*c* steps. Now
    the 99×99 board isn’t looking so good: it could take over 7 million steps. This
    is why it helps so much to reduce the number of calls of BFS!'
  prefs: []
  type: TYPE_NORMAL
- en: Any time a problem involves a set of objects (board locations, courses, people,
    websites, and so on) and relationships between those objects, it’s a good bet
    that modeling the problem as a graph will help. Once you model a problem as a
    graph, you can take advantage of a huge number of fast algorithms on graphs. BFS
    is one of those algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '*Graphs vs. Dynamic Programming*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes it can be difficult to determine whether to use dynamic programming
    or a graph to solve a problem. The giveaway is often the presence of a cycle:
    if you have a cycle, then you need a graph.'
  prefs: []
  type: TYPE_NORMAL
- en: None of the problems that we solved in [Chapter 3](ch03.xhtml) or [Chapter 4](ch04.xhtml)
    had a cycle. In Burger Fervor we recursed with fewer minutes. In Moneygrubbers
    we recursed with fewer needed apples. In Hockey Rivalry we recursed with fewer
    games. We always go down—there’s no way to loop back to a higher number of minutes
    or apples or games to cause a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: It’s trickier to see that this is true for The Jumper in [Chapter 4](ch04.xhtml),
    but it is. Think back to our forward formulation. If we jump to the right, then
    we recurse with a bigger jump distance. If we jump to the left, then we recurse
    with the same jump distance but a smaller-numbered square. There’s no way to start
    at a given subproblem and get back to it using these jumps. You might try to do
    that by making some jumps to the left and then making a jump to the right—but
    your jump to the right will have increased the jump distance by one and there’s
    no way to decrease it by one ever again.
  prefs: []
  type: TYPE_NORMAL
- en: No cycle!
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: Rope Climb'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Knight Chase problem, we were explicitly given a board on which a game
    takes place. Here, we won’t be given the board directly, so we’ll have to work
    it out. Again, the strategy will be to model valid moves using BFS.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `wc18c1s3`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bob is asked to climb a rope in gym class. The rope is infinitely long, but
    Bob is being asked to get only to a height of at least *h* meters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob starts at a height of 0\. He knows how to jump up by exactly *j* meters,
    but that’s the only jump he knows how to do—so if *j* is `5`, then he can’t jump
    up four or six meters or any other number of meters except five. In addition,
    Bob knows how to fall, and he can fall down any number of meters: one, two, three,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Each jump or fall counts as one move. For example, if Bob jumps up five meters,
    falls down two meters, jumps up five meters, and falls down eight meters, then
    Bob will have made four moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here’s the fun part: Alice has spread itching powder on some segments
    of the rope. If such a segment goes from height *a* to height *b*, then the entire
    segment from *a* to *b*, including the endpoints *a* and *b*, has itching powder.
    The effect that the itching powder has on Bob’s moves is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Bob cannot jump up *j* meters if that would land him on itching powder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bob cannot fall down a given number of meters if that would land him on itching
    powder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is to determine the minimum number of moves needed for Bob to get to
    height *h* or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A line containing three integers: *h*, *j*, and *n*. *h* tells us the minimum
    height that Bob must reach, *j* is the distance that Bob can jump up, and *n*
    is the number of segments on which Alice has spread itching powder. Each integer
    is at most 1,000,000, and *j* is at most *h*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, each of which contains two integers. The first integer gives the
    starting height for a segment of rope with itching powder; the second gives the
    ending height. Each integer is at most *h* – 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the minimum number of moves needed for Bob to reach height *h* or higher.
    If there is no way for Bob to reach height *h* or higher, output `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 1.8 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Finding the Moves*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by making direct comparisons to the Knight Chase problem. Notice
    in both cases that our goal is to minimize the number of moves. Whether it’s a
    knight on a board or Bob on a rope, the goal is the same. It’s true that the knight
    was moving around a two-dimensional board and Bob is moving around a one-dimensional
    rope, but that just changes how we’ll refer to each position. BFS won’t otherwise
    care about the change from two dimensions to one. If anything, dropping one dimension
    simplifies things a little!
  prefs: []
  type: TYPE_NORMAL
- en: 'How about the number of possible moves from each position? The knight had at
    most eight of those. In contrast, the number of possible moves Bob can make increases
    with his position. For example, if Bob is at a height of 4, and he can jump up
    by 5, then he has five possible moves: jump up by 5, fall down by 1, fall down
    by 2, fall down by 3, or fall down by 4\. If Bob is at a height of 1,000, then
    he has 1,001 possible moves! So we’ll have to take Bob’s current position into
    account when determining the number of available moves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What about the itching powder? Knight Chase doesn’t have anything resembling
    that. Let’s look at a test case to see what we’re up against here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Bob has to get to a height of 10 or higher. He can jump up by four. So, if there
    were no itching powder, he’d be able to jump from a height of 0 to 4, then to
    8, and then to 12\. That’s three moves.
  prefs: []
  type: TYPE_NORMAL
- en: Bob can’t do that, though! He isn’t allowed to jump from 4 to 8, because there’s
    itching powder at a height of 8 (as the itching powder goes from 8 to 9). The
    solution, by factoring in the itching powder, is four moves. For example, Bob
    can jump from 0 to 4, then fall to 3, then jump to 7, and then jump to 11\. That
    jump from 7 to 11 breezes right past the itching powder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The move from 4 to 8 seems available based on Bob’s ability to jump up by four,
    but it is actually not available because of the itching powder. This isn’t so
    different than a knight move being unavailable because it would take the knight
    outside of the board. For those invalid knight moves, we detected them in the
    BFS and didn’t add them to the next round of positions. We’ll handle itching powder
    similarly: any move that would cause Bob to land on itching powder will be disallowed
    in our BFS code.'
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of those invalid knight moves that take the knight outside of the board,
    do we have to worry about that kind of thing here? The rope is infinitely long,
    so we won’t break any rules by letting Bob climb higher and higher. However, at
    some point we really do have to stop; otherwise, the BFS will forever be finding
    and exploring new positions. I’ll invoke the insight from Moneygrubbers in [Chapter
    3](ch03.xhtml) that helped us out of a very similar bind when buying apples. We
    said there that if we’re asked to buy 50 apples, then we should consider buying
    at most 149 apples, because each pricing scheme gives us at most 100 apples. Here,
    remember from the problem description that *j*, the distance that Bob jumps up,
    is at most *h*, the minimum target height. We shouldn’t let Bob get to height
    2*h* or higher. Think about what it would mean the first time we got Bob to height
    2*h* or higher. One move prior, Bob would have been at height 2*h* – *j* ≥ *h*,
    and that would have taken one move less than getting Bob to height 2*h*! Thus,
    getting Bob to height 2*h* or higher can’t be the fastest way to get him to at
    least height *h*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Breadth-First Search
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We’ll very closely follow what we did for the Knight Chase problem, making
    changes only when necessary. Back then, each knight position consisted of both
    a row and a column, so we created a struct to hold both of those pieces of information.
    Now, a position on a rope is just an integer, so we don’t need a struct for that.
    We’ll make type definitions for the “board” and the positions discovered by BFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It may seem a little weird to call a rope a board, I suppose, but it serves
    the same purpose as the corresponding type definition in the Knight Chase problem,
    so let’s stick with it.
  prefs: []
  type: TYPE_NORMAL
- en: We’re eventually going to make a single call of BFS, and that call is going
    to calculate the minimum number of moves for Bob to get from a height of zero
    to each valid position. The code for the BFS is given in [Listing 5-6](ch05.xhtml#ch05ex06)—compare
    this to the `find_distance` code in [Listing 5-1](ch05.xhtml#ch05ex01). (Especially,
    compare it to the code I hope you wrote after reading “A Time Optimization” on
    [page 168](ch05.xhtml#sec69).)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-6: Minimum number of moves for Bob using BFS*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four parameters for this `find_distances` function:'
  prefs: []
  type: TYPE_NORMAL
- en: target_height   The minimum height that Bob must reach. It’s the *h* value from
    the test case.
  prefs: []
  type: TYPE_NORMAL
- en: jump_distance   The distance that Bob can jump up. It’s the *j* value from the
    test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'itching   An array that indicates where itching powder is present. If `itching[i]`   is
    `0`, then there’s no itching powder at height `i`; otherwise, there is. (Looking
    ahead, we’ll have to build this array from the segments of itchy rope given in
    the test case. But we’ll be able to do that, and then we won’t have to worry about
    the particular segments themselves: we can just index this array.)'
  prefs: []
  type: TYPE_NORMAL
- en: min_moves   The board in which we’ll store the minimum number of moves to get
    to each position.
  prefs: []
  type: TYPE_NORMAL
- en: As in [Listing 5-1](ch05.xhtml#ch05ex01) for Knight Chase, we initialize each
    position of the board to `-1` ➊, which means that BFS hasn’t found this position
    yet. That initialization, as with any other manipulation of `board` here, indexes
    a one-dimensional (not two-dimensional!) array. Other than that, the structure
    is quite similar to the BFS code for Knight Chase.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, an interesting structural change to the code that adds positions.
    Bob has exactly one jump distance, so there’s only one jump move to consider ➋:
    Bob starts at `from_height` and ends up, if it’s a valid position, at `from_height
    + jump_distance`. We can use `target_height * 2 - 1` to get the maximum height
    that Bob is allowed to reach. For falling down, we cannot hard-code Bob’s available
    moves; those moves depend on Bob’s current height. To handle that, we use a loop
    ➌ to consider all destination heights from 0 (the ground) up to but not including
    `from_height` (Bob’s current height). This loop is the only significant change
    from the Knight Chase BFS.'
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up our BFS code, we need to implement the `add_position` helper function.
    That code is given in [Listing 5-7](ch05.xhtml#ch05ex07).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-7: Adding a position*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob wants to move from `from_height` to `to_height`. This move is allowed if
    it passes three tests. First, Bob can’t be jumping above the maximum allowed height.
    Second, he can’t be jumping somewhere that has itching powder. Third, the `min_moves`
    board better not have already recorded a number of moves for `to_height`: if a
    value is already in there, then it has a faster way to get to `to_height`. If
    we passed these tests, then we’ve found a new, valid position; we set the number
    of moves to get there and then store this as a position for the next round of
    BFS.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Best Height
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are many possibilities for Bob’s final position. It could be the target
    height *h* from the test case. However, depending on *j* and the itching powder,
    it could be higher than that. We know for each position the minimum number of
    moves to get there. What we have to do now is check all of the candidate positions,
    choosing the one that minimizes the number of moves. That code is given in [Listing
    5-8](ch05.xhtml#ch05ex08).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-8: The minimum number of moves*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible that Bob can’t get to his target height, so we start `best` off
    with a value of `-1` ➊. For each candidate height, we then check whether it’s
    possible for Bob to land there. If he can, and doing so is faster than our current
    minimum number of moves `best` ➋, then we update `best` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now got all the code to process a test case and output the result. All
    that’s left is to read the input. The `main` function in [Listing 5-9](ch05.xhtml#ch05ex09)
    does that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-9: The* main *function*'
  prefs: []
  type: TYPE_NORMAL
- en: As is typical for large arrays, we have made `itching` and `min_moves` static.
    The elements of `itching` are initialized to `0`, which means that there is no
    itching powder yet on the rope. For each segment where there is itching powder
    on the rope, we loop through each integer in the range ➊ and set the corresponding
    element of `itching` to `1` ➋. Once we’re done looping through the itchy segments,
    each index of `itching` tells us if the rope does (value `1`) or does not (value
    `0`) have itching powder there. We no longer care about the individual itchy segments
    themselves—we have all that we need in `itching`.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. We’ve got a solution that uses a single call of BFS. It’s time to
    submit to the judge. As some might say, Bob’s your uncle . . .
  prefs: []
  type: TYPE_NORMAL
- en: Or, hopefully he will be, but he’s not yet. Because you should receive a “Time-Limit
    Exceeded” error with this code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: A Remodel*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s run test cases of increasing size to get a sense of how our runtime is
    growing. To simplify things, we won’t use any itching powder. Here’s the first
    test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s a target height of at least 30,000, with a jump distance of 5\. On my
    laptop, that takes about eight seconds. Now let’s double the target height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'I’m looking at about 30 seconds here. That’s nearly four times longer than
    in the previous case. We’ve long blown past the 1.8-second time limit, but let’s
    do this one more time, doubling the target height again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'That gives a glacially slow 130 seconds, approximately another fourfold increase
    from the previous test case. That is, it seems that doubling the input size leads
    to the runtime being multiplied by four. This isn’t as catastrophic as what we
    saw in “Solution 2: Memoization” when solving Burger Fervor in [Chapter 3](ch03.xhtml),
    but it’s clearly too slow.'
  prefs: []
  type: TYPE_NORMAL
- en: Too Many Fall Edges
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In “BFS on Graphs” on [page 172](ch05.xhtml#sec72), I warned that we need to
    keep two things in check when using BFS: the number of times we call BFS and the
    number of edges in the graph. We’re doing as well as possible with the number
    of BFS calls, as we only call BFS once. To further pursue a solution based on
    BFS, then, we need a way to reduce the number of edges in the graph.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the graph for a small example shown in [Figure 5-5](ch05.xhtml#ch05fig05).
    We’ll then be able to extrapolate to larger examples and see why our code churrs
    and churrs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: A graph of Bob’s moves*'
  prefs: []
  type: TYPE_NORMAL
- en: The graph shows the available moves from a height of 0 to a height of 7, if
    we assume that Bob can jump up by 3\. This is an example of a directed graph;
    notice, for example, that there is a move from 6 to 5 but not one from 5 to 6.
  prefs: []
  type: TYPE_NORMAL
- en: The graph contains jump edges that encode Bob’s possible jumps and fall edges
    that encode Bob’s possible falls. The jump edges go from the bottom to the top
    and the fall edges go from the top to the bottom. For example, the edge from a
    height of 0 to a height of 3 is a jump edge; the aforementioned edge from 6 to
    5 is a fall edge.
  prefs: []
  type: TYPE_NORMAL
- en: The number of jump edges isn’t worrisome at all. We have at most one jump edge
    per node. If we have *n* nodes, then we have at most *n* jump edges. If we decide
    to model up to a height of 8 instead of 7, then we’d add only one new jump edge.
  prefs: []
  type: TYPE_NORMAL
- en: However, the fall edges proliferate at a much faster rate. Notice that there
    is one fall edge from a height of 1, two fall edges from 2, three fall edges from
    3, and so on. That is, for a rope of height *h*, we have a total of 1 + 2 + 3
    + . . . + *h* fall edges. If we want to know how many fall edges there are for
    a given rope height, we could add up the integers from 1 to that height. There
    is, however, a convenient formula that we can use instead to get the answer much
    faster. It’s *h*(*h* + 1)/2\. For a rope height of 50, for example, we’d have
    50(51)/2 = 1, 275 fall edges. For a rope height of two million, we’d have over
    two trillion fall edges.
  prefs: []
  type: TYPE_NORMAL
- en: Back in [Chapter 1](ch01.xhtml), we saw a very similar formula in “Diagnosing
    the Problem” on [page 9](ch01.xhtml#ch01lev1), when we were counting pairs of
    snowflakes. Like that one, our formula here is quadratic, being *O*(*h*²), and
    it’s this quadratic growth in fall edges that bests our algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Moves
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If we’re going to reduce the number of edges in the graph, then we’re going
    to have to change the available moves that the graph encodes. We can’t change
    the rules of the actual game that Bob plays in gym class, but we *can* change
    the moves in our graph model of the game. Of course, we are only able to change
    the graph if a BFS on the new graph produces the same answer as a BFS on the old
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: There’s an important lesson here. It’s tempting to map the available moves,
    one for one, from the real-world problem to the graph. We did that for Knight
    Chase and succeeded in solving the problem. While this might be tempting, it’s
    not a requirement. We can produce a different graph, one with a more desirable
    number of nodes or edges, as long as that graph can still give us the answer to
    the original problem.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we want to fall some distance from a height of five meters. One
    possibility might be to fall four meters. Indeed, solving the problem as in Solution
    1, there would be a fall edge from a height of 5 down to 1\. However, another
    way to think of this fall is as four falls of one meter each. That is, we can
    think of Bob falling from 5 to 4, then falling to 3, then falling to 2, and then
    falling finally to 1\. That is, I’m imagining that every fall edge would be exactly
    one meter long. No more fall edges like those from a height of 5 to 3, or 5 to
    2, or 5 to 1, or 5 to 0\. There would be just one fall edge from each node, bringing
    us one meter lower. This should drastically cut down on the number of fall edges!
  prefs: []
  type: TYPE_NORMAL
- en: We have to be careful, though. We can’t let each of these mini, one-meter falls
    count as a move. If Bob falls four meters, using four one-meter-fall edges, then
    we still have to count it as a single move, not four moves.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have two ropes (0 and 1), not one. Rope 0 is the rope that we’ve
    always had. Alice set it up. It might have itching powder. Rope 1 is new, devised
    by us, for the purposes of modeling. It has no itching powder. In addition, when
    Bob is on Rope 1, he’s not allowed to move upward.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Bob wants to make a fall move, he will move from Rope 0 to Rope 1\. He’ll
    stick with Rope 1, falling, for as long as he wants to fall. Then, at any point
    where there isn’t itching powder on Rope 0, he can end his fall by moving back
    to Rope 0\. Specifically, we have the following moves now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When Bob is on Rope 0, he has two possible moves: jump up by *j* meters or
    move over to Rope 1\. Each costs one move.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When Bob is on Rope 1, he has two possible moves: fall by one meter or move
    over to Rope 0\. Each costs 0 moves. That’s right: these moves are free!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bob jumps up as before, using Rope 0\. When he wants to fall, he moves to Rope
    1 (that costs him one move), falls down Rope 1 as much as he likes (that’s free),
    and then moves back to Rope 0 (that’s free, too). The whole fall, then, costs
    Bob just one move. Perfect—this is just as before! No one will know that we’re
    using two ropes instead of one.
  prefs: []
  type: TYPE_NORMAL
- en: Compare [Figure 5-5](ch05.xhtml#ch05fig05), with its mass of edges, to [Figure
    5-6](ch05.xhtml#ch05fig06), which depicts the two-ropes maneuver.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: A graph of Bob’s moves using two ropes*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s true that we’ve doubled the number of nodes, but that’s okay: what we
    care about for BFS is not the number of nodes but the number of edges. On that
    front, we’re laughing. We have, at most, two edges leaving each node: on Rope
    0, we have a jump edge and a move to Rope 1; on Rope 1, we have a fall edge and
    a move to Rope 0\. That is, for height *h*, we have about 4*h* edges. That’s linear!
    We’ve avoided that messy quadratic *h*² business.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve annotated each edge here with whether it costs a move (1) or doesn’t (0).
    This is our first example of a *weighted* graph, where each edge is given a weight
    or cost.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Positions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve meandered our way back to a two-dimensional board. (Hello, Knight Chase!)
    We need one dimension for Bob’s height and the second for the rope that Bob is
    on. The standard terminology for that second dimension is a *state*. When Bob
    is on Rope 0, we’ll say he’s in state 0, and when Bob is on Rope 1, we’ll say
    he’s in state 1\. Let’s use “state” from now on instead of “rope.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the new `typedef`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than start with `find_distances`, as we have been doing in this chapter,
    we’ll start with the `add_position` functions. Yes: functions, plural, because
    we’re going to encode each type of move as its own function. There are four types
    of moves: a jump up, a fall down, a move from State 0 to State 1, and a move from
    State 1 to State 0\. Hence we’ll need four `add_position` functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Jumping Up
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The code for following a jump edge is given in [Listing 5-10](ch05.xhtml#ch05ex010).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-10: Adding a position: jumping up*'
  prefs: []
  type: TYPE_NORMAL
- en: This function involves jumping up from `from_height` to `to_height`. This kind
    of move is allowed only in state 0; whenever we index `min_moves`, we’ll therefore
    use `0` as the second index.
  prefs: []
  type: TYPE_NORMAL
- en: The code is similar to [Listing 5-7](ch05.xhtml#ch05ex07), but with a few important
    changes. First, I’ve changed the name of `new_positions` to `pos` and `num_new_positions`
    to `num_pos`. We’ll talk about the reason for this change to more generic parameter
    names after we’ve gone through the four functions.
  prefs: []
  type: TYPE_NORMAL
- en: Second, to facilitate comparison between the four functions, I’ve added a `distance`
    variable ➊ that indicates the number of moves it takes to get to `to_height` by
    using `from_height`. Here, it’s one more move than the minimum number of moves
    to `from_height`, because we pay one move for this jump.
  prefs: []
  type: TYPE_NORMAL
- en: Third and finally, I’ve changed the part of the if condition that checks whether
    we’ve found a new position ➋. This is because a position might be discovered by
    an edge that counts as one move, but it could later be rediscovered by an edge
    that doesn’t count as a move. We want to allow for the possibility that the minimum
    number of moves is updated and improved by one of those no-cost edges. (Jumping
    up is not a no-cost edge, so we don’t need this change here; but I’ve kept it
    in for consistency across the four functions.)
  prefs: []
  type: TYPE_NORMAL
- en: Falling Down
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s now take a look at the code for falling down given in [Listing 5-11](ch05.xhtml#ch05ex011).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-11: Adding a position: falling down*'
  prefs: []
  type: TYPE_NORMAL
- en: Falling down can only happen in state 1; that’s why the second index is `1`
    whenever we access `min_moves`. Also, there’s nothing to do with itching powder
    here. Bob can fall as much as he likes in State 1 and not have to worry about
    the itching powder. Finally, a crucial point about the calculated distance is
    that there’s no `+ 1` added ➊!
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: this doesn’t count as a move.'
  prefs: []
  type: TYPE_NORMAL
- en: Switching States
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are two more functions to go. First we have the function to move from
    State 0 to State 1 in [Listing 5-12](ch05.xhtml#ch05ex012).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-12: Adding a position: moving from state 0 to state 1*'
  prefs: []
  type: TYPE_NORMAL
- en: Then we have the function to move from state 1 to state 0, shown in [Listing
    5-13](ch05.xhtml#ch05ex013).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-13: Adding a position: moving from state 1 to state 0*'
  prefs: []
  type: TYPE_NORMAL
- en: Moving from State 0 to State 1 costs one move, but moving from State 1 to State
    0 does not. Also notice we’re only allowed to move from State 1 to State 0 if
    there’s no itching powder at that height. Without that check, we’d be allowed
    to stop a fall on a segment of the rope with itching powder, and that would be
    breaking the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 0-1 BFS
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now it’s time to incorporate the state into the `find_distances` code from [Listing
    5-6](ch05.xhtml#ch05ex06). However, we had better be careful, lest we miscount
    the moves.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example. I’ll use (*h*, *s*) to refer to Bob being at height *h* in
    state *s*. Suppose that Bob can jump up by three. Bob starts at (0, 0), and it
    takes zero moves to get there. Exploring from (0, 0), we will identify (0, 1)
    as a new position, and record that it takes one move to get there. It’ll be added
    to the positions for the next round of BFS. We’ll also find (3, 0) and similarly
    record that it takes one move to get there. That’s another position for the next
    round of BFS. That’s all standard BFS fare.
  prefs: []
  type: TYPE_NORMAL
- en: When exploring out of (3, 0), we’ll find the new positions (3, 1) and (6, 0).
    Both will be added to the next round of BFS, and both will be reachable in a minimum
    of two moves.
  prefs: []
  type: TYPE_NORMAL
- en: However, we need to be careful with position (3, 1). We know that (2, 1) is
    reachable from here, so it’s tempting to add it to the next round of BFS. If we
    did that, though, then we wouldn’t be doing BFS anymore. We are supposed to put
    positions in the next round of the BFS when they are exactly one move away from
    those in the current round. Is (2, 1) one more move away from (3, 1)? No! They
    are the same number of moves from (0, 0), because falling in State 1 is free.
  prefs: []
  type: TYPE_NORMAL
- en: That is, (2, 1) doesn’t go in the next round of BFS. It goes in the *current*
    round of BFS, right along with (3, 1) and everything else whose minimum moves
    is two.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, whenever we move along an edge that costs us a move, we add the
    new position to the next round of BFS. That’s what we’ve always done. However,
    when we move along an edge that is free, then we add it to the current round of
    BFS so that it can be processed along with the other positions whose distance
    is the same. This is why we moved away from `new_positions` and `num_new_positions`
    in the `add_position` functions in “Adding Positions” on [page 182](ch05.xhtml#ch05lev1z).
    Two of the functions will indeed add moves to the new positions, but the other
    two will add moves to the current positions.
  prefs: []
  type: TYPE_NORMAL
- en: This variant of BFS is called *0-1 BFS*, because it works on graphs whose edges
    cost zero moves or one move.
  prefs: []
  type: TYPE_NORMAL
- en: At last, it’s time for the BFS. Check it out in [Listing 5-14](ch05.xhtml#ch05ex014).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-14: The minimum number of moves for Bob using 0-1 BFS*'
  prefs: []
  type: TYPE_NORMAL
- en: The new code checks whether the current position is in State 0 or State 1 ➊.
    In each case, there are two moves to consider. In State 0, the new positions (those
    for the next round of BFS) are used; in State 1, the current positions are used.
  prefs: []
  type: TYPE_NORMAL
- en: What about the `main` and `solve` functions? For `main`, we can use the same
    function from Solution 1\. For `solve`, we just need to add State 0 whenever we
    index `min_moves`. If you make those changes and submit to the judge, you’ll see
    that we pass all tests with plenty of time to spare.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 3: Book Translation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Knight Chase and Rope Climb problems, there was no explicit graph to
    read from the input; the BFS incrementally produced the graph as it explored.
    We’ll now see a problem where the graph is presented to us up front.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ecna16d`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You have written a new book in English, and you want to get the book translated
    into *n* other target languages. You’ve found *m* translators. Each translator
    knows how to translate between exactly two languages and will do the translation
    at a given cost. For example, a translator may know how to translate between Spanish
    and Bengali at a cost of $1,800; this means that you could ask this translator
    to translate from Spanish to Bengali for $1,800 or Bengali to Spanish for $1,800.
  prefs: []
  type: TYPE_NORMAL
- en: To reach a given target language may require multiple translations. For example,
    you may want to translate your book from English to Bengali but have no translator
    between these two languages. You might instead have to translate from English
    to Spanish and then Spanish to Bengali.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the number of translation errors, you will minimize the number of
    translations needed to reach each target language. If there are multiple ways
    to achieve a minimum number of translations to a target language, then you will
    choose the cheapest one. Your goal is to minimize the number of translations to
    each target language; if there are multiple ways to do this, choose the one with
    minimum total cost.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing two integers *n* and *m*. *n* is the number of target languages;
    *m* is the number of translators. There are at most 100 target languages and at
    most 4,500 translators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *n* strings, each naming a target language. `English` will
    not be a target language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*m* lines, each giving information for one translator. Each of these lines
    contains three space-separated tokens: a language, a second language, and the
    positive integer cost to translate between them. There is at most one translator
    per pair of languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the minimum monetary cost to translate the book into all of the target
    languages, while minimizing the number of translations to each target language.
    If there is no way to translate the book into all of the target languages, output
    `Impossible`.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 0.6 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reading the Language Names*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rather than use language names directly—English, Spanish, and so on—I’ll associate
    each language with an integer. English will be language 0, and each target language
    will be given a unique integer greater than 0\. We can then work with integers
    from here on out, as we did for the other problems in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one annoyance here: the problem description does not tell us the maximum
    length of a language name. We therefore cannot hardcode some maximum language
    name length like 16 or even 100, because we have no control over the input. We
    therefore use a `read_word` helper function; see [Listing 5-15](ch05.xhtml#ch05ex015).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-15: Reading a word*'
  prefs: []
  type: TYPE_NORMAL
- en: The `read_word` function takes an initial size that we hope suffices for most
    or all of the language names. When we call the function, we will give an initial
    size of 16, because that covers most language names we’re likely to see. We can
    use `read_word` to read characters ➊ up until the array reaches its maximum length;
    if the array fills up and the language name still isn’t over, it then uses `realloc`
    to double the array’s length ➋, thereby creating more space to read more characters.
    We’re careful to terminate `str` with a null character ➌; otherwise, it wouldn’t
    be a valid string!
  prefs: []
  type: TYPE_NORMAL
- en: '*Building the Graph*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s turn to building a graph from the input. This will help us explore
    the allowable translations from each language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s work with a small test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Can you construct the graph? What are the nodes and what are the edges? Is it
    undirected or directed? Is it unweighted or weighted?
  prefs: []
  type: TYPE_NORMAL
- en: As always, the edges encode the allowed moves; here, a move corresponds to a
    translation between two languages. The nodes, then, are the languages. An edge
    going from language *a* to language *b* means that there is a translator between
    these two languages. The translator can translate from *a* to *b* or vice versa—so
    the graph is undirected. It’s also weighted, because each edge (a translation)
    has a weight (the translation cost). The graph is shown in [Figure 5-7](ch05.xhtml#ch05fig07).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: A graph of translations*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The total translation cost for us to reach all of the target languages is $500
    for English to Spanish, plus $1,000 for English to Italian, plus $1,800 for Spanish
    to Bengali. That’s $3,300 in all. Don’t be taken in by that alluring $250 Spanish–Italian
    translation: using that would result in a distance of two from English to Italian,
    but remember that we need the minimum distances, even when that leads to spending
    more money. Indeed, the reason we’ll be able to use BFS here is precisely because
    we care first about the minimum number of edges for each target language, not
    its minimum cost overall. For the latter, we’d need more powerful tools, and these
    will be introduced in [Chapter 6](ch06.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: To store the graph, I’ll use what’s called an *adjacency list*. (Node *b* is
    said to be *adjacent* to Node *a* if there is an edge from *a* to *b*; that’s
    where the name “adjacency list” comes from.) This is just an array with one index
    per node, where each index stores a linked list of the edges involving that node.
    We use linked lists of edges, rather than arrays of edges, because we don’t know
    in advance the number of edges that involve a given node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the constants and `typedef`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: An `edge` has a `to_lang` and a `cost`—that makes sense. However, it doesn’t
    have a `from_lang`, and that’s because we’ll already know the `from_lang` based
    on which index of the adjacency list the edge is in.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml), when storing trees, we used a `struct node` rather
    than a `struct edge`. The reason for the node-centric focus in [Chapter 2](ch02.xhtml)
    is that the nodes are the entities associated with information, such as candy
    values and numbers of descendants. In the present problem, we have an edge-centric
    focus, with the `struct edge`, because it’s the edges (not the nodes) that are
    associated with information (the translation costs).
  prefs: []
  type: TYPE_NORMAL
- en: It’s easiest to add to a linked list at its beginning. One side effect of this
    choice is that the edges for a node end up in the linked list in the opposite
    order in which we read them. For example, if we read an edge from Node 1 to Node
    2 and then read an edge from Node 1 to Node 3, then in our linked list we will
    find that the edge to Node 3 shows up *before* the edge to Node 2\. Don’t let
    this catch you off guard when tracing through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to see how the graph is built. It’s in the `main` function given
    in [Listing 5-16](ch05.xhtml#ch05ex016).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-16: The* main *function for building the graph*'
  prefs: []
  type: TYPE_NORMAL
- en: The `lang_names` array maps integers (the array indices) to language names.
    We give `English` the number 0, as promised ➊. We then map each integer 1, 2,
    . . . , to language names as we read them ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the graph is undirected: if we add an edge from *a* to *b*, then
    we had better add the edge from *b* to *a*, too. As such, for each translator,
    we add two edges to the graph: one from `from_index` to `to_index` ➌ and one from
    `to_index` to `from_index` ➍. Those `from_index` and `to_index` indices are produced
    by `find_lang`, which searches for a language name; see [Listing 5-17](ch05.xhtml#ch05ex017).'
  prefs: []
  type: TYPE_NORMAL
- en: In the calls to the helper functions at the bottom, we use `num_targets + 1`
    rather than `num_targets` because `num_targets` gives the number of target languages;
    the `+ 1` lets us include English in the count of total languages being processed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-17: Finding a language*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BFS*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code for `add_position` in [Listing 5-18](ch05.xhtml#ch05ex018) is similar
    to the other `add_position` functions we’ve studied earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-18: Adding a position*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready for the BFS itself; see [Listing 5-19](ch05.xhtml#ch05ex019).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-19: Minimum cost of translations using BFS*'
  prefs: []
  type: TYPE_NORMAL
- en: For each language, we’ll use `min_costs` to store the minimum-cost edge that
    could have been used to discover that language. Referring back to [Figure 5-7](ch05.xhtml#ch05fig07),
    we’d store 500 for Spanish, 1,000 for Italian, and 1,800 for Bengali. In a different
    function, described soon, we’ll add up all of these numbers to get the total cost
    for all of the translations.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum number of moves is of interest only to this function, not the outside
    world, so we declare it as a local variable ➊. All the outside world cares about
    is `min_costs`.
  prefs: []
  type: TYPE_NORMAL
- en: Trying each possible move amounts to traversing the linked list of edges for
    the current node ➋. That gives us all of the `new_positions`. Now we know which
    languages are discovered in the next round of the BFS, but we don’t yet know the
    cost of adding each of those languages. The thing is, there could be multiple
    edges from `cur_positions` that reach the same node in `new_positions`. Consult
    [Figure 5-7](ch05.xhtml#ch05fig07) again. Bengali takes two translations, so it’s
    discovered in round 2 of the BFS—but the edge we need is the one from Spanish,
    not the one from Italian.
  prefs: []
  type: TYPE_NORMAL
- en: We therefore have a new `for` loop ➌, one whose role we haven’t seen yet in
    this chapter. The variable `added_lang` tracks each of the new positions (that
    is, the positions for the next round of BFS). We find the cheapest edge between
    `added_lang` and any node discovered in the current round of BFS. Each such language
    will have a distance of one less than `added_lang`, which explains the first condition
    in the `if` statement ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Total Cost*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we’ve got the costs stored, all we do is add them up to get the total cost
    of translating to all target languages. The code is given in [Listing 5-20](ch05.xhtml#ch05ex020).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-20: The minimum total cost*'
  prefs: []
  type: TYPE_NORMAL
- en: The task is impossible if any of the target languages is not reachable ➊. Otherwise,
    we print the total cost that we accumulated ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re ready to submit to the judge. Sabasa!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We wrote gobs of code in this chapter. Of course, I hope that the code offers
    you a starting point for solving your own graph problems. In the long term, though,
    what I hope you remember is the importance of modeling as an early step in the
    problem-solving process. Couching a problem in terms of BFS collapses the domains
    of knights and ropes and translations into the single domain of graphs. Searching
    Google for “how to climb a rope” will get you nowhere (except perhaps up a real
    rope). Searching for “breadth-first search” will instead offer as many code samples
    and explanations and examples as you’re willing to read. If you read comments
    left by programmers on the judges’ websites, you’ll see that they communicate
    on the level of algorithms, not on the level of problem-specific aspects. Often,
    they’ll just say “BFS Problem” to get their point across. You’re learning this
    language of modeling and how to go from the model to working code. There’s more
    graph-modeling coming up in the next chapter, where we tackle weighted graphs
    in their full generality.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Knight Chase is originally from the 1999 Canadian Computing Competition. Rope
    Climb is originally from the 2018 Woburn Challenge, Online Round 1, Senior Division.
    Book Translation is originally from the 2016 East Central North America Regional
    Programming Contest.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a trick that we can use to cut down the code we have to write when
    considering multiple, similar moves in a BFS. Feel free to check out how that
    works in “Knight Chase: Encoding Moves” in [Appendix B](app02.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned all about BFS in this chapter, but if you continue with graph algorithms
    you might like to study *depth-first search* (DFS) as well. I recommend *Algorithms
    Illuminated (Part 2): Graph Algorithms and Data Structures* by Tim Roughgarden
    (2018) for more on BFS, DFS, and other graph algorithms.'
  prefs: []
  type: TYPE_NORMAL
