- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: GRAPHS AND BREADTH-FIRST SEARCH
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图形与广度优先搜索
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common1.jpg)'
- en: In this chapter, we’ll study three problems in which we’re asked to solve puzzles
    in the minimum number of moves. How quickly can a knight catch a pawn? How quickly
    can a student climb a rope in gym class? How cheaply can we translate a book written
    in one language to other target languages? Breadth-first search (BFS) is the unifying
    algorithm here. BFS dispatches these problems, and it applies more generally whenever
    we want to solve a puzzle with the minimum number of moves. Along the way, we’ll
    learn about graphs, a powerful way to model and solve problems that involve objects
    and connections between those objects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究三种问题，要求我们用最少的步数解决谜题。骑士多快能追上兵？学生在体育课上爬绳子多快？我们能以多低的成本将一本书从一种语言翻译成其他目标语言？广度优先搜索（BFS）是解决这些问题的统一算法。BFS解决了这些问题，并且更广泛地应用于我们想要以最少步数解决谜题的场景。在此过程中，我们将学习图形，这是建模和解决涉及物体及物体间连接问题的强大工具。
- en: 'Problem 1: Knight Chase'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题1：骑士追击
- en: This is DMOJ problem `ccc99s4`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`ccc99s4`。
- en: '*The Problem*'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题描述*'
- en: 'This problem concerns two players, a pawn and a knight, playing a board game.
    (Don’t worry: you don’t need to know anything about chess.)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题涉及两个玩家，一个是兵，一个是骑士，在棋盘上进行对弈。（别担心：你不需要了解任何关于国际象棋的知识。）
- en: The board has *r* rows, with row 1 at the bottom and row *r* at the top. The
    board has *c* columns, with column 1 at the left and column *c* at the right.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘有*r*行，第一行在底部，*r*行在顶部。棋盘有*c*列，第一列在左侧，*c*列在右侧。
- en: 'The pawn and knight each start on their own square of the board. The pawn moves
    first, then the knight moves, then the pawn, then the knight, and so on, until
    the game ends. For each turn, a move must be made: remaining at the current square
    is not an option.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 兵和骑士各自从棋盘上的一个方格开始。兵先移动，然后骑士移动，然后是兵，再是骑士，依此类推，直到游戏结束。每轮必须进行移动：不能停留在当前方格。
- en: 'The pawn has no choice on what move to make: for each of its turns, it moves
    up one square.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 兵无法选择要怎么移动：每轮它都会向上一格移动。
- en: 'The knight, by contrast, has up to eight choices for each move:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，骑士每次移动都有最多八个选择：
- en: Up 1, right 2
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上 1，向右 2
- en: Up 1, left 2
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上 1，向左 2
- en: Down 1, right 2
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下 1，向右 2
- en: Down 1, left 2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下 1，向左 2
- en: Up 2, right 1
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上 2，向右 1
- en: Up 2, left 1
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上 2，向左 1
- en: Down 2, right 1
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下 2，向右 1
- en: Down 2, left 1
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下 2，向左 1
- en: I say “up to eight choices,” not “exactly eight choices,” because moves that
    bring the knight outside of the board are not allowed. For example, if the board
    has 10 columns and the knight is in column 9, then no move that takes the knight
    two columns to the right is allowed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我说“最多八个选择”，而不是“恰好八个选择”，因为任何让骑士超出棋盘的移动都是不允许的。例如，如果棋盘有10列，骑士在第9列，那么任何让骑士向右移动两列的行为都是不允许的。
- en: 'The following diagram shows the knight’s available moves:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了骑士的可用移动：
- en: '|   |   |   |   |   |   |   |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |'
- en: '|  |  | f |  | e |  |  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  |  | f |  | e |  |  |'
- en: '|  | b |  |  |  | a |  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  | b |  |  |  | a |  |'
- en: '|  |  |  | K |  |  |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | K |  |  |  |'
- en: '|  | d |  |  |  | c |  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  | d |  |  |  | c |  |'
- en: '|  |  | h |  | 9 |  |  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |  | h |  | 9 |  |  |'
- en: '|   |   |   |   |   |   |   |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |'
- en: Here, the knight is represented as `K`, and each letter from `a` to `h` represents
    one of its possible moves.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，骑士用`K`表示，从`a`到`h`的每个字母代表其可能的移动。
- en: 'The game ends when one of three things happens: the knight wins, the game is
    a stalemate (that is, a tie), or the knight loses.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束时会发生以下三种情况：骑士获胜，游戏和棋（即平局），或骑士失败。
- en: '**Win**   The knight wins if the knight makes a move and lands on the same
    square as the pawn before the pawn reaches the top row. To win, the knight has
    to be the one to make the move; if the pawn makes a move and lands on the knight,
    this doesn’t count as the knight winning.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**胜利** 如果骑士移动并停在与兵相同的方格上，而兵还未到达顶排，骑士就获胜。为了获胜，必须是骑士做出这个移动；如果是兵移动并停在骑士上，这不算骑士获胜。'
- en: '**Stalemate**   The game is a stalemate if the knight makes a move and lands
    on the square above the pawn before the pawn reaches the top row. Again, the knight
    has to be the one to make this move; the only exception is that the game can start
    as a stalemate if the knight starts one square above the pawn.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**和棋** 游戏是和棋如果骑士移动并停在兵前方的方格上，而兵还没有到达顶排。同样，必须是骑士做出这个移动；唯一的例外是，如果骑士从兵上方一格开始，游戏可以一开始就为和棋。'
- en: '**Loss**   The knight loses if the pawn reaches the top row before the game
    otherwise ends. That is, if the pawn gets to the top row before the knight lands
    on the pawn or lands on the square above it, then the knight loses. Once the pawn
    reaches the top row, the knight is not allowed to move anymore.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to determine the best-case outcome for the knight and the number
    of knight moves required to produce that outcome.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first line of input gives the number of test cases that will follow. Each
    test case consists of six lines:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The number of rows in the board, between 3 and 99
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of columns in the board, between 2 and 99
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The starting row of the pawn
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The starting column of the pawn
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The starting row of the knight
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The starting column of the knight
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s guaranteed that the pawn and knight will have different starting positions
    and that the knight starts at a position where it has at least one available move.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Output
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For each test case, output a line with one of three messages:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: If the knight can win, output `Win in *m* knight move(s).`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the knight cannot win but can cause a stalemate, output `Stalemate in *m*
    knight move(s).`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the knight cannot win or cause a stalemate, output `Loss in *m* knight move(s).`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, m is the minimum number of moves made by the knight.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test cases is one second.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '*Moving Optimally*'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A true two-player game, such as tic-tac-toe or chess, gives each player a choice
    of what move to make next. However, here, only the knight has a choice. The pawn’s
    moves are all fixed, and we’ll know exactly where the pawn is at all times. It’s
    a good thing, too, because this problem would be significantly more difficult
    if both players had choices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: There may be various ways for the knight to win or cause a stalemate. Suppose
    that the knight can win. Each way that the knight can win requires some number
    of moves; we want to identify the minimum number of moves.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Board
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s explore a little through this input:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The board for this test case has seven rows and seven columns. The pawn starts
    at row 1, column 1, and the knight starts at row 4, column 6.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving optimally, the knight can win here in three moves. The following diagram
    shows how the knight can do this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  |  |  |  |  |  |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| **6** |  | K2 |  |  |  |  |  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| **5** |  |  |  | K1 |  |  |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| **4** | K3 P3 |  |  |  |  | K |  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| **3** | P2 |  |  |  |  |  |  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| **2** | P1 |  |  |  |  |  |  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| **1** | P |  |  |  |  |  |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: Here, `K` is used for the knight’s starting position and `P` for the pawn’s
    starting position. `K1`, `K2`, and `K3` give the location of the knight after
    move 1, move 2, and move 3, respectively; `P1`, `P2`, and `P3` do likewise for
    the pawn.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates (*x*, *y*) refer to row *x*, column *y*. As expected, the pawn
    simply marches up its column, from (1, 1), to (2, 1), to (3, 1), and finally to
    (4, 1). The knight, however, moves as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Starting at (4, 6), it moves up one and left two to (5, 4). The pawn is at (2,
    1).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From (5, 4), it moves up one and left two to (6, 2). The pawn is at (3, 1).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From (6, 2), it moves down two and left one to (4, 1). That’s where the pawn
    is!
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are other ways for the knight to win. For example, here’s what can happen
    if the knight goofs off a little:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  |  |  |  |  |  |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| **6** |  | K2 |  |  |  |  |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| **5** | K4 P4 |  |  | K1 |  |  |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| **4** | P3 |  | K3 |  |  | K |  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| **3** | P2 |  |  |  |  |  |  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| **2** | P1 |  |  |  |  |  |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| **1** | P |  |  |  |  |  |  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: The knight catches the pawn after four moves, not three. Though the knight still
    wins, this is *not* the fastest way that it can do so. We need to report a minimum
    of three moves here, not four.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we had an algorithm to determine the minimum number of moves that
    the knight can take from its starting point to some destination. We could then
    determine the number of knight moves required to get to each pawn location; if
    the knight can get there at the same time as the pawn, then the knight wins. If
    the knight cannot win, then we could do similarly for stalemates. That is, we
    could determine the number of knight moves required to get to the square above
    each pawn location; if at any point the knight can land on the square above the
    pawn, we have a stalemate.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'To design such an algorithm, we can explore the board from the knight’s starting
    point. There’s only one square on the board that is reachable in zero moves: the
    knight’s starting point itself. From there, we can discover those squares that
    are reachable in one move. From those squares that are one move away, we can discover
    those squares that are reachable in two moves. We can use those squares reachable
    in two moves to find those reachable in three moves, and so on. We stop when we
    find the desired destination; at that point, we’ll know the minimum number of
    moves that it takes to get there.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate this procedure using the same test case as before: seven
    rows and seven columns, with the knight starting at (4, 6). (We’ll ignore the
    pawn for now.) To confirm our answer of three moves that we arrived at by hand,
    we’ll calculate the minimum number of moves for the knight to get from (4, 6)
    to (4, 1).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagrams, numbers in the squares indicate the minimum distance
    from the knight’s starting point. As mentioned above, the only square reachable
    in zero moves is the knight’s starting point itself, (4, 6). We’ll call this round
    0 of the exploration:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  |  |  |  |  |  |  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| **6** |  |  |  |  |  |  |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| **5** |  |  |  |  |  |  |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| **4** |  |  |  |  |  | 0 |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| **3** |  |  |  |  |  |  |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| **2** |  |  |  |  |  |  |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| **1** |  |  |  |  |  |  |  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: 'From (4, 6), we try all eight possible moves to identify the squares reachable
    in one move. We can’t move up one and right two or down one and right two, because
    those would take us beyond the right edge of the board. That leaves six squares
    that are one move away. This is round 1:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  |  |  |  |  |  |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| **6** |  |  |  |  | 1 |  | 1 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| **5** |  |  |  | 1 |  |  |  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| **4** |  |  |  |  |  | 0 |  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| **3** |  |  |  | 1 |  |  |  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| **2** |  |  |  |  | 1 |  | 1 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| **1** |  |  |  |  |  |  |  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: 'We haven’t found (4, 1) yet, so we keep going. We explore from each of those
    six new squares that we discovered in round 1; that will yield the squares that
    are two moves away. For example, consider square (6, 5); the squares reachable
    from there are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Up 1, right 2: (7, 7)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Up 1, left 2: (7, 3)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Down 1, right 2: (5, 7)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Down 1, left 2: (5, 3)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Up 2, right 1: (which is not valid)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Up 2, left 1: (which is not valid)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Down 2, right 1: (4, 6)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Down 2, left 1: (4, 4)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These squares are two moves away from the starting point—except for (4, 6),
    whose value (0) we filled in before! Looking at all valid moves from all squares
    that are one move away brings us to round 2, the squares that are two moves away.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  |  | 2 |  | 2 |  | 2 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| **6** |  | 2 |  |  | 1 | 2 | 1 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| **5** |  |  | 2 | 1 | 2 |  | 2 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| **4** |  | 2 |  | 2 |  | 0 |  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| **3** |  |  | 2 | 1 | 2 |  | 2 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| **2** |  | 2 |  |  | 1 | 2 | 1 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| **1** |  |  | 2 |  | 2 |  | 2 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: Notice that there cannot be any other squares that are two moves away. Every
    square that is two moves away must emanate from a square that is one move away,
    and we explored all possible moves from all possible squares that are one move
    away.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still no (4, 1), so we keep going. Exploring from all squares that
    are two moves away gives us round 3, the squares that are three moves away:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '| **7** |  | 3 | 2 | 3 | 2 | 3 | 2 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| **6** | 3 | 2 | 3 |  | 1 | 2 | 1 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| **5** |  | 3 | 2 | 1 | 2 | 3 | 2 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| **4** | 3 | 2 | 3 | 2 | 3 | 0 | 3 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| **3** |  | 3 | 2 | 1 | 2 | 3 | 2 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| **2** | 3 | 2 | 3 |  | 1 | 2 | 1 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| **1** |  | 3 | 2 | 3 | 2 | 3 | 2 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: 'There we have it: square (4, 1) is filled in with a value of 3\. It therefore
    takes a minimum of three moves to get from (4, 6) to (4, 1). Had we not found
    (4, 1) here, we’d continue: we could proceed to find squares that are four moves
    away, then five moves away, and so on.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: This technique—finding all squares that are zero moves away, then one move away,
    then two moves away, and so on—is called *breadth-first search*, or BFS for short.
    The word *breadth* refers to a full range. BFS is so named because we explore
    the full range of what is reachable from each square before moving on to other
    squares. BFS is fast, memory efficient, and clean to implement. It’s an absolute
    power move to invoke BFS whenever you want the minimum distance from one location
    to another location. Let’s go for it!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术——首先找到所有与目标零步之遥的格子，然后是一步之遥、两步之遥，依此类推——称为*广度优先搜索*，简称BFS。*广度*指的是完整的范围。BFS之所以这样命名，是因为我们从每个格子开始，首先探索所有可达的格子，再继续向其他格子扩展。BFS非常快速，内存高效，而且实现起来很简洁。每当你想要找出从一个位置到另一个位置的最短距离时，调用BFS绝对是个强力的选择。让我们开始吧！
- en: Implementing Breadth-First Search
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现广度优先搜索
- en: 'Let’s start with a couple of type definitions that clean up our code a little.
    First, each board position is composed of a row and a column, so let’s package
    those together using a struct:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义几个类型，以便稍微清理一下代码。每个棋盘位置由一行和一列组成，因此我们将这两个元素使用结构体打包在一起：
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A board is a two-dimensional array, and we can make a type definition for that
    too. We’ll let it hold integers, which will correspond to numbers of moves. We
    have a maximum of 99 rows and 99 columns, but we allocate one extra row and column
    so we can start indexing rows and columns at `1`, not `0`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘是一个二维数组，我们也可以为它定义一个类型。我们将让它保存整数，这些整数表示移动次数。棋盘最多有99行和99列，但我们额外分配了一行和一列，这样我们就可以从`1`开始索引行和列，而不是从`0`：
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, let’s make an array type for holding the positions that we discover
    during the BFS. We’ll make it big enough that it can hold every possible square
    on the board:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为保存BFS过程中发现的位置创建一个数组类型。我们将使它足够大，以便能够容纳棋盘上所有可能的格子：
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we’re ready for the BFS itself. We need a function to determine the minimum
    number of knight moves to get from its starting point to some destination that
    we specify. (Recall that our plan is to find the minimum number of moves needed
    to catch the pawn at each pawn location.) Here’s the signature for the function
    we’ll implement:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始广度优先搜索（BFS）了。我们需要一个函数来确定骑士从起始点到指定目标的最小移动次数。（回想一下我们的计划是找到每个棋子位置所需的最小移动次数。）这是我们将要实现的函数的签名：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The parameters `knight_row` and `knight_col` give the starting location of the
    knight, and `dest_row` and `dest_col` give the desired destination. The parameters
    `num_rows` and `num_cols` give, respectively, the number of rows and columns in
    the board; we’ll need those to determine whether a move is valid. The function
    returns the minimum number of moves for the knight to go from its starting location
    to the destination. If there’s no way for the knight to get to the destination,
    then we return `-1`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`knight_row`和`knight_col`给出了骑士的起始位置，`dest_row`和`dest_col`给出了目标位置。参数`num_rows`和`num_cols`分别给出了棋盘的行数和列数；我们需要这些来判断一个移动是否有效。该函数返回骑士从起始位置到目标位置的最小移动次数。如果骑士无法到达目标位置，则返回`-1`。
- en: 'There are two key arrays that drive the BFS:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个关键数组驱动BFS：
- en: cur_positions   This array holds the positions discovered from the current round
    of BFS. For example, it might be all of the positions discovered in round 3.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: cur_positions   这个数组保存了当前轮BFS中发现的位置。例如，它可能保存的是第3轮发现的所有位置。
- en: new_positions   This array holds the positions discovered in the next round
    of BFS. For example, if `cur_positions` holds the positions discovered in round
    3, then `new_positions` will hold those positions discovered in round 4.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: new_positions   这个数组保存了在下一轮广度优先搜索（BFS）中发现的位置。例如，如果`cur_positions`保存的是第3轮发现的位置，那么`new_positions`将保存第4轮发现的位置。
- en: The code is given in [Listing 5-1](ch05.xhtml#ch05ex01).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 代码见[清单 5-1](ch05.xhtml#ch05ex01)。
- en: '[PRE5]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-1: The minimum number of knight moves using BFS*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-1：使用BFS计算骑士最小移动次数*'
- en: The first thing we do is clear out the `min_moves` array by setting all values
    to `-1`; this means that we have not yet computed the number of moves. The only
    square for which we know the minimum number of moves is the knight’s starting
    square, so we initialize that to `0` ➊. That starting square is also the square
    that jump-starts the BFS ➋. The `while` loop then runs as long as the most-recent
    round of BFS has discovered at least one new square ➌. Inside the `while` loop,
    we look at each such square. If we discover the destination square ➍, then we
    return its minimum number of moves. Otherwise, we keep exploring.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一件事是清空`min_moves`数组，将所有值设置为`-1`；这意味着我们还没有计算出移动次数。唯一我们知道最小移动次数的方格是骑士的起始方格，因此我们将其初始化为`0`
    ➊。这个起始方格也是启动BFS的方格 ➋。然后，`while`循环会继续执行，只要最近一轮BFS发现至少一个新方格 ➌。在`while`循环中，我们检查每个这样的方格。如果我们发现了目标方格
    ➍，我们就返回它的最小移动次数。否则，我们继续探索。
- en: 'Exploring all eight moves from a given square is accomplished by eight calls
    to a helper function called `add_position`, which adds new squares to `new_positions`
    and updates `num_new_positions` accordingly. Focus on the first four arguments:
    those give the current row and column and the new row and column resulting from
    one of the eight moves. For example, the first call ➎ is for the move that goes
    up two and right one. We’ll look at the code for `add_position` shortly.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定的方格探索所有八个移动是通过八次调用一个名为`add_position`的辅助函数来完成的，该函数将新的方格添加到`new_positions`并相应地更新`num_new_positions`。重点是前四个参数：它们提供当前的行和列，以及通过其中一个八个移动得出的新行和新列。例如，第一个调用
    ➎ 是向上移动两步并向右移动一步。我们稍后会查看`add_position`的代码。
- en: We’ve gone through each square in `cur_positions` and found new squares that
    are one more move away. That completes one round of BFS. To prepare for the next
    round, we keep track of the number of new squares ➏ and copy all of the new squares
    from `new_positions` to `cur_positions`. That way, the next iteration of the `while`
    loop uses those new squares and finds further new squares from there.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遍历了`cur_positions`中的每个方格，并找到了距离一个移动距离的新方格。这完成了BFS的一个回合。为了准备下一轮，我们跟踪新方格的数量
    ➏ 并将所有新方格从`new_positions`复制到`cur_positions`。这样，`while`循环的下一次迭代将使用这些新方格，并从这些方格中找到进一步的新方格。
- en: If we reach the bottom of the code and haven’t found the destination square,
    then we return `-1`—that destination square is not reachable from the knight’s
    starting location.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行到代码末尾，仍然没有找到目标方格，那么我们返回`-1`——目标方格无法从骑士的起始位置到达。
- en: Now for that `add_position` helper function; see [Listing 5-2](ch05.xhtml#ch05ex02).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看一下那个`add_position`辅助函数；请参见[清单 5-2](ch05.xhtml#ch05ex02)。
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-2: Adding a position*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：添加位置*'
- en: 'The `if` statement has five conditions, all of which must be true for `to_row`
    and `to_col` to be a valid position: the row must be at least one, the column
    must be at least one, the row must be at most the number of rows, the column must
    be at most the number of columns, and . . . hmm, that last one, `min_moves[to_row][to_col]
    == -1`, what’s that doing?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句有五个条件，只有当所有条件都为真时，`to_row`和`to_col`才是一个有效的位置：行必须至少为1，列必须至少为1，行不能超过行数，列不能超过列数，最后一个条件是`min_moves[to_row][to_col]
    == -1`，这是什么意思呢？'
- en: That final condition is there to determine whether we’ve already seen this square.
    If we haven’t, then it will have a value of `-1` and we can go ahead and set its
    number of moves now. If it already has some other value, then it must have been
    discovered in an *earlier* round of BFS, and therefore it already has a smaller
    number of moves than what we could give it now. That is, a value other than `-1`
    means that the minimum number of moves is already set, and we shouldn’t mess with
    it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最终条件是用来判断我们是否已经遇到过这个方格。如果没有遇到过，那么它的值将为`-1`，我们可以立即为它设置移动次数。如果它已经有其他值，那么它一定是在BFS的*早期*回合中被发现的，因此它已经有了一个比现在能给它的值更小的移动次数。也就是说，任何非`-1`的值都意味着最小的移动次数已经设置好，我们不应更改它。
- en: If all five conditions pass, then we’ve discovered a new square. We discovered
    (`from_row`, `from_col`) in the previous round of BFS and `(to_row`, `to_col`)
    in the current round. Therefore, the minimum number of moves to (`to_row`, `to_col`)
    is one more than the minimum moves to (`from_row`, `from_col`) ➊. By virtue of
    (`from_row`, `from_col`) coming from the previous round of BFS, we already have
    its value stored in `min_moves`, and so we can simply look up its value without
    recalculating it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'You may see shades of memoization and dynamic programming here. It’s true:
    BFS uses the same trick of looking stuff up rather than recomputing it. However,
    there’s not really a notion of maximizing or minimizing a solution based on subproblem
    solutions or combining smaller solutions to form a larger solution. Algorithm
    developers therefore generally don’t refer to BFS as a dynamic-programming algorithm,
    instead classifying it as a search or exploration algorithm.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '*Best Knight Outcome*'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve got BFS bottled up nicely as the `find_distance` function. Now let’s
    count the number of moves as the pawn marches up its column and use `find_distance`
    to determine whether the knight can ever land on the pawn. For example, if the
    pawn takes three moves to get somewhere, and the knight can take exactly three
    moves to get there too, then the knight wins in three moves. If the knight can’t
    win, then we can try a similar technique for stalemates: let the pawn march up
    its column again, this time checking whether the knight can cause a stalemate.
    If no stalemates are possible, well, then the knight loses. I’ve got this logic
    coded up in [Listing 5-3](ch05.xhtml#ch05ex03). The function `solve` takes six
    parameters: the starting row and column of the pawn, the starting row and column
    of the knight, and the numbers of rows and columns in the board. It prints one
    line of output corresponding to whether the knight wins, stalemates, or loses.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-3: The best outcome for the knight (bugged!)*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get a grip on this code by studying it in three chunks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The first chunk is the code that checks whether the knight can win. We begin
    by saving the pawn’s row in a new variable ➊—we’ll mess with the pawn’s row to
    move the pawn up the board, so we need to remember the row in which it originally
    started. The `while` loop keeps going as long as the pawn hasn’t reached the top
    row. On each iteration, we calculate the number of moves that the knight needs
    to get to the same location as the pawn. If the knight can get there at the same
    time as the pawn ➋, then the knight can win. If the knight can’t win, then the
    pawn will reach the top of the board and we’ll continue below the `while` loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: That’s where the second chunk of code begins ➌. Its task is to determine whether
    the knight can cause a stalemate. The code is the same as the first chunk, except
    that in the `while` loop it checks the number of moves required for the knight
    to land on the row above the pawn rather than the row of the pawn.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是第二段代码开始的地方 ➌。它的任务是判断骑士是否能造成和棋。该段代码与第一段相同，只是在`while`循环中检查骑士到达兵上方行的位置所需的步数，而不是兵的行位置。
- en: The third chunk is a single line ➍, and it only executes if the knight cannot
    win or stalemate. This chunk simply outputs the loss message.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第三段是一个单独的代码行 ➍，只有在骑士无法获胜或和棋时才会执行。这段代码只是输出失败信息。
- en: That’s how we process a single test case. To read and process all of the test
    cases, we need a little `main` function; it’s as simple as [Listing 5-4](ch05.xhtml#ch05ex04).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们处理单个测试用例的方式。为了读取和处理所有测试用例，我们需要一个简单的`main`函数；它和[列表 5-4](ch05.xhtml#ch05ex04)一样简单。
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-4: The* main *function*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4：* 主 *函数*'
- en: Feeling good? We’ve now got a complete solution. We’re using BFS to optimize
    the number of moves taken by the knight. We’re checking for knight wins, stalemates,
    and losses. Now submit this solution to the judge. Are you still feeling good?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 感觉不错吧？我们现在有了完整的解决方案。我们使用广度优先搜索（BFS）来优化骑士所需的移动次数。我们在检查骑士的胜利、和棋和失败情况。现在把这个解决方案提交给评审。你还感觉不错吗？
- en: '*The Knight Flip-Flop*'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*骑士反转*'
- en: 'In earlier chapters, I hit you with some solutions that were correct but too
    slow to pass the test cases. In contrast, what I’ve provided here for the Knight
    Chase problem is *incorrect*: there are test cases for which we produce the wrong
    output. Our code happens to be unnecessarily slow, too.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我曾给你提供一些正确但速度太慢的解决方案，无法通过测试用例。相反，我在这里为骑士追逐问题提供的解法是*错误的*：有些测试用例会输出错误结果。我们的代码也恰好过于缓慢。
- en: Let’s fix it all!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来修复这个问题！
- en: Making Our Code Correct
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使我们的代码正确
- en: Our code is incorrect because it does not consider that the knight can sometimes
    be too fast! That is, it can get to a pawn’s location before the pawn gets there.
    Testing for exactly the same number of pawn and knight moves is therefore too
    stringent.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码是错误的，因为它没有考虑到骑士有时会太快！也就是说，骑士可以在兵到达之前就到达兵的位置。因此，要求骑士和兵的移动次数完全相同的测试是过于严格的。
- en: 'A test case will clear this up:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试用例可以澄清这一点：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a board with five rows and three columns; the pawn starts at row 1,
    column 1 and the knight starts at row 3, column 1\. Here’s what our current code
    outputs for this test case:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个五行三列的棋盘；兵从第1行第1列开始，骑士从第3行第1列开始。以下是我们当前代码对此测试用例的输出：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: (The output is `3`, not `4`, because the knight is not allowed to move once
    the pawn reaches the top row.) This means that there is no win or stalemate location
    for which the minimum number of knight moves is the same as the number of pawn
    moves. That, at least, is true. However, it’s still possible for the knight to
    win here and to do so in two moves. Take some time to try to identify how the
    knight can do this!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: （输出是`3`，而不是`4`，因为当兵到达顶行时，骑士不允许再移动。）这意味着不存在一个胜利或和棋位置，在该位置骑士的最少移动次数与兵的移动次数相同。至少这是事实。不过，骑士仍然可以在这里获胜，并且可以在两步内做到这一点。花点时间尝试找出骑士如何做到这一点吧！
- en: 'There’s no way for the knight to win in one move if the pawn is at (2, 1).
    However, after two moves, the pawn is at (3, 1), and it’s possible for the knight
    to land on (3, 1) after two moves, too. Here’s what the knight can do:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果兵在（2, 1）的位置，骑士不可能在一步内获胜。然而，经过两步之后，兵会到达（3, 1），此时骑士也有可能在两步后到达（3, 1）。以下是骑士可以采取的动作：
- en: 'Move 1: go from (3, 1) to (5, 2).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1步：从（3, 1）到（5, 2）。
- en: 'Move 2: go from (5, 2) back to (3, 1).'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2步：从（5, 2）回到（3, 1）。
- en: The minimum number of moves for the knight to get to (3, 1) is zero— it’s the
    knight’s starting point, after all. By going to some other square and returning,
    the knight can land on (3, 1) not only after zero moves but after two moves as
    well.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 骑士到达（3, 1）的最少步数是零——毕竟这是骑士的起始位置。通过先去其他地方再返回，骑士不仅可以在零步内到达（3, 1），也可以在两步内到达。
- en: 'Here’s a self-check: change the knight’s starting point from (3, 1) to (5,
    3). Can you figure out how the knight can win now in three moves?'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自检：将骑士的起始位置从（3, 1）改为（5, 3）。你能弄明白骑士如何在三步内获胜吗？
- en: Generalizing, we can say that if the knight can get to a square in a minimum
    of *m* moves, then it can also get to that square in *m* + 2 moves, or *m* + 4
    moves, and so on. All it has to do is keep going to some other square and returning.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 概括来说，我们可以说，如果骑士能够在最少的*m*步内到达某个方格，那么它也可以在*m* + 2步、*m* + 4步等步数内到达该方格。它所要做的只是不断去其他方格再返回。
- en: 'What this means for our solution is that, at each step, there are two ways
    for the knight to win or stalemate: it can do so because its minimum number of
    moves matches the number of pawn moves or because its minimum number of moves
    is an even number larger than the number of pawn moves.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们的解决方案意味着，在每一步，骑士有两种方式可以获胜或和棋：一种是因为它的最少步数与兵的步数相同，另一种是因为它的最少步数是一个大于兵步数的偶数。
- en: 'That is, instead of:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，之前是：
- en: '[PRE11]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'we need this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是：
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we’re testing whether the difference between the number of pawn moves
    and the number of knight moves is a multiple of two.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在测试的是，兵的移动次数与骑士的移动次数之间的差是否是二的倍数。
- en: There are two instances of the incorrect code in [Listing 5-3](ch05.xhtml#ch05ex03);
    changing both yields the (correct!) code in [Listing 5-5](ch05.xhtml#ch05ex05).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-3](ch05.xhtml#ch05ex03)中有两个不正确的代码实例；更改这两个后，得到[列表 5-5](ch05.xhtml#ch05ex05)中的（正确的！）代码。'
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 5-5: The best outcome for the knight*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：骑士的最佳结果*'
- en: As promised, all we’ve done is change two conditions ➊ ➋. Now the code passes
    the judge.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，我们所做的只是更改了两个条件 ➊ ➋。现在代码通过了判定。
- en: A Correctness Argument
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个正确性论证
- en: If you’re suitably convinced of correctness, feel free to skip this section.
    Otherwise, I’d now like to address a possible concern that you may have at this
    point.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确信正确性，可以跳过这一部分。否则，我现在想解决一个你可能有的疑虑。
- en: Suppose that the knight gets to a square an even number of moves ahead of the
    pawn and that this takes *m* moves. Also suppose that the knight leaves and revisits
    this square as many times as it likes, returning to this square after *m* + 2
    moves, *m* + 4 moves, and so on, eventually catching the pawn here. It would be
    scary if the knight could use some other sequence of moves to catch the pawn in
    *m* + 1 moves, or *m* + 3 moves, and so on, because then adding an odd number
    of moves could provide us a better minimum than adding an even number of moves.
    Fortunately, that can’t happen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 假设骑士用*m*步到达了一个方格，且这个方格比兵的移动提前了偶数步。还假设骑士可以随意离开并重新访问这个方格，每次都会在*m* + 2步、*m* + 4步等步数后回到该方格，最终在这里追上兵。如果骑士能用其他移动顺序，在*m*
    + 1步，或者*m* + 3步等奇数步后追上兵，那就很可怕了，因为那样加上奇数步可能会提供比加偶数步更小的最短步数。幸运的是，这种情况不会发生。
- en: 'Try this little experiment: choose a starting point and destination for the
    knight, and find the minimum number of moves that it takes for the knight to move
    from the starting point to the destination. That number of moves is *m*. Now try
    to find a way for the knight to get from that same starting point to that same
    destination using exactly one more move, or three more moves, and so on. For example,
    if the fastest way takes two moves, try to find a way to take three moves. You
    won’t be able to do so.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 试试这个小实验：选择一个起始点和目的地，找出骑士从起始点到目的地所需的最少步数。这个步数就是*m*。现在试着找到一种方法，让骑士从同样的起始点到同样的目的地，恰好用一步更多的步数，或者三步更多的步数，依此类推。例如，如果最快的方式需要两步，试着找到一个需要三步的方式。你是做不到的。
- en: Each knight move changes the row or column number by two and the other by one.
    For example, it might change the row number from six to four and the column number
    from four to five. Changing a number by two does not change whether that number
    is even or odd, but changing a number by one *does* change that number from even
    to odd or vice versa. That is, in terms of being even or odd, each move leaves
    one of the two numbers (row or column) alone, and it changes the other one. When
    a number changes from even to odd or vice versa, we say that its *parity* changes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每次骑士移动都会让行号或列号变化两个单位，另一个变化一个单位。例如，它可能把行号从六变成四，把列号从四变成五。改变一个数字两个单位不会改变该数字是偶数还是奇数，但改变一个数字一个单位*会*让该数字从偶数变为奇数，反之亦然。也就是说，就偶数或奇数而言，每次移动都会保持其中一个数字（行号或列号）不变，改变另一个数字。当一个数字从偶数变为奇数或反之时，我们说它的*奇偶性*发生了变化。
- en: Let *k* be an odd integer. Now we’re ready to see why the knight can’t take
    both *m* moves and *m* + *k* moves to get to the same destination. Suppose that
    the knight can take *m* moves to get to square *s*, that *m*[1] of those moves
    change whether the row is even or odd, and that *m*[2] of those moves change whether
    the column is even or odd.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that *m*[1] and *m*[2] are both even. As such, the moves don’t change
    the parity of the row or column: if we start with some number and flip its parity
    an even number of times, its parity doesn’t change. If we make some other sequence
    of moves, and it flips the parity of the row an odd number of times or flips the
    parity of the column an odd number of times, then that sequence cannot land at
    *s*, because it will land on a square with different row or column parity than
    *s*.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, *m*, the total number of moves *m*[1] + *m*[2], is even: adding two even
    numbers gives an even number. But, *m* + *k* is odd, because it’s the sum of an
    even number and an odd number. And, since *m* + *k* is odd, it cannot be built
    from an even number of moves that change the row and an even number of moves that
    change the column; at least one of them must be odd and therefore change the parity
    of the row or column. This is why these *m* + *k* moves cannot result in the knight
    landing on *s*! (There are three other cases—*m*[1] even and *m*[2] odd, *m*[1]
    odd and *m*[2] even, and *m*[1] odd and *m*[2] odd—but I’ll skip those. Their
    analysis is similar.)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '*A Time Optimization*'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our current solution ([Listing 5-5](ch05.xhtml#ch05ex05)) can make a lot of
    BFS calls. Each time the pawn moves up a row, we use BFS (by calling `find_distance`)
    to determine whether it can be caught there by the knight.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that the pawn starts at (1, 1). We run a BFS from the knight’s starting
    point to (1, 1), and that explores some of the squares. Suppose that the knight
    can’t catch the pawn here. We then have to run a BFS from the knight’s starting
    point to (2, 1). This explores some of the squares, too. However, (1, 1) and (2,
    1) are very close together, to the point that the second BFS probably re-explores
    many of the squares whose shortest distances were discovered in the first BFS
    call. Unfortunately, each of our BFS calls is independent, so that second BFS
    call redoes a lot of the work that the first BFS call did. The third call then
    duplicates a lot of what the prior two BFS calls did, and on and on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: It’s true that BFS is fast, and I’ll give more details on why in the next section.
    Still, it pays to try to reduce the number of invocations of BFS.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'I have good news: we can reduce the number of BFS calls to just . . . one!
    Recall our BFS code in [Listing 5-1](ch05.xhtml#ch05ex01). We had code ➍ to cut
    our BFS short if we found the target position. However, if this code is removed,
    then the BFS will explore the entire board, calculating the shortest distance
    to each square. Making that change means that we can make one call to BFS and
    then be done with it. From then on, we just look up what we need in the `min_moves`
    array.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Do it! Make the required changes to the code so that BFS is called only one
    time.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The code we worked through together takes 0.1 seconds when I submit to the judge.
    With the “only one invocation of BFS” optimization, the code takes only 0.02 seconds,
    a speedup of 500 percent. More importantly, this optimization shows that BFS can
    be used not only to find the shortest distance from a starting position to some
    other position, but also to find the distance from the starting position to *all*
    other positions. I’ll discuss BFS a little more in the next section. And keep
    reading after that, because I think the flexibility of BFS is going to surprise
    you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Graphs and BFS
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BFS is a powerful search algorithm, as we saw in the solution to the Knight
    Chase problem. To run a BFS, we need what’s called a *graph*. We didn’t think
    about graphs when solving the Knight Chase problem—or perhaps didn’t know what
    they were!—but there was indeed a graph underlying the BFS.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '*What Are Graphs?*'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 5-1](ch05.xhtml#ch05fig01) is our first example of a graph.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig01.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: A graph of knight moves*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Like a tree, a graph consists of *nodes* (the boxes) and *edges* between nodes
    (the lines). In this graph, the edges represent valid knight moves. For example,
    from the (5, 1) node, the knight can move on an edge to (4, 3) or on an edge to
    (3, 2). There are no other edges involving (5, 1), so there are no other knight
    moves from there.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I can explain how we implicitly used a graph to solve the Knight Chase
    problem. Suppose that (5, 1) is the knight’s starting position. Our BFS tries
    all eight moves from there, but six of them lead to a position that is outside
    of the board; in graph terminology, six of them are not edges from (5, 1). The
    BFS discovers the two nodes that *are* reachable on an edge from (5, 1): (4, 3)
    and (3, 2). The exploration then continues with the nodes reachable from each
    of these two nodes, and so on.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: I laid the graph out as a grid to reflect the underlying board, but the way
    that a graph is drawn carries no meaning. All that matters are the nodes and edges.
    I could have drawn the graph with the nodes chaotically spread around, and it
    would have conveyed the same meaning. However, when the graph is rooted in some
    underlying geometry, it makes sense to display the graph in a corresponding way
    for easier interpretation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: To solve the Knight Chase problem, we didn’t need to explicitly represent the
    graph in code, because we figured out the available moves (edges) from each node
    as we explored the board. Sometimes, though, we do need to represent a graph explicitly
    in code, along the lines of our tree representations in [Chapter 2](ch02.xhtml).
    We’ll see how to do that in Problem 3.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '*Graphs vs. Trees*'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Graphs and trees have a lot in common. They’re both used to represent relationships
    between nodes. In fact, every tree is a graph, but there are graphs that are not
    trees. Graphs are more general, and they can express more than what trees can
    express.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'First, graphs (but not trees) allow cycles. We have a *cycle* in a graph if
    we can start from a node and get back to it without using any repeated edges or
    nodes. (The first and last nodes in the cycle are the only ones that repeat.)
    Look back at [Figure 5-1](ch05.xhtml#ch05fig01). Here’s a cycle in that graph:
    (5, 3) → (4, 5) → (3, 3) → (4, 1) → (5, 3).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Second, graphs (but not trees) can be *directed*. The trees and graph we’ve
    seen so far are *undirected*, meaning that if two nodes *a* and *b* are connected
    by an edge, then we can travel both from *a* to *b* and from *b* to *a*. The graph
    in [Figure 5-1](ch05.xhtml#ch05fig01) is undirected; for example, we can move
    from (5, 3) on an edge to (4, 5) and use that same edge to move from (4, 5) to
    (5, 3). Sometimes, though, we want to allow travel in only one direction, not
    the other. A *directed* graph is a graph in which each edge indicates the allowed
    direction of travel. [Figure 5-2](ch05.xhtml#ch05fig02) depicts a directed graph.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig02.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: A directed graph*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Note, in [Figure 5-2](ch05.xhtml#ch05fig02), how it’s possible to move from
    E to each of the other nodes, but it is not possible to move from any of those
    nodes to E. The edges are one-way edges.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Directed graphs are useful whenever an undirected graph would lead to loss of
    information. In my Computer Science department, each course has one or more prerequisite
    courses. For example, we have a C Programming course, which requires that students
    have already taken our Software Design course. A directed edge Software Design
    → C Programming captures this relationship. Had we used an undirected edge, we’d
    still know that the courses were related, but we wouldn’t know the order in which
    the courses must be taken. [Figure 5-3](ch05.xhtml#ch05fig03) shows a small prerequisite
    graph.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig03.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: A graph of course prerequisites*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The third thing that makes graphs more general than trees is that graphs can
    be *disconnected*. All trees and graphs we have seen to this point are *connected*,
    which means that you can get from any node to any other node. Now check out the
    disconnected graph in [Figure 5-4](ch05.xhtml#ch05fig04).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig04.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: A graph of disconnected course prerequisites*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: It’s disconnected because, for example, you can’t follow a path from *Intro
    to Programming* to *World Prehistory*. Disconnected graphs are useful whenever
    a graph is naturally composed of separate pieces.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '*BFS on Graphs*'
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can run BFS on an undirected graph (as we did for the Knight Chase problem)
    or a directed graph. The algorithm is the same: we go through the possible moves
    from the current node and explore them. BFS is known as a *shortest-path* algorithm:
    among all paths between a starting node and some other node, BFS gives us the
    shortest one in terms of the number of edges. As long as what we care about is
    minimizing the number of edges, it solves the *single-source shortest-paths* problem,
    since it finds shortest paths from a single source (or starting) node.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to control to make BFS fast is not whether the graph is undirected
    or directed, but the number of times we invoke BFS and the number of edges in
    the graph. The runtime of a BFS call is proportional to the number of edges reachable
    from the starting node. That’s because BFS looks at each edge once to determine
    whether it leads to the discovery of a new node. We call BFS a linear-time algorithm,
    since it does work linear in the number of edges: if 5 edges takes 5 steps for
    BFS to explore it, then 10 edges will take 10 steps. We’ll use the number of edges
    to estimate the number of steps performed by BFS.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Knight Chase problem, we had a board with *r* rows and *c* columns.
    Each node has at most eight edges, so the board has at most 8*rc* edges in total.
    Therefore, running one BFS takes 8*rc* steps. For the biggest board, 99×99, this
    is fewer than 80,000 steps. If we call BFS on the order of *r* times, as can happen
    in [Listing 5-5](ch05.xhtml#ch05ex05), then we’re looking at 8*r*²*c* steps. Now
    the 99×99 board isn’t looking so good: it could take over 7 million steps. This
    is why it helps so much to reduce the number of calls of BFS!'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Any time a problem involves a set of objects (board locations, courses, people,
    websites, and so on) and relationships between those objects, it’s a good bet
    that modeling the problem as a graph will help. Once you model a problem as a
    graph, you can take advantage of a huge number of fast algorithms on graphs. BFS
    is one of those algorithms.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '*Graphs vs. Dynamic Programming*'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes it can be difficult to determine whether to use dynamic programming
    or a graph to solve a problem. The giveaway is often the presence of a cycle:
    if you have a cycle, then you need a graph.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: None of the problems that we solved in [Chapter 3](ch03.xhtml) or [Chapter 4](ch04.xhtml)
    had a cycle. In Burger Fervor we recursed with fewer minutes. In Moneygrubbers
    we recursed with fewer needed apples. In Hockey Rivalry we recursed with fewer
    games. We always go down—there’s no way to loop back to a higher number of minutes
    or apples or games to cause a cycle.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: It’s trickier to see that this is true for The Jumper in [Chapter 4](ch04.xhtml),
    but it is. Think back to our forward formulation. If we jump to the right, then
    we recurse with a bigger jump distance. If we jump to the left, then we recurse
    with the same jump distance but a smaller-numbered square. There’s no way to start
    at a given subproblem and get back to it using these jumps. You might try to do
    that by making some jumps to the left and then making a jump to the right—but
    your jump to the right will have increased the jump distance by one and there’s
    no way to decrease it by one ever again.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: No cycle!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: Rope Climb'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Knight Chase problem, we were explicitly given a board on which a game
    takes place. Here, we won’t be given the board directly, so we’ll have to work
    it out. Again, the strategy will be to model valid moves using BFS.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `wc18c1s3`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bob is asked to climb a rope in gym class. The rope is infinitely long, but
    Bob is being asked to get only to a height of at least *h* meters.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob starts at a height of 0\. He knows how to jump up by exactly *j* meters,
    but that’s the only jump he knows how to do—so if *j* is `5`, then he can’t jump
    up four or six meters or any other number of meters except five. In addition,
    Bob knows how to fall, and he can fall down any number of meters: one, two, three,
    and so on.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Each jump or fall counts as one move. For example, if Bob jumps up five meters,
    falls down two meters, jumps up five meters, and falls down eight meters, then
    Bob will have made four moves.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here’s the fun part: Alice has spread itching powder on some segments
    of the rope. If such a segment goes from height *a* to height *b*, then the entire
    segment from *a* to *b*, including the endpoints *a* and *b*, has itching powder.
    The effect that the itching powder has on Bob’s moves is as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Bob cannot jump up *j* meters if that would land him on itching powder.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bob cannot fall down a given number of meters if that would land him on itching
    powder.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is to determine the minimum number of moves needed for Bob to get to
    height *h* or higher.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'A line containing three integers: *h*, *j*, and *n*. *h* tells us the minimum
    height that Bob must reach, *j* is the distance that Bob can jump up, and *n*
    is the number of segments on which Alice has spread itching powder. Each integer
    is at most 1,000,000, and *j* is at most *h*.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, each of which contains two integers. The first integer gives the
    starting height for a segment of rope with itching powder; the second gives the
    ending height. Each integer is at most *h* – 1.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the minimum number of moves needed for Bob to reach height *h* or higher.
    If there is no way for Bob to reach height *h* or higher, output `-1`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 1.8 seconds.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Finding the Moves*'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by making direct comparisons to the Knight Chase problem. Notice
    in both cases that our goal is to minimize the number of moves. Whether it’s a
    knight on a board or Bob on a rope, the goal is the same. It’s true that the knight
    was moving around a two-dimensional board and Bob is moving around a one-dimensional
    rope, but that just changes how we’ll refer to each position. BFS won’t otherwise
    care about the change from two dimensions to one. If anything, dropping one dimension
    simplifies things a little!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'How about the number of possible moves from each position? The knight had at
    most eight of those. In contrast, the number of possible moves Bob can make increases
    with his position. For example, if Bob is at a height of 4, and he can jump up
    by 5, then he has five possible moves: jump up by 5, fall down by 1, fall down
    by 2, fall down by 3, or fall down by 4\. If Bob is at a height of 1,000, then
    he has 1,001 possible moves! So we’ll have to take Bob’s current position into
    account when determining the number of available moves.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'What about the itching powder? Knight Chase doesn’t have anything resembling
    that. Let’s look at a test case to see what we’re up against here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Bob has to get to a height of 10 or higher. He can jump up by four. So, if there
    were no itching powder, he’d be able to jump from a height of 0 to 4, then to
    8, and then to 12\. That’s three moves.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Bob can’t do that, though! He isn’t allowed to jump from 4 to 8, because there’s
    itching powder at a height of 8 (as the itching powder goes from 8 to 9). The
    solution, by factoring in the itching powder, is four moves. For example, Bob
    can jump from 0 to 4, then fall to 3, then jump to 7, and then jump to 11\. That
    jump from 7 to 11 breezes right past the itching powder.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'The move from 4 to 8 seems available based on Bob’s ability to jump up by four,
    but it is actually not available because of the itching powder. This isn’t so
    different than a knight move being unavailable because it would take the knight
    outside of the board. For those invalid knight moves, we detected them in the
    BFS and didn’t add them to the next round of positions. We’ll handle itching powder
    similarly: any move that would cause Bob to land on itching powder will be disallowed
    in our BFS code.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of those invalid knight moves that take the knight outside of the board,
    do we have to worry about that kind of thing here? The rope is infinitely long,
    so we won’t break any rules by letting Bob climb higher and higher. However, at
    some point we really do have to stop; otherwise, the BFS will forever be finding
    and exploring new positions. I’ll invoke the insight from Moneygrubbers in [Chapter
    3](ch03.xhtml) that helped us out of a very similar bind when buying apples. We
    said there that if we’re asked to buy 50 apples, then we should consider buying
    at most 149 apples, because each pricing scheme gives us at most 100 apples. Here,
    remember from the problem description that *j*, the distance that Bob jumps up,
    is at most *h*, the minimum target height. We shouldn’t let Bob get to height
    2*h* or higher. Think about what it would mean the first time we got Bob to height
    2*h* or higher. One move prior, Bob would have been at height 2*h* – *j* ≥ *h*,
    and that would have taken one move less than getting Bob to height 2*h*! Thus,
    getting Bob to height 2*h* or higher can’t be the fastest way to get him to at
    least height *h*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Breadth-First Search
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We’ll very closely follow what we did for the Knight Chase problem, making
    changes only when necessary. Back then, each knight position consisted of both
    a row and a column, so we created a struct to hold both of those pieces of information.
    Now, a position on a rope is just an integer, so we don’t need a struct for that.
    We’ll make type definitions for the “board” and the positions discovered by BFS:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It may seem a little weird to call a rope a board, I suppose, but it serves
    the same purpose as the corresponding type definition in the Knight Chase problem,
    so let’s stick with it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: We’re eventually going to make a single call of BFS, and that call is going
    to calculate the minimum number of moves for Bob to get from a height of zero
    to each valid position. The code for the BFS is given in [Listing 5-6](ch05.xhtml#ch05ex06)—compare
    this to the `find_distance` code in [Listing 5-1](ch05.xhtml#ch05ex01). (Especially,
    compare it to the code I hope you wrote after reading “A Time Optimization” on
    [page 168](ch05.xhtml#sec69).)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 5-6: Minimum number of moves for Bob using BFS*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four parameters for this `find_distances` function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: target_height   The minimum height that Bob must reach. It’s the *h* value from
    the test case.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: jump_distance   The distance that Bob can jump up. It’s the *j* value from the
    test case.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'itching   An array that indicates where itching powder is present. If `itching[i]`   is
    `0`, then there’s no itching powder at height `i`; otherwise, there is. (Looking
    ahead, we’ll have to build this array from the segments of itchy rope given in
    the test case. But we’ll be able to do that, and then we won’t have to worry about
    the particular segments themselves: we can just index this array.)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: min_moves   The board in which we’ll store the minimum number of moves to get
    to each position.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: As in [Listing 5-1](ch05.xhtml#ch05ex01) for Knight Chase, we initialize each
    position of the board to `-1` ➊, which means that BFS hasn’t found this position
    yet. That initialization, as with any other manipulation of `board` here, indexes
    a one-dimensional (not two-dimensional!) array. Other than that, the structure
    is quite similar to the BFS code for Knight Chase.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, an interesting structural change to the code that adds positions.
    Bob has exactly one jump distance, so there’s only one jump move to consider ➋:
    Bob starts at `from_height` and ends up, if it’s a valid position, at `from_height
    + jump_distance`. We can use `target_height * 2 - 1` to get the maximum height
    that Bob is allowed to reach. For falling down, we cannot hard-code Bob’s available
    moves; those moves depend on Bob’s current height. To handle that, we use a loop
    ➌ to consider all destination heights from 0 (the ground) up to but not including
    `from_height` (Bob’s current height). This loop is the only significant change
    from the Knight Chase BFS.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up our BFS code, we need to implement the `add_position` helper function.
    That code is given in [Listing 5-7](ch05.xhtml#ch05ex07).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 5-7: Adding a position*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob wants to move from `from_height` to `to_height`. This move is allowed if
    it passes three tests. First, Bob can’t be jumping above the maximum allowed height.
    Second, he can’t be jumping somewhere that has itching powder. Third, the `min_moves`
    board better not have already recorded a number of moves for `to_height`: if a
    value is already in there, then it has a faster way to get to `to_height`. If
    we passed these tests, then we’ve found a new, valid position; we set the number
    of moves to get there and then store this as a position for the next round of
    BFS.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Best Height
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are many possibilities for Bob’s final position. It could be the target
    height *h* from the test case. However, depending on *j* and the itching powder,
    it could be higher than that. We know for each position the minimum number of
    moves to get there. What we have to do now is check all of the candidate positions,
    choosing the one that minimizes the number of moves. That code is given in [Listing
    5-8](ch05.xhtml#ch05ex08).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-8: The minimum number of moves*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible that Bob can’t get to his target height, so we start `best` off
    with a value of `-1` ➊. For each candidate height, we then check whether it’s
    possible for Bob to land there. If he can, and doing so is faster than our current
    minimum number of moves `best` ➋, then we update `best` accordingly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now got all the code to process a test case and output the result. All
    that’s left is to read the input. The `main` function in [Listing 5-9](ch05.xhtml#ch05ex09)
    does that.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-9: The* main *function*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: As is typical for large arrays, we have made `itching` and `min_moves` static.
    The elements of `itching` are initialized to `0`, which means that there is no
    itching powder yet on the rope. For each segment where there is itching powder
    on the rope, we loop through each integer in the range ➊ and set the corresponding
    element of `itching` to `1` ➋. Once we’re done looping through the itchy segments,
    each index of `itching` tells us if the rope does (value `1`) or does not (value
    `0`) have itching powder there. We no longer care about the individual itchy segments
    themselves—we have all that we need in `itching`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. We’ve got a solution that uses a single call of BFS. It’s time to
    submit to the judge. As some might say, Bob’s your uncle . . .
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Or, hopefully he will be, but he’s not yet. Because you should receive a “Time-Limit
    Exceeded” error with this code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: A Remodel*'
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s run test cases of increasing size to get a sense of how our runtime is
    growing. To simplify things, we won’t use any itching powder. Here’s the first
    test case:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That’s a target height of at least 30,000, with a jump distance of 5\. On my
    laptop, that takes about eight seconds. Now let’s double the target height:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'I’m looking at about 30 seconds here. That’s nearly four times longer than
    in the previous case. We’ve long blown past the 1.8-second time limit, but let’s
    do this one more time, doubling the target height again:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That gives a glacially slow 130 seconds, approximately another fourfold increase
    from the previous test case. That is, it seems that doubling the input size leads
    to the runtime being multiplied by four. This isn’t as catastrophic as what we
    saw in “Solution 2: Memoization” when solving Burger Fervor in [Chapter 3](ch03.xhtml),
    but it’s clearly too slow.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Too Many Fall Edges
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In “BFS on Graphs” on [page 172](ch05.xhtml#sec72), I warned that we need to
    keep two things in check when using BFS: the number of times we call BFS and the
    number of edges in the graph. We’re doing as well as possible with the number
    of BFS calls, as we only call BFS once. To further pursue a solution based on
    BFS, then, we need a way to reduce the number of edges in the graph.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the graph for a small example shown in [Figure 5-5](ch05.xhtml#ch05fig05).
    We’ll then be able to extrapolate to larger examples and see why our code churrs
    and churrs.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig05.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: A graph of Bob’s moves*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: The graph shows the available moves from a height of 0 to a height of 7, if
    we assume that Bob can jump up by 3\. This is an example of a directed graph;
    notice, for example, that there is a move from 6 to 5 but not one from 5 to 6.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: The graph contains jump edges that encode Bob’s possible jumps and fall edges
    that encode Bob’s possible falls. The jump edges go from the bottom to the top
    and the fall edges go from the top to the bottom. For example, the edge from a
    height of 0 to a height of 3 is a jump edge; the aforementioned edge from 6 to
    5 is a fall edge.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The number of jump edges isn’t worrisome at all. We have at most one jump edge
    per node. If we have *n* nodes, then we have at most *n* jump edges. If we decide
    to model up to a height of 8 instead of 7, then we’d add only one new jump edge.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: However, the fall edges proliferate at a much faster rate. Notice that there
    is one fall edge from a height of 1, two fall edges from 2, three fall edges from
    3, and so on. That is, for a rope of height *h*, we have a total of 1 + 2 + 3
    + . . . + *h* fall edges. If we want to know how many fall edges there are for
    a given rope height, we could add up the integers from 1 to that height. There
    is, however, a convenient formula that we can use instead to get the answer much
    faster. It’s *h*(*h* + 1)/2\. For a rope height of 50, for example, we’d have
    50(51)/2 = 1, 275 fall edges. For a rope height of two million, we’d have over
    two trillion fall edges.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Back in [Chapter 1](ch01.xhtml), we saw a very similar formula in “Diagnosing
    the Problem” on [page 9](ch01.xhtml#ch01lev1), when we were counting pairs of
    snowflakes. Like that one, our formula here is quadratic, being *O*(*h*²), and
    it’s this quadratic growth in fall edges that bests our algorithm.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Moves
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If we’re going to reduce the number of edges in the graph, then we’re going
    to have to change the available moves that the graph encodes. We can’t change
    the rules of the actual game that Bob plays in gym class, but we *can* change
    the moves in our graph model of the game. Of course, we are only able to change
    the graph if a BFS on the new graph produces the same answer as a BFS on the old
    graph.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: There’s an important lesson here. It’s tempting to map the available moves,
    one for one, from the real-world problem to the graph. We did that for Knight
    Chase and succeeded in solving the problem. While this might be tempting, it’s
    not a requirement. We can produce a different graph, one with a more desirable
    number of nodes or edges, as long as that graph can still give us the answer to
    the original problem.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we want to fall some distance from a height of five meters. One
    possibility might be to fall four meters. Indeed, solving the problem as in Solution
    1, there would be a fall edge from a height of 5 down to 1\. However, another
    way to think of this fall is as four falls of one meter each. That is, we can
    think of Bob falling from 5 to 4, then falling to 3, then falling to 2, and then
    falling finally to 1\. That is, I’m imagining that every fall edge would be exactly
    one meter long. No more fall edges like those from a height of 5 to 3, or 5 to
    2, or 5 to 1, or 5 to 0\. There would be just one fall edge from each node, bringing
    us one meter lower. This should drastically cut down on the number of fall edges!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: We have to be careful, though. We can’t let each of these mini, one-meter falls
    count as a move. If Bob falls four meters, using four one-meter-fall edges, then
    we still have to count it as a single move, not four moves.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have two ropes (0 and 1), not one. Rope 0 is the rope that we’ve
    always had. Alice set it up. It might have itching powder. Rope 1 is new, devised
    by us, for the purposes of modeling. It has no itching powder. In addition, when
    Bob is on Rope 1, he’s not allowed to move upward.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'When Bob wants to make a fall move, he will move from Rope 0 to Rope 1\. He’ll
    stick with Rope 1, falling, for as long as he wants to fall. Then, at any point
    where there isn’t itching powder on Rope 0, he can end his fall by moving back
    to Rope 0\. Specifically, we have the following moves now:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'When Bob is on Rope 0, he has two possible moves: jump up by *j* meters or
    move over to Rope 1\. Each costs one move.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When Bob is on Rope 1, he has two possible moves: fall by one meter or move
    over to Rope 0\. Each costs 0 moves. That’s right: these moves are free!'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bob jumps up as before, using Rope 0\. When he wants to fall, he moves to Rope
    1 (that costs him one move), falls down Rope 1 as much as he likes (that’s free),
    and then moves back to Rope 0 (that’s free, too). The whole fall, then, costs
    Bob just one move. Perfect—this is just as before! No one will know that we’re
    using two ropes instead of one.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Compare [Figure 5-5](ch05.xhtml#ch05fig05), with its mass of edges, to [Figure
    5-6](ch05.xhtml#ch05fig06), which depicts the two-ropes maneuver.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig06.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: A graph of Bob’s moves using two ropes*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s true that we’ve doubled the number of nodes, but that’s okay: what we
    care about for BFS is not the number of nodes but the number of edges. On that
    front, we’re laughing. We have, at most, two edges leaving each node: on Rope
    0, we have a jump edge and a move to Rope 1; on Rope 1, we have a fall edge and
    a move to Rope 0\. That is, for height *h*, we have about 4*h* edges. That’s linear!
    We’ve avoided that messy quadratic *h*² business.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: I’ve annotated each edge here with whether it costs a move (1) or doesn’t (0).
    This is our first example of a *weighted* graph, where each edge is given a weight
    or cost.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Adding Positions
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve meandered our way back to a two-dimensional board. (Hello, Knight Chase!)
    We need one dimension for Bob’s height and the second for the rope that Bob is
    on. The standard terminology for that second dimension is a *state*. When Bob
    is on Rope 0, we’ll say he’s in state 0, and when Bob is on Rope 1, we’ll say
    he’s in state 1\. Let’s use “state” from now on instead of “rope.”
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the new `typedef`s:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Rather than start with `find_distances`, as we have been doing in this chapter,
    we’ll start with the `add_position` functions. Yes: functions, plural, because
    we’re going to encode each type of move as its own function. There are four types
    of moves: a jump up, a fall down, a move from State 0 to State 1, and a move from
    State 1 to State 0\. Hence we’ll need four `add_position` functions.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Jumping Up
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The code for following a jump edge is given in [Listing 5-10](ch05.xhtml#ch05ex010).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 5-10: Adding a position: jumping up*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: This function involves jumping up from `from_height` to `to_height`. This kind
    of move is allowed only in state 0; whenever we index `min_moves`, we’ll therefore
    use `0` as the second index.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The code is similar to [Listing 5-7](ch05.xhtml#ch05ex07), but with a few important
    changes. First, I’ve changed the name of `new_positions` to `pos` and `num_new_positions`
    to `num_pos`. We’ll talk about the reason for this change to more generic parameter
    names after we’ve gone through the four functions.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Second, to facilitate comparison between the four functions, I’ve added a `distance`
    variable ➊ that indicates the number of moves it takes to get to `to_height` by
    using `from_height`. Here, it’s one more move than the minimum number of moves
    to `from_height`, because we pay one move for this jump.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Third and finally, I’ve changed the part of the if condition that checks whether
    we’ve found a new position ➋. This is because a position might be discovered by
    an edge that counts as one move, but it could later be rediscovered by an edge
    that doesn’t count as a move. We want to allow for the possibility that the minimum
    number of moves is updated and improved by one of those no-cost edges. (Jumping
    up is not a no-cost edge, so we don’t need this change here; but I’ve kept it
    in for consistency across the four functions.)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Falling Down
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s now take a look at the code for falling down given in [Listing 5-11](ch05.xhtml#ch05ex011).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 5-11: Adding a position: falling down*'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Falling down can only happen in state 1; that’s why the second index is `1`
    whenever we access `min_moves`. Also, there’s nothing to do with itching powder
    here. Bob can fall as much as he likes in State 1 and not have to worry about
    the itching powder. Finally, a crucial point about the calculated distance is
    that there’s no `+ 1` added ➊!
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: this doesn’t count as a move.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Switching States
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are two more functions to go. First we have the function to move from
    State 0 to State 1 in [Listing 5-12](ch05.xhtml#ch05ex012).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 5-12: Adding a position: moving from state 0 to state 1*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Then we have the function to move from state 1 to state 0, shown in [Listing
    5-13](ch05.xhtml#ch05ex013).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 5-13: Adding a position: moving from state 1 to state 0*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Moving from State 0 to State 1 costs one move, but moving from State 1 to State
    0 does not. Also notice we’re only allowed to move from State 1 to State 0 if
    there’s no itching powder at that height. Without that check, we’d be allowed
    to stop a fall on a segment of the rope with itching powder, and that would be
    breaking the rules.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 0-1 BFS
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now it’s time to incorporate the state into the `find_distances` code from [Listing
    5-6](ch05.xhtml#ch05ex06). However, we had better be careful, lest we miscount
    the moves.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example. I’ll use (*h*, *s*) to refer to Bob being at height *h* in
    state *s*. Suppose that Bob can jump up by three. Bob starts at (0, 0), and it
    takes zero moves to get there. Exploring from (0, 0), we will identify (0, 1)
    as a new position, and record that it takes one move to get there. It’ll be added
    to the positions for the next round of BFS. We’ll also find (3, 0) and similarly
    record that it takes one move to get there. That’s another position for the next
    round of BFS. That’s all standard BFS fare.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: When exploring out of (3, 0), we’ll find the new positions (3, 1) and (6, 0).
    Both will be added to the next round of BFS, and both will be reachable in a minimum
    of two moves.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: However, we need to be careful with position (3, 1). We know that (2, 1) is
    reachable from here, so it’s tempting to add it to the next round of BFS. If we
    did that, though, then we wouldn’t be doing BFS anymore. We are supposed to put
    positions in the next round of the BFS when they are exactly one move away from
    those in the current round. Is (2, 1) one more move away from (3, 1)? No! They
    are the same number of moves from (0, 0), because falling in State 1 is free.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: That is, (2, 1) doesn’t go in the next round of BFS. It goes in the *current*
    round of BFS, right along with (3, 1) and everything else whose minimum moves
    is two.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: In summary, whenever we move along an edge that costs us a move, we add the
    new position to the next round of BFS. That’s what we’ve always done. However,
    when we move along an edge that is free, then we add it to the current round of
    BFS so that it can be processed along with the other positions whose distance
    is the same. This is why we moved away from `new_positions` and `num_new_positions`
    in the `add_position` functions in “Adding Positions” on [page 182](ch05.xhtml#ch05lev1z).
    Two of the functions will indeed add moves to the new positions, but the other
    two will add moves to the current positions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: This variant of BFS is called *0-1 BFS*, because it works on graphs whose edges
    cost zero moves or one move.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: At last, it’s time for the BFS. Check it out in [Listing 5-14](ch05.xhtml#ch05ex014).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 5-14: The minimum number of moves for Bob using 0-1 BFS*'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: The new code checks whether the current position is in State 0 or State 1 ➊.
    In each case, there are two moves to consider. In State 0, the new positions (those
    for the next round of BFS) are used; in State 1, the current positions are used.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: What about the `main` and `solve` functions? For `main`, we can use the same
    function from Solution 1\. For `solve`, we just need to add State 0 whenever we
    index `min_moves`. If you make those changes and submit to the judge, you’ll see
    that we pass all tests with plenty of time to spare.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 3: Book Translation'
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Knight Chase and Rope Climb problems, there was no explicit graph to
    read from the input; the BFS incrementally produced the graph as it explored.
    We’ll now see a problem where the graph is presented to us up front.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ecna16d`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You have written a new book in English, and you want to get the book translated
    into *n* other target languages. You’ve found *m* translators. Each translator
    knows how to translate between exactly two languages and will do the translation
    at a given cost. For example, a translator may know how to translate between Spanish
    and Bengali at a cost of $1,800; this means that you could ask this translator
    to translate from Spanish to Bengali for $1,800 or Bengali to Spanish for $1,800.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: To reach a given target language may require multiple translations. For example,
    you may want to translate your book from English to Bengali but have no translator
    between these two languages. You might instead have to translate from English
    to Spanish and then Spanish to Bengali.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the number of translation errors, you will minimize the number of
    translations needed to reach each target language. If there are multiple ways
    to achieve a minimum number of translations to a target language, then you will
    choose the cheapest one. Your goal is to minimize the number of translations to
    each target language; if there are multiple ways to do this, choose the one with
    minimum total cost.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: A line containing two integers *n* and *m*. *n* is the number of target languages;
    *m* is the number of translators. There are at most 100 target languages and at
    most 4,500 translators.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *n* strings, each naming a target language. `English` will
    not be a target language.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*m* lines, each giving information for one translator. Each of these lines
    contains three space-separated tokens: a language, a second language, and the
    positive integer cost to translate between them. There is at most one translator
    per pair of languages.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the minimum monetary cost to translate the book into all of the target
    languages, while minimizing the number of translations to each target language.
    If there is no way to translate the book into all of the target languages, output
    `Impossible`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 0.6 seconds.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '*Reading the Language Names*'
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rather than use language names directly—English, Spanish, and so on—I’ll associate
    each language with an integer. English will be language 0, and each target language
    will be given a unique integer greater than 0\. We can then work with integers
    from here on out, as we did for the other problems in this chapter.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one annoyance here: the problem description does not tell us the maximum
    length of a language name. We therefore cannot hardcode some maximum language
    name length like 16 or even 100, because we have no control over the input. We
    therefore use a `read_word` helper function; see [Listing 5-15](ch05.xhtml#ch05ex015).'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 5-15: Reading a word*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The `read_word` function takes an initial size that we hope suffices for most
    or all of the language names. When we call the function, we will give an initial
    size of 16, because that covers most language names we’re likely to see. We can
    use `read_word` to read characters ➊ up until the array reaches its maximum length;
    if the array fills up and the language name still isn’t over, it then uses `realloc`
    to double the array’s length ➋, thereby creating more space to read more characters.
    We’re careful to terminate `str` with a null character ➌; otherwise, it wouldn’t
    be a valid string!
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '*Building the Graph*'
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s turn to building a graph from the input. This will help us explore
    the allowable translations from each language.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s work with a small test case:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Can you construct the graph? What are the nodes and what are the edges? Is it
    undirected or directed? Is it unweighted or weighted?
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: As always, the edges encode the allowed moves; here, a move corresponds to a
    translation between two languages. The nodes, then, are the languages. An edge
    going from language *a* to language *b* means that there is a translator between
    these two languages. The translator can translate from *a* to *b* or vice versa—so
    the graph is undirected. It’s also weighted, because each edge (a translation)
    has a weight (the translation cost). The graph is shown in [Figure 5-7](ch05.xhtml#ch05fig07).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch05fig07.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: A graph of translations*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'The total translation cost for us to reach all of the target languages is $500
    for English to Spanish, plus $1,000 for English to Italian, plus $1,800 for Spanish
    to Bengali. That’s $3,300 in all. Don’t be taken in by that alluring $250 Spanish–Italian
    translation: using that would result in a distance of two from English to Italian,
    but remember that we need the minimum distances, even when that leads to spending
    more money. Indeed, the reason we’ll be able to use BFS here is precisely because
    we care first about the minimum number of edges for each target language, not
    its minimum cost overall. For the latter, we’d need more powerful tools, and these
    will be introduced in [Chapter 6](ch06.xhtml).'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: To store the graph, I’ll use what’s called an *adjacency list*. (Node *b* is
    said to be *adjacent* to Node *a* if there is an edge from *a* to *b*; that’s
    where the name “adjacency list” comes from.) This is just an array with one index
    per node, where each index stores a linked list of the edges involving that node.
    We use linked lists of edges, rather than arrays of edges, because we don’t know
    in advance the number of edges that involve a given node.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the constants and `typedef`s:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: An `edge` has a `to_lang` and a `cost`—that makes sense. However, it doesn’t
    have a `from_lang`, and that’s because we’ll already know the `from_lang` based
    on which index of the adjacency list the edge is in.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml), when storing trees, we used a `struct node` rather
    than a `struct edge`. The reason for the node-centric focus in [Chapter 2](ch02.xhtml)
    is that the nodes are the entities associated with information, such as candy
    values and numbers of descendants. In the present problem, we have an edge-centric
    focus, with the `struct edge`, because it’s the edges (not the nodes) that are
    associated with information (the translation costs).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: It’s easiest to add to a linked list at its beginning. One side effect of this
    choice is that the edges for a node end up in the linked list in the opposite
    order in which we read them. For example, if we read an edge from Node 1 to Node
    2 and then read an edge from Node 1 to Node 3, then in our linked list we will
    find that the edge to Node 3 shows up *before* the edge to Node 2\. Don’t let
    this catch you off guard when tracing through the code.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to see how the graph is built. It’s in the `main` function given
    in [Listing 5-16](ch05.xhtml#ch05ex016).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 5-16: The* main *function for building the graph*'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: The `lang_names` array maps integers (the array indices) to language names.
    We give `English` the number 0, as promised ➊. We then map each integer 1, 2,
    . . . , to language names as we read them ➋.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the graph is undirected: if we add an edge from *a* to *b*, then
    we had better add the edge from *b* to *a*, too. As such, for each translator,
    we add two edges to the graph: one from `from_index` to `to_index` ➌ and one from
    `to_index` to `from_index` ➍. Those `from_index` and `to_index` indices are produced
    by `find_lang`, which searches for a language name; see [Listing 5-17](ch05.xhtml#ch05ex017).'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: In the calls to the helper functions at the bottom, we use `num_targets + 1`
    rather than `num_targets` because `num_targets` gives the number of target languages;
    the `+ 1` lets us include English in the count of total languages being processed.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 5-17: Finding a language*'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '*The BFS*'
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code for `add_position` in [Listing 5-18](ch05.xhtml#ch05ex018) is similar
    to the other `add_position` functions we’ve studied earlier in this chapter.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 5-18: Adding a position*'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready for the BFS itself; see [Listing 5-19](ch05.xhtml#ch05ex019).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 5-19: Minimum cost of translations using BFS*'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: For each language, we’ll use `min_costs` to store the minimum-cost edge that
    could have been used to discover that language. Referring back to [Figure 5-7](ch05.xhtml#ch05fig07),
    we’d store 500 for Spanish, 1,000 for Italian, and 1,800 for Bengali. In a different
    function, described soon, we’ll add up all of these numbers to get the total cost
    for all of the translations.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: The minimum number of moves is of interest only to this function, not the outside
    world, so we declare it as a local variable ➊. All the outside world cares about
    is `min_costs`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Trying each possible move amounts to traversing the linked list of edges for
    the current node ➋. That gives us all of the `new_positions`. Now we know which
    languages are discovered in the next round of the BFS, but we don’t yet know the
    cost of adding each of those languages. The thing is, there could be multiple
    edges from `cur_positions` that reach the same node in `new_positions`. Consult
    [Figure 5-7](ch05.xhtml#ch05fig07) again. Bengali takes two translations, so it’s
    discovered in round 2 of the BFS—but the edge we need is the one from Spanish,
    not the one from Italian.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: We therefore have a new `for` loop ➌, one whose role we haven’t seen yet in
    this chapter. The variable `added_lang` tracks each of the new positions (that
    is, the positions for the next round of BFS). We find the cheapest edge between
    `added_lang` and any node discovered in the current round of BFS. Each such language
    will have a distance of one less than `added_lang`, which explains the first condition
    in the `if` statement ➍.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '*The Total Cost*'
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we’ve got the costs stored, all we do is add them up to get the total cost
    of translating to all target languages. The code is given in [Listing 5-20](ch05.xhtml#ch05ex020).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 5-20: The minimum total cost*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The task is impossible if any of the target languages is not reachable ➊. Otherwise,
    we print the total cost that we accumulated ➋.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re ready to submit to the judge. Sabasa!
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We wrote gobs of code in this chapter. Of course, I hope that the code offers
    you a starting point for solving your own graph problems. In the long term, though,
    what I hope you remember is the importance of modeling as an early step in the
    problem-solving process. Couching a problem in terms of BFS collapses the domains
    of knights and ropes and translations into the single domain of graphs. Searching
    Google for “how to climb a rope” will get you nowhere (except perhaps up a real
    rope). Searching for “breadth-first search” will instead offer as many code samples
    and explanations and examples as you’re willing to read. If you read comments
    left by programmers on the judges’ websites, you’ll see that they communicate
    on the level of algorithms, not on the level of problem-specific aspects. Often,
    they’ll just say “BFS Problem” to get their point across. You’re learning this
    language of modeling and how to go from the model to working code. There’s more
    graph-modeling coming up in the next chapter, where we tackle weighted graphs
    in their full generality.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Knight Chase is originally from the 1999 Canadian Computing Competition. Rope
    Climb is originally from the 2018 Woburn Challenge, Online Round 1, Senior Division.
    Book Translation is originally from the 2016 East Central North America Regional
    Programming Contest.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a trick that we can use to cut down the code we have to write when
    considering multiple, similar moves in a BFS. Feel free to check out how that
    works in “Knight Chase: Encoding Moves” in [Appendix B](app02.xhtml).'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned all about BFS in this chapter, but if you continue with graph algorithms
    you might like to study *depth-first search* (DFS) as well. I recommend *Algorithms
    Illuminated (Part 2): Graph Algorithms and Data Structures* by Tim Roughgarden
    (2018) for more on BFS, DFS, and other graph algorithms.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
