<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="199" id="Page_199"/>12</span><br/>
<span class="ChapterTitle">Creating Simulations and Games</span></h1>
</header><figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<h2 id="h1-501645c12-0001" class="HeadProject"><span><span epub:type="pagebreak" title="200" id="Page_200"/>Sketch 89: Predator-Prey Simulation</span></h2>
<p class="BodyFirst">Picture rabbits and coyotes living together in their natural environment. They don’t get along in the traditional sense: coyotes tend to eat rabbits when they can. Rabbits can breed very quickly, whereas coyotes cannot. And, of course, if rabbits are the only prey, then if the rabbits should all perish, the coyotes will also, soon after. This is a <span class="KeyTerm">predator-prey</span> relationship, and it can be simply modeled when there is only one species in each group.</p>
<p>Mathematically the predator-prey relationship is represented by a pair of <span class="KeyTerm">differential equations</span> (don’t worry, very little actual math here) that look like this:</p>
<figure class="graphic center">
<img src="Images/c12eq001.png" alt="c12eq001" width="118" height="110"/></figure>
<p>Here <span class="GraphicInline"><img src="Images/c12i001.png" alt="c12i001" width="20" height="52"/></span>  represents how fast the coyote population is growing, and <span class="GraphicInline"><img src="Images/c12i002.png" alt="c12i002" width="20" height="52"/></span> is how fast the rabbit population is growing. The solution to these equations, known as the Lotka-Volterra equations, is not important. The program will simulate them. In these equations, the variables are as follows:</p>
<ol class="none">
<li><em>x</em>: The number of rabbits (prey animals)</li>
<li><em>y</em>: The number of coyotes (predator species)</li>
<li>α: The rate at which the rabbit population grows, unfettered</li>
<li>β: The rate at which prey and predators meet and a rabbit dies as a result</li>
<li>γ: The rate of death of predators due to natural causes or moving away</li>
<li>δ: The rate of growth of the predator population</li>
</ol>
<p>The simulation will begin with specified values of the four variables α, β, γ, and δ, (<code>alpha</code>, <code>beta</code>, <code>gamma</code>, and <code>delta</code>) and will have known initial population sizes. It will then compute a new population each time <code>draw()</code> executes, based on the preceding equations. This is the critical code for the rabbits <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>dr = alpha*Nrabbits - beta*Nrabbits*Ncoyotes;        
Nrabbits = (int)(Nrabbits + dr);</code></pre>
<p>And for the coyotes <span class="CodeAnnotation" aria-label="annotation4">4</span>:</p>
<pre><code>dc<sub> </sub>= delta*Nrabbits*Ncoyotes - gamma*Ncoyotes;
Ncoyotes = (int)(Ncoyotes + dc);</code></pre>
<p>The populations are then rendered graphically in the window. We draw each rabbit as a green circle someplace on the screen (position does not matter) <span class="CodeAnnotation" aria-label="annotation1">1</span>, and each coyote is a red circle <span class="CodeAnnotation" aria-label="annotation2">2</span>. We can observe the relative populations increase and decrease as the predator population and the prey population change. If all of the prey die, the predators do too; if all of the predators die, the prey grows without limit.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>int Nrabbits=190, Ncoyotes=16;
float time=0, alpha=.19, beta=0.008, gamma=0.15, delta=.0005;

void setup ()
{
  size (500, 500);
  frameRate(2);
  noStroke();
}

void draw ()
{
  background(200);
  fill (0,200,0);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> for (int i=0; i&lt;Nrabbits; i++)
    ellipse (random(width),random(height),2,2);
  fill (200,0,0);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> for (int i=0; i&lt;Ncoyotes; i++)
    ellipse (random(width),random(height),4,2);
  prey(); 
  predator();  
}

void prey ()
{
  float dr=0.0;
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> dr = alpha*Nrabbits - beta*Nrabbits*Ncoyotes;

  Nrabbits = (int)(Nrabbits + dr);
  if(Nrabbits&lt;0) Nrabbits = 0;
  fill(0); 
  text ("  Rabbits = "+Nrabbits, 10, 25);
}

void predator ()
{
  float dc=0.0;
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> dc = delta*Nrabbits*Ncoyotes - gamma*Ncoyotes;
  Ncoyotes = (int)(Ncoyotes + dc);
  fill (0); 
  text (" Coyotes now "+Ncoyotes, 150, 25);
}</code></pre>
<span epub:type="pagebreak" title="201" id="Page_201"/><figure class="graphic"><img src="Images/g089001.png" alt="g089001" width="417" height="417"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c12-0002" class="HeadProject"><span><span epub:type="pagebreak" title="202" id="Page_202"/>Sketch 90: Flocking Behavior</span></h2>
<p class="BodyFirst">Craig Reynolds created a system he called Boids in 1986. It was a simulation of the behavior of birds when in a flock, or fish in a school. A <span class="KeyTerm">flock</span> is a collection of distinct objects of the same kind. They move, and wish to end up in the same place. They also don’t wish to hit each other. The simulation involves knowing where each object is, how fast it is moving, and what direction it is traveling, and then updating the position of each object iteratively. Three rules make the objects a flock:</p>
<ol class="none">
<li><span class="RunInHead">Separation</span>  Objects try to maintain a small distance between themselves and their neighbors. During each iteration, an object moves away (if possible) from any neighbor nearer than a distance <em>d</em>. </li>
<li><span class="RunInHead">Alignment</span>  Objects try to match velocities with nearby objects. This keeps them moving in a similar direction and keeps them from spreading out too much. We compute a local velocity as seen from the object and then add a fraction of that to the object’s velocity for the next iteration.</li>
<li><span class="RunInHead">Cohesion</span>  An object will try to move toward the center of mass of its neighbors. This keeps them in a group. We find the center of mass, not including the current object itself, and move the object a fraction (1 percent to 3 percent) of the way toward that point.</li>
</ol>
<p>Each position is stored as a vector (<code>PVector</code> object) that has an x and y component. The vector array <code>FlockV</code> stores the velocity of each object. The <code>draw()</code> function calls functions that move and then draw the flock. <code>match()</code> computes a new velocity, trying to match neighbors <span class="CodeAnnotation" aria-label="annotation2">2</span>; <code>toCenter()</code> moves each object toward the center of mass <span class="CodeAnnotation" aria-label="annotation3">3</span>; and <code>away()</code> attempts to keep the spacing between objects <span class="CodeAnnotation" aria-label="annotation4">4</span>. We call each of the three for each object during each iteration. Each of these functions returns a value that we add to the object’s position <span class="CodeAnnotation" aria-label="annotation1">1</span>. Objects are small circles, and they will follow the mouse as we move it. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Read more about Craig Reynolds at <a href="https://www.red3d.com/cwr/" class="LinkURL">https://www.red3d.com/cwr/</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>final int N = 42;
PVector flock[]=new PVector[N], 
flockV[]=new PVector[N];

void setup ()
{
  size (500,400);
  for (int i=0; i&lt;N; i++)
  {
   flock[i]= new PVector(random(width),
     random(height));
   flockV[i] = new PVector(0, 0, 0); 
  }
  noStroke(); fill (255); frameRate(15);
}

void draw ()
{  
   background (0);   
   drawFlock();  
   moveFlock();
 }

void drawFlock ()
{
   for (int i=0; i&lt;N; i++) 
         ellipse(flock[i].x, flock[i].y, 5,5); 
}

void moveFlock ()
{
  PVector c = new PVector(0,0);
  for (int i=0; i&lt;N; i++) 
  {
    c = toCenter (i);   
    c.add(away(i));  
    c.add(match(i));
    flockV[i].add(c);  
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> flock[i].add(flockV[i]);
    flockV[i].normalize(); 
    flockV[i].mult(6);
  }  
}

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> PVector match (int b)
{
  PVector c=new PVector (0,0);
  for (int i=0; i&lt;N; i++)
    if (i!=b) c.add(flockV[i]);
  c.div(N-1);  
  c.sub(flockV[b]);  
  c.div(8);
  return c;
}

<span class="CodeAnnotationHang" aria-label="annotation3">3</span> PVector toCenter (int b)
{
  PVector c = new PVector(0,0,0);
  for (int i=0; i&lt;N; i++)     // Find center of mass
        if (i!=b) c.add(flock[i]);
  c.div(N-1);  
  c.sub(flock[b]);  
  c.x -= 2*(flock[b].x-mouseX);   
  c.y -= 2*(flock[b].y-mouseY);
  c.normalize(); 
  return c;
}

<span class="CodeAnnotationHang" aria-label="annotation4">4</span> PVector away (int b)
{
  PVector r=new PVector (0,0),q=new PVector
    (flock[b].x, flock[b].y);
  for (int i=0; i&lt;N; i++)
    if (flock[b].dist(flock[i]) &lt; 100) 
    {  
        q.set(flock[b]);  
        q.sub(flock[i]); 
        r.sub(q);    
    }
  r.normalize(); 
  r.mult(-.5);
  return r;
}</code></pre>
<span epub:type="pagebreak" title="203" id="Page_203"/><figure class="graphic"><img src="Images/g090001.png" alt="g090001" width="520" height="416"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c12-0003" class="HeadProject"><span><span epub:type="pagebreak" title="204" id="Page_204"/>Sketch 91: Simulating the Aurora</span></h2>
<p class="BodyFirst">Among objects that are difficult to render on a computer, the northern lights, or aurora, is near the top of the list. They flicker and roll, the colors change, the shape changes at various speeds, and they generally have no one specific shape. There have been efforts to draw them with more or less success; this sketch is one of those attempts.</p>
<p>There are many shapes that the aurora can take, and we will only attempt to draw one of those in this sketch: the typical curtain type, one example of which appears in <a href="#figure91-1" id="figureanchor91-1">Figure 91-1</a>.</p>
<figure>
<img src="Images/f091001.png" alt="f091001" class="" width="694" height="459"/>
<figcaption><p><a id="figure91-1">Figure 91-1</a>: Red and green aurora</p></figcaption>
</figure>
<p>The sketch will make the color change slowly as a function of y position. Starting with a red value at the bottom of the auroral curtain, the hue will increase in pixels above. Starting with a hue value of <code>h</code>=15, the hue increases according to this equation <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>h = h + random(.87);</code></pre>
<p class="BodyContinued">Thus, the hue increases at a random rate, but it always increases as the y-coordinate changes. At the very top of the curtain, the brightness will decrease, fading the color away.</p>
<p>Next, notice that the aurora appears to consist of vertical strokes and is banded horizontally. This is accomplished in the program by changing the saturation of the pixels periodically as a function of the x-coordinate <span class="CodeAnnotation" aria-label="annotation1">1</span>. This is the code, where <code>i</code> is the horizontal position and <code>s</code> is the saturation:</p>
<pre><code>if (i%3 == 0) s = 220+random(20)-10;
else if (i%2 == 0) s = 210+random(20)-10;
else s = 200+random(20)-10;</code></pre>
<p class="BodyContinued"><code>i%3</code> is the remainder when <code>i</code> is divided by 3, so there is a somewhat random variation in the saturation, giving darker bands.</p>
<p><span epub:type="pagebreak" title="205" id="Page_205"/>The curtain effect is accomplished using a sine function to locate the pixels vertically. For a basic coordinate (<code>i</code>, <code>j</code>) the actual pixel will be at <code>(i,j-bb*sin(a*i))</code>, where the parameters <code>a</code> and <code>bb</code> change by a small and random amount during each iteration <span class="CodeAnnotation" aria-label="annotation3">3</span>. This makes the curtain move.</p>
<p>The visual effect is enhanced using a pair of images. An image of stars is used as a background, mimicking the night sky. We draw the aurora over this, followed by a foreground image of trees and shrubs. This image is a <span class="KeyTerm">stencil</span>, with black objects on a transparent background. The result is a pleasing interpretation of the aurora, although it is far from perfect, and much work could be done to improve the realism. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>float a=.02, bb=10;
PImage foreground, background;
void setup ()
{
  foreground=loadImage("trees.gif");
  background=loadImage("stars.jpg");
  size (400, 224);
  colorMode(HSB);
}

void draw ()
{
  float h, s, b=250, dt=0;
  image (background, 0, 0);
  for (int i=0; i&lt;390; i++)
  {
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> if (i%3 == 0) s = 220+random(20)-10;
    else if (i%2 == 0) s = 210+random(20)-10;
    else s = 200+random(20)-10;
    h = 15;
    for (int j=130; j&gt;30; j--)
    {
      if (j&lt;=100) dt = (100-j)*3;
      else dt = 0;
      stroke (h, s, b, 200-dt);
     <span class="CodeAnnotationHang" aria-label="annotation2">2</span>  h = h + random(.87);
     <span class="CodeAnnotationHang" aria-label="annotation3">3</span>  point (i,j-bb*sin(a*i));
    }
    a = a + random(0.001)-0.0005;
    bb = bb + random(1)-0.5;
    if (bb&gt;16) bb = 15;
    if (bb&lt;-10) bb = 0;
    if (a&lt;-0.1 || a&gt;0.1) a = 0;
  }
  image (foreground, 0, 0);
}</code></pre>
<figure class="graphic"><img src="Images/g091001.png" alt="g091001" width="515" height="289"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c12-0004" class="HeadProject"><span><span epub:type="pagebreak" title="206" id="Page_206"/>Sketch 92: A Dynamic Advertisement</span></h2>
<p class="BodyFirst">On video screens all over the world, we see public advertising. In airports, shopping malls, and even schools, promotional material of all kinds is presented to a captive audience. Video is a convenient medium, since the price of large plasma and LCD screens has dropped below $10 per inch. Video is a more dynamic medium as well, allowing ads that move and multiple presentations in sequence, something that printed posters and billboards can’t do.</p>
<p>The technology connected with video ads is well known too (Biteable Ad Maker, InVideo, even Adobe Premiere), and it’s available on the computer desktop. This sketch is one example of a simple advertisement—for a Tex-Mex restaurant. It is loosely based on a collection of actual video presentations seen in airports in North America.</p>
<p>First we need a good image of the subject (the product): a burrito. The image used here is publicly available (<a href="https://commons.wikimedia.org/wiki/File:Carne-asada-burrito.jpg" class="LinkURL">https://commons.wikimedia.org/wiki/File:Carne-asada-burrito.jpg</a>), but in general such images are professional photographs taken at high resolution. In the sketch, this image is 800×431 pixels. We reduce it to a smaller size, 770×401, or 30 pixels smaller in each dimension. This is so we can slowly move the image for a more dynamic presentation.  We display the image using this statement <span class="CodeAnnotation" aria-label="annotation1">1</span>, where <code>xoff</code> and <code>yoff</code> are pixel offsets for positioning the image before display:</p>
<pre><code>image (ad1, xoff, yoff);</code></pre>
<p class="BodyContinued">These offsets change in each frame by a small amount, up to a maximum of 30 pixels, at which time the displacement reverses direction <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>xoff += dx; yoff += dy;
if (xoff &lt;= -30 || xoff &gt; 0) dx = -dx;
if (yoff &lt;= -30 || yoff &gt; 0) dy = -dy;</code></pre>
<p>The values of <code>dx</code> and <code>dy</code> are very small, 0.05 and 0.03 respectively. They differ in value so that the image appears to move in a vaguely elliptical manner.</p>
<p>The text is displayed over the image in a fixed position, reinforcing the motion of the image. The text at the bottom remains the same throughout, but the text at the top changes. The implementation has two stages: if the variable <code>stage = 0</code>, we display the first text string (“It takes us hours to make it”) <span class="CodeAnnotation" aria-label="annotation3">3</span>. After 850 frames (about 28 seconds) have passed, we increment the variable <code>stage</code>, and as a result we display the second string (“It takes you five minutes to eat it”) <span class="CodeAnnotation" aria-label="annotation4">4</span>. After 900 more frames, <code>stage</code> becomes 1 again and the cycle repeats.</p>
<p>We could allow an arbitrary number of stages to allow for the presentation of multiple distinct messages and images, and in a random sequence.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PImage ad1;
float xoff=0, yoff=0;
float dx=-.05, dy=.03;
int stage = 0, count = 0;

void setup ()
{
  size(100,100);
  surface.setResizable(true);
  ad1 = loadImage ("burrito.jpg");
  surface.setSize (ad1.width-30, ad1.height-30);
}

void draw ()
{
  noStroke();
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> image (ad1, xoff, yoff);
  xoff += dx; yoff += dy;

  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (xoff &lt;= -30 || xoff &gt; 0) dx = -dx;
  if (yoff &lt;= -30 || yoff &gt; 0) dy = -dy;
  fill (150, 150, 90);
  rect (0, height-50, width, 90);
  triangle (width-260, height, width, height-120, width, height);
  fill(200);
  textSize(30);
  text ("Organically raised, no additives. Only the best.", 40, height-20);

  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (stage == 0)
  {
    fill (30);
    text ("It takes us hours to make it.", 40, 90);
    count += 1;
    if (count &gt; 850)
    {   count = 0; stage = 1; }
  } else if (stage == 1)
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> {
    fill (30, 100, 100);
    text ("It takes you five minutes to eat it.", 40, 90);
    count += 1;
    if (count &gt; 900)
    {  count = 0; stage = 0;
    }
  }
}</code></pre>
<span epub:type="pagebreak" title="207" id="Page_207"/><figure class="graphic"><img src="Images/g092001.png" alt="g092001" width="440" height="239"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c12-0005" class="HeadProject"><span><span epub:type="pagebreak" title="208" id="Page_208"/>Sketch 93: Nim</span></h2>
<p class="BodyFirst">Nim is a game so old that its origins are lost to history. It was likely invented in China, and it is one of the oldest games known. It was also one of the first games to have a computer or electronic implementation and has been the frequent subject of assignments in computer programming classes. The game starts with three rows of objects, such as matches or coins, and there are a different number of objects in each row. A player may remove as many objects from one row as they choose, but they must remove at least one and must take them only from one row. Players take turns removing objects, and the player taking the final one is the winner.</p>
<p>This sketch will implement the game using 9, 7, and 5 coins, and it will play one side.</p>
<p>Setting the stage for the game play involves reading an image for the object, in this case a penny, and drawing the correct number of them in the window. When the human player clicks the mouse over one of the coins, that coin and all of the coins to the left are removed, and the remaining ones will move left. Then the computer will remove some coins. </p>
<p>There are three rows 100 pixels apart, so when the player clicks the mouse, the row index is simply <code>i = (mouseY/100)-1</code>. The number of coins removed is the number of coins to the left, which in the case of the sketch is <code>j = (mouseX-10)/45+1</code> because of how we drew them (45 pixels apart, indented 10 from the left) <span class="CodeAnnotation" aria-label="annotation1">1</span>. An array named <code>val</code> contains the number of coins in each row, so when the user clicks the mouse, this is the action <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>val[i] = val[i] - j;</code></pre>
<p class="BodyContinued">This reduces the number of coins in row <code>(mouseY/100)-1</code> by <code>(mouseX-10)/45+1</code>. </p>
<p>Then it is the computer’s turn. There is a strategy that will permit the computer to almost always win, as long as the user makes the first move. It involves computing a <span class="KeyTerm">parity</span> value and making a move to ensure that we maintain that parity value. Consider the initial state and the state after taking two coins from row 1:</p>
<table id="tabular-501645c12-0001" border="1"><tbody>
<tr>
<td/>
<td><b>Before</b></td>
<td><b>After</b></td>
</tr>
<tr>
<td><b>Row 1</b></td>
<td><code>5 = 0 1 0 1</code></td>
<td><code>3 = 0 0 1 1</code></td>
</tr>
<tr>
<td><b>Row 2</b></td>
<td><code>7 = 0 1 1 1</code></td>
<td><code>7 = 0 1 1 1</code></td>
</tr>
<tr>
<td><b>Row 3</b></td>
<td><code>9 = 1 0 0 1</code></td>
<td><code>9 = 1 0 0 1</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td><b>Parity</b></td>
<td><code>    1 0 1 1</code></td>
<td><code>    1 1 0 1</code></td>
</tr>
</tbody>
</table>
<p>The parity is determined by looking at each digit in the binary representation of the values. In each column position, the parity bit for that column is 1 if the number of 1 bits in the column is odd and 0 if it is even. We can calculate this using the <span class="KeyTerm">exclusive OR</span> operator, which in Processing is “<code>^</code>”, like so: <code>val[0]^val[1]^val[2]</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>The strategy in Nim is to make a move that makes the parity value 0. It turns out that this is always possible; in the preceding situation, the computer might remove 5 coins from row 3 giving this state:</p>
<table id="tabular-501645c12-0002" border="1"><tbody>
<tr>
<td><b>Row 1</b></td>
<td><code>3 = 0 0 1 1</code></td>
</tr>
<tr>
<td><b>Row 2</b></td>
<td><code>7 = 0 1 1 1</code></td>
</tr>
<tr>
<td><b>Row 3</b></td>
<td><code>4 = 0 1 0 0</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td><b>Parity</b></td>
<td><code>    0 0 0 0</code></td>
</tr>
</tbody>
</table>
<p>This is what the sketch does after every move the player makes: computes the parity of all possible moves until it finds one with 0 parity <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PImage piece; 
int val[] = {5, 7, 9}, i, j;

void setup ()
{
  size (500, 400);
  piece = loadImage ("coin.gif");
  frameRate (0.5);
}

void draw ()
{
  background (0);
  for (int j=0; j&lt;3; j++)
    for (int i=0; i&lt;val[j]; i=i+1)
      <span class="CodeAnnotationHang" aria-label="annotation1">1</span> image (piece, i*45+10, (j+1)*100);
}

void mouseReleased ()
{
  i = (mouseY/100)-1; j = (mouseX-10)/45+1;
  if (i&lt;0) return;
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (j&lt;=val[i]) val[i] = val[i] - j;
  draw(); move();
  if (val[0]+val[1]+val[2] == 0) 
  { draw(); text ("Computer wins.",20,300); 
    noLoop(); return; 
  }
}

<span class="CodeAnnotationHang" aria-label="annotation3">3</span> int eval() { return val[0]^val[1]^val[2]; }
  
void move()
{ 
  if (val[0]+val[1]+val[2] == 0) 
  { text ("You Win.",20,300); noLoop(); return; }
  for(int i=0; i&lt;3; i++)
    for (int j=1; j&lt;=val[i]; j++)
    {
      val[i] = val[i] - j;
      if (  <span class="CodeAnnotationHang" aria-label="annotation4">4</span>eval() == 0) return;
      val[i] = val[i] + j;
    }
  text ("Computer resigns- you win.", 20, 300); 
  noLoop(); 
}</code></pre>
<span epub:type="pagebreak" title="209" id="Page_209"/><figure class="graphic"><img src="Images/g093001.png" alt="g093001" width="424" height="339"/></figure>
<figure class="graphic"><img src="Images/g093002.png" alt="g093002" width="424" height="338"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c12-0006" class="HeadProject"><span><span epub:type="pagebreak" title="210" id="Page_210"/>Sketch 94: Pathfinding </span></h2>
<p class="BodyFirst"><span class="KeyTerm">Pathfinding</span> amounts to finding a route from one place to another in two or three dimensions. Potential routes could be blocked by walls, rivers, wires, or a host of other obstacles. Of course, it is the <em>best</em> route that is desired, where “best” can be based on many factors, such as physical distance, time, or cost. In circuit design, we use pathfinding to create a connection between circuit elements. In computer games, it finds a path to get a game object from one place to another. This sketch will implement a basic pathfinding method in two dimensions.</p>
<p>The method begins at some initial point, (<em>x</em>, <em>y</em>), and there is a destination or target point to be reached, (<em>x</em><sub>t</sub>, <em>y</em><sub>t</sub>). Each neighbor (<em>x</em><sub><em>n</em></sub>, <em>y</em><sub><em>n</em></sub>) of (<em>x</em>, <em>y</em>) is <em>marked</em> with its distance to (<em>x</em>, <em>y</em>). Then we look at the neighbors of those locations (<em>x</em><sub><em>n</em></sub>, <em>y</em><sub><em>n</em></sub>) and mark those locations with the distance to (<em>x</em>, <em>y</em>) by adding the distance to the neighbor (<em>x</em><sub><em>n</em></sub>, <em>y</em><sub><em>n</em></sub>) to the distance of (<em>x</em><sub><em>n</em></sub>, <em>y</em><sub><em>n</em></sub>) to (<em>x</em>, <em>y</em>). We keep repeating this until we find ourselves at the target pixel (<em>x</em><sub>t</sub>, <em>y</em><sub>t</sub>). Now we know the distance to the start pixel, and the best route can be traced backward following the connected locations having the smallest marked value. A neighbor must be an open space, not an obstacle, in order to be marked, so the route will never pass through obstacles.</p>
<p>The program begins by reading in an image on which obstacles appear in black and the background is white. The start and end positions of the path are specified in the program as x, y coordinates: <code>startx</code>, <code>starty</code>, and <code>endx</code>, <code>endy</code> (you can change these to find a different path). </p>
<p>Beginning at the start coordinates, we examine the immediately neighboring pixels <span class="CodeAnnotation" aria-label="annotation1">1</span>. The neighbors of any pixel are the ones to the left, right, above, or below. The distance between pixels (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>) and (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>) is therefore |<em>x</em><sub>0</sub> – <em>x</em><sub>1</sub>| + |<em>y</em><sub>0</sub> – <em>y</em><sub>1</sub>| and is an integer. The distance between the start pixel and its neighbors is 1. This way of measuring distance is called <span class="KeyTerm">Manhattan distance</span>; you could adapt the pathfinding method to use other distance measurements as well.</p>
<p>If one of the neighbors is the end of the path, the search is complete <span class="CodeAnnotation" aria-label="annotation2">2</span>; otherwise we color the pixel a shade of cyan proportional to its distance from the start point. We use the red component of the RGB color as the distance, so as the red increases, the color gets brighter. We could instead use a separate 2D array to store distances, especially if floating-point distances are required, such as when calculating Euclidean distances. </p>
<p>Next, we examine all pixels that have the red value 1 (those that are a distance 1 from the start) in the same way, and set their neighbors to 2. Then we set their neighbors to 3, and so on until we reach the end location.</p>
<p>At this point, the distance to the start point is <em>N</em>. To trace a route back to the start, we look for a neighbor of the end location that has a value of <em>N</em> − 1; any one will do. Mark that location as being on the route, and look for a neighbor of that location that has a value of <em>N</em> − 2; mark it and repeat. At any moment there will be many pixels having a particular value, but only ones connected to the path are interesting. The path is complete when we reach the start location. The <code>drawRoute()</code> function searches the neighbors of the end pixel for a neighbor with a value of <em>N</em>, marks that pixel with a specific color, and then recursively finds a neighbor of that pixel, marks it, and so on <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>set (i,j,color(0,100,200)); 
drawRoute (i,j,n-1);  </code></pre>
<p>The result is that a path is drawn on the displayed image.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The colors indicate distance in this sketch only to illustrate the method. This would not be done in an actual application. Also, this method is generally too slow for many applications, and better (and more complex) algorithms exist. The most commonly used method is the <span class="KeyTerm">A* algorithm</span>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>int startx=20, starty=20; 
int endx=99, endy=73;
PImage back;
int stage = 1, n=1;

void setup ()
{
  size (200, 200);
  back = loadImage("plan.png");
  back.set(startx, starty, color(1,1,1));
  image(back, 0, 0);
}

void draw ()
{
  if (stage == 1) step();
  else 
    if (drawRoute(endx, endy, n-1)) noLoop();
}
void step ()
{
  for (int i=0; i&lt;width; i++)
    for (int j=0; j&lt;height; j++)
      if (red(get(i,j)) == n) 
      {
        <span class="CodeAnnotationHang" aria-label="annotation1">1</span> if(red(get(i-1,j))&gt;n) set(i-1,j,color(n+1, 255, 255));
        if(red(get(i+1,j))&gt;n) set(i+1,j,color(n+1, 255, 255));
        if(red(get(i,j-1))&gt;n) set(i,j-1,color(n+1, 255, 255));
        if(red(get(i,j+1))&gt;n) set(i,j+1,color(n+1, 255, 255));
        <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (i==endx &amp;&amp; j==endy) { stage = 2; return; }
      }
  n=n+1;
}
boolean drawRoute (int x, int y, int n)
{
  for (int i=x-1; i&lt;=x+1; i++)
    for (int j=y-1; j&lt;=y+1; j++)
      if (red(get(i,j)) == n) 
        { 
          <span class="CodeAnnotationHang" aria-label="annotation3">3</span> set (i,j,color(0,100,200)); 
          drawRoute (i,j,n-1);  
          return true; 
        }
    return false;
}</code></pre>
<span epub:type="pagebreak" title="211" id="Page_211"/><figure class="graphic"><img src="Images/g094001.png" alt="g094001" width="465" height="467"/></figure>
<figure class="graphic"><img src="Images/g094002.png" alt="g094002" width="465" height="464"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c12-0007" class="HeadProject"><span><span epub:type="pagebreak" title="212" id="Page_212"/>Sketch 95: Metaballs—A Lava Lamp</span></h2>
<figure>
<img src="Images/f095001.png" alt="f095001" class="" width="333" height="336"/>
<figcaption><p><a id="figure95-1">Figure 95-1</a>: A lava lamp (shown in motion online: <a href="https://en.wikipedia.org/wiki/File:Lava_lamp_(oT)_07_ies.ogv" class="LinkURL">https://en.wikipedia.org/wiki/File:Lava_lamp_(oT)_07_ies.ogv</a>)</p></figcaption>
</figure>
<p class="BodyFirst">This sketch represents an attempt to create a dynamic graphical simulation of a lava lamp, a popular item from the 1960s (see <a href="#figure95-1" id="figureanchor95-1">Figure 95-1</a>). Most North Americans will recognize one, because they have undergone a resurgence in popularity, perhaps due to an interest in retro furnishings. The lamp is a glass container filled with oil. There is an incandescent lamp at the bottom and some colored wax. When the lamp heats up, it melts the wax, and globules slowly rise to the top, changing shape. Cooling globules fall to the bottom, creating a dynamic visual effect as the smooth wax shapes interact.</p>
<p>Each blob in the lamp seems to move on its own, so we’ll use a collection of points with x, y coordinates that form the center of each blob, and these points can move about in a 2D area. We’ll create the actual blob in an interesting way: each one is a 3D function, and we’ll render a 2D view looking down at the part of the 3D blobs that have z (height) values greater than a threshold, like an aerial view of an island sticking out of the water (<a href="#figure95-2" id="figureanchor95-2">Figure 95-2</a>). These 3D functions are referred to as <span class="KeyTerm">isosurfaces</span> or <span class="KeyTerm">metaballs</span>.</p>
<figure>
<img src="Images/f095002.png" alt="f095002" class="" width="428" height="147"/>
<figcaption><p><a id="figure95-2">Figure 95-2</a>: How the threshold slices the 3D function</p></figcaption>
</figure>
<p>As two metaballs get close to each other, the height of the area where they intersect is the sum of the two objects, and as they get nearer, this region will exceed the z threshold, so it will appear in the 2D rendering (<a href="#figure95-3" id="figureanchor95-3">Figure 95-3</a>). This creates the illusion of wax blobs interacting.</p>
<figure>
<img src="Images/f095003.png" alt="f095003" class="" width="460" height="186"/>
<figcaption><p><a id="figure95-3">Figure 95-3</a>: How the metaballs add up to produce a blob</p></figcaption>
</figure>
<p>We will use a simple function for the metaball: a sphere, as defined by the function named <code>equation()</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>. It defines a pixel value at any point <code>x</code>, <code>y</code> with respect to a sphere <code>k</code> at some other point, as follows:</p>
<pre><code>radius[k] / sqrt( (xx-x[k])*(xx-x[k]) + (yy-y[k])*(yy-y[k]) ) );</code></pre>
<p><span epub:type="pagebreak" title="213" id="Page_213"/>This sketch has six spheres defined by arrays <code>x</code> and <code>y</code>, and they move as defined by arrays <code>dx</code><b> </b>and <code>dy</code>. The <code>setup()</code> function initializes the six spheres. The first one is quite large, does not move, and lies at the bottom of the region to simulate the large wax reservoir at the bottom of most lamps <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<p>The <code>draw()</code> function calculates the sum of all spheres at any point in the drawing area <span class="CodeAnnotation" aria-label="annotation2">2</span>. In many instances this will be zero, but as the balls get nearer, the sum increases and becomes visible if it is greater than the threshold <code>MINT</code>. Visible pixels will be drawn as green, and the background will be yellow. The balls are moved each iteration <span class="CodeAnnotation" aria-label="annotation3">3</span> and can change size randomly <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>int maxMetaballs = 6;
float x[] = new float[maxMetaballs];
float y[] = new float[maxMetaballs];
float dx[] = new float[maxMetaballs];
float dy[] = new float[maxMetaballs];
float radius[] = new float[maxMetaballs];
float MINT = 1.4f, MAXT = 50f;

void setup ()
{
  size(500, 500);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> for (int i=0; i&lt;maxMetaballs; i=i+1) radius[i] = -1;
  x[0] = 250; y[0] = 850; radius[0] = 400; 
  x[1] = 100; y[1] = 300; radius[1] = 20; dx[1] = 0; dy[1] = -0.55;
  x[2] = 120; y[2] = 100; radius[2] = 30; dx[2] = 0.01; dy[2] = 0.57;
  x[3] = 90;  y[3] = -330; radius[3] = 23; dx[3] = -0.01; dy[3] = 0.32;
  x[4] = 320; y[4] = -650; radius[4] = 19; dx[4] = 0.01; dy[4] = 0.4;
  x[5] = 230; y[5] = -800; radius[5] = 24; dx[5] = -0.01; dy[5] = 0.42;
}

void draw () 
{ 
  float sum;
  background(230, 220, 40, 90); 
  for(int yy = 0; yy &lt; height; yy++) 
    for(int xx = 0; xx &lt; width; xx++) 
    {
      sum = 0; 
      <span class="CodeAnnotationHang" aria-label="annotation2">2</span> for(int i = 0; i &lt; maxMetaballs &amp;&amp; radius[i] &gt; 0; i++) 
        sum += equation(xx,yy,i);
      if(sum &gt;= MINT &amp;&amp; sum &lt;= MAXT) 
        set(xx, yy, color(0,170,50,100));  
    } 
  for (int i=1; i&lt;maxMetaballs; i=i+1)
  { 
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (radius[i] &gt;0) 
    {
      y[i] += dy[i]; 
      if (y[i]&gt;height+6*radius[i] || (y[i]&lt;-3*radius[i])&amp;&amp;(dy[i]&lt;0))
      { dy[i] = -dy[i]; x[i] += random (10)-5; }
    }
    ellipse (x[i], y[i], 3, 3);
  }
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> if (random(500)&lt; 2) radius[(int)random (maxMetaballs)] += random (1)-0.5;
}

  <span class="CodeAnnotationHang" aria-label="annotation5">5</span> float equation(float xx, float yy, int k) 
{ return (radius[k] / sqrt( (xx-x[k])*(xx-x[k]) + (yy-y[k])*(yy-y[k]) ) ); }</code></pre>
<figure class="graphic"><img src="Images/g095001.png" alt="g095001" width="285" height="286"/></figure>
<figure class="graphic"><img src="Images/g095002.png" alt="g095002" width="285" height="285"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c12-0008" class="HeadProject"><span><span epub:type="pagebreak" title="214" id="Page_214"/>Sketch 96: A Robot Arm</span></h2>
<p class="BodyFirst">The word <span class="KeyTerm">robot</span> is often associated with a human-shaped mechanical device, but by far the most common robots are more restricted devices with a single function and a small range of motion. An example would be the kind of robot that welds joints or paints cars in factories. These frequently look like an arm, complete with multiple joints and some kind of tool at the end of the arm where the hand would be. This sketch allows a user to move a 2D simulated robot arm using key presses.</p>
<p>The robot in the simulation is typical of the type described, such as the commercially available PUMA. It consists of three linked segments, each of which can be rotated at the joint, as shown in <a href="#figure96-1" id="figureanchor96-1">Figure 96-1</a>. The joints are the shoulder (jangle1), joined by the bicep to the elbow (jangle2), joined by the forearm to the wrist (jangle3), which connects to the hand. The user controls the angles subtended by the joints using keys: jangle1 is controlled by <span class="KeyCaps">Q</span> and <span class="KeyCaps">E</span>, jangle2 by <span class="KeyCaps">A</span> and <span class="KeyCaps">D</span>, and jangle3 by <span class="KeyCaps">Z</span> and <span class="KeyCaps">C</span>.</p>
<figure>
<img src="Images/f096001-r.png" alt="f096001-r" class="" width="423" height="294"/>
<figcaption><p><a id="figure96-1">Figure 96-1</a>: Three linked segments forming a robot arm</p></figcaption>
</figure>
<p>We’ll represent each arm section by an image. The axis of rotation is not the upper-left corner or the center of the image but instead is a point in the image where the joint is connected to the previous one. The angle for any joint is increased by pressing one key and decreased by another, but because they are connected to each other, the rotations must be relative to the previous section. The rotations are computed from the shoulder down to the hand. Then the hand is drawn at the final rotated location (all three rotations), the forearm is drawn at the location previous (two rotations), and finally the bicep after its rotation. This is accomplished using the Processing functions <code>pushMatrix()</code> and <code>popMatrix()</code>: the shoulder joint is rotated and then the state pushed <span class="CodeAnnotation" aria-label="annotation1">1</span>; the elbow is rotated and pushed <span class="CodeAnnotation" aria-label="annotation2">2</span>; the wrist is rotated and drawn. Then we restore the previous state, draw the bicep <span class="CodeAnnotation" aria-label="annotation3">3</span>, and then perform one more restoration.</p>
<p>The images that represent the arm parts must be analyzed and the results coded into the program as coordinates. For example, consider the elbow: this is where the bicep (<code>armA</code> in the code) meets the forearm (<code>armB</code> in the code). The point where they meet has an offset from both images by a different amount, as shown in <a href="#figure96-2" id="figureanchor96-2">Figure 96-2</a>. For the bicep, the point of contact is (167, 37) as measured from its upper left. The connection to the forearm is at (31, 25) relative to the forearm image, which is its axis of rotation as well. So, to rotate the forearm, we first translate it by (−31, −25) so that it appears to rotate about the correct place. The forearm must be translated when drawn so that the connection on the bicep at (167, 37) aligns with the connection on the forearm at (31, 25), so the next translation is (167 − 30, −(37 − 24)), or (137, −13). We reverse the sign on the y-coordinate because the direction of y is reversed from the usual y-axis <span epub:type="pagebreak" title="215" id="Page_215"/>in mathematics. The coordinates of each connection point are obtained from the images, and if they change, the points will have to be remeasured.</p>
<figure>
<img src="Images/f096002-r.png" alt="f096002-r" class="" width="661" height="149"/>
<figcaption><p><a id="figure96-2">Figure 96-2</a>: The connection points between the arm segments</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>float jangle1=-40, jangle2=22, jangle3=90;
PImage armA, armB, armC;
void setup () 
{
  size(500, 500);  
  armA = loadImage ("robotA.gif");
  armB = loadImage ("robotB.gif");
  armC = loadImage ("robotC.gif");
  fill (200, 200, 110);
}

void draw () 
{
  background(100, 100, 100, 1);
  makeArm();
}

void makeArm ()
{
  translate (100, 400);
  rect (0, 0, 100, 100);
  translate (50, 40);
  pushMatrix();
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> translate (-31, -37); rotate (radians(jangle1));
  pushMatrix();
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> translate (137, -13); rotate(radians(jangle2));
  pushMatrix();
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> translate (137, -11); rotate (radians(jangle3));
  translate (-16, -15); image (armC, 0, 0);
  popMatrix();
  translate (-30, -25); image(armB, 0, 0);
  popMatrix();
  translate (-31, -37); image (armA, 0, 0);
  popMatrix();
}
void keyPressed ()
{
  if (key=='q') jangle1 = jangle1-1;
  if (key=='e') jangle1 = jangle1+1;
  if (key=='a') jangle2 = jangle2-1;
  if (key=='d') jangle2 = jangle2+1;
  if (key=='z') jangle3 = jangle3-1;
  if (key=='c') jangle3 = jangle3+1;
}</code></pre>
<figure class="graphic"><img src="Images/g096001.png" alt="g096001" width="425" height="256"/></figure>
<figure class="graphic"><img src="Images/g096002.png" alt="g096002" width="425" height="424"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c12-0009" class="HeadProject"><span><span epub:type="pagebreak" title="216" id="Page_216"/>Sketch 97: Lightning</span></h2>
<p class="BodyFirst">Lightning moves quickly, randomly, and brightly. It would seem to be a difficult thing to capture in a computer graphic sense, and yet because it is in everyone’s experience, there are situations where it would be important to be able to draw lightning. This sketch is a basic attempt to do that.</p>
<p>As was the situation with the auroral simulation of Sketch 91, there is a history and literature on the subject of drawing lightning, and a lot of it is based on an effort to model the physical process by which lightning occurs in the real world. This is too complex to reproduce in a small program, but some of the fruits of that work can be useful. Researchers have measured the angle between a streak of lightning and a branch, for instance (about 16 degrees), and also the likelihood of a branch.</p>
<p>This sketch will generate random lightning shapes as small, connected line segments. The length of the segment and an angle from the previous one will be random. A 2D array will hold the various segments for the main and branching parts. The main part is a sequence of line segments in the first part of the array: a line segment with starting point <code>x[0][i]</code> and <code>y[0][i]</code> connected to segment endpoint <code>x[0][i+1]</code>, <code>y[0][i+1]</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. A branch will occur at random, with probability 0.11 <span class="CodeAnnotation" aria-label="annotation2">2</span>, and it will occupy another row of the array, the first branch starting at <code>x[1][0]</code>, <code>y[1][0]</code>, the second at <code>x[2][0]</code>, <code>y[2][0]</code>, and so on.</p>
<p>A branch can also terminate, with probability 0.2 <span class="CodeAnnotation" aria-label="annotation3">3</span>, but the main branch cannot. It will continue until it reaches a y value greater than 205, where it terminates <span class="CodeAnnotation" aria-label="annotation4">4</span>. A new lightning stroke will occur later, at a random time and x location <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>Each time <code>draw()</code> is called, a new section of each stroke is created and drawn, so the lightning is a dynamic display. It appears to descend from the top of the image down to the ground, or to the water in this case: a background image of a storm at sea is displayed, and the lightning appears to start in the clouds and strike the water.</p>
<p>This scheme has some flaws. Sometimes, at random, strokes can appear in what a human would consider an unrealistic way. Branches can pass over each other, sometimes more than once. This <em>could</em> occur in real life, but it does not happen very often. A lightning path usually has a surrounding glow, too, and this is missing from the sketch. Lightning is also a source of illumination and would alter the ambient light in the scene. It is possible to reproduce this effect, but using a static image as the background makes it difficult to change the illumination. Finally, we add to the lightning strokes iteratively and, once they are determined to a specific point, do not change. Lightning paths have been seen to move along their length, not just at the lower end, but the effect is subtle.</p>
<p>The code offers chances for experimentation. We can alter the probabilities of the creation of a new branch or of an existing one being deleted. The length of each section, now random between 0 and 12, and the angle, random between −30 and +30 degrees, can also have a significant visual impact on the result.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PImage back;
float x[][] = new float [40][600];
float y[][] = new float [40][600];
int n[] = new int [40], m=0, count=0;
void setup ()
{
  size(100,100);
  surface.setResizable(true);
  back = loadImage ("back.jpg");
  surface.setSize (back.width, back.height);
  m=1; n[0] = 1;
  x[0][0] = 30; x[0][1] = 35;
  y[0][0] = 43; y[0][1] = 47;
}
void draw ()
{
  float a, d;
  stroke (250,255, 250,128);
  image (back, 0, 0);
  if (count&lt;=0)
    if (random(300) &lt; 2)
    {
      m=1; x[0][0] = random(width); x[0][1] = x[0][0];
      y[0][0] = random(50)+12; y[0][1] = y[0][0]; n[0] = 1; count=1;
    }
  for (int i=0; i&lt;m; i++)
    for (int j=0; j&lt;n[i]; j++)   // Draw existing
      if (x[i][0]&gt;0) line (x[i][j], y[i][j], x[i][j+1],y[i][j+1]);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> for (int i=0; i&lt;m; i++)        // Grow existing
  {
    a = random (60)+60; d = random (12);
    if (x[i][0] &lt; 0) continue;
    x[i][n[i]+1] = x[i][n[i]]+d*cos(radians(a));
    y[i][n[i]+1] = y[i][n[i]]+d*sin(radians(a));
    n[i] = n[i] + 1;
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (random (1)&lt;0.11)         // New branch
    {
      a = random (60)+60; d = random (12);
      x[m][0] = x[i][n[i]-1]; y[m][0] = y[i][n[i]-1];
      x[m][1] = x[i][n[i]-1]; y[m][1] = y[i][n[i]-1];
      n[m] = 1; m = m + 1;
    }
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (i!=0 &amp;&amp; random(1) &lt; 0.20) for (int j=0; j&lt;600; j++) x[i][j] = -1;
  }
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> if (y[0][n[0]-1] &gt; 205) { m=0; count = -1; }
}</code></pre>
<span epub:type="pagebreak" title="217" id="Page_217"/><figure class="graphic"><img src="Images/g097001.png" alt="g097001" width="263" height="585"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c12-0010" class="HeadProject"><span><span epub:type="pagebreak" title="218" id="Page_218"/>Sketch 98: The Computer Game Breakout</span></h2>
<p class="BodyFirst">The original game Breakout was designed and built in 1975 by legendary early builder of games Nolan Bushnell, Steve Wozniak (later of Apple fame), and Steve Bristow at Atari. In basic concept, it is a variation on Pong for one player, where the paddle is used to bounce a ball into bricks that vanish when hit. The original game has eight rows of rectangular bricks, with pairs of rows having the same color. The ball bounces off the sides and top of the game screen, and off a brick after it disappears, but is free to pass through the bottom. The player must move the paddle to hit the downward-moving ball to prevent it from disappearing. The player has three turns (that is, they can miss the ball three times) to clear the screen of bricks, and different colored bricks score a different number of points.</p>
<p>This sketch will implement a simplified version of the game. There are three rows of red bricks, all worth the same amount. There is no sound and no high score. The bricks are filled rectangles, 30 pixels by 15 pixels, and the ball is simply a small circle, 3 pixels across. A 2D array, <code>exists[][]</code>, is used to keep track of which bricks have been eliminated, and the brick in row <code>i</code> column <code>j</code> will be drawn if <code>exists[i][j]</code> is true. Drawing the bricks is therefore simple <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>for (int i=0; i&lt;Ncols; i++)  // Draw all bricks
  for (int j=0; j&lt;Nrows; j++)
    if (exists[i][j]) rect (i*30+20, j*15+30, 30, 15);</code></pre>
<p>The ball is drawn at location <code>(x, y)</code> and is moved during each frame by an amount <code>(dx, dy)</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. The paddle is simply a line drawn centered at <code>(px, py)</code>. Typing the <span class="KeyCaps">A</span> key moves the paddle left by 10 pixels (<code>px=px-10</code>), and typing <span class="KeyCaps">D</span> moves it right by the same amount. If the ball moves past the coordinate <code>py</code> (= 300) and its <code>x</code> value is between <code>px</code> − 30 and <code>px</code> + 30, then the ball changes y-direction (<code>dy=-dy</code>) and it appears to bounce. The ball also bounces off the top of the screen (<code>y==0</code>) and the sides (<code>x&lt;0</code> or <code>x&gt;width</code>). </p>
<p>We test the ball against each brick for a collision during each frame; this is done using the absolute coordinates of each brick. If the brick at (i, j) exists, then these are the brick boundaries: </p>
<table id="tabular-501645c12-0003" border="1"><tbody>
<tr>
<td><b>Dimension</b></td>
<td><b>Coordinate value</b></td>
<td><b>Boundary</b></td>
<td><b>Coordinate value</b></td>
<td><b>Boundary</b></td>
</tr>
<tr>
<td>X</td>
<td>i*30+20</td>
<td>Left edge</td>
<td>i*30+50</td>
<td>Right edge</td>
</tr>
</tbody>
<tbody>
<tr>
<td>Y</td>
<td>j*15+30</td>
<td>Top edge</td>
<td>j*15+45</td>
<td>Bottom edge</td>
</tr>
</tbody>
</table>
<p>Simply check the ball’s coordinates against these values for every brick, and bounce if the ball is inside the brick <span class="CodeAnnotation" aria-label="annotation3">3</span>, at the same time setting <code>exists[i][j]</code> to <code>false</code> and increasing the <code>score</code>.</p>
<p>After the ball falls past the bottom, we decrement <code>life</code> and the ball is redrawn at a random <code>x</code> location at <code>y</code> value 150. The game is over when either the value of <code>life</code> is 0 or the <code>score</code> is the maximum of 36.</p>
<p>This simple version has flaws. The bounce off of the bricks is not dependent on the side of the brick that was hit; the y-direction of the ball is always changed. The bounce off the paddle is always the same, no matter where the point of impact.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code><span epub:type="pagebreak" title="219" id="Page_219"/>final int Ncols = 12, Nrows = 3;
boolean exists [][] = new boolean[Ncols][Nrows];
int x, y, dx, dy, px, py, score = 0, life=5;
int direction = 0;
void setup ()
{
  size (400, 400);  fill (200, 40, 40);
  for (int i=0; i&lt;Ncols; i++)  // All bricks exist
    for (int j=0; j&lt;Nrows; j++) exists[i][j] = true;
  x = (int)random(300)+100; y = 150;  // Random X 
    start
  dx=1; dy=-2; px = 120; py = 300; // Initial paddle 
    position
}

void draw ()
{
  background(200);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> for (int i=0; i&lt;Ncols; i++)  // Draw all bricks
    for (int j=0; j&lt;Nrows; j++)
      if (exists[i][j]) rect (i*30+20, j*15+30, 30, 
        15);
  line (px-30, py, px+30, py);    // Paddle
  ellipse (x, y, 3, 3); move();   // Ball
  text ("Score: "+score+"           Lives remaining: 
    "+life,20,350);
  if (score&gt;=36) text (" YOU WIN!",100, 300);
  else if (life &lt;= 0) 
  {  
    text (" YOU LOSE!",100, 300); 
    noLoop(); // Win or lose.
  }
}
void keyPressed ()  // Use the 'a' and 'd' keys to 
  move the paddle
{
  if (key == 'a' &amp;&amp; px &gt; 30) direction = -4; 
  else if (key == 'd' &amp;&amp; px&lt;width-30) direction = 4; 
  else direction = 0;
}  

void keyReleased ()
{
  direction = 0;
}

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> void move ()  // Move the ball

{
  x = x + dx; y = y + dy;  // Basic move
  px = px + direction;
  if (x&lt;2|| x&gt;width-2) dx = -dx;  // X bounce?
  if (y&gt;=py-1&amp;&amp;y&lt;=py+1 &amp;&amp; (x&gt;=px-30&amp;&amp;x&lt;=px+30)) dy = 
    -dy;  // Paddle bounce
  if (y&lt;0) dy = -dy;  //  Y bounce top
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> for (int i=0; i&lt;Ncols; i++)  // Ball hits a brick
    for (int j=0; j&lt;Nrows; j++) 
      if(exists[i][j] &amp;&amp; x&gt;=i*30+20 &amp;&amp; y&gt;=j*15+30 &amp;&amp;
        x&lt;=i*30+50 &amp;&amp; y&lt;=j*15+45)
      {
        exists[i][j] = false;  // Brick is destroyed
        dy = -dy; score++;     // Ball bounces, score
      }
  if (y&gt;height)  // Ball through the bottom
  { 
    if (score &lt; 36) life--;  y=150;  // Lose a life, 
      restart the ball 
    x = (int)random(width-100+50);
  }
}      </code></pre>
<figure class="graphic"><img src="Images/g098001.png" alt="g098001" width="466" height="492"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c12-0011" class="HeadProject"><span><span epub:type="pagebreak" title="220" id="Page_220"/>Sketch 99: Midpoint Displacement—Simulating Terrain</span></h2>
<p class="BodyFirst">This sketch will generate a pseudo-random terrain profile, with a darkening sky and twinkling stars. The heart of this sketch is the <span class="KeyTerm">midpoint displacement</span> method for generating terrain, and while this example is only two-dimensional, it illustrates the more general algorithm pretty well.</p>
<p>The method starts with a line, which in the case of this sketch is a line that runs horizontally across the entire image. Next we select the midpoint of the line, displace it by a random value between <code>dy</code> and <code>–dy</code>, and create two lines as in <a href="#figure99-1" id="figureanchor99-1">Figure 99-1</a>.</p>
<figure>
<img src="Images/f099001.png" alt="f099001" class="" width="446" height="190"/>
<figcaption><p><a id="figure99-1">Figure 99-1</a>: Splitting a line</p></figcaption>
</figure>
<p>Then we do the same thing again with the two lines just created, except we decrease the value of <code>dy</code>. The result is four lines. Each time we generate a new line pair, the resulting segments can be split again using a smaller <code>dy</code> value until some termination criterion is reached. In the sketch, the initial value of <code>dy</code> is 75, and the splitting process ceases when it becomes smaller than 2. </p>
<p>The splitting process is accomplished by a recursive procedure, <code>md()</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>:</p>
<pre><code>void md (float x0, float y0, float x1, float y1, float dy)</code></pre>
<p class="BodyContinued">Here, (<code>x0</code>, <code>y0</code>) and (<code>x1</code>, <code>y1</code>) are the line segment endpoints, and <code>dy</code> is the maximum value of the random height change. This procedure finds the midpoint and calls itself twice, passing the left and right halves of the line and a smaller <code>dy</code>. The process continues as illustrated in <a href="#figure99-2" id="figureanchor99-2">Figure 99-2</a> until we reach the minimum <code>dy</code> value. </p>
<p>The line endpoints are then saved in an array pair, <code>lx[]</code> and <code>ly[]</code>. We don’t actually draw the line segments but make a filled region by drawing a line from each endpoint down to the bottom of the window that is as thick as half of the line segment x width <span class="CodeAnnotation" aria-label="annotation3">3</span>. The result is a horizon line with a convincing random nature.</p>
<figure>
<img src="Images/f099002.png" alt="f099002" class="" width="538" height="336"/>
<figcaption><p><a id="figure99-2">Figure 99-2</a>: Multiple recursive splits create a realistic horizon.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="221" id="Page_221"/>The sky is a set of horizontal lines starting at a color of (50, 50, 240) and decreasing by 1 in the blue value for every two lines drawn <span class="CodeAnnotation" aria-label="annotation1">1</span>. This produces a nice deep blue gradient in the sky.</p>
<p>The stars are simply small circles drawn in random locations, but they must appear in the same place during each frame, so the arrays <code>starx[]</code> and <code>stary[]</code> hold their locations. They don’t exactly twinkle, but we draw them with a probability of 99 percent so that once in a while one of the stars is not drawn during a particular frame <span class="CodeAnnotation" aria-label="annotation2">2</span>. During any one frame it is likely that at least one star has gone dark. The overall effect is that of an evening sky and a rural landscape.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>int starx[]=new int[50], stary[]=new int[50];
float lx[]=new float[1000], ly[]=new float[1000];
int n=0;
void setup () 
{
  size(640, 480);
  fill (255);
  for (int i=0; i&lt;50; i++)
  {
    starx[i] = (int)random(width); 
    stary[i] = (int)random(height/2);
  }
  md(0,300,width, 300, 75.0);  
}
 
void draw () 
{
  for (int i=0; i&lt;height; i++)
  {
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> stroke(50, 50, (float)(height-i)/2);
    line (0,i, width, i);
  }
  noStroke();
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> for (int i=0; i&lt;50; i++)
    if (random(1)&lt;0.99) ellipse (starx[i], stary[i], 2, 2);
  stroke(0); strokeWeight(lx[1]-lx[0]+1);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> for (int i=0; i&lt;n; i=i+1)  
    line (lx[i],ly[i], lx[i],height);
}

  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> void md (float x0, float y0, float x1, float y1, float dy)
{
  if (dy &lt; 2)
  {
    lx[n] = x0; ly[n] = y0;
    lx[n+1] = x1; ly[n+1] = y1;
    n = n + 2;
  } else
    {
      float d = random(dy+dy)-dy;
      md (x0,y0, x0+(x1-x0)/2, y0+(y1-y0)/2-d, .6*dy); 
      md (x0+(x1-x0)/2, y0+(y1-y0)/2-d, x1, y1, .6*dy);
    }
}</code></pre>
<figure class="graphic"><img src="Images/g099001.png" alt="g099001" width="348" height="261"/></figure>
<figure class="graphic"><img src="Images/g099002.png" alt="g099002" width="347" height="259"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</section>
</div></body></html>