<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch7" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch7">
<span class="CN"><span aria-label=" Page 93. " epub:type="pagebreak" id="pg_93" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">CONTROLLING AC MAINS POWER OUTLETS</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">In this chapter, you’ll learn to safely control mains AC power outlets using various forms of automation and remote control. This technique lets you easily manipulate devices such as lamps, fans, and pumps from a distance, without any direct connection to the mains power wiring.</p>
<p class="TX">You’ll learn to:</p>
<ul class="ul">
<li class="BL">Use optocouplers to isolate electrical signals</li>
<li class="BL">Hack a wireless AC mains remote-control transmitter and connect it to an Arduino circuit</li>
<li class="BL">Create a timer-controlled wireless AC mains outlet</li>
<li class="BL">Control AC mains outlets remotely with SMS text messages</li>
</ul>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-50"/><span aria-label=" Page 94. " epub:type="pagebreak" id="pg_94" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Optocouplers</samp></h2>
<p class="TNI">An <i>optocoupler</i> is a small device that allows the transmission of a signal between parts of a circuit while keeping those two parts electrically isolated. Inside a typical optocoupler are an LED and a phototransistor, a device that responds to light by amplifying an electric current. When a current runs through the LED, it switches on; the phototransistor detects the light and allows another current to flow through it. When the LED is off, current cannot flow through the phototransistor. The two currents are completely electrically isolated throughout the process.</p>
<p class="TX"><a href="chapter7.xhtml#fig7-1">Figure 7-1</a> shows the schematic symbol for an optocoupler.</p>
<figure class="IMG"><img alt="THE SCHEMATIC SYMBOL FOR A TYPICAL OPTOCOUPLER" class="img3" id="fig7-1" src="../images/fig7-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: The schematic symbol for a typical optocoupler</samp></p></figcaption>
</figure>
<p class="TX">In the schematic, an LED is connected to pins 1 (the anode) and 2 (the cathode). Pins 4, 5, and 6 are the phototransistor, while pin 3 is not used. The optocoupler model you’ll use, the 4N28, is in a six-pin dual in-line (DIL) package, as shown in <a href="chapter7.xhtml#fig7-2">Figure 7-2</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF A 4N28 OPTOCOUPLER INSERTED INTO A SOLDERLESS BREADBOARD" class="img8" id="fig7-2" src="../images/fig7-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: A 4N28 optocoupler inserted into a solderless breadboard</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 95. " epub:type="pagebreak" id="pg_95" role="doc-pagebreak"/>To use the optocoupler, you’ll need a current-limiting resistor for the LED. You’ll use 1 k<span lang="el" xml:lang="el">Ω</span> for this chapter. Connect the circuit to switch on or off across pins 4 and 5. If you’d like to experiment with an optocoupler, build the circuit shown in <a href="chapter7.xhtml#fig7-3">Figure 7-3</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR AN OPTOCOUPLER DEMONSTRATION CIRCUIT" class="img8" id="fig7-3" src="../images/fig7-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: An optocoupler demonstration circuit</samp></p></figcaption>
</figure>
<p class="TX">When SW<sub>1</sub> is closed, current runs through the resistor R<sub>1</sub>, and the LED inside the optocoupler illuminates. This in turn triggers the photoresistor, which allows current to flow through from pin 5 to pin 4, turning on LED D<sub>1</sub>. Pin 3 on the optocoupler is not electrically connected. This makes the optocoupler a switch of sorts, without any electrical or mechanical contact between the two sides of the switch.</p>
<p class="TX">You’ll use optocouplers to interface with the transmitter of the wireless remote AC outlet in the following projects.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-51"/><samp class="SANS_Futura_Std_Bold_B_11">Remote-Control AC Outlets</samp></h2>
<p class="TNI">Inexpensive wireless remote-control AC outlets, like the one shown in <a href="chapter7.xhtml#fig7-4">Figure 7-4</a>, allow you to safely control mains power. In <a href="chapter7.xhtml#fig7-4">Figure 7-4</a>, the transmitter is on the right, and the receiver outlet is on the left.</p>
<figure class="IMG"><img alt="A PHOTO OF THE EXAMPLE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER AND RECEIVER" class="img5" id="fig7-4" src="../images/fig7-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: A typical wireless remote-control AC outlet</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 96. " epub:type="pagebreak" id="pg_96" role="doc-pagebreak"/>The transmitter needs separate on and off buttons for control. Try to find one with as much space as possible between the buttons; the farther apart they are, the easier it will be to hack into the transmitter unit in Project #22, allowing you to connect it to an Arduino circuit to control the power outlet. You can find these units from the usual retailers, such as Amazon, Walmart, and so on.</p>
<p class="Warning"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">WARNING</samp></span></p>
<p class="NOTE-TXT"><i>Under no circumstances are you to open or modify the receiver unit containing the mains outlet, as exposing yourself to mains wiring can be lethal.</i></p>
<p class="TX">To work through this chapter, I recommend buying two sets of controls: one to experiment with (so you don’t need to worry too much about breaking it) and another to use for the project.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-52"/><samp class="SANS_Futura_Std_Bold_B_11">Hacking the Outlet Transmitter</samp></h2>
<p class="TNI">This section explains how to hack into your wireless transmitter to control it via an Arduino. I’ll show you with a series of photographs how I hacked into my remote, and you can use these guidelines to experiment with your remote to achieve the same goal. This requires some soldering and de-soldering, so be sure you’re equipped with a hobbyist 20 to 50 W soldering iron, hand tools such as side-cutters, and some de-soldering wick.</p>
<p class="TX">Transmitters will be slightly different in shape, size, and so on, but make sure the one you purchase runs from a little 12 V A23-style battery and has separate on and off buttons, as noted earlier. Before doing any damage to the unit, insert the battery and test it to get an idea of how far between the transmitter and receiver in which you can use the outlet. <a href="chapter7.xhtml#fig7-5">Figure 7-5</a> shows the battery in my transmitter.</p>
<figure class="IMG"><img alt="A PHOTO OF A BATTERY INSIDE A WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER" class="img6" id="fig7-5" src="../images/fig7-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: The battery in a wireless remote-control transmitter</samp></p></figcaption>
</figure>
<p class="TX">Check for any screws or tabs you can use to pop the transmitter enclosure apart, and open it, as shown in <a href="chapter7.xhtml#fig7-6">Figure 7-6</a>.<span aria-label=" Page 97. " epub:type="pagebreak" id="pg_97" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A PHOTO OF INSIDE THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER" class="img6" id="fig7-6" src="../images/fig7-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: The wiring inside the wireless remote-control transmitter</samp></p></figcaption>
</figure>
<p class="TX">This should reveal the PCB for the circuit, along with the buttons used to control the outputs. Carefully remove the PCB to check whether it looks possible to de-solder some of the buttons; if not, reassemble the unit and return it to your retailer. You should be able to de-solder buttons on any transmitters that fit the specs described earlier in this section, but it’s best to make sure, for example, that they’re the type that have buttons with through-hole pins.</p>
<p class="TX">You’ll also need to connect power. If there are already wires running from the battery holder to the PCB, like those shown in <a href="chapter7.xhtml#fig7-7">Figure 7-7</a>, carefully cut off or de-solder them using the solder wick from the battery holder ends.</p>
<figure class="IMG"><img alt="A PHOTO OF INSIDE THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER AND THE PCB PULLED OUT" class="img6" id="fig7-7" src="../images/fig7-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-7: The power wires in the PCB</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 98. " epub:type="pagebreak" id="pg_98" role="doc-pagebreak"/>Next, identify the PCB pads that contain the pins of the on and off buttons for the first (or only) outlet in the system by locating the buttons and then finding their matching pins on the other side of the PCB. Viewing the buttons from the bottom of the PCB (the side with the copper tracks), match the buttons’ pins to the PCB pads.</p>
<p class="TX">In our example, the PCB uses standard tactile buttons with four legs, two for each contact. In <a href="chapter7.xhtml#fig7-8">Figure 7-8</a>, I’ve drawn lines between the pads of each side of the tactile switch to note which PCB pads I needed to de-solder.</p>
<figure class="IMG"><img alt="A PHOTO OF THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER PCB MARKED TO SHOW WHICH PCB TRACKS TO MODIFY" class="img8" id="fig7-8" src="../images/fig7-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-8: The transmitter PCB with button pins separated out with a black marker</samp></p></figcaption>
</figure>
<p class="TX">Once you’ve located the PCB pads for the on and off buttons, de-solder the pins, ideally using some solder wick, as shown in <a href="chapter7.xhtml#fig7-9">Figure 7-9</a>. Be careful not to overheat and destroy the pads.</p>
<figure class="IMG"><img alt="A PHOTO OF DE-SOLDERING BUTTONS FROM THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER PCB" class="img8" id="fig7-9" src="../images/fig7-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-9: De-soldering buttons from the transmitter</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 99. " epub:type="pagebreak" id="pg_99" role="doc-pagebreak"/>Now gently pry the buttons out from the PCB. This will leave you with some blank button spaces, as shown in <a href="chapter7.xhtml#fig7-10">Figure 7-10</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER PCB WITH TWO BUTTONS REMOVED" class="img8" id="fig7-10" src="../images/fig7-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-10: The transmitter PCB with control buttons removed</samp></p></figcaption>
</figure>
<p class="TX">In these empty holes, solder in some jumper wires long enough to reach from the transmitter PCB to a solderless breadboard. I’ve chopped the ends from some preformed jumpers for easy connections to external circuitry, as shown in <a href="chapter7.xhtml#fig7-11">Figure 7-11</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER PCB WITH NEW WIRES REPLACING BUTTONS" class="img8" id="fig7-11" src="../images/fig7-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-11: Modified wiring on the transmitter PCB</samp></p></figcaption>
</figure>
<p class="TX">It’s time to check the operation of the transmitter PCB. Connect 12 V to the power leads and short out the on and off wire pairs in turn to check the receiver still switches on and off. If it doesn’t, the (now removed) buttons <span aria-label=" Page 100. " epub:type="pagebreak" id="pg_100" role="doc-pagebreak"/>may have formed part of the circuit—that is, both button contacts for each side were used as a PCB track connection. This happened with my example buttons, so I placed a short wire across the side of the button and soldered it into the PCB, as shown in <a href="chapter7.xhtml#fig7-12">Figure 7-12</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF WIRES BRIDGING PCB PADS ON THE REMOTE CONTROL AC OUTLET TRANSMITTER PCB" class="img8" id="fig7-12" src="../images/fig7-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-12: Adding links to the transmitter’s button pads</samp></p></figcaption>
</figure>
<p class="TX">Give the system another test if necessary. If it’s successful, cover the link wires’ joints with some hot glue so they don’t come off by accident later, as shown in <a href="chapter7.xhtml#fig7-13">Figure 7-13</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF HOT GLUE PUT OVER THE SOLDER JOINTS ON THE WIRELESS REMOTE CONTROL PCB" class="img8" id="fig7-13" src="../images/fig7-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-13: Protecting the extra soldered links with hot glue</samp></p></figcaption>
</figure>
<p class="TX">You now have a transmitter PCB that can be controlled by an Arduino and an external optocoupler circuit. Let’s put it to work.</p>
<p class="HeadProject"><span id="h1-53"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #22: Controlling the Transmitter Board</samp></p>
<p class="TNI">This project briefly demonstrates controlling a hacked transmitter board, which will give you the framework to control the outlet in your own projects. You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A 12 V DC, 1A power supply, wall wart, or plugpack (if you like, you can use the DC socket breakout described for <span class="Xref">Project #19 in <a href="chapter6.xhtml">Chapter 6</a></span>)</li>
<li class="BL">A hacked wireless outlet transmitter and receiver from the previous section</li>
<li class="BL">Two 1 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL"><span aria-label=" Page 101. " epub:type="pagebreak" id="pg_101" role="doc-pagebreak"/>Two 4N28 optocouplers</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Various jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter7.xhtml#fig7-14">Figure 7-14</a>.</p>
<figure class="IMG"><img alt="SCHEMATIC FOR PROJECT #22" class="img1" id="fig7-14" src="../images/fig7-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-14: The schematic for Project #22</samp></p></figcaption>
</figure>
<p class="TX">The TX_On and TX_Off pairs in the schematic represent the wiring to the transmitter PCB control buttons, and TX_12VDC+ and <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp> represent the 12 V power leads to the transmitter PCB. As the 12 V DC is supplying the entire circuit, the power to the Arduino is via the Vin pin. Arduino pins D2 and D3 are used to turn the transmitter on and off.</p>
<p class="TX">Now upload the Project #22 sketch. After a few moments, the mains outlet should repeatedly switch on and off around every five seconds.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-22"/>

<pre><code>// Project #22 - Mains outlet control with Arduino

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> void mainsOff()
{
    digitalWrite(3, HIGH);
    delay(1000);
    digitalWrite(3, LOW);
}

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> void mainsOn()
{
    digitalWrite(2, HIGH);
    delay(1000);
    digitalWrite(2, LOW);
}

void setup()
{
    delay(1000);
    pinMode(2, OUTPUT);
    pinMode(3, OUTPUT);
}

<span aria-label=" Page 102. " epub:type="pagebreak" id="pg_102" role="doc-pagebreak"/>void loop()
{
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> mainsOn(); // AC mains on
    delay(5000);
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> mainsOff(); // AC mains off
    delay(5000);
}
</code></pre>

<p class="TX">To control the transmitter, the sketch simply closes the contacts for the on and off switches, now represented by the optocouplers, with the functions at <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The delay in these functions ensures the transmitter has activated long enough to trigger the receiver unit.</p>
<p class="TX">The delay in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> helps to test the circuit, as otherwise the transmitter would sometimes turn on immediately when power was applied to the Arduino. You should leave this delay in your own projects to avoid unnecessary or unwanted outlet activation.</p>
<p class="TX">Finally, the code demonstrates the control by turning the AC on and off slowly <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. You might connect a lamp or a small fan to the AC outlet to see the effects.</p>
<p class="TX">Keep this project’s hardware together, as you’ll expand upon it in the next project.</p>
<p class="HeadProject"><span id="h1-54"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #23: Controlling the Mains Outlet with a Timer</samp></p>
<p class="TNI">In this project, you’ll use the DS1307 or DS3231 real-time clock IC to build an AC mains outlet that turns on or off at the required point(s) in time. This is a great way to control small irrigation pumps, night lights, alarms, or similar devices.</p>
<p class="TX">To build this project, you’ll need the same hardware setup used in Project #22, along with a DS3231 or DS1307 RTC module or the logging shield used with <span class="Xref">Project #21 in <a href="chapter6.xhtml">Chapter 6</a></span>. Assemble the circuit as shown in <a href="chapter7.xhtml#fig7-15">Figure 7-15</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #23" class="img1" id="fig7-15" src="../images/fig7-15.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-15: The schematic for Project #23</samp></p></figcaption>
</figure>
<p class="TX">Now upload the Project #23 sketch (which should work for either RTC IC you’ve used). Don’t forget to set the time with your current time data <span aria-label=" Page 103. " epub:type="pagebreak" id="pg_103" role="doc-pagebreak"/>using the <samp class="SANS_TheSansMonoCd_W5Regular_11">setDS3231time()</samp> function in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>. Once you’ve updated the time values, uncomment the function, upload the sketch, and then re-comment the function and upload the sketch again. I’ve used the DS3231 library as demonstrated with <span class="Xref">Project #21 in <a href="chapter6.xhtml">Chapter 6</a></span>.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-23"/>

<pre><code>// Project #23 - Timer-controlled mains outlet
#include &lt;Wire.h&gt; <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
#include &lt;DS3231.h&gt;

DS3231 RTC;
bool century = false; <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
bool h12Flag = false;
bool pmFlag = false;
byte year = <var>22</var>;
byte month = <var>9</var>;
byte date = <var>19</var>;
byte hour = <var>21</var>;
byte minute = <var>53</var>;
byte second = <var>0</var>;

void setTimeData()
{
    RTC.setYear(year);
    RTC.setMonth(month);
    RTC.setDate(date);
    RTC.setHour(hour);
    RTC.setMinute(minute);
    RTC.setSecond(second);
    RTC.setClockMode(false); // Set clock to 24 hour
}

void mainsOff()
{
    digitalWrite(3, HIGH);
    delay(1000);
    digitalWrite(3, LOW);
    digitalWrite(13, LOW);
}

void mainsOn()
{
    digitalWrite(2, HIGH);
    delay(1000);
    digitalWrite(2, LOW);
    digitalWrite(13, HIGH);
}

void setup()
{
    mainsOff();
    //setTimeData(); <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> // Set time and date
    Wire.begin();
<span aria-label=" Page 104. " epub:type="pagebreak" id="pg_104" role="doc-pagebreak"/>    pinMode(2, OUTPUT);
    pinMode(3, OUTPUT);
    pinMode(13, OUTPUT);
    digitalWrite(13, LOW);
}

void turnOn(int onHour, int onMinute)
{
    if ((RTC.getHour(h12Flag, pmFlag) == hour) &amp;&amp; (onMinute == RTC.getMinute()))
    {
        mainsOn();
        delay(59100);
    }
}

void turnOff(int offHour, int offMinute)
{
    if ((RTC.getHour(h12Flag, pmFlag) == hour) &amp;&amp; (offMinute == RTC.getMinute()))
    {
        mainsOff();
        delay(59100);
    }
}

void loop()
{
    turnOn(17, 02);
    turnOff(17, 03);
    turnOn(17, 04);
    turnOff(17, 05);
    turnOn(17, 06);
    turnOff(17, 07);
}</code></pre>

<p class="TX">The sketch first includes the I<sup>2</sup>C and RTC libraries and then creates an instance of the real-time clock to reference <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. It then declares the required variables to hold the time and data information <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. These include three Boolean variables, which are left as false by default, since the sketch uses 24-hour time.</p>
<p class="TX">The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">setTimeData()</samp> function contains the functions to set all the time and date parameters. The variables declared earlier are placed in each matching function. This function needs to be called only once <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, as you initially set the time and date and then comment out the function before re-uploading the sketch; otherwise, the clock will reset to the value of the variables.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">mainsOff()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">mainsOn()</samp> functions also use the Arduino’s LED on D13 to indicate the system’s on or off status. For outlet control at a certain time, the two <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOn()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">turnoff()</samp> functions each accept an hour and minute and compare them against the current time.</p>
<p class="TX">If there’s a match, the outlet is turned on or off, respectively, as shown with the examples in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>. You can include as many on or off functions as required; the sketch will continually loop about the functions <span aria-label=" Page 105. " epub:type="pagebreak" id="pg_105" role="doc-pagebreak"/>checking to turn on or off. There is a long delay in both <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOn()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOff()</samp> to stop multiple activations of the transmitter during the times when there is a match of time for on or off.</p>
<p class="TX">For a challenge, you can modify the sketch to allow the user to select the date or day of the week along with the time to turn on or off.</p>
<p class="HeadProject"><span id="h1-55"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #24: Controlling the Mains Outlet with SMS</samp></p>
<p class="TNI">This project takes wireless control to the next level, using the Project #22 hardware in conjunction with a 3G cellular shield to create an AC mains outlet controllable by text message (wherever there’s cell phone service). Doing so is surprisingly simple.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>You may have built similar projects to this in Chapter 22 of</i> <span class="note">Arduino Workshop</span><i>, 2nd edition.</i></p>
<p class="TX">For this project to work, you’ll need access to a cellular network that operates at UMTS (3G) 850 MHz, 900 MHz, 1900 MHz, or 2100 MHz and allows the use of devices not supplied by the network provider. This information should be available from your cellular provider. You will also need a SIM card for your network—prepaid or otherwise—for this shield, in addition to the one already in your phone. Also make sure the requirement to enter a PIN to use the SIM card is turned off. (You should be able to do this by inserting the SIM card into a regular cell phone and changing the setting in the Security menu.)</p>
<p class="TX">This project uses the SIM5320-type 3G GSM shield and antenna shown in <a href="chapter7.xhtml#fig7-16">Figure 7-16</a>. This shield is available from TinySine (<a href="https://www.tinyosshop.com"><i>https://<wbr/>www<wbr/>.tinyosshop<wbr/>.com</i></a>) and its distributors. There are two types of SIM5320 shield, the SIM5320A and SIM5320E. The latter uses the UMTS/HSDPA 900/2100MHz frequency bands (mainly for European users), and the former uses the UMTS/HSDPA 850/1900MHz frequency band (mainly for US-based users and Australians using the Telstra network).</p>
<figure class="IMG"><img alt="A PHOTO OF A 3G CELLULAR SHIELD FOR ARDUINO WITH ANTENNA" class="img5" id="fig7-16" src="../images/fig7-16.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-16: A 3G shield with an antenna</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 106. " epub:type="pagebreak" id="pg_106" role="doc-pagebreak"/>Since these shields require 12 V external power, begin by connecting the power supply you used in earlier projects in this chapter via the Vin and GND pins. To configure pins D2 and D3, which the shield uses with SoftwareSerial to communicate with the Arduino, connect the jumpers over the RX 3 and TX 2 pins, as shown in <a href="chapter7.xhtml#fig7-17">Figure 7-17</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF A 3G CELLULAR SHIELD FOR ARDUINO CONFIGURATION JUMPERS" class="img5" id="fig7-17" src="../images/fig7-17.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-17: Shield serial configuration jumpers</samp></p></figcaption>
</figure>
<p class="TX">Next, turn the shield over and insert your carrier SIM card into the holder, as shown in <a href="chapter7.xhtml#fig7-18">Figure 7-18</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF A SIM CARD HOLDER ON THE 3G SHIELD" class="img8" id="fig7-18" src="../images/fig7-18.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-18: A SIM card in its holder</samp></p></figcaption>
</figure>
<p class="TX">Gently insert the 3G shield into the Arduino. Connect the external power and the USB cable between the Arduino and the PC, then screw in <span aria-label=" Page 107. " epub:type="pagebreak" id="pg_107" role="doc-pagebreak"/>the external antenna. Finally, turn the SIM module on using the power button on the top left of the shield, as shown in <a href="chapter7.xhtml#fig7-19">Figure 7-19</a>. Press the button for two seconds, then let go.</p>
<figure class="IMG"><img alt="A PHOTO OF A 3G CELLULAR SHIELD FOR ARDUINO. ALL THREE LEDS ARE ON FOR POWER, STATUS AND NETWORK ACTIVITY" class="img6" id="fig7-19" src="../images/fig7-19.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-19: The 3G shield power button and status LEDs, which are on for power, status, and network activity</samp></p></figcaption>
</figure>
<p class="TX">The P (for power) and S (for status) LEDs should come on. The blue W (for network activity) LED should start blinking once the 3G shield has registered with the cellular network, meaning you’re ready to use the shield and all is well.</p>
<p class="TX">To build this project, you’ll need the 3G shield you’ve just put together, along with the hardware setup you built in Project #22. Assemble the circuit as shown in <a href="chapter7.xhtml#fig7-20">Figure 7-20</a>. Note that the optocoupler inputs have changed from the pins used in Project #22 to Arduino pins D4 and D5, as we use D2 and D3 for the 3G shield’s serial communications.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #24" class="img1" id="fig7-20" src="../images/fig7-20.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-20: The schematic for Project #24</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 108. " epub:type="pagebreak" id="pg_108" role="doc-pagebreak"/>Enter and upload the following sketch. Once the shield turns on and the blue LED starts blinking, send <samp class="SANS_TheSansMonoCd_W7Bold_B_11">#1</samp> as an SMS to the SIM card’s cellular number. The mains outlet should turn on; send <samp class="SANS_TheSansMonoCd_W7Bold_B_11">#0</samp> to turn it off again. I hope this inspires a brief sense of wonder—these moments make learning and building projects quite enjoyable.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-24"/>

<pre><code>// Project #24 - Setting up an SMS remote control

#include &lt;SoftwareSerial.h&gt;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> SoftwareSerial cell(2, 3);

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> void mainsOff()
{
    digitalWrite(5, HIGH);
    delay(1000);
    digitalWrite(5, LOW);
    digitalWrite(13, LOW);
}

<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> void mainsOn()
{
    digitalWrite(4, HIGH);
    delay(1000);
    digitalWrite(4, LOW);
    digitalWrite(13, HIGH);
}

void setup()
{
    pinMode(5, OUTPUT);
    pinMode(4, OUTPUT);
    pinMode(13, OUTPUT);
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> pinMode(8, OUTPUT);
    mainsOff();
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> digitalWrite(8, HIGH);
    delay(2000);
    digitalWrite(8, LOW);
    cell.begin(4800);
    delay(30000);
  <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> cell.println("AT+CMGF=1");
    delay(200);
  <span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> cell.println("AT+CNMI=3,3,0,0");
    delay(200);
}

void loop()
{
    char inchar;
    if (cell.available() &gt; 0)
    {
        inchar = cell.read();
      <span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> if (inchar == '#')
<span aria-label=" Page 109. " epub:type="pagebreak" id="pg_109" role="doc-pagebreak"/>        {
            delay(10);
            inchar = cell.read();
            if (inchar == '0')
            {
              <span aria-label="annotation9" class="CodeAnnotationCode">❾</span> mainsOff();
            }
            else if (inchar == '1')
            {
              <span aria-label="annotation10" class="CodeAnnotationCode">❿</span> mainsOn();
            }
            delay(10);
            cell.println("AT+CMGD=1,4"); // Delete all SMS
        }
    }
}
</code></pre>

<p class="TX">The sketch initializes the software serial port for communication with the 3G shield <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and then declares the variable used to interrogate incoming data from the shield. The transmitter control functions appear at <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, and the code configures the digital pins in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">Starting at <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, the sketch turns on and configures the 3G shield for use, using the AT command <samp class="SANS_TheSansMonoCd_W5Regular_11">AT+CMGF=1</samp> to convert incoming SMS messages to text and send them to the software serial port <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. Whenever the 3G shield receives a text message, the details are sent to the Arduino via the software serial port, one character at a time <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. The sketch tests each incoming character to see if it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp> <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>; if so, it checks for a <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and then turns the transmitter off <span aria-label="annotation9" class="CodeAnnotationCode">❾</span> or on <span aria-label="annotation10" class="CodeAnnotationCode">❿</span> respectively.</p>
<p class="TX">The shield’s power button is connected to digital pin 8, so you can also control the power from the project sketch, instead of manually turning the button on or off.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-56"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">In this chapter, you learned to safely control mains AC power outlets using various forms of automation and remote control. You can use the knowledge gained to control the AC mains outlet using various sensors, switches, or other inputs or code in your own projects. As long as your input device can control an LED, it can control the AC mains outlet.</p>
<p class="TX">In the next chapter, you’ll use high-power shift registers to build even more interesting control applications.</p>
</section>
</section>
</body>
</html>