<html><head></head><body>
<h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_157"/><strong><span class="big">16</span><br/>INSECURE DIRECT OBJECT REFERENCES</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">An <em>insecure direct object reference (IDOR)</em> vulnerability occurs when an attacker can access or modify a reference to an object, such as a file, database record, account, and so on, that should be inaccessible to them. For example, let’s say the website <em>www.&lt;example&gt;.com</em> has private user profiles that should be accessible only to the profile owner through the URL <em>www.&lt;example&gt;.com/user?id=1</em>. The <span class="literal">id</span> parameter would determine which profile you’re viewing. If you can access someone else’s profile by changing the <span class="literal">id</span> parameter to 2, that would be an IDOR vulnerability.</p>&#13;
<h3 class="h3" id="ch16lev1sec1"><span epub:type="pagebreak" id="page_158"/><strong>Finding Simple IDORs</strong></h3>&#13;
<p class="noindent">Some IDOR vulnerabilities are easier to find than others. The easiest IDOR vulnerability you’ll find is similar to the previous example: it’s one in which the identifier is a simple integer that automatically increments as new records are created. To test for this kind of IDOR, you just add or subtract 1 from an <span class="literal">id</span> parameter and confirm you can access records you shouldn’t have access to.</p>&#13;
<p class="indent">You can perform this testing using the web proxy tool Burp Suite, discussed in <a href="app01.xhtml#app01">Appendix A</a>. A <em>web proxy</em> captures the traffic your browser sends to a website. Burp allows you to monitor HTTP requests, modify them on the fly, and replay requests. To test for IDORs, you can send your request to Burp’s Intruder, set a payload on the <span class="literal">id</span> parameter, and choose a numerical payload to increment or decrement.</p>&#13;
<p class="indent">After starting a Burp Intruder attack, you can see whether you have access to data by checking the content lengths and HTTP response codes Burp receives. For example, if a site you’re testing always returns status code 403 responses that are all the same content length, the site is likely not vulnerable. Status code 403 means access has been denied, so uniform content lengths indicate you’re receiving a standard access denied message. But if you receive a status code 200 response and a variable content length, you might have accessed private records.</p>&#13;
<h3 class="h3" id="ch16lev1sec2"><strong>Finding More Complex IDORs</strong></h3>&#13;
<p class="noindent">Complex IDORs can occur when the <span class="literal">id</span> parameter is buried in a <span class="literal">POST</span> body or is not readily identifiable through the parameter name. You’ll likely encounter unobvious parameters, such as <span class="literal">ref</span>, <span class="literal">user</span>, or <span class="literal">column</span> being used as IDs. Even when you can’t easily pick out the ID by its parameter name, you might identify the parameter if it takes integer values. When you find a parameter that takes an integer value, test it to see how the site behavior changes when the ID is modified. Again, you can use Burp to help make this easy by intercepting HTTP requests, changing the ID, and using the Repeater tool to replay the request.</p>&#13;
<p class="indent">IDORs are even harder to identify when sites use randomized identifiers, such <em>universal unique identifiers (UUIDs)</em>. UUIDs are 36-character alphanumeric strings that don’t follow a pattern. If you discover a site that uses UUIDs, it will be nearly impossible to find a valid record or object by testing random values. Instead, you can create two records and switch between them during your testing. For example, let’s say you’re trying to access user profiles that are identified using a UUID. Create your profile with user A; then log in as user B to try to access user A’s profile using its UUID.</p>&#13;
<p class="indent">In some cases, you’ll be able to access objects that use UUIDs. But a site might not consider this a vulnerability because UUIDs are made to be unguessable. In those cases, you’ll need to look for opportunities where the site is disclosing the random identifier in question. Let’s say you’re on a team-based site and the users are identified by UUIDs. When you invite a user to your team, the HTTP response to the invitation might disclose <span epub:type="pagebreak" id="page_159"/>their UUID. In other situations, you might be able to search for a record on a website and get a returned result that includes the UUID. When you can’t find obvious places where UUIDs are being leaked, review the HTML page source code included in HTTP responses, which might disclose information that isn’t readily visible on the site. You can do this by monitoring requests in Burp or by right-clicking in your web browser and selecting View Page Source.</p>&#13;
<p class="indent">Even if you can’t find a leaked UUID, some sites will reward the vulnerability if the information is sensitive and clearly violates their permission model. It’s your responsibility to explain to the company why you believe you’ve found an issue they should address and what impact you’ve determined the vulnerability has. The following examples demonstrate the range of difficulty in finding IDOR vulnerabilities.</p>&#13;
<h3 class="h3" id="ch16lev1sec3"><strong><a href="http://Binary.com">Binary.com</a> Privilege Escalation</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="http://www.binary.com">www.binary.com</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/98247/">https://hackerone.com/reports/98247/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> November 6, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $300</p>&#13;
<p class="noindent">When you’re testing web applications that use accounts, you should register two different accounts and test them simultaneously. Doing so allows you to test for IDORs between two different accounts you control and know what to expect from. This is the approach Mahmoud Gamal took when discovering an IDOR in <em><a href="http://binary.com">binary.com</a></em>.</p>&#13;
<p class="indent">The website <em><a href="http://binary.com">binary.com</a></em> is a trading platform that allows users to trade currencies, indices, stocks, and commodities. At the time of this report, the URL <em>www.binary.com/cashier</em> would render an iFrame with a <span class="literal">src</span> attribute that referenced the subdomain <em>cashier.binary.com</em> and passed URL parameters, such as <span class="literal">pin</span>, <span class="literal">password</span>, and <span class="literal">secret</span>, to the website. These parameters were likely intended to authenticate users. Because the browser was accessing <em>www.binary.com/cashier</em>, the information being passed to <em>cashier.binary.com</em> wouldn’t be visible without viewing the HTTP requests being sent by the website.</p>&#13;
<p class="indent">Gamal noticed that the <span class="literal">pin</span> parameter was being used as an account identifier and that it appeared to be an easily guessed numerically incremented integer. Using two different accounts, which we’ll refer to as account A and account B, he visited the <em>/cashier</em> path on account A, noted the <span class="literal">pin</span> parameter, and then logged into account B. When he modified account B’s iFrame to use account A’s pin, he was able to access account A’s information and request withdrawals while authenticated as account B.</p>&#13;
<p class="indent">The team at <em><a href="http://binary.com">binary.com</a></em> resolved the report within a day of receiving it. They claimed that they manually reviewed and approved withdrawals, and so they would have noticed suspicious activity.</p>&#13;
<h4 class="h4" id="ch16lev2sec1"><span epub:type="pagebreak" id="page_160"/><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">In this case, a hacker easily tested the bug manually by using a customer pin from one account while logged in as a different account. You can also use Burp plug-ins, such as Autorize and Authmatrix, to automate this type of testing.</p>&#13;
<p class="indent">But finding obscure IDORs can be more difficult. This site was using an iFrame, which can make the vulnerable URL and its parameters easy to miss because you wouldn’t see them in your browser without viewing the HTML page source. The best way to track iFrames and cases where multiple URLs might be accessed by a single web page is to use a proxy like Burp. Burp will record any <span class="literal">GET</span> requests to other URLs, like <em>cashier.binary.com</em>, in the proxy history, making catching requests easier for you.</p>&#13;
<h3 class="h3" id="ch16lev1sec4"><strong>Moneybird App Creation</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://moneybird.com/user/applications/">https://moneybird.com/user/applications/</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/135989/">https://hackerone.com/reports/135989/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> May 3, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $100</p>&#13;
<p class="noindent">In May 2016, I began testing Moneybird for vulnerabilities, focusing on its user account permissions. To do this, I created a business with account A and then invited a second user, account B, to join with limited permissions. Moneybird defines permissions that it assigns to added users, such as the ability to use invoices, estimates, and so on.</p>&#13;
<p class="indent">A user with full permissions could create apps and enable API access. For example, a user could submit a <span class="literal">POST</span> request to create an app with full permissions, which would look like the following:</p>&#13;
<p class="programs">POST /user/applications HTTP/1.1<br/>&#13;
Host: moneybird.com<br/>&#13;
User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:45.0) Gecko/20100101 Firefox/45.0<br/>&#13;
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br/>&#13;
Accept-Language: en-US,en;q=0.5<br/>&#13;
Accept-Encoding: gzip, deflate, br<br/>&#13;
DNT: 1<br/>&#13;
Referer: https://moneybird.com/user/applications/new<br/>&#13;
Cookie: _moneybird_session=REDACTED; trusted_computer=<br/>&#13;
Connection: close<br/>&#13;
Content-Type: application/x-www-form-urlencoded<br/>&#13;
Content-Length: 397<br/>&#13;
utf8=%E2%9C%93&amp;authenticity_token=REDACTED&amp;doorkeeper_application%5Bname%5D=TW<br/>&#13;
DApp&amp;token_type=access_token&amp;<span class="ent">➊</span>administration_id=ABCDEFGHIJKLMNOP&amp;scopes%5B%5D<br/>&#13;
=sales_invoices&amp;scopes%5B%5D=documents&amp;scopes%5B%5D=estimates&amp;scopes%5B%5D=ban<br/>&#13;
k&amp;scopes%5B%5D=settings&amp;doorkeeper_application%5Bredirect_uri%5D=&amp;commit=Save</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_161"/>As you can see, the <span class="literal">POST</span> body includes the <span class="literal">administration_id</span> <span class="ent">➊</span> parameter. This is the account ID that users are added to. Although the length and randomness of the ID make it difficult to guess, the ID was immediately disclosed to added users when they visited the account that invited them. For example, when account B logged in and visited account A, they would be redirected to the URL <em>https://moneybird.com/ABCDEFGHIJKLMNOP/</em>, where <span class="literal">ABCDEFGHIJKLMNOP</span> would be the <span class="literal">administration_id</span> for account A.</p>&#13;
<p class="indent">I tested to see if account B could create an application for account A’s business without the proper permission to do so. I logged in as account B and created a second business, which account B was the sole member of. This would give account B full permissions on the second business, even though account B should have had limited permissions to account A and no ability to create apps for it.</p>&#13;
<p class="indent">Next, I visited account B’s settings page, created an app, and using Burp Suite, intercepted the <span class="literal">POST</span> call to replace <span class="literal">administration_id</span> with account A’s ID. Forwarding the modified request confirmed that the vulnerability worked. As account B, I had an app with full permissions to account A. This allowed account B to bypass the limited permissions of their account and use the newly created app to perform any action they otherwise shouldn’t have had access to.</p>&#13;
<h4 class="h4" id="ch16lev2sec2"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Look for parameters that could contain ID values, such as any parameter names that include the characters <span class="literal">id</span>. Especially be on the lookout for parameter values that only include numbers, because those IDs are likely to be generated in some guessable way. If you can’t guess an ID, determine whether it’s being leaked somewhere. I noticed the <span class="literal">administrator_id</span> given the ID reference in its name. Although the ID values didn’t follow a guessable pattern, the value was being disclosed in the URL whenever a user was invited to a company.</p>&#13;
<h3 class="h3" id="ch16lev1sec5"><strong>Twitter Mopub API Token Theft</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://mopub.com/api/v3/organizations/ID/mopub/activate/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/95552/">https://hackerone.com/reports/95552/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> October 24, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $5,040</p>&#13;
<p class="noindent">After discovering any vulnerability, make sure to consider the impact it would have if an attacker abused it. In October 2015, Akhil Reni reported that Twitter’s Mopub application (a 2013 acquisition) was vulnerable to an IDOR that leaked API keys and a secret. But several weeks later, Reni realized the vulnerability was more severe than he initially reported and submitted an update. Luckily, he made his update before Twitter paid a bounty for his vulnerability.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_162"/>When Reni initially submitted his report, he found that a Mopub endpoint hadn’t properly authorized users and would leak an account’s API key and <span class="literal">build_secret</span> in a <span class="literal">POST</span> response. Here’s what the <span class="literal">POST</span> request looked like:</p>&#13;
<p class="programs">POST /api/v3/organizations/5460d2394b793294df01104a/mopub/activate HTTP/1.1<br/>&#13;
Host: fabric.io<br/>&#13;
User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:41.0) Gecko/20100101<br/>&#13;
Firefox/41.0<br/>&#13;
Accept: */*<br/>&#13;
Accept-Language: en-US,en;q=0.5<br/>&#13;
Accept-Encoding: gzip, deflate<br/>&#13;
X-CSRF-Token: 0jGxOZOgvkmucYubALnlQyoIlsSUBJ1VQxjw0qjp73A=<br/>&#13;
Content-Type: application/x-www-form-urlencoded; charset=UTF-8<br/>&#13;
X-CRASHLYTICS-DEVELOPER-TOKEN: 0bb5ea45eb53fa71fa5758290be5a7d5bb867e77<br/>&#13;
X-Requested-With: XMLHttpRequest<br/>&#13;
Referer: https://fabric.io/img-srcx-onerrorprompt15/android/apps/app<br/>&#13;
.myapplication/mopub<br/>&#13;
Content-Length: 235<br/>&#13;
Cookie: &lt;redacted&gt;<br/>&#13;
Connection: keep-alive<br/>&#13;
Pragma: no-cache<br/>&#13;
Cache-Control: no-cache<br/>&#13;
company_name=dragoncompany&amp;address1=123 street&amp;address2=123&amp;city=hollywood&amp;<br/>&#13;
state=california&amp;zip_code=90210&amp;country_code=US&amp;link=false</p>&#13;
<p class="indent">And the response to the request was the following:</p>&#13;
<p class="programs">{"mopub_identity":{"id":"5496c76e8b15dabe9c0006d7","confirmed":true,"primary":<br/>&#13;
false,"service":"mopub","token":"35592"},<span class="ent">➊</span>"organization":{"id":"5460d2394b793<br/>&#13;
294df01104a","name":"test","alias":"test2",<span class="ent">➋</span>"api_key":"8590313c7382375063c2fe<br/>&#13;
279a4487a98387767a","enrollments":{"beta_distribution":"true"},"accounts<br/>&#13;
_count":3,"apps_counts":{"android":2},"sdk_organization":true,<span class="ent">➌</span>"build<br/>&#13;
_secret":"5ef0323f62d71c475611a635ea09a3132f037557d801503573b643ef8ad82054",<br/>&#13;
"mopub_id":"33525"}}</p>&#13;
<p class="indent">Mopub’s <span class="literal">POST</span> response provides the <span class="literal">api_key</span> <span class="ent">➋</span> and <span class="literal">build_secret</span> <span class="ent">➌</span>, which Reni reported to Twitter in his initial report. But accessing the information also requires knowing an <span class="literal">organization_id</span> <span class="ent">➊</span>, which is an unguessable 24-digit string. Reni noticed that users could share application crash issues publicly via a URL, such as <em>http://crashes.to/s/&lt;11 CHARACTERS&gt;</em>. Visiting one of these URLs would return the unguessable <span class="literal">organization_id</span> in the response body. Reni was able to enumerate <span class="literal">organization_id</span> values by visiting the URLs returned using the Google dork <em>site:http://crashes.to/s/</em>. With the <span class="literal">api_key</span>, <span class="literal">build_secret</span>, and <span class="literal">organization_id</span>, an attacker could steal API tokens.</p>&#13;
<p class="indent">Twitter resolved the vulnerability and asked Reni to confirm he could no longer access the vulnerable information. It was at that point that Reni realized the <span class="literal">build_secret</span> returned in the HTTP response was also used in the URL <em>https://app.mopub.com/complete/htsdk/?code=</em>&lt;<em>BUILDSECRET&gt;&amp;amp;next=%2d</em>. This URL authenticated a user and redirected them to the associated Mopub account, which would have allowed a malicious user to log into the account of any other user. The malicious user would have had access to the <span epub:type="pagebreak" id="page_163"/>target account’s apps and organizations from Twitter’s mobile development platform. Twitter responded to Reni’s comment requesting additional information and the steps to reproduce the attack, which Reni provided.</p>&#13;
<h4 class="h4" id="ch16lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Always be sure to confirm the full impact of your bugs, especially when it comes to IDORs. In this case, Reni found he could obtain secret values by accessing <span class="literal">POST</span> requests and using a single Google dork. Reni initially reported that Twitter was leaking sensitive information, but only later did he realize how these values were used on the platform. If Reni hadn’t provided additional information after submitting his report, Twitter likely wouldn’t have realized that they were vulnerable to account takeovers and they might have paid Reni less.</p>&#13;
<h3 class="h3" id="ch16lev1sec6"><strong>ACME Customer Information Disclosure</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> High</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://www.&lt;acme&gt;.com/customer_summary?customer_id=abeZMloJyUovapiXqrHyi0DshH</em></p>&#13;
<p class="hang"><strong>Source:</strong> N/A</p>&#13;
<p class="hang"><strong>Date reported:</strong> February 20, 2017</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $3,000</p>&#13;
<p class="noindent">This bug is part of a private program on HackerOne. This vulnerability remains undisclosed, and all information in it has been anonymized.</p>&#13;
<p class="indent">A company, which I’ll refer to as ACME Corp for the sake of this example, created software that allows administrators to create users and assign permissions to those users. When I started testing the software for vulnerabilities, I used my administrator account to create a second user with no permissions. Using the second user account, I began visiting URLs the administrator was able to access that shouldn’t have been accessible to the second user.</p>&#13;
<p class="indent">Using my unprivileged account, I visited a customer details page through the URL <em>www.&lt;acme&gt;.com/customization/customer_summary?customer_id=abeZMloJyUovapiXqrHyi0DshH</em>. This URL returns customer information based on the ID passed to the <span class="literal">customer_id</span> parameter. I was surprised to see that customer details were being returned to the second user account.</p>&#13;
<p class="indent">Although the <span class="literal">customer_id</span> appeared to be unguessable, it might be mistakenly disclosed on the site somewhere. Alternatively, if a user had their permission revoked, they would still be able to access customer information if they knew the <span class="literal">customer_id</span>. I reported the bug with this reasoning. In hindsight, I should have looked for the leaked <span class="literal">customer_id</span> before reporting.</p>&#13;
<p class="indent">The program closed my report as informative on the grounds that the <span class="literal">customer_id</span> was unguessable. Informative reports don’t result in a bounty <span epub:type="pagebreak" id="page_164"/>and can negatively impact your HackerOne stats. Undeterred, I started looking for places where the ID could be leaked by testing all the endpoints I could find. Two days later, I found a vulnerability.</p>&#13;
<p class="indent">I began accessing URLs with a user that only had permission to search orders and shouldn’t have had any access to customer or product information. But I found a response from an order search that produced the following JSON:</p>&#13;
<p class="programs">{<br/>&#13;
  "select": "(*,hits.(data.(order_no, customer_info, product_items.(product_<br/>&#13;
id,item_text), status, creation_date, order_total, currency)))",<br/>&#13;
  "_type": "order_search_result",<br/>&#13;
  "count": 1,<br/>&#13;
  "start": 0,<br/>&#13;
  "hits": [{<br/>&#13;
    "data": {<br/>&#13;
      "order_no": "00000001",<br/>&#13;
      "product_items": [{<br/>&#13;
        "_type": "product_item",<br/>&#13;
        "product_id": "test1231234",<br/>&#13;
        "item_text": "test"<br/>&#13;
      }],<br/>&#13;
      "_type": "order",<br/>&#13;
      "creation_date": "2017-02-25T02:31Z",<br/>&#13;
      "customer_info": {<br/>&#13;
        "customer_no": "00006001",<br/>&#13;
        "_type": "customer_info",<br/>&#13;
        "customer_name": "pete test",<br/>&#13;
        "customer_id": "abeZMloJyUovapiXqHyi0DshH",<br/>&#13;
        "email": "test@gmail.com"<br/>&#13;
      }<br/>&#13;
    }<br/>&#13;
  }]<br/>&#13;
}<span class="codeitalic1">--snip--</span></p>&#13;
<p class="indent">Notice that the JSON includes a <span class="literal">customer_id</span> <span class="ent">➊</span>, which was the same as the ID being used in the URL that would display customer information. This meant that the customer ID was being leaked, and an unprivileged user could find and access customer information they shouldn’t have had the permissions to see.</p>&#13;
<p class="indent">In addition to finding the <span class="literal">customer_id</span>, I continued to investigate the extent of the vulnerability. I discovered other IDs that could also be used in URLs to return information that should have been inaccessible. My second report was accepted and paid a bounty.</p>&#13;
<h4 class="h4" id="ch16lev2sec4"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">When you find a vulnerability, make sure you understand the extent to which an attacker can use it. Try to find leaked identifiers or other IDs that could have a similar vulnerability. Additionally, don’t be discouraged if a <span epub:type="pagebreak" id="page_165"/>program disagrees with your report. You can keep looking for other places in which you might be able to use the vulnerability and can submit another report if you find any further information.</p>&#13;
<h3 class="h3" id="ch16lev1sec7"><strong>Summary</strong></h3>&#13;
<p class="noindent">IDORs occur when an attacker can access or modify a reference to an object that they shouldn’t be able to access. IDORs can be simple: they might require exploiting numerically incremented integers by adding and subtracting 1. For more complex IDORs that make use of UUIDs or random identifiers, you might need to test the platform thoroughly for leaks. You can check for leaks in a variety of places, such as in JSON responses, in HTML content, through Google dorks, and through URLs. When you’re reporting, be sure to detail how an attacker can abuse the vulnerability. For example, the bounty for a vulnerability where an attacker could bypass platform permissions will be less than the bounty for a bug that results in a full account takeover.<span epub:type="pagebreak" id="page_166"/></p>&#13;
</body></html>