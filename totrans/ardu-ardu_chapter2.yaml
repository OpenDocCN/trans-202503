- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PORT
    MANIPULATION</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter introduces *port manipulation*, the process of simultaneously addressing
    your Arduino’s digital input and output pins to increase the speed of controlling
    or reading their statuses. Doing so reduces the *response time*, or the time required
    for a digital read or write to complete, thus increasing the sketch’s speed of
    operation. Port manipulation also uses less code than normal digital write/read
    functions, reducing the size of your sketch, which comes in handy when you hit
    the upper limits of your Arduino’s memory constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use port manipulation to rapidly control digital outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control seven-segment LED displays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read multiple digital input pins simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read binary-coded decimal (BCD) switches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, you’ll build a binary number display, a light-emitting diode
    (LED) blinking wave, and a single-digit LED die. The instructions in this chapter
    are for an Arduino Uno or compatible board, original Nano, or other Arduino-compatible
    with an ATmega328-series microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Ports, Pins, and Registers</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *port* is a collection of sequential I/O pins. Each has a *register* (a section
    of memory inside the microcontroller), which is written to control the output
    status or read from if the pin status is set to an input. You use another register—the
    data direction register (DDR)—to set pins in a port as inputs or outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-1](chapter2.xhtml#fig2-1) shows the pins and the ports in which they
    are grouped. Port B consists of digital pins D13 through D8, port C consists of
    analog pins A5 through A0, and port D consists of digital pins D7 through D0.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A SIMPLIFIED DIAGRAM OF AN ARDUINO UNO SHOWING THE THREE I/O PIN PORTS: PORT
    B, C AND D](../images/fig2-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: Ports on the Arduino
    Uno</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a pin as an input or output, you don’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> as you normally
    would. Rather, use the following simple syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">DDR</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>
    is the data direction register, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>
    is the port (B, C, or D) and each <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp>
    matches a pin in the port (from highest to lowest). The B in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyyyyyy</samp> indicates that
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyyyyyy</samp> is a binary
    number. For example, to set all of port D to digital outputs, you use the following
    line of code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To set digital pins D13, D12, and D11 to inputs and digital pins D9, D8, and
    D7 to outputs, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can see how much sketch space this saves compared to multiples or loops
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to abbreviating your code and shortening the response time, port
    manipulation can save you hardware costs when controlling digital output pins.
    For example, in the past, you may have used a shift register IC to control an
    LED display. Port manipulation allows you to do the same using a spare bank of
    I/O pins instead.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put this theory into practice with some projects.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #4: Increasing Digital Output
    Pin Speed</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll practice using port manipulation by controlling eight
    digital outputs at once, with LEDs used to display output status.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight 1 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-male jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To minimize the number of part types used in this book and therefore reduce
    the cost of completing projects, this project uses the same 1 kΩ resistors from
    the previous chapter instead of the usual 560 Ω or thereabouts. The LEDs will
    still be plenty bright.
  prefs: []
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 2-2](chapter2.xhtml#fig2-2) on the
    solderless breadboard, connecting the points labeled D7 through D0 and GND to
    the Arduino’s respective pins.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCHEMATIC FOR PROJECT #4](../images/fig2-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: Schematic for Project
    #4</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter and upload the following sketch to your Arduino:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once the upload is complete, all the LEDs should blink on and off every half
    second. The pins on port D are set to outputs ❶ and all turned on ❷ and then off
    again ❸. This simple example shows how little code is required to accomplish a
    lot of digital pin control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep the hardware for this project together, as you’ll use it again in Project
    #5.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Speed Advantage</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Arduino environment uses a hardware abstraction layer that simplifies controlling
    the hardware in your Arduino board or compatible circuit with the help of software
    functions and classes. This code requires extra processing time, which normally
    slows down sketch execution. Port manipulation allows you to bypass the hardware
    abstraction layer, which greatly reduces the amount of code the CPU needs to run
    to accomplish the same task.
  prefs: []
  type: TYPE_NORMAL
- en: To see how much port manipulation speeds up I/O pin operation, this section
    shows how to use test equipment such as a frequency counter or a digital storage
    oscilloscope (DSO) to measure the frequency at which a port of digital pins turns
    on and off. If you have an oscilloscope or a frequency counter, you can follow
    along.
  prefs: []
  type: TYPE_NORMAL
- en: First, test the pin speed with the usual Arduino sketch functions, using the
    sketch in [Listing 2-1](#LiT-2-1) with a digital pin connected to the oscilloscope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1 A pin speed test,
    which turns digital pins D7 to D0 on and off in sequence and then repeats</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-3](chapter2.xhtml#fig2-3) shows the results of this measurement:
    an average frequency of 15.15 kHz, which gives a time interval of around 0.000066
    seconds (66 μs) to turn all eight digital pins on and off.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREEN CAPTURE OF A DIGITAL STORAGE OSCILLOSCOPE MEASURING THE PERIOD BETWEEN
    ARDUINO DIGITAL OUTPUT ON AND OFF USING ARDUINO CODE](../images/fig2-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The results from
    running the [Listing 2-1](#LiT-2-1) test</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now repeat this test with the modified sketch in [Listing 2-2](#LiT-2-2), which
    uses port manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: Using port manipulation
    to test pin speed</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> commands in [Listing
    2-2](#LiT-2-2) demonstrate turning the pins on and off long enough for the oscilloscope
    to capture the true speed of this operation. If there were only two <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp>
    commands (for on and off), the time measurement would include the period between
    the pins being turned off and the loop starting over.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-4](chapter2.xhtml#fig2-4) shows the results of this sketch on the
    oscilloscope.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREEN CAPTURE OF A DIGITAL STORAGE OSCILLOSCOPE MEASURING THE PERIOD BETWEEN
    ARDUINO DIGITAL OUTPUT ON AND OFF USING PORT MANIPULATION CODE](../images/fig2-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: Results from the
    “fast” test</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This second test resulted in an average frequency of 8.06 MHz, or a time interval
    of around 0.00000012406 seconds (0.12405 μs) to turn all eight digital pins on
    and off. On average, using port manipulation turned those pins on and off around
    532 times faster than normal sketch functions.
  prefs: []
  type: TYPE_NORMAL
- en: You can see how much using port manipulation improves operation speed and reduces
    the amount of required code in your sketches. In the next project, we’ll demonstrate
    these benefits of port manipulation by controlling LEDs for display purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #5: Displaying Binary Numbers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll continue to consolidate your knowledge of port manipulation
    by using the method to display binary numbers with eight LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project uses the same hardware as Project #4\. Once you’ve uploaded the
    sketch, the LEDs should illuminate in turn to display binary numbers from 0 to
    255, with the least-significant bit on the right side of the LEDs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we set the pins on port D to outputs ❶. We then set <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp>
    to the increasing value of the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    As the port register contains 8 bits, we can assign an integer between 0 and 255
    to the port so that the outputs match the binary equivalent of the number assigned
    to the register ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, let’s practice mastering bit-shifting in port manipulation
    by turning LEDs on and off in one direction and then the other.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #6: Creating a Blinking LED
    Wave</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, using the hardware from Projects #4 and #5, you’ll create
    a wavelike light pattern to emulate the lights across the bonnet of the famous
    vehicle K.I.T.T. from the 1980s television show *Knight Rider*. Once you’ve uploaded
    this sketch, you should be presented with your own version of K.I.T.T.’s iconic
    scrolling lights.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This sketch has two loops: one to blink the LEDs from right to left and one
    to blink them in the opposite direction. We use bit-shifting to move the number
    1 from right to left along the port register. We loop eight times, for eight LEDs
    ❶. The LED is activated by assigning 1 to the port register ❷, which turns on
    the LED on digital pin D0 in the second run of the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> is 1, so
    we shift the bit one to the left (using <samp class="SANS_TheSansMonoCd_W5Regular_11"><<</samp>)
    in the port register, turning on the second LED on digital pin D1\. This process
    repeats until all eight LEDs have been turned on and off. The following list of
    port register bytes represents each event in this sequence of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The process then repeats in reverse in the second loop at ❸, beginning by putting
    a bit in the seventh position (<samp class="SANS_TheSansMonoCd_W5Regular_11">01000000</samp>),
    and then continues along to bit 1\. We don’t need to put a bit in location 0 for
    this second loop, as that would illuminate the first LED twice in a row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two projects demonstrate another convenient application for port manipulation:
    using seven-segment LED displays, which are simply eight LEDs arranged to form
    a number with an optional decimal point.'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #7: Controlling Seven-Segment
    LED Displays</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: People generally use an external shift register IC, such as the 74HC595, to
    display simple numerical information with seven-segment LED displays. If you have
    the digital I/O pins to spare, however, you can save money on parts by using the
    method in this project. This project also includes a quick review of bitwise arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight 1 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common-cathode seven-segment LED display (FND500-compatible)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-male jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 2-5](chapter2.xhtml#fig2-5) on the
    solderless breadboard and connect the points labeled D7 through D0 and GND to
    the Arduino’s respective pins.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #7](../images/fig2-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: The schematic for
    Project #7</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve uploaded the sketch, the numbers 0 through 9 should display in turn
    and then display once more, this time with the decimal point in the LED display
    turned on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The sketch defines an array with 10 elements ❶, each including a binary number
    representing the LEDs of the display needed to power on or off to display each
    digit. From the schematic in [Figure 2-5](chapter2.xhtml#fig2-5), you can see
    that the display is wired so its first pin (A) is connected to digital pin D7,
    and so on. In this project, port D is set at ❷. Displaying the required digit
    is a simple matter of allocating the required array element (0 to 9) to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> at ❸ and ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The loop ❹ turns the decimal point on. Bit 0 in each array element represents
    the decimal point LED in the display, so the sketch needs to change the bit in
    bit 0 using the OR function (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>)
    in bitwise arithmetic. When you use OR to compare 2 bits, the result is 1 if either
    bit is 1 or if both are 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, you can add the decimal point to a numerical byte using the following
    (in the sketch, the numerical byte is set to display the number 1 and the decimal
    point):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the future, if you’re using the LED display in your own projects with port
    manipulation, you can take advantage of the following custom function to display
    numbers with or without the decimal point. You can also test it by adding it to
    Project #7.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to turn off a particular output that you know is currently on without
    affecting the other pins, use the bitwise AND function <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>.
    When a bit is compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    0, the result is 0 if the bit is 1\. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn off the first and last output when all pins are on, you’d use the following
    code, which leaves bits 6 through 1 on, with 7 and 0 off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have the LED display circuit connected, let’s make an electronic
    die.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #8: Creating an Electronic
    Die</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll create an electronic die that generates a random number
    between one and six to mimic rolling a physical die.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project uses the same hardware as Project #7\. Upload the sketch; the
    display should rapidly scroll through the numbers and then slow down bit by bit
    until it stops.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The sketch is a combination of new code and the functions that were used in
    Project #7\. The sketch first uses the custom function from that project to display
    the digits ❶ and then seed the random number generator ❷. It rapidly displays
    100 random numbers for visual effect ❸ and then displays the next 10 random numbers
    with an increasing time delay between each number ❹. Finally, after one last random
    number is displayed ❺, everything stops. To display another random number, press
    the reset button.'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #9: Reading Multiple Digital
    Inputs Simultaneously</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can also read digital input pins rapidly using the port-style operations,
    rather than by using multiple <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalRead()</samp>
    functions. Since each port returns 8 bits of data (including ports B and C, which
    have only six physical pins), we can simply set the required port to inputs and
    then assign the value of a port to a variable. The value is an 8-bit number that
    represents the status of the input pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once inputs have been set using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DDR</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> function in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>, just assign the port to a variable to read the status of the pins.
    For example, to read the status of port D once set to inputs, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This project demonstrates how to read an entire port at once and then display
    the status of that port using another port of LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four 1 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four 10 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four tactile buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-male jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 2-6](chapter2.xhtml#fig2-6) on the
    solderless breadboard and connect the points labeled D7 through D4, D13 through
    D10, 5V, and GND to the Arduino’s respective pins.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #9](../images/fig2-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: The schematic for
    Project #9</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve uploaded the sketch, pressing a button should illuminate the matching
    LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This sketch demonstrates the code minimalization made possible using port manipulation:
    you can read the status of up to eight buttons in one line, instead of using eight
    separate <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalRead()</samp> functions.
    After setting the pins’ status ❶, the sketch assigns the value of the pins (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp>) to port D, which sets the
    outputs as instructed ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code bit-shifts the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp>
    2 bits to the left ❸. Port B has only six physical pins but still returns an 8-bit
    number when read. The two most significant bits are 0, and the final six represent
    the status of D13 to D8\. Therefore, this project moves the <samp class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp>
    value to the left so the bits match port D for the output control.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Binary-Coded Decimal Switches</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The form of reading digital inputs demonstrated in Project #9 lends itself
    well to input devices with more than one output, such as rotary switches with
    BCD outputs representing the binary values of numbers 0 through 9\. BCD switches
    are a convenient method of accepting user input for setting options, values, or
    other project requirements where the user inputs a number between 0 and 9.'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC SYMBOL FOR A TYPICAL BCD SWITCH](../images/fig2-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-7: The schematic symbol
    for a typical BCD switch</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: BCD switches offer 10 position selections and have 4 output pins easily readable
    with 4 digital input pins. The fifth pin is commonly connected to the 5V pin,
    which allows the current to flow through to the switched output pins. [Figure
    2-7](chapter2.xhtml#fig2-7) shows the schematic symbol for a typical BCD switch.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A PUSH-WHEEL BCD SWITCH](../images/fig2-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-8: A push-wheel BCD
    switch</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of BCD switches include the retro-style “push-wheel” switches, as shown
    in [Figure 2-8](chapter2.xhtml#fig2-8), and rotary switches, as shown in [Figure
    2-9](chapter2.xhtml#fig2-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A ROTARY BCD SWITCH](../images/fig2-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-9: A rotary BCD switch</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For performing simple BCD experiments, it’s easier to use the rotary BCD switch
    shown in [Figure 2-9](chapter2.xhtml#fig2-9), as it doesn’t require any soldering.
  prefs: []
  type: TYPE_NORMAL
- en: With any switch, users must be careful to move the lever or pointer to the correct
    position. For example, if you change a rotary switch and leave the pointer between
    two digits, it will not return a correct value. The next project demonstrates
    how to implement these switches with port manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #10: Reading BCD Switches</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates reading a BCD switch by using port manipulation to
    return the value in both binary and decimal to the Serial Monitor, allowing you
    to receive numerical user input simply and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BCD rotary or push-wheel switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-male jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 2-10](chapter2.xhtml#fig2-10) on the
    solderless breadboard and connect the points labeled 5V and D11 through D8 to
    the Arduino’s respective pins.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #10](../images/fig2-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-10: The schematic
    for Project #10</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Enter and upload the sketch and then open the Serial Monitor. You should see
    the value of the switch’s setting displayed in both binary and decimal, as shown
    in [Figure 2-11](chapter2.xhtml#fig2-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN EXAMPLE OUTPUT FROM PROJECT #10 ON THE ARDUINO SERIAL MONITOR, SHOWING
    BINARY AND DECIMAL RESULTS FROM READING THE BCD SWITCH](../images/fig2-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-11: Example output
    for Project #10</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code sets pins D11 through D8 to inputs and sets D12 and D13 to outputs
    ❶, since it doesn’t want to return the values of pins D12 and D13\. It then simply
    returns the value of port B to the Serial Monitor in binary ❷ and decimal ❸ forms.
    The binary value should reflect the actual signals from the switch back to the
    Arduino’s input pins, while the decimal is the integer equivalent of the same
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter showed you how to work more quickly and efficiently with your Arduino’s
    digital input and output pins by using port manipulation, controlling many LEDs
    without external ICs and receiving settings without needing to use a display or
    multiple switches. In the next chapter, you’ll learn how to use the physically
    smaller and cheaper ATtiny series of microcontrollers for less complex Arduino
    projects.
  prefs: []
  type: TYPE_NORMAL
