<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_391"/><span class="big">15</span><br/>USING FIREFLY</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent"><a href="ch14.xhtml#ch14">Chapter 14</a> introduced us to Firefly. Now let’s see what we can make it do. First, we’ll walk through the environment for building and testing Firefly programs. Then, we’ll look at five examples that put Firefly to the test. For the first test, we’ll make the firefly count (“Fly Time”). After that, we’ll simulate a 1960s sci-fi computer display (“Space Trek”). Then, we’ll go high-brow and play some classical music (“Beethoven in Lights”). We’ll even experiment with animation effects (“Dance Dance”) and end with something useful, a tea timer (“Tea Time”). We’ll conclude the chapter with a discussion of Firefly as a programming language.</p>&#13;
<h3 class="h3" id="lev1sec97"><span epub:type="pagebreak" id="page_392"/><strong>The Process</strong></h3>&#13;
<p class="noindent">There are two versions of the Firefly interpreter: one for the console and one for the micro:bit. <a href="ch14.xhtml#ch14">Chapter 14</a> presented the micro:bit version. In this section, we’ll walk through developing Firefly programs, testing with the console interpreter, debugging via execution tracing, and deploying code on the micro:bit. The last step is optional for all the examples in the chapter, should you not have a micro:bit handy. However, you won’t hear the firefly sing.</p>&#13;
<p class="indent">The process involves the sequence of steps listed next. Steps 4, 5, and 6 are specific to the micro:bit, so console-only users should stop after Step 3.</p>&#13;
<ol>&#13;
<li class="noindent">Write Firefly code, including comments and whitespace, in a text  editor.</li>&#13;
<li class="noindent">Run the code with the console interpreter, <em>firefly.py</em>.</li>&#13;
<li class="noindent">Optionally debug the code with execution tracing.</li>&#13;
<li class="noindent">Package the debugged program using <em>fly_dump.py</em>.</li>&#13;
<li class="noindent">Build a micro:bit runtime to bundle the compacted Firefly code with  the micro:bit interpreter, <em>firefly_micro.py</em>.</li>&#13;
<li class="noindent">Transfer the bundled runtime to the micro:bit using the <em><a href="http://microbit.org">microbit.org</a></em>  Python editor, <a href="https://python.microbit.org/v/2/">https://python.microbit.org/v/2/</a>.</li>&#13;
</ol>&#13;
<p class="indent">If you plan on using a micro:bit, we’ll be using the online Python editor at <em><a href="https://python.microbit.org/v/2">https://python.microbit.org/v/2</a></em>. It works best with Windows. I used the Microsoft Edge browser and had no trouble at all.</p>&#13;
<p class="indent">To work with the micro:bit on Linux, I had some success with the Mu editor when using a version 1 micro:bit and the 1.0.2 version of Mu. With later versions of the editor and a version 2 micro:bit, I was only able to get stable functionality from Ubuntu 18.04 when running the editor directly from the GitHub repo at <em><a href="https://github.com/mu-editor/mu/">https://github.com/mu-editor/mu/</a></em>. Your mileage may vary.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch015fig1">Figure 15-1</a> shows the Python editor running on Windows in the Microsoft Edge browser.</p>&#13;
<span epub:type="pagebreak" id="page_393"/>&#13;
<div class="image"><img id="ch015fig1" src="Images/15fig01.jpg" alt="Image" width="680" height="635"/></div>&#13;
<p class="figcap"><em>Figure 15-1: The Python editor for micro:bit</em></p>&#13;
<p class="indent">Note that the book’s GitHub site contains short videos showing the code running on a micro:bit. Please take a look, especially if you do not intend to use the micro:bit yourself.</p>&#13;
<h4 class="h4" id="lev2sec133"><strong><em>Writing Firefly Code</em></strong></h4>&#13;
<p class="noindent">Our first example is the Firefly equivalent of “Hello, world!” The program draws the letters <span class="literal">HI</span> on the screen. The source code is in <em>hi.fly</em> in the <em>firefly/ console/examples</em> directory (see <a href="ch15.xhtml#ch015list1">Listing 15-1</a>).</p>&#13;
<pre><span epub:type="pagebreak" id="page_394"/>MNNWW5  ! move mode, go to (0,0), intensity 5&#13;
SSS     ! left side of the "H"&#13;
MNN5    ! up to (1,0)&#13;
EEE     ! crossbar of the "H"&#13;
MNW     ! move to (0,2)&#13;
5SSS    ! right side of the "H"&#13;
MEEN    ! move to (0,4)&#13;
5NNN    ! "I"&#13;
L       ! loop</pre>&#13;
<p class="caption" id="ch015list1"><em>Listing 15-1: “Hello, world!” in Firefly</em></p>&#13;
<p class="indent">The first line of <em>hi.fly</em> ensures move mode (no trail) and moves the firefly from its initial (2,2) position to the upper-left corner, (0,0). The mode is then set to intensity 5.</p>&#13;
<p class="indent">The next line moves south three spaces to draw the left side of the H. At this point, the firefly is at position (3,0), so switching to move mode and going north twice puts the firefly at (1,0). Setting the mode to 5 and moving east three times draws the crossbar of the H. The next two lines finish the H and <span class="literal">MEEN</span> moves to (2,4). From (2,4), setting the mode to 5 and moving north three times draws the I, ending with the firefly at position (4,4). The <span class="literal">L</span> instruction loops forever to preserve the “HI” display on the micro:bit.</p>&#13;
<h4 class="h4" id="lev2sec134"><strong><em>Using the Console Interpreter</em></strong></h4>&#13;
<p class="noindent">To execute <a href="ch15.xhtml#ch015list1">Listing 15-1</a>, we need the console interpreter. Run the code with</p>&#13;
<pre>&gt; <span class="codestrong1">python3 firefly.py examples/hi.fly</span></pre>&#13;
<p class="noindent">to produce</p>&#13;
<pre>    5   5   5&#13;
    5 5 5   5&#13;
    5   5   5</pre>&#13;
<p class="indent">The 5×5 display is indented four spaces and one space is printed between each digit. By default, <em>firefly.py</em> shows 0 intensity as a space. Adding the <span class="literal">-z</span> command line option shows 0 intensity as 0s</p>&#13;
<pre>    5 0 5 0 5 &#13;
    5 5 5 0 5 &#13;
    5 0 5 0 5 &#13;
    0 0 0 0 0 &#13;
    0 0 0 0 0</pre>&#13;
<p class="noindent">where we now see the full 5×5 grid.</p>&#13;
<p class="indent">Next, step through <em>hi.fly</em> by adding the <span class="literal">-t</span> (trace) command line option:</p>&#13;
<pre>&gt; <span class="codestrong1">python3 firefly.py examples/hi.fly -t</span></pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_395"/>In trace mode, an instruction is executed and the display is updated; then, before execution of the next instruction, the interpreter shows a status line and waits for the user to press ENTER or Q to quit the program. For example, running <em>hi.fly</em> in trace mode presents us with</p>&#13;
<pre>I=(2,2)(12), SHOW=A, DRAW=A, M=M, INST=M</pre>&#13;
<p class="indent">which tells us that the last instruction executed was <span class="literal">M</span> (set move mode). This is the <span class="literal">INST</span> part of the status line. The rest of the status line is described as follows:</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Instruction</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Explanation</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">I=(2,2)(12)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">The firefly is at (2,2) (index 12)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">SHOW=A</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Grid A is currently visible</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">DRAW=A</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Grid A is currently drawn to</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">M=M</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Move mode is “M”</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">The index is into the <span class="literal">bytearray</span> of the currently active memory grid.</p>&#13;
<p class="indent">Pressing ENTER moves us to</p>&#13;
<pre>I=(1,2)( 7), SHOW=A, DRAW=A, M=M, INST=N</pre>&#13;
<p class="noindent">which informs us that the firefly is now at position (1, 2) (index 7) because a “move north” instruction was executed.</p>&#13;
<p class="indent">Continuing to press ENTER traces through the entire program.</p>&#13;
<pre>I=(0,2)( 2), SHOW=A, DRAW=A, M=M, INST=N&#13;
I=(0,1)( 1), SHOW=A, DRAW=A, M=M, INST=W&#13;
I=(0,0)( 0), SHOW=A, DRAW=A, M=M, INST=W&#13;
I=(0,0)( 0), SHOW=A, DRAW=A, M=5, INST=5&#13;
I=(1,0)( 5), SHOW=A, DRAW=A, M=5, INST=S&#13;
I=(2,0)(10), SHOW=A, DRAW=A, M=5, INST=S&#13;
I=(3,0)(15), SHOW=A, DRAW=A, M=5, INST=S&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="noindent">We continue to the <span class="literal">L</span> instruction, which throws us into an infinite loop. Use CTRL-C to exit the loop.</p>&#13;
<p class="indent">We have a working program. Let’s now bundle it to run on the micro:bit.</p>&#13;
<h4 class="h4" id="lev2sec135"><strong><em>Packing a Bundle</em></strong></h4>&#13;
<p class="noindent">We can’t use <em>hi.fly</em> as-is with the micro:bit version of Firefly because we first need to strip the comments and whitespace. We could do this manually, but why bother when we already have a utility to do it for us? In the same <span class="literal">console</span> directory as <em>firefly.py</em> is <em>fly_dump.py</em>. Let’s run it to get a single-string version of <em>hi.fly</em>.</p>&#13;
<pre>&gt; <span class="codestrong1">python3 fly_dump.py examples/hi.fly ../micro/examples/hi.fly</span></pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_396"/>The first argument is the console version of the code with comments and whitespace. The second is the output, which in this case is sent to the <em>examples</em> directory of the micro:bit version in <em>micro</em>. The output generated is</p>&#13;
<pre>MNNWW5SSSMNN5EEEMNW5SSSMEEN5NNNL</pre>&#13;
<p class="indent">This version of the code still runs in the console interpreter. Give it a try and see for yourself.</p>&#13;
<p class="indent">To make the micro:bit bundle, we’ll need to complete the following steps:</p>&#13;
<ol>&#13;
<li class="noindent">Copy <em>firefly_micro.py</em> to <em>hi.py</em>.</li>&#13;
<li class="noindent">Edit <em>hi.py</em> and update <em>PRG</em> to be the text in <em>micro/examples/hi.fly</em>.</li>&#13;
<li class="noindent">Run the Python editor and load <em>hi.py</em>.</li>&#13;
<li class="noindent">Attach the micro:bit via USB.</li>&#13;
<li class="noindent">Program the micro:bit from the online Python editor.</li>&#13;
</ol>&#13;
<p class="indent">Steps 1 and 2 mean that bundles are copies of the micro:bit version of the interpreter edited to contain the compacted Firefly code. The default <em>firefly_micro.py</em> file begins with</p>&#13;
<pre>PRG = """&#13;
1TJ0TITFTFTFTFTFTFTF5TG8TJ1TFH&#13;
"""</pre>&#13;
<p class="noindent">which becomes</p>&#13;
<pre>PRG = """&#13;
MNNWW7SSSMNN7EEEMNW7SSSMEEN7NNNL&#13;
"""</pre>&#13;
<p class="noindent">This embeds the code in <em>hi.py</em>. The remainder of <em>hi.py</em> is the same as the interpreter code of <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>&#13;
<p class="indent">To program the micro:bit, first run the editor in Microsoft Edge by opening <em><a href="https://python.microbit.org/v/2/">https://python.microbit.org/v/2/</a></em>. Then, connect the micro:bit’s Micro-USB port to the computer’s USB port. The micro:bit will likely automount. If so, just close any Explorer window that opens.</p>&#13;
<p class="indent">Next, connect to the micro:bit by clicking <strong>Connect</strong> and selecting the micro:bit from the resulting dialog. The micro:bit is present and working if you see a string similar to “‘BBC micro:bit CMSIS-DAP’ – Paired.” Select the micro:bit and click <strong>Connect</strong>.</p>&#13;
<p class="indent">Next, open <em>hi.py</em> by clicking <strong>Load/Save</strong> followed by <strong>Download</strong> to program the micro:bit. Programming takes a few seconds. When complete, the program starts immediately producing <a href="ch15.xhtml#ch015fig2">Figure 15-2</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_397"/><img id="ch015fig2" src="Images/15fig02.jpg" alt="Image" width="531" height="432"/></div>&#13;
<p class="figcap"><em>Figure 15-2: “Hello, world!” micro:bit style</em></p>&#13;
<p class="indent">Did you notice something when the program ran? Rerun it by pressing the reset button beneath the micro:bit.</p>&#13;
<p class="indent">If you are using a version 1 micro:bit, you’ll see the message draw on the screen from left to right. The <em>hi.fly</em> program moves the firefly on grid A while showing grid A, so we see each instruction’s effect. Later in the chapter, we’ll adjust <em>hi.fly</em> to use double buffering (see “Space Trek” below).</p>&#13;
<p class="indent">The remainder of this chapter walks through each example’s code, running it on the console when applicable and then running the code on the micro:bit. In each case, program the micro:bit as we did here: use <em>fly_dump.py</em> to strip comments and whitespace, paste the compacted Firefly program text into a suitably renamed copy of <em>firefly_micro.py</em>, and load the copy onto the micro:bit via the Python editor. Don’t forget to take a look at the micro:bit videos on the book’s GitHub site as well.</p>&#13;
<p class="indent">Let’s put our firefly to work.</p>&#13;
<h3 class="h3" id="lev1sec98"><strong>Fly Time</strong></h3>&#13;
<p class="noindent">The <span class="literal">P</span> instruction pauses the program for 0.1 seconds. Therefore, <span class="literal">PPPPPPPPPP</span> pauses the program for one second. Let’s use this as the basis for a counter/ timer. Our goal is a Firefly program that counts seconds, up to 1,000, before rolling over and starting again. Firefly lacks any looping mechanism other than starting a program from the beginning after it ends; therefore, we need to design our program so that looping from the beginning starts the counter again from 0.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_398"/>If 10 <span class="literal">P</span> instructions give a one-second pause, then <span class="literal">PPPPPPPPPPT</span> pauses for one second before “moving” the firefly by remaining in place. If the mode is <span class="literal">I</span> (increment), the net effect is a one-second pause before incrementing the current firefly position. Repeat the one-second pause 10 times with <span class="literal">T</span> after each pause, and we have a 10-second timer.</p>&#13;
<p class="indent">To count, we increment the ones digit until it rolls over back to 0 and then increment the tens digit by 1. We can use this approach with the one-second timer to build a two-digit timer by moving from the current firefly position, the ones position, over to the left and incrementing, and then moving back and repeating for another 10 seconds.</p>&#13;
<p class="indent">This thought suggests a set of repeated instructions. The program begins with the firefly at position (2,2). Let’s use position (0,4) for the ones and position (0,3) for the tens. Consider the sequence of instructions shown in <a href="ch15.xhtml#ch015list2">Listing 15-2</a>.</p>&#13;
<pre>NNEE            ! move to (0,4)&#13;
I               ! increment mode&#13;
PPPPPPPPPPT     ! 1 second and increment&#13;
PPPPPPPPPPT     ! &#13;
PPPPPPPPPPT     ! &#13;
PPPPPPPPPPT     ! &#13;
PPPPPPPPPPT     ! &#13;
PPPPPPPPPPT     ! &#13;
PPPPPPPPPPT     ! &#13;
PPPPPPPPPPT     ! &#13;
PPPPPPPPPPT     ! &#13;
PPPPPPPPPPT     ! &#13;
MWIT            ! move over 1 and increment&#13;
MEI             ! move back, set increment mode</pre>&#13;
<p class="caption" id="ch015list2"><em>Listing 15-2: A 10-second timer</em></p>&#13;
<p class="indent">The first line moves the firefly from (2,2) to (0,4), which is the ones position. The second line sets the mode to increment. Next comes a one-second delay followed by a “tick” to increment the ones position. Nine more one-second delays finish the 10-second delay, and the ones position has moved from 0 up through 9 and back to 0.</p>&#13;
<p class="indent">The line <span class="literal">MWIT</span> moves one position to the left, to (0,3), and increments the tens position by 1. Let’s break the steps down: <span class="literal">M</span> sets move mode (no trail), <span class="literal">W</span> moves left one position, <span class="literal">I</span> sets increment mode, and <span class="literal">T</span> increments position (0,3). The block of steps ends with <span class="literal">MEI</span> to move back to (0,4), the ones position, which is currently 0 because it rolled over, followed by <span class="literal">I</span> to reassert increment mode.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch015list2">Listing 15-2</a> counts for 10 seconds. If <a href="ch15.xhtml#ch015list2">Listing 15-2</a> is repeated nine more times, except for the top two lines, <span class="literal">NNEE</span> and <span class="literal">I</span>, which set up the initial firefly position and mode, we’ll have a 100-second timer.</p>&#13;
<p class="indent">The file <em>fly_time.fly</em> in <em>console/examples</em> contains the code we need. Most of the code is repeated blocks like <a href="ch15.xhtml#ch015list2">Listing 15-2</a>. However, the 10th block ends with <a href="ch15.xhtml#ch015list3">Listing 15-3</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_399"/>PPPPPPPPPPT     ! 1 second and increment&#13;
MWIT            ! move over 1 and increment&#13;
MWIT            ! move over 1 more and increment&#13;
MEEI            ! move back, set increment mode</pre>&#13;
<p class="caption" id="ch015list3"><em>Listing 15-3: End of the 10th timer block</em></p>&#13;
<p class="indent">The last one-second pause and an increment happens, followed by <span class="literal">MWIT</span> to move from (0,4) to (0,3) and increment the tens value. As this is the 10th block, the tens value has rolled over from 9 back to 0. So a second <span class="literal">MWIT</span> moves from (0,3) to (0,2), the hundreds position, and increments it.</p>&#13;
<p class="indent">This last step completes a counter from 0 to 100. If the firefly moves back to (0,4) and the program loops by starting over, the display will still read <span class="literal">1 0 0</span>. The final line is <span class="literal">MEEI</span> to move back to (0,4) and set increment mode. As there is no <span class="literal">H</span> or <span class="literal">L</span> instruction, the program begins again.</p>&#13;
<p class="indent">Note that when the program loops, the display memory is preserved, but the firefly is warped back to its initial position of (2,2). However, this is what we want. The first instructions in <em>fly_time.fly</em> tell the firefly to move to (0,4), which is just where we need it to be to count another 100 seconds.</p>&#13;
<p class="indent">The hundreds position, (0,2), is incremented again after another 100 seconds, leaving the display at <span class="literal">2 0 0</span>. Another 100 seconds later, the display is <span class="literal">3 0 0</span>. This continues to 1,000 seconds, after which the display rolls over to all 0s. We don’t increment the thousands position, but the program continues to loop until we hit CTRL-C, so the 1,000-second counter begins again, over and over.</p>&#13;
<p class="indent">Run <em>fly_time.fly</em> with the console interpreter using <span class="literal">-z</span> to show 0 memory as 0s.</p>&#13;
<pre>&gt; <span class="codestrong1">python3 firefly.py examples/fly_time.fly -z</span></pre>&#13;
<p class="noindent">The program counts until you hit CTRL-C. By starting the program at the beginning of an interval, and using CTRL-C to stop the program at the end of an interval, we have a primitive stopwatch—geeky to be sure, but functional.</p>&#13;
<p class="indent">This example makes use of the only looping available to Firefly: restarting the program. It is naturally designed for the console so we can read the time directly as a number, but nothing stops you from running this code on the micro:bit. If you do, you’ll see sequences of increasingly bright LEDs. If you are like me, you’ll see the LEDs change and understand that the program is counting up, but not be able to reliably tell the difference between an LED that is at, say, brightness 3 versus one at brightness 4.</p>&#13;
<p class="indent">Of course, <em>fly_time.fly</em> is counting in base-10; however, there is no reason why other bases couldn’t be used. If we used binary, then the micro:bit would work nicely. Or perhaps we could use base-3, with LED intensities of 0, 5, and 9 to make the distinction between digits clear. Changing the base changes the repeated code block used, but the general idea remains the same. Instead of ones (10<sup>0</sup>), tens (10<sup>1</sup>), and hundreds positions (10<sup>2</sup>), we would use ones (3<sup>0</sup>), threes (3<sup>1</sup>), nines (3<sup>2</sup>), and possibly twenty-sevens positions (3<sup>3</sup>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_400"/>We’ll implement a different sort of timer later in the chapter, but for now, let’s learn how to use Firefly’s double buffering for animations.</p>&#13;
<h3 class="h3" id="lev1sec99"><strong>Space Trek</strong></h3>&#13;
<p class="noindent">We’ve mentioned Firefly’s double buffering several times now. Let’s see it in action. The examples in this section work best on the micro:bit. Depending on your machine’s speed, you might see some effect when using the console interpreter; however, it’s most noticeable on the micro:bit.</p>&#13;
<p class="indent">Earlier in the chapter, we played around with <em>hi.fly</em> and commented that since we are showing grid A while drawing on grid A, we see the letters as they’re drawn. A simple modification uses double buffering to present the letters to us only after being drawn. The code we need is in <em>hi2.fly</em> under <em>console/examples</em>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch015list4">Listing 15-4</a> presents the updated code. The only difference between <a href="ch15.xhtml#ch015list4">Listing 15-4</a> and <a href="ch15.xhtml#ch015list1">Listing 15-1</a> is the first line, <span class="literal">Y</span>, and the second-to-last line, <span class="literal">X</span>.</p>&#13;
<pre>Y       ! show grid B, drawing on A&#13;
MNNWW5  ! move mode, go to (0,0), intensity to 5&#13;
SSS     ! left side of the "H" &#13;
MNN5    ! up to (1,0)&#13;
EEE     ! crossbar of the "H" &#13;
MNW     ! move to (0,2)&#13;
5SSS    ! right side of the "H" &#13;
MEEN    ! move to (0,4)&#13;
5NNN    ! "I" &#13;
X       ! now show grid A&#13;
L       ! loop</pre>&#13;
<p class="caption" id="ch015list4"><em>Listing 15-4: “HI” with double buffering</em></p>&#13;
<p class="indent">We show grid A and draw to it. Executing <span class="literal">Y</span> shows grid B, which is empty, while still drawing to grid A. The letters are drawn as before, but the user does not see it because grid B is shown. When the letters are finished, <span class="literal">X</span> shows grid A again, and <span class="literal">L</span> enters the loop to preserve the micro:bit display.</p>&#13;
<p class="indent">Bundle <em>hi2.fly</em> and load it on the micro:bit. When it runs, instead of watching the letters draw, you’ll see nothing until the complete word <span class="literal">HI</span> suddenly appears. If you run <em>hi2.fly</em> in the console using the <span class="literal">-t</span> option, you’ll notice <span class="literal">HI</span> suddenly appear as well.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch015list4">Listing 15-4</a> is a bare-minimum example of double buffering. The core concept of double buffering is to show grid B while updating grid A and then switch and show grid A while updating grid B. We repeat this as necessary so that the user never views a grid as it is being drawn.</p>&#13;
<p class="indent">Let’s see a slightly more interesting example where we simulate the random “computer” displays often seen in the background of 1960s sci-fi shows. First, we’ll generate the display live, without double buffering. Then we’ll change the code to use double buffering. The difference between the two is visibly clear; however, to be honest, both approaches are pretty cool to watch.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_401"/><a href="ch15.xhtml#ch015list5">Listing 15-5</a> generates random displays without double buffering.</p>&#13;
<pre>WWNN        ! move to (0,0)&#13;
R           ! set random mode&#13;
EEEES       ! random row 0&#13;
WWWWS       ! random row 1&#13;
EEEES       ! random row 2&#13;
WWWWS       ! random row 3&#13;
EEEES       ! random row 4</pre>&#13;
<p class="caption" id="ch015list5"><em>Listing 15-5: Random computer lights</em></p>&#13;
<p class="indent">The first line moves to (0,0), the upper-left corner of the display. Recall that not only does the firefly start at position (2,2), it also starts in “move” mode (<span class="literal">M</span>) so there is no trail. The second line sets the mode to “random” (<span class="literal">R</span>).</p>&#13;
<p class="indent">The third line moves east from (0,0) four times. Each move sets the previous position to a random intensity. After the last move east, the firefly is at position (0,4), so a move south sets position (0,4) to a random intensity and puts the firefly at position (1,4).</p>&#13;
<p class="indent">To fill in the second row of the display, we’ll need four moves to the west followed by a move south to end up at the beginning of the third row. This zig-zag continues through the remaining rows until the final <span class="literal">S</span> moves the firefly to (0,4). A final move then sets the last LED at (4,4).</p>&#13;
<p class="indent">There is no halt instruction, so the program loops after filling the display. The firefly is reset to (2,2), immediately moved to (0,0), and the grid is drawn again from top to bottom. Therefore, the display is overwritten continuously, row by row, with the previous set of random intensities still present.</p>&#13;
<p class="indent">The console interpreter is too fast to see the overwriting effect, but running <em>random.fly</em> on the micro:bit makes it visible, though just barely. Even on the micro:bit, the code is almost too fast. The effect is mesmerizing. Unfortunately, there is no way to capture the effect in a still image in a book. To see the effect, do view the videos on the GitHub site.</p>&#13;
<p class="indent">Instead of overwriting the display one row at a time, we can introduce double buffering and display a full grid of random intensities while generating the next grid, then flip and display that grid, and so on.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch015list6">Listing 15-6</a> shows us <em>random2.fly</em>.</p>&#13;
<pre>B           ! draw on B, showing A&#13;
WWNN        ! move to (0,0)&#13;
R           ! set random mode&#13;
EEEES       ! random row 0&#13;
WWWWS       ! random row 1&#13;
EEEES       ! random row 2&#13;
WWWWS       ! random row 3&#13;
EEEES       ! random row 4, end at (4,0)&#13;
M           ! move mode&#13;
NNNN        ! move to (0,0)&#13;
YA          ! show B, draw on A<span epub:type="pagebreak" id="page_402"/>&#13;
R           ! set random mode&#13;
EEEES       ! random row 0&#13;
WWWWS       ! random row 1&#13;
EEEES       ! random row 2&#13;
WWWWS       ! random row 3&#13;
EEEES       ! random row 4, end at (4,0)&#13;
X           ! show A</pre>&#13;
<p class="caption" id="ch015list6"><em>Listing 15-6: Random computer lights with double buffering</em></p>&#13;
<p class="indent">The code is in two distinct blocks. The first block is nearly identical to <a href="ch15.xhtml#ch015list5">Listing 15-5</a> except for the addition of a leading <span class="literal">B</span> instruction to tell the firefly to make trails on grid B even though grid A is being shown. At the bottom of the first block, after the entirety of grid B is updated, come <span class="literal">M</span> and <span class="literal">NNNN</span> to set move mode and then move back to (0,0).</p>&#13;
<p class="indent">The second block of code now takes over. First, <span class="literal">YA</span> shows grid B, the grid the first block of code just filled with random intensities, and switches to drawing trails on grid A. The next six lines fill grid A and the final instruction is <span class="literal">X</span> to show grid A.</p>&#13;
<p class="indent">At this point, the program loops and begins again, filling grid B. The final <span class="literal">X</span> has us looking at grid A, just as we do when a Firefly program begins, so the sequence repeats: show A, draw on B, show B, draw on A, and repeat forever.</p>&#13;
<p class="indent">Unlike <a href="ch15.xhtml#ch015list5">Listing 15-5</a>, which constantly overwrites the one grid shown, <a href="ch15.xhtml#ch015list6">Listing 15-6</a> ping-pongs between the two grids, so the user only sees the grid that was most recently filled and never the grid actively being drawn to. The effect is perhaps even more like the old sci-fi movies. There is no flow from top to bottom and the intensities change seemingly at once.</p>&#13;
<h3 class="h3" id="lev1sec100"><strong>Beethoven in Lights</strong></h3>&#13;
<p class="noindent">I claimed in <a href="ch14.xhtml#ch14">Chapter 14</a> that our firefly knows how to sing. Let’s prove it now by writing some music in Firefly. Of course, without an actual micro:bit, console-only runs of the examples in this section will be disappointing. Have no fear! You can always listen to the song via the videos included on the book’s GitHub site.</p>&#13;
<p class="indent">Firefly supports playing notes in the key of C. Middle C (the default) is octave 4, and middle C itself is note 1. Therefore, the simplest way to play a note in Firefly is to execute <span class="literal">1TF</span>, which sets the intensity to 1, “ticks” to update the default firefly position of (2,2), and plays with the default duration of a quarter note. The code loops, of course, and after a brief pause for reset, the note plays again. The result is a dim LED in the middle of the grid followed by buzzing at the pitch of middle C, over and over and over until you cut the power. Still, it’s impressive to get sound from a three-character program.</p>&#13;
<p class="indent">A slightly longer program does sound fun and a bit outer space-ish: <span class="literal">1TJRTF</span>. First, it sets the note duration to 1, which is one-quarter of a quarter note (a sixteenth note). Then it sets the note itself to a random note and <span epub:type="pagebreak" id="page_403"/>plays it. Visually, the higher the pitch, the brighter the LED. The <span class="literal">R</span> instruction sets positions to a random value in the range [1,9]. However, you’ll notice pauses while the random melody plays. If the random value is 8, it acts as note 0, which is a rest. For fun, experiment with two slightly different versions: <span class="literal">RTJRTF</span> and <span class="literal">0TJRTF</span>. The first makes the note duration random as well, and the second sets the duration to 0, causing a staccato effect.</p>&#13;
<p class="indent">We’ll get to Beethoven in time, but before we do, <a href="ch15.xhtml#ch015list7">Listing 15-7</a> shows us how to play an actual scale.</p>&#13;
<pre>1TJ     ! set note duration&#13;
0TI     ! set first note and increment mode&#13;
TF      ! increment and play note&#13;
TF      ! increment and play note&#13;
TF      ! increment and play note&#13;
TF      ! increment and play note&#13;
TF      ! increment and play note&#13;
TF      ! increment and play note&#13;
TF      ! increment and play note&#13;
5TG     ! set octave to 5 (default is 4)&#13;
8TJ     ! set duration&#13;
1TF     ! play note 1 of octave 5&#13;
H       ! halt</pre>&#13;
<p class="caption" id="ch015list7"><em>Listing 15-7: A simple C-major scale</em></p>&#13;
<p class="indent">The first line sets the duration to 1, as we did with the random melody. Next, we set the note to 0 and the mode to increment. Then, <span class="literal">TF</span> increments to 1 and plays the note (middle C). The next <span class="literal">TF</span> increments to 2 and plays D. This repeats for notes E through B.</p>&#13;
<p class="indent">To play the C one octave above middle C, we need to update the octave with <span class="literal">5TG</span>, remembering that middle C is octave 4. Lastly, <span class="literal">8TG</span> sets the duration to a half note (8) and plays the first note of octave 5 before halting.</p>&#13;
<p class="indent">The scale plays quickly, but there is a distinct pause before the final note plays. In this case, it adds a bit of dramatic effect, but in reality, the pause is an artifact of how slowly the micro:bit interprets Firefly instructions. There are eight instructions between playing the second-to-last note, B, and the last note, C. Interpreting these eight instructions causes the pause you hear.</p>&#13;
<p class="indent">Let’s get classical. We want code to make the firefly “sing” Beethoven’s <em>Ode to Joy</em> (see <a href="ch15.xhtml#ch015fig3">Figure 15-3</a>).</p>&#13;
<div class="image"><img id="ch015fig3" src="Images/15fig03.jpg" alt="Image" width="677" height="72"/></div>&#13;
<p class="figcap"><em>Figure 15-3: Beethoven’s</em> Ode to Joy</p>&#13;
<p class="indent">Instead of simply playing the notes in one place, wouldn’t it be nice if the firefly displayed the notes as it played them? S- along with singing, we want the firefly to show us the notes in lights on the display.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_404"/>There are 30 notes in <a href="ch15.xhtml#ch015fig3">Figure 15-3</a>, split into two musical phrases of 15 notes each. There are five LEDs per row on the micro:bit display. How convenient for us. We’ll show the notes, one per position, using the first three rows of LEDs to cover a 15-note phrase. Then, we’ll clear the screen and repeat the process for the remaining 15 notes. The code we need is in <em>ode.fly</em>.</p>&#13;
<p class="indent">Let’s walk through the code by musical phrase. The first phrase is in <a href="ch15.xhtml#ch015list8">Listing 15-8</a>.</p>&#13;
<pre>NNWW    ! move to (0,0)&#13;
3TFE    ! E &#13;
3TFE    ! E &#13;
4TFE    ! F &#13;
5TFE    ! G &#13;
5TFEMS  ! G &#13;
4TFE    ! F &#13;
3TFE    ! E &#13;
2TFE    ! D &#13;
1TFE    ! C &#13;
1TFEMS  ! C &#13;
2TFE    ! D &#13;
3TFE    ! E &#13;
3TFE    ! E &#13;
2TFE    ! D &#13;
B8TJ    ! draw on B, showing A&#13;
A2TF    ! draw on A, D8</pre>&#13;
<p class="caption" id="ch015list8"><em>Listing 15-8: Ode to Joy, first phrase</em></p>&#13;
<p class="indent">By default, the octave is that of middle C, and the duration matches a quarter note, so we need not change the duration or octave. We want the notes displayed as they play, row by row, so we first move the firefly to position (0,0). The next line sets up a pattern we’ll repeat for each note. For example, <span class="literal">3TFE</span> sets the current position to 3 (<span class="literal">3T</span>) and plays the note (<span class="literal">F</span>) before moving one position to the east (<span class="literal">E</span>). This pattern of instructions is used for every note of the piece.</p>&#13;
<p class="indent">The next four notes, E-F-G-G, finish the first row and leave the firefly back at position (0,0). To get to the next row, we use <span class="literal">MS</span> to move south to (1,0) without changing the current value of (0,0). The notes of the second row play next, F-E-D-C-C, before moving to the third row.</p>&#13;
<p class="indent">The first four notes of row 3 play: D-E-E-D. Then, we change the duration from quarter notes to half notes. If we make the change directly, we’ll upset the display, as we need to set a position to 8 for the <span class="literal">J</span> instruction. So we tell the firefly to draw on grid B, which is not displayed, and set the duration that way before switching back to drawing on grid A and playing the note: <span class="literal">A2TF</span>. The first phrase is now complete.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch015list9">Listing 15-9</a> plays the second phrase.</p>&#13;
<pre><span epub:type="pagebreak" id="page_405"/>CB4TJA  ! clear A, draw on B, set duration, draw on A&#13;
MNNE    ! back to (0,0)&#13;
3TFE    ! E&#13;
3TFE    ! E&#13;
4TFE    ! F&#13;
5TFE    ! G&#13;
5TFEMS  ! G&#13;
4TFE    ! F&#13;
3TFE    ! E&#13;
2TFE    ! D&#13;
1TFE    ! C&#13;
1TFEMS  ! C&#13;
2TFE    ! D&#13;
3TFE    ! E&#13;
2TFE    ! D&#13;
1TFE    ! C&#13;
B8TJ    ! draw on B, showing A&#13;
A1TF    ! draw on A, C8&#13;
H       !</pre>&#13;
<p class="caption" id="ch015list9"><em>Listing 15-9: Ode to Joy, second phrase</em></p>&#13;
<p class="indent"><a href="ch15.xhtml#ch015list9">Listing 15-9</a> is much the same as <a href="ch15.xhtml#ch015list8">Listing 15-8</a> except for the first line. That line clears the display, grid A, switches to grid B to reset the duration to 4, and then goes back to drawing on grid A. The next line moves the firefly to (0,0), and the second phrase plays just as the first did. After the final note, the program executes <span class="literal">H</span> to end.</p>&#13;
<p class="indent">Naturally, we must run this program on the micro:bit, but you can play the associated video to see how it goes if you don’t have one. It would be straightforward to copy this technique to play other melodies, though we were fortunate that <em>Ode to Joy</em> consists of two distinct musical phrases of exactly 15 notes and thus fits perfectly on the 5×5 display.</p>&#13;
<p class="indent">If you watch the melody play, you’ll see how the LED intensity is related to the pitch of the note; higher notes are brighter, at least within the same octave.</p>&#13;
<h3 class="h3" id="lev1sec101"><strong>Dance Dance</strong></h3>&#13;
<p class="noindent">Now let’s use Firefly’s double-buffering abilities to do a bit of animation with music. We’ll begin with the animation and add the music later.</p>&#13;
<p class="indent">Our goal is to make a simple figure “dance.” With a 5×5 display, the emphasis is definitely on the word <em>simple</em>. Each stance of the figure is a display. To make the animation, we’ll use double buffering and a collection of independent stances. We’ll proceed by defining the stances in code, putting them together in an animation, and adding the dance music. Our firefly will be quite the busy flier for this example.</p>&#13;
<h4 class="h4" id="lev2sec136"><span epub:type="pagebreak" id="page_406"/><strong><em>The Stances</em></strong></h4>&#13;
<p class="noindent">We’ll make the firefly trace the figure for each stance beginning and ending at position (2,2). This allows us to string the stances together in any order that we wish and be in the proper position when the program loops and begins again.</p>&#13;
<p class="indent">We will begin with Stance 1. As the figure dances, each move returns to Stance 1 before moving on to the next. <a href="ch15.xhtml#ch015list10">Listing 15-10</a> shows the code for Stance 1 along with the stance itself.</p>&#13;
<pre>MNN5    !   &#13;
SSSMW   !     5&#13;
5SS     !   55555&#13;
MNNEE   !     5&#13;
5SS     !    5 5&#13;
MSE     !    5 5&#13;
5WWWWW  ! &#13;
MWWS    !</pre>&#13;
<p class="caption" id="ch015list10"><em>Listing 15-10: Stance 1</em></p>&#13;
<p class="indent">With a bit of imagination, you’ll see a figure with outstretched arms. To make the figure dance, we’ll move the arms and legs in sequence. We can move both arms up or down, or move one up and the other down. Similarly, we can move the right leg out or the left leg out for a total of six possible stances. <a href="ch15.xhtml#ch015tab1">Table 15-1</a> gives us the code and the appearance of each stance.</p>&#13;
<p class="tabcap" id="ch015tab1"><strong>Table 15-1:</strong> The Remaining Stances</p>&#13;
<div class="image"><img src="Images/f0406-01.jpg" alt="Image" width="700" height="679"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_407"/>While developing this example, it was extremely helpful to use the console interpreter in trace mode. I first generated the code for each stance independently of the others. We’ll see below how this helps create the desired animation sequence by literally copying and pasting code in the right place.</p>&#13;
<h4 class="h4" id="lev2sec137"><strong><em>The Dance</em></strong></h4>&#13;
<p class="noindent">To animate the figure, we start with Stance 1, and after each move go back to Stance 1. The sequence is</p>&#13;
<p class="equationc">1 → 2 → 1 → 3 → 1 → 4 → 1 → 5 → 1 → 6 → 1 → 7</p>&#13;
<p class="noindent">where we end with Stance 7 and allow the program to loop to begin again with Stance 1.</p>&#13;
<p class="indent">Look carefully at the sequence of stances and think of Firefly’s double buffers. When the program starts, we’re looking at grid A and the firefly is drawing to grid A. We’ll draw Stance 1 in grid A, but doing that will let the user see the firefly draw, so we’ll show grid B while drawing Stance 1. Likewise, when the firefly has drawn Stance 1 in grid A, we’ll show grid A and tell the firefly to draw in grid B. Then, we’ll render Stance 2 in grid B.</p>&#13;
<p class="indent">At this point, we might be tempted to draw Stance 1 in grid A; however, Stance 1 is already in grid A, so we don’t need to draw it again. This is why the figure always returns to Stance 1 before moving to another stance—we can leave Stance 1 in grid A and only draw it once. When we need to draw a new stance, we’ll do it in grid B while showing Stance 1 in grid A.</p>&#13;
<p class="indent">Therefore, to animate, we need the following sequence, formatted as (<em>shown</em>, <em>drawn</em>):</p>&#13;
<p class="equationc">(<em>B</em>, <em>A</em>) → (<em>A</em>, <em>B</em>) → (<em>B</em>, ∗) → (<em>A</em>, <em>B</em>) → (<em>B</em>, ∗) → (<em>A</em>, <em>B</em>) →</p>&#13;
<p class="equationc">(<em>B</em>, ∗) → (<em>A</em>, <em>B</em>) → (<em>B</em>, ∗) → (<em>A</em>, <em>B</em>) → (<em>B</em>, ∗) → (<em>A</em>, <em>B</em>)</p>&#13;
<p class="noindent">Here, ∗ means we don’t change the grid drawn to as we’re showing Stance 1, which never needs to be redrawn. At each step in the sequence, save the first, the grid shown reveals the most recently drawn stance (or Stance 1).</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch015list11">Listing 15-11</a> presents the animation code in skeleton form to show the sequence of stances drawn and how the different grids are displayed and drawn to. To generate the actual code, replace instances of “draw Stance 1” and so on with the proper code block from <a href="ch15.xhtml#ch015tab1">Table 15-1</a> or <a href="ch15.xhtml#ch015list10">Listing 15-10</a>.</p>&#13;
<pre>YVA     ! show B, clear A, draw A&#13;
... draw Stance 1 ... &#13;
PPPPP&#13;
XZB     ! show A, clear B, draw B&#13;
... draw Stance 2 ... &#13;
PPPPP&#13;
Y       ! show B&#13;
PPPPP   ! pause&#13;
XZB     ! show A, clear B, draw B&#13;
... draw Stance 3 ... <span epub:type="pagebreak" id="page_408"/>&#13;
PPPPP&#13;
Y       ! show B&#13;
PPPPP&#13;
XZB     ! show A, clear B, draw B&#13;
... draw Stance 4 ... &#13;
PPPPP&#13;
Y       ! show B&#13;
PPPPP&#13;
XZB     ! show A, clear B, draw B&#13;
... draw Stance 5 ... &#13;
PPPPP&#13;
Y       ! show B&#13;
PPPPP&#13;
XZB     ! show A, clear B, draw B&#13;
... draw Stance 6 ... &#13;
PPPPP&#13;
Y       ! show B&#13;
PPPPP&#13;
XZB     ! show A, clear B, draw B&#13;
... draw Stance 7 ... &#13;
PPPPP</pre>&#13;
<p class="caption" id="ch015list11"><em>Listing 15-11: Animation sequence code skeleton</em></p>&#13;
<p class="indent">The <span class="literal">PPPPP</span> blocks delay for 0.5 seconds to control the speed of the animation. These are also the locations where we’ll later add music. To watch the animation without music, execute <em>dance.fly</em>.</p>&#13;
<h4 class="h4" id="lev2sec138"><strong><em>The Music</em></strong></h4>&#13;
<p class="noindent">Let’s add some music. The melody we’ll use was kindly written for us by film and television composer Paul Kneusel (see <a href="ch15.xhtml#ch015fig4">Figure 15-4</a>).</p>&#13;
<div class="image"><img id="ch015fig4" src="Images/15fig04.jpg" alt="Image" width="676" height="65"/></div>&#13;
<p class="figcap"><em>Figure 15-4: “Dance dance” by Paul Kneusel (</em><a href="https://www.paulkneusel.com/">https://www.paulkneusel.com/</a><em>)</em></p>&#13;
<p class="indent">Translating the score into Firefly code leads to <a href="ch15.xhtml#ch015list12">Listing 15-12</a>.</p>&#13;
<pre>!  first measure&#13;
5TG4TJ1TF 2TJ1TF 4TG1TJ6TF 5TG1TF 2TJ0TF 5TG1TF 1TF4TG2TJ 6TF&#13;
&#13;
!  second measure&#13;
4TJ5TF 2TJ5TF 1TJ3TF 5TF 2TJ0TF 5TF6TF 5TF&#13;
&#13;
!  third measure&#13;
4TJ4TF 2TJ4TF 1TJ3TF2TF 2TJ0TF 4TF 3TF 2TF&#13;
&#13;
<span epub:type="pagebreak" id="page_409"/>!  fourth measure&#13;
4TJ5TF 3TG1TJ5TF 6TF 0TF 4TG1TF 0TF 2TF 0TF 3TF 2TJ2TF 1TF</pre>&#13;
<p class="caption" id="ch015list12"><em>Listing 15-12: “Dance dance” in Firefly</em></p>&#13;
<p class="indent">You can hear the melody by loading <em>dance_loop.fly</em> onto the micro:bit or by watching the video on the GitHub site. The music plays in place, so the center LED on the micro:bit fluctuates in brightness as the melody plays.</p>&#13;
<p class="indent">To complete this section, we’ll merge the melody with the animation code. <a href="ch15.xhtml#ch015list11">Listing 15-11</a> has pauses between screens, <span class="literal">PPPPP</span>. For the musical version, we’ll replace the pauses with successive measures from the melody, so the first instance of <span class="literal">PPPPP</span> in <a href="ch15.xhtml#ch015list11">Listing 15-11</a> is replaced by the first measure of <a href="ch15.xhtml#ch015list12">Listing 15-12</a> and so on. The result is <em>dance_music.fly</em>. We won’t show the code here, but do read through it.</p>&#13;
<p class="indent">If you run <em>dance_music.fly</em>, you’ll hear the first measure as a sort of intro before the animation. There are noticeable pauses while successive screens are rendered in the buffer not shown, but the tune and animation still work.</p>&#13;
<h3 class="h3" id="lev1sec102"><strong>Tea Time</strong></h3>&#13;
<p class="noindent">There is no general agreement as to how long one should steep a cup of tea, but a rule of thumb I often use is about three and a half minutes for a cup of black tea. In this section, we’ll use Firefly to write a tea timer that runs for about three and a half minutes. Once you see the pattern, you’ll be able to adjust the delay to suit your tastes.</p>&#13;
<p class="indent">The timer counts down a display of LEDs. When the countdown is complete, the program animates the display while playing an alarm sound to let us know our tea is ready. This example is practical enough to make it worth dedicating an entire micro:bit to the task. Just put your teabag in the hot water, start the micro:bit, and wait for the visual and audio alarm to sound—your tea is now ready.</p>&#13;
<p class="indent">The source code is in <em>tea_timer.fly</em>. The program fills the first four rows of the display with maximum intensity. Then, starting with position (0,0), the program dims the LEDs by 1 after a one-second delay. When the LED at the current position is 0, the program moves to the next position and repeats. LED after LED is dimmed to 0 this way until all four rows are 0. After the display is completely 0, a brief animation of star patterns plays along with a rapid scale as the audio alarm.</p>&#13;
<p class="indent">Filling four rows of the display means we have 20 LEDs to dim. Each LED takes 10 seconds to go from maximum intensity to 0; therefore, dimming the display takes</p>&#13;
<div class="imagec"><img src="Images/f0409-01.jpg" alt="Image" width="450" height="47"/></div>&#13;
<p class="noindent">The animation and alarm add a few more seconds to give us an approximate three-and-a-half minute timer.</p>&#13;
<p class="indent">The timer starts by filling the first four rows of grid A with 9s (see <a href="ch15.xhtml#ch015list13">Listing 15-13</a>).</p>&#13;
<pre><span epub:type="pagebreak" id="page_410"/>Y       ! show B while setting up the screen&#13;
WWNN    ! move from (2,2) to (0,0)&#13;
9       ! full power&#13;
EEEES   ! first row&#13;
WWWWS   ! second row&#13;
EEEES   ! third row&#13;
WWWWS   ! fourth row, at (4,0)&#13;
M       ! move mode &#13;
NNNN    ! move to (0,0)&#13;
XD      ! screen ready, show A, decrement mode</pre>&#13;
<p class="caption" id="ch015list13"><em>Listing 15-13: Filling the display</em></p>&#13;
<p class="noindent">To avoid watching the display draw, grid B is shown until the first four rows of grid A are full, and then grid A is shown again after moving the firefly to position (0,0).</p>&#13;
<p class="indent">The countdown now begins. Here’s where the simplicity of Firefly pains us a bit. The pattern we need to implement is</p>&#13;
<pre>for r in 0..3:&#13;
    for c in 0..4:&#13;
        for i in 0..9:&#13;
            wait one second&#13;
            M[r,c] = M[r,c] - 1</pre>&#13;
<p class="noindent">Here, <span class="literal">M</span> is the micro:bit display, grid A. It would be nice to have some sort of looping construct, but Firefly is too primitive to support looping, so we need to unroll the loops and manually decrement each position to 0 before moving to the next position and then repeat, row by row.</p>&#13;
<p class="indent">Fortunately, once we have a pattern in place for the current position, we have what we need for virtually all the positions in a row. Once we have all we need for a row, we have what we need for all four rows. So unrolling the loops isn’t too bad and is relatively straightforward with the help of some copy-and-paste magic.</p>&#13;
<p class="indent">For example, to process the first column of the first row, meaning position (0,0), we need</p>&#13;
<pre>PPPPPPPPPPT ! show for one second, decrement&#13;
PPPPPPPPPPT&#13;
PPPPPPPPPPT&#13;
PPPPPPPPPPT&#13;
PPPPPPPPPPT&#13;
PPPPPPPPPPT&#13;
PPPPPPPPPPT&#13;
PPPPPPPPPPT&#13;
PPPPPPPPPPT&#13;
PPPPPPPPPP  ! show for one second&#13;
MED         ! move to the next column, restore decrement</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_411"/>The first line pauses for one second, then uses <span class="literal">T</span> to decrement the current position without moving. This changes intensity 9 to intensity 8. Repeating this process eight more times results in intensity 0 at (0,0). We need to wait one more second for the 0 intensity before moving to the next column with <span class="literal">MED</span>. We are now at position (0,1) and ready to repeat this code block. We do the same for positions (0,2), (0,3), and (0,4).</p>&#13;
<p class="indent">At the end of position (0,4), we need to move to the next row. So instead of executing <span class="literal">MED</span>, we execute <span class="literal">MESD</span> to arrive at (1,0). The entire process repeats for row 1, row 2, and row 3. However, at the end of row 3, the timer portion is complete and all of grid A is empty. We conclude by moving to (2,2) via <span class="literal">MWWN</span> so we are in position to begin the animation and alarm.</p>&#13;
<p class="indent">The animation is straightforward: two star patterns, with one stored on each grid. We’ll toggle between them while playing the alarm. <a href="ch15.xhtml#ch015list14">Listing 15-14</a> shows the code.</p>&#13;
<pre>YA      ! show memory B, draw on A&#13;
7EM     ! (2,2) = 7&#13;
N5W     ! (1,3) = 5&#13;
MW5W    ! (1,1) = 5&#13;
MN3EM   ! (0,0) = 3&#13;
EEE3S   ! (0,4) = 3&#13;
MSSS3W  ! (4,4) = 3&#13;
MWWW3N  ! (4,0) = 3&#13;
ME5E    ! (3,1) = 5&#13;
ME5E    ! (3,3) = 5&#13;
MNWW    ! at (2,2)&#13;
&#13;
XB      ! show memory A, draw on B&#13;
7E5E3S  ! (2,2)=7, (2,3)=5, (2,4)=3&#13;
MWW5W   ! (3,2)=5&#13;
MN5W3N  ! (2,1)=5, (2,0)=3&#13;
MEE5N   ! (1,2)=5&#13;
3E      ! (0,2)=3&#13;
MSSSSW  !&#13;
3W      ! (4,2)=3&#13;
MNNE    ! to (2,2)&#13;
1TJI    ! set duration and note&#13;
Y       ! show memory B&#13;
&#13;
PTFXPTFYPTFX  ! animate for ~2 seconds&#13;
PTFYPTFXPTFY  ! while playing the scale&#13;
PTFXPTFYPTFX&#13;
PTFXPTFYPTFX&#13;
PTFYPTFXPTFY&#13;
PTFXPTFYPTFX&#13;
AC            ! showing A, work with A, clear&#13;
H</pre>&#13;
<p class="caption" id="ch015list14"><em>Listing 15-14: Animation and alarm code</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_412"/>There are three code blocks. The first generates an X shape on grid A and the second displays a + shape on grid B. The last block toggles between grids A and B while playing a scale over and over. Note that the firefly is at position (2,2), so the center pixel on both grids changes as the animation happens. When complete, the program exits, and our tea is ready.</p>&#13;
<p class="indent">The tea timer concludes our Firefly examples. There is one more, using genetic programming to evolve Firefly programs, but its complexity requires moving it to Appendix 16. Do take a look. The examples of this chapter are fun and whimsical. The example in Appendix 16 demonstrates a more sophisticated way to use even the tiniest of esolangs.</p>&#13;
<h3 class="h3" id="lev1sec103"><strong>Discussion</strong></h3>&#13;
<p class="noindent">Firefly is most definitely <em>not</em> Turing complete. We learned in <a href="ch03.xhtml#ch03">Chapter 3</a> that a Turing complete imperative programming language requires some form of conditional branching and arbitrary memory. Firefly has no branching, conditional or otherwise, and minimal memory; therefore, Firefly is not Turing complete and not able to implement, even in theory, arbitrary algorithms.</p>&#13;
<p class="indent">However, as the examples of this chapter demonstrate, Firefly does support useful programs. We created a counter suitable for timing things in the real world. We also created a timer for steeping tea and programs to play music. Even the random sci-fi backgrounds are useful, if desired: imagine a wall of micro:bits each running <em>random.fly</em> or <em>random2.fly</em> and built into a prop.</p>&#13;
<p class="indent">Is Firefly all it could be? Definitely not. The micro:bit has two pushbuttons for user input, but Firefly ignores them. And this says nothing about all the many other advanced features the micro:bit supports. One reason for making Firefly primitive was the limited memory of the version 1 micro:bit. Another was the need for simplicity in the presentation via a physical book. Firefly is screaming for enhancement. I genuinely hope a reader or two accepts the challenge and enhances the language. If you do, please share it with us. Part of the fun of esoteric programming languages is how they build upon each other—just witness the many variants of BF. One language’s ideas prompt new thoughts about languages and lead to “what if” ideas, which lead to new esolangs.</p>&#13;
<h3 class="h3" id="lev1sec104"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we presented many examples of Firefly programs. Some were trivial, like <em>hi.fly</em>, and others were visually appealing, like <em>random.fly</em>, or musical, like <em>ode.fly</em>. Some were cute, like <em>dance.fly</em>, and some were perhaps even a bit useful, like <em>fly_time.fly</em> and <em>tea_timer.fly</em>. Regardless, all were (hopefully) fun. Many more fun Firefly programs doubtless exist, waiting to <span epub:type="pagebreak" id="page_413"/>be extracted from the ether and written down. For example, its display and its compact size makes the thought of embedding the micro:bit in a craft or holiday decoration something to consider.</p>&#13;
<p class="indent">Firefly also concludes our exploration of esolangs and programming languages in general. Only one chapter remains: where to go from here.<span epub:type="pagebreak" id="page_414"/></p>&#13;
</div></body></html>