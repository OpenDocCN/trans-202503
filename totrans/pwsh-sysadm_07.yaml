- en: '6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WRITING FUNCTIONS
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, the code you’ve written has been fairly one-dimensional: your scripts
    had a single task. And while there’s nothing wrong with a script that can only
    access files in a folder, you’ll want code that can do more than one thing as
    you write more-robust PowerShell tools. There’s nothing stopping you from packing
    more and more into a script. You could write a thousand lines of code that do
    hundreds of tasks, all in a single, uninterrupted block of code. But that script
    would be a mess to read and a mess to work with. You could break each task into
    its own script, but that would be a mess to use. You want one tool that can do
    many things, not a hundred that can each do a single thing.'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you’ll break each task into its own *function*, a labeled piece
    of code that performs a single task. A function is defined once. You write the
    code to solve a certain problem once, store it in a function, and anytime you
    run into that problem, you just use—or *call*—the function that solves it. Functions
    dramatically increase the usability and readability of your code, making it much
    easier to work with. In this chapter, you’ll learn to write functions, add and
    manage your functions’ parameters, and set up functions to accept pipeline input.
    But first, let’s look at a bit of terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Functions vs. Cmdlets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the idea of a function sounds familiar, it is probably because it sounds
    a bit like the cmdlets you’ve been using throughout this book, such as `Start-Service`
    and `Write-Host`. These are also named pieces of code that solve a single problem.
    The difference between a function and a cmdlet is *how* each of these constructs
    is made. A cmdlet isn’t written with PowerShell. It’s written in another language,
    typically something like C#, and then it’s compiled and made available inside
    PowerShell. Functions, on the other hand, are written in PowerShell’s simple scripting
    language.
  prefs: []
  type: TYPE_NORMAL
- en: You can see which commands are cmdlets and which are functions by using the
    `Get-Command` cmdlet and its `CommandType` parameter, as in [Listing 6-1](ch06.xhtml#ch6list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-1: Displaying the available functions*'
  prefs: []
  type: TYPE_NORMAL
- en: This command will display all the functions currently loaded into your PowerShell
    session, or inside modules that are available to PowerShell ([Chapter 7](ch07.xhtml#ch7)
    covers modules). To see other functions, you have to copy and paste them into
    the console, add them to an available module, or *dot source* them (which we’ll
    also cover later).
  prefs: []
  type: TYPE_NORMAL
- en: With that out of the way, let’s start writing functions.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you can use a function, you need to define it. To define a function,
    you use the `function` keyword, followed by a descriptive, user-defined name,
    followed by a set of curly brackets. Inside the curly brackets is a scriptblock
    that you want PowerShell to execute. [Listing 6-2](ch06.xhtml#ch6list2) defines
    a basic function in the console and executes it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-2: Writing a message to the console with a simple function*'
  prefs: []
  type: TYPE_NORMAL
- en: The function you’ve defined, `Install-Software`, uses `Write-Host` to display
    a message in the console. Once it’s defined, you can use this function’s name
    to execute the code inside its scriptblock.
  prefs: []
  type: TYPE_NORMAL
- en: A function’s name is important. You can name your functions whatever you want,
    but the name should always describe what the function does. Function-naming convention
    in PowerShell follows the Verb-Noun syntax, and it’s considered best practice
    to always use this syntax unless absolutely necessary. You can use the `Get-Verb`
    command to see a list of recommended verbs. The noun is typically the singular
    name of whatever entity you’re working with—in this case, software.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to change the behavior of a function, you can redefine it, as in
    [Listing 6-3](ch06.xhtml#ch6list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-3: Redefining the Install-Software function to change its behavior*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve redefined `Install-Software`, it will display a slightly different
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Functions can be defined in a script or typed directly into the console. In
    [Listing 6-2](ch06.xhtml#ch6list2), you had a small function, so defining it in
    the console wasn’t a problem. Most of the time, you’ll have bigger functions,
    and it’ll be easier to define those functions in a script or a module, and then
    call that script or module in order to load the function into memory. As you might
    imagine from [Listing 6-3](ch06.xhtml#ch6list3), retyping a hundred-line function
    every time you want to tweak its functionality could get a little frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, you’ll expand our `Install-Software` function
    to accept parameters and accept pipeline input. I suggest you open your favorite
    editor and store the function in a *.ps1* file as you’re working through the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Parameters to Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PowerShell functions can have any number of parameters. When you create your
    own functions, you’ll have the option to include parameters and decide how those
    parameters work. The parameters can be mandatory or optional, and they can either
    accept anything or be forced to accept one of a limited list of possible arguments.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the fictional software you’re installing via the `Install-Software`
    function might have many versions, but currently, the `Install-Software` function
    offers a user no way to specify which version they want to install. If you were
    the only one using the function, you could redefine the function each time you
    wanted a specific version—but that would be a waste of time and would be prone
    to potential errors, not to mention that you want others to be able to use your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing parameters into your function allows it to have variability. Just
    as variables allowed you to write scripts that could handle many versions of the
    same situation, parameters allow you to write a single function that does one
    thing many ways. In this case, you want it to install multiple versions of the
    same piece of software, and do so on many computers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first add a parameter to the function that enables you or a user to specify
    the version to install.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Simple Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Creating a parameter on a function requires a `param` block, which will hold
    all the parameters for the function. You can define a `param` block with the `param`
    keyword followed by parentheses, as in [Listing 6-4](ch06.xhtml#ch6list4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-4: Defining a param block*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, your function’s actual functionality hasn’t changed. You’ve just
    installed the plumbing, preparing the function for a parameter. You’ll use a `Write-Host`
    command to simulate the software installation so you can focus on writing the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the demos this for book, you’ll build only* advanced *functions. There
    are also* basic *functions, but nowadays, they’re typically used in only small,
    niche situations. The differences are too nuanced to go into detail, but if you
    see a [CmdletBinding()] reference under the function name, or a parameter defined
    as [Parameter()], you know you’re working with an advanced function.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve added the `param` block, you can create the parameter by putting
    it within the `param` block’s parentheses, as in [Listing 6-5](ch06.xhtml#ch6list5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-5: Creating a parameter*'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `param` block, you first define the `Parameter` block ❶. An empty
    `Parameter` block like the one here does nothing but is required (I’ll explain
    how to use it in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus instead on the `[string]` type ❷ in front of the parameter name.
    By putting the parameter’s type between square brackets before the parameter variable
    name, you can cast the parameter so PowerShell will always try to convert any
    value that’s passed to this parameter into a string—if it isn’t one already. Here,
    anything passed in as `$Version` will always be treated as a string. Casting your
    parameter to a type isn’t mandatory, but I highly encourage it, because explicitly
    defining the type will significantly reduce errors down the road.
  prefs: []
  type: TYPE_NORMAL
- en: You also add `$Version` into your print statement ❸, which means that when you
    run the `Install-Software` command with the `Version` parameter and pass it a
    version number, you should get a statement saying so, as in [Listing 6-6](ch06.xhtml#ch6list6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-6: Passing a parameter to your function*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now defined a working parameter to your function. Let’s see what you
    can do with that parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The Mandatory Parameter Attribute
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use the `Parameter` block to control various *parameter attributes*,
    which will allow you to change the behavior of the parameter. For example, if
    you want to make sure anyone calling the function has to pass in a given parameter,
    you could define that parameter as `Mandatory`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, parameters are optional. Let’s force the user to pass in a version
    by using the `Mandatory` keyword inside the `Parameter` block, as in [Listing
    6-7](ch06.xhtml#ch6list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-7: Using a mandatory parameter*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this, you should get the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve set the `Mandatory` attribute, executing the function without the
    parameter will halt execution until the user inputs a value. The function will
    wait until the user specifies a value for the `Version` parameter, and once they
    enter it, PowerShell will execute the function and move on. To avoid this prompt,
    simply pass the value as a parameter when you call the function with the -ParameterName
    syntax—for example, `Install-Software -Version 2`.
  prefs: []
  type: TYPE_NORMAL
- en: Default Parameter Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also assign a parameter a default value when the parameter is defined.
    This is useful when you expect a certain value for a parameter most of the time.
    For example, if you want to install version 2 of this software 90 percent of the
    time, and you’d rather not have to set the value every time you run this function,
    you could assign a default value of `2` to the `$Version` parameter, as in [Listing
    6-8](ch06.xhtml#ch6list8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-8: Using a default parameter value*'
  prefs: []
  type: TYPE_NORMAL
- en: Having a default parameter doesn’t prevent you from passing one in. Your passed-in
    value will override the default value.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Parameter Validation Attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to making parameters mandatory and giving them default values, you
    can restrict them to certain values by using *parameter validation attributes*.
    When possible, limiting the information that users (or even you!) can pass to
    your functions or scripts will eliminate unnecessary code inside your function.
    For example, say you pass the value 3 to your `Install-Software` function, knowing
    that version 3 is an existing version. Your function assumes that every user knows
    which versions exist, so it doesn’t account for what happens when you try to specify
    version 4\. In that case, the function will fail to find the version’s folder
    because it doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 6-9](ch06.xhtml#ch6list9), you use the `$Version` string in a file
    path. If someone passes a value that doesn’t complete an existing folder name
    (for example, SoftwareV3 or SoftwareV4), the code will fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-9: Assuming parameter values*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You could write error-handling code to account for this problem, or you could
    nip the problem in the bud by requiring the user pass only an existing version
    of the software. To limit the user’s input, you’ll add parameter validation.
  prefs: []
  type: TYPE_NORMAL
- en: Various kinds of parameter validation exist, but with respect to your `Install-Software`
    function, the `ValidateSet` attribute works best. The `ValidateSet` attribute
    enables you to specify a list of values allowed for the parameter. If you’re accounting
    for only the string 1 or 2, you’d ensure that the user can specify only these
    values; otherwise, the function will fail immediately and notify the user why.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add parameter validation attributes inside the `param` block, right under
    the original `Parameter` block, as in [Listing 6-10](ch06.xhtml#ch6list10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-10: Using the ValidateSet parameter validation attribute*'
  prefs: []
  type: TYPE_NORMAL
- en: You add the set of items 1 and 2 inside the `ValidateSet` attribute’s trailing
    parentheses, which tells PowerShell that the only values valid for `Version` are
    1 or 2\. If a user tries to pass something besides what’s in the set, they will
    receive an error message (see [Listing 6-11](ch06.xhtml#ch6list11)) notifying
    them that they have only a specific number of options available.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-11: Passing a parameter value that’s not in the ValidateSet block*'
  prefs: []
  type: TYPE_NORMAL
- en: The `ValidateSet` attribute is a common validation attribute, but others are
    available. For a complete breakdown of all the ways parameter values can be restricted,
    check out the `Functions_Advanced_Parameters` help topic by running `Get-Help
    about_Functions_Advanced_Parameters`.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting Pipeline Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, you’ve created a function with a parameter that can be passed only by
    using the typical -ParameterName <Value> syntax. But in [Chapter 3](ch03.xhtml#ch3),
    you learned that PowerShell has a pipeline that allows you to seamlessly pass
    objects from one command to another. Recall that some functions didn’t have pipeline
    capability—when working with your own functions, that’s something you control.
    Let’s add pipeline capabilities to our `Install-Software` function.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Another Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, you’ll add another parameter to your code that specifies the computer
    on which you want to install the software. You’ll also add that parameter to your
    `Write-Host` command to simulate the installation. [Listing 6-12](ch06.xhtml#ch6list12)
    adds the new parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-12: Adding the ComputerName parameter*'
  prefs: []
  type: TYPE_NORMAL
- en: Just as with `$Version`, you’ve added the `ComputerName` parameter to the `param`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve added the `ComputerName` parameter to the function, you could iterate
    over a list of computer names and pass the values for the computer name and the
    version to the `Install-Software` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: But as you’ve seen a few times already, you should forgo `foreach` loops like
    this and use the pipeline instead.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Function Pipeline Compatible
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unfortunately, if you try to use the pipeline straightaway, you’ll get errors.
    Before you add pipeline support to the function, you should decide which type
    of pipeline input you want the function to accept. As you learned in [Chapter
    3](ch03.xhtml#ch3), a PowerShell function uses two kinds of pipeline input: `ByValue`
    (entire object) and `ByPropertyName` (a single object property). Here, because
    our `$computers` list contains only strings, you’ll pass those strings via `ByValue`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add pipeline support, you add a parameter attribute to the parameter you
    want by using one of two keywords: `ValueFromPipeline` or `ValueFromPipelineByPropertyName`,
    as in [Listing 6-13](ch06.xhtml#ch6list13).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-13: Adding pipeline support*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script again, and you should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `Install-Software` executes for only the last string in the array.
    You’ll see how to fix this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a process Block
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To tell PowerShell to execute this function for every object coming in, you
    must include a `process` block. Inside the `process` block, you put the code you
    want to execute each time the function receives pipeline input. Add a `process`
    block to your script, as shown in [Listing 6-14](ch06.xhtml#ch6list14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-14: Adding a process block*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `process` keyword is followed by a set of curly brackets, which
    contain the code your function executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `process` block, you should see output for all three servers in `$computers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `process` block should contain the main code you want to execute. You can
    also use `begin` and `end` blocks for code that will execute at the beginning
    and end of the function call. For more information about building advanced functions
    including the `begin`, `process`, and `end` blocks, check out the `about``_Functions_Advanced`
    help topic by running `Get-Help about_Functions_Advanced`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions allow you to compartmentalize code into discrete building blocks.
    They not only help you break your work into smaller, more manageable chunks, but
    also force you to write readable and testable code. When you use descriptive names
    for your functions, your code becomes self-documenting, and anyone reading it
    can intuitively understand what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you learned the basics of functions: how to define them, how
    to specify parameters and their attributes, and how to accept pipeline input.
    In the next chapter, you’ll see how to bundle many functions together by using
    modules.'
  prefs: []
  type: TYPE_NORMAL
