<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_215" aria-label="215"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch11">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">DIFFIE–HELLMAN</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">In November 1976, Stanford researchers Whitfield Diffie and Martin Hellman published a research paper titled “New Directions in Cryptography” that revolutionized cryptography forever. Their paper introduced the notion of public-key encryption and signatures, though they didn’t actually have any of those schemes; they simply had what they termed a <i>public-key cryptosystem</i>, a protocol that allows two parties to establish a shared secret by exchanging information visible to an eavesdropper. This is now known as the <i>Diffie–Hellman (DH) protocol</i>. Prior to Diffie–Hellman, establishing a shared secret required tedious procedures such as manually exchanging sealed envelopes.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_216" aria-label="216"/>Once communicating parties establish a shared secret value with the DH protocol, they can use that secret to establish a <i>secure channel</i> by turning the secret into one or more symmetric keys that they then use to encrypt and authenticate subsequent communication. The DH protocol and its variants are therefore called <i>key agreement</i> protocols.</p>&#13;
<p class="TX">In the first part of this chapter, you’ll read about the mathematical foundations of the Diffie–Hellman protocol, including the computational problems that DH relies on to perform its magic. Then you’ll learn about different versions of the Diffie–Hellman protocol you can use to create secure channels. Finally, because Diffie–Hellman schemes are secure only when their parameters are well chosen, you’ll see scenarios where Diffie–Hellman can fail.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Diffie and Hellman received the prestigious Turing Award in 2015 for their invention of public-key cryptography and digital signatures, but others deserve credit as well. In 1974, while a computer science undergraduate, Ralph Merkle introduced the idea of public-key cryptography with</i> <span class="note_Italic">Merkle’s puzzles</span><i>. Around that same time, researchers at the British Government Communications Headquarters (GCHQ), the British equivalent of the NSA, discovered the principles behind Rivest–Shamir–Adleman (RSA) and Diffie–Hellman key agreement, though that fact was declassified only decades later.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-76"/><samp class="SANS_Futura_Std_Bold_B_11">The Diffie–Hellman Function</samp></h3>&#13;
<p class="TNI">To understand DH key agreement protocols, you must understand their core operation, the <i>DH function</i>. Diffie and Hellman originally defined the DH function to work with groups denoted <b>Z</b><span class="ePub-I-SUB">p</span><sup>*</sup>, which consist of nonzero integer numbers modulo a prime number, which is usually denoted <i>p</i> (see <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>). Another public parameter is the base number, or <i>generator</i>, <i>g</i>.</p>&#13;
<p class="TX">The DH function involves two private values chosen randomly by the two communicating parties from the group <b>Z</b><span class="ePub-I-SUB">p</span><sup>*</sup>, which we’ll write <i>a</i> and <i>b</i>. A private value <i>a</i> is associated with the public value <i>A</i> = <i>g</i><i><sup>a</sup></i> mod <i>p</i>, or <i>g</i> raised to the power <i>a</i> modulo <i>p</i>. This <i>A</i> is sent to the other party through a message visible to eavesdroppers. The public value associated with <i>b</i> is <i>B</i> = <i>g</i><i><sup>b</sup></i> mod <i>p</i>, which is sent to the owner of <i>a</i>. An attacker can thus learn <i>A</i> and <i>B</i>.</p>&#13;
<p class="TX">DH works by combining either public value with the other private value, such that the result is the same in both cases: <i>A</i><i><sup>b</sup></i> = (<i>g</i><i><sup>a</sup></i>)<i><sup>b</sup></i> = <i>g</i><i><sup>ab</sup></i> and <i>B</i> <i><sup>a</sup></i> = (<i>g</i><i><sup>b</sup></i>)<i><sup>a</sup></i> = <i>g</i><i><sup>ba</sup></i> = <i>g</i><i><sup>ab</sup></i>. The resulting value, <i>g</i><i><sup>ab</sup></i>, is the <i>shared secret</i>; you then pass it to a <i>key derivation function (KDF)</i> to generate one or more shared symmetric keys. A KDF is a kind of hash function that returns a random-looking string the size of the desired key length.</p>&#13;
<p class="TX">And that’s it. Like many great scientific discoveries (gravity, relativity, quantum computing, or RSA), the Diffie–Hellman trick is relatively simple in hindsight.</p>&#13;
<p class="TX">Diffie–Hellman’s simplicity can be deceiving, however. For one, it won’t work with just any prime <i>p</i> or base number <i>g</i>. Some values of <i>g</i> restrict the shared secrets <i>g</i><i><sup>ab</sup></i> to a small subset of possible values, whereas you’d expect <span role="doc-pagebreak" epub:type="pagebreak" id="pg_217" aria-label="217"/>to have about as many possible values as elements in <b>Z</b><span class="ePub-I-SUB">p</span><sup>*</sup> and therefore as many possible values for the shared secret. To ensure the highest security, safe DH parameters should work with a prime <i>p</i> such that (<i>p</i> – 1)/2 is also prime. Such a <i>safe prime</i> guarantees that the group doesn’t have small subgroups that would make DH easier to break. With a safe prime, DH can work with any element in <b>Z</b><span class="ePub-I-SUB">p</span><sup>*</sup>, excepting 1 and <i>p</i> – 1; notably, <i>g</i> = 2 makes computations slightly faster. But generating a safe prime <i>p</i> takes more time than generating a totally random one.</p>&#13;
<p class="TX">For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">dhparam</samp> command of the OpenSSL toolkit generates only safe DH parameters, but the extra checks built into the algorithm result increase the execution time considerably, as <a href="chapter11.xhtml#Lis11-1">Listing 11-1</a> shows.</p>&#13;
<span id="Lis11-1"/><pre><code>$ <b>time openssl dhparam 2048</b>&#13;
Generating DH parameters, 2048 bit long safe prime, generator 2&#13;
This is going to take a long time&#13;
<var>--snip--</var>&#13;
-----BEGIN DH PARAMETERS-----&#13;
MIIBCAKCAQEAoSIbyA9e844q7V89rcoEV8vd/l2svwhIIjG9EPwWWr7FkfYhYkU9&#13;
fRNttmilGCTfxc9EDf+4dzw+AbRBc6oOL9gxUoPnOd1/G/YDYgyplF5M3xeswqea&#13;
SD+B7628pWTaCZGKZham7vmiN8azGeaYAucckTkjVWceHVIVXe5fvU74k7+C2wKk&#13;
iiyMFm8th2zm9W/shiKNV2+SsHtD6r3ZC2/hfu7XdOI4iT6ise83YicU/cRaDmK6&#13;
zgBKn3SlCjwL4M3+m1J+Vh0UFz/nWTJ1IWAVC+aoLK8upqRgApOgHkVqzP/CgwBw&#13;
XAOE8ncQqroJ0mUSB5eLqfpAvyBWpkrwQwIBAg==&#13;
-----END DH PARAMETERS-----&#13;
openssl dhparam 2048  7.46s user 0.10s system 99% cpu 7.593 total</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Measuring the execution time of generating 2,048-bit Diffie–Hellman parameters with the OpenSSL toolkit</samp></p>&#13;
<p class="TX">It took around eight seconds to generate the DH parameters using the OpenSSL toolkit (it’s common to observe generation times in the order of 30 seconds or even more than 1 minute).</p>&#13;
<p class="TX">For the sake of comparison, <a href="chapter11.xhtml#Lis11-2">Listing 11-2</a> shows how long it takes on the same system to generate RSA parameters of the same size (that is, two prime numbers, <i>p</i> and <i>q</i>, each half the size of the <i>p</i> used for DH).</p>&#13;
<span id="Lis11-2"/><pre><code>$ <b>time openssl genrsa 2048</b>&#13;
Generating RSA private key, 2048 bit long modulus&#13;
...................................................+++&#13;
.............................................................+++&#13;
e is 65537 (0x10001)&#13;
-----BEGIN RSA PRIVATE KEY-----&#13;
<var>--snip--</var>&#13;
-----END RSA PRIVATE KEY-----&#13;
openssl genrsa 2048  0.16s user 0.01s system 95% cpu 0.171 total</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: Generating 2,048-bit RSA parameters while measuring the execution time</samp></p>&#13;
<p class="TX">Generating DH parameters took about 50 times longer than generating RSA parameters of the same security level, mainly due to the extra constraint imposed on the prime generated to create DH parameters.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_218" aria-label="218"/>&#13;
<h3 class="H1" id="sec2"><span id="h1-77"/><samp class="SANS_Futura_Std_Bold_B_11">The Diffie–Hellman Problems</samp></h3>&#13;
<p class="TNI">The security of DH protocols relies on the hardness of computational problems, especially on that of the discrete logarithm problem (DLP) from <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>. You can break DH by recovering the private value <i>a</i> from its public value <i>g</i><i><sup>a</sup></i>, which boils down to solving a DLP instance. But we don’t care about just the discrete logarithm problem when using DH to compute shared secrets. We also care about two DH-specific problems.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-134"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Computational Problem</samp></h4>&#13;
<p class="TNI">The <i>computational Diffie–Hellman (CDH)</i> problem is that of computing the shared secret <i>g</i> <i><sup>ab</sup></i> given only the public values <i>g</i> <i><sup>a</sup></i> and <i>g</i> <i><sup>b</sup></i>, without knowing the secret values <i>a</i> and <i>b</i>. The motivation is to ensure that even if an eavesdropper captures <i>g</i> <i><sup>a</sup></i> and <i>g</i> <i><sup>b</sup></i>, they shouldn’t be able to determine the shared secret <i>g</i> <i><sup>ab</sup></i>.</p>&#13;
<p class="TX">If you can solve DLP, then you can also solve CDH; that is, if you determine <i>a</i> and <i>b</i> given <i>g</i> <i><sup>a</sup></i> and <i>g</i> <i><sup>b</sup></i>, then you’ll be able to compute <i>g</i> <i><sup>ab</sup></i>. In other words, DLP is <i>at least</i> as hard as CDH. But you don’t know for sure whether CDH is at least as hard as DLP, which would make the problems equally hard. In other words, DLP is to CDH what the factoring problem is to the RSA problem. (Recall that factoring allows you to solve the RSA problem but not necessarily the converse.)</p>&#13;
<p class="TX">Diffie–Hellman shares another similarity with RSA in that DH delivers a similar security level as RSA for a given modulus size. For example, the DH protocol with a 2,048-bit prime <i>p</i> offers roughly 90-bit security, as RSA with a 2,048-bit modulus. Indeed, the fastest way to break CDH is to solve DLP using the <i>number field sieve</i> algorithm, a method similar but not identical to the general number field sieve (GNFS), which breaks RSA by factoring its modulus.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-135"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Decisional Problem</samp></h4>&#13;
<p class="TNI">When you need a seemingly stronger assumption than CDH’s hardness, enter the <i>decisional Diffie–Hellman (DDH)</i> problem. Given <i>g</i> <i><sup>a</sup></i>, <i>g</i> <i><sup>b</sup></i>, and a value that’s either <i>g</i> <i><sup>ab</sup></i> or <i>g</i> <i><sup>c</sup></i> for some random <i>c</i> (each of the two with a chance of 1/2), the DDH problem consists of determining whether <i>g</i> <i><sup>ab</sup></i> (the shared secret corresponding to <i>g</i> <i><sup>a</sup></i> and <i>g</i> <i><sup>b</sup></i>) was chosen.</p>&#13;
<p class="TX">Relying on DDH rather than CDH is relevant in the following case: imagine that an attacker can compute only the first 32 bits of <i>g</i> <i><sup>ab</sup></i> given the 2,048-bit values of <i>g</i> <i><sup>a</sup></i> and <i>g</i> <i><sup>b</sup></i>. Although CDH remains unbroken because 32 bits may not be enough to completely recover <i>g</i> <i><sup>ab</sup></i>, the attacker would’ve learned something about the shared secret, which might allow them to compromise an application’s security.</p>&#13;
<p class="TX">To ensure that an attacker can’t learn anything about the shared secret <i>g</i> <i><sup>ab</sup></i>, this value needs to be <i>indistinguishable</i> from a random group element, just as an encryption scheme is secure when ciphertexts are indistinguishable from random strings. That is, an attacker shouldn’t be able <span role="doc-pagebreak" epub:type="pagebreak" id="pg_219" aria-label="219"/>to determine whether a given number is <i>g</i> <i><sup>ab</sup></i> or <i>g</i><i><sup>c</sup></i> for some random <i>c</i>, given <i>g</i><i><sup>a</sup></i>, <i>g</i><i><sup>b</sup></i>. The <i>decisional Diffie–Hellman assumption</i> assumes that no attacker can solve DDH efficiently.</p>&#13;
<p class="TX">If DDH is hard, then so is CDH, and you can’t learn anything about <i>g</i> <i><sup>ab</sup></i>. So if you can solve CDH, you can also solve DDH: given a triplet (<i>g</i> <i><sup>a</sup></i>, <i>g</i> <i><sup>b</sup></i>, <i>x</i>), you’d be able to derive <i>g</i> <i><sup>ab</sup></i> from <i>g</i><i><sup>a</sup></i> and <i>g</i> <i><sup>b</sup></i> and check whether the result is equal to the given <i>x</i>.</p>&#13;
<p class="TX">The bottom line is that DDH is fundamentally less hard than CDH (notably, DDH is not hard over <b>Z</b><span class="ePub-I-SUB">p</span><sup>*</sup>, contrarily to CDH), yet DDH hardness is a prime assumption in cryptography and one of the most studied.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-136"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variants of Diffie–Hellman</samp></h4>&#13;
<p class="TNI">Sometimes cryptographers devise new schemes and prove that they’re at least as hard to break as it is to solve some hard problem. But such hard problems are not always CDH or DDH but instead can be variants of them. We’d like to be able to demonstrate that breaking a cryptosystem is as hard as solving CDH or DDH, but this isn’t always possible with advanced cryptographic mechanisms, typically because such schemes involve more complex operations than basic Diffie–Hellman protocols.</p>&#13;
<p class="TX">For example, in one DH-like problem, given <i>g</i><i><sup>a</sup></i>, an attacker attempts to compute <i>g</i><sup>1/</sup><i><sup>a</sup></i>, where 1/<i>a</i> is the inverse of <i>a</i> in the group (typically <b>Z</b><span class="ePub-I-SUB">p</span><sup>*</sup> for some prime <i>p</i>). In another, an attacker might distinguish the pairs (<i>g</i><i><sup>a</sup></i>, <i>g</i><i><sup>b</sup></i>) from the pairs (<i>g</i><i><sup>a</sup></i>, <i>g</i><sup>1/</sup><i><sup>a</sup></i>) for random <i>a</i> and <i>b</i>. Finally, in the <i>twin Diffie–Hellman problem</i>, given <i>g</i><i><sup>a</sup></i>, <i>g</i><i><sup>b</sup></i>, and <i>g</i><i><sup>c</sup></i>, an attacker attempts to compute the two values <i>g</i><i><sup>ab</sup></i> and <i>g</i><i><sup>ac</sup></i>. Sometimes such DH variants turn out to be as hard as CDH or DDH, and sometimes they’re fundamentally easier—and therefore provide lower security guarantees. As an exercise, try to find connections between the hardness of these problems and that of CDH and DDH. (Twin Diffie–Hellman is actually <i>as hard</i> as CDH, but that isn’t easy to prove!)</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H1" id="sec6"><span id="h1-78"/><samp class="SANS_Futura_Std_Bold_B_11">Key Agreement Protocols</samp></h3>&#13;
<p class="TNI">The Diffie–Hellman problem is designed to build secure key agreement protocols, which secure communication between two or more parties communicating over a network with the aid of a shared secret. The parties turn this secret into one or more <i>session keys</i>—symmetric keys that encrypt and authenticate the information exchanged for the duration of the session.</p>&#13;
<p class="TX">Before studying actual DH protocols, you should know what makes a key agreement protocol secure and how simpler protocols work. We’ll begin our discussion with a prevalent key agreement protocol that doesn’t rely on DH.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-137"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Non-DH Key Agreement</samp></h4>&#13;
<p class="TNI">To provide a sense of how a key agreement protocol works and what it means for it to be secure, let’s look at the protocol the 4G and 5G <span role="doc-pagebreak" epub:type="pagebreak" id="pg_220" aria-label="220"/>telecommunications standards use to establish communication between a SIM card and a telecom operator: <i>authenticated key agreement (AKA)</i>. It doesn’t use the Diffie–Hellman function but instead uses only symmetric-key operations. <a href="chapter11.xhtml#fig11-1">Figure 11-1</a> details how the protocol works.</p>&#13;
<figure class="IMG"><img id="fig11-1" class="img1" src="../images/fig11-1.jpg" alt="" width="1381" height="663"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: The AKA protocol in 4G and 5G telecommunication</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this description of the protocol, the SIM card has a secret key, <i>K</i>, that the operator knows. The operator begins the session by selecting a random value, <i>R</i>, and then computes two values, <i>SK</i> and <i>V</i><sub>1</sub>, based on two pseudorandom functions, <b>PRF</b>0 and <b>PRF</b>1. Next, the operator sends a message to the SIM card containing the values <i>R</i> and <i>V</i><sub>1</sub>, which are visible to attackers. Once the SIM card has <i>R</i>, it has what it needs to compute <i>SK</i> with <b>PRF</b>0, and it does. The two parties in this session end up with a shared key, <i>SK</i>, that attackers are unable to determine by simply looking at the messages exchanged between the parties, or even by modifying them or injecting new ones. The SIM card verifies that it’s talking to the operator by recomputing <i>V</i><sub>1</sub> with <b>PRF</b>1, <i>K</i>, and <i>R</i>, and then checking to make sure that the calculated <i>V</i><sub>1</sub> matches the <i>V</i><sub>1</sub> sent by the operator. The SIM card then computes a verification value, <i>V</i><sub>2</sub>, with a new function, <b>PRF</b>2, with <i>K</i> and <i>R</i> as input, and sends <i>V</i><sub>2</sub> to the operator. The operator verifies that the SIM card knows <i>K</i> by computing <i>V</i><sub>2</sub> and checking that the computed value matches the received <i>V</i><sub>2</sub>.</p>&#13;
<p class="TX">In the protocol as I described it, there’s a way to fool the SIM card with a replay attack. Essentially, if an attacker captures a pair (<i>R</i>, <i>V</i><sub>1</sub>), they may send it to the SIM card and trick the SIM into believing that the pair came from a legitimate operator that knows <i>K</i>. To prevent this attack, the protocol includes additional checks to ensure the same <i>R</i> isn’t reused.</p>&#13;
<p class="TX">Problems arise if <i>K</i> is compromised. For example, an attacker who compromises <i>K</i> can perform a man-in-the-middle attack and listen to all cleartext communication. Such an attacker could send messages between the two parties while pretending to be both the legitimate SIM card operator and the SIM card. Even if <i>K</i> isn’t compromised at the time of a given <span role="doc-pagebreak" epub:type="pagebreak" id="pg_221" aria-label="221"/>communication, an attacker can record communications and any messages exchanged during the key agreement and later decrypt those communications by using the captured <i>R</i> values if they find <i>K</i>. An attacker could then determine the past session keys and use them to decrypt the recorded traffic—in that case, the protocol doesn’t offer <i>forward secrecy</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-138"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Attack Models for Key Agreement Protocols</samp></h4>&#13;
<p class="TNI">There is no single definition of security for key agreement protocols, and a key protocol is never completely secure without context and without considering the attack model and the security goals. You can, for example, argue that the previous 4G/5G protocol is secure because a passive attacker won’t find the session keys, but it’s also insecure because once the key <i>K</i> leaks, this compromises all previous and future communications.</p>&#13;
<p class="TX">There are different notions of security in key agreement protocols as well as three main attack models that depend on the information the protocol leaks. From weakest to strongest, these are the <i>network attacker</i>, the <i>data leak</i>, and the <i>breach</i>:</p>&#13;
<p class="RunInPara"><b>The network attacker </b>This attacker observes the messages exchanged between the two legitimate parties running a key agreement protocol and can record, modify, drop, or inject messages. To protect against such an attacker, a key agreement protocol must not leak any information on the established shared secret.</p>&#13;
<p class="RunInPara"><b>The data leak </b>In this model, the attacker acquires the session key and all <i>temporary</i> secrets (such as <i>SK</i> in the telecom protocol example) from one or more executions of the protocol, but not the long-term secrets (like <i>K</i> in that same protocol).</p>&#13;
<p class="RunInPara"><b>The breach (or corruption) </b>In this model, the attacker learns the long-term key of one or more of the parties. Once a breach occurs, security is no longer attainable because the attacker can impersonate one or both parties in subsequent sessions of the protocol, as it’s the only piece of information that identifies a party (at least in theory, since in practice mechanisms such as IP whitelisting can reduce the risk of impersonation). Nonetheless, the attacker shouldn’t be able to recover secrets from sessions executed before gathering the key.</p>&#13;
<p class="TX">Now that we’ve looked at the attack models and seen what an attacker can do, let’s explore the security goals—that is, the security guarantees that the protocol should offer. You can design a key agreement protocol to satisfy several security goals. The four most relevant ones are described here, from simplest to most sophisticated:</p>&#13;
<p class="RunInPara"><b>Authentication </b>The protocol should allow for <i>mutual authentication</i>, wherein each party can authenticate the other party. AKA occurs when a protocol authenticates both parties.</p>&#13;
<p class="RunInPara"><b>Key control </b>Neither party should be able to choose the final shared secret or coerce it to be in a specific subset. The previously discussed <span role="doc-pagebreak" epub:type="pagebreak" id="pg_222" aria-label="222"/>4G/5G key agreement protocol lacks this property because the operator chooses the value for <i>R</i> that entirely determines the final shared key.</p>&#13;
<p class="RunInPara"><b>Forward secrecy  </b>Even if all long-term secrets are exposed, an attacker should be unable to compute shared secrets from previous executions of the protocol, even if they record all previous executions or can inject or modify messages from previous executions. A <i>forward-secret</i>, or <i>forward-secure</i>, protocol guarantees that even if you have to deliver your devices and their secrets to some authority, they won’t be able to decrypt your prior encrypted communications. (The 4G/5G key agreement protocol doesn’t provide forward secrecy.)</p>&#13;
<p class="RunInPara"><b>Resistance to key-compromise impersonation (KCI) </b>KCI occurs when an attacker compromises a party’s long-term key and can use it to impersonate another party. For example, the 4G/5G key agreement protocol allows trivial key-compromise impersonation because both parties share the same key <i>K</i>. A key agreement protocol ideally prevents this kind of attack.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h4 class="H2" id="sec9"><span id="h2-139"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performance</samp></h4>&#13;
<p class="TNI">To be useful, a key agreement protocol should be efficient as well as secure. You should take several factors into account when considering a key agreement protocol’s efficiency, including the number of messages exchanged, their length, the computational effort to implement the protocol, and whether precomputations can be made to save time. A protocol is generally more efficient when exchanging fewer, shorter messages, and it’s best if interactivity is kept minimal so that neither party has to wait to receive a message before sending the next one. You can typically measure a protocol’s efficiency through its duration in terms of <i>round trips</i>, or the time it takes to send a message and receive a response.</p>&#13;
<p class="TX">Round-trip time is usually the main cause of latency in protocols, but the amount of computation to be carried out by the parties also counts; the fewer required computations, and the more precomputations that can be done in advance, the better. For example, the 4G/5G key agreement protocol exchanges two messages of a few hundred bits each, which must be sent in a certain order. You can use precomputation with this protocol to save time since the operator can pick many values of <i>R</i> in advance; precompute the matching values of <i>SK</i>, <i>V</i><sub>1</sub>, and <i>V</i><sub>2</sub>; and store them all in a database. In this case, precomputation has the advantage of reducing the exposure of the long-term key.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_223" aria-label="223"/>&#13;
<h3 class="H1" id="sec10"><span id="h1-79"/><samp class="SANS_Futura_Std_Bold_B_11">Diffie–Hellman Protocols</samp></h3>&#13;
<p class="TNI">The Diffie–Hellman function is the core of most of the deployed public-key agreement protocols—for example, in TLS and SSH. However, there is no single Diffie–Hellman protocol but rather a variety of ways to use the DH function to establish a shared secret. We’ll review three protocols in the sections that follow. In each discussion, I’ll stick to the usual crypto placeholder names and call the two parties Alice and Bob, and the attacker Eve. I’ll write <i>g</i> as the generator of the group used for arithmetic operations, a value fixed and known in advance to Alice, Bob, and Eve.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-140"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anonymous Diffie–Hellman</samp></h4>&#13;
<p class="TNI"><i>Anonymous Diffie–Hellman</i> is the simplest Diffie–Hellman protocol. It’s anonymous because it’s not authenticated; the participants have no cryptographic identity that either party can verify, and neither party holds a long-term key. Alice can’t prove to Bob that she’s Alice, and vice versa.</p>&#13;
<p class="TX">In anonymous Diffie–Hellman, each party picks a random value (<i>a</i> for Alice and <i>b</i> for Bob) to use as a private key and sends the corresponding public key to the other peer. <a href="chapter11.xhtml#fig11-2">Figure 11-2</a> shows the process in more detail.</p>&#13;
<figure class="IMG"><img id="fig11-2" class="img1" src="../images/fig11-2.jpg" alt="" width="1310" height="441"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: The anonymous Diffie–Hellman protocol</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Alice uses her exponent <i>a</i> and the group basis <i>g</i> to compute <i>A</i> = <i>g</i><i><sup>a</sup></i>, which she sends to Bob. Bob receives <i>A</i> and computes <i>A</i><i><sup>b</sup></i>, which is equal to (<i>g</i><i><sup>a</sup></i>)<i><sup>b</sup></i>. Bob now obtains the value <i>g</i><i><sup>ab</sup></i> and computes <i>B</i> from his random exponent <i>b</i> and the value <i>g</i>. He then sends <i>B</i> to Alice, which she uses to compute <i>g</i><i><sup>ab</sup></i>. Alice and Bob end up with the same value, <i>g</i><i><sup>ab</sup></i>, after performing similar operations that involve raising both <i>g</i> and the value received to their private exponent’s power. A simple protocol, secure against only the laziest of attackers.</p>&#13;
<p class="TX">Attackers can take down anonymous DH with a man-in-the-middle attack. A network attacker simply needs to intercept messages and pretend to be Bob (to Alice) and pretend to be Alice (to Bob), as <a href="chapter11.xhtml#fig11-3">Figure 11-3</a> depicts.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_224" aria-label="224"/>&#13;
<figure class="IMG"><img id="fig11-3" class="img1" src="../images/fig11-3.jpg" alt="" width="1314" height="888"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: A man-in-the-middle attack on the anonymous Diffie–Hellman protocol</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As in the previous exchange, Alice and Bob pick random exponents, <i>a</i> and <i>b</i>. Alice now computes and sends <i>A</i>, but Eve intercepts and drops the message. Eve then picks a random exponent, <i>c</i>, and computes <i>C</i> = <i>g</i><i><sup>c</sup></i> to send to Bob. Because this protocol has no authentication, Bob believes he is receiving <i>C</i> from Alice and goes on to compute <i>g</i><i><sup>bc</sup></i>. Bob then computes <i>B</i> and sends that value to Alice, but Eve intercepts and drops the message again. Eve now computes <i>g</i><i><sup>bc</sup></i>; picks a new exponent, <i>d</i>; computes <i>g</i><i><sup>ad</sup></i>; computes <i>D</i> from <i>g</i><i><sup>d</sup></i>; and sends <i>D</i> to Alice. Alice then computes <i>g</i><i><sup>ad</sup></i> as well.</p>&#13;
<p class="TX">As a result of this attack, the attacker Eve shares a secret with Alice (<i>g</i><i><sup>ad</sup></i>) and another secret with Bob (<i>g</i><i><sup>bc</sup></i>), while Alice and Bob believe that they’re sharing a single secret with each other. After completing the protocol execution, Alice derives symmetric keys from <i>g</i><i><sup>ad</sup></i> to encrypt data sent to Bob, but Eve intercepts the encrypted messages, decrypts them, and reencrypts them to Bob using another set of keys derived from <i>g</i><i><sup>bc</sup></i>—after potentially modifying the cleartext. All of this happens with Alice and Bob unaware; they’re doomed.</p>&#13;
<p class="TX">To foil this attack, you need a way to authenticate the parties so Alice can prove she’s the real Alice and Bob can prove he’s the real Bob. Fortunately, there’s a way to do so.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H2" id="sec12"><span id="h2-141"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authenticated Diffie–Hellman</samp></h4>&#13;
<p class="TNI"><i>Authenticated Diffie–Hellman</i> addresses the man-in-the-middle attacks that can affect anonymous DH. Authenticated DH equips the two parties with both a private key and a public key, thereby allowing Alice and Bob to sign their messages to stop Eve from sending messages on their behalf. Here, the signatures aren’t computed with a DH function but with a public-key signature scheme such as RSA-PSS. As a result, to successfully send messages on behalf <span role="doc-pagebreak" epub:type="pagebreak" id="pg_225" aria-label="225"/>of Alice, an attacker needs to forge a valid signature, which is impossible with a secure signature scheme. <a href="chapter11.xhtml#fig11-4">Figure 11-4</a> shows how authenticated DH works.</p>&#13;
<figure class="IMG"><img id="fig11-4" class="img1" src="../images/fig11-4.jpg" alt="" width="1372" height="542"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: The authenticated Diffie–Hellman protocol</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The label <b>Alice</b> (<i>priv</i><span class="ePub-I-SUB">A</span>, <i>pub</i><span class="ePub-I-SUB">B</span>) on the first line means that Alice holds her own private key, <i>priv</i><span class="ePub-I-SUB">A</span>, as well as Bob’s public key, <i>pub</i><span class="ePub-I-SUB">B</span>. This <i>priv</i>/<i>pub</i> key pair is called a <i>long-term key</i> because it’s fixed in advance and remains constant through consecutive runs of the protocol. Alice can use her key pair <i>priv</i><span class="ePub-I-SUB">A</span>/<i>pub</i><span class="ePub-I-SUB">A</span> with parties other than Bob, as long as they know <i>pub</i><span class="ePub-I-SUB">A</span> (<i>how</i> they know it is another question and one of the hardest operational problems in cryptography). These long-term private keys should be kept secret, while the public keys are considered to be known to an attacker.</p>&#13;
<p class="TX">Alice and Bob begin by picking random exponents, <i>a</i> and <i>b</i>, as in anonymous DH. Alice then calculates <i>A</i> and a signature <i>sig</i><span class="ePub-I-SUB">A</span> based on a combination of her signing function <b>sign</b>, her private key <i>priv</i><span class="ePub-I-SUB">A</span>, and <i>A</i>. Now Alice sends <i>A</i> and <i>sig</i><span class="ePub-I-SUB">A</span> to Bob, who verifies <i>sig</i><span class="ePub-I-SUB">A</span> with her public key <i>pub</i><span class="ePub-I-SUB">A</span>. If the signature is invalid, Bob knows that the message didn’t come from Alice, and he discards <i>A</i>.</p>&#13;
<p class="TX">If the signature is correct, Bob computes <i>g</i><i><sup>ab</sup></i> from <i>A</i> and his random exponent <i>b</i>. He then computes <i>B</i> and his own signature from a combination of the <b>sign</b> function, his private key <i>priv</i><span class="ePub-I-SUB">B</span>, and <i>B</i>. He sends <i>B</i> and <i>sig</i><span class="ePub-I-SUB">B</span> to Alice, who attempts to verify <i>sig</i><span class="ePub-I-SUB">B</span> with Bob’s public key <i>pub</i><span class="ePub-I-SUB">B</span>. Alice computes <i>g</i><i><sup>ab</sup></i> only if Bob’s signature is successfully verified.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h5 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Against Network Attackers</samp></h5>&#13;
<p class="TNI">Authenticated DH is secure against network attackers because they can’t learn any bit of information on the shared secret <i>g</i><i><sup>ab</sup></i> since they ignore the DH exponents. Authenticated DH also provides forward secrecy: even if an attacker corrupts any of the parties at some point, as in the <i>breach</i> attack model discussed earlier, they’d learn the private signing keys but not any of the ephemeral DH exponents; hence, they’d be unable to learn the value of any previously shared secrets.</p>&#13;
<p class="TX">The authenticated variant of DH offers only partial protection against <i>key control</i>. Alice can’t craft special values of <i>a</i> to restrict the choice of shared <span role="doc-pagebreak" epub:type="pagebreak" id="pg_226" aria-label="226"/>secret <i>g</i><i><sup>ab</sup></i>, because she doesn’t yet know <i>g</i><i><sup>b</sup></i>, which influences the result as much as <i>a</i>. (One exception would be if Alice chose <i>a</i> = 0, in which case you’d have <i>g</i><i><sup>ab</sup></i> = 1 for any <i>b</i>. The protocol should thus reject 0, though implementations may not do so in practice.) However, Bob can try several values of <i>b</i> until he finds one “that suits him”; for example, for which <i>g</i><i><sup>ab</sup></i> has certain properties, such as its first 16 bits being 1.</p>&#13;
<p class="TX">You can eliminate Bob’s power over the value of the secret by sending <b>Hash</b>(<i>g</i><i><sup>b</sup></i>) from Bob to Alice as the first message, before Alice sends her <i>g</i><i><sup>a</sup></i>. I’ll leave you to analyze this modification and understand why it works (the newly sent message is a <i>commitment</i> of Bob’s public key).</p>&#13;
<p class="TX">Authenticated DH has other limitations. For one, Eve can pretend to be Alice by recording previous values of <i>A</i> and <i>sig</i><span class="ePub-I-SUB">A</span> and replaying them to Bob. Bob mistakenly believes he’s sharing a secret with Alice, even though Eve isn’t able to learn that secret because she doesn’t know Alice’s secret <i>a</i>. She thus wouldn’t be able to compute <i>B</i><i><sup>a</sup></i> from the <i>B</i> sent by Bob.</p>&#13;
<p class="TX">You can eliminate this risk by adding a <i>key confirmation</i> procedure, wherein Alice and Bob prove to each other that they own the shared secret. For example, Alice and Bob may perform key confirmation by sending <b>Hash</b>(<i>pub</i><span class="ePub-I-SUB">A</span> || <i>pub</i><span class="ePub-I-SUB">B</span> || <i>g</i><i><sup>ab</sup></i>) and <b>Hash</b>(<i>pub</i><span class="ePub-I-SUB">B</span> || <i>pub</i><span class="ePub-I-SUB">A</span> || <i>g</i><i><sup>ab</sup></i>), respectively, for some hash function <b>Hash</b>. Both parties can verify the correctness of these hash values by recomputing its result. The different order of public keys <i>pub</i><span class="ePub-I-SUB">A</span> || <i>pub</i><span class="ePub-I-SUB">B</span> and <i>pub</i><span class="ePub-I-SUB">B</span> || <i>pub</i><span class="ePub-I-SUB">A</span> ensures that Alice and Bob will send different values and that an attacker can’t pretend to be Alice by copying Bob’s hash value.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h5 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Against Data Leaks</samp></h5>&#13;
<p class="TNI">Authenticated DH’s vulnerability to data leak attackers is of greater concern. In this type of attack, the attacker learns the value of ephemeral, short-term secrets (namely, the exponents <i>a</i> and <i>b</i>) and uses that information to impersonate one of the communicating parties. If Eve learns the value of an exponent <i>a</i> along with the value of <i>sig</i><span class="ePub-I-SUB">A</span> sent to Bob, she could initiate a new execution of the protocol and impersonate Alice, as <a href="chapter11.xhtml#fig11-5">Figure 11-5</a> illustrates.</p>&#13;
<figure class="IMG"><img id="fig11-5" class="img1" src="../images/fig11-5.jpg" alt="" width="1385" height="554"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: An impersonation attack on the authenticated Diffie–Hellman protocol</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_227" aria-label="227"/>In this attack scenario, Eve learns the value of an <i>a</i> and replays the corresponding <i>A</i> and its signature <i>sig</i><span class="ePub-I-SUB">A</span>, pretending to be Alice. Bob verifies the signature and computes <i>g</i><i><sup>ab</sup></i> from <i>A</i> and sends <i>B</i> and <i>sig</i><span class="ePub-I-SUB">B</span>, which Eve then uses to compute <i>g</i><i><sup>ab</sup></i>, using the stolen <i>a</i>. This results in the two having a shared secret. Bob now believes he’s talking to Alice.</p>&#13;
<p class="TX">You can protect authenticated DH against the leak of ephemeral secrets by integrating the long-term keys into the shared secret computation so that you can’t determine the shared secret without knowing the long-term secret.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-142"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Menezes–Qu–Vanstone</samp></h4>&#13;
<p class="TNI">The <i>Menezes–Qu–Vanstone (MQV)</i> protocol is a milestone in the history of DH-based protocols. Designed in 1998, MQV was approved to protect most critical assets when the NSA included it in its Suite B, a portfolio of algorithms designed to protect classified information. (NSA eventually dropped MQV, allegedly because it wasn’t used. I’ll discuss the reasons why shortly.)</p>&#13;
<p class="TX">MQV is Diffie–Hellman on steroids. It’s more secure than authenticated DH, and it improves on authenticated DH’s performance properties. In particular, MQV allows users to send only two messages, independently of each other, in arbitrary order. Users can also send shorter messages than with authenticated DH, and they don’t need to send explicit signature or verification messages. In other words, you don’t need to use a signature scheme in addition to the Diffie–Hellman function.</p>&#13;
<p class="TX">As with authenticated DH, in MQV Alice and Bob each hold a long-term private key as well as the long-term public key of the other party. The difference is that the MQV keys aren’t signing keys: they consist of a private exponent, <i>x</i>, and a public value, <i>g</i><i><sup>x</sup></i>. <a href="chapter11.xhtml#fig11-6">Figure 11-6</a> shows the operation of the MQV protocol.</p>&#13;
<figure class="IMG"><img id="fig11-6" class="img1" src="../images/fig11-6.jpg" alt="" width="1210" height="441"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: The MQV protocol</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <i>x</i> and <i>y</i> are Alice and Bob’s respective long-term private keys, and <i>X</i> and <i>Y</i> are their public keys. Bob and Alice start with their own private keys and each other’s public keys, which are <i>g</i> to the power of a private key. Each chooses a random exponent, and then Alice calculates <i>A</i> and sends it to Bob, who then calculates <i>B</i> and sends it to Alice. Once Alice gets Bob’s ephemeral public key <i>B</i>, she combines it with her long-term private key <i>x</i>, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_228" aria-label="228"/>her ephemeral private key <i>a</i>, and Bob’s long-term public key <i>Y</i> by calculating the result of (<i>B</i> × <i>Y</i><i><sup>B</sup></i>)<i><sup>a</sup></i> <sup>+</sup> <i><sup>xA</sup></i>, as in <a href="chapter11.xhtml#fig11-6">Figure 11-6</a>. Developing this expression, you obtain the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg228-1.jpg" alt="" width="1385" height="87"/></figure>&#13;
<p class="TX">Meanwhile, Bob calculates the result of (<i>A</i> × <i>X</i><i><sup>A</sup></i>)<i><sup>b</sup></i> <sup>+</sup> <i><sup>yB</sup></i>, and you can verify that it’s equal to the value Alice calculated:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg228-2.jpg" alt="" width="1385" height="86"/></figure>&#13;
<p class="TX">You get the same value for both Alice and Bob, <i>g</i><sup>(</sup><i><sup>b</sup></i> <sup>+</sup> <i><sup>yB</sup></i><sup>)(</sup><i><sup>a</sup></i> <sup>+</sup> <i><sup>xA</sup></i><sup>)</sup>, which tells you that Alice and Bob share the same secret.</p>&#13;
<p class="TX">Unlike authenticated DH, you can’t break MQV by a mere leak of the ephemeral secrets. Knowledge of <i>a</i> or <i>b</i> won’t let an attacker determine the final shared secret because they need the long-term private keys to compute it.</p>&#13;
<p class="TX">What happens in the strongest attack model, the breach model, when a long-term key is compromised? If Eve compromises Alice’s long-term private key <i>x</i>, the previously established shared secrets are safe because their computation also involved Alice’s ephemeral private keys.</p>&#13;
<p class="TX">However, MQV doesn’t provide <i>perfect</i> forward secrecy because of the following attack. Say, for example, that Eve intercepts Alice’s <i>A</i> message and replaces it with her <i>A</i> = <i>g</i><i><sup>a</sup></i> for some <i>a</i> that Eve chose. In the meantime, Bob sends <i>B</i> to Alice (and Eve records <i>B</i>’s value) and computes the shared key. If Eve later compromises Alice’s long-term private key <i>x</i>, she can determine the key that Bob computed during this session. This breaks forward secrecy since Eve has now recovered the shared secret of a previous execution of the protocol. In practice, however, you can eliminate the risk with a key-confirmation step in which Alice and Bob would realize that they don’t share the same key, and they’d abort the protocol before deriving any session keys.</p>&#13;
<p class="TX">Despite its elegance and security, MQV is rarely used in practice for a couple of reasons. It used to be encumbered by patents, which hampered its widespread adoption. It’s also harder than it looks to get MQV right. In fact, when weighed against its increased complexity, MQV’s security benefits are often perceived as low in comparison to the simpler authenticated DH.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H1" id="sec16"><span id="h1-80"/><samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp></h3>&#13;
<p class="TNI">Diffie–Hellman protocols can fail spectacularly in a variety of ways. The following sections highlight some cases often observed in practice.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H2" id="sec17"><span id="h2-143"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Not Hashing the Shared Secret</samp></h4>&#13;
<p class="TNI">I’ve alluded to the fact that the shared secret that concludes a DH session exchange (<i>g</i><i><sup>ab</sup></i> in our examples) is taken as input to derive session keys but is <span role="doc-pagebreak" epub:type="pagebreak" id="pg_229" aria-label="229"/>not a key itself. And it shouldn’t be. A symmetric key should look random, and each bit should either be 0 or 1 with the same probability. But <i>g</i><i><sup>ab</sup></i> is not a random string; it’s a random element within some mathematical group whose bits may be biased toward 0 or 1. A random group element is different from a random string of bits.</p>&#13;
<p class="TX">Imagine, for example, that you’re working within the multiplicative group <b>Z</b><sub>13</sub><sup>*</sup> = {1, 2, 3, . . . , 12} using <i>g</i> = 2 as a generator of the group, meaning that <i>g</i><i><sup>i</sup></i> spans all values of <b>Z</b><sub>13</sub><sup>*</sup> for <i>i</i> in 1, 2, . . . 12: <i>g</i><sup>1</sup> = 2, <i>g</i><sup>2</sup> = 4, <i>g</i><sup>3</sup> = 8, <i>g</i><sup>4</sup> = 3, and so on. If <i>g</i>’s exponent is random, you’ll get a random element of <b>Z</b><sub>13</sub><sup>*</sup>, but the encoding of a <b>Z</b><sub>13</sub><sup>*</sup> element as a 4-bit string won’t be uniformly random: not all bits will have the same probability of being a 0 or a 1. In <b>Z</b><sub>13</sub><sup>*</sup>, seven values have 0 as their most significant bit (the numbers from 1 to 7 in the group), but only five have 1 as their most significant bit (from 8 to 12). That is, this bit is 0 with probability 7/12 ≈ 0.58, whereas a random bit should ideally be 0 with probability 0.5. Moreover, the 4-bit sequences 1101, 1110, and 1111 will never appear.</p>&#13;
<p class="TX">To avoid such biases in the session keys derived from a DH shared secret, use a cryptographic hash function such as BLAKE3 or SHA-3—or, better yet, a key derivation function (KDF). An example of KDF construction is HKDF, or HMAC-based KDF (as specified in RFC 5869), but today BLAKE2 and SHA-3 feature dedicated modes to behave as KDFs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H2" id="sec18"><span id="h2-144"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anonymous Diffie–Hellman from TLS 1.0</samp></h4>&#13;
<p class="TNI">The TLS protocol is the security behind HTTPS secure websites as well as many other protocols, such as email transfer with the Simple Mail Transfer Protocol (SMTP). TLS takes several parameters, including the type of Diffie–Hellman protocol it will use. For backward compatibility reasons, TLS supports anonymous DH since version 1.0 up to version 1.2 (that is, without any server authentication), though not in version 1.3. As DH is secure against only passive attackers, it can give a false impression of security.</p>&#13;
<p class="TX">The original documentation of TLS describes the risks of this protocol (<i><a href="https://www.rfc-editor.org/rfc/rfc2246">https://<wbr/>www<wbr/>.rfc<wbr/>-editor<wbr/>.org<wbr/>/rfc<wbr/>/rfc2246</a></i>):</p>&#13;
<blockquote>&#13;
<p class="ExtractPara">Completely anonymous connections only provide protection against passive eavesdropping. Unless an independent tamper-proof channel is used to verify that the finished messages were not replaced by an attacker, server authentication is required in environments where active man-in-the-middle attacks are a concern.</p>&#13;
</blockquote>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2" id="sec19"><span id="h2-145"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsafe Group Parameters</samp></h4>&#13;
<p class="TNI">In January 2016, the maintainers of the OpenSSL toolkit fixed a high-severity vulnerability (CVE-2016-0701) that allowed an attacker to exploit unsafe Diffie–Hellman parameters. The root cause of the vulnerability was that OpenSSL allowed users to work with unsafe DH group parameters <span role="doc-pagebreak" epub:type="pagebreak" id="pg_230" aria-label="230"/>(namely, an unsafe prime <i>p</i>) instead of throwing an error and aborting the protocol altogether before performing any arithmetic operation.</p>&#13;
<p class="TX">Essentially, OpenSSL accepted a prime number <i>p</i> whose multiplicative group <b>Z</b><span class="ePub-I-SUB">p</span><sup>*</sup> (where all DH operations happen) contained small subgroups. As you learned at the beginning of this chapter, the existence of small subgroups within a larger group in a cryptographic protocol is bad because it confines shared secrets to a much smaller set of possible values than if it were to use the whole group <b>Z</b><span class="ePub-I-SUB">p</span><sup>*</sup>. Worse still, an attacker can craft a DH exponent <i>x</i> that, when combined with the victim’s public key <i>g</i><i><sup>y</sup></i>, reveals information on the private key <i>y</i> and eventually its entirety.</p>&#13;
<p class="TX">Although the actual vulnerability is from 2016, the principle the attack used dates back to the 1997 paper “A Key Recovery Attack on Discrete Log-based Schemes Using a Prime Order Subgroup” by Chae Hoon Lim and Pil Joong Lee. The fix for the vulnerability is simple: when accepting a prime <i>p</i> as group modulus, the protocol must check that <i>p</i> is a safe prime by verifying that (<i>p</i> – 1) / 2 is prime as well to ensure that the group <b>Z</b><span class="ePub-I-SUB">p</span><sup>*</sup> won’t have small subgroups and that an attack on this vulnerability will fail.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H1" id="sec20"><span id="h1-81"/><samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp></h3>&#13;
<p class="TNI">You can dig deeper into the DH key agreement protocols by reading a number of standards and official publications, including ANSI X9.42, RFC 2631 and RFC 5114, IEEE 1363, and NIST SP 800-56A. These serve as references to ensure interoperability and to provide recommendations for group parameters.</p>&#13;
<p class="TX">To learn more about advanced DH protocols (such as MQV and its cousins HMQV and OAKE, among others) and their security notions (including unknown-key share attacks and group representation attacks), read the 2005 article “HMQV: A High-Performance Secure Diffie–Hellman Protocol” by Hugo Krawczyk (<i><a href="https://eprint.iacr.org/2005/176">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2005<wbr/>/176</a></i>) and the 2011 article “A New Family of Implicitly Authenticated Diffie–Hellman Protocols” by Andrew C. Yao and Yunlei Zhao (<i><a href="https://eprint.iacr.org/2011/035">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2011<wbr/>/035</a></i>). These articles express Diffie–Hellman operations differently than in this chapter. For example, they represent the shared secret as <i>xP</i> instead of <i>g</i><i><sup>x</sup></i>. Generally, you’ll find multiplication replaced with addition and exponentiation replaced with multiplication, because those protocols are usually not defined over groups of integers but over elliptic curves, as you’ll learn in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>