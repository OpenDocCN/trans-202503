- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 13 ORGANIZING A WEB APPLICATION
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13 组织Web应用程序
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, we’ll progressively explore a structured approach to dividing
    a web application’s responsibilities among multiple scripts while also developing
    a project folder architecture that gives every script a clearly defined home.
    You’ll be introduced to the *front-controller* design pattern, which requires
    the sending of every request to the web server through a single script that decides
    how to respond, then delegates the responsibility for generating that response
    to other server scripts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将逐步探索一种结构化的方法，将Web应用程序的职责划分到多个脚本中，同时开发一个项目文件夹架构，为每个脚本定义一个明确的家园。你将会接触到*前端控制器*设计模式，它要求通过一个单一的脚本将每个请求发送到Web服务器，该脚本决定如何响应，然后将生成响应的责任委派给其他服务器脚本。
- en: '[Chapters 11](chapter11.xhtml) and [12](chapter12.xhtml) introduced differing
    approaches to designing a web application. One is to write multiple scripts for
    each web form that separately handle displaying, validating, and confirming the
    form; another is to create a single postback script that does all those tasks.
    Both approaches have advantages and disadvantages, but neither is scalable for
    web applications that may grow in size and complexity over time. You wouldn’t
    want to have tens, hundreds, or even thousands of PHP scripts sitting in your
    application’s *public* folder, as might happen with the first approach, for reasons
    of maintenance as well as security (malicious users may attempt to execute public
    scripts out of sequence to bypass validation checks, for example). But neither
    would you want an individual script to become overly complex, as might happen
    with the second approach.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第11章](chapter11.xhtml)和[第12章](chapter12.xhtml)介绍了设计Web应用程序的不同方法。一种方法是为每个Web表单编写多个脚本，分别处理显示、验证和确认表单；另一种方法是创建一个单一的回传脚本来完成所有这些任务。这两种方法各有优缺点，但对于可能随着时间推移而在规模和复杂度上增长的Web应用程序来说，任何一种方法都无法扩展。你肯定不希望在应用程序的*public*文件夹中存放几十、几百甚至上千个PHP脚本，这种情况可能出现在第一种方法中，原因包括维护和安全性（例如，恶意用户可能尝试按顺序执行公共脚本，以绕过验证检查）。但是，你也不希望单个脚本变得过于复杂，这可能是第二种方法的弊端。'
- en: The architecture we’ll discuss in this chapter addresses these problems by focusing
    all decision-making logic on the single front-controller script while using other
    scripts or functions to carry out all other tasks. The front controller acts much
    like the receptionist in a large office building, whom every guest must visit;
    it identifies and interprets each request (who the visitor is and what they’re
    asking for), and directs it to the appropriate server script (a room in the building)
    that satisfies the request. With this architecture, no one script is overly complicated,
    and while an application can grow to include many scripts, they’re organized in
    such a way that the application is easy to maintain and extend.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将讨论的架构通过将所有决策逻辑集中在单一的前端控制器脚本上来解决这些问题，同时使用其他脚本或函数来执行所有其他任务。前端控制器就像一个大型办公楼的接待员，所有客人都必须拜访它；它识别并解释每个请求（访客是谁，他们要求什么），然后将请求引导到适当的服务器脚本（办公楼中的一个房间）来满足请求。使用这种架构，任何一个脚本都不会变得过于复杂，而随着应用程序的增长，可能会包含许多脚本，但它们的组织方式使得应用程序易于维护和扩展。
- en: Front Controllers and the MVC Architecture
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端控制器与MVC架构
- en: '[Chapter 10](chapter10.xhtml) introduced the model-view-controller (MVC) architecture,
    a design pattern that divides a web application into three main components. The
    *model* represents the data underlying the application, typically stored in a
    database; the *view* uses templating to determine how the data is displayed to
    the user; and the *controller* makes decisions about what data to display when.
    The front-controller scripts we’ll explore in this chapter are the core piece
    of the controller portion of the MVC architecture, as they take in every HTTP
    request to the application and determine how to respond. [Figure 13-1](#fig13-1)
    illustrates how a front controller fits into the MVC pattern.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](chapter10.xhtml)介绍了模型-视图-控制器（MVC）架构，这是一种将Web应用程序分为三个主要组件的设计模式。*模型*代表应用程序背后的数据，通常存储在数据库中；*视图*使用模板来决定如何将数据显示给用户；*控制器*则决定何时显示哪些数据。本章中我们将探讨的前端控制器脚本是MVC架构中控制器部分的核心，因为它们处理所有的HTTP请求，并决定如何响应。[图13-1](#fig13-1)展示了前端控制器如何适应MVC模式。'
- en: '![](../images/figure13-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure13-1.jpg)'
- en: 'Figure 13-1: The MVC architecture, featuring a front controller'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-1：MVC 架构，具有前端控制器
- en: 'The *front controller* ❶ handles every HTTP request received from web clients,
    deciding which *action controller* should be invoked. These action controllers
    are more specialized scripts or functions, also part of the controller component
    of the MVC architecture, that carry out particular tasks for the application,
    such as checking stored security credentials or manipulating data like shopping-cart
    contents. An action controller may need to read the contents of a data store,
    such as a database system (more about this in [Part VI](part6.xhtml)). The action
    controller then invokes the view (templating) component ❷ to create the contents
    of the response to be returned to the user, passing along the data from the model
    if appropriate. The action controller then receives the output from the view component
    ❸ and adds any appropriate headers or response codes. Finally, the response is
    sent back to the web client ❹.  ### Separating Display and Logic Files'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*前端控制器* ❶ 处理从 Web 客户端接收到的每个 HTTP 请求，决定应该调用哪个 *动作控制器*。这些动作控制器是更专业化的脚本或函数，也是
    MVC 架构中的控制器组件的一部分，执行应用程序的特定任务，例如检查存储的安全凭证或操作数据，如购物车内容。动作控制器可能需要读取数据存储的内容，如数据库系统（更多内容见
    [第六部分](part6.xhtml)）。然后，动作控制器调用视图（模板）组件 ❷ 来创建返回给用户的响应内容，必要时传递来自模型的数据。接着，动作控制器接收来自视图组件的输出
    ❸ 并添加任何适当的头信息或响应代码。最后，响应被发送回 Web 客户端 ❹。  ### 分离显示和逻辑文件'
- en: 'We’ll revisit the simple *Hello <name>* form developed in the preceding two
    chapters to start the process of separating the display code from the decision-making
    logic in an application. See “A Simple Example” on [page 199](chapter11.xhtml#pg_199)
    to review how we initially created and processed that form with separate scripts,
    and “Simple Validation Logic” on [page 231](chapter12.xhtml#pg_231) for how we
    validated and displayed the form with a single postback script. In this version,
    the application will have three possible responses it may return:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新访问前两章中开发的简单 *Hello <name>* 表单，开始将应用程序中的显示代码与决策逻辑分离的过程。请参见 “[简单示例](chapter11.xhtml#pg_199)”
    以回顾我们如何使用独立的脚本创建和处理该表单，以及 “[简单验证逻辑](chapter12.xhtml#pg_231)” 以了解我们如何通过单个回传脚本验证和显示表单。在此版本中，应用程序将有三种可能的响应。
- en: The blank form if the HTTP request used the GET method
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 HTTP 请求使用 GET 方法，则显示空表单
- en: A *Hello <name>* confirmation message if a valid name was received
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果收到有效的名称，则显示 *Hello <name>* 确认信息
- en: An error message if an invalid name (less than three characters long) was received
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果接收到无效的名称（少于三个字符），则显示错误信息
- en: The decision-making logic and possible outputs are modeled in the flowchart
    in [Figure 13-2](#fig13-2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 决策逻辑和可能的输出在 [图 13-2](#fig13-2) 中的流程图中进行了建模。
- en: '![](../images/figure13-2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure13-2.jpg)'
- en: 'Figure 13-2: Modeling the logic and outputs of the Hello <name> application'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-2：建模 Hello <name> 应用程序的逻辑和输出
- en: 'We’ll create a separate file for each of the three possible outputs. Meanwhile,
    every request will be routed to the front controller in the *index.php* file.
    The logic in the front controller will decide what to do (that is, which of the
    other three files to draw upon to generate the output to be returned to the user).
    The file structure for the project will therefore look as follows when we’ve finished:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为三种可能的输出创建一个单独的文件。同时，所有请求将被路由到*index.php*文件中的前端控制器。前端控制器中的逻辑将决定该做什么（即，从其他三个文件中选择哪个来生成返回给用户的输出）。因此，完成后项目的文件结构将如下所示：
- en: '![](../images/pg243.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg243.jpg)'
- en: Notice that all the files are located in the project’s *public* folder.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有文件都位于项目的 *public* 文件夹中。
- en: Creating the Front Controller
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建前端控制器
- en: We’ll first write the *index.php* front-controller script. All requests for
    this project will be for *index.php*, some with the GET method, some with the
    POST method, some containing valid submitted data, and some containing invalid
    submitted data. Depending on the type of HTTP method (GET or POST) and whether
    the submitted data is valid, this script decides which of the three display pages
    to return as the response. [Listing 13-1](#lis13-1) shows the code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写 *index.php* 前端控制器脚本。此项目的所有请求将指向 *index.php*，其中一些使用 GET 方法，一些使用 POST
    方法，一些包含有效的提交数据，另一些则包含无效的提交数据。根据 HTTP 方法（GET 或 POST）以及提交的数据是否有效，脚本将决定返回哪个显示页面作为响应。[列表
    13-1](#lis13-1) 显示了代码。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 13-1: The front-controller script in index.php deciding which page
    to display'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-1：index.php 中的前端控制器脚本，决定显示哪个页面
- en: First, we test whether the request received was via the GET method and set the
    $isGetMethod Boolean flag accordingly. Then we pass this flag to an if...else
    statement. If true, we display the form by requiring the file *displayForm.php*
    ❶. Otherwise, we must be processing a POST request containing the form submission,
    so we use the logic in the else branch (the rest of the script) to read and validate
    the data. For that, we use filter_input() to extract a $firstName value from the
    POST variables. Then we test the validity of the received name. If it’s too short,
    we set $errorMessage to a suitable message, then read in the *displayError.php*
    file to show the error page ❷. If the name is valid, we read in the *displayHello.php*
    file to show the *Hello <name>* confirmation message ❸.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们测试接收到的请求是否为 GET 方法，并相应地设置 $isGetMethod 布尔标志。然后，我们将这个标志传递给 if...else 语句。如果为
    true，则通过要求文件*displayForm.php*来显示表单 ❶。否则，我们一定是在处理一个包含表单提交的 POST 请求，因此我们使用 else
    分支（即脚本的其余部分）的逻辑来读取和验证数据。为此，我们使用 filter_input() 从 POST 变量中提取 $firstName 值。然后我们测试接收到的名称的有效性。如果名称太短，我们将
    $errorMessage 设置为适当的错误信息，然后读取*displayError.php*文件来显示错误页面 ❷。如果名称有效，则读取*displayHello.php*文件，显示*Hello
    <name>* 确认信息 ❸。
- en: Writing the Display Scripts
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写显示脚本
- en: Next, we’ll create the three display scripts, starting with the web form itself.
    Enter the contents of [Listing 13-2](#lis13-2) into a file named *displayForm.php*
    in the *public* folder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建三个显示脚本，首先是网页表单本身。将[列表 13-2](#lis13-2)的内容输入到名为*displayForm.php*的文件中，该文件位于*public*文件夹内。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 13-2: The displayForm.php script to display the form to the user'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-2：displayForm.php 脚本，用来向用户显示表单
- en: This script consists entirely of HTML template text, namely a POST-method form
    with a name input and a Submit button. Because we don’t give the form an action
    attribute, the form will be submitted to the same URL as the request that displayed
    the form. In this case, that’s our *index.php* front-controller script.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本完全由 HTML 模板文本组成，即一个 POST 方法的表单，包含一个名称输入框和一个提交按钮。因为我们没有给表单指定 action 属性，表单会提交到与显示表单的请求相同的
    URL。在这种情况下，就是我们的*index.php*前端控制器脚本。
- en: Next, [Listing 13-3](#lis13-3) creates the page confirming a valid submission.
    Copy the listing into a file called *displayHello.php*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，[列表 13-3](#lis13-3)创建了一个确认有效提交的页面。将列表内容复制到名为*displayHello.php*的文件中。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 13-3: The displayHello.php script to confirm that a valid name has
    been received'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-3：displayHello.php 脚本，用来确认已收到有效的名称
- en: 'Within the HTML template text, we use the PHP short echo tag to output the
    value of the $firstName variable. Notice that this variable hasn’t been declared
    in *displayHello.php* itself, but that’s okay. This file isn’t written as a stand-alone
    script but rather is intended to be required from another script: *index.php*.
    As long as we’ve set the $firstName variable in *index.php* before reading in
    this script (which we have), the variable will be accessible within *displayHello.php*
    as well.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 模板文本中，我们使用 PHP 简短的 echo 标签输出 $firstName 变量的值。请注意，这个变量并没有在*displayHello.php*中声明，但这没关系。这个文件不是作为独立脚本编写的，而是打算从另一个脚本（*index.php*）中被引入。只要我们在读取这个脚本之前在*index.php*中设置了
    $firstName 变量（我们已经设置了），该变量在*displayHello.php*中也可以访问。
- en: Finally, we’ll write the third display page that outputs an error message. Create
    *displayError.php* and enter the contents of [Listing 13-4](#lis13-4).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编写第三个显示页面，输出错误信息。创建*displayError.php*并输入[列表 13-4](#lis13-4)的内容。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 13-4: The displayError.php script to show an error message to the user'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-4：用来向用户显示错误信息的 displayError.php 脚本
- en: We again use a PHP short echo tag to output the value of a variable (in this
    case, $errorMessage). Once again, we need to ensure that this variable has been
    assigned a value in *index.php* before the front-controller script references
    the *displayError.php* display script.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 PHP 简短的 echo 标签输出变量的值（在此例中是$errorMessage）。我们需要确保在前端控制器脚本引用*displayError.php*显示脚本之前，*index.php*中已经给这个变量赋值。
- en: We now have four PHP scripts in our project. This may seem like a lot, but each
    script has the advantage of having a single core responsibility. We have three
    scripts to display the application’s three possible pages, along with an *index.php*
    front-controller script that pulls together the main program logic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的项目中有四个PHP脚本。虽然这看起来有点多，但每个脚本都有一个核心职责。我们有三个脚本来显示应用程序的三个可能页面，还有一个*index.php*前端控制器脚本，负责将主要程序逻辑整合在一起。
- en: Moving Website Logic into Functions
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将网站逻辑移入函数
- en: We can further organize our project by taking each task or decision in the *index.php*
    front controller and encapsulating it in its own function. While the current level
    of complexity of *index.php* is suitable for this small project, multipage websites
    with multiple forms would become much too complex for a single script to handle.
    We’ll create a PHP file named *controllerFunctions.php* to store the functions,
    thereby streamlining the front-controller script.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将*index.php*前端控制器中的每个任务或决策封装成独立的函数，进一步组织我们的项目。虽然当前*index.php*的复杂度适合这个小项目，但对于有多个表单的多页面网站来说，单个脚本将变得过于复杂，无法处理。我们将创建一个名为*controllerFunctions.php*的PHP文件来存储这些函数，从而简化前端控制器脚本。
- en: Also, at present all the files are in the project’s *public* folder, meaning
    any of them can be directly requested and served to a user. For example, you could
    enter *localhost:8000/displayHello.php* in your browser’s address bar and the
    display script would be executed without the $firstName variable first having
    been assigned a value, since the form-processing logic in *index.php* wouldn’t
    have been executed. This would trigger a notice-level error flagging the undefined
    variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，目前所有文件都位于项目的*public*文件夹中，这意味着其中任何一个文件都可以被直接请求并传递给用户。例如，你可以在浏览器的地址栏中输入*localhost:8000/displayHello.php*，然后显示脚本会被执行，但此时变量$firstName尚未赋值，因为*index.php*中的表单处理逻辑尚未执行。这将触发一个通知级别的错误，提示未定义的变量。
- en: This file structure would be messy and unmanageable for a larger project, with
    potentially hundreds of directly accessible files in the *public* folder. In addition,
    we’re exposing PHP scripts that the user shouldn’t ever be able to directly request.
    The solution, as first discussed in [Chapter 10](chapter10.xhtml), is to use folders
    to separate public scripts (generally the *index.php* front controller) from those
    that shouldn’t be directly accessible to the public. We’ll implement this change
    as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个较大的项目来说，这种文件结构会显得杂乱无章，难以管理，*public*文件夹中可能有数百个可以直接访问的文件。此外，我们暴露了用户不应直接请求的PHP脚本。解决方案，如在[第10章](chapter10.xhtml)中首次讨论的那样，是使用文件夹将公共脚本（通常是*index.php*前端控制器）与不应直接对公众开放的脚本分开。我们也将实现这一变更。
- en: Designing a Secure Folder Structure
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计一个安全的文件夹结构
- en: 'To make the application more secure, move the three output scripts (*displayHello.php*,
    *displayError.php*, and *displayForm.php*) from *public* to a new folder named
    *templates*. Likewise, we don’t want users to be able to directly request our
    new *controllerFunctions.php* file. This file will contain only function declarations,
    so there’s no reason for it to be published in the *public* folder. Instead, we’ll
    put *controllerFunctions.php* in its own folder, which by convention we’ll name
    *src* (short for *source code*). The file structure for our refactored project
    will therefore look as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序更安全，将三个输出脚本（*displayHello.php*、*displayError.php*和*displayForm.php*）从*public*文件夹移动到一个名为*templates*的新文件夹中。同样，我们不希望用户能够直接请求我们新的*controllerFunctions.php*文件。这个文件只包含函数声明，因此没有必要将其发布在*public*文件夹中。相反，我们将把*controllerFunctions.php*放在一个自己的文件夹中，按照惯例我们将其命名为*src*（即*源代码*的缩写）。因此，经过重构的项目文件结构将如下所示：
- en: '![](../images/pg245.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg245.jpg)'
- en: Using separate folders like this not only makes the application more secure
    but also keeps it better organized, with the scripts grouped into folders based
    on their purpose.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用单独的文件夹不仅能提高应用程序的安全性，还能更好地组织它，将脚本按其用途分组到不同的文件夹中。
- en: Simplifying the Front-Controller Script
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简化前端控制器脚本
- en: Now let’s simplify our front-controller script by replacing some of the logic
    with function calls. The main task the front controller needs to do is check whether
    the received request used the GET method (in which case the form should be displayed)
    or the POST method (in which case the form should be processed).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过用函数调用替换部分逻辑来简化前端控制器脚本。前端控制器的主要任务是检查接收到的请求是否使用了GET方法（在这种情况下应该显示表单）或POST方法（在这种情况下应该处理表单）。
- en: We’ll update the script to focus just on this decision and leave the remaining
    details to separate functions (which we’ll write next). [Listing 13-5](#lis13-5)
    shows how to modify the *index.php* file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新脚本，专注于这个决策，并将剩余的细节交给单独的函数（我们接下来将编写）。[列表13-5](#lis13-5)展示了如何修改*index.php*文件。
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 13-5: The simplified front-controller script in index.php'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-5：index.php中的简化前端控制器脚本
- en: We read in the definitions for all the functions we’ll be using from *src/controllerFunctions.php*.
    The two dots (..) at the start of the filepath signify the parent directory relative
    to the current script’s directory (that is, the overall project folder that contains
    both *public* and *src*). As before, we next set the $isGetMethod Boolean flag
    and use it to control an if...else statement. This time, however, the if...else
    statement simply invokes the displayForm() function if the server receives a GET
    request or invokes the processForm() function if it is a POST request.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从*src/controllerFunctions.php*中读取所有将要使用的函数的定义。文件路径开头的两个点（..）表示相对于当前脚本目录的父级目录（即包含*public*和*src*文件夹的整个项目文件夹）。与之前一样，我们接着设置$isGetMethod布尔标志，并用它来控制if...else语句。不过这次，if...else语句仅在服务器收到GET请求时调用displayForm()函数，或者在收到POST请求时调用processForm()函数。
- en: Writing the Functions
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写函数
- en: All that remains is to declare the functions handling the more granular front-controller
    logic in the new *src/controllerFunctions.php* file. First, let’s write the displayForm()
    function, as in [Listing 13-6](#lis13-6).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是在新的*src/controllerFunctions.php*文件中声明处理更细粒度前端控制器逻辑的函数了。首先，让我们编写displayForm()函数，如[列表13-6](#lis13-6)所示。
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 13-6: A function to display the form'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-6：显示表单的函数
- en: This function simply reads in and executes the contents of the *templates/ displayForm.php*
    file by using require_once.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数仅通过使用require_once读取并执行*templates/displayForm.php*文件的内容。
- en: Next, let’s write the processForm() function that will extract the name from
    the POST variables and decide what to do depending on whether it’s valid, as in
    [Listing 13-7](#lis13-7).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写processForm()函数，该函数将从POST变量中提取名字，并根据其有效性决定执行什么操作，如[列表13-7](#lis13-7)所示。
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 13-7: A function to process the form'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-7：处理表单的函数
- en: 'This function reads the $firstName variable from the incoming request and tests
    whether it’s less than three characters long. We invoke another custom function
    depending on the result: either displayErrorMessage() or displayHello(). Notice
    that the latter takes the $firstName variable as an argument; you’ll learn more
    about this shortly. We’ll define these two functions in [Listing 13-8](#lis13-8).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数从传入的请求中读取$firstName变量，并测试它是否小于三个字符。如果是，根据结果调用另一个自定义函数：要么调用displayErrorMessage()，要么调用displayHello()。请注意，后者将$firstName变量作为参数传递；稍后你将更详细地了解这一点。我们将在[列表13-8](#lis13-8)中定义这两个函数。
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 13-8: Functions to display the Hello <name> greeting or an error message'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-8：用于显示Hello <name>问候语或错误信息的函数
- en: The displayHello() function receives the valid first-name string, then reads
    in and displays the *displayHello.php* page. The displayErrorMessage() function
    assigns an error message string to the $errorMessage variable, then reads in and
    displays the *displayError.php* page.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: displayHello()函数接收有效的名字字符串，然后读取并显示*displayHello.php*页面。displayErrorMessage()函数将错误消息字符串分配给$errorMessage变量，然后读取并显示*displayError.php*页面。
- en: The displayHello() function has a $firstName parameter because of the scoping
    of variables in PHP. When a function reads in and executes a PHP script file by
    using a require_once statement, any variables expected by that script must be
    either parameters received by the function or variables created within the function.
    In this case, since the *displayHello.php* script needs access to $firstName,
    a value for that variable must be passed to the displayHello() function. If $firstName
    weren’t a function parameter, no variable of that name would be available to output
    in the *displayHello.php* script, and we would see the error displayed in [Figure
    13-2](#fig13-2).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayHello()` 函数有一个 `$firstName` 参数，这是由于 PHP 中变量的作用域。当一个函数通过 `require_once`
    语句读取并执行 PHP 脚本文件时，任何该脚本需要的变量必须是函数接收的参数或者在函数内创建的变量。在这种情况下，由于 *displayHello.php*
    脚本需要访问 `$firstName`，因此必须将该变量的值传递给 `displayHello()` 函数。如果 `$firstName` 不是一个函数参数，则在
    *displayHello.php* 脚本中无法使用该名称的变量进行输出，我们将看到在 [图 13-2](#fig13-2) 中显示的错误。'
- en: 'Overall, the functionality of our application is just the same as before, but
    it has a much better architecture that’s easier to maintain, more secure, and
    more scalable in the event the project requirements expand in the future. Our
    only public script is the front controller in *public/index.php*, and every HTTP
    request to the server goes through this script. The front controller determines
    whether the user wants the form displayed (via a GET request) or has submitted
    the form for processing (a POST request). The remaining controller logic is encapsulated
    in a collection of functions declared in the *src/controllerFunctions.php* file.
    Meanwhile, the three responses that can be returned to the client are defined
    in scripts in the *templates* folder: *displayForm.php*, *displayHello.php*, and
    *displayError.php*.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们应用程序的功能和之前一样，但它具有更好的架构，易于维护、更安全，并且在未来项目需求扩展时具有更好的可扩展性。我们唯一的公共脚本是 *public/index.php*
    中的前端控制器，每个 HTTP 请求都通过这个脚本。前端控制器决定用户是想显示表单（通过 GET 请求），还是已经提交表单进行处理（通过 POST 请求）。剩余的控制器逻辑被封装在
    *src/controllerFunctions.php* 文件中声明的一系列函数中。同时，返回给客户端的三种响应定义在 *templates* 文件夹中的脚本中：*displayForm.php*、*displayHello.php*
    和 *displayError.php*。
- en: Generalizing the Front-Controller Structure
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用前端控制器结构
- en: You’ve seen how much simpler scripts and functions become once you start breaking
    an application into individual responsibilities. Let’s now test the architecture
    we’ve developed on a new, more complex website project with several pages. You’ll
    see how a front-controller script can cope with several GET requests as well as
    a POST form submission and its validation logic.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，脚本和函数在开始将应用程序拆分成独立的职责后变得多么简单。接下来，我们将在一个新的、更复杂的多页面网站项目中测试我们开发的架构。你将看到一个前端控制器脚本如何处理多个
    GET 请求以及 POST 表单提交和其验证逻辑。
- en: '[Figure 13-3](#fig13-3) shows the three-page site we’ll create, including a
    home page, a contact details page, and an inquiry form. The *MGW* name is a placeholder,
    standing for *My Great Website*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-3](#fig13-3) 展示了我们将创建的三页站点，包括一个主页、一个联系方式页面和一个查询表单。*MGW* 名称是一个占位符，代表 *My
    Great Website*。'
- en: '![](../images/figure13-3.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure13-3.jpg)'
- en: 'Figure 13-3: A three-page web application displayed in the browser'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-3：在浏览器中显示的三页 Web 应用程序
- en: Each page has a navigation bar at the top with the current page highlighted,
    followed by a level 1 heading and some page content. To give the pages the nice
    styling shown in the figure, we’ll link to the prewritten Bootstrap CSS stylesheet,
    as we did in [Chapter 11](chapter11.xhtml).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面顶部都有一个导航栏，当前页面被高亮显示，后面跟着一个一级标题和一些页面内容。为了给页面提供如图所示的漂亮样式，我们将链接到预编写的 Bootstrap
    CSS 样式表，正如我们在 [第 11 章](chapter11.xhtml) 中所做的那样。
- en: Distinguishing Between Requested Pages
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 区分请求的页面
- en: Each of the three pages in our application will be displayed in response to
    a GET request, so we need a way to determine which page is being requested. This
    is a bit different from our *Hello <name>* application, where we knew a GET request
    could only be for displaying the web form. One simple and common solution is to
    add an action query-string variable to every request, regardless of whether the
    GET or POST method is used, and give the variable a value indicating the desired
    action or page. The request URLs will therefore look something like *index.php?action=contactUs*
    to display the contact details page and *index.php?action=inquiryForm* to display
    the inquiry form page.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用中的三个页面将响应GET请求进行显示，因此我们需要一种方法来确定哪个页面正在被请求。这与我们*Hello <name>*应用有所不同，在那个应用中，我们知道GET请求仅用于显示网页表单。一个简单且常见的解决方案是为每个请求添加一个操作查询字符串变量，无论使用的是GET方法还是POST方法，并为该变量赋值，以指示所需的操作或页面。因此，请求的URL将类似于*index.php?action=contactUs*，用于显示联系方式页面，*index.php?action=inquiryForm*，用于显示咨询表单页面。
- en: As we build our new site, we’ll be sure to present links to the user that will
    pass such an action variable to the server with each GET request. We’ll also set
    an action query-string variable to processForm when the inquiry form is being
    submitted with the POST method. All the requests will go to the *index.php* front-controller
    script, which simply has to detect the value of the action variable to determine
    what to do. If no value for action is received, or if the value isn’t recognized,
    the home page will be displayed by default.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们新网站的过程中，我们将确保为用户呈现链接，这些链接会将操作变量传递给服务器，以便在每个GET请求中使用。我们还会在使用POST方法提交咨询表单时，将操作查询字符串变量设置为processForm。所有请求都会发送到*index.php*前端控制器脚本，脚本只需要检测操作变量的值来确定执行什么操作。如果没有接收到操作值，或者值无法识别，则默认显示主页。
- en: Notice that the different values for the action query-string variable can also
    be seen in the URL address bars in [Figure 13-3](#fig13-3). The home page, which
    is also the website root, is simply *localhost:8000*; the Contact Us page ends
    with *index.php?action=contact*; and the Enquiry Form page ends with *index.php?action=enquiryForm*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，操作查询字符串变量的不同值也可以在[图13-3](#fig13-3)中的URL地址栏中看到。主页，也是网站的根目录，仅为*localhost:8000*；联系我们页面以*index.php?action=contact*结尾；咨询表单页面以*index.php?action=enquiryForm*结尾。
- en: Building a Multipage Application
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建多页面应用
- en: We’ll now build a three-page web application like the one illustrated in [Figure
    13-3](#fig13-3). Create a new folder for this project, and create the *public*,
    *src*, and *templates* subfolders inside it. We’ll follow the same directory structure
    used for the simpler application earlier in the chapter. We’ll start by writing
    the application’s front-controller script.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个三页的网站应用，如[图13-3](#fig13-3)所示。为此项目创建一个新文件夹，并在其中创建*public*、*src*和*templates*子文件夹。我们将遵循本章前面简单应用程序使用的相同目录结构。我们将从编写应用程序的前端控制器脚本开始。
- en: Creating the Front Controller
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建前端控制器
- en: We’ll structure our *public/index.php* script around a straightforward PHP switch
    statement (see [Chapter 4](chapter4.xhtml)) based on the value of the action query-string
    variable. [Listing 13-9](#lis13-9) shows the script. It includes calls to some
    functions we’ll write in a moment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将围绕一个简单的PHP switch语句（参见[第4章](chapter4.xhtml)）来构建*public/index.php*脚本，该语句基于操作查询字符串变量的值。[列表13-9](#lis13-9)显示了该脚本。它包括调用我们稍后将编写的一些函数。
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 13-9: The front-controller logic in index.php for a three-page website'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-9：用于三页网站的index.php中的前端控制器逻辑
- en: The front controller reads in the function declarations in *controller Functions.php*,
    then extracts the value of the action query-string variable and passes it to a
    switch statement. The statement has cases for displaying each of the pages (including
    the default case of displaying the home page), as well as a case for processing
    the submitted inquiry form. Each case simply calls a custom function that will
    handle the actual work of carrying out the desired action, such as displayContactDetails()
    to show the contact details page.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前端控制器读取*controller Functions.php*中的函数声明，然后提取操作查询字符串变量的值，并将其传递给switch语句。该语句包含用于显示每个页面的情况（包括默认的显示主页情况），以及处理提交的咨询表单的情况。每个情况简单地调用一个自定义函数来处理执行所需操作的实际工作，例如，displayContactDetails()用来显示联系方式页面。
- en: Designing the front controller around a switch statement makes it quite simple
    to expand the application if necessary. To add another page to the website, all
    we’d have to do is insert another case into the switch statement, write a corresponding
    function in *controllerFunctions.php*, and add a template for displaying the page
    to the *templates* folder. For more complex websites, we could break things up
    even further by having different collections of functions for different types
    of website actions. For example, manager actions could be in a file named *managerFunctions.php*,
    and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设计围绕 switch 语句的前端控制器使得在必要时扩展应用程序变得非常简单。要向网站添加另一页，我们所需要做的只是将另一个 case 插入到 switch
    语句中，在 *controllerFunctions.php* 中编写相应的函数，并为页面创建一个模板并添加到 *templates* 文件夹中。对于更复杂的网站，我们可以通过为不同类型的网页操作创建不同的函数集合来进一步拆分。例如，管理者操作可以放在一个名为
    *managerFunctions.php* 的文件中，以此类推。
- en: Writing the Display Functions
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写显示函数
- en: Now we’ll write simple functions to display the three basic pages. Create *src/controllerFunctions.php*
    containing the code in [Listing 13-10](#lis13-10).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写简单的函数来显示三个基本页面。创建包含 [列表 13-10](#lis13-10) 中代码的 *src/controllerFunctions.php*
    文件。
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 13-10: The functions to display the three basic pages'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-10：显示三个基本页面的函数
- en: Each of the functions uses a require_once statement to read in and display the
    contents of the corresponding template file. (We’ll make those template files
    next.) For example, the displayHomePage() function reads in and displays the *templates/homepage.php*
    script.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数使用 require_once 语句来读取并显示相应模板文件的内容。（接下来我们将创建这些模板文件。）例如，displayHomePage()
    函数读取并显示 *templates/homepage.php* 脚本。
- en: Creating the Page Templates
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建页面模板
- en: We’ll now create the templates for the application’s various pages, starting
    with the project’s home page in *templates/homePage.php*. Create the file as shown
    in [Listing 13-11](#lis13-11).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为应用程序的各个页面创建模板，从 *templates/homePage.php* 开始，这是项目的主页。按照 [列表 13-11](#lis13-11)
    所示创建该文件。
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 13-11: The homePage.php template'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-11：homePage.php 模板
- en: After linking to the Bootstrap stylesheet, we create a navigation bar at the
    top of the page by using an unordered list with the Bootstrap nav and nav-pills
    styles ❶. Each list item, styled with the nav-item class, contains a link to one
    of the three pages. Each link is styled with the nav-link class. The link for
    the currently displayed page (home) is also styled with the active class so it
    will be highlighted ❷. Notice that we include an action query-string variable
    in the hyperlinks for the Contact Us and Inquiry Form pages. The hyperlink for
    the home page is simply a forward slash (/). We could have used /index.php instead,
    but since the *index.php* script loads by default, this isn’t necessary.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接到 Bootstrap 样式表后，我们通过使用带有 Bootstrap nav 和 nav-pills 样式的无序列表来创建页面顶部的导航栏 ❶。每个列表项都使用
    nav-item 类样式，并包含指向三个页面之一的链接。每个链接都使用 nav-link 类样式。当前显示的页面（首页）的链接也使用 active 类样式，以便高亮显示
    ❷。注意，我们在“联系我们”和“查询表单”页面的超链接中包括了一个 action 查询字符串变量。首页的超链接则是简单的斜杠（/）。我们本可以使用 /index.php
    代替，但由于 *index.php* 脚本是默认加载的，所以不需要这样做。
- en: We can now copy our home-page script and alter its code to create the contact
    details page in *templates/contactUs.php*, as shown in [Listing 13-12](#lis13-12).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以复制首页脚本，并修改其代码来创建 *templates/contactUs.php* 中的联系信息页面，如 [列表 13-12](#lis13-12)
    所示。
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 13-12: The contactUs.php template'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-12：contactUs.php 模板
- en: We’ve kept the boilerplate HTML at the start of the file the same, except for
    changing the page title and styling the Contact Us page link in the navigation
    bar as active instead of the home-page link. Then we’ve filled in some contact
    information for the body of the page.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保持了文件开头的基本 HTML 结构不变，唯一的修改是更改了页面标题，并将导航栏中的“联系我们”链接样式设置为激活状态，而不是首页链接。然后，我们在页面的主体部分填写了一些联系信息。
- en: Next, we’ll write the code for the inquiry form. Once again, start by copying
    one of your other templates into a new *templates/inquiryForm.php* file. Then
    change the page title and set the Inquiry Form link in the navigation bar to active.
    Use the HTML code in [Listing 13-13](#lis13-13) to create the inquiry form itself.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写查询表单的代码。再次通过复制其他模板中的一个文件到一个新的 *templates/inquiryForm.php* 文件中开始。然后更改页面标题，并将导航栏中的“查询表单”链接设置为激活状态。使用
    [列表 13-13](#lis13-13) 中的 HTML 代码来创建查询表单本身。
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 13-13: The inquiryForm.php template'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-13：inquiryForm.php 模板
- en: We make the Submit an Inquiry link active in the navigation bar ❶. We declare
    the form with the POST method and define its action as /index.php?action=processForm
    ❷, so when the form is submitted, it will pass an action query-string variable
    with the value processForm. The rest of the HTML adds form inputs for a customer
    name, an email address, and the text of an inquiry (as a textarea input), plus
    a Submit button, all decorated with more Bootstrap CSS classes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使“提交询问”链接在导航栏中变为激活状态❶。我们声明表单使用 POST 方法，并将其 action 设置为 /index.php?action=processForm❷，因此当表单提交时，它将传递一个名为
    action 的查询字符串变量，值为 processForm。剩余的 HTML 添加了客户姓名、电子邮件地址和询问内容（作为文本区域输入）的表单输入项，还有一个提交按钮，所有这些都装饰有更多的
    Bootstrap CSS 类。
- en: Confirming Receipt of Valid Form Data
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 确认有效表单数据的接收
- en: If the user enters valid data (we’ll just test for non-empty form fields for
    this project), we’ll display a confirmation page stating that the inquiry has
    been received and echoing the submitted values back to the user. One simple way
    to do this is to present a similar form prefilled with the submitted values, with
    each field set to disabled so the user can’t edit the information and attempt
    to resubmit it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入有效数据（对于这个项目，我们只测试表单字段是否为空），我们将显示一个确认页面，声明询问已收到，并将提交的值回显给用户。实现这一点的一种简单方法是呈现一个类似的表单，预填入提交的值，且每个字段都设置为禁用，这样用户无法编辑信息并尝试重新提交。
- en: '[Figure 13-4](#fig13-4) shows an inquiry form complete with valid values (left)
    and the corresponding read-only confirmation form page (right). Users will understand
    that the page is read-only because the boxes are grayed out, there isn’t a Submit
    button, and nothing happens when they click the mouse cursor in the fields.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-4](#fig13-4)显示了一个完整的询问表单（左侧）和相应的只读确认表单页面（右侧）。用户将明白该页面是只读的，因为框已被灰显，没有提交按钮，且点击表单字段时不会发生任何事情。'
- en: '![](../images/figure13-4.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure13-4.jpg)'
- en: 'Figure 13-4: Comparing the form submission and confirmation pages'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-4：比较表单提交与确认页面
- en: Enter the content in [Listing 13-14](#lis13-14) into a new template file called
    *templates/confirmData.php* to create the valid form confirmation. Much of the
    code can be copied from the inquiry form script *inquiryForm.php*. You’ll also
    need to add our standard HTML head and navigation bar at the beginning of the
    file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表 13-14](#lis13-14)中的内容输入到一个名为 *templates/confirmData.php* 的新模板文件中，以创建有效的表单确认。大部分代码可以从询问表单脚本
    *inquiryForm.php* 中复制。你还需要在文件的开头添加我们的标准 HTML 头和导航栏。
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 13-14: The confirmData.php template'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-14：confirmData.php 模板
- en: We use the PHP short echo tag to insert the value of the $customerName variable
    into the customerName input field, setting the field to disabled so it can’t be
    edited ❶. We use the same mechanism to show the received $customerEmail and $inquiry
    values. We don’t need to add a <form> element or a Submit button to this template
    page; we’re just echoing the data back to the user, so this isn’t an interactive
    form.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 PHP 短回显标签将 $customerName 变量的值插入到 customerName 输入字段中，并将该字段设置为禁用，以防止编辑❶。我们使用相同的机制显示接收到的
    $customerEmail 和 $inquiry 值。我们不需要在此模板页面中添加 `<form>` 元素或提交按钮；我们只是将数据回显给用户，所以这不是一个交互式表单。
- en: Processing the Submitted Data
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理提交的数据
- en: Let’s now write the processForm() function to receive the form data submitted
    with the POST request and decide what to do depending on whether the data is valid.
    Add the function shown in [Listing 13-15](#lis13-15) to the end of the *src/controllerFunctions.php*
    file (although it doesn’t actually matter in what order functions are declared
    in files like this).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写 `processForm()` 函数，接收通过 POST 请求提交的表单数据，并根据数据是否有效决定下一步操作。将[列表 13-15](#lis13-15)中的函数添加到
    *src/controllerFunctions.php* 文件的末尾（尽管在这种文件中，函数的声明顺序实际上并不重要）。
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 13-15: A function to process the form data'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-15：一个处理表单数据的函数
- en: First, we use three filter_input() calls ❶ to attempt to extract the received
    POST form data for the three expected values. Notice that for the two strings
    (name and inquiry), we use a FILTER_SANITIZE_SPECIAL_CHAR filter as the third
    function argument, and we use FILTER_SANITIZE_EMAIL for the customer email input.
    These filters remove any unsafe characters submitted through the form, protecting
    against cross-site scripting (XSS) attacks, where JavaScript code is submitted
    through forms to attempt to gain entry to website data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: We next implement the array-based approach to data validation discussed in [Chapter
    12](chapter12.xhtml). We declare $errors as an empty array ❷, then use three if
    statements to test whether any of the received form variables are empty, adding
    an appropriate error message to the array if necessary. Finally, we test the size
    of the $errors array ❸, and if any errors have been found, we display the file
    *templates/displayError.php* (which we’ll create next). Otherwise, if the submitted
    data is all valid, we invoke the confirmData() function, passing $customerName,
    $customerEmail, and $inquiry as arguments. [Listing 13-16](#lis13-16) shows the
    code for this function. Enter the code at the end of *src/controllerFunctions.php*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 13-16: A function confirming valid data to the user'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: This function reads in and executes the *templates/confirmData.php* file. As
    before, the function must take in the variables needed within the template script
    as parameters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Error Page
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As a final step, we need to create the template file for a page displaying any
    error messages to the user. [Figure 13-5](#fig13-5) shows this error page when
    all three validation checks have failed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure13-5.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: The error page'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called *templates/displayError.php* containing the error output
    script shown in [Listing 13-17](#lis13-17). Once again, you’ll have to also add
    the standard HTML head and navigation bar code to the start of the script.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 13-17: A displayError.php template'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'We set the CSS style of the page’s main <div> to the Bootstrap classes "alert
    alert-danger" ❶, a typical website error style with a pink background. Then we
    use a foreach loop with alternative syntax to cycle through each message in the
    $errors array ❷ and display it as a list item ❸.  ### Summary'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ve worked toward a well-organized and extensible web application
    architecture, which we’ve applied to a multipage website featuring both static
    pages and a web form. The architecture hinges on a single *public/index.php* front-controller
    script, which at its core is a straightforward switch statement deciding what
    to do based on the action query-string variable sent with each incoming HTTP request.
    We’ve delegated other, more granular logic to custom functions, which we’ve safely
    declared outside the *public* folder in *src/controllerFunctions.php*. Meanwhile,
    all the scripts that output HTML content to the user are located in the *templates*
    folder. These scripts harness Bootstrap CSS to achieve professional-looking formatting
    with minimal code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Although this project has many more pages and features than the previous form-processing
    projects from the last few chapters, none of our scripts or functions are complex
    or long-winded, demonstrating that the architecture we’ve adopted is suitable
    for more sophisticated websites, while still being readily understandable and
    easy to maintain.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Create a website containing four simple page templates (no forms): a home
    page (*home.php*), an about page (*about.php*), a contact details page (*contact.php*),
    and a customer recommendations page (*recommendations.php*). These pages should
    be accessed from the index page through the value of the action query-string parameter,
    like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Structure your project by using the front-controller architecture demonstrated
    in this chapter and the functions declared in *src/controllerFunctions.php*. You
    should have the following file structure:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg257.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: 2.   Using the front-controller architecture from this chapter, create a new
    website with a home-page template (*home.php*), containing a link to a staff login
    page. The staff login page template (*loginStaff.php*) should display a standard
    username/password login form. The values for a successful staff login are the
    username author and the password words. If correct values are entered, display
    a staff login success page (*successStaff.php*), but if the received username
    and password don’t match the correct ones, display a login error page (*loginError.php*).
    The error page should contain a link back to the home page.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'The website pages should be accessed from the index page through the value
    of the action query-string parameter, like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 3.   Copy and extend your solution for Exercise 2, adding a second login page
    for clients (*loginClient.php*), with a link to this page also offered on the
    home page. Values for the client login are the username customer and the password
    paying. If correct client login values are received, display a client login success
    page (*successClient.php*), but if the values are invalid, display the login error
    page (*loginError.php*).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The website pages should be accessed from the index page through the value
    of the action query-string parameter, like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 网站页面应该通过索引页面访问，并通过 action 查询字符串参数的值来进行访问，格式如下：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 4.   Copy and extend your solution for Exercise 3, placing the staff and client
    login forms into the home page. The home page should contain welcome text and
    two login forms, one for staff and one for clients.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   复制并扩展第3题的解法，将员工和客户登录表单放入主页。主页应包含欢迎文本和两个登录表单，一个供员工使用，一个供客户使用。
- en: '5.   Copy and extend your solution for Exercise 4, now offering a single login
    form on the home page, but two Submit buttons: one for staff and one for clients.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   复制并扩展第4题的解法，现在在主页上提供一个登录表单，但有两个提交按钮：一个供员工使用，一个供客户使用。
- en: 'Hint: See [Chapter 11](chapter11.xhtml) to review how to detect which of the
    two Submit buttons has been clicked.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：查看[第11章](chapter11.xhtml)以复习如何检测哪个提交按钮被点击了。
