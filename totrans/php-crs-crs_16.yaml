- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 13 ORGANIZING A WEB APPLICATION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll progressively explore a structured approach to dividing
    a web application’s responsibilities among multiple scripts while also developing
    a project folder architecture that gives every script a clearly defined home.
    You’ll be introduced to the *front-controller* design pattern, which requires
    the sending of every request to the web server through a single script that decides
    how to respond, then delegates the responsibility for generating that response
    to other server scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapters 11](chapter11.xhtml) and [12](chapter12.xhtml) introduced differing
    approaches to designing a web application. One is to write multiple scripts for
    each web form that separately handle displaying, validating, and confirming the
    form; another is to create a single postback script that does all those tasks.
    Both approaches have advantages and disadvantages, but neither is scalable for
    web applications that may grow in size and complexity over time. You wouldn’t
    want to have tens, hundreds, or even thousands of PHP scripts sitting in your
    application’s *public* folder, as might happen with the first approach, for reasons
    of maintenance as well as security (malicious users may attempt to execute public
    scripts out of sequence to bypass validation checks, for example). But neither
    would you want an individual script to become overly complex, as might happen
    with the second approach.'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture we’ll discuss in this chapter addresses these problems by focusing
    all decision-making logic on the single front-controller script while using other
    scripts or functions to carry out all other tasks. The front controller acts much
    like the receptionist in a large office building, whom every guest must visit;
    it identifies and interprets each request (who the visitor is and what they’re
    asking for), and directs it to the appropriate server script (a room in the building)
    that satisfies the request. With this architecture, no one script is overly complicated,
    and while an application can grow to include many scripts, they’re organized in
    such a way that the application is easy to maintain and extend.
  prefs: []
  type: TYPE_NORMAL
- en: Front Controllers and the MVC Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 10](chapter10.xhtml) introduced the model-view-controller (MVC) architecture,
    a design pattern that divides a web application into three main components. The
    *model* represents the data underlying the application, typically stored in a
    database; the *view* uses templating to determine how the data is displayed to
    the user; and the *controller* makes decisions about what data to display when.
    The front-controller scripts we’ll explore in this chapter are the core piece
    of the controller portion of the MVC architecture, as they take in every HTTP
    request to the application and determine how to respond. [Figure 13-1](#fig13-1)
    illustrates how a front controller fits into the MVC pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure13-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: The MVC architecture, featuring a front controller'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *front controller* ❶ handles every HTTP request received from web clients,
    deciding which *action controller* should be invoked. These action controllers
    are more specialized scripts or functions, also part of the controller component
    of the MVC architecture, that carry out particular tasks for the application,
    such as checking stored security credentials or manipulating data like shopping-cart
    contents. An action controller may need to read the contents of a data store,
    such as a database system (more about this in [Part VI](part6.xhtml)). The action
    controller then invokes the view (templating) component ❷ to create the contents
    of the response to be returned to the user, passing along the data from the model
    if appropriate. The action controller then receives the output from the view component
    ❸ and adds any appropriate headers or response codes. Finally, the response is
    sent back to the web client ❹.  ### Separating Display and Logic Files'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll revisit the simple *Hello <name>* form developed in the preceding two
    chapters to start the process of separating the display code from the decision-making
    logic in an application. See “A Simple Example” on [page 199](chapter11.xhtml#pg_199)
    to review how we initially created and processed that form with separate scripts,
    and “Simple Validation Logic” on [page 231](chapter12.xhtml#pg_231) for how we
    validated and displayed the form with a single postback script. In this version,
    the application will have three possible responses it may return:'
  prefs: []
  type: TYPE_NORMAL
- en: The blank form if the HTTP request used the GET method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *Hello <name>* confirmation message if a valid name was received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error message if an invalid name (less than three characters long) was received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decision-making logic and possible outputs are modeled in the flowchart
    in [Figure 13-2](#fig13-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure13-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: Modeling the logic and outputs of the Hello <name> application'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create a separate file for each of the three possible outputs. Meanwhile,
    every request will be routed to the front controller in the *index.php* file.
    The logic in the front controller will decide what to do (that is, which of the
    other three files to draw upon to generate the output to be returned to the user).
    The file structure for the project will therefore look as follows when we’ve finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that all the files are located in the project’s *public* folder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Front Controller
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll first write the *index.php* front-controller script. All requests for
    this project will be for *index.php*, some with the GET method, some with the
    POST method, some containing valid submitted data, and some containing invalid
    submitted data. Depending on the type of HTTP method (GET or POST) and whether
    the submitted data is valid, this script decides which of the three display pages
    to return as the response. [Listing 13-1](#lis13-1) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-1: The front-controller script in index.php deciding which page
    to display'
  prefs: []
  type: TYPE_NORMAL
- en: First, we test whether the request received was via the GET method and set the
    $isGetMethod Boolean flag accordingly. Then we pass this flag to an if...else
    statement. If true, we display the form by requiring the file *displayForm.php*
    ❶. Otherwise, we must be processing a POST request containing the form submission,
    so we use the logic in the else branch (the rest of the script) to read and validate
    the data. For that, we use filter_input() to extract a $firstName value from the
    POST variables. Then we test the validity of the received name. If it’s too short,
    we set $errorMessage to a suitable message, then read in the *displayError.php*
    file to show the error page ❷. If the name is valid, we read in the *displayHello.php*
    file to show the *Hello <name>* confirmation message ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Display Scripts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll create the three display scripts, starting with the web form itself.
    Enter the contents of [Listing 13-2](#lis13-2) into a file named *displayForm.php*
    in the *public* folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-2: The displayForm.php script to display the form to the user'
  prefs: []
  type: TYPE_NORMAL
- en: This script consists entirely of HTML template text, namely a POST-method form
    with a name input and a Submit button. Because we don’t give the form an action
    attribute, the form will be submitted to the same URL as the request that displayed
    the form. In this case, that’s our *index.php* front-controller script.
  prefs: []
  type: TYPE_NORMAL
- en: Next, [Listing 13-3](#lis13-3) creates the page confirming a valid submission.
    Copy the listing into a file called *displayHello.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-3: The displayHello.php script to confirm that a valid name has
    been received'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the HTML template text, we use the PHP short echo tag to output the
    value of the $firstName variable. Notice that this variable hasn’t been declared
    in *displayHello.php* itself, but that’s okay. This file isn’t written as a stand-alone
    script but rather is intended to be required from another script: *index.php*.
    As long as we’ve set the $firstName variable in *index.php* before reading in
    this script (which we have), the variable will be accessible within *displayHello.php*
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll write the third display page that outputs an error message. Create
    *displayError.php* and enter the contents of [Listing 13-4](#lis13-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-4: The displayError.php script to show an error message to the user'
  prefs: []
  type: TYPE_NORMAL
- en: We again use a PHP short echo tag to output the value of a variable (in this
    case, $errorMessage). Once again, we need to ensure that this variable has been
    assigned a value in *index.php* before the front-controller script references
    the *displayError.php* display script.
  prefs: []
  type: TYPE_NORMAL
- en: We now have four PHP scripts in our project. This may seem like a lot, but each
    script has the advantage of having a single core responsibility. We have three
    scripts to display the application’s three possible pages, along with an *index.php*
    front-controller script that pulls together the main program logic.
  prefs: []
  type: TYPE_NORMAL
- en: Moving Website Logic into Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can further organize our project by taking each task or decision in the *index.php*
    front controller and encapsulating it in its own function. While the current level
    of complexity of *index.php* is suitable for this small project, multipage websites
    with multiple forms would become much too complex for a single script to handle.
    We’ll create a PHP file named *controllerFunctions.php* to store the functions,
    thereby streamlining the front-controller script.
  prefs: []
  type: TYPE_NORMAL
- en: Also, at present all the files are in the project’s *public* folder, meaning
    any of them can be directly requested and served to a user. For example, you could
    enter *localhost:8000/displayHello.php* in your browser’s address bar and the
    display script would be executed without the $firstName variable first having
    been assigned a value, since the form-processing logic in *index.php* wouldn’t
    have been executed. This would trigger a notice-level error flagging the undefined
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: This file structure would be messy and unmanageable for a larger project, with
    potentially hundreds of directly accessible files in the *public* folder. In addition,
    we’re exposing PHP scripts that the user shouldn’t ever be able to directly request.
    The solution, as first discussed in [Chapter 10](chapter10.xhtml), is to use folders
    to separate public scripts (generally the *index.php* front controller) from those
    that shouldn’t be directly accessible to the public. We’ll implement this change
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a Secure Folder Structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the application more secure, move the three output scripts (*displayHello.php*,
    *displayError.php*, and *displayForm.php*) from *public* to a new folder named
    *templates*. Likewise, we don’t want users to be able to directly request our
    new *controllerFunctions.php* file. This file will contain only function declarations,
    so there’s no reason for it to be published in the *public* folder. Instead, we’ll
    put *controllerFunctions.php* in its own folder, which by convention we’ll name
    *src* (short for *source code*). The file structure for our refactored project
    will therefore look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using separate folders like this not only makes the application more secure
    but also keeps it better organized, with the scripts grouped into folders based
    on their purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the Front-Controller Script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s simplify our front-controller script by replacing some of the logic
    with function calls. The main task the front controller needs to do is check whether
    the received request used the GET method (in which case the form should be displayed)
    or the POST method (in which case the form should be processed).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll update the script to focus just on this decision and leave the remaining
    details to separate functions (which we’ll write next). [Listing 13-5](#lis13-5)
    shows how to modify the *index.php* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-5: The simplified front-controller script in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: We read in the definitions for all the functions we’ll be using from *src/controllerFunctions.php*.
    The two dots (..) at the start of the filepath signify the parent directory relative
    to the current script’s directory (that is, the overall project folder that contains
    both *public* and *src*). As before, we next set the $isGetMethod Boolean flag
    and use it to control an if...else statement. This time, however, the if...else
    statement simply invokes the displayForm() function if the server receives a GET
    request or invokes the processForm() function if it is a POST request.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All that remains is to declare the functions handling the more granular front-controller
    logic in the new *src/controllerFunctions.php* file. First, let’s write the displayForm()
    function, as in [Listing 13-6](#lis13-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-6: A function to display the form'
  prefs: []
  type: TYPE_NORMAL
- en: This function simply reads in and executes the contents of the *templates/ displayForm.php*
    file by using require_once.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s write the processForm() function that will extract the name from
    the POST variables and decide what to do depending on whether it’s valid, as in
    [Listing 13-7](#lis13-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-7: A function to process the form'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function reads the $firstName variable from the incoming request and tests
    whether it’s less than three characters long. We invoke another custom function
    depending on the result: either displayErrorMessage() or displayHello(). Notice
    that the latter takes the $firstName variable as an argument; you’ll learn more
    about this shortly. We’ll define these two functions in [Listing 13-8](#lis13-8).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-8: Functions to display the Hello <name> greeting or an error message'
  prefs: []
  type: TYPE_NORMAL
- en: The displayHello() function receives the valid first-name string, then reads
    in and displays the *displayHello.php* page. The displayErrorMessage() function
    assigns an error message string to the $errorMessage variable, then reads in and
    displays the *displayError.php* page.
  prefs: []
  type: TYPE_NORMAL
- en: The displayHello() function has a $firstName parameter because of the scoping
    of variables in PHP. When a function reads in and executes a PHP script file by
    using a require_once statement, any variables expected by that script must be
    either parameters received by the function or variables created within the function.
    In this case, since the *displayHello.php* script needs access to $firstName,
    a value for that variable must be passed to the displayHello() function. If $firstName
    weren’t a function parameter, no variable of that name would be available to output
    in the *displayHello.php* script, and we would see the error displayed in [Figure
    13-2](#fig13-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, the functionality of our application is just the same as before, but
    it has a much better architecture that’s easier to maintain, more secure, and
    more scalable in the event the project requirements expand in the future. Our
    only public script is the front controller in *public/index.php*, and every HTTP
    request to the server goes through this script. The front controller determines
    whether the user wants the form displayed (via a GET request) or has submitted
    the form for processing (a POST request). The remaining controller logic is encapsulated
    in a collection of functions declared in the *src/controllerFunctions.php* file.
    Meanwhile, the three responses that can be returned to the client are defined
    in scripts in the *templates* folder: *displayForm.php*, *displayHello.php*, and
    *displayError.php*.'
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing the Front-Controller Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve seen how much simpler scripts and functions become once you start breaking
    an application into individual responsibilities. Let’s now test the architecture
    we’ve developed on a new, more complex website project with several pages. You’ll
    see how a front-controller script can cope with several GET requests as well as
    a POST form submission and its validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-3](#fig13-3) shows the three-page site we’ll create, including a
    home page, a contact details page, and an inquiry form. The *MGW* name is a placeholder,
    standing for *My Great Website*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure13-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: A three-page web application displayed in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: Each page has a navigation bar at the top with the current page highlighted,
    followed by a level 1 heading and some page content. To give the pages the nice
    styling shown in the figure, we’ll link to the prewritten Bootstrap CSS stylesheet,
    as we did in [Chapter 11](chapter11.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing Between Requested Pages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each of the three pages in our application will be displayed in response to
    a GET request, so we need a way to determine which page is being requested. This
    is a bit different from our *Hello <name>* application, where we knew a GET request
    could only be for displaying the web form. One simple and common solution is to
    add an action query-string variable to every request, regardless of whether the
    GET or POST method is used, and give the variable a value indicating the desired
    action or page. The request URLs will therefore look something like *index.php?action=contactUs*
    to display the contact details page and *index.php?action=inquiryForm* to display
    the inquiry form page.
  prefs: []
  type: TYPE_NORMAL
- en: As we build our new site, we’ll be sure to present links to the user that will
    pass such an action variable to the server with each GET request. We’ll also set
    an action query-string variable to processForm when the inquiry form is being
    submitted with the POST method. All the requests will go to the *index.php* front-controller
    script, which simply has to detect the value of the action variable to determine
    what to do. If no value for action is received, or if the value isn’t recognized,
    the home page will be displayed by default.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the different values for the action query-string variable can also
    be seen in the URL address bars in [Figure 13-3](#fig13-3). The home page, which
    is also the website root, is simply *localhost:8000*; the Contact Us page ends
    with *index.php?action=contact*; and the Enquiry Form page ends with *index.php?action=enquiryForm*.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Multipage Application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll now build a three-page web application like the one illustrated in [Figure
    13-3](#fig13-3). Create a new folder for this project, and create the *public*,
    *src*, and *templates* subfolders inside it. We’ll follow the same directory structure
    used for the simpler application earlier in the chapter. We’ll start by writing
    the application’s front-controller script.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Front Controller
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll structure our *public/index.php* script around a straightforward PHP switch
    statement (see [Chapter 4](chapter4.xhtml)) based on the value of the action query-string
    variable. [Listing 13-9](#lis13-9) shows the script. It includes calls to some
    functions we’ll write in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-9: The front-controller logic in index.php for a three-page website'
  prefs: []
  type: TYPE_NORMAL
- en: The front controller reads in the function declarations in *controller Functions.php*,
    then extracts the value of the action query-string variable and passes it to a
    switch statement. The statement has cases for displaying each of the pages (including
    the default case of displaying the home page), as well as a case for processing
    the submitted inquiry form. Each case simply calls a custom function that will
    handle the actual work of carrying out the desired action, such as displayContactDetails()
    to show the contact details page.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the front controller around a switch statement makes it quite simple
    to expand the application if necessary. To add another page to the website, all
    we’d have to do is insert another case into the switch statement, write a corresponding
    function in *controllerFunctions.php*, and add a template for displaying the page
    to the *templates* folder. For more complex websites, we could break things up
    even further by having different collections of functions for different types
    of website actions. For example, manager actions could be in a file named *managerFunctions.php*,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Display Functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now we’ll write simple functions to display the three basic pages. Create *src/controllerFunctions.php*
    containing the code in [Listing 13-10](#lis13-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-10: The functions to display the three basic pages'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the functions uses a require_once statement to read in and display the
    contents of the corresponding template file. (We’ll make those template files
    next.) For example, the displayHomePage() function reads in and displays the *templates/homepage.php*
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Page Templates
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll now create the templates for the application’s various pages, starting
    with the project’s home page in *templates/homePage.php*. Create the file as shown
    in [Listing 13-11](#lis13-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-11: The homePage.php template'
  prefs: []
  type: TYPE_NORMAL
- en: After linking to the Bootstrap stylesheet, we create a navigation bar at the
    top of the page by using an unordered list with the Bootstrap nav and nav-pills
    styles ❶. Each list item, styled with the nav-item class, contains a link to one
    of the three pages. Each link is styled with the nav-link class. The link for
    the currently displayed page (home) is also styled with the active class so it
    will be highlighted ❷. Notice that we include an action query-string variable
    in the hyperlinks for the Contact Us and Inquiry Form pages. The hyperlink for
    the home page is simply a forward slash (/). We could have used /index.php instead,
    but since the *index.php* script loads by default, this isn’t necessary.
  prefs: []
  type: TYPE_NORMAL
- en: We can now copy our home-page script and alter its code to create the contact
    details page in *templates/contactUs.php*, as shown in [Listing 13-12](#lis13-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-12: The contactUs.php template'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve kept the boilerplate HTML at the start of the file the same, except for
    changing the page title and styling the Contact Us page link in the navigation
    bar as active instead of the home-page link. Then we’ve filled in some contact
    information for the body of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll write the code for the inquiry form. Once again, start by copying
    one of your other templates into a new *templates/inquiryForm.php* file. Then
    change the page title and set the Inquiry Form link in the navigation bar to active.
    Use the HTML code in [Listing 13-13](#lis13-13) to create the inquiry form itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-13: The inquiryForm.php template'
  prefs: []
  type: TYPE_NORMAL
- en: We make the Submit an Inquiry link active in the navigation bar ❶. We declare
    the form with the POST method and define its action as /index.php?action=processForm
    ❷, so when the form is submitted, it will pass an action query-string variable
    with the value processForm. The rest of the HTML adds form inputs for a customer
    name, an email address, and the text of an inquiry (as a textarea input), plus
    a Submit button, all decorated with more Bootstrap CSS classes.
  prefs: []
  type: TYPE_NORMAL
- en: Confirming Receipt of Valid Form Data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If the user enters valid data (we’ll just test for non-empty form fields for
    this project), we’ll display a confirmation page stating that the inquiry has
    been received and echoing the submitted values back to the user. One simple way
    to do this is to present a similar form prefilled with the submitted values, with
    each field set to disabled so the user can’t edit the information and attempt
    to resubmit it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-4](#fig13-4) shows an inquiry form complete with valid values (left)
    and the corresponding read-only confirmation form page (right). Users will understand
    that the page is read-only because the boxes are grayed out, there isn’t a Submit
    button, and nothing happens when they click the mouse cursor in the fields.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure13-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: Comparing the form submission and confirmation pages'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the content in [Listing 13-14](#lis13-14) into a new template file called
    *templates/confirmData.php* to create the valid form confirmation. Much of the
    code can be copied from the inquiry form script *inquiryForm.php*. You’ll also
    need to add our standard HTML head and navigation bar at the beginning of the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-14: The confirmData.php template'
  prefs: []
  type: TYPE_NORMAL
- en: We use the PHP short echo tag to insert the value of the $customerName variable
    into the customerName input field, setting the field to disabled so it can’t be
    edited ❶. We use the same mechanism to show the received $customerEmail and $inquiry
    values. We don’t need to add a <form> element or a Submit button to this template
    page; we’re just echoing the data back to the user, so this isn’t an interactive
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Processing the Submitted Data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s now write the processForm() function to receive the form data submitted
    with the POST request and decide what to do depending on whether the data is valid.
    Add the function shown in [Listing 13-15](#lis13-15) to the end of the *src/controllerFunctions.php*
    file (although it doesn’t actually matter in what order functions are declared
    in files like this).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-15: A function to process the form data'
  prefs: []
  type: TYPE_NORMAL
- en: First, we use three filter_input() calls ❶ to attempt to extract the received
    POST form data for the three expected values. Notice that for the two strings
    (name and inquiry), we use a FILTER_SANITIZE_SPECIAL_CHAR filter as the third
    function argument, and we use FILTER_SANITIZE_EMAIL for the customer email input.
    These filters remove any unsafe characters submitted through the form, protecting
    against cross-site scripting (XSS) attacks, where JavaScript code is submitted
    through forms to attempt to gain entry to website data.
  prefs: []
  type: TYPE_NORMAL
- en: We next implement the array-based approach to data validation discussed in [Chapter
    12](chapter12.xhtml). We declare $errors as an empty array ❷, then use three if
    statements to test whether any of the received form variables are empty, adding
    an appropriate error message to the array if necessary. Finally, we test the size
    of the $errors array ❸, and if any errors have been found, we display the file
    *templates/displayError.php* (which we’ll create next). Otherwise, if the submitted
    data is all valid, we invoke the confirmData() function, passing $customerName,
    $customerEmail, and $inquiry as arguments. [Listing 13-16](#lis13-16) shows the
    code for this function. Enter the code at the end of *src/controllerFunctions.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-16: A function confirming valid data to the user'
  prefs: []
  type: TYPE_NORMAL
- en: This function reads in and executes the *templates/confirmData.php* file. As
    before, the function must take in the variables needed within the template script
    as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Error Page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As a final step, we need to create the template file for a page displaying any
    error messages to the user. [Figure 13-5](#fig13-5) shows this error page when
    all three validation checks have failed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure13-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: The error page'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called *templates/displayError.php* containing the error output
    script shown in [Listing 13-17](#lis13-17). Once again, you’ll have to also add
    the standard HTML head and navigation bar code to the start of the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-17: A displayError.php template'
  prefs: []
  type: TYPE_NORMAL
- en: 'We set the CSS style of the page’s main <div> to the Bootstrap classes "alert
    alert-danger" ❶, a typical website error style with a pink background. Then we
    use a foreach loop with alternative syntax to cycle through each message in the
    $errors array ❷ and display it as a list item ❸.  ### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ve worked toward a well-organized and extensible web application
    architecture, which we’ve applied to a multipage website featuring both static
    pages and a web form. The architecture hinges on a single *public/index.php* front-controller
    script, which at its core is a straightforward switch statement deciding what
    to do based on the action query-string variable sent with each incoming HTTP request.
    We’ve delegated other, more granular logic to custom functions, which we’ve safely
    declared outside the *public* folder in *src/controllerFunctions.php*. Meanwhile,
    all the scripts that output HTML content to the user are located in the *templates*
    folder. These scripts harness Bootstrap CSS to achieve professional-looking formatting
    with minimal code.
  prefs: []
  type: TYPE_NORMAL
- en: Although this project has many more pages and features than the previous form-processing
    projects from the last few chapters, none of our scripts or functions are complex
    or long-winded, demonstrating that the architecture we’ve adopted is suitable
    for more sophisticated websites, while still being readily understandable and
    easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Create a website containing four simple page templates (no forms): a home
    page (*home.php*), an about page (*about.php*), a contact details page (*contact.php*),
    and a customer recommendations page (*recommendations.php*). These pages should
    be accessed from the index page through the value of the action query-string parameter,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Structure your project by using the front-controller architecture demonstrated
    in this chapter and the functions declared in *src/controllerFunctions.php*. You
    should have the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 2.   Using the front-controller architecture from this chapter, create a new
    website with a home-page template (*home.php*), containing a link to a staff login
    page. The staff login page template (*loginStaff.php*) should display a standard
    username/password login form. The values for a successful staff login are the
    username author and the password words. If correct values are entered, display
    a staff login success page (*successStaff.php*), but if the received username
    and password don’t match the correct ones, display a login error page (*loginError.php*).
    The error page should contain a link back to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The website pages should be accessed from the index page through the value
    of the action query-string parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 3.   Copy and extend your solution for Exercise 2, adding a second login page
    for clients (*loginClient.php*), with a link to this page also offered on the
    home page. Values for the client login are the username customer and the password
    paying. If correct client login values are received, display a client login success
    page (*successClient.php*), but if the values are invalid, display the login error
    page (*loginError.php*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The website pages should be accessed from the index page through the value
    of the action query-string parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 4.   Copy and extend your solution for Exercise 3, placing the staff and client
    login forms into the home page. The home page should contain welcome text and
    two login forms, one for staff and one for clients.
  prefs: []
  type: TYPE_NORMAL
- en: '5.   Copy and extend your solution for Exercise 4, now offering a single login
    form on the home page, but two Submit buttons: one for staff and one for clients.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: See [Chapter 11](chapter11.xhtml) to review how to detect which of the
    two Submit buttons has been clicked.'
  prefs: []
  type: TYPE_NORMAL
