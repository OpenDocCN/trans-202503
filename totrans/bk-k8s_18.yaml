- en: '16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CONFIGURATION AND SECRETS
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Any high-quality application is designed so that key configuration items can
    be injected at runtime rather than being embedded in the source code. When we
    move our application components to containers, we need a way to tell the container
    runtime what configuration information to inject to ensure that our application
    components behave the way they should.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes provides two primary resource types for injecting this configuration
    information: ConfigMap and Secret. These two resources are very similar in capability
    but have slightly different use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we looked at container runtimes in [Part I](part01.xhtml#part01), we saw
    that we could pass environment variables to our containers. Of course, as Kubernetes
    manages the container runtime for us, we’ll first need to pass that information
    to Kubernetes, which will then pass it to the container runtime for us.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The example repository for this book is at* [https://github.com/book-of-kubernetes/examples](https://github.com/book-of-kubernetes/examples).
    *See “Running Examples” on [page xx](ch00.xhtml#ch00lev1sec2) for details on getting
    set up.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For simple configuration injection, we can provide environment variables directly
    from the Pod specification. We saw an example of this in Pod form when we created
    a PostgreSQL server in [Chapter 10](ch10.xhtml#ch10). Here’s a PostgreSQL Deployment
    with a similar configuration in its embedded Pod specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '*pgsql.yaml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When we provide environment variables directly in the Deployment, those environment
    variables are stored directly in the YAML file and in the cluster’s configuration
    for that Deployment. There are two important problems with embedding environment
    variables in this manner. First, we’re reducing flexibility because we can’t specify
    a new value for the environment variable without changing the Deployment YAML
    file. Second, the password is visible in plaintext directly in the Deployment
    YAML file. YAML files are often checked in to source control, so we’re going to
    have a hard time adequately protecting the password.
  prefs: []
  type: TYPE_NORMAL
- en: '**GITOPS**'
  prefs: []
  type: TYPE_NORMAL
- en: The reason that the YAML files that define Kubernetes resources are often checked
    in to source control is that this is by far the best way to manage an application
    deployment. GitOps is a best practice by which all configuration is kept in a
    Git repository. This includes the cluster configuration, additional infrastructure
    components including load balancers, ingress controller, and storage plug-ins,
    as well as all of the information to build, assemble, and deploy applications.
    GitOps provides a log of changes to the cluster configuration, avoids configuration
    drift that can occur over time, and ensures consistency between development, test,
    and production environments. Not only that, but GitOps tools like FluxCD and ArgoCD
    can be used to watch changes to a Git repository and automatically pull the latest
    configuration to update a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first look at moving the configuration out of the Deployment; then we’ll
    consider how best to protect the password.
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing Configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Embedding configuration in the Deployment makes the resource definition less
    reusable. If, for example, we wanted to deploy a PostgreSQL server for both test
    and production versions of our application, it would be useful to reuse the same
    Deployment to avoid duplication and to avoid configuration drift between the two
    versions. However, for security, we would not want to use the same password in
    both environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s better if we externalize the configuration by storing it in a separate
    resource and referring to it from the Deployment. To enable this, Kubernetes offers
    the *ConfigMap* resource. A ConfigMap specifies a set of key–value pairs that
    can be referenced when specifying a Pod. For example, we can define our PostgreSQL
    configuration this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '*pgsql-cm.yaml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By storing this configuration information in a ConfigMap, it is no longer directly
    part of the Deployment YAML file or the cluster configuration for the Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: After we’ve defined our ConfigMap, we can reference it in our Deployment, as
    demonstrated in [Listing 16-1](ch16.xhtml#ch16list1).
  prefs: []
  type: TYPE_NORMAL
- en: '*pgsql-ext-cfg.yaml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-1: PostgreSQL with ConfigMap*'
  prefs: []
  type: TYPE_NORMAL
- en: In place of the `env` field, we have an `envFrom` field that specifies one or
    more ConfigMaps to serve as environment variables for the container. All of the
    key–value pairs in the ConfigMap will become environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: This has the same effect as specifying one or more environment variables directly
    in the Deployment, but our Deployment specification is now reusable. The Deployment
    will look for the identified ConfigMap in its own Namespace, so we can have multiple
    Deployments from the same specification in separate Namespaces, and each can be
    configured differently.
  prefs: []
  type: TYPE_NORMAL
- en: This use of Namespace isolation to prevent naming conflicts, together with the
    Namespace-scoped security controls we saw in [Chapter 11](ch11.xhtml#ch11) and
    the Namespace-scoped quotas we saw in [Chapter 14](ch14.xhtml#ch14), allows a
    single cluster to be used for many different purposes, by many different groups,
    a concept known as *multitenancy*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create this Deployment and see how Kubernetes injects the configuration.
    First, let’s create the actual Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command completes successfully because the Deployment has been created
    in the cluster, but Kubernetes will not be able to start any Pods because the
    ConfigMap is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now create the ConfigMap, we see that the Pod is then created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It can take a minute or so for Kubernetes to determine that the ConfigMap is
    available and start the Pod. As soon as the Pod is running, we can verify that
    the environment variables were injected based on the data in the ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The command `env` prints out all of the environment variables associated with
    a process. Because Kubernetes provides the same environment variables to our `/bin/sh`
    process as it provided to our main PostgreSQL process, we know that the environment
    variable was set as expected. It’s important to note, however, that even though
    we can change the ConfigMap at any time, doing so will not cause the Deployment
    to update its Pods; the application will not automatically pick up any environment
    variable changes. Instead, we need to apply some configuration change to the Deployment
    to cause it to create new Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Although the configuration has been externalized, we still are not protecting
    it. Let’s do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting Secrets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When protecting secrets, thinking through the nature of the protection that
    makes sense is important. For example, we might need to protect authentication
    information that our application uses to connect to a database. However, given
    that the application itself needs that information to make the connection, anyone
    who can inspect the inner details of the application is going to be able to extract
    those credentials.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 11](ch11.xhtml#ch11), Kubernetes provides fine-grained
    access control over each individual resource type in a given Namespace. To enable
    protection of secrets, Kubernetes provides a separate resource type, *Secret*.
    This way, access to secrets can be limited to only those users who require access,
    a principle known as *least privilege*.
  prefs: []
  type: TYPE_NORMAL
- en: One more advantage to the Secret resource type is that it uses base64 encoding
    for all of its data, with automatic decoding when the data is provided to the
    Pod, which simplifies the storage of binary data.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENCRYPTING SECRET DATA**'
  prefs: []
  type: TYPE_NORMAL
- en: By default, data stored in a Secret is base64 encoded but is not encrypted.
    It is possible to encrypt secret data, and doing so is good practice for a production
    cluster, but remember that the data must be decrypted so that it can be provided
    to the Pod. For this reason, anyone who can control what Pods exist in a namespace
    can access secret data, as can any cluster administrators who can access the underlying
    container runtime. This is true even if the secret data is encrypted when stored.
    Proper access controls are essential to keep a cluster secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Secret definition looks almost identical to a ConfigMap definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*pgsql-secret.yaml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The one obvious difference is the resource type of Secret rather than ConfigMap.
    However, there is a subtle difference as well. When we define this Secret, we
    place the key–value pairs in a field called `stringData` rather than just `data`.
    This tells Kubernetes that we are providing unencoded strings. When it creates
    the Secret, Kubernetes will encode the strings for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though we specified the data using the field `stringData` and an unencoded
    string, the actual Secret uses the field `data` and stores the value using base64
    encoding. We can also do the base64 encoding ourselves. In that case, we place
    the value directly into the `data` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '*pgsql-secret-2.yaml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This approach is necessary to define binary content for the Secret in order
    for us to be able to supply that binary content as part of a YAML resource definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a Secret in a Deployment definition in exactly the same way we use a
    ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '*pgsql-ext-sec.yaml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The only change is the use of `secretRef` in place of `configMapRef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, let’s apply this new Deployment configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From the perspective of our Pod, the behavior is exactly the same. Kubernetes
    handles the base64 decoding, making the decoded value visible to our Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As before, we use the `env` command to show that the `POSTGRES_PASSWORD` environment
    variable was set as expected. The Pod sees the same behavior whether we specify
    the environment variable directly or use a ConfigMap or Secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let’s delete this Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using ConfigMaps and Secrets, we have the ability to externalize environment
    variable configuration for our application so that our Deployment specification
    can be reusable and to facilitate fine-grained access control over secret data.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, environment variables are not the only way we commonly configure
    applications. We also need a way to provide configuration files. We can do that
    using the same ConfigMap and Secret resources we’ve seen already.
  prefs: []
  type: TYPE_NORMAL
- en: Any files we inject in this way override files that exist in the container image,
    which means that we can supply the container image with a sensible default configuration
    and then override that configuration with each container we run. This makes it
    much easier to reuse container images.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to specify file content in a ConfigMap and then mount it in a container
    is immediately useful for configuration files, but we can also use it to update
    the NGINX web server example we showed in [Chapter 15](ch15.xhtml#ch15). As we’ll
    see, with this version we can declare our HTML content solely using Kubernetes
    resource YAML files, with no need for console commands to copy content into a
    PersistentVolume.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to define a ConfigMap with the HTML content we want to serve:'
  prefs: []
  type: TYPE_NORMAL
- en: '*nginx-cm.yaml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The key part of the key–value pair is used to specify the desired filename,
    in this case *index.html*. For ease of reading, we use a pipe character (`|`)
    to start a YAML multiline string. This string continues as long as the following
    lines are indented, or until the end of the YAML file. We can define multiple
    files in this way by just adding more keys to the ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Deployment we saw in [Listing 16-1](ch16.xhtml#ch16list1), we specified
    the ConfigMap as the source of environment variables. Here, we specify it as the
    source of a volume mount:'
  prefs: []
  type: TYPE_NORMAL
- en: '*nginx-deploy.yaml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This volume definition looks similar to the one we saw in [Chapter 15](ch15.xhtml#ch15).
    As before, the volume specification comes in two parts. The `volume` field specifies
    where the volume comes from, in this case the ConfigMap. The `volumeMounts` allows
    us to specify the path in the container where the files should be made available.
    In addition to making it possible to use the same volume in multiple containers
    in a Pod, this also means that we can share the same syntax when mounting persistent
    volumes and when mounting the configuration as files in the container filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the ConfigMap and then get this Deployment started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After the Pod is running, we can see that the file content is as expected,
    and NGINX is serving our HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output looks similar to what we saw in [Chapter 15](ch15.xhtml#ch15) when
    we provided the HTML content as a PersistentVolume, but we were able to avoid
    the effort of attaching the PersistentVolume and then copying content into it.
    In practice, both approaches have value, as maintaining a ConfigMap with a large
    amount of data would be unwieldy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the contents of the ConfigMap appear as files in a directory, Kubernetes
    is writing out the contents of the ConfigMap to the host filesystem and then mounting
    the directory from the host into the container. This means that the specific directory
    shows up as part of the output for the `mount` command inside the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `mount` command reports that the directory */usr/share/nginx/html* is a
    separately mounted path coming from the host’s primary disk */dev/sda1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re finished with the NGINX Deployment, so go ahead and delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s look at how ConfigMap and Secret information is stored in a typical
    Kubernetes cluster so that we can see where `kubelet` is getting this content.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster Configuration Repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it’s possible to run a Kubernetes cluster with different choices of
    configuration repository, most Kubernetes clusters use `etcd` as the backing store
    for all cluster configuration data. This includes not only the ConfigMap and Secret
    storage but also all of the other cluster resources and the current cluster state.
    Kubernetes also uses `etcd` to elect a leader when running in a highly available
    configuration with multiple API servers.
  prefs: []
  type: TYPE_NORMAL
- en: Although `etcd` is generally stable and reliable, node failures can lead to
    cases in which the `etcd` cluster can’t reestablish itself and elect a leader.
    Our purpose in demonstrating `etcd` is not just to see how configuration data
    is stored, but also to provide some valuable background into an essential cluster
    component that an administrator might need to debug.
  prefs: []
  type: TYPE_NORMAL
- en: For all of our example clusters, `etcd` is installed on the same nodes as the
    API server, which is common in smaller clusters. In large clusters, running `etcd`
    on separate nodes to allow it to scale separately from the Kubernetes control
    plane is common.
  prefs: []
  type: TYPE_NORMAL
- en: To explore the contents of the `etcd` backing store, we’ll use `etcdctl`, a
    command line client designed for controlling and troubleshooting `etcd`.
  prefs: []
  type: TYPE_NORMAL
- en: Using etcdctl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We need to tell `etcdctl` where our `etcd` server instance is located and how
    to authenticate to it. For authentication, we’ll use the same client certificate
    that the API server uses.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, we can set environment variables that `etcdctl` will read,
    so we don’t need to pass in those values via the command line with every command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the environment variables we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '*etcd-env*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'These variables configure `etcdctl` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ETCDCTL_API Use version 3 of the `etcd` API. With recent versions of `etcd`,
    only version 3 is supported.
  prefs: []
  type: TYPE_NORMAL
- en: ETCDCTL_CACERT Verify the `etcd` host using the provided certificate authority.
  prefs: []
  type: TYPE_NORMAL
- en: ETCDCTL_CERT Authenticate to `etcd` using this certificate.
  prefs: []
  type: TYPE_NORMAL
- en: ETCDCTL_KEY Authenticate to `etcd` using this private key.
  prefs: []
  type: TYPE_NORMAL
- en: ETCDCTL_ENDPOINTS Connect to `etcd` at this URL. While `etcd` is running on
    all three nodes, we only need one node to talk to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, these environment variables are conveniently stored in a script
    in */opt* so that we can load them for use with upcoming commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use `etcdctl` commands to inspect the cluster and the configuration
    data it’s storing. Let’s begin by listing only the cluster members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As expected, each of the control plane nodes has an instance of `etcd`. For
    a highly available configuration, we need to run at least three instances, and
    we need a majority of those instances to be running for the cluster to be healthy.
    This `etcdctl` command is a good first step to determine whether the cluster has
    any failed nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as the cluster is healthy, we can store and retrieve data. Within `etcd`,
    information is stored in key–value pairs. Keys are specified as paths in a hierarchy.
    We can list the paths that have content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `--prefix` flag tells `etcdctl` to get all keys that start with `/`, whereas
    `--keys-only` ensures that we print only the keys to prevent being overwhelmed
    with data. Still, a lot of information is returned, including all of the various
    Kubernetes resource types that we’ve described in this book. Also included are
    the ConfigMaps and Secrets we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Deciphering Data in etcd
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can generally rely on Kubernetes to store the correct configuration data
    in `etcd`, and we can rely on `kubectl` to see the current cluster configuration.
    However, it is useful to know how the underlying data store works in case we need
    to inspect the configuration when the cluster is down or in an anomalous state.
  prefs: []
  type: TYPE_NORMAL
- en: To save storage space and bandwidth, both `etcd` and Kubernetes use the `protobuf`
    library, a language-neutral binary data format. Because we’re using `etcdctl`
    to retrieve data from `etcd`, we can ask it to return data in JSON format, instead;
    however, that JSON data will include an embedded `protobuf` structure with the
    data from Kubernetes, so we’ll need to decode that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by examining the JSON format for a Kubernetes Secret in `etcd`.
    We’ll send the output through `jq` for formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `kvs` field has the key–value pair that Kubernetes stored for this Secret.
    The value for the key is a simple base64-encoded string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We use `jq` to extract just the key’s value and return it in raw format (without
    quotes), and then we use `base64` to decode the string.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the interesting part of this key–value pair is the value because
    it contains the actual Kubernetes Secret. Although the value is also base64 encoded,
    we need to do a bit more detangling to access its information.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we decode the base 64 value, we’ll have a `protobuf` message. However,
    it has a magic prefix that Kubernetes uses to allow for future changes in the
    storage format. We can see that prefix if we look at the first few bytes of the
    decoded value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We use `head` to retrieve the first 10 bytes of the decoded value and then use
    `xxd` to see a hex dump. The first few bytes are `k8s` followed by an ASCII null
    character. The rest of the data, starting with byte 5, is the actual `protobuf`
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run one more command to actually decode the `protobuf` message using
    the `protoc` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `protoc` tool is mostly used for generating source code to read and write
    `protobuf` messages, but it’s also handy for message decoding. As we can see,
    within the `protobuf` message is all of the data Kubernetes stores for this Secret,
    including the resource version and type, the resource name and namespace, and
    the data. This illustrates, as mentioned earlier, that access to the hosts on
    which Kubernetes runs provides access to all of the secret data in the cluster.
    Even if we configured Kubernetes to encrypt data before storing it in `etcd`,
    the encryption keys themselves need to be stored unencrypted in `etcd` so that
    the API server can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the ability to provide either environment variables or files to Pods, ConfigMaps
    and Secrets allow us to externalize the configuration of our containers, which
    makes it possible to reuse both Kubernetes resource definitions such as Deployments
    and container images in a variety of applications.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we need to be aware of how Kubernetes stores this configuration
    data and how it provides it to containers. Anyone with the right role can access
    configuration data using `kubectl`; anyone with access to the host running the
    container can access it from the container runtime; and anyone with the right
    authentication information can access it directly from `etcd`. For a production
    cluster, it’s critical that all of these mechanisms are correctly secured.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve seen how Kubernetes stores built-in cluster resource data in `etcd`,
    but Kubernetes can also store any kind of custom resource data we might choose
    to declare. In the next chapter, we’ll explore how custom resource definitions
    enable us to add new behavior to a Kubernetes cluster in the form of operators.
  prefs: []
  type: TYPE_NORMAL
