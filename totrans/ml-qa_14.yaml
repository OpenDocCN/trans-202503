- en: '**12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FULLY CONNECTED AND CONVOLUTIONAL LAYERS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Under which circumstances can we replace fully connected layers with convolutional
    layers to perform the same computation?
  prefs: []
  type: TYPE_NORMAL
- en: Replacing fully connected layers with convolutional layers can offer advantages
    in terms of hardware optimization, such as by utilizing specialized hardware accelerators
    for convolution operations. This can be particularly relevant for edge devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are exactly two scenarios in which fully connected layers and convolutional
    layers are equivalent: when the size of the convolutional filter is equal to the
    size of the receptive field and when the size of the convolutional filter is 1\.
    As an illustration of these two scenarios, consider a fully connected layer with
    two input and four output units, as shown in [Figure 12-1](ch12.xhtml#ch12fig1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/12fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Four inputs and two outputs connected via eight weight parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fully connected layer in this figure consists of eight weights and two
    bias units. We can compute the output nodes via the following dot products:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node 1** *w*[1,1] *× x*[1] + *w*[1,2] *× x*[2] + *w*[1,3] *× x*[3] + *w*[1,4]
    *× x*[4] + *b*[1]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node 2** *w*[2,1] *× x*[1] + *w*[2,2] *× x*[2] + *w*[2,3] *× x*[3] + *w*[2,4]
    *× x*[4] + *b*[2]'
  prefs: []
  type: TYPE_NORMAL
- en: The following two sections illustrate scenarios in which convolutional layers
    can be defined to produce exactly the same computation as the fully connected
    layer described.
  prefs: []
  type: TYPE_NORMAL
- en: '**When the Kernel and Input Sizes Are Equal**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with the first scenario, where the size of the convolutional filter
    is equal to the size of the receptive field. Recall from [Chapter 11](ch11.xhtml)
    how we compute a number of parameters in a convolutional kernel with one input
    channel and multiple output channels. We have a kernel size of 2*×*2, one input
    channel, and two output channels. The input size is also 2*×*2, a reshaped version
    of the four inputs depicted in [Figure 12-2](ch12.xhtml#ch12fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/12fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: A convolutional layer with a 2×2 kernel that equals the input
    size and two output channels*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the convolutional kernel dimensions equal the input size, as depicted in
    [Figure 12-2](ch12.xhtml#ch12fig2), there is no sliding window mechanism in the
    convolutional layer. For the first output channel, we have the following set of
    weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0076-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the second output channel, we have the following set of weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0076-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the inputs are organized as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0077-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'we calculate the first output channel as *o*[1] = *∑i*(*W*[1] ***x**)*[i]*
    + *b*[1], where the convolutional operator * is equal to an element-wise multiplication.
    In other words, we perform an element-wise multiplication between two matrices,
    *W*[1] and **x**, and then compute the output as the sum over these elements;
    this equals the dot product in the fully connected layer. Lastly, we add the bias
    unit. The computation for the second output channel works analogously: *o*[2]
    = *∑i*(*W*[2] * **x**)*[i]* + *b*[2].'
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, the supplementary materials for this book include PyTorch code to
    show this equivalence with a hands-on example in the *supplementary/q12-fc-cnn-equivalence*
    subfolder at *[https://github.com/rasbt/MachineLearning-QandAI-book](https://github.com/rasbt/MachineLearning-QandAI-book)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**When the Kernel Size Is 1**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second scenario assumes that we reshape the input into an input “image”
    with 1*×*1 dimensions where the number of “color channels” equals the number of
    input features, as depicted in [Figure 12-3](ch12.xhtml#ch12fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/12fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The number of output nodes equals the number of channels if the
    kernel size is equal to the input size.*'
  prefs: []
  type: TYPE_NORMAL
- en: Each kernel consists of a stack of weights equal to the number of input channels.
    For instance, for the first output layer, the weights are
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0077-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'while the weights for the second channel are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0077-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To get a better intuitive understanding of this computation, check out the illustrations
    in [Chapter 11](ch11.xhtml), which describe how to compute the parameters in a
    convolutional layer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Recommendations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fact that fully connected layers can be implemented as equivalent convolutional
    layers does not have immediate performance or other advantages on standard computers.
    However, replacing fully connected layers with convolutional layers can offer
    advantages in combination with developing specialized hardware accelerators for
    convolution operations.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, understanding the scenarios where fully connected layers are equivalent
    to convolutional layers aids in understanding the mechanics of these layers. It
    also lets us implement convolutional neural networks without any use of fully
    connected layers, if desired, to simplify code implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**12-1.** How would increasing the stride affect the equivalence discussed
    in this chapter?'
  prefs: []
  type: TYPE_NORMAL
- en: '**12-2.** Does padding affect the equivalence between fully connected layers
    and convolutional layers?'
  prefs: []
  type: TYPE_NORMAL
