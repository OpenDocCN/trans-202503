<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="247" id="Page_247"/>11</span><br/>
<span class="ChapterTitle">AssemblyScript</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="190" height="190"/>
</figure>
<p class="ChapterIntro">AssemblyScript is a high-level language explicitly designed to compile to WebAssembly or WAT. AssemblyScript is more expressive than WAT but can compile to it. When you use AssemblyScript, you lose some of the fine optimization control that you have with WAT, but it’s much faster to write. </p>
<p>We’ll begin this chapter by creating a simple <code>AddInt</code><code>s</code> function, like the <code>AddInt</code> one we created in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>. We’ll write an AssemblyScript hello world app and compile it into WAT to see the WebAssembly that the AssemblyScript compiler generates. We’ll examine AssemblyScript’s use of length-prefixed strings, and then install the AssemblyScript loader to see how it can make it easier to transfer strings between AssemblyScript and JavaScript. We’ll pass strings into AssemblyScript by writing a string concatenation app. We’ll also explore OOP in AssemblyScript. We’ll create a couple of classes to demonstrate class inheritance and discuss <code>private</code> attributes that prevent AssemblyScript from exporting attributes to the <span epub:type="pagebreak" title="248" id="Page_248"/>embedding environment. Next, we’ll write JavaScript that allows us to create <code>public</code>, <code>private</code>, and <code>protected</code><code> </code>members directly, as well as use the AssemblyScript loader. Then we’ll compare the performance of direct and loader function calls.</p>
<p>The AssemblyScript team designed it to be similar to TypeScript and JavaScript. Unlike WAT, AssemblyScript is a high-level language with features such as classes, strings, and arrays. Along with high-level features, AssemblyScript allows users to code with low-level WAT-like memory commands. AssemblyScript has a <em>Command Line Interface (CLI)</em> that can compile AssemblyScript into a WebAssembly module for use from within JavaScript applications.</p>
<p>For JavaScript developers interested in using WebAssembly to improve the performance of their JavaScript applications, AssemblyScript is a great tool. Unfortunately, as with everything in WebAssembly, merely tweaking your TypeScript until it compiles with the AssemblyScript compiler might not result in a considerable performance boost. Understanding what AssemblyScript does under the hood allows you to write code in a language that looks like JavaScript but runs like C++. To gain this understanding, we’ll compile AssemblyScript code to WAT to explore the AssemblyScript compiler’s output.</p>
<h2 id="h1-501737c11-0001">AssemblyScript CLI</h2>
<p class="BodyFirst">Install AssemblyScript using the following command:</p>
<pre><code>npm install assemblyscript -g</code></pre>
<p>The <code>npm</code> command installs AssemblyScript globally, which allows you to use the AssemblyScript compiler <code>asc</code> command from the command line. Running <code>asc -h</code> provides a list of compiler command examples and options.</p>
<p>I won’t explain all the command line arguments but will mention a few that are useful. The <code>-O</code> option optimizes in the same way as <code>wasm-opt</code> in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>. You follow <code>-O</code> with a number 0 to 3, s, or z, instructing the compiler to optimize for size or performance and how much optimization to apply. The <code>-o</code> flag when followed by the name of a <em>.wat </em>file will generate WAT code from the AssemblyScript, and when followed by the name of a <em>.wasm </em>file will generate a binary WebAssembly module. The <code>--sourceMap</code> flag creates a source map file to help you debug your AssemblyScript from the browser. </p>
<p>We’ll first create a simple AssemblyScript module. Create the file <em>as_add.ts</em> and add the code in <a href="#listing11-1" id="listinganchor11-1">Listing 11-1</a>. This is a much simpler version of the <code>AddInt</code> function in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>.</p>
<p class="CodeLabel"><b>as_add.ts</b></p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> export function AddInts(<span class="CodeAnnotationHang" aria-label="annotation2">2</span>a: i32, <span class="CodeAnnotationHang" aria-label="annotation3">3</span>b: i32 ): i32 {
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> return a + b;
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-1">Listing 11-1</a>: Adding two integers</p>
<p><span epub:type="pagebreak" title="249" id="Page_249"/>We make the <code>function</code> available to the embedding JavaScript using the <code>export</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> keyword. It takes two <code>i32</code> parameters <code>a</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and <code>b</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, and returns <code>a + b</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> as an <code>i32</code>. Compile <em>as_add.ts</em> using the command in <a href="#listing11-2" id="listinganchor11-2">Listing 11-2</a>.</p>
<pre><code>asc as_add.ts -Oz -o as_add.wat</code></pre>
<p class="CodeListingCaption"><a id="listing11-2">Listing 11-2</a>: Compiling <code>AddInt</code><code>s</code> to WAT</p>
<p>The <code>-Oz</code> flag makes the size of the output binary as small as possible. The final flag, <code>-o</code><code> as_add.wat</code>, tells the compiler to output WAT. Alternatively, we could have compiled a <em>.wasm</em> file, such as <em>as_add.wasm</em>, which would output a WebAssembly binary. When we look at the <em>as_add.wat</em> file that is output, we see the WAT code in <a href="#listing11-3" id="listinganchor11-3">Listing 11-3</a>.</p>
<p class="CodeLabel"><b>as_add.wat</b></p>
<pre><code>(module
  (type $i32_i32_=&gt;_i32 (func (param i32 i32) (result i32)))
  (memory $0 0)
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (export "AddInts" (func $as_add/AddInts))
  (export "memory" (memory $0))
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (func $as_add/AddInts (param $0 i32) (param $1 i32) (result i32)
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> local.get $0
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> local.get $1
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> i32.add
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing11-3">Listing 11-3</a>: AssemblyScript <code>AddInts</code> function compiled to WAT</p>
<p>Writing code in AssemblyScript is much easier than writing code directly in WAT. This code produces the <code>AddInts</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function that exports a function <span class="CodeAnnotation" aria-label="annotation2">2</span> that takes two <code>i32</code> parameters and returns an <code>i32</code>. The output function uses a <code>local.get</code> to retrieve the first <span class="CodeAnnotation" aria-label="annotation3">3</span> and second <span class="CodeAnnotation" aria-label="annotation4">4</span> parameters, and uses an <code>i32.add</code><code> </code><span class="CodeAnnotation" aria-label="annotation5">5</span> to add those two values. </p>
<p>AssemblyScript is a beautiful little language that is relatively easy to learn for anyone familiar with TypeScript or JavaScript. Understanding WAT is a great way to get the most from your AssemblyScript or whichever high-level language you choose for WebAssembly development. </p>
<h2 id="h1-501737c11-0002">Hello World AssemblyScript</h2>
<p class="BodyFirst">Next, we’ll build an AssemblyScript version of the WAT hello world application from <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. Create a new AssemblyScript file named <em>as_hello.ts</em> and add the code in <a href="#listing11-4" id="listinganchor11-4">Listing 11-4</a>.</p>
<p class="CodeLabel"><b>as_hello.ts</b></p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> declare function console_log( msg: string ):void;

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> export function HelloWorld():void {
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> console_log("hello world!");
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-4">Listing 11-4</a>: A hello world AssemblyScript app</p>
<p><span epub:type="pagebreak" title="250" id="Page_250"/>The function declaration in AssemblyScript must correspond with a JavaScript function passed into the WebAssembly module. So we’ll need to pass in a function through the <code>importObject</code> that logs our string to the console. The <code>declare</code><code> function</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> imports the <code>console_log</code> function from the JavaScript. This function will pass a string from the AssemblyScript back to the calling JavaScript app. We create an <code>export</code><code> function</code> called <code>HelloWorld</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> that calls the imported <code>console_log</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> function, passing in the string <code>"hello world!"</code>. Before we compile this into a WebAssembly module, we’ll use <code>asc</code> to compile a WAT file so we can look at the WebAssembly created (<a href="#listing11-5" id="listinganchor11-5">Listing 11-5</a>).</p>
<pre><code>asc as_hello.ts -Oz -o as_hello.wat</code></pre>
<p class="CodeListingCaption"><a id="listing11-5">Listing 11-5</a>: Compile the <em>as_hello.ts</em> AssemblyScript file into <em>as_hello.wat</em>.</p>
<p>Then we can open <em>as_hello.wat</em> in <a href="#listing11-6" id="listinganchor11-6">Listing 11-6</a> to see the WebAssembly that AssemblyScript generated. </p>
<pre><code><span class="LiteralGray">;; The comments were added by the author and not generated by asc</span> <span class="CodeAnnotationCode" aria-label="annotation1">1</span>
(module
  (type $none_=&gt;_none (func))
  (type $i32_=&gt;_none (func (param i32)))
<span class="LiteralGray">  ;; the declare command at the top of the AssemblyScript created an import</span>
<span class="LiteralGray">  ;; that imports the console_log function inside of the outer as_hello</span>
<span class="LiteralGray">  ;; object.  AssemblyScript requires its imports in the AssemblyScript file name</span>
<span class="LiteralGray">  ;; not including the .ts extension</span>
  (import "as_hello" "console_log" (func $as_hello/console_log (param i32))) <span class="CodeAnnotationCode" aria-label="annotation2">2</span>
<span class="LiteralGray">  ;; using a string automatically creates the memory expression</span>
  (memory $0 1) <span class="CodeAnnotationCode" aria-label="annotation3">3</span>
  <span class="LiteralGray">;; the data line below wraps because the line is too long</span>
<span class="LiteralGray">  ;; The "hello world!" string is preceded by a header and has a hex 00 byte in</span>
<span class="LiteralGray">  ;; between every letter in the string.  This is because AssemblyScript uses</span>
<span class="LiteralGray">  ;; the UTF-16 character set instead of ASCII as we did when we were manipulating</span>
<span class="LiteralGray">  ;; string data in WAT.</span>
  (data (i32.const 16) <span class="CodeAnnotationCode" aria-label="annotation4">4</span>
    "\18\00\00\00\01\00\00\00\01\00\00\00\18\00\00\00h\00e\00l\00l\00o\00 \00w\00o\00r\00l\00d\00!")
  (export "memory" (memory $0))
<span class="LiteralGray">  ;; The module exports our function with the AssemblyScript name we gave it.</span>
  (export "HelloWorld" (func $as_hello/HelloWorld)) <span class="CodeAnnotationCode" aria-label="annotation5">5</span>
<span class="LiteralGray">  ;; the function name we gave AssemblyScript is prefixed by the name of our file</span>
<span class="LiteralGray">  ;; without the .ts extension</span>
  (func $as_hello/HelloWorld (; 1 ;) <span class="CodeAnnotationCode" aria-label="annotation6">6</span>
<span class="LiteralGray">  ;; 32 is the location in linear memory of the 'h' byte in "hello world"</span>
  i32.const 32 <span class="CodeAnnotationCode" aria-label="annotation7">7</span>
<span class="LiteralGray">  ;; the console_log function is called passing in the location of "hello world"</span>
<span class="LiteralGray">  ;; in linear memory</span>
  call $as_hello/console_log <span class="CodeAnnotationCode" aria-label="annotation8">8</span>
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing11-6">Listing 11-6</a>: The <em>as_hello.wat</em> file generated from the <em>as_hello.ts</em> AssemblyScript</p>
<p><span epub:type="pagebreak" title="251" id="Page_251"/>I’ve added comments to clarify the code <span class="CodeAnnotation" aria-label="annotation1">1</span>. This module imports <code>console_log</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> wrapped in the object <code>as_hello</code>, the name of our AssemblyScript file without the <em>.ts</em> extension. This is the naming convention AssemblyScript uses for its <code>importObject</code>; when you write your JavaScript, you must name your object inside the imported object accordingly. </p>
<p>AssemblyScript creates a <code>memory</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> expression to hold the string data. The string has a prefixed header that includes the length of the string, which AssemblyScript uses to manipulate the data from within WebAssembly. The string <code>data</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> uses two bytes per character, and because AssemblyScript uses UTF-16, every character in this example is separated by a null byte <code>\00</code>. UTF-16 is the 16-bit version of the Unicode character set that allows for many additional characters not available in ASCII. </p>
<p>After the data expression, the WAT exports <span class="CodeAnnotation" aria-label="annotation5">5</span> the function with the name we gave it in the AssemblyScript, prefixed with the <code>$</code> character and excluding the <em>.ts</em> extension. The <code>HelloWorld </code><span class="CodeAnnotation" aria-label="annotation6">6</span><code> </code>function calls <code>console_log </code><span class="CodeAnnotation" aria-label="annotation8">8</span>, passing in the location of the first character in our <code>hello world!</code> string in linear memory, which is <code>32</code> <span class="CodeAnnotation" aria-label="annotation7">7</span>. </p>
<p>With our WAT file compiled, we can use the <code>asc</code> command in <a href="#listing11-7" id="listinganchor11-7">Listing 11-7</a> to compile our WebAssembly module.</p>
<pre><code>asc as_hello.ts -Oz -o as_hello.wasm</code></pre>
<p class="CodeListingCaption"><a id="listing11-7">Listing 11-7</a>: Compiling our AssemblyScript to WebAssembly binary</p>
<p>Next, we create our JavaScript.</p>
<h3 id="h2-501737c11-0001">JavaScript for Our Hello World App</h3>
<p class="BodyFirst">Currently, we have a WebAssembly module named <em>as_hello.wasm</em>. Next, we’ll write a Node.js app that will load and run this module. In this section, we’ll decode the string data the way we did in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> to understand how AssemblyScript transfers strings to JavaScript. Then we’ll use the AssemblyScript loader tool to do much of this work for us.</p>
<p>First, we’ll write a function to pull the string out of linear memory using the index passed from the WebAssembly module. AssemblyScript places the length of the string in the four bytes immediately preceding the string data. We can use <code>Uint32Array</code> to obtain the string length integer and use that length to create our string in JavaScript. Create a file named <em>as_hello.js</em> and add the code in <a href="#listing11-8" id="listinganchor11-8">Listing 11-8</a>.</p>
<p class="CodeLabel"><b>as_hello.js</b></p>
<pre><code>const fs = require('fs');
const bytes = fs.readFileSync(__dirname + '/as_hello.wasm');

<span class="LiteralGray">// The memory object is exported from AssemblyScript</span>
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> var memory = null;

let importObject = {</code></pre>
<span class="LiteralGray">  // module's file name without extension is used as the outer object name</span>
<pre><code><span class="CodeAnnotationCode" aria-label="annotation2">2</span> as_hello: {
<span class="LiteralGray">    // AssemblyScript passes a length prefixed string with a simple index</span>
<span epub:type="pagebreak" title="252" id="Page_252"/>  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> console_log: function (index) {
<span class="LiteralGray">      // in case this is called before memory is set</span>
      if (memory == null) {
        console.log('memory buffer is null');
        return;
      }

    <span class="CodeAnnotationCode" aria-label="annotation4">4</span> const len_index = index - 4;

<span class="LiteralGray">      // must divide by 2 to get from bytes to 16-bit unicode characters</span>
    <span class="CodeAnnotationCode" aria-label="annotation5">5</span> const len = new Uint32Array(memory.buffer, len_index, 4)[0];
    <span class="CodeAnnotationCode" aria-label="annotation6">6</span> const str_bytes = new Uint16Array(memory.buffer,
        index, len);

<span class="LiteralGray">      // decode the utf-16 byte array into a JS string</span>
    <span class="CodeAnnotationCode" aria-label="annotation7">7</span> const log_string = new TextDecoder('utf-16').decode(str_bytes);
      console.log(log_string);
    }
  },
  env: {
    abort: () =&gt; { } 
  }
};

(async () =&gt; {
  let obj = await WebAssembly.instantiate(new Uint8Array(bytes),
    importObject);

<span class="LiteralGray">  // memory object exported from AssemblyScript</span>
<span class="CodeAnnotationCode" aria-label="annotation8">8</span> memory = obj.instance.exports.memory;
<span class="LiteralGray">  // call the HelloWorld function</span>
<span class="CodeAnnotationCode" aria-label="annotation9">9</span><span class="LiteralGray"> </span>obj.instance.exports.HelloWorld();
})();</code></pre>
<p class="CodeListingCaption"><a id="listing11-8">Listing 11-8</a>: Calling the AssemblyScript <code>HelloWorld</code> from JavaScript</p>
<p>WebAssembly modules that AssemblyScript generates always create and export their own memory unless they’re compiled with the <code>--importMemory</code> flag. By default, AssemblyScript creates its own linear memory in the WebAssembly module. Therefore, in the JavaScript, we don’t create a linear memory object. Instead, we create a <code>var</code> called <code>memory</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which we’ll later set to the linear memory object that the WebAssembly module exports.</p>
<p>Inside <code>importObject</code>, the object that holds the data for import must have the same name as the AssemblyScript file importing it: <code>as_hello</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> for our AssemblyScript file <em>as_hello.ts</em>. Inside <code>as_hello</code> is <code>console_log</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, which is passed a string parameter when called from the AssemblyScript. When the WebAssembly module calls <code>as_hello</code>, the JavaScript function receives just a single numeric index into WebAssembly linear memory, which is the location of the string data portion of the length prefixed string that AssemblyScript uses to define its string type.</p>
<p>The length is a 32-bit integer in the four bytes that precede the <code>index</code>. To get the index of the length integer, we subtract four from the string index. We use the value for the length located in linear memory by creating <span epub:type="pagebreak" title="253" id="Page_253"/>a new <code>Uint32Array</code>, passing in the <code>memory.buffer</code>, the <code>len_index </code><span class="CodeAnnotation" aria-label="annotation4">4</span>, and a value of <code>4</code> for the number of bytes. Because <code>Uint32Array</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> is an array of 32-bit integers, we need to get the first and only item in the array using <code>[0]</code>.</p>
<p>We retrieve the string byte data from linear memory using <code>new Uint16Array</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> and convert that byte array into a JavaScript string by using a new <code>TextDecoder</code> that decodes for <code>utf-16</code> text data. The code calls the <code>TextDecoder</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> <code>decode </code>function, passing in the string data, which returns a JavaScript string we then log to the console. We use an IIFE to instantiate the AssemblyScript WebAssembly module. Note that we must set the <code>memory</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> object to the memory object exported from the WebAssembly module before calling the <code>HelloWorld</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> function. The <code>console_log</code> function uses the <code>memory</code> object, and if it isn’t set, calling <code>HelloWorld</code> will do nothing.</p>
<p>Fortunately, there is an easier way to move string data between AssemblyScript and JavaScript, which is by using the AssemblyScript loader. This code is provided by the AssemblyScript team. In the “Performance of Loader vs. Direct WebAssembly Calls<em>”</em> section, we’ll see whether we can improve the performance of the AssemblyScript loader with code we’ve written.</p>
<h3 id="h2-501737c11-0002">Hello World with the AssemblyScript Loader</h3>
<p class="BodyFirst">The AssemblyScript loader is a set of helper functions from the AssemblyScript team designed to make it easier to make calls to AssemblyScript from JavaScript. We’ll compare the code we wrote earlier with code written using the AssemblyScript loader. Initially, we’ll consider ease of use and later look into the performance implications of using or not using the loader. </p>
<p>We use the AssemblyScript loader to send a string back to the JavaScript from the AssemblyScript. The loader helper function converts the index coming from WebAssembly into a JavaScript string. Now we will install the loader using <code>npm</code>:</p>
<pre><code>npm install @assemblyscript/loader --save</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You might need to upgrade Node.js to use the loader. At the time of this writing, the newest version of the AssemblyScript loader requires Node.js version 14.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p> Now we’ll create a JavaScript file to load and run our WebAssembly module. Create a file named <em>as_hello_loader.js</em> and add the code in <a href="#listing11-9" id="listinganchor11-9">Listing 11-9</a>.</p>
<p class="CodeLabel"><b>as_hello_loader.js</b></p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> const loader = require("@assemblyscript/loader");
const fs = require('fs');
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> var module;

const importObject = {
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> as_hello: {
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> console_log: (str_index) =&gt; {
    <span class="CodeAnnotationCode" aria-label="annotation5">5</span> console.log(module.exports.__getString(str_index));
    }
  }
<span epub:type="pagebreak" title="254" id="Page_254"/>};
  
(async () =&gt; {
  let wasm = fs.readFileSync('as_hello.wasm');
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> module = await loader.instantiate(wasm, importObject);
<span class="CodeAnnotationCode" aria-label="annotation7">7</span> module.exports.HelloWorld();
})();</code></pre>
<p class="CodeListingCaption"><a id="listing11-9">Listing 11-9</a>: Using the AssemblyScript loader to call the WebAssembly module</p>
<p>This JavaScript function first requires <span class="CodeAnnotation" aria-label="annotation1">1</span> the AssemblyScript loader. We use this loader object to load the <code>module</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> object, which we declare globally. The <code>module</code> object is an AssemblyScript loader module that includes additional AssemblyScript loader helper functions. Inside the <code>importObject</code> is a child object with the <code>as_hello</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> name of our AssemblyScript module. That is where the AssemblyScript code expects to locate the imported functions. Inside the <code>as_hello</code> object is <code>console_log</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, which takes the string index <code>str_index</code> as its only parameter. This function uses the <code>__getString</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> function on the <code>module</code> object created by the loader. When given the string index, the <code>__getString</code> function retrieves a JavaScript string from linear memory. This string is printed to the console with <code>console.log</code>. The IIFE function loads an AssemblyScript module using the AssemblyScript <code>loader</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> object. Finally, the IIFE calls the <code>HelloWorld</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> function. When you run this JavaScript file using <code>node</code>, you’ll see the output in <a href="#listing11-10" id="listinganchor11-10">Listing 11-10</a>.</p>
<pre><code>hello world!</code></pre>
<p class="CodeListingCaption"><a id="listing11-10">Listing 11-10</a>: Output from the AssemblyScript hello world app</p>
<p>Using the AssemblyScript loader makes the JavaScript code significantly simpler. Later, in the “Performance of Loader vs. Direct WebAssembly Calls” section, we’ll explore the performance implications.</p>
<h3 id="h2-501737c11-0003">AssemblyScript String Concatenation</h3>
<p class="BodyFirst">Now that we know how to receive strings from AssemblyScript, we’ll send a string to an AssemblyScript module. This next function concatenates two strings separated by a pipe character (<code>|</code>). We’ll use the loader to make it easier to write the code on the JavaScript side. String concatenation is the kind of functionality that is challenging to implement directly in WAT but is very simple in AssemblyScript. Create a new file named <em>as_concat.ts</em> and add the code in <a href="#listing11-11" id="listinganchor11-11">Listing 11-11</a>.</p>
<p class="CodeLabel"><b>as_concat.ts</b></p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> export function cat( str1: string, str2: string ): string {
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> return str1 + "|" + str2;
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-11">Listing 11-11</a>: Concatenating strings using AssemblyScript</p>
<p>We export <span class="CodeAnnotation" aria-label="annotation1">1</span> <code>cat</code>, which takes two string parameters and returns a string. This function concatenates <span class="CodeAnnotation" aria-label="annotation2">2</span> the string with a pipe character (<code>|</code>) separating them.</p>
<p><span epub:type="pagebreak" title="255" id="Page_255"/>Now we can compile <em>as_concat.ts </em>using the <code>asc</code> command in <a href="#listing11-12" id="listinganchor11-12">Listing 11-12</a>.</p>
<pre><code>asc as_concat.ts --exportRuntime -Oz -o as_concat.wasm</code></pre>
<p class="CodeListingCaption"><a id="listing11-12">Listing 11-12</a>: Compiling the <em>as_concat.ts</em> file using <code>asc</code></p>
<p>We pass the <code>--exportRuntime</code> flag, which is necessary for passing strings into the WebAssembly module. Compiling with <code>--exportRuntime</code> adds code that allows you to call the <code>__allocString</code> function from JavaScript. If we fail to export the runtime, the following error occurs when the application executes:</p>
<pre><code>TypeError: alloc is not a function</code></pre>
<p>When you compile <em>as_concat.ts </em>into WAT, notice that the WAT file is much larger than our <em>as_hello.ts </em>file. The reason is that the runtime adds several string functions that perform necessary tasks, such as copy memory, concatenate strings, and get/set string length methods. </p>
<p>Now we can write our JavaScript app. The code in <a href="#listing11-13" id="listinganchor11-13">Listing 11-13</a> creates two strings in linear memory and calls the WebAssembly function <code>cat</code>. Create a new JavaScript file named <em>as_concat.js</em> and add the code in <a href="#listing11-13">Listing 11-13</a>.</p>
<p class="CodeLabel"><b>as_concat.js</b></p>
<pre><code>const fs = require('fs');
const loader = require("@assemblyscript/loader");

(async () =&gt; {
  let module = await loader.instantiate(fs.readFileSync('as_concat.wasm'));

  <span class="LiteralGray">//__newString, __getString functions require</span>
  <span class="LiteralGray">//compile with --exportRuntime flag</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> let first_str_index = module.exports.__newString("first string");
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> let second_str_index = module.exports.__newString("second string");
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> let cat_str_index = module.exports.cat(first_str_index,second_str_index);
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> let cat_string = module.exports.__getString(cat_str_index);
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> console.log(cat_string);
})();</code></pre>
<p class="CodeListingCaption"><a id="listing11-13">Listing 11-13</a>: JavaScript uses the AssemblyScript loader to call the <code>cat</code> AssemblyScript function.</p>
<p>The <code>cat</code> function we defined in the WebAssembly module doesn’t take a string as a parameter directly, so it needs an index into linear memory for the string location. The <code>module.exports.__newString</code> loader helper function takes a JavaScript string, copies it into linear memory, and returns an index to pass into <code>module.cat</code>. We call <code>module.exports.__newString</code> twice, passing <code>"first string"</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and then passing <code>"second string"</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. Each of these calls returns an index that we store in <code>first_str_index</code> and <code>second_str_index</code>. Next, we call <code>module.exports.cat</code>, passing in these indexes, from which we receive a JavaScript string index that we store in <code>cat_str_index</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. Then we call <code>module.exports.__getString</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, passing in <code>cat_str_index</code>, and storing that string in <code>cat_string</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>, which we log to the console. </p>
<p><span epub:type="pagebreak" title="256" id="Page_256"/> Now that we have our JavaScript and WebAssembly, we can run our application using <code>node</code>:</p>
<pre><code>node as_concat.js</code></pre>
<p>And here’s the output to your console:</p>
<pre><code>first string|second string</code></pre>
<p>There is a lot more to AssemblyScript to explore. As you can see, it’s much simpler to write code that works with strings in AssemblyScript than it is in WAT. That doesn’t necessarily tell you when you should work with string data in WebAssembly, but it exposes it as an option. AssemblyScript, like WebAssembly more broadly, is a quickly developing project. Taking the time to learn more about it from the project home page at <a href="http://assemblyscript.org" class="LinkURL">assemblyscript.org</a> is worth the time spent.</p>
<h2 id="h1-501737c11-0003">Object Oriented Programming in AssemblyScript</h2>
<p class="BodyFirst">OOP is almost impossible to use in WAT format, but because AssemblyScript is modeled on TypeScript, it offers significantly more options for OOP. In this section, we’ll cover some of the basics of OOP in AssemblyScript, as well as some of its limitations, which might no longer apply in future releases.</p>
<p>Let’s begin by creating a new AssemblyScript file named <em>vector.ts</em>. Right now, AssemblyScript is piggybacking on top of TypeScript file formatting, which works in most cases. </p><p/>
<p>Saule Cabrera has created an AssemblyScript language server plug-in for VS Code, which is available at <a href="https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls." class="LinkURL">https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.</a></p>
<p>Next, we’ll write an AssemblyScript <code>Vector2D</code> class to hold the coordinates of the collider objects that are similar to what we wrote for the collision detection app in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>. We’ll compile the code to WAT so we can explore the output of the AssemblyScript compiler. Gaining a better understanding of the compiler and its output can be extremely beneficial when optimizing WebAssembly code. Add <a href="#listing11-14" id="listinganchor11-14">Listing 11-14</a> to your file to create the class <code>Vector2D</code>.</p>
<p class="CodeLabel"><b>vector.ts</b></p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> export class Vector2D {
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> x: f32;
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> y: f32;

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> constructor(x: f32, y: f32) {
    this.x = x;
    this.y = y;
  }

<span class="CodeAnnotationCode" aria-label="annotation5">5</span> Magnitude(): f32 {
    return Mathf.sqrt(this.x * this.x + this.y * this.y);
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-14">Listing 11-14</a>: Creating a vector class in AssemblyScript</p>
<p><span epub:type="pagebreak" title="257" id="Page_257"/>We export a class called <code>Vector2D</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> that has two attributes, <code>x</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and <code>y</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. It also has a <code>constructor</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> that creates a new <code>Vector2D</code> object from the <code>x</code> and <code>y</code> parameters. The <code>Magnitude</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> method calculates the magnitude of the vector by summing the squares of <code>x</code> and <code>y</code> and taking the square root of that sum.</p>
<p>If you’re familiar with TypeScript, you’ll notice that this code looks just like the <code>class</code> structures in TypeScript. However, rather than using the TypeScript <code>number</code> type, we’re using <code>f32</code> types for 32-bit floating-point numbers. If you use the <code>number</code> type in your AssemblyScript, it’s the same as using an <code>f64</code> 64-bit floating-point, which has the poorest performance of the WebAssembly types in most circumstances. </p>
<p>The following command compiles <em>vector.ts </em>into a WAT file using <code>asc</code>:</p>
<pre><code>asc vector.ts -o vector.wat</code></pre>
<p>This creates a WAT file we can examine in VS Code. To <code>asc</code> we pass the name of the AssemblyScript file and then we pass the <code>-o</code><code> </code>flag with the filename for the output file,<code> vector.wat</code>. The extension determines whether the output will be WAT or the WebAssembly binary file. Open <em>vector.wat</em> and scroll down a bit until you get to the exports shown in <a href="#listing11-15" id="listinganchor11-15">Listing 11-15</a>.</p>
<p class="CodeLabel"><b>vector.wat</b></p>
<pre><code>...
  (export "memory" (memory $0))
  (export "Vector2D" (global $vector/Vector2D))
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (export "Vector2D#get:x" (func $vector/Vector2D#get:x))
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (export "Vector2D#set:x" (func $vector/Vector2D#set:x))
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (export "Vector2D#get:y" (func $vector/Vector2D#get:y))
  (export "Vector2D#set:y" (func $vector/Vector2D#set:y))
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (export "Vector2D#constructor" (func $vector/Vector2D#constructor))
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> (export "Vector2D#Magnitude" (func $vector/Vector2D#Magnitude))
...</code></pre>
<p class="CodeListingCaption"><a id="listing11-15">Listing 11-15</a>: The exported functions in our WAT file</p>
<p>Notice how the compiler generated <code>get</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and <code>set</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> accessor functions for the <code>x</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and <code>y</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> attributes, and exported them so you can access them from the embedding environment. This indicates that when the user sets an object attribute using the loader, it calls a function in the WebAssembly module. One implication of this is that if you’re setting several attributes at once, you might want to consider creating a function to do this all at once for performance reasons. That way, you’re not making multiple function calls to the WebAssembly module. You can also see that the WebAssembly module exported the <code>constructor</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> and <code>Magnitude</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> functions. </p>
<p>The naming conventions are important to understand if you want to call functions in the WebAssembly module from JavaScript. The methods are all prefixed with the name of the class and a hash mark (<code>#</code>) character (<code>Vector2D#</code>). The <code>set</code> and <code>get</code> methods have a suffix that indicates which attribute they’re setting and getting, such as <code>:x</code> or <code>:y</code>. To access these functions and attributes from our JavaScript without using the AssemblyScript loader, we need to use this naming convention. </p>
<h3 id="h2-501737c11-0004"><span epub:type="pagebreak" title="258" id="Page_258"/>Using Private Attributes</h3>
<p class="BodyFirst">If you don’t want to export all the attributes to the embedding environment, you need to use the <code>private</code> keyword before the <code>x </code>and <code>y</code> attributes. Do that now in your AssemblyScript and recompile with the <code>asc</code> command. <a href="#listing11-16" id="listinganchor11-16">Listing 11-16</a> shows the new version.</p>
<p class="CodeLabel"><b>vector.ts</b></p>
<pre><code>export class Vector2D {
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> private x: f32;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> private y: f32;

  constructor(x: f32, y: f32) {
    this.x = x;
    this.y = y;
  }

  Magnitude(): f32 {
    return Mathf.sqrt(this.x * this.x + this.y * this.y);
  }

}</code></pre>
<p class="CodeListingCaption"><a id="listing11-16">Listing 11-16</a>: Creating private functions in AssemblyScript</p>
<p>The <code>private</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> modifier before <code>x</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and <code>y</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> tells the AssemblyScript compiler that these attributes shouldn’t be publicly accessible. Recompile the WebAssembly module, which no longer exports the accessor methods that set and get the <code>x</code> and <code>y</code> variables to the embedding environment, as shown in <a href="#listing11-17" id="listinganchor11-17">Listing 11-17</a>.</p>
<p class="CodeLabel"><b>vector.wat</b></p>
<pre><code>...
(export "memory" (memory $0))
(export "Vector2D" (global $vector/Vector2D))
(export "Vector2D#constructor" (func $vector/Vector2D#constructor))
(export "Vector2D#Magnitude" (func $vector/Vector2D#Magnitude))
...</code></pre>
<p class="CodeListingCaption"><a id="listing11-17">Listing 11-17</a>: Exports in the WAT file</p>
<p>TypeScript has three modifiers, <code>public</code>, <code>private</code>, and <code>protected</code>, to define how attributes can be accessed. These modifiers behave a little differently in AssemblyScript than in other languages, such as TypeScript. In most languages, protected attributes are available to classes that extend the class but cannot be accessed outside the parent or child class. The<code> protected</code><code> </code>method in AssemblyScript isn’t implemented fully and behaves the same as the <code>public</code> modifier. For now, you should avoid using it to prevent confusion. The keywords may eventually work as they do in TypeScript, but be aware that these limitations still exist in AssemblyScript version 0.17.7. </p>
<p>The <code>private</code> modifier prevents AssemblyScript from exporting the <code>get</code> and <code>set</code> methods when it compiles the module. </p>
<p><span epub:type="pagebreak" title="259" id="Page_259"/>Unlike in other OOP languages, the <code>private</code> modifier in AssemblyScript doesn’t prevent classes that extend the original from accessing that attribute. </p>
<p>Let’s use the following command to compile our AssemblyScript into a WebAssembly module so we can call it from our JavaScript:</p>
<pre><code>asc vector.ts -o vector.wasm</code></pre>
<p>When we change the <code>-o</code> flag to <em>vector.wasm</em>, we tell the <code>asc</code> compiler to output a WebAssembly binary file. That will allow us to load and run the module from a JavaScript embedding environment. Next, let’s look at how to load and call WebAssembly functions using Node.js.</p>
<h3 id="h2-501737c11-0005">JavaScript Embedding Environment</h3>
<p class="BodyFirst">We’ll use Node.js to load and execute the WebAssembly module. If we instead use a browser, the JavaScript would use <code>WebAssembly.instantiateStreaming</code><code/><code/> and <code>fetch</code> instead of using <code>fs</code> to load the WebAssembly module from the filesystem and calling <code>WebAssembly.instantiate</code><code/><code/>. </p>
<p>Create the file <em>vector.js</em> and add the code in <a href="#listing11-18" id="listinganchor11-18">Listing 11-18</a>.</p>
<p class="CodeLabel"><b>vector.js</b></p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> const fs = require('fs');

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> (async () =&gt; {
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> let wasm = fs.readFileSync('vector.wasm');
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> let obj = await WebAssembly.instantiate(wasm,{env:{abort:()=&gt;{}}});

<span class="CodeAnnotationCode" aria-label="annotation5">5</span> let Vector2D = {
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> init: function (x, y) {
      return obj.instance.exports["Vector2D#constructor"](0, x, y)
    },
  <span class="CodeAnnotationCode" aria-label="annotation7">7</span> Magnitude: obj.instance.exports["Vector2D#Magnitude"],
}

<span class="CodeAnnotationCode" aria-label="annotation8">8</span> let vec1_id = Vector2D.init(3, 4);
  let vec2_id = Vector2D.init(4, 5);

  console.log(`
  <span class="CodeAnnotationCode" aria-label="annotation9">9</span> vec1.magnitude=${Vector2D.Magnitude(vec1_id)}
    vec2.magnitude=${Vector2D.Magnitude(vec2_id)}
    `);
})();</code></pre>
<p class="CodeListingCaption"><a id="listing11-18">Listing 11-18</a>: Calling functions on the <code>Vector2D</code> AssemblyScript class</p>
<p>We use the <code>fs</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> Node.js module to load <span class="CodeAnnotation" aria-label="annotation3">3</span> the binary WebAssembly data from a file inside an asynchronous IIFE <span class="CodeAnnotation" aria-label="annotation2">2</span>. Once we have the binary data, we pass it to <code>WebAssembly.instantiate</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, which returns a WebAssembly module object. We then create the JavaScript object <code>Vector2D</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>, which mirrors the functions inside the WebAssembly module. </p>
<p>We create an <code>init</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> function that calls the WebAssembly module’s <code>Vector2D</code> <code>constructor</code>, passing in <code>0</code> as the first parameter. Passing <span epub:type="pagebreak" title="260" id="Page_260"/>this value to the <code>constructor</code> function allows some degree of choice of object placement in linear memory. We are passing <code>0</code>, which makes the constructor create a new object at the next available memory location.The function will then return the location in linear memory where it created this object. The <code>Magnitude</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> attribute in <code>Vector2D</code> takes its value from <code>obj.instance.exports["Vector2D#Magnitude"]</code>, which is a function in our WebAssembly module. </p>
<p>After defining the JavaScript <code>Vector2D</code> object, we call <code>Vector2D.init</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> twice to create two <code>Vector2D</code> WebAssembly objects in linear memory, as well as return the linear memory address of these objects, which we use for method calls. We then call <code>Vector2D.Magnitude</code> twice inside a <code>console.log</code> template string. We pass in the vector ids (<code>vec1_id</code> and <code>vec2_id</code>) we saved in <a href="#listing11-18">Listing 11-18</a>, which tell the WebAssembly module which object it’s using. The <code>Magnitude</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> function passes back the magnitude of the given vector, which the app logs to the console. Run this app using <code>node</code>:</p>
<pre><code>node vector.js</code></pre>
<p>Here’s the result:</p>
<pre><code>vec1.magnitude=5
vec2.magnitude=6.4031243324279785</code></pre>
<p>The two values are the magnitude of our first vector where x = 3 and y = 4, and the magnitude of the second vector where x = 4 and y = 5. </p>
<p>Now that we know how to make calls into our AssemblyScript app directly, let’s look at how to use the AssemblyScript loader to make coding the JavaScript a little easier.</p>
<h3 id="h2-501737c11-0006">AssemblyScript Loader</h3>
<p class="BodyFirst">Now we’ll modify our AssemblyScript code to use the AssemblyScript loader library. This will allow us to compare the methods of interfacing with an AssemblyScript module in terms of ease of use and performance. As mentioned previously, it’s important to understand when it’s possible to improve your application’s performance and how much effort that requires. This information helps you make decisions concerning the trade-off between development time and application performance.</p>
<p>Open <em>vector_loader.ts</em> and add the code in <a href="#listing11-19" id="listinganchor11-19">Listing 11-19</a> to use the AssemblyScript loader.</p>
<p class="CodeLabel"><b>vector_loader.ts</b></p>
<pre><code>export class Vector2D {
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> x: f32;
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> y: f32;

  constructor(x: f32, y: f32) {
    this.x = x;
    this.y = y;
  }

<span epub:type="pagebreak" title="261" id="Page_261"/>  Magnitude(): f32 {
    return Mathf.sqrt(this.x * this.x + this.y * this.y);
  }

<span class="CodeAnnotationCode" aria-label="annotation3">3</span> add(vec2: Vector2D): Vector2D {
    this.x += vec2.x;
    this.y += vec2.y;
    return this;
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-19">Listing 11-19</a>: Remove the private modifier from the <code>x</code> and <code>y</code> attributes</p>
<p>There are two changes to <em>vector.ts</em> that we will add into <em>vector_loader.ts</em>. First, we remove the <code>private</code> modifiers from the <code>x</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and <code>y</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> attributes so we can access <code>x</code> and <code>y</code> from JavaScript. Second, we create an <code>add</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> function that adds a second vector. This function allows us to add two vectors together. In <a href="#listing11-20" id="listinganchor11-20">Listing 11-20</a>, we compile <em>vector_loader.ts</em> using <code>asc</code>.</p>
<pre><code>asc vector_loader.ts -o vector_loader.wasm</code></pre>
<p class="CodeListingCaption"><a id="listing11-20">Listing 11-20</a>: Compiling <em>vector.ts</em> to a WebAssembly file using <code>asc</code></p>
<p>Next, we’ll create a new JavaScript file named <em>vector_loader.js</em> so we can run the new WebAssembly module. Add the code in <a href="#listing11-21" id="listinganchor11-21">Listing 11-21</a> to <em>vector_loader.js</em>.</p>
<p class="CodeLabel"><b>vector_loader.js</b></p>
<pre><code>const fs = require('fs');
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> const loader = require('@assemblyscript/loader');

(async () =&gt; {
  let wasm = fs.readFileSync('vector_loader.wasm');
<span class="LiteralGray">  // instantiate the module using the loader</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> let module = await loader.instantiate(wasm);
  
<span class="LiteralGray">  // module.exports.Vector2D mirrors the AssemblyScript class.</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> let Vector2D = module.exports.Vector2D;

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> let vector1 = new Vector2D(3, 4);
  let vector2 = new Vector2D(4, 5);

<span class="CodeAnnotationCode" aria-label="annotation5">5</span> vector2.y += 10;
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> vector2.add(vector1);

  console.log(`
  <span class="CodeAnnotationCode" aria-label="annotation7">7</span> vector1=(${vector1.x}, ${vector1.y})
    vector2=(${vector2.x}, ${vector2.y})

    vector1.magnitude=${vector1.Magnitude()}
    vector2.magnitude=${vector2.Magnitude()}
   `);
})();</code></pre>
<p class="CodeListingCaption"><a id="listing11-21">Listing 11-21</a>: Using the AssemblyScript loader in JavaScript</p>
<p><span epub:type="pagebreak" title="262" id="Page_262"/>When using the loader, you can interact with AssemblyScript classes almost as if they’re JavaScript classes. There is a slight difference in that you call the demangled constructor function without using the JavaScript <code>new</code> operator, as you would do if these classes were created in JavaScript. However, once you’ve instantiated the object, you can interact with it as if it were written in JavaScript.</p>
<p>We first require the AssemblyScript <code>loader</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. Rather than using the <code>WebAssembly.instantiate</code> function from the IIFE, we call the <code>loader.instantiate</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function, which returns a loader module. This module works a little differently than the WebAssembly module object returned by the <code>WebAssembly.instantiate</code> call. The AssemblyScript loader adds functionality that allows the JavaScript to work with high-level AssemblyScript objects, such as classes and strings.</p>
<p>We then call <code>loader.demangle</code>, passing it the module returned by <code>loader.instantiate</code>. The <code>demangle</code> function returns an object structure that provides us with functions we can use to instantiate objects from our WebAssembly module. We pull the <code>Vector2D</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> function out of the object structure so we can use it as a constructor function for creating <code>Vector2D</code> objects in JavaScript. Note that we didn't use the <code>new </code>operator when instantiating <code>Vector2D</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. However, the current loader version supports use of the <code>new</code> operator. </p>
<p>We use the <code>Vector2D</code> function to create a <code>vector1</code> and <code>vector2</code> object, passing in the <code>x</code> and <code>y</code> values for those vectors. We can now use these objects as regular JavaScript objects. The loader wires everything up for us. For example, we call <code>vector2.y += 10</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> to increase the value of <code>vector2.y</code> by 10, and <code>vector2.add(vector1)</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> calls the <code>add </code>function on the <code>vector2</code> object, passing in <code>vector1</code>. In our <code>console.log</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> call, we can use values like <code>vector1.x</code> and <code>vector1.y</code>.</p>
<p>Run the JavaScript using <code>node</code>:</p>
<pre><code>node vector_loader.js</code></pre>
<p>You should see the following output:</p>
<pre><code>    vector1=(3, 4)
    vector2=(7, 19)

    vector1.magnitude=5
    vector2.magnitude=20.248456954956055</code></pre>
<p>The AssemblyScript loader interface allows you to work with WebAssembly modules created in AssemblyScript almost as if they were classes, objects, and functions created in JavaScript. This creates an ergonomic experience that you might not have when you write your own interface with the WebAssembly module. If you have specific performance targets, you’ll need to perform additional testing to see whether the loader meets all your needs. In the next section, we’ll extend our AssemblyScript class through inheritance.</p>
<h3 id="h2-501737c11-0007"><span epub:type="pagebreak" title="263" id="Page_263"/>Extending Classes in AssemblyScript</h3>
<p class="BodyFirst">OOP allows developers to extend a class by adding additional attributes or functionality to a base class. The syntax for extending classes in AssemblyScript is the same as it is in TypeScript. In <a href="#listing11-22" id="listinganchor11-22">Listing 11-22</a>, we’ll extend the <code>Vector2D</code> class with a <code>Vector3D</code> class that will add an additional attribute <code>z</code>, which will represent a third dimension for our vector.</p>
<p>Open the <em>vector_loader.ts</em> file and add the code in <a href="#listing11-22">Listing 11-22</a> after the <code>Vector2D</code> definition.</p>
<p class="CodeLabel"><b>vector_loader.ts</b></p>
<pre><code>...
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> export class Vector3D extends Vector2D {
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> z: f32;

  constructor(x: f32, y: f32, z: f32) {
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> super(x, y);
    this.z = z;
  }

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> Magnitude(): f32 {
    return Mathf.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  add(vec3: Vector3D): Vector3D {
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> super.add(vec3);
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> this.z += vec3.z;
    return this;
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-22">Listing 11-22</a>: Extending the <code>Vector2D</code> class using the <code>Vector3D</code> class</p>
<p>The new <code>Vector3D</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> class keeps the original <code>x</code> and <code>y</code> attributes, and adds a third <code>z</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> attribute for the third dimension. Its constructor calls <code>super</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, which runs the constructor from the <code>Vector2D</code> class. It then sets the value of <code>this.z</code> to the <code>z</code> parameter passed into the constructor. We override the <code>Magnitude</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> method from <code>Vector2D</code> so it takes the third dimension into account when calculating the magnitude of the vector. Then the <code>add</code> function calls the <code>Vector2D</code> class’s <code>add</code> function using <code>super.add</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> and increases the value of <code>this.z</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> using the <code>vec3</code> parameter’s <code>z</code> attribute value.</p>
<p>Now we can recompile our WebAssembly module using <code>asc</code>:</p>
<pre><code>asc vector_loader.ts -o vector_loader.wasm</code></pre>
<p>Next, in <a href="#listing11-23" id="listinganchor11-23">Listing 11-23</a>, we modify the <em>vector_loader.js</em> file to pull in the <code>Vector3D</code> class.</p>
<p class="CodeLabel"><b>vector_loader.js</b></p>
<pre><code>  const fs = require('fs');
  const loader = require("@assemblyscript/loader");

  (async () =&gt; {
    let wasm = fs.readFileSync('vector_loader.wasm');
    let module = await loader.instantiate(wasm);
<span epub:type="pagebreak" title="264" id="Page_264"/>
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span><b> </b>let { Vector2D, Vector3D } = await loader.demangle(module).exports;

    let vector1 = Vector2D(3, 4);
    let vector2 = Vector2D(4, 5);
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span><b> </b>let vector3 = Vector3D(5, 6, 7);

    vector2.y += 10;
    vector2.add(vector1);
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span><b> </b>vector3.z++;

    console.log(`
    vector1=(${vector1.x}, ${vector1.y})
    vector2=(${vector2.x}, ${vector2.y})
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span><b> </b>vector3=(${vector3.x}, ${vector3.y}, ${vector3.z})

    vector1.magnitude=${vector1.Magnitude()}
    vector2.magnitude=${vector2.Magnitude()}
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span><b> </b>vector3.magnitude=${vector3.Magnitude()}
    `);
  })();</code></pre>
<p class="CodeListingCaption"><a id="listing11-23">Listing 11-23</a>: JavaScript using the AssemblyScript loader to load <code>Vector2D</code> and <code>Vector3D</code> classes</p>
<p>We modify the line that took the <code>Vector2D</code> function from the call to <code>demangle</code>, and change it to destructure <span class="CodeAnnotation" aria-label="annotation1">1</span> the result, creating a <code>Vector2D</code> and <code>Vector3D </code>function variable. We create an object <code>vector3</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, using the function <code>Vector3D</code>, to which we pass <code>x</code>, <code>y</code>, and <code>z</code> values. We increment <code>vector3.z</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> for no particular reason other than to show that we can do it. Inside the template string passed to <code>console.log</code>, we add a line that displays the <code>x</code>, <code>y</code>, and <code>z</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> values in <code>vector3</code>, as well as the magnitude of <code>vector3</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>.</p>
<p>When you run this JavaScript from the command line using <code>node</code>, you get the output in <a href="#listing11-24" id="listinganchor11-24">Listing 11-24</a>.</p>
<pre><code>  vector1=(3, 4)
  vector2=(7, 19)
  vector3=(5, 6, 8)

  vector1.magnitude=5
  vector2.magnitude=20.248456954956055
  vector3.magnitude=11.180339813232422</code></pre>
<p class="CodeListingCaption"><a id="listing11-24">Listing 11-24</a>: Output from <em>vector_loader.js</em></p>
<p>Now let’s look at how the performance of the loader compares to direct calls into the WebAssembly module.</p>
<h3 id="h2-501737c11-0008">Performance of Loader vs. Direct WebAssembly Calls</h3>
<p class="BodyFirst">The AssemblyScript loader provides a more intuitive structure for interaction between the AssemblyScript module and our JavaScript. The final section of this chapter compares the loader with direct calls into the <span epub:type="pagebreak" title="265" id="Page_265"/>WebAssembly modules. To run this test, we don’t need to write any additional AssemblyScript. We’ll use the WebAssembly modules created earlier in this chapter, so we only need to create a new JavaScript file to call the existing modules. Create a new file named <em>vector_perform.js</em> and add the code in <a href="#listing11-25" id="listinganchor11-25">Listing 11-25</a>.</p>
<p class="CodeLabel"><b>vector_perform.js</b></p>
<pre><code>const fs = require('fs');
const loader = require("@assemblyscript/loader");

(async () =&gt; {
  let importObject = {
    env: {
      abort: () =&gt; { }
    }
  };
  let wasm = fs.readFileSync('vector_loader.wasm');
  let module = await loader.instantiate(wasm);
  let obj = await WebAssembly.instantiate(wasm, importObject);

<span class="LiteralGray">  // This JavaScript class will have all the functions</span>
<span class="LiteralGray">  // exported from AssemblyScript</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> let dVector2D = {
<span class="LiteralGray">    // the init function will call the constructor on Vector2D</span>
    init: function (x, y) {
      return obj.instance.exports["Vector2D#constructor"](0, x, y)
    },
    getX: obj.instance.exports["Vector2D#get:x"],
    setX: obj.instance.exports["Vector2D#set:x"],
    getY: obj.instance.exports["Vector2D#get:y"],
    setY: obj.instance.exports["Vector2D#set:y"],
    Magnitude: obj.instance.exports["Vector2D#Magnitude"],
    add: obj.instance.exports["Vector2D#add"],
  }

<span class="LiteralGray">  // This JavaScript class will have all the functions</span>
<span class="LiteralGray">  // exported from AssemblyScript</span>
  let dVector3D = {
<span class="LiteralGray">    // the init function will call the constructor on Vector3D</span>
    init: function (x, y, z) {
      return obj.instance.exports["Vector3D#constructor"](0, x, y, z)
    },
    getX: obj.instance.exports["Vector3D#get:x"],
    setX: obj.instance.exports["Vector3D#set:x"],
    getY: obj.instance.exports["Vector3D#get:y"],
    setY: obj.instance.exports["Vector3D#set:y"],
    getZ: obj.instance.exports["Vector3D#get:z"],
    setZ: obj.instance.exports["Vector3D#set:z"],
    Magnitude: obj.instance.exports["Vector3D#Magnitude"],
    add: obj.instance.exports["Vector3D#add"],
  }
<span class="LiteralGray">  // prepare to log the time it takes to run functions directly</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> let start_time_direct = (new Date()).getTime();

<span class="CodeAnnotationCode" aria-label="annotation3">3</span> let vec1_id = dVector2D.init(1, 2);
<span epub:type="pagebreak" title="266" id="Page_266"/>  let vec2_id = dVector2D.init(3, 4);
  let vec3_id = dVector3D.init(5, 6, 7);

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> for (let i = 0; i &lt; 1_000_000; i++) {
    dVector2D.add(vec1_id, vec2_id);
    dVector3D.setX(vec3_id, dVector3D.getX(vec3_id) + 10);
    dVector2D.setY(vec2_id, dVector2D.getY(vec2_id) + 1);
    dVector2D.Magnitude(vec2_id);
  }
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> console.log("direct time=" + (new Date().getTime() - start_time_direct));

<span class="CodeAnnotationCode" aria-label="annotation6">6</span> let { Vector2D, Vector3D } = await loader.demangle(module).exports;

<span class="CodeAnnotationCode" aria-label="annotation7">7</span> let start_time_loader = (new Date()).getTime();

<span class="CodeAnnotationCode" aria-label="annotation8">8</span> let vector1 = Vector2D(1, 2);
  let vector2 = Vector2D(3, 4);
  let vector3 = Vector3D(5, 6, 7);

<span class="CodeAnnotationCode" aria-label="annotation9">9</span> for (i = 0; i &lt; 1_000_000; i++) {
    vector1.add(vector2);
    vector3.x += 10;
    vector2.y++;
    vector2.Magnitude();
  }
<span class="CodeAnnotationCode" aria-label="annotationa">a</span> console.log("loader time=" + (new Date().getTime() - start_time_loader)); 
})();</code></pre>
<p class="CodeListingCaption"><a id="listing11-25">Listing 11-25</a>: Comparing loader function calls with direct function calls</p>
<p>Now we can see what it costs for us to use that pretty AssemblyScript loader syntax. This JavaScript creates an object to hold the direct calls to the <code>Vector2D</code> AssemblyScript class <code>dVector2D</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and one for the <code>Vector3D</code> class called <code>dVector3D</code>. We then set the variable <code>start_direct_time</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to the current time, which we’ll use to track the performance, and initialize <span class="CodeAnnotation" aria-label="annotation3">3</span> three vector objects. Two of the vector objects are <code>Vector2D</code> objects, and one is a <code>Vector3D</code> object. </p>
<p>After initializing the vectors, we loop one million times <span class="CodeAnnotation" aria-label="annotation4">4</span>, making calls to those objects. We didn’t test every function, so this isn’t a perfect performance test. The goal is simply to get some numbers and see how they compare. As long as we make the same calls to the direct and loader versions, we should be able to get a reasonable comparison. We then use <code>console.log</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> to log out the amount of time it took to initialize the vectors and run through the loop. This first loop tests the performance of the direct call to the WebAssembly module without using the AssemblyScript loader. Next, the code tests the performance of the module with the loader.</p>
<p>We use the <code>loader.demangle</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> function to create the <code>Vector2D</code> and <code>Vector3D</code> factory functions. We then initialize <code>start_time_loader</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> to the current time and call the <code>Vector2D</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> and <code>Vector3D</code> functions to create three objects mirroring the code in the first loop <span class="CodeAnnotation" aria-label="annotation4">4</span> that tested the direct initialization calls. We loop one million times <span class="CodeAnnotation" aria-label="annotation9">9</span>, executing the same functions as <span epub:type="pagebreak" title="267" id="Page_267"/>earlier, except through the loader. Finally, we <code>log</code> <span class="CodeAnnotation" aria-label="annotationa">a</span> the amount of time it took to execute the code using the loader. </p>
<p>Run <em>vector_perform.js</em> from the command line using <code>node</code>:</p>
<pre><code>node vector_perform.js</code></pre>
<p>This is the output I received when I executed the file:</p>
<pre><code>direct time=74
loader time=153</code></pre>
<p>As you can see, the version using the loader took roughly twice as long to execute. The difference is even starker when we include the initialization calls in a loop. If you’re going to use the AssemblyScript loader, it’s best to structure your code to make as few calls as possible between the JavaScript and AssemblyScript. </p>
<h2 id="h1-501737c11-0004">Summary</h2>
<p class="BodyFirst">In this chapter, you learned about the AssemblyScript high-level language, the AssemblyScript CLI, and the <code>asc</code> command you can use to compile AssemblyScript apps.</p>
<p>We created an <code>AddInts</code> function and a hello world app to show how writing an app in AssemblyScript compares to writing the same app in WAT. We compiled it to WAT format, looked through the code that the AssemblyScript compiler generated, and wrote a JavaScript app that ran the hello world app directly. While doing this, you learned how to use WAT to understand what the WebAssembly, created by the AssemblyScript compiler, is doing under the hood.</p>
<p>We then installed the AssemblyScript loader and used the JavaScript functions written by the AssemblyScript team to help us write the JavaScript code. </p>
<p>We discussed using strings in AssemblyScript, wrote a string concatenation app, and looked at how we must use additional flags with the <code>asc</code> compiler to allow <code>asc</code> to include additional WebAssembly libraries when compiling.</p>
<p>In the latter half of the chapter, we explored OOP in AssemblyScript. We created a class and looked at the exports from the WAT file it generated. We looked at <code>private</code> attributes and how they prevent AssemblyScript from exporting those attributes so they can’t be used by the embedding environment. We wrote JavaScript that allowed us to create the glue classes directly, and then used the AssemblyScript loader to create the glue code for us. We compared the performance of the direct and the loader methods. Finally, we extended our <code>Vector2D</code> class with a <code>Vector3D</code> class and discussed the differences between class inheritance in AssemblyScript and TypeScript.</p>
<aside class="endnote" epub:type="rearnote">
</aside>

</section>
</div></body></html>