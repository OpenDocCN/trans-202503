- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">OBJECT-ORIENTED
    PONG</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter we built our own version of the game *Pong*. Earlier,
    in [Chapter 6](chapter6.xhtml), you learned about classes and object-oriented
    programming in JavaScript. You might be wondering why we didn’t use any classes
    for our implementation of *Pong*. The main reason was that I wanted to keep the
    game code as simple as possible, without including any unnecessary concepts, to
    make it easier to see what the actual game is doing. As programs get larger and
    more complex, however, it helps to give them more structure, and one common way
    to do that is to use object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: To help you get a better understanding of how to design software in an object-oriented
    style, in this chapter we’ll walk through an object-oriented version of *Pong*.
    There won’t be any changes to the logic of the game, but the structure and organization
    of the code will be different. For example, the code for handling the ball will
    all live in a class called Ball. We’ll use this class to keep track of the ball’s
    position and to determine how the ball should bounce when it hits a wall or paddle.
    Similarly, all the code for handling the paddles will live in a class called Paddle.
    We’ll be able to easily share common code that applies to both balls and paddles
    by making the Ball and Paddle classes inherit from a shared superclass.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore the general structure of the object-oriented *Pong*
    program, but we won’t go into every single detail of the code; you should already
    have a pretty good idea of how it works from the last chapter. With that in mind,
    instead of building up the game incrementally, in this chapter we’ll step through
    the full code in order, section by section. Because of that, the code won’t run
    correctly or really *do* anything until you’ve entered it all. But before we get
    to the code itself, let’s first look more broadly at how to approach designing
    an object-oriented computer program.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Object-Oriented Design</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing code in an object-oriented way adds structure to computer programs by
    organizing the code into classes representing the various aspects of the program.
    This structure makes it easier for other programmers (and even a later version
    of you) to understand how your code works. A complete treatment of object-oriented
    design techniques would be beyond the scope of this book, but in this section
    we’ll look at a few key principles at the heart of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important first step in object-oriented design is modeling your domain,
    or the world of your program. What are the different elements in the program,
    what do they need to be able to do, and how do they relate to and interact with
    each other? In this case, the domain is the game *Pong*, and there are several
    visible elements in the game: the ball, the paddles, and the scores. While there
    are two paddles, they mostly behave in the same way, so we can create a single
    Paddle class with two customized instances. Meanwhile, the ball is distinct enough
    to deserve its own class. We also have to model how these elements interact. For
    example, how do we model the ball colliding with a paddle? That code has to live
    somewhere. As you’ll see, in my design, I decided that the code should live in
    the Ball class. In other words, the ball should “know” how to bounce off the paddles
    and the walls when it collides with them.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect of object-oriented programming is *encapsulation*.
    This means hiding the inner details of a class from the rest of the program, and
    providing a simple interface for it to use to interact with the class. Encapsulating
    these details makes it easier to change them later without affecting the rest
    of the program. For example, the Ball class doesn’t need to expose its speed or
    position to the rest of the program. If we decide to change how the speed is represented
    (for example, using angle and speed instead of xSpeed and ySpeed), we shouldn’t
    have to change how any other part of the program works.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Technically, xSpeed and ySpeed will be accessible outside of the Ball class,
    but we won’t be accessing them, so we can treat them as encapsulated details.
    JavaScript does have a way to declare properties as* private*, meaning they can’t
    be accessed outside of the class, but at the time of this writing it’s a new feature
    and isn’t available in all browsers.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A final key aspect of object-oriented programming is *polymorphism*, the idea
    that if a method expects to receive objects of a certain class, then it can also
    receive objects that are instances of subclasses of that class. For example, in
    this chapter you’ll see an Entity class that has a draw method and two subclasses:
    Paddle and Ball. In keeping with polymorphism, any code that uses the draw method
    should be able to receive any kind of Entity as an argument, without caring about
    whether we pass it a Ball or a Paddle.'
  prefs: []
  type: TYPE_NORMAL
- en: In the end, object-oriented design is more of an art than a science, and there
    are a lot of different ways to do it. You should treat the design in this chapter
    as one possible way to approach the problem, rather than “the right way” to do
    things. With that in mind, let’s dive into our object-oriented *Pong* code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The File Structure</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HTML for the object-oriented version of *Pong* is exactly the same as in
    the previous chapter, but the JavaScript is completely different. If you want,
    you can make a copy of the *tennjs* directory, remove the *script.js* file, and
    create a new *script.js* file with the code shown in the following sections. Alternatively,
    you can just delete all the code in the *script.js* file in your existing *tennjs*
    directory and replace it with the new object-oriented code. Either way, the updated
    *script.js* file will consist of a series of class declarations, followed by some
    extra code to set the game in motion. We’ll look at each section of the code in
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The GameView Class</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first class we’ll declare is called GameView. This class is responsible
    for the player’s view of the game, or how the game is displayed. Because the game
    uses a canvas for rendering, the GameView class is responsible for the canvas
    and drawing context. This class is also responsible for drawing things to the
    canvas, such as the ball and paddles, and for displaying the “GAME OVER” text.
    See [Listing 11-1](#Lis11-1) for the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: The GameView
    class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GameView constructor ❶ gets a reference to the canvas and its drawing context
    and saves these as properties called canvas and ctx, respectively. It also stores
    some values that will be used for drawing: the width and height of the canvas,
    and the offset of the canvas from the top of the browser viewport.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The draw method ❷ uses rest parameters, introduced in [Chapter 5](chapter5.xhtml).
    This way, you can pass multiple arguments to draw, and all the arguments will
    be collected into a single array called entities. Each argument will be an object
    representing one of the elements in the game: the ball and the two paddles. The
    method first draws a black rectangle to clear the canvas and then goes through
    the array of elements, calling each element’s own draw method in turn ❸ and passing
    the drawing context as an argument. This will work only if every object passed
    to GameView.draw has its own draw method; we’ll see how that’s implemented in
    the next section. The draw method on GameView has the ultimate responsibility
    for drawing to the canvas with each repetition of the game loop, but it delegates
    responsibility for actually drawing the game elements to the objects representing
    those elements. In effect, each element in the game “knows” how to draw itself,
    and GameView.draw just orchestrates the calls.'
  prefs: []
  type: TYPE_NORMAL
- en: The drawScores method ❹ takes an object containing the two scores and draws
    them to the canvas. It’s much the same as the score drawing code from the previous
    chapter. The main difference is that instead of relying on a global variable for
    the width of the canvas, it’s able to use the width property from the GameView
    class by referring to this.width.
  prefs: []
  type: TYPE_NORMAL
- en: The drawGameOver method ❺ is also mostly the same as the equivalent function
    in the previous chapter, but again, it gets the width and height from GameView
    rather than from global variables.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Game Elements</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next we’ll implement classes representing the three main game elements: the
    two paddles and the ball. We’ll begin with a superclass called Entity that will
    be a parent to the subclasses Paddle and Ball. The Entity class exists to share
    the general code common to both the paddles and the ball. This includes code for
    keeping track of the sizes and positions of the elements, calculating the boundaries
    of the elements for collision detection, and drawing the elements. Since all the
    game elements are rectangles, all this code is the same whether we’re dealing
    with a paddle or the ball. This shows the beauty of object-oriented programming:
    we can write all the common code once in the superclass, and let the subclasses
    inherit it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-2](#Lis11-2) contains the code for the Entity class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: The Entity class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The Entity constructor ❶ takes an x- and a y-coordinate for the top-left corner
    of the entity, and a width and height for its size. These are saved as properties.
  prefs: []
  type: TYPE_NORMAL
- en: The boundingBox method ❷ returns an object with the left, right, top, and bottom
    bounds of the entity. In the previous chapter, we manually created these objects
    for each entity in the checkCollision function. The Entity superclass gives us
    a convenient way of generalizing this common calculation for both the ball and
    the paddles.
  prefs: []
  type: TYPE_NORMAL
- en: The draw method ❸ takes a drawing context and draws a white rectangle using
    the properties defined in the constructor. The objects passed into the draw method
    on GameView will all be subclasses of Entity, and it’s the draw method on Entity
    that will be called for each item.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Paddles</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Paddle class extends the Entity class. It’s declared in [Listing 11-3](#Lis11-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-3: The Paddle class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This class includes three *static properties*, which are properties assigned
    to the class itself rather than to an individual instance of the class. A static
    property’s value will be shared across all instances of the class. In this case,
    while each instance of Paddle needs its own x- and y-coordinates, every Paddle
    object should have the same width and height, as well as the same offset from
    the left or right edge of the canvas. Thus, we define those values as the static
    properties WIDTH, HEIGHT, and OFFSET, which correspond to the PADDLE_WIDTH, PADDLE_HEIGHT,
    and PADDLE_OFFSET constants from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*There’s no straightforward way to define static constants in classes, which
    is why the constants from the previous chapter are now technically variables.
    Their names are in all caps to indicate that they should be treated as constants.*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare a static property using the static keyword. For example, we declare
    the WIDTH static property using static WIDTH = 5 ❶. Static properties are accessed
    using dot notation, as with an instance’s properties, except that you use the
    class name on the left side of the dot, rather than this or the name of the instance.
    For example, Paddle.WIDTH accesses the WIDTH static property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Paddle constructor ❷ has only two parameters: x and y. It uses super to
    call the constructor of its superclass (Entity), passing through the x and y parameters
    as well as Paddle.WIDTH for the width parameter and Paddle.HEIGHT for the height
    parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Ball</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next comes the Ball class. This is similar to the Paddle class in that it extends
    Entity, but Ball has its own logic for updating its position based on its speed,
    and for collision detection. [Listing 11-4](#Lis11-4) shows the first part of
    the code for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-4: The beginning
    of the Ball class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This class has a static property called SIZE that defines the width and height
    of the ball ❶. Next comes its constructor method ❷. Like the Paddle constructor,
    the first thing the Ball constructor does is call the constructor of its superclass,
    Entity, this time passing 0 for the x and y parameters and Ball.SIZE for the width
    and height parameters. The 0s are just placeholders; in fact, the ball starts
    each point at the same position, (20, 30). This positioning is handled by the
    Ball class’s init method, which is called for the first time from the constructor
    ❸. The init method itself is defined to set the initial position and speed of
    the ball ❹, just like the initBall function from the previous chapter. This method
    will be called whenever the ball needs to be reset to its initial position (after
    a point is scored).
  prefs: []
  type: TYPE_NORMAL
- en: The next method, update, uses the ball’s current speed to update its x- and
    y-position ❺. It’s followed by the adjustAngle method ❻, equivalent to the adjustAngle
    function described in the previous chapter. It changes the ball’s vertical speed
    (the angle of the bounce) depending on where the ball hits the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: The Ball class definition continues in [Listing 11-5](#Lis11-5) with the methods
    for collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-5: The rest of the
    Ball class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The checkPaddleCollision method has some overlap with the check Collision and
    checkPaddleCollision functions from the previous chapter. The method takes two
    parameters: an object representing one of the paddles, and xSpeedAfterBounce.
    The latter represents the new value we should set xSpeed to if a bounce off one
    of the paddles occurs, and it lets us configure whether the ball is expected to
    always bounce to the right (from the left paddle) or to the left (from the right
    paddle). As in the previous chapter, we enforce that a collision with the left
    paddle makes the ball bounce right and vice versa to avoid weirdness where the
    ball could bounce around “inside” the paddle.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the boundingBox method from the parent Entity class to get the bounding
    boxes of the ball and the paddle ❶, storing them as ballBox and paddleBox. Next,
    we compare the various bounding box edges to determine if a collision has taken
    place between the ball and the paddle, saving the result in the Boolean variable
    collisionOccurred ❷. If collisionOccurred is true, we call the adjustAngle method
    with the appropriate distances as determined from the bounding boxes ❸, then set
    the ball’s xSpeed to xSpeedAfterBounce ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the checkWallCollision method checks to see if a collision has occurred
    between the ball and a wall. It takes the width and height of the playing area
    and an object representing the scores as parameters. If the ball hits the left
    wall ❺ or right wall ❻, the appropriate score is incremented, and the ball is
    reset with a call to the init method. If it hits the top or bottom wall, it bounces
    ❼.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Scores and Computer Classes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Scores class is a simple container for keeping track of the current scores.
    The Computer class contains the logic for following the ball. The code for these
    two classes is in [Listing 11-6](#Lis11-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-6: The Scores and
    Computer classes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The Scores constructor ❶ sets the scores for the left and right players to 0.
    We could just use a plain object for the scores, but using a class keeps the structure
    of the code more consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Computer class has a single method called followBall, which updates the
    left paddle’s position based on the ball’s position. It’s a *static method*, meaning
    it doesn’t need an instance of the class to be called. We declare it as static
    using the static keyword ❷, similar to declaring a static property. Static methods
    are called using the class name rather than the instance name, like this: Computer.followBall(leftPaddle,
    ball).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We create instances of a class when there are properties specific to that
    instance that need to be stored. The Computer class doesn’t have any properties,
    so we don’t need to create an instance of it. Since the Computer class is never
    instantiated, it also doesn’t need a constructor.*'
  prefs: []
  type: TYPE_NORMAL
- en: We could just as easily have created a standalone function to move the left
    paddle, but as with the Scores class, keeping the code as part of a Computer class
    maintains consistency.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Game Class</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We finally come to the Game class, which is where all the other classes get
    instantiated (where applicable) and are stitched together and orchestrated. See
    [Listing 11-7](#Lis11-7) for the first part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-7: The first part
    of the Game class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The Game constructor first instantiates the GameView, Ball, and Paddle classes.
    The leftPaddle instance is created with Paddle.OFFSET for its x-coordinate ❶.
    The right one uses Paddle.OFFSET, Paddle.WIDTH, and this .gameView.width to determine
    its x-coordinate ❷, similar to how we calculated the position of the right paddle
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating other classes inside a class is a common feature of object-oriented
    code. This technique is called *composition*, because we’re composing instances
    inside other instances
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the Game constructor instantiates Scores ❸ and sets the gameOver Boolean
    to false. Finally, it sets up a mousemove event listener ❹ to update the right
    paddle’s position when the user moves the mouse. An event listener set up in a
    class constructor works just like the other event listeners we’ve seen in the
    book: it will be available as long as the application is running, and it triggers
    its handler function whenever the event is detected.'
  prefs: []
  type: TYPE_NORMAL
- en: After the constructor is the Game class’s draw method, which has the top-level
    responsibility for drawing all the visual aspects of the game. First the method
    calls this.gameView.draw ❺, passing the three main game elements, this.ball, this.leftPaddle,
    and this.rightPaddle. This is a call to the draw method of the GameView class
    we saw in [Listing 11-1](#Lis11-1), which took a variable number of objects as
    arguments and called the draw method on each one. The net result is that game.draw
    calls gameView.draw, which calls ball.draw, leftPaddle.draw, and rightPaddle.draw.
    It may seem a bit roundabout, but you’ll often find cases like this in object-oriented
    code, where keeping the code in its logical place requires jumping through some
    hoops. In this case, game.draw is responsible for knowing *which* objects get
    drawn (because the Game class keeps track of all the game elements); gameView.draw
    is responsible for the drawing context, clearing the canvas, and calling the draw
    methods on the elements; and the draw method on each game element is responsible
    for knowing how to draw itself.
  prefs: []
  type: TYPE_NORMAL
- en: After it has drawn all the entities, the draw method calls this.gameView .drawScores,
    passing the this.scores object ❻.
  prefs: []
  type: TYPE_NORMAL
- en: The Game class continues with the rest of its methods in [Listing 11-8](#Lis11-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-8: The rest of the
    Game class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Game class’s checkCollision method coordinates all the collision detection
    logic. First it calls the ball’s checkPaddleCollision method twice, to check for
    collisions between the ball and each of the paddles. Recall from [Listing 11-5](#Lis11-5)
    that this method takes two arguments: a Paddle object and a new, post-bounce value
    for xSpeed. For the left paddle, we know that we want the ball to bounce right,
    so we make the new xSpeed positive by taking the Math.abs of the current xSpeed
    ❶. For the right paddle we want the ball to bounce left, so we make the new xSpeed
    negative by negating the result of Math.abs(xSpeed) ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the checkCollision method calls ball.checkWallCollision to handle wall
    collisions ❸. This method takes the width and height (because the Ball object
    doesn’t know how big the playing area is) and the scores (so they can be incremented
    if a side wall is hit). Finally, the method checks to see if either score has
    exceeded the threshold ❹ and, if so, sets this.gameOver to true.
  prefs: []
  type: TYPE_NORMAL
- en: The Game object’s update method ❺ controls the changes of state between each
    repetition of the game loop. It calls the ball’s update method to move the ball,
    then tells the computer to move the left paddle based on the ball’s new position
    using the Computer.followBall static method.
  prefs: []
  type: TYPE_NORMAL
- en: The last method of the Game class, loop, defines the game loop ❻. We call this.draw,
    this.update, and this.checkCollision in sequence. Then we check to see if this.gameOver
    is true. If so ❼, we call draw again to render the final score, and we call gameView.drawGameOver
    to render the “GAME OVER” text. Otherwise, we use setTimeout to call the loop
    method again after 30 ms ❽, continuing the game.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Starting the Game</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The very last thing we have to do is start the game by instantiating the Game
    class and kicking off the game loop, as shown in [Listing 11-9](#Lis11-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-9: Starting the
    game</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We must create the instance of the Game class at the top level of the program,
    outside any of the class definitions. All the other required objects are instantiated
    by the Game class’s constructor, so creating a Game object automatically creates
    all the other objects as well. We could also have had the Game constructor call
    the loop method to set the game in motion as part of the Game class instantiation.
    However, placing the first call to game.loop at the top level of the program makes
    it easier to see exactly where the game gets going.
  prefs: []
  type: TYPE_NORMAL
- en: With this final listing, we now have all the code for the object-oriented version
    of our game! As long as you’ve entered all the code in order, it should now work,
    and gameplay should be exactly the same as in the version from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you created an object-oriented version of your *Pong* program,
    learning some strategies for object-oriented software design in the process. None
    of the game’s logic from the previous chapter changed; only the code’s organization
    differs. You may find one or the other of these two versions easier to read and
    understand, depending on your preferences and experience with object-oriented
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design is a complex field, and it can take a lot of practice
    to decompose programs into individual objects that make sense on their own. Even
    in this simple game, there are many ways you could split up the game’s components
    into objects and methods. For example, you might decide that the GameView class
    is unnecessary and that Game can keep track of the canvas, avoiding the need for
    the complex dance where draw calls draw calls draw. The main thing is to arrange
    your code in a way that makes sense and is easy for you and other programmers
    to understand and modify.
  prefs: []
  type: TYPE_NORMAL
