<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_217"/><span class="big">10</span><br/>GO PLUGINS AND EXTENDABLE TOOLS</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">Many security tools are constructed as <em>frameworks</em>—core components, built with a level of abstraction that allows you to easily extend their functionality. If you think about it, this makes a lot of sense for security practitioners. The industry is constantly changing; the community is always inventing new exploits and techniques to avoid detection, creating a highly dynamic and somewhat unpredictable landscape. However, by using plug-ins and extensions, tool developers can future-proof their products to a degree. By reusing their tools’ core components without making cumbersome rewrites, they can handle industry evolution gracefully through a pluggable system.</p>&#13;
<p class="indent">This, coupled with massive community involvement, is arguably how the Metasploit Framework has managed to age so well. Hell, even commercial enterprises like Tenable see the value in creating extendable products; Tenable relies on a plug-in-based system to perform signature checks within its Nessus vulnerability scanner.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_218"/>In this chapter, you’ll create two vulnerability scanner extensions in Go. You’ll first do this by using the native Go plug-in system and explicitly compiling your code as a shared object. Then you’ll rebuild the same plug-in by using an embedded Lua system, which predates the native Go plug-in system. Keep in mind that, unlike creating plug-ins in other languages, such as Java and Python, creating plug-ins in Go is a fairly new construct. Native support for plug-ins has existed only since Go version 1.8. Further, it wasn’t until Go version 1.10 that you could create these plug-ins as Windows dynamic link libraries (DLLs). Make sure you’re running the latest version of Go so that all the examples in this chapter work as planned.</p>&#13;
<h3 class="h3" id="ch10lev1sec1">Using Go’s Native Plug-in System</h3>&#13;
<p class="noindent">Prior to version 1.8 of Go, the language didn’t support plug-ins or dynamic runtime code extendibility. Whereas languages like Java allow you to load a class or JAR file when you execute your program to instantiate the imported types and call their functions, Go provided no such luxury. Although you could sometimes extend functionality through interface implementations and such, you couldn’t truly dynamically load and execute the code itself. Instead, you needed to properly include it during compile time. As an example, there was no way to replicate the Java functionality shown here, which dynamically loads a class from a file, instantiates the class, and calls <span class="literal">someMethod()</span> on the instance:</p>&#13;
<pre>File file = new File("<span class="codeitalic1">/path/to/classes/</span>");&#13;
URL[] urls = new URL[]{file.toURL()};&#13;
ClassLoader cl = new URLClassLoader(<span class="codeitalic1">urls</span>);&#13;
Class clazz = cl.loadClass("<span class="codeitalic1">com.example.MyClass</span>");&#13;
clazz.getConstructor().newInstance().someMethod();</pre>&#13;
<p class="indent">Luckily, the later versions of Go have the ability to mimic this functionality, allowing developers to compile code explicitly for use as a plug-in. Limitations exist, though. Specifically, prior to version 1.10, the plug-in system worked only on Linux, so you’d have to deploy your extendable framework on Linux.</p>&#13;
<p class="indent">Go’s plug-ins are created as shared objects during the building process. To produce this shared object, you enter the following build command, which supplies <span class="literal">plugin</span> as the <span class="literal">buildmode</span> option:</p>&#13;
<pre>$ <span class="codestrong1">go build -buildmode=plugin</span></pre>&#13;
<p class="indent">Alternatively, to build a Windows DLL, use <span class="literal">c-shared</span> as the <span class="literal">buildmode</span> option:</p>&#13;
<pre>$ <span class="codestrong1">go build -buildmode=c-shared</span></pre>&#13;
<p class="indent">To build a Windows DLL, your program must meet certain conventions to export your functions and also must import the <span class="literal">C</span> library. We’ll let you explore these details on your own. Throughout this chapter, we’ll focus <span epub:type="pagebreak" id="page_219"/>almost exclusively on the Linux plug-in variant, since we’ll demonstrate how to load and use DLLs in <a href="ch12.xhtml#ch12">Chapter 12</a>.</p>&#13;
<p class="indent">After you’ve compiled to a DLL or shared object, a separate program can load and use the plug-in at runtime. Any of the exported functions will be accessible. To interact with the exported features of a shared object, you’ll use Go’s <span class="literal">plugin</span> package. The functionality in the package is straightforward. To use a plug-in, follow these steps:</p>&#13;
<ol>&#13;
<li><p class="noindent">Call <span class="literal">plugin.Open(</span><span class="codeitalic1">filename</span> <span class="codeitalic1">string</span><span class="literal">)</span> to open a shared object file, creating a <span class="literal">*plugin.Plugin</span> instance.</p></li>&#13;
<li><p class="noindent">On the <span class="literal">*plugin.Plugin</span> instance, call <span class="literal">Lookup(</span><span class="codeitalic1">symbolName</span> <span class="codeitalic1">string</span><span class="literal">)</span> to retrieve a <span class="literal">Symbol</span> (that is, an exported variable or function) by name.</p></li>&#13;
<li><p class="noindent">Use a type assertion to convert the generic <span class="literal">Symbol</span> to the type expected by your program.</p></li>&#13;
<li><p class="noindent">Use the resulting converted object as desired.</p></li>&#13;
</ol>&#13;
<p class="indent">You may have noticed that the call to <span class="literal">Lookup()</span> requires the consumer to supply a symbol name. This means that the consumer must have a predefined, and hopefully publicized, naming scheme. Think of it as almost a defined API or generic interface to which plug-ins will be expected to adhere. Without a standard naming scheme, new plug-ins would require you to make changes to the consumer code, defeating the entire purpose of a plug-in-based system.</p>&#13;
<p class="indent">In the examples that follow, you should expect plug-ins to define an exported function named <span class="literal">New()</span> that returns a specific interface type. That way, you’ll be able to standardize the bootstrapping process. Getting a handle back to an interface allows us to call functions on the object in a predictable way.</p>&#13;
<p class="indent">Now let’s start creating your pluggable vulnerability scanner. Each plug-in will implement its own signature-checking logic. Your main scanner code will bootstrap the process by reading your plug-ins from a single directory on your filesystem. To make this all work, you’ll have two separate repositories: one for your plug-ins and one for the main program that consumes the plug-ins.</p>&#13;
<h4 class="h4" id="ch10lev2sec1">Creating the Main Program</h4>&#13;
<p class="noindent">Let’s start with your main program, to which you’ll attach your plug-ins. This will help you understand the process of authoring your plug-ins. Set up your repository’s directory structure so it matches the one shown here:</p>&#13;
<pre>$ <span class="codestrong1">tree</span>&#13;
.&#13;
--- cmd&#13;
    --- scanner&#13;
        --- main.go&#13;
--- plugins&#13;
--- scanner&#13;
    --- scanner.go</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_220"/>The file called <em>cmd/scanner/main.go</em> is your command line utility. It will load the plug-ins and initiate a scan. The <em>plugins</em> directory will contain all the shared objects that you’ll load dynamically to call various vulnerability signature checks. You’ll use the file called <em>scanner/scanner.go</em> to define the data types your plug-ins and main scanner will use. You put this data into its own package to make it a little bit easier to use.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10list1">Listing 10-1</a> shows what your <em>scanner.go</em> file looks like. (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.)</p>&#13;
<pre>   package scanner&#13;
&#13;
   // Scanner defines an interface to which all checks adhere&#13;
<span class="ent">❶</span> type Checker interface {&#13;
    <span class="ent">❷</span> Check(<span class="codeitalic1">host string</span>, <span class="codeitalic1">port uint64</span>) *Result&#13;
   }&#13;
&#13;
   // Result defines the outcome of a check&#13;
<span class="ent">❸</span> type Result struct {&#13;
       Vulnerable bool&#13;
       Details    string&#13;
   }</pre>&#13;
<p class="caption" id="ch10list1"><em>Listing 10-1: Defining core scanner types (</em><a href="https://ch-10/plugin-core/scanner/scanner.go">/ch-10/plugin-core/scanner/scanner.go</a><em>)</em></p>&#13;
<p class="indent">In this package, named <span class="literal">scanner</span>, you define two types. The first is an interface called <span class="literal">Checker</span> <span class="ent">❶</span>. The interface defines a single method named <span class="literal">Check()</span> <span class="ent">❷</span>, which accepts a host and port value and returns a pointer to a <span class="literal">Result</span>. Your <span class="literal">Result</span> type is defined as a <span class="literal">struct</span> <span class="ent">❸</span>. Its purpose is to track the outcome of the check. Is the service vulnerable? What details are pertinent in documenting, validating, or exploiting the flaw?</p>&#13;
<p class="indent">You’ll treat the interface as a contract or blueprint of sorts; a plug-in is free to implement the <span class="literal">Check()</span> function however it chooses, so long as it returns a pointer to a <span class="literal">Result</span>. The logic of the plug-in’s implementation will vary based on each plug-in’s vulnerability-checking logic. For instance, a plug-in checking for a Java deserialization issue can implement the proper HTTP calls, whereas a plug-in checking for default SSH credentials can issue a password-guessing attack against the SSH service. The power of abstraction!</p>&#13;
<p class="indent">Next, let’s review <em>cmd/scanner/main.go</em>, which will consume your plug-ins (<a href="ch10.xhtml#ch10list2">Listing 10-2</a>).</p>&#13;
<pre>const PluginsDir = "../../plugins/" <span class="ent">❶</span>&#13;
&#13;
func main() {&#13;
    var (&#13;
        files []os.FileInfo&#13;
        err   error&#13;
        p     *plugin.Plugin&#13;
        n     plugin.Symbol&#13;
        check scanner.Checker&#13;
<span epub:type="pagebreak" id="page_221"/>        res   *scanner.Result&#13;
    )  &#13;
    if files, err = ioutil.ReadDir(PluginsDir)<span class="ent">❷</span>; err != nil {&#13;
        log.Fatalln(err)&#13;
    }  &#13;
&#13;
    for idx := range files { <span class="ent">❸</span>&#13;
        fmt.Println("Found plugin: " + files[idx].Name())&#13;
        if p, err = plugin.Open(PluginsDir + "/" + files[idx].Name())<span class="ent">❹</span>; err != nil {&#13;
            log.Fatalln(err)&#13;
        }&#13;
&#13;
        if n, err = p.Lookup("New")<span class="ent">❺</span>; err != nil {&#13;
            log.Fatalln(err)&#13;
        }&#13;
&#13;
        newFunc, ok := n.(func() scanner.Checker) <span class="ent">❻</span>&#13;
        if !ok {&#13;
            log.Fatalln("Plugin entry point is no good. Expecting: func New() scanner.Checker{ ... }")&#13;
        }&#13;
        check = newFunc()<span class="ent">❼</span>&#13;
        res = check.Check("10.0.1.20", 8080) <span class="ent">❽</span>&#13;
        if res.Vulnerable { <span class="ent">❾</span>&#13;
            log.Println("Host is vulnerable: " + res.Details)&#13;
        } else {&#13;
            log.Println("Host is NOT vulnerable")&#13;
        }&#13;
    }  &#13;
}</pre>&#13;
<p class="caption" id="ch10list2"><em>Listing 10-2: The scanner client that runs plug-ins (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-10/plugin-core/cmd/scanner/main.go">/ch-10/plugin-core/cmd/scanner/main.go</a><em>)</em></p>&#13;
<p class="indent">The code starts by defining the location of your plug-ins <span class="ent">❶</span>. In this case, you’ve hardcoded it; you could certainly improve the code so it reads this value in as an argument or environment variable instead. You use this variable to call <span class="literal">ioutil.ReadDir(PluginDir)</span> and obtain a file listing <span class="ent">❷</span>, and then loop over each of these plug-in files <span class="ent">❸</span>. For each file, you use Go’s <span class="literal">plugin</span> package to read the plug-in via a call to <span class="literal">plugin.Open()</span> <span class="ent">❹</span>. If this succeeds, you’re given a <span class="literal">*plugin.Plugin</span> instance, which you assign to the variable named <span class="literal">p</span>. You call <span class="literal">p.Lookup("New")</span> to search your plug-in for a symbol named <span class="literal">New</span> <span class="ent">❺</span>.</p>&#13;
<p class="indent">As we mentioned during the high-level overview earlier, this symbol lookup convention requires your main program to provide the explicit name of the symbol as an argument, meaning you expect the plug-in to have an exported symbol by the same name—in this case, our main program is looking for the symbol named <span class="literal">New</span>. Furthermore, as you’ll see shortly, the code expects the symbol to be a function that will return a concrete implementation of your <span class="literal">scanner.Checker</span> interface, which we discussed in the previous section.</p>&#13;
<p class="indent">Assuming your plug-in contains a symbol named <span class="literal">New</span>, you make a type assertion for the symbol as you try to convert it to type <span class="literal">func()</span> <span class="literal">scanner.Checker</span> <span class="ent">❻</span>. That is, you’re expecting the symbol to be a function that returns an object implementing <span class="literal">scanner.Checker</span>. You assign <span epub:type="pagebreak" id="page_222"/>the converted value to a variable named <span class="literal">newFunc</span>. Then you invoke it and assign the returned value to a variable named <span class="literal">check</span> <span class="ent">❼</span>. Thanks to your type assertion, you know that <span class="literal">check</span> satisfies your <span class="literal">scanner.Checker</span> interface, so it must implement a <span class="literal">Check()</span> function. You call it, passing in a target host and port <span class="ent">❽</span>. The result, a <span class="literal">*scanner.Result</span>, is captured using a variable named <span class="literal">res</span> and inspected to determine whether the service was vulnerable or not <span class="ent">❾</span>.</p>&#13;
<p class="indent">Notice that this process is generic; it uses type assertions and interfaces to create a construct through which you can dynamically call plug-ins. Nothing within the code is specific to a single vulnerability signature or method used to check for a vulnerability’s existence. Instead, you’ve abstracted the functionality enough that plug-in developers can create stand-alone plug-ins that perform units of work without having knowledge of other plug-ins—or even extensive knowledge of the consuming application. The only thing that plug-in authors must concern themselves with is properly creating the exported <span class="literal">New()</span> function and a type that implements <span class="literal">scanner.Checker</span>. Let’s have a look at a plug-in that does just that.</p>&#13;
<h4 class="h4" id="ch10lev2sec2">Building a Password-Guessing Plug-in</h4>&#13;
<p class="noindent">This plug-in (<a href="ch10.xhtml#ch10list3">Listing 10-3</a>) performs a password-guessing attack against the Apache Tomcat Manager login portal. A favorite target for attackers, the portal is commonly configured to accept easily guessable credentials. With valid credentials, an attacker can reliably execute arbitrary code on the underlying system. It’s an easy win for attackers.</p>&#13;
<p class="indent">In our review of the code, we won’t cover the specific details of the vulnerability test, as it’s really just a series of HTTP requests issued to a specific URL. Instead, we’ll focus primarily on satisfying the pluggable scanner’s interface requirements.</p>&#13;
<pre>import (&#13;
    // Some snipped for brevity&#13;
    "github.com/bhg/ch-10/plugin-core/scanner" <span class="ent">❶</span>&#13;
)&#13;
&#13;
var Users = []string{"admin", "manager", "tomcat"}&#13;
var Passwords = []string{"admin", "manager", "tomcat", "password"}&#13;
&#13;
// TomcatChecker implements the scanner.Check interface. Used for guessing Tomcat creds&#13;
type TomcatChecker struct{} <span class="ent">❷</span>&#13;
&#13;
// Check attempts to identify guessable Tomcat credentials&#13;
func (c *TomcatChecker) Check(host string, port uint64) *scanner.Result { <span class="ent">❸</span>&#13;
    var (&#13;
        resp   *http.Response&#13;
        err    error&#13;
        url    string&#13;
        res    *scanner.Result&#13;
        client *http.Client&#13;
        req    *http.Request&#13;
    )  &#13;
    log.Println("Checking for Tomcat Manager...")&#13;
<span epub:type="pagebreak" id="page_223"/>    res = new(scanner.Result) <span class="ent">❹</span>&#13;
    url = fmt.Sprintf("http://%s:%d/manager/html", host, port)&#13;
    if resp, err = http.Head(url); err != nil {&#13;
        log.Printf("HEAD request failed: %s\n", err)&#13;
        return res&#13;
    }  &#13;
    log.Println("Host responded to /manager/html request")&#13;
    // Got a response back, check if authentication required&#13;
    if resp.StatusCode != http.StatusUnauthorized || resp.Header.Get("WWW-Authenticate") == "" {&#13;
        log.Println("Target doesn't appear to require Basic auth.")&#13;
        return res&#13;
    }  &#13;
&#13;
    // Appears authentication is required. Assuming Tomcat manager. Guess passwords...&#13;
    log.Println("Host requires authentication. Proceeding with password guessing...")&#13;
    client = new(http.Client)&#13;
    if req, err = http.NewRequest("GET", url, nil); err != nil {&#13;
        log.Println("Unable to build GET request")&#13;
        return res&#13;
    }&#13;
    for _, user := range Users {&#13;
        for _, password := range Passwords {&#13;
            req.SetBasicAuth(user, password)&#13;
            if resp, err = client.Do(req); err != nil {&#13;
                log.Println("Unable to send GET request")&#13;
                continue&#13;
            }&#13;
            if resp.StatusCode == http.StatusOK { <span class="ent">❺</span>&#13;
                res.Vulnerable = true&#13;
                res.Details = fmt.Sprintf("Valid credentials found - %s:%s", user, password)&#13;
                return res&#13;
            }  &#13;
        }  &#13;
    }  &#13;
    return res&#13;
}&#13;
&#13;
// New is the entry point required by the scanner&#13;
func New() scanner.Checker { <span class="ent">❻</span>&#13;
    return new(TomcatChecker)&#13;
}</pre>&#13;
<p class="caption" id="ch10list3"><em>Listing 10-3: Creating a Tomcat credential-guessing plug-in natively (</em><a href="https://github.com/blackhat-go/bhg/tree/master/ch-10/plugin-tomcat/main.go">/ch-10/plugin-tomcat/main.go</a><em>)</em></p>&#13;
<p class="indent">First, you need to import the <span class="literal">scanner</span> package we detailed previously <span class="ent">❶</span>. This package defines both the <span class="literal">Checker</span> interface and the <span class="literal">Result</span> struct that you’ll be building. To create an implementation of <span class="literal">Checker</span>, you start by defining an empty <span class="literal">struct</span> type named <span class="literal">TomcatChecker</span> <span class="ent">❷</span>. To fulfill the <span class="literal">Checker</span> interface’s implementation requirements, you create a method matching the required <span class="literal">Check(host string, port uint64) *scanner.Result</span> function signature <span class="ent">❸</span>. Within this method, you perform all of your custom vulnerability-checking logic.</p>&#13;
<p class="indent">Since you’re expected to return a <span class="literal">*scanner.Result</span>, you initialize one, assigning it to a variable named <span class="literal">res</span> <span class="ent">❹</span>. If the conditions are met—that is, <span epub:type="pagebreak" id="page_224"/>if the checker verifies the guessable credentials—and the vulnerability is confirmed <span class="ent">❺</span>, you set <span class="literal">res.Vulnerable</span> to <span class="literal">true</span> and set <span class="literal">res.Details</span> to a message containing the identified credentials. If the vulnerability isn’t identified, the instance returned will have <span class="literal">res.Vulnerable</span> set to its default state—<span class="literal">false</span>.</p>&#13;
<p class="indent">Lastly, you define the required exported function <span class="literal">New() *scanner.Checker</span> <span class="ent">❻</span>. This adheres to the expectations set by your scanner’s <span class="literal">Lookup()</span> call, as well as the type assertion and conversion needed to instantiate the plug-in-defined <span class="literal">TomcatChecker</span>. This basic entry point does nothing more than return a new <span class="literal">*TomcatChecker</span> (which, since it implements the required <span class="literal">Check()</span> method, happens to be a <span class="literal">scanner.Checker</span>).</p>&#13;
<h4 class="h4" id="ch10lev2sec3">Running the Scanner</h4>&#13;
<p class="noindent">Now that you’ve created both your plug-in and the main program that consumes it, compile your plug-in, using the <span class="literal">-o</span> option to direct your compiled shared object to the scanner’s plug-ins directory:</p>&#13;
<pre>$ <span class="codestrong1">go build -buildmode=plugin -o /path/to/plugins/tomcat.so</span></pre>&#13;
<p class="indent">Then run your scanner (<em>cmd/scanner/main.go</em>) to confirm that it identifies the plug-in, loads it, and executes the plug-in’s <span class="literal">Check()</span> method:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go</span>&#13;
Found plugin: tomcat.so&#13;
2020/01/15 15:45:18 Checking for Tomcat Manager...&#13;
2020/01/15 15:45:18 Host responded to /manager/html request&#13;
2020/01/15 15:45:18 Host requires authentication. Proceeding with password guessing...&#13;
2020/01/15 15:45:18 Host is vulnerable: Valid credentials found - tomcat:tomcat</pre>&#13;
<p class="indent">Would you look at that? It works! Your scanner is able to call code within your plug-in. You can drop any number of other plug-ins into the plug-ins directory. Your scanner will attempt to read each and kick off the vulnerability-checking functionality.</p>&#13;
<p class="indent">The code we developed could benefit from a number of improvements. We’ll leave these improvements to you as an exercise. We encourage you to try a few things:</p>&#13;
<ol>&#13;
<li><p class="noindent">Create a plug-in to check for a different vulnerability.</p></li>&#13;
<li><p class="noindent">Add the ability to dynamically supply a list of hosts and their open ports for more extensive tests.</p></li>&#13;
<li><p class="noindent">Enhance the code to call only applicable plug-ins. Currently, the code will call all plug-ins for the given host and port. This isn’t ideal. For example, you wouldn’t want to call the Tomcat checker if the target port isn’t HTTP or HTTPS.</p></li>&#13;
<li><p class="noindent">Convert your plug-in system to run on Windows, using DLLs as the plug-in type.</p></li>&#13;
</ol>&#13;
<p class="indent">In the next section, you’ll build the same vulnerability-checking plug-in in a different, unofficial plug-in system: Lua.</p>&#13;
<h3 class="h3" id="ch10lev1sec2"><span epub:type="pagebreak" id="page_225"/>Building Plug-ins in Lua</h3>&#13;
<p class="noindent">Using Go’s native <span class="literal">buildmode</span> feature when creating pluggable programs has limitations, particularly because it’s not very portable, meaning the plug-ins may not cross-compile nicely. In this section, we’ll look at a way to overcome this deficiency by creating plug-ins with Lua instead. Lua is a scripting language used to extend various tools. The language itself is easily embeddable, powerful, fast, and well-documented. Security tools such as Nmap and Wireshark use it for creating plug-ins, much as you’ll do right now. For more info, refer to the official site at <em><a href="https://www.lua.org/">https://www.lua.org/</a></em>.</p>&#13;
<p class="indent">To use Lua within Go, you’ll use a third-party package, <span class="literal">gopher-lua</span>, which is capable of compiling and executing Lua scripts directly in Go. Install it on your system by entering the following:</p>&#13;
<pre>$ <span class="codestrong1">go get github.com/yuin/gopher-lua</span></pre>&#13;
<p class="indent">Now, be forewarned that the price you’ll pay for portability is increased complexity. That’s because Lua has no implicit way to call functions in your program or various Go packages and has no knowledge of your data types. To solve this problem, you’ll have to choose one of two design patterns:</p>&#13;
<ol>&#13;
<li><p class="noindent">Call a single entry point in your Lua plug-in, and let the plug-in call any helper methods (such as those needed to issue HTTP requests) through other Lua packages. This makes your main program simple, but it reduces portability and could make dependency management a nightmare. For example, what if a Lua plug-in requires a third-party dependency not installed as a core Lua package? Your plug-in would break the moment you move it to another system. Also, what if two separate plug-ins require different versions of a package?</p></li>&#13;
<li><p class="noindent">In your main program, wrap the helper functions (such as those from the <span class="literal">net/http</span> package) in a manner that exposes a façde through which the plug-in can interact. This, of course, requires you to write extensive code to expose all the Go functions and types. However, once you’ve written the code, the plug-ins can reuse it in a consistent manner. Plus, you can sort of not worry about the Lua dependency issues that you’d have if you used the first design pattern (although, of course, there’s always the chance that a plug-in author uses a third-party library and breaks something).</p></li>&#13;
</ol>&#13;
<p class="indent">For the remainder of this section, you’ll work on the second design pattern. You’ll wrap your Go functions to expose a façde that’s accessible to your Lua plug-ins. It’s the better of the two solutions (and plus, the word <em>façde</em> makes it sound like you’re building something really fancy).</p>&#13;
<p class="indent">The bootstrapping, core Go code that loads and runs plug-ins will reside in a single file for the duration of this exercise. For the sake of simplicity, we’ve specifically removed some of patterns used in the examples at <em><a href="https://github.com/yuin/gopher-lua/">https://github.com/yuin/gopher-lua/</a></em>. We felt that some of the patterns, such as using user-defined types, made the code less readable. In a real <span epub:type="pagebreak" id="page_226"/>implementation, you’d likely want to include some of those patterns for better flexibility. You’d also want to include more extensive error and type checking.</p>&#13;
<p class="indent">Your main program will define functions to issue GET and HEAD HTTP requests, register those functions with the Lua virtual machine (VM), and load and execute your Lua scripts from a defined plug-ins directory. You’ll build the same Tomcat password-guessing plug-in from the previous section, so you’ll be able to compare the two versions.</p>&#13;
<h4 class="h4" id="ch10lev2sec4">Creating the head() HTTP Function</h4>&#13;
<p class="noindent">Let’s start with the main program. First, let’s look at the <span class="literal">head()</span> HTTP function, which wraps calls to Go’s <span class="literal">net/http</span> package (<a href="ch10.xhtml#ch10list4">Listing 10-4</a>).</p>&#13;
<pre>func head(l *lua.LState<span class="ent">❶</span>) int {&#13;
    var (&#13;
        host string&#13;
        port uint64&#13;
        path string&#13;
        resp *http.Response&#13;
        err  error&#13;
        url  string&#13;
    )&#13;
 <span class="ent">❷</span> host = l.CheckString(1)&#13;
    port = uint64(l.CheckInt64(2))&#13;
    path = l.CheckString(3)&#13;
    url = fmt.Sprintf("http://%s:%d/%s", host, port, path)&#13;
    if resp, err = http.Head(url); err != nil {&#13;
     <span class="ent">❸</span> l.Push(lua.LNumber(0))&#13;
        l.Push(lua.LBool(false))&#13;
        l.Push(lua.LString(fmt.Sprintf("Request failed: %s", err)))&#13;
     <span class="ent">❹</span> return 3&#13;
    }&#13;
 <span class="ent">❺</span> l.Push(lua.LNumber(resp.StatusCode))&#13;
    l.Push(lua.LBool(resp.Header.Get("WWW-Authenticate") != ""))&#13;
    l.Push(lua.LString(""))&#13;
 <span class="ent">❻</span> return 3&#13;
}</pre>&#13;
<p class="caption" id="ch10list4"><em>Listing 10-4: Creating a</em> <span class="codeitalic">head()</span> <em>function for Lua (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go">/ch-10/lua-core/cmd/scanner/main.go</a><em>)</em></p>&#13;
<p class="indent">First, notice that your <span class="literal">head()</span> function accepts a pointer to a <span class="literal">lua.LState</span> object and returns an <span class="literal">int</span> <span class="ent">❶</span>. This is the expected signature for any function you wish to register with the Lua VM. The <span class="literal">lua.LState</span> type maintains the running state of the VM, including any parameters passed in to Lua and returned from Go, as you’ll see shortly. Since your return values will be included within the <span class="literal">lua.LState</span> instance, the <span class="literal">int</span> return type represents the number of values returned. That way, your Lua plug-in will be able to read and use the return values.</p>&#13;
<p class="indent">Since the <span class="literal">lua.LState</span> object, <span class="literal">l</span>, contains any parameters passed to your function, you read the data in via calls to <span class="literal">l.CheckString()</span> and <span class="literal">l.CheckInt64()</span> <span class="ent">❷</span>. (Although not needed for our example, other <span class="literal">Check*</span> functions exist to <span epub:type="pagebreak" id="page_227"/>accommodate other expected data types.) These functions receive an integer value, which acts as the index for the desired parameter. Unlike Go slices, which are 0-indexed, Lua is 1-indexed. So, the call to <span class="literal">l.CheckString(1)</span> retrieves the first parameter supplied in the Lua function call, expecting it to be a string. You do this for each of your expected parameters, passing in the proper index of the expected value. For your <span class="literal">head()</span> function, you’re expecting Lua to call <span class="literal">head(host, port, path)</span>, where <span class="literal">host</span> and <span class="literal">path</span> are strings and <span class="literal">port</span> is an integer. In a more resilient implementation, you’d want to do additional checking here to make sure the data supplied is valid.</p>&#13;
<p class="indent">The function proceeds to issue an HTTP HEAD request and perform some error checking. In order to return values to your Lua callers, you push the values onto your <span class="literal">lua.LState</span> by calling <span class="literal">l.Push()</span> and passing it an object that fulfills the <span class="literal">lua.LValue</span> interface type <span class="ent">❸</span>. The <span class="literal">gopher-lua</span> package contains several types that implement this interface, making it as easy as calling <span class="literal">lua.LNumber(0)</span> and <span class="literal">lua.LBool(false)</span>, for example, to create numerical and boolean return types.</p>&#13;
<p class="indent">In this example, you’re returning three values. The first is the HTTP status code, the second determines whether the server requires basic authentication, and the third is an error message. We’ve chosen to set the status code to <span class="literal">0</span> if an error occurs. You then return <span class="literal">3</span>, which is the number of items you’ve pushed onto your <span class="literal">LState</span> instance <span class="ent">❹</span>. If your call to <span class="literal">http.Head()</span> doesn’t produce an error, you push your return values onto <span class="literal">LState</span> <span class="ent">❺</span>, this time with a valid status code, and then check for basic authentication and return <span class="literal">3</span> <span class="ent">❻</span>.</p>&#13;
<h4 class="h4" id="ch10lev2sec5">Creating the get() Function</h4>&#13;
<p class="noindent">Next, you’ll create your <span class="literal">get()</span> function, which, like the previous example, wraps the <span class="literal">net/http</span> package’s functionality. In this case, however, you’ll issue an HTTP GET request. Other than that, the <span class="literal">get()</span> function uses fairly similar constructs as your <span class="literal">head()</span> function by issuing an HTTP request to your target endpoint. Enter the code in <a href="ch10.xhtml#ch10list5">Listing 10-5</a>.</p>&#13;
<pre>func get(l *lua.LState) int {&#13;
    var (&#13;
        host     string&#13;
        port     uint64&#13;
        username string&#13;
        password string&#13;
        path     string&#13;
        resp     *http.Response&#13;
        err      error&#13;
        url      string&#13;
        client   *http.Client&#13;
        req      *http.Request&#13;
    )  &#13;
    host = l.CheckString(1)&#13;
    port = uint64(l.CheckInt64(2))&#13;
 <span class="ent">❶</span> username = l.CheckString(3)&#13;
    password = l.CheckString(4)&#13;
    path = l.CheckString(5)&#13;
    url = fmt.Sprintf("http://%s:%d/%s", host, port, path)&#13;
<span epub:type="pagebreak" id="page_228"/>    client = new(http.Client)&#13;
    if req, err = http.NewRequest("GET", url, nil); err != nil {&#13;
        l.Push(lua.LNumber(0))&#13;
        l.Push(lua.LBool(false))&#13;
        l.Push(lua.LString(fmt.Sprintf("Unable to build GET request: %s", err)))&#13;
        return 3&#13;
    }  &#13;
    if username != "" || password != "" {&#13;
        // Assume Basic Auth is required since user and/or password is set&#13;
        req.SetBasicAuth(username, password)&#13;
    }  &#13;
    if resp, err = client.Do(req); err != nil {&#13;
        l.Push(lua.LNumber(0))&#13;
        l.Push(lua.LBool(false))&#13;
        l.Push(lua.LString(fmt.Sprintf("Unable to send GET request: %s", err)))&#13;
        return 3&#13;
    }&#13;
    l.Push(lua.LNumber(resp.StatusCode))&#13;
    l.Push(lua.LBool(false))&#13;
    l.Push(lua.LString(""))&#13;
    return 3&#13;
}</pre>&#13;
<p class="caption" id="ch10list5"><em>Listing 10-5: Creating a</em> <span class="codeitalic">get()</span> <em>function for Lua (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go">/ch-10/lua-core/cmd/scanner/main.go</a><em>)</em></p>&#13;
<p class="indent">Much like your <span class="literal">head()</span> implementation, your <span class="literal">get()</span> function will return three values: the status code, a value expressing whether the system you’re trying to access requires basic authentication, and any error messages. The only real difference between the two functions is that your <span class="literal">get()</span> function accepts two additional string parameters: a username and a password <span class="ent">❶</span>. If either of these values is set to a non-empty string, you’ll assume you have to perform basic authentication.</p>&#13;
<p class="indent">Now, some of you are probably thinking that the implementations are oddly specific, almost to the point of negating any flexibility, reusability, and portability of a plug-in system. It’s almost as if these functions were designed for a very specific use case—that is, to check for basic authentication—rather than for a general purpose. After all, why wouldn’t you return the response body or the HTTP headers? Likewise, why wouldn’t you accept more robust parameters to set cookies, other HTTP headers, or issue POST requests with a body, for example?</p>&#13;
<p class="indent"><em>Simplicity</em> is the answer. Your implementations can act as a starting point for building a more robust solution. However, creating that solution would be a more significant endeavor, and you’d likely lose the code’s purpose while trying to navigate implementation details. Instead, we’ve chosen to do things in a more basic, less flexible fashion to make the general, foundational concepts simpler to understand. An improved implementation would likely expose complex user-defined types that better represent the entirety of, for example, the <span class="literal">http.Request</span> and <span class="literal">http.Response</span> types. Then, rather than accepting and returning multiple parameters from Lua, you could simplify <span epub:type="pagebreak" id="page_229"/>your function signatures, reducing the number of parameters you accept and return. We encourage you to work through this challenge as an exercise, changing the code to accept and return user-defined <span class="literal">structs</span> rather than primitive types.</p>&#13;
<h4 class="h4" id="ch10lev2sec6">Registering the Functions with the Lua VM</h4>&#13;
<p class="noindent">Up to this point, you’ve implemented wrapper functions around the necessary <span class="literal">net/http</span> calls you intend to use, creating the functions so <span class="literal">gopher-lua</span> can consume them. However, you need to actually register the functions with the Lua VM. The function in <a href="ch10.xhtml#ch10list6">Listing 10-6</a> centralizes this registration process.</p>&#13;
<pre><span class="ent">❶</span> const LuaHttpTypeName = "http"&#13;
&#13;
   func register(l *lua.LState) {&#13;
    <span class="ent">❷</span> mt := l.NewTypeMetatable(LuaHttpTypeName)&#13;
    <span class="ent">❸</span> l.SetGlobal("http", mt)&#13;
       // static attributes&#13;
    <span class="ent">❹</span> l.SetField(mt, "head", l.NewFunction(head))&#13;
       l.SetField(mt, "get", l.NewFunction(get))&#13;
   }</pre>&#13;
<p class="caption" id="ch10list6"><em>Listing 10-6: Registering plug-ins with Lua (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go">/ch-10/lua-core/cmd/scanner/main.go</a><em>)</em></p>&#13;
<p class="indent">You start by defining a constant that will uniquely identify the namespace you’re creating in Lua <span class="ent">❶</span>. In this case, you’ll use <span class="literal">http</span> because that’s essentially the functionality you’re exposing. In your <span class="literal">register()</span> function, you accept a pointer to a <span class="literal">lua.LState</span>, and use that namespace constant to create a new Lua type via a call to <span class="literal">l.NewTypeMetatable()</span> <span class="ent">❷</span>. You’ll use this metatable to track types and functions available to Lua.</p>&#13;
<p class="indent">You then register a global name, <span class="literal">http</span>, on the metatable <span class="ent">❸</span>. This makes the <span class="literal">http</span> implicit package name available to the Lua VM. On the same metatable, you also register two fields by using calls to <span class="literal">l.SetField()</span> <span class="ent">❹</span>. Here, you define two static functions named <span class="literal">head()</span> and <span class="literal">get()</span>, available on the <span class="literal">http</span> namespace. Since they’re static, you can call them via <span class="literal">http.get()</span> and <span class="literal">http.head()</span> without having to create an instance of type <span class="literal">http</span> in Lua.</p>&#13;
<p class="indent">As you may have noted in the <span class="literal">SetField()</span> calls, the third parameter is the destination function that’ll handle the Lua calls. In this case, those are your <span class="literal">get()</span> and <span class="literal">head()</span> functions you previously implemented. These are wrapped in a call to <span class="literal">l.NewFunction()</span>, which accepts a function of form <span class="literal">func(*LState) int</span>, which is how you defined your <span class="literal">get()</span> and <span class="literal">head()</span> functions. They return a <span class="literal">*lua.LFunction</span>. This might be a little overwhelming, since we’ve introduced a lot of data types and you’re probably unfamiliar with <span class="literal">gopher-lua</span>. Just understand that this function is registering the global namespace and function names and creating mappings between those function names and your Go functions.</p>&#13;
<h4 class="h4" id="ch10lev2sec7"><span epub:type="pagebreak" id="page_230"/>Writing Your Main Function</h4>&#13;
<p class="noindent">Lastly, you’ll need to create your <span class="literal">main()</span> function, which will coordinate this registration process and execute the plug-in (<a href="ch10.xhtml#ch10list7">Listing 10-7</a>).</p>&#13;
<pre><span class="ent">❶</span> const PluginsDir = "../../plugins"&#13;
&#13;
   func main() {&#13;
       var (&#13;
           l     *lua.LState&#13;
           files []os.FileInfo&#13;
           err   error&#13;
           f     string&#13;
       )&#13;
    <span class="ent">❷</span> l = lua.NewState()&#13;
       defer l.Close()&#13;
    <span class="ent">❸</span> register(l)&#13;
    <span class="ent">❹</span> if files, err = ioutil.ReadDir(PluginsDir); err != nil {&#13;
           log.Fatalln(err)&#13;
       }&#13;
&#13;
    <span class="ent">❺</span> for idx := range files {&#13;
           fmt.Println("Found plugin: " + files[idx].Name())&#13;
           f = fmt.Sprintf("%s/%s", PluginsDir, files[idx].Name())&#13;
        <span class="ent">❻</span> if err := l.DoFile(f); err != nil {&#13;
               log.Fatalln(err)&#13;
           }&#13;
       }&#13;
   }</pre>&#13;
<p class="caption" id="ch10list7"><em>Listing 10-7: Registering and calling Lua plug-ins (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/cmd/scanner/main.go">/ch-10/lua-core/cmd/scanner/main.go</a><em>)</em></p>&#13;
<p class="indent">As you did for your <span class="literal">main()</span> function in the Go example, you’ll hardcode the directory location from which you’ll load your plug-ins <span class="ent">❶</span>. In your <span class="literal">main()</span> function, you issue a call to <span class="literal">lua.NewState()</span> <span class="ent">❷</span> to create a new <span class="literal">*lua.LState</span> instance. The <span class="literal">lua.NewState()</span> instance is the key item you’ll need to set up your Lua VM, register your functions and types, and execute arbitrary Lua scripts. You then pass that pointer to the <span class="literal">register()</span> function you created earlier <span class="ent">❸</span>, which registers your custom <span class="literal">http</span> namespace and functions on the state. You read the contents of your plug-ins directory <span class="ent">❹</span>, looping through each file in the directory <span class="ent">❺</span>. For each file, you call <span class="literal">l.DoFile(f)</span> <span class="ent">❻</span>, where <span class="literal">f</span> is the absolute path to the file. This call executes the contents of the file within the Lua state on which you registered your custom types and functions. Basically, <span class="literal">DoFile()</span> is <span class="literal">gopher-lua</span>’s way of allowing you to execute entire files as if they were stand-alone Lua scripts.</p>&#13;
<h4 class="h4" id="ch10lev2sec8"><span epub:type="pagebreak" id="page_231"/>Creating Your Plug-in Script</h4>&#13;
<p class="noindent">Now let’s take a look at your Tomcat plug-in script, written in Lua (<a href="ch10.xhtml#ch10list8">Listing 10-8</a>).</p>&#13;
<pre>usernames = {"admin", "manager", "tomcat"}&#13;
passwords = {"admin", "manager", "tomcat", "password"}&#13;
&#13;
status, basic, err = http.head("10.0.1.20", 8080, "/manager/html") <span class="ent">❶</span>&#13;
if err ~= "" then&#13;
    print("[!] Error: "..err)&#13;
    return&#13;
end&#13;
if status ~= 401 or not basic then&#13;
    print("[!] Error: Endpoint does not require Basic Auth. Exiting.")&#13;
    return&#13;
end&#13;
print("[+] Endpoint requires Basic Auth. Proceeding with password guessing")&#13;
for i, username in ipairs(usernames) do&#13;
    for j, password in ipairs(passwords) do&#13;
        status, basic, err = http.get("10.0.1.20", 8080, username, password, "/manager/html") <span class="ent">❷</span>&#13;
        if status == 200 then&#13;
            print("[+] Found creds - "..username..":"..password)&#13;
            return&#13;
        end&#13;
    end&#13;
end</pre>&#13;
<p class="caption" id="ch10list8"><em>Listing 10-8: A Lua plug-in for Tomcat password guessing (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-10/lua-core/plugins/tomcat.lua">/ch-10/lua-core/plugins/tomcat.lua</a><em>)</em></p>&#13;
<p class="indent">Don’t worry too much about the vulnerability-checking logic. It’s essentially the same as the logic you created in the Go version of this plug-in; it performs basic password guessing against the Tomcat Manager portal after it fingerprints the application by using a HEAD request. We’ve highlighted the two most interesting items.</p>&#13;
<p class="indent">The first is a call to <span class="literal">http.head("10.0.1.20", 8080, "/manager/html")</span> <span class="ent">❶</span>. Based off your global and field registrations on the state metatable, you can issue a call to a function named <span class="literal">http.head()</span> without receiving a Lua error. Additionally, you’re supplying the call with the three parameters your <span class="literal">head()</span> function expected to read from the <span class="literal">LState</span> instance. The Lua call is expecting three return values, which align with the numbers and types you pushed onto the <span class="literal">LState</span> before you exited the Go function.</p>&#13;
<p class="indent">The second item is your call to <span class="literal">http.get()</span> <span class="ent">❷</span>, which is similar to the <span class="literal">http.head()</span> function call. The only real difference is that you are passing username and password parameters to the <span class="literal">http.get()</span> function. If you refer back to the Go implementation of your <span class="literal">get()</span> function, you’ll see that we’re reading these two additional strings from the <span class="literal">LState</span> instance.</p>&#13;
<h4 class="h4" id="ch10lev2sec9"><span epub:type="pagebreak" id="page_232"/>Testing the Lua Plug-in</h4>&#13;
<p class="noindent">This example isn’t perfect and could benefit from additional design considerations. But as with most adversarial tools, the most important thing is that it works and solves a problem. Running your code proves that it does, indeed, work as expected:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go</span>&#13;
Found plugin: tomcat.lua&#13;
[+] Endpoint requires Basic Auth. Proceeding with password guessing&#13;
[+] Found creds - tomcat:tomcat</pre>&#13;
<p class="indent">Now that you have a basic working example, we encourage you to improve the design by implementing user-defined types so that you aren’t passing lengthy lists of arguments and parameters to and from functions. With this, you’ll likely need to explore registering instance methods on your struct, whether for setting and getting values in Lua or for calling methods on a specifically implemented instance. As you work through this, you’ll notice that your code will get significantly more complex, since you’ll be wrapping a lot of your Go functionality in a Lua-friendly manner.</p>&#13;
<h3 class="h3" id="ch10lev1sec3">Summary</h3>&#13;
<p class="noindent">As with many design decisions, there are multiple ways to skin a cat. Whether you’re using Go’s native plug-in system or an alternative language like Lua, you must consider trade-offs. But regardless of your approach, you can easily extend Go to make rich security frameworks, particularly since the addition of its native plug-in system.</p>&#13;
<p class="indent">In the next chapter, you’ll tackle the rich topic of cryptography. We’ll demonstrate various implementations and use cases, and then build an RC2 symmetric-key brute-forcer.</p>&#13;
</div>



  </body></html>