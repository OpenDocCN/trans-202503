["```\n#error `arbitrary text`\n#warning `arbitrary text`\n```", "```\n#define `identifier` `arbitrary_text`\n```", "```\n#define pi 3.14159\n```", "```\nmaxCnt = 10\n```", "```\npi = 3.14159\n    .\n    .\n    .\n   .double pi\n```", "```\n#define pi 3.14159\n   .\n   .\n   .\n   .double pi\n```", "```\n .double 3.14159\n```", "```\n#define hw \"Hello, World!\"\n```", "```\n#define xor eor\n   .\n   .\n   .\n  xor x1, x0, x2\n```", "```\n+  -  *  /  %  == != <  <=  >  >=  !  ~  && ||  &  | << >>\n```", "```\ndefined(`identifier`)\n```", "```\n#if `expression`\n .\n .\n .\n#elif `expression`  // This is optional and may appear multiple times.\n .\n .\n .\n#else             // This is optional.\n .\n .\n .\n#endif\n\n#ifdef `identifier`\n .\n .\n .\n#else             // This is optional.\n .\n .\n .\n#endif\n\n#ifndef `identifier`\n .\n  .\n .\n#else             // This is optional.\n .\n .\n .\n#endif\n```", "```\n#if defined(`identifier`)\n .\n .\n .\n#endif\n```", "```\n#if !defined(`identifier`)\n .\n .\n .\n#endif\n```", "```\n#ifdef isMacOS\n\n    `Code written for macOS`\n\n#else\n\n    `Assume the code was written for Linux or Pi OS.`\n\n#endif\n```", "```\n#define isMacOS\n```", "```\n// Uncomment to activate debug output or -D debug on the command line.\n\n// #define debug\n      .\n      .\n      .\n     #ifdef debug\n\n        #warning *** DEBUG build\n\n        mov  x1, [fp, #i]\n        mstr x1, [sp]\n        lea  x0, debugMsg\n        bl   printf\n\n     #else\n\n        #warning *** RELEASE build\n\n     #endif\n```", "```\n#define lcl(arg1)  [fp, #arg1]\n   .\n   .\n   .\n  ldr w0, lcl(varName)\n```", "```\n ldr w0, [fp, #varName]\n```", "```\n#define zeroArgs()  `text`\n```", "```\n#define noArgs  `text1`\n#define zeroArgs() `text2`\n```", "```\n#define twoArgs(arg1, arg2)  `text to expand`\n```", "```\nmov w0, twoArgs(1, 2)\n```", "```\n singleArg(\"Strings can contain commas, that's okay!\")\n  singleArg(',')    // Also okay\n  singleArg((1,2))  // (1,2) is a single argument.\n```", "```\n#define reserve(amt)  amt + 1\n```", "```\n.space  reserve(Size) * 2  // Size is a constant.\n```", "```\n.space  Size + 1 * 2\n```", "```\n#define reserve(amt)  ((amt) + 1)\n```", "```\n.space  reserve((Size + 5)) * 2\n```", "```\n#define varArgs(...)  `text to expand`\n```", "```\n#define bytes(...) __VA_ARGS__\n   .\n   .\n   .\n  .byte bytes(1, 2, 3, 4)\n```", "```\n.byte 1, 2, 3, 4\n```", "```\n.byte bytes()\n```", "```\n.byte\n```", "```\n#define inc(x) ((x)+1)\n#define mult(y) ((y)*2)\n   .\n   .\n   .\n  .byte mult(inc(5))\n```", "```\n.byte mult(((5) + 1))  // First step\n```", "```\n.byte (((5) + 1) * 2)   // Second step\n```", "```\n.byte 12\n```", "```\n#define calledMacro(x) mov w0, x\n#define callingMacro(y) calledMacro(y)\n   .\n   .\n   .\n  callingMacro(5)\n```", "```\n calledMacro(5)\n```", "```\n mov w0, 5\n```", "```\n#define identifier(`parameters)` `text to expand` \\n\n```", "```\n#define multipleLines(parms) `text1` \\\n                             `text2` \\\n                              .\n                              .\n                              .\n                             `textn`\n```", "```\n#define printi(i)        \\\n        lea   x0, iFmtStr  \\\n        lea   x1, i        \\\n        ldr   x1, [x1]     \\\n        mstr  x1, [sp]     \\\n bl    printf\n         .\n         .\n         .\n        printi(var)\n```", "```\n#ifdef isMacOS\n#define someMacro `text to expand if macOS`\n#else\n#define someMacro `text to expand if not macOS`\n#endif\n```", "```\nident ## ifier\n```", "```\n#define one 1\n#define _e  e\n#define produceOne(x) on ## x\n   .\n   .\n   .\n  produceOne(_e)  // Expands to on_e\n```", "```\n#define produceOne  1\n#define concat(x, y) x ## y\n\n    mov w0, #concat(produce, One)\n```", "```\nmov w0, #produceOne\n```", "```\nmov w0, #1\n```", "```\n# `parmID`\n```", "```\nif_else(`expression`) (`true expansion`) (`false expansion`)\n```", "```\n.asciz if_else(MacOS) (\"macOS\") (\"LinuxOS\")\n```", "```\n#define _secondArg_(a, b, ...) b\n\n#define _is_probe_(...) _secondArg_(__VA_ARGS__, 0)\n#define _probe_() ~, 1\n\n#define _cat_(a, b) a ## b\n\n#define _not_(x) _is_probe_(_cat_(_not_, x))\n#define _not_0 _probe_()\n\n#define _bool_(x) _not_(_not_(x))\n\n#define if_else(condition) _if_else_(_bool_(condition))\n#define _if_else_(condition) _cat_(_if_ , condition)\n\n#define _if_1(...) __VA_ARGS__ _if_1_else\n#define _if_0(...)             _if_0_else\n\n#define _if_1_else(...)\n#define _if_0_else(...) __VA_ARGS__\n```", "```\n#define macStr(x) if_else(x) (\"macOS\")(\"Linux\")\n```", "```\nmap(`macroName`, `arg1`, `arg2`, ..., `argn`)\n```", "```\n `macroName`(`arg1`)\n  `macroName`(`arg2`)\n   .\n   .\n   .\n  `macroName`(`argn)`\n```", "```\n// Include the macro definitions for if_else from\n// the previous section here.\n\n#define _firstArg_(a, ...) a\n\n#define _empty_()\n\n#define eval(...) eval1024(__VA_ARGS__)\n#define eval1024(...) eval512(eval512(__VA_ARGS__))\n#define eval512(...) eval256(eval256(__VA_ARGS__))\n#define eval256(...) eval128(eval128(__VA_ARGS__))\n#define eval128(...) eval64(eval64(__VA_ARGS__))\n#define eval64(...) eval32(eval32(__VA_ARGS__))\n#define eval32(...) eval16(eval16(__VA_ARGS__))\n#define eval16(...) eval8(eval8(__VA_ARGS__))\n#define eval8(...) eval4(eval4(__VA_ARGS__))\n#define eval4(...) eval2(eval2(__VA_ARGS__))\n#define eval2(...) eval1(eval1(__VA_ARGS__))\n#define eval1(...) __VA_ARGS__\n\n#define _defer1(m) m _empty_()\n#define _defer2(m) m _empty_ _empty_()()\n#define _defer3(m) m _empty_ _empty_ _empty_()()()\n#define _defer4(m) m _empty_ _empty_ _empty_ _empty_()()()()\n\n#define _has_args(...) _bool_(_firstArg_(_end_of_args __VA_ARGS__)())\n#define _end_of_args() 0\n\n#define map(m, _firstArg_, ...)       \\\n  m(_firstArg_)                       \\\n  if_else(_has_args(__VA_ARGS__))(    \\\n    _defer2(_map)()(m, __VA_ARGS__) \\\n  )(                                    \\\n    /* Do nothing, just terminate */    \\\n  )\n#define _map() map\n```", "```\n#define inc(x) (x+1),\n     .\n     .\n     .\n    .byte eval(map(inc, 1, 2, 3, 4, 5, 6, 7)) 9\n```", "```\n-D isLinux=1    (for Linux and Pi OS)\n-D isMacOS=1    (for macOS)\n```", "```\n#define isLinux 1\n#define isMacOS 1\n```", "```\n#ifdef isLinux\n  #define myIsLinux 1\n  #define myIsMacOS 0\n#else\n  #define myIsLinux 0\n  #define myIsMacOS 1\n#endif\n```", "```\n#undef `identifier`\n```", "```\n.err\n```", "```\n.error \"`String error message`\"\n```", "```\n.warning \"`String warning message`\"\n```", "```\n.if `expression1`\n\n  `Statements to assemble if expression is nonzero`\n\n.elseif `expression2`  // Optional, may appear multiple times\n\n  `Statements to assemble if expression2 is nonzero`\n\n.else  // Optional, but only one instance is legal\n\n  `Statements to assemble if expression1, expression2, ...`\n  `and so on, were all 0`\n\n.endif\n```", "```\n.rept `expression`\n\n  `Statements to repeat`\n\n.endr\n```", "```\n.set  i, 0     // Initialize array element value.\n.rept 32\n.byte i\n.set  i, i + 1 // Increment array element value.\n.endr\n```", "```\n// Zero out an eight-dword array:\n\n    .set  ofs, 0\n    .rept 8\n    str   xzr, [x0, #ofs]\n    .set  ofs, ofs + 8\n    .endr\n```", "```\n str xzr, [x0, #0]\n    str xzr, [x0, #8]\n    str xzr, [x0, #16]\n    str xzr, [x0, #24]\n    str xzr, [x0, #32]\n    str xzr, [x0, #40]\n    str xzr, [x0, #48]\n    str xzr, [x0, #56]\n```", "```\n.irp `identifier`, `comma-separated-list-of-values`\n .\n .\n .\n.endr\n```", "```\n.irp  i, 0, 1, 2, 3\n.byte \\i\n.endr\n```", "```\n.byte 0\n.byte 1\n.byte 2\n.byte 3\n```", "```\n.irpc `identifier`, `text`\n .\n .\n .\n.endr\n```", "```\n.irpc x, acde\n.byte '\\x'\n.endr\n```", "```\n.byte 'a'\n.byte 'c'\n.byte 'd'\n.byte 'e'\n```", "```\n.byte a\n.byte c\n.byte d\n.byte e\n```", "```\n.macro `identifier` {`parameter_list`}\n\n  `Statements to expand on macro invocation`\n\n.endm\n```", "```\n.macro oneByte value\n.byte  \\value\n.endm\n .\n .\n .\noneByte 1  // Expands to .byte 1\n```", "```\n.macro bytes yy:req, zz=0, tt, ss:vararg\n.byte  \\yy\n.byte  \\zz\n.byte  \\tt\n.byte  \\ss\n.endm\n```", "```\nbytes 5\n```", "```\n.byte 5\n.byte 0  // Because zz expands to 0 by default\n.byte    // Argument tt expands to the empty string.\n.byte    // Argument ss also expands to the empty string.\n```", "```\nbytes 5, 4, 3, 2, 1, 0\n```", "```\n.byte 5        // yy expansion\n.byte 4        // zz expansion\n.byte 3        // tt expansion\n.byte 2, 1, 0  // ss expansion\n```", "```\n.macro  addVals theVals:vararg\nadd     x0, x0, #\\theVals\n.endm\n```", "```\naddVals 1, 2\n```", "```\nadd x0, x0, #1, 2\n```", "```\n.macro  addVals theVals:vararg\n.irp    valToAdd, \\theVals\nadd     x0, x0, #\\valToAdd\n.endr\n.endm\n```", "```\nadd x0, x0, #1\nadd x0, x0, #2\n```", "```\n.macro select which\nlea    x1, var\\which\nldr    w1, [x1]\n.endm\n```", "```\nlea x1, var0\nldr w1, [x1]\n```", "```\nlea x1, var1\nldr w1, [x1]\n```", "```\n.macro select2 which\nlea    x1, \\whichvar\nldr    w1, [x1]\n.endm\n```", "```\n.macro select2 which\nlea    x1, \\which\\()var\nldr    w1, [x1]\n.endm\n```", "```\nlea    x1, myvar\nldr    w1, [x1]\n```", "```\n.macro myStr theStr\n.asciz \\theStr\n.endm\n .\n .\n .\nmyStr \"hello\"\n```", "```\n.asciz hello\n```", "```\n.macro myStr theStr\n.asciz \"\\theStr\"\n.endm\n .\n .\n .\nmyStr \"hello\"\n```", "```\n.asciz \"hello\"\n```", "```\n.macro  sum from=0, to=5\n.long   \\from\n.ifgt   \\to-\\from\nsum     \"(\\from+1)\",\\to\n.endif\n.endm\n```", "```\n.long   0\n.long   1\n.long   2\n.long   3\n.long   4\n.long   5\n```", "```\n.exitm\n```", "```\n.macro reverse first, args:vararg\n.ifb    \\first\n.exitm  // Quit recursion if no more arguments.\n.endif\nreverse \\args\n.byte   \\first\n.endm\n```", "```\n.byte 3\n.byte 2\n.byte 1\n.byte 0\n```", "```\n .macro  lclsym sym\n        b       a\\()\\@\na\\()\\@:\n        .endm\n```", "```\n// aoaa.inc\n//\n// \"Magic\" header file for The Art of ARM Assembly\n// that smooths over the differences between Linux\n// and macOS\n//\n// Assertions:\n//\n// Either isMacOS or isLinux has been\n// defined in the source file (using #define) prior\n// to including this source file. This source file\n// must be included using `#include \"aoaa.inc\"`\n// NOT using the Gas `.include` directive.\n```", "```\n// aoaa.inc (cont.)\n//\n#ifndef aoaa_inc\n#define aoaa_inc 0\n```", "```\n// aoaa.inc (cont.)\n//\n// Make sure all OS symbols are\n// defined and only one of them\n// is set to 1:\n\n#ifndef isMacOS\n    #define isMacOS (0)\n#else\n    #undef isMacOS\n    #define isMacOS (1)\n#endif\n\n#ifndef isLinux\n    #define isLinux (0)\n#else\n    #undef isLinux\n #define isLinux (1)\n#endif\n\n// Make sure exactly one of the OS symbols is set to 1:\n\n#if (isMacOS+isLinux) != 1\n    #error \"Exactly one of isMacOS or isLinux,\" \\\n                       \" must be 1\"\n#endif\n```", "```\n// aoaa.inc (cont.)\n//\n// Do macOS-specific stuff here:\n\n#if isMacOS\n\n    // Change all the C global function\n    // names to include a leading underscore\n    // character, as required by macOS (these\n    // definitions allow you to use all the\n    // same names in example programs in\n    // macOS and Linux). This list includes\n    // all the C stdlib functions used by\n    // AoAA example code.\n\n    #define asmMain  _asmMain\n    #define acos     _acos\n    #define asin     _asin\n    #define atan     _atan\n    #define cos      _cos\n    #define exp      _exp\n    #define exp2     _exp2\n    #define getTitle _getTitle\n    #define free     _free\n    #define log      _log\n    #define log2     _log2\n    #define log10    _log10\n    #define malloc   _malloc\n    #define pow      _pow\n    #define printf   _printf\n    #define readLine _readLine\n    #define sin      _sin\n    #define sqrt     _sqrt\n    #define strcat   _strcat\n    #define strchr   _strchr\n #define strcmp   _strcmp\n    #define strcpy   _strcpy\n    #define strlen   _strlen\n    #define strncat  _strncat\n    #define strncpy  _strncpy\n    #define strstr   _strstr\n    #define strtol   _strtol\n    #define tan      _tan\n    #define write    _write\n\n    #define __errno_location ___error\n```", "```\n// aoaa.inc (cont.)\n//\n// lea (Load Effective Address) macro.\n// Correctly loads the address of\n// a memory object into a register, even\n// on machines that use position-independent\n// executables (PIE):\n\n.macro  lea, reg, mem\n    adrp    \\reg,\\mem@PAGE\n    add     \\reg, \\reg, \\mem@PAGEOFF\n.endm\n```", "```\n// aoaa.inc (cont.)\n//\n// mstr Assembles to a str instruction under macOS\n// mstrb\n// mstrh\n\n.macro      mstr, operands:vararg\nstr         \\operands\n.endm\n\n.macro      mstrb, operands:vararg\nstrb        \\operands\n.endm\n\n.macro      mstrh, operands:vararg\nstrh        \\operands\n```", "```\n// aoaa.inc (cont.)\n//\n// macOS's assembler doesn't have .dword,\n// define it here:\n\n.macro  .dword, value:vararg\n    .quad   \\value\n.endm\n```", "```\n// aoaa.inc (cont.)\n//\n// Macros to load parameters 2..8 onto\n// the stack for macOS when calling\n// a variadic (variable parameter list)\n// function, such as printf().\n//\n// Note that parameter 1 still goes into X0.\n\n.macro  vparm2, mem\nlea     x1, \\mem\nldr     x1, [x1]\nstr     x1, [sp]\n.endm\n\n.macro  vparm3, mem\nlea     x2, \\mem\nldr     x2, [x2]\nstr     x2, [sp, #8]\n.endm\n\n.macro  vparm4, mem\nlea     x3, \\mem\nldr     x3, [x3]\nstr     x3, [sp, #16]\n.endm\n\n.macro  vparm5, mem\nlea     x4, \\mem\nldr     x4, [x4]\nstr     x4, [sp, #24]\n.endm\n\n.macro  vparm6, mem\nlea     x5, \\mem\nldr     x5, [x5]\nstr     x5, [sp, #32]\n.endm\n\n.macro  vparm7, mem\nlea     x6, \\mem\nldr     x6, [x6]\nstr     x6, [sp, #40]\n.endm\n\n.macro  vparm8, mem\nlea     x7, \\mem\nldr     x7, [x7]\nstr     x7, [sp, #48]\n.endm        .endm\n```", "```\n// aoaa.inc (cont.)\n\n#elif isLinux == 1\n\n    // Do Linux (no-PIE)-specific stuff here:\n\n    .macro  lea, reg, mem\n        adrp    \\reg,\\mem\n        add     \\reg, \\reg, :lo12:\\mem\n    .endm\n\n    // mstr  assembles to nothing under Linux\n    // mstrb\n    // mstrh\n\n    .macro      mstr, operands:vararg\n    .endm\n\n .macro      mstrb, operands:vararg\n    .endm\n\n    .macro      mstrh, operands:vararg\n    .endm\n\n    .macro  vparm2, mem\n    lea     x1, \\mem\n    ldr     x1, [x1]\n    .endm\n\n    .macro  vparm3, mem\n    lea     x2, \\mem\n    ldr     x2, [x2]\n    .endm\n\n    .macro  vparm4, mem\n    lea     x3, \\mem\n    ldr     x3, [x3]\n    .endm\n\n    .macro  vparm5, mem\n    lea     x4, \\mem\n    ldr     x4, [x4]\n    .endm\n\n    .macro  vparm6, mem\n    lea     x5, \\mem\n    ldr     x5, [x5]\n    .endm\n\n    .macro  vparm7, mem\n    lea     x6, \\mem\n    ldr     x6, [x6]\n    .endm\n\n    .macro  vparm8, mem\n    lea     x7, \\mem\n    ldr     x7, [x7]\n    .endm\n\n#endif      #endif\n```", "```\n// aoaa.inc (cont.)\n//\n// Global declarations:\n\n.global asmMain\n.global getTitle\n.global readLine\n.global printf\n```", "```\n// aoaa.inc (cont.)\n//\n// Generic code for all OSes:\n\n// Gas doesn't have a .qword\n// directive. Map .qword to .octa:\n\n.macro  .qword, value:vararg\n    .octa   \\value\n.endm\n```", "```\n// aoaa.inc (cont.)\n//\n// Macros for structure definitions:\n\n__inStruct          = 0\n__inArgs            = 0\n__inLocals          = 0\n__dir               = 1\n```", "```\n// aoaa.inc (cont.)\n\n                ❶ .macro  struct  name, initialOffset=0\n__inStruct          = 1\n__inLocals          = 0\n__inArgs            = 0\n__struct_offset     = \\initialOffset\n\\name\\().base       = \\initialOffset\n__dir               = 1\n                    .if     \\initialOffset > 0\n                    .err\n                    error   struct offset must be negative or 0\n                    .endif\n                    .endm\n\n                ❷ .macro  args  name, initialOffset=16\n__inStruct          = 0\n__inLocals          = 0\n__inArgs            = 1\n__struct_offset     = \\initialOffset\n\\name\\().base       = \\initialOffset\n__dir               = 1\n                    .endm\n                ❸ .macro  locals  name\n__inStruct          = 0\n__inLocals          = 1\n__inArgs            = 0\n__struct_offset     = 0\n__dir               = -1\n                    .endm\n```", "```\n// aoaa.inc (cont.)\n\n                    .macro  salign, size\n__salign        = 0xFFFFFFFFFFFFFFFF - ((1 << \\size)-1)\n__struct_offset = (__struct_offset + (1 << \\size)-1) & __salign\n                    .endm\n```", "```\n// aoaa.inc (cont.)\n\n                    .macro  byte, name, elements=1\n                    .if     __dir > 0\n\\name               =       __struct_offset\n__struct_offset     =       __struct_offset + \\elements\n                    .else\n__struct_offset     =       __struct_offset + \\elements\n\\name               =       -__struct_offset\n                    .endif\n                    .endm\n\n                    .macro  hword, name, elements=1\n .if     __dir > 0\n\\name               =       __struct_offset\n__struct_offset     =       __struct_offset + ((\\elements)*2)\n                    .else\n__struct_offset     =       __struct_offset + ((\\elements)*2)\n\\name               =       -__struct_offset\n                    .endif\n                    .endm\n\n                    .macro  word, name, elements=1\n                    .if     __dir > 0\n\\name               =       __struct_offset\n__struct_offset     =       __struct_offset + ((\\elements)*4)\n                    .else\n__struct_offset     =       __struct_offset + ((\\elements)*4)\n\\name               =       -__struct_offset\n                    .endif\n                    .endm\n\n                    .macro  dword, name, elements=1\n                    .if     __dir > 0\n\\name               =       __struct_offset\n__struct_offset     =       __struct_offset + ((\\elements)*8)\n                    .else\n__struct_offset     =       __struct_offset + ((\\elements)*8)\n\\name               =       -__struct_offset\n                    .endif\n                    .endm\n\n                    .macro  qword, name, elements=1\n                    .if     __dir > 0\n\\name               =       __struct_offset\n__struct_offset     =       __struct_offset + ((\\elements)*16)\n                    .else\n__struct_offset     =       __struct_offset + ((\\elements)*16)\n\\name               =       -__struct_offset\n                    .endif\n                    .endm\n\n                    .macro  oword, name, elements=1\n                    .if     __dir > 0\n\\name               =       __struct_offset\n__struct_offset     =       __struct_offset + ((\\elements)*32)\n                    .else\n__struct_offset     =       __struct_offset + ((\\elements)*32)\n\\name               =       -__struct_offset\n                    .endif\n                    .endm\n\n                    .macro  single, name, elements=1\n                    .if     __dir > 0\n\\name               =       __struct_offset\n__struct_offset     =       __struct_offset + ((\\elements)*4)\n                    .else\n__struct_offset     =       __struct_offset + ((\\elements)*4)\n\\name               =       -__struct_offset\n                    .endif\n                    .endm\n\n                    .macro  double, name, elements=1\n                    .if     __dir > 0\n\\name               =       __struct_offset\n__struct_offset     =       __struct_offset + ((\\elements)*8)\n                    .else\n__struct_offset     =       __struct_offset + ((\\elements)*8)\n\\name               =       -__struct_offset\n                    .endif\n                    .endm\n```", "```\n// aoaa.inc (cont.)\n//\n// Generate name.size and name.offset constants\n// specifying total structure size and the offset\n// just beyond the last field.\n//\n// Also create a macro to be used to declare\n// structure variables.\n\n                    .macro ends, name\n__inStruct          =      0\n\\name\\().size       =      __struct_offset-\\name\\().base\n\\name\\().offset = __struct_offset\n                    .macro  \\name, varName\n                    .if     \\name\\().base < 0\n                    .space  __struct_offset-(\\name\\().base)\n                    .endif\n\\varName:\n                    .if     __struct_offset > 0\n                    .fill   __struct_offset\n                    .endif\n\n                    .endm\n                    .endm\n                    .macro enda, name\n__inArgs            =      0\n\\name\\().size       =      __struct_offset-\\name\\().base\n                    .endm\n\n                    .macro endl, name\n__inLocal           =      0\n\\name\\().size       =      __struct_offset\n                    .endm\n```", "```\n// aoaa.inc (cont.)\n//\n// Macro to emit a string that is padded with bytes\n// so that it consumes a multiple of 4 bytes in memory:\n\n                    .macro   wastr, theStr\n                    .asciz   \"\\theStr\"\n                    .p2align 2\n                    .endm\n```", "```\n// aoaa.inc (cont.)\n//\n// Macros for declaration procedures/functions:\n\npublic              =       1\n                    .macro  proc pName:req, isPublic=0\n\n// If \"public\" argument is present, emit\n// global statement.\n\n                    .if     \\isPublic\n                    .global _\\pName\n                    .global \\pName\n                    .endif\n\n\\pName\\().isOpenProcDCL = 1\n\\pName:\n_\\pName:\n                    .endm\n\n .macro  endp pName:req\n                    .ifndef \\pName\\().isOpenProcDCL\n                    .err\n                    .err    \"Not an open procedure\"\n                    .else\n                    .if     \\pName\\().isOpenProcDCL\n                    .else\n                    .err\n                    .err    \"endp name does not match last proc name\"\n                    .endif\n                    .endif\n\\pName\\().isOpenProcDCL = 0\n                    .endm\n```", "```\n// aoaa.inc (cont.)\n//\n// Sanity for ARM code:\n\n                    .macro  .code\n                    .text\n                    .align  2\n                    .endm\n```", "```\n// aoaa.inc (cont.)\n//\n// Assembly standard entry sequence:\n\n    .macro  enter, localsSize\n    stp     fp, lr, [sp, #-16]!\n    mov     fp, sp\n    .if     \\localsSize > 0\n    sub     sp, sp, #((\\localsSize)+15) & 0xFFFFFFFFFFFFFFF0\n    .endif\n    .endm\n\n// Assembly standard exit sequence:\n\n    .macro  leave\n    mov     sp, fp\n ldp     fp, lr, [sp], #16\n    ret\n    .endm\n```", "```\n// aoaa.inc (cont.)\n//\n// goto\n//\n// Transfers control to the specified label\n// anywhere in the 64-bit address space:\n\n            .macro  goto, destination\n            adr     x16, 0f\n            ldr     x17, 0f\n            add     x16, x16, x17\n            br      x16\n0:\n            .dword  \\destination-0b\n            .endm\n```", "```\n// aoaa.inc (cont.)\n//\n// getErrno\n//\n// Retrieves C errno value and returns\n// it in X0:\n\n            .extern __errno_location\n            .macro  getErrno\n            bl      __errno_location\n            ldr     w0, [x0]\n            .endm\n```", "```\n// aoaa.inc (cont.)\n//\n// Constants to use in the immediate field of\n// ccmp:\n\n//          NZCV\n    .equ    ccne,   0b0000          // Z = 0\n    .equ    cceq,   0b0100          // Z = 1\n    .equ    cchi,   0b0010          // C = 1\n    .equ    cchs,   0b0110          // Z = 1, C = 1\n    .equ    cclo,   0b0000          // Z = 0, C = 0\n    .equ    ccls,   0b0100          // Z = 1, C = 0\n    .equ    ccgt,   0b0000          // Z = 0, N = V\n    .equ    ccge,   0b0100          // Z = 1, N = V\n    .equ    cclt,   0b0001          // Z = 0, N! = V\n    .equ    ccle,   0b0101          // Z = 1, N! = V\n\n    .equ    cccs,   0b0010          // C = 1\n    .equ    cccc,   0b0000          // C = 0\n    .equ    ccvs,   0b0001          // V = 1\n    .equ    ccvc,   0b0000          // V = 0\n    .equ    ccmi,   0b1000          // N = 1\n    .equ    ccpl,   0b0000          // N = 0\n\n    .equ    ccnhi,  0b0100          // Not HI = LS, Z = 1, C = 0\n    .equ    ccnhs,  0b0000          // Not HS = LO, Z = 0, C = 0\n    .equ    ccnlo,  0b0110          // Not LO = HS, Z = 1, C = 1\n    .equ    ccnls,  0b0010          // Not LS = HI, C = 1\n\n    .equ    ccngt,  0b0101          // Not GT = LE, Z = 1, N! = V\n    .equ    ccnge,  0b0001          // Not GE = LT, Z = 0, N! = V\n    .equ    ccnlt,  0b0100          // Not LT = GE, Z = 1, N = V\n    .equ    ccnle,  0b0000          // Not LE = GT, Z = 0, N = V\n```", "```\n// aoaa.inc (cont.)\n//\n// Opposite conditions (useful with all conditional instructions)\n\n#define nhi ls\n#define nhs lo\n#define nlo hs\n#define nls hi\n#define ngt le\n#define nge lt\n#define nlt ge\n#define nle gt\n\n// Opposite branches\n\n        .macro  bnlt, dest\n        bge     \\dest\n        .endm\n\n        .macro  bnle, dest\n        bgt     \\dest\n        .endm\n\n        .macro  bnge, dest\n        blt     \\dest\n        .endm\n\n        .macro  bngt, dest\n        ble     \\dest\n        .endm\n\n        .macro  bnlo, dest\n        bhs     \\dest\n        .endm\n\n        .macro  bnls, dest\n        bhi     \\dest\n        .endm\n\n        .macro  bnhs, dest\n        blo     \\dest\n        .endm\n\n        .macro  bnhi, dest\n        bls     \\dest\n        .endm\n#endif // aoaa_inc\n```", "```\n// Variant of the proc macro that deals\n// with procedures that have varying\n// parameter lists. This macro creates\n// a macro named \"_`name`\" (where `name` is\n// the procedure name) that loads all\n// but the first parameters into registers\n// X1..X7 and stores those values onto\n// the stack.\n//\n// Limitation: maximum of seven arguments\n\n        .macro  varProc pName:req\n\n// Create a macro specifically for this func:\n\n        .macro  _\\pName parms:vararg\nreg     =       1\n        .irp    parm, \\parms\n        .irpc   rnum, 1234567\n        .if     reg==\\rnum\n        lea     x\\rnum, \\parm\n        ldr     x\\rnum, [x\\rnum]\n        mstr    x\\rnum, [sp, #(reg-1)*8]\n        .endif\n        .endr\nreg     =       reg + 1\n        .endr\n        bl      \\pName\n        .endm\n\n// Finish off the varProc macro (just like\n// the proc macro from aoaa.inc):\n\n\\pName\\().isOpenProcDCL = 1\n\\pName:\n        .endm\n```", "```\n// Demonstrate the varProc macro\n// (creates a macro name _someFunc\n// that will load parameters and\n// then branch to printf):\n\n        varProc someFunc\n        b       printf\n        endp    someFunc\n```", "```\n .macro _someFunc, parms:vararg\nreg     =       1\n        .irp    parm, \\parms\n        .irpc   rnum, 1234567\n        .if     reg==\\rnum\n        lea     x\\rnum, \\parm\n        ldr     x\\rnum, [x\\rnum]\n        mstr    x\\rnum, [sp, #(reg-1)*8]\n        .endif\n        .endr\nreg     =       reg + 1\n        .endr\n        bl      someFunc\n        .endm\n```", "```\n lea x0, fmtStr\n    _someFunc i, j\n```", "```\n lea x0, fmtStr\n\n// Macro expansion:\n\n    lea x1, i\n    ldr x1, [x1]\n    lea x2, j\n    ldr x2, [x2]\n    bl  someFunc\n```", "```\n.macro  createdMacro\n  `Empty body`\n.endm\n\n.macro  createMacro\n\n.purgem createdMacro\n.macro  createdMacro\n\n  `Macro body`\n\n.endm // createdMacro\n  .\n  .\n  .\n.endm\n```", "```\nmov x0, #cppMacro(0, x)\n```", "```\nlea x0, someLabel  // Expands to two instructions!\n```", "```\n#define aStr \"Hello, World!\"       // This works.\n//      .set aStr, \"Hello, World!\" // This does not.\n\n        .asciz aStr\n```", "```\n// #define a (a+1)  // Generally doesn't work as expected\n    .set a, a+1     // Works fine (assuming some previous definition of a)\n```", "```\na:   .byte 0\n      .\n      .\n      .\n#ifdef a    // a is undefined to CPP; it's a Gas symbol.\n .\n .\n .\n#endif\n\n .ifdef a  // a is defined to Gas's conditional assembly.\n     .\n     .\n     .\n    .endif\n```"]