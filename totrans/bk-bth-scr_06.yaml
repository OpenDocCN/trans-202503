- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 5 STRING AND BOOLEAN DATA TYPES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first thing to learn about assigning data types in Batch is that Batch doesn’t
    allow for the assignment of data types. There’s no underlying egalitarian ethos
    at play, but all Batch variables are created equal. Intrinsically, there’s no
    difference between a variable holding a number, text, or even a boolean. However,
    a variable set to a number can be treated as numeric, and I’ll focus on those
    data types in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, after an overview of all Batch data types, you’ll learn about
    string and character variables. You’ll also explore strings further with methods
    for substringing and text replacement. Booleans were not devised by the creators
    of Batch, but I’ll show you how to build and use this useful data type.
  prefs: []
  type: TYPE_NORMAL
- en: Common Data Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many if not most programming languages not only allow but also require every
    variable to be declared as a specific data type before it can be assigned a value
    or used in any fashion. There are variations from language to language, but here’s
    a general list of data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Character**    Single alphanumeric character'
  prefs: []
  type: TYPE_NORMAL
- en: '**String**    Zero to many alphanumeric characters'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer**    Positive and negative whole numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '**Floating-point**    Numbers with a decimal place'
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean**    True or false'
  prefs: []
  type: TYPE_NORMAL
- en: For better or worse, Batch variables aren’t declared. One comes into being ex
    nihilo the first time the interpreter discovers a new variable name. This practice
    does allow for a great deal of flexibility, but it can be tricky and dangerous.
    One misspelled instance of a variable name used a dozen times is considered to
    be an entirely different variable by the interpreter, and the mistake will not
    be caught by the guiding hand of a compiler. Instead, it’s treated as a new variable
    that’ll likely resolve to nothing.
  prefs: []
  type: TYPE_NORMAL
- en: A variable can be assigned an integer, and arithmetic can be performed on it.
    That same variable can then be assigned text and treated like a string. That also
    means that arithmetic can inadvertently be performed on a variable containing
    a string, but on the upside, a number can easily be treated as a string without
    any type of conversion when written to the console or a report. It’s pure digital
    anarchy, a coding language for nihilists, and somehow it works.
  prefs: []
  type: TYPE_NORMAL
- en: Even though you can’t assign data types, you can create variables and treat
    them as one of the types, but—and I cannot stress this enough—the underlying structure
    of every Batch variable is really just a few nondescript bytes of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A character is merely a single byte of text; in the world of Batch, think of
    it as a very short string, as it’s treated exactly like any other single-character
    string. I’ll keep this section short and move on to strings.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A string is text of any length, containing alphabetic characters, numbers,
    and/or special characters. The following command sets the aString variable to
    a five-word string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Including embedded spaces, its length totals 35 characters or, in the parlance
    of coders, bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many special characters, such as the dollar and pound signs, can be explicitly
    included in the string, but others, such as the percent sign, cannot, because
    they have specific uses in Batch. In [Chapter 14](chapter14.xhtml), I’ll address
    how escaping allows for the inclusion of all characters in a string, but for now,
    understand that the interpreter won’t abort when it comes upon an exclamation
    mark in a string, but you might not see your expected result. For instance, the
    last character in the value being assigned to this variable is an exclamation
    mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result of the echo command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The punctuation mark isn’t written to the console because it wasn’t included
    in the string variable.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*As mentioned in [Chapter 3](chapter3.xhtml), I’m assuming that delayed expansion
    is enabled throughout this book. This example is a great case in point, because
    if delayed expansion had been disabled, the exclamation mark would’ve been just
    another character, not a delimiter used to resolve a variable. The character would’ve
    been included as part of the value and would’ve been written to the console with
    the rest of the text. Being able to treat an exclamation mark as simple text might
    be the only advantage of disabling delayed expansion. This trivial advantage pales
    in comparison to the functionality afforded by delayed expansion, which is why
    I recommend its universal use.*'
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, I’ll discuss how to write strings and other data types to
    files, but here I’ll explain how to build, concatenate, substring, and manipulate
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: Build and Concatenate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The previous example used a single set command to assign the value Awesome
    Batch Code Dares Excellence to a variable. The following six lines perform the
    same task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In practice, this method would be horribly inefficient for building a string,
    but it nicely demonstrates the principle of concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: The variables defined by the first five letters of the alphabet are each set
    to a single word. Then on the last line all five variables are resolved and concatenated
    together to create aString. Take note of the four embedded spaces in the result.
    One is from the trailing space after Batch, another is from the leading space
    before Excellence, and the other two are embedded in the last set command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example shows how to create a string by concatenating other strings,
    but you can also append or prepend an existing string with other text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here a string is being appended with additional text four times to create a
    very long string.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is my preference for creating long string variables, but you can
    do the same task with the “continuation character” or caret (^). When the interpreter
    comes to a caret at the end of a line, it appends to that line the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, three carets are used to make a four-line set command. The
    first and third lines have a space in front of the caret, and their following
    lines start in the first byte, resulting in a space between the words. To demonstrate
    a different means of doing the same thing, the second caret immediately follows
    the word way, and the next line has a space prior to the next word, over. The
    upshot is a long string of words, all separated by a single space.
  prefs: []
  type: TYPE_NORMAL
- en: I am not a fan of this technique for the simple reason that it plays havoc with
    my indentation scheme. I indent most commands two or more spaces, as the first
    line of the set command shows, but any spaces at the beginning of the subsequent
    line are considered part of the appended text. This effectively means that these
    lines must be left-justified. I’ll delve into indenting schemes further in [Chapter
    9](chapter9.xhtml). For now, just understand that it works—but it’s ugly.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I put “continuation character” in quotes because this is a gross simplification.
    The caret is really an escape character. In [Chapter 14](chapter14.xhtml), I’ll
    explain why that matters, but many Batch coders simply refer to it as the* continuation
    character*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Substrings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Any language worth its salt will support a substringing function that retrieves
    a portion of a string, and Batch is up to the task. For the next few examples,
    let’s consider the aString variable being set just as it was earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A *substringing function* needs two numbers, the offset or starting position
    and the length of the desired text. Surprisingly, Batch uses the zero-offset that
    predominates more modern languages and not the one-offset more common of 20th-century
    languages. This means the first byte is position 0 (not 1), the second byte is
    position 1, the 100th byte is position 99, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax to substring is a bit clunky. The variable is resolved with percent
    signs as is typical, but the closing percent sign is preceded with a colon, a
    tilde, the offset, a comma, and ultimately the length. Hence, the following syntax
    returns the first three characters of the aString variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The offset of 0 tells the interpreter to start with the first byte and the length
    is defined as 3, resulting in the text Awe being assigned to subString.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following extracts the text some out of the first word of the same string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We need to start in the fourth byte, which is a zero-offset of 3. If you find
    the zero-offset confusing, think of the offset as the number of bytes *before*
    the substring. More obviously, the length is 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two substrings put together with a hardcoded to and a couple spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The 15th byte is the capital C in Code, so the first substring is the remaining
    three bytes of the word. The eighth byte is the space before Batch, so the next
    five bytes encompass that entire word. The result is an apt, if not corny, reinterpretation
    of the original string: ode to Batch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the length isn’t defined, the interpreter returns the remainder of the string.
    To demonstrate, the following substring has no length and no preceding comma.
    The offset corresponds to the 25 bytes preceding the last word in the 35-byte
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The upshot is that subString is assigned the string Excellence, the last 10
    bytes of the original string.
  prefs: []
  type: TYPE_NORMAL
- en: Negative Offsets
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Notice the negative offset in the following example. Interestingly, this also
    assigns Excellence to the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A *negative offset* indicates that the starting position is relative to the
    end of the string, not the beginning, which means -10 tells the interpreter that
    the substring is to start 10 bytes from the end of the string. Since no length
    is given, it returns the remainder of the text. As long as the variable is populated,
    %aString:~-1% is an easy way to inspect its last byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these commands result in the same ode substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first command’s offset is 15 bytes from the start of the original string,
    while the second command finds the same position by counting 20 bytes from the
    end of the 35-byte variable.
  prefs: []
  type: TYPE_NORMAL
- en: Negative Lengths
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A negative length works in a similar fashion. Don’t think of it as a *length*;
    think of it as the number of bytes at the end of the string *not* in the substring.
    For instance, the following returns a string with the first and last bytes stripped
    off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even use negative offsets with negative lengths. The following extracts
    the penultimate byte of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The offset of -2 tells the interpreter to start with the second to last byte,
    and the length of -1 indicates that the last byte is dropped.
  prefs: []
  type: TYPE_NORMAL
- en: Substring in Practice
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One nice feature of retrieving a substring in Batch is that a null is simply
    returned if calling for a substring beyond the length of the string. Thus, the
    interpreter won’t crash when it comes upon %aString:~99,1% for the 35-byte string,
    nor will it return a space. Instead, it returns only an empty string. It’s a handy
    way of determining the length of a string with no fear of the null pointer exceptions
    prevalent in compiled code. If the 36th byte equals null (that is, "%aString:~35,1%"
    equ "") but the 35th byte is populated, the string is exactly 35 bytes in length.
  prefs: []
  type: TYPE_NORMAL
- en: However, this syntax works only when substringing a populated string. As I just
    mentioned, the resolution of %aString:~35,1% is null if the string is between
    1 and 35 bytes in length, and of course, it resolves to the 36th byte if the string
    is 36 bytes or longer. But if the string is empty or set to null, %aString:~35,1%
    resolves to ~35,1, or everything between the colon and trailing delimiter. Likewise
    due to this batveat, when trying to inspect the last byte of an empty string,
    %aString:~-1% resolves to ~-1, not the null you may have expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'You now know how to extract any portion of a string from another string, but
    all of the offsets and lengths are hardcoded in the earlier examples. Often, if
    not most of the time, those two numbers will be variables. In the following example,
    the offset and length are defined as obviously named variables and used in the
    third command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The percent signs encasing offset and length first resolve these variables to
    their numeric values. Then the exclamation marks kick in so that !aString:~15,3!
    resolves to our familiar ode, which is yet another victory for enabling delayed
    expansion.
  prefs: []
  type: TYPE_NORMAL
- en: After finishing the next chapter, where I discuss arithmetic, you’ll be able
    to calculate variables holding integer values to be used as offsets and lengths
    to find a substring.
  prefs: []
  type: TYPE_NORMAL
- en: Text Replacement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Batch also has a handy mechanism for replacing all or part of a string with
    other text. For example, assume that the following variable contains this awkward
    filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you aren’t fond of this filename, you could change the underscores to dashes.
    In [Chapter 7](chapter7.xhtml), I’ll introduce the ideal command for renaming
    a file, but here I’ll discuss how to build a variable containing the new filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text replacement syntax is similar to what was used for substringing. The
    variable and a colon are surrounded by percent signs as before, but now there’s
    no tilde. Instead, after the colon comes the text to search for and change, followed
    by an equal sign delimiter, and finally the replacement text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Each and every underscore character (_), not just the first one encountered,
    is changed to a dash (-), resulting in File-Name-With-Underscores.docx. Be careful
    not to change more text than you intend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at this filename, it also would make sense to change the word Underscores
    to Dashes. Fortunately, Batch doesn’t require that the target and replacement
    text be the same length, so this additional command further updates the value
    of this variable to File-Name-With-Dashes.docx:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since both words end in es, I’m using the singular Dash as the replacement text,
    and the target text is underscor, which isn’t even a real word. Also, notice that
    Underscores is capitalized in the variable’s value, but underscor is lowercase
    in the replace syntax. Very important, Batch does a case-insensitive replacement.
    The target text can be whichever case or even mixed case with no effect on the
    outcome, but the replacement text will be used exactly as it is entered in the
    command. Hence, %newFilNm:UNDERscor=Dash% is functionally identical to the variable
    resolution in the previous command, but %newFilNm:underscor=DASH% would result
    in a new filename of File-Name-With -DASHes.docx.
  prefs: []
  type: TYPE_NORMAL
- en: It’s subtle, but the prior two commands show two distinct methods of assignment.
    The first assigns the modified value of filNm to newFilNm, leaving filNm unchanged.
    The second command reassigns newFilNm to itself so that its ultimate value reflects
    both text replacements. These two methods give you the flexibility to either alter
    a variable’s value in place or maintain two variables, one with the old and one
    with the new text.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use delayed expansion to turn the target text, targ, and the replacement
    text, repl, into variables. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The result is the far more honest string I Hate Broccoli.
  prefs: []
  type: TYPE_NORMAL
- en: 'A text search is one wonderful application of the text replacement syntax.
    In [Chapter 24](chapter24.xhtml), I’ll compare and contrast two methods of determining
    whether one string is part of another string. The findstr command works well,
    but the method based on the previous syntax executes in a fraction of the time.
    Spoiler alert: the text search logic replaces the searched for text with null,
    and the result is compared to the original text. If they differ, the text was
    found.'
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Booleans are ever-present in compiled languages having two, and *only* two,
    possible states: true or false. Once set, you can use them alone as the conditional
    clause in an if command to be evaluated as true or false, thus determining whether
    a block of code should be executed. Batch doesn’t support booleans explicitly,
    but with a little ingenuity, you can create them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Much ink has been spilled exploring the question, “Does God exist?” This isn’t
    one of those books, but we can answer a far easier question, “Does *God.txt* exist?”
    In [Chapter 4](chapter4.xhtml), I showed how to use an if command to determine
    the existence or nonexistence of a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A variable is being set to Found or NotFound based on the status of the file
    at a certain instant in time. The god variable can then be interrogated in the
    future to determine whether *God.txt* existed at that earlier time. It works,
    but it’s a bit clunky; a boolean would provide a more elegant solution. You could
    then easily reference the boolean as many times as is necessary throughout the
    code and maybe even reset it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and Evaluating Booleans
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Batch, a boolean, like all variables, is really just some text, but text
    that can be evaluated as true or false. As a convention, I always prefix boolean
    variable names with a lowercase b followed by an uppercase character to make it
    stand out as a boolean. (A more verbose and descriptive option is to lead with
    the bool text.) Let’s duplicate the logic in the previous example with the only
    difference being that the clunky variable god is replaced with the boolean, bGod,
    which gets set to true if *God.txt* is found and false if it isn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In other languages, a boolean is explicitly set to true or false. For instance,
    a valid Java command is bGod = true;. But the previous set commands for the Batch
    boolean look a bit different; in particular, each has three equal signs. The first
    is simply for the assignment; the other two are a portion of the assigned value.
    When the conditional clause of the if command is true, we set bGod to true==true;
    if not, false==x is the value. That certainly looks odd, but now the variable,
    while still technically nothing but text, can be evaluated as the conditional
    clause of another if command like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: But how? If bGod had been set to what we consider true, the interpreter resolves
    if %bGod% to if true == true. The variable contains an equality operator, double
    equal signs, with identical values on either side. (Don’t ask about the spaces
    around the operator, but this is what the interpreter sees.) Put all of this after
    an if command, and it evaluates to true.
  prefs: []
  type: TYPE_NORMAL
- en: If the variable had been set to what we consider false, however, the command
    would’ve been resolved to if false == x, which compares two values that clearly
    differ, resulting in the code after the if command not to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The if command with a boolean can also be used with the not clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If the text, if not %bGod%, resolves to if not true == true, the result of the
    evaluation is *not true* or false. But when the text resolves to the double negative
    if not false == x, it evaluates to *not false* or true, and the text is written
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Booleans to Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ve chosen true==true as the value for true, but x==x or 0 == 0 would’ve worked
    and required fewer keystrokes. Even false==false would evaluate to true, but let’s
    not be difficult. Likewise, false==x could’ve contained any two differing strings,
    but I chose these values so that either the text true or false is at the forefront
    of the boolean value. The structure of the boolean variable allows you to mimic
    another feature of booleans in compiled code—the conversion of the boolean to
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'As structured, you can convert Batch booleans to the string true or false by
    simply stripping off everything after and including the two equal signs. When
    we get to the for command in [Chapter 19](chapter19.xhtml), I’ll show exactly
    how that works, but for now, the following line of code truncates the extraneous
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After this executes against a valid boolean, the *boolean string* variable named
    bStrGod will contain either true or false.
  prefs: []
  type: TYPE_NORMAL
- en: (If boolean variables are prefixed with b, it might make sense to prefix boolean
    string variables with bs, but the convention that I’ve settled on heads off accusations
    of my code being full of BS.)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strings are ubiquitous in Batch, and in this chapter, I detailed how to build
    and concatenate them. Substringing and text replacement are two powerful and useful
    tools that all Batch coders should master, despite their esoteric syntaxes. Booleans
    are not so ubiquitous, but I hope that I demonstrated the usefulness of this underused
    data type.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll continue the discussion on data types, delving into
    the numeric data types. I’ll detail integers of three different bases and floating-point
    numbers, providing a great opportunity to explore how arithmetic is tackled in
    Batch.
  prefs: []
  type: TYPE_NORMAL
