<html><head></head><body>
<h2 class="h2" id="ch24"><span epub:type="pagebreak" id="page_609"/><span class="big"><strong>24</strong></span><br/><strong>GOING FURTHER WITH THE GRAMMAR OF GRAPHICS</strong></h2>&#13;
<div class="image"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">You covered the basics of the <code>ggplot2</code> package—which offers an alternative to traditional R graphics—in <a href="ch07.xhtml#ch07lev1sec26">Section 7.4</a> and throughout <a href="ch14.xhtml#ch14">Chapter 14</a>. In this chapter, you’ll look at a couple of this package’s more popular and useful features, as well as its relatively young cousin, <code>ggvis</code>, which provides an interactive, browser-based experience.</p>&#13;
<h3 class="h3" id="ch24lev1sec82"><strong>24.1 ggplot or qplot?</strong></h3>&#13;
<p class="noindentb">So far when creating the relatively simple <code>ggplot2</code> graphics, you’ve used the <code>qplot</code> function to initialize the visual object. In fact, the more general <code>ggplot</code> command is the core function of <code>ggplot2</code>. There are several key differences between these two initialization functions:</p>&#13;
<p class="bull">• <code>qplot</code> is a shortcut version of <code>ggplot</code>; it’s used if you just want a quick look at your data or if you’re working directly in the R console.</p>&#13;
<p class="bull"><span epub:type="pagebreak" id="page_610"/>• <code>qplot</code> is designed to be reminiscent of the base R <code>plot</code> function—you pass it <em>x</em>- and <em>y</em>-coordinate vectors and then tell it what to do. By contrast, <code>ggplot</code> prefers its data argument as a data frame object, and you tell it what to do by explicitly adding geom layers.</p>&#13;
<p class="bull">• A call to <code>qplot</code> alone can produce a graphic. When using <code>ggplot</code>, layers have to be added before anything becomes visible.</p>&#13;
<p class="bull">• To access the full power and flexibility of <code>ggplot2</code> graphics, <code>ggplot</code> is the recommended function; this comes at the cost of providing a little more explicit instruction than <code>qplot</code> requires.</p>&#13;
<p class="indentt">All in all, you can create most plots using either <code>qplot</code> or <code>ggplot</code>. Many users make the decision based on the form their data are in (in other words, a data frame or as separate vectors in the global environment) and whether they want polished visuals (for example, for publication purposes) or just a quick look at the data while working directly in the console.</p>&#13;
<p class="indent">As a quick example of the difference in syntax, flip back to the code on <a href="ch14.xhtml#page_297">page 297</a> used to create the histogram on the right of <a href="ch14.xhtml#ch14fig5">Figure 14-5</a>. You could argue that the numerous modifications made to that particular plot warrant a more compartmentalized approach than <code>qplot</code> offers. Load <code>ggplot2</code> with a call to <code>library("ggplot2")</code> and create the following three objects:</p>&#13;
<pre>R&gt; gg.static &lt;- ggplot(data=mtcars,mapping=aes(x=hp)) +<br/>                    ggtitle("Horsepower") + labs(x="HP")<br/>R&gt; mtcars.mm &lt;- data.frame(mm=c(mean(mtcars$hp),median(mtcars$hp)),<br/>                           stats=factor(c("mean","median")))<br/>R&gt; gg.lines &lt;- geom_vline(mapping=aes(xintercept=mm,linetype=stats),<br/>                          show.legend=TRUE,data=mtcars.mm)</pre>&#13;
<p class="indent">The first object, <code>gg.static</code>, represents the part of the plot that will stay the same throughout, say, if you wanted to experiment with adding other features later. Note that the call to <code>ggplot</code> differs from <code>qplot</code> in that the first argument is the entire data frame of interest, allowing access to all data columns within the frame for any subsequent geoms or annotations. You then add the <code>ggtitle</code> and <code>labs</code> functions to set the main title and the horizontal axis title. The second object, <code>mtcars.mm</code>, stores the horsepower mean and median as a “dummy” data frame. The mean and median lines are then superimposed on the histogram by the third object, <code>gg.lines</code>, which is a single call to the <code>geom_vline</code> function with the same content used in the earlier code, albeit in a slightly modified form to stay true to the initial use of <code>ggplot</code>.</p>&#13;
<p class="indent">Nothing is displayed until you make a call that prints the <code>ggplot2</code> object (as noted in <a href="ch07.xhtml#ch07lev1sec26">Section 7.4</a>). The following call reproduces the image on the right of <a href="ch14.xhtml#ch14fig5">Figure 14-5</a>:</p>&#13;
<pre>R&gt; gg.static + geom_histogram(color="black",fill="white",<br/>                              breaks=seq(0,400,25),closed="right") + gg.lines +<br/>               scale_linetype_manual(values=c(2,3)) + labs(linetype="")</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_611"/>The pieces are put together in much the same way as for the creation of <a href="ch14.xhtml#ch14fig5">Figure 14-5</a>: the addition of the <code>geom_histogram</code> layer to <code>gg.static</code> invokes the plot, and the addition of <code>gg.lines</code> with changes to the default line types made with <code>scale_linetype_manual</code> marks off the mean and median. If you wanted to produce the histogram without these lines, you would simply print the <code>gg.static</code> object plus <code>geom_histogram</code>.</p>&#13;
<p class="indent">As you get more experienced with <code>ggplot2</code>, you’ll find yourself leaning toward either <code>ggplot</code> or <code>qplot</code>, depending on the application. The help file in <code>?ggplot</code> provides a good description of the typical ways <code>ggplot</code> is used and how it stacks up against <code>qplot</code>. For further information, refer to <em>ggplot2: Elegant Graphics for Data Analysis</em> by Wickham (<a href="ref.xhtml#ref72">2009</a>). I’ll use <code>ggplot</code> for the rest of the plots in this chapter to provide some examples of the syntax of the <code>ggplot</code> command to compare with the earlier uses of <code>qplot</code>.</p>&#13;
<h3 class="h3" id="ch24lev1sec83"><strong>24.2 Smoothing and Shading</strong></h3>&#13;
<p class="noindent">Data visualization using the <code>ggplot2</code> package is particularly powerful when you want to split features of the plot by one or more categorical variables. This is especially apparent when you’re enhancing your plot with features that are more difficult to achieve using base R commands.</p>&#13;
<h4 class="h4" id="ch24lev2sec238"><strong><em>24.2.1 Adding LOESS Trends</em></strong></h4>&#13;
<p class="noindent">When you’re looking at raw data, it’s sometimes difficult to get an overall impression of trends without fitting a parametric model (for example, via linear regression), which means making assumptions about the nature of these trends. This is where <em>nonparametric smoothing</em> comes in—you can use certain methods to determine how your data appear to behave without fitting a specific model. These methods are a flexible aid for interpreting overall trends, whatever their form, but the trade-off is that you’re not provided with any specific numeric details of the relationships between response and predictors (since you’re not estimating any coefficients such as slopes or intercepts) and you lose any reliable ability to extrapolate.</p>&#13;
<p class="indent"><em>Locally weighted scatterplot smoothing (LOESS or LOWESS)</em> is a nonparametric smoothing technique that produces the smoothed trend by using regression methods on localized subsets of the data, step-by-step over the entire range of the explanatory variable.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For theoretical details, <a href="ch06.xhtml#ch06">Chapter 6</a> of</em> Applied Nonparametric Regression <em>(<a href="ref.xhtml#ref29">Härdle, 1990</a>), as well as <a href="ch02.xhtml#ch02">Chapters 2</a> and <a href="ch03.xhtml#ch03">3</a> of</em> Introduction to Nonparametric Regression <em>(<a href="ref.xhtml#ref64">Takezawa, 2006</a>), provide clear discussions of LOESS smoothers.</em></p>&#13;
</div>&#13;
<p class="indent">For an illustration, load the <code>MASS</code> package and return your attention to the <code>survey</code> data frame. First, create a new data frame object with any missing values deleted to avoid default warning messages:</p>&#13;
<pre>R&gt; surv &lt;- na.omit(survey[,c("Sex","Wr.Hnd","Height")])</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_612"/>Then, after loading <code>ggplot2</code>, execute the following to produce the image on the left of <a href="ch24.xhtml#ch24fig1">Figure 24-1</a>.</p>&#13;
<pre>R&gt; ggplot(surv,aes(x=Wr.Hnd,y=Height)) +<br/>       geom_point(aes(col=Sex,shape=Sex)) + geom_smooth(method="loess")</pre>&#13;
<p class="indent">The call to <code>ggplot</code> initializes the object and sets the default mapping of handspan on the <em>x</em>-axis and height on the <em>y</em>-axis. The addition of <code>geom_point</code> adds the points, using color and point type to differentiate between males and females. The addition of <code>geom_smooth</code> superimposes the LOESS smoother. By default, a 95 percent confidence interval for the estimated trend is marked off by a transparent gray-shaded area.</p>&#13;
<div class="image"><img src="../images/f24-01.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch24fig1"/>Figure 24-1: Showcasing</em> <code>ggplot2</code> <em>(left) and base R graphics (right) for display of nonparametrically estimated trends via LOESS</em></p>&#13;
<p class="indent">Now I’ll demonstrate how to produce a similar result using base R graphics. Although there are base R functions, such as <code>scatter.smooth</code>, that can produce a scatterplot with the smoothed trend relatively quickly, to be able to do things such as shade in the confidence interval region, it’s helpful to be able to build the plot up piece by piece. Compare the relative ease of the <code>ggplot2</code> approach with the following base R code, which produces the image on the right of <a href="ch24.xhtml#ch24fig1">Figure 24-1</a>:</p>&#13;
<pre>R&gt; plot(surv$Wr.Hnd,surv$Height,col=surv$Sex,pch=c(16,17)[surv$Sex])<br/>R&gt; smoother &lt;- loess(Height~Wr.Hnd,data=surv)<br/>R&gt; handseq &lt;- seq(min(surv$Wr.Hnd),max(surv$Wr.Hnd),length=100)<br/>R&gt; sm &lt;- predict(smoother,newdata=data.frame(Wr.Hnd=handseq),se=TRUE)<br/>R&gt; lines(handseq,sm$fit)<br/>R&gt; polygon(x=c(handseq,rev(handseq)),<br/>           y=c(sm$fit+2*sm$se,rev(sm$fit-2*sm$se)),<br/>           col=adjustcolor("gray",alpha.f=0.5),border=NA)</pre>&#13;
<p class="indent">The first line plots the raw data, and the second line uses the built-in <code>loess</code> function to provide the smoothed trend—the syntax is identical to that of <code>lm</code>. Just as with linear models fitted by <code>lm</code>, for drawing to begin, you need <span epub:type="pagebreak" id="page_613"/>to set up a fine sequence of values of the <em>x</em>-axis variable at which to obtain the point estimates and their standard errors; this is achieved with <code>seq</code> in the third line, followed by <code>predict</code> in the fourth line with the <code>se</code> argument set to <code>TRUE</code>. This results in the object <code>sm</code>, a list with components <code>$fit</code> and <code>$se</code> as usual.</p>&#13;
<p class="indent">The smoothed trend is then drawn, using <code>sm$fit</code> in a call to <code>lines</code>. Finally, a rough 95 percent confidence interval is calculated for each of the predicted values as the <code>sm$fit</code> elements plus and minus twice the corresponding standard errors in <code>sm$se</code>. This is done directly in the call to <code>polygon</code>, which draws the gray band based on the vertices formed by the confidence interval (therein, the <code>rev</code> command is used to reverse the entries in the given <code>handseq</code> vector). You need to instruct the gray-filled shape to be transparent with a call to the ready-to-use <code>adjustcolor</code> command (the argument <code>alpha.f</code> takes a value from 0, which is fully transparent, to 1, which is fully opaque); setting <code>alpha.f=0.5</code> sets 50 percent opacity of the specified <code>"gray"</code>.</p>&#13;
<p class="indent">All that, and a legend hasn’t been put in yet! This example certainly exposes the extra effort the base R version of the image requires, not just in terms of the length of the script but also for the whole process of thinking about its construction (for example, putting together the vertices of a polygon for the confidence region appropriately and remembering to adjust the opacity of the filled shape to prevent any preplotted content being covered up). This becomes even more apparent the moment you become a little more ambitious with such features. Suppose you wanted to superimpose smoothers for each sex separately; this would require separate estimation of the LOESS functions and a rethink of the plotting strategy. However, this addition is simple in <code>ggplot2</code> terms, simply requiring a change in the aesthetic mapping of the relevant geom. The following code produces <a href="ch24.xhtml#ch24fig2">Figure 24-2</a>:</p>&#13;
<pre>R&gt; ggplot(surv,aes(x=Wr.Hnd,y=Height,col=Sex,shape=Sex)) +<br/>       geom_point() + geom_smooth(method="loess")</pre>&#13;
<p class="indent">All that’s happened is that the aesthetic mapping for color and point type (<code>col=Sex</code> and <code>shape=Sex</code>, respectively) has shifted so that instead of being specific to the plotted points only, it’s part of the default mapping declared in the initialization call to <code>ggplot</code>. Any layer added afterward (that doesn’t reassign the mapping) will follow this default, as is the case for both <code>geom_point</code> and <code>geom_smooth</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The implementation of LOESS and other trend smoothers depends on you specifying the amount of smoothing you want; this is controlled by the proportion of the data to use as each localized weighted subset, for each step/location in the estimation procedure. A larger proportion leads to a smoother, less variable trend estimate than a smaller proportion. This value, referred to as the</em> span<em>, can be set by the optional argument</em> <code><span class="codeitalic">span</code></span> <em>in either</em> <code><span class="codeitalic">loess</code></span> <em>or</em> <code><span class="codeitalic">geom_smooth</code></span><em>. For quick data exploration, however, the default value of 0.75 is usually adequate. You can try experimenting with this on the example plots in this section to see the effects on the respective trends.</em></p>&#13;
</div>&#13;
<div class="image"><span epub:type="pagebreak" id="page_614"/><img src="../images/f24-02.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch24fig2"/>Figure 24-2: Illustrating separate LOESS smoothers for categorical subsets of data, a result of a simple change in aesthetic mapping, with</em> <code>ggplot2</code> <em>functionality</em></p>&#13;
<h4 class="h4" id="ch24lev2sec239"><strong><em>24.2.2 Constructing Smooth Density Estimates</em></strong></h4>&#13;
<p class="noindent">The idea of smoothing isn’t limited to scatterplot trends. <em>Kernel density estimation (KDE)</em> is a method for producing a smooth estimate of a probability density function, based on observed data. Briefly, KDE involves assigning a scaled probability function (the <em>kernel</em>) to each observation in a data set and summing them all to give an impression of the distribution of the data set as a whole. It’s basically a sophisticated version of a histogram. For theoretical details, the text by Wand and Jones (<a href="ref.xhtml#ref70">1995</a>) is a good reference.</p>&#13;
<p class="indent">To illustrate this method, consider the built-in <code>airquality</code> data frame; enter <code>?airquality</code> at the prompt to open the documentation, which tells you it contains a number of measurements taken of the air in New York over several months. A basic plot of the kernel estimate of the density of the temperature measurements is provided with the following line and shown on the left of <a href="ch24.xhtml#ch24fig3">Figure 24-3</a>:</p>&#13;
<pre>R&gt; ggplot(data=airquality,aes(x=Temp)) + geom_density()</pre>&#13;
<p class="indent">Such a plot is relatively easy to create with base R graphics as well, using the built-in <code>density</code> command to implement KDE for a given data vector. However, <code>ggplot2</code> lets you dress up the plot using aesthetic mappings with relative ease—a big draw for fans of <code>ggplot2</code>. For example, suppose you want to visualize the density estimates for temperature separately according to the month of observation. First, execute the following code:</p>&#13;
<pre>R&gt; air &lt;- airquality<br/>R&gt; air$Month &lt;- factor(air$Month,<br/>                       labels=c("May","June","July","August","September"))</pre>&#13;
<div class="image"><span epub:type="pagebreak" id="page_615"/><img src="../images/f24-03.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch24fig3"/>Figure 24-3: Visualizing temperature distributions in the</em> <code>airquality</code> <em>data frame via KDE, using</em> <code>ggplot2</code> <em>functionality</em></p>&#13;
<p class="indent">This has created a copy of the <code>airquality</code> data frame in your workspace and recoded the originally numeric <code>Month</code> vector as a factor vector (as required for <code>ggplot2</code> mappings), labeling the entries appropriately. Then, using <code>air</code>, the following code produces the right-hand plot in <a href="ch24.xhtml#ch24fig3">Figure 24-3</a>:</p>&#13;
<pre>R&gt; ggplot(data=air,aes(x=Temp,fill=Month)) + geom_density(alpha=0.4) +<br/>       ggtitle("Monthly temperature probability densities") +<br/>       labs(x="Temp (F)",y="Kernel estimate")</pre>&#13;
<p class="indent">The different densities are clearly identified by different color fills, set using <code>fill=Month</code> in <code>aes</code> in the plot initialization mapped out by <code>ggplot</code>. You additionally supply <code>alpha=0.4</code> to <code>geom_density</code> to set 40 percent opacity so you can see all five curves clearly. The remaining calls to <code>ggtitle</code> and <code>labs</code> simply tidy up the main and axis titles. Features of the distributions of these measurements are as you might expect—temperatures for July, the hottest month, are centered over a far higher range of values than, say, those for May.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Just like LOESS techniques, the precise appearance of kernel-estimated probability density function is dependent on the amount of smoothing employed. Like the binwidth in the construction of a histogram, the quantity of interest in KDE is referred to as the</em> bandwidth <em>or</em> smoothing parameter<em>—a larger bandwidth imposes greater smoothing over the range of the data. By default, the bandwidth is automatically chosen using a data-driven technique in these examples. This default level of smoothing is generally acceptable for simple exploration of your data.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch24lev1sec84"><span epub:type="pagebreak" id="page_616"/><strong>24.3 Multiple Plots and Variable-Mapped Facets</strong></h3>&#13;
<p class="noindent">In <a href="ch23.xhtml#ch23lev2sec225">Section 23.1.4</a>, you saw different ways in which several traditional R plots can be viewed or laid out in a single graphics device. The same methods, such as setting <code>mfrow</code> in a call to <code>par</code> or compartmentalizing the device using <code>layout</code>, can’t be used for <code>ggplot2</code> graphics. There are other functions, though, that allow independent <code>ggplot2</code> plots to populate a single device. True to form, <code>ggplot2</code> also offers a convenient way to consider multiple-plot graphics using facets, where the images are all drawn in one go.</p>&#13;
<h4 class="h4" id="ch24lev2sec240"><strong><em>24.3.1 Independent Plots</em></strong></h4>&#13;
<p class="noindent">First, let’s say you have several <code>ggplot2</code> plots that you’ve created independently of one another and that you’d like to arrange as a single image. A quick way to do this is to use the <code>grid.arrange</code> function provided in the contributed <code>gridExtra</code> package (<a href="ref.xhtml#ref05">Auguie, 2012</a>). Install the package by running <code>install.packages("gridExtra")</code> at the prompt (you’ll need an Internet connection).</p>&#13;
<p class="indent">To illustrate the use of <code>grid.arrange</code>, continue with the <code>air</code> object—the copy of <code>airquality</code> you created in <a href="ch24.xhtml#ch24lev1sec83">Section 24.2</a> with the factor <code>Month</code> column. Now, consider the following three <code>ggplot2</code> objects, which I’ll explain further in a moment:</p>&#13;
<pre>R&gt; gg1 &lt;- ggplot(air,aes(x=1:nrow(air),y=Temp)) +<br/>              geom_line(aes(col=Month)) +<br/>              geom_point(aes(col=Month,size=Wind)) +<br/>              geom_smooth(method="loess",col="black") +<br/>              labs(x="Time (days)",y="Temperature (F)")<br/>R&gt; gg2 &lt;- ggplot(air,aes(x=Solar.R,fill=Month)) +<br/>              geom_density(alpha=0.4) +<br/>              labs(x=expression(paste("Solar radiation (",ring(A),")")),<br/>                   y="Kernel estimate")<br/>R&gt; gg3 &lt;- ggplot(air,aes(x=Wind,y=Temp,color=Month)) +<br/>              geom_point(aes(size=Ozone)) +<br/>              geom_smooth(method="lm",level=0.9,fullrange=FALSE,alpha=0.2) +<br/>              labs(x="Wind speed (MPH)",y="Temperature (F)")</pre>&#13;
<p class="indent">Execute <code>library("gridExtra")</code> to load the required package. To view <code>gg1</code>, <code>gg2</code>, and <code>gg3</code> in one window, simply call the following, which produces <a href="ch24.xhtml#ch24fig4">Figure 24-4</a>:</p>&#13;
<pre>R&gt; grid.arrange(gg1,gg2,gg3)</pre>&#13;
<p class="indent">Note that you’ll likely see some warning messages telling you there are missing values in the <code>air</code> data frame and recommending to resize the window containing the plots.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_617"/><img src="../images/f24-04.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch24fig4"/>Figure 24-4: A series of three</em> <code>ggplot2</code> <em>graphics of the</em> <code>airquality</code> <em>data, plotted in the same device window via</em> <code>grid.arrange</code> <em>in the</em> <code>gridExtra</code> <em>package. Top: A time series of the temperatures by day, distinguishing between months and wind speed, with an overall LOESS trend with a 95 percent CI. Middle: Kernel density estimates of the distributions of solar radiation by month. Bottom: A scatterplot of temperature by wind speed, using color to delineate month and point size to reference ozone level. Separately fitted simple linear models of temperature on wind speed, split by month, along with 90 percent CIs, are superimposed.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_618"/>As you can see, <code>grid.arrange</code> is easy to use—you simply create your <code>ggplot2</code> images first and store them as objects, then provide them directly to the arrangement function. <code>grid.arrange</code> decides how to produce the final layout based on the number of objects you give it (in this case, it’s a column of the three plots). You can control the order of the plots by changing the order in which the objects are supplied. There are more optional arguments, which you can read about in the documentation file <code>?grid.arrange</code>.</p>&#13;
<p class="indent">The plots <code>gg1</code>, <code>gg2</code>, and <code>gg3</code> also provide an opportunity to discuss even more <code>ggplot2</code> capabilities. Since there’s a lot going on, especially in <code>gg1</code> and <code>gg3</code>, I’ll discuss the code for each object separately.</p>&#13;
<p class="noindenth"><code><span class="codestrong">gg1</code></span> The first plot is of the daily temperature. In setting the default aesthetics in <code>ggplot</code>, I create a sequence of integers matching the number of rows in <code>air</code>, to be paired with the relevant <code>Temp</code> element. Then <code>geom_line</code> and <code>geom_point</code> add the interconnecting lines and the raw observations themselves, to be added to the default aesthetic mapping. The interconnecting lines are set to change color according to <code>Month</code>. The raw observations also change color according to <code>Month</code>, and the point sizes change to be proportional to the wind speed readings. I include an overall LOESS smoother with its default color changed to <code>"black"</code>. I remain with the default mapping here—I don’t want separate smoothed trends for each month. The final addition of <code>labs</code> merely clarifies the axis titles as you’ve already seen it used.</p>&#13;
<p class="noindenth"><code><span class="codestrong">gg2</code></span> The second plot is a variant of the plot on the right of <a href="ch24.xhtml#ch24fig3">Figure 24-3</a>. This time, it shows the estimated densities of the solar radiation readings (in angstroms). The opacity is set, as you saw earlier, using <code>alpha</code> in <code>geom_density</code>. It’s also worth noting that I used <code>expression</code> in <code>labs</code> to approximate the angstrom unit symbol, Å, using <code>ring(A)</code>.</p>&#13;
<p class="noindenth"><code><span class="codestrong">gg3</code></span> The last is a scatterplot of temperature by wind speed, where you can see a negative relationship. The color, again to be assigned to each month, is also set as the default aesthetic mapping in <code>ggplot</code>. In the call to <code>geom_point</code>, the aesthetic enhancement is instructed to plot point size as proportional to the ozone reading (this is to ensure correct formatting of the corresponding legend, in light of the next addition). Here you can see a different kind of use for <code>geom_smooth</code>. In setting <code>method="lm"</code>, the line (or lines) I want superimposed correspond to simple linear model fits according to the <code>x</code> and <code>y</code> aesthetic mappings as predictor and response, respectively. Additionally including the factor <code>Month</code> in the default mapping ensures separate simple linear models are fitted for the temperature on wind speed data for each month and colored appropriately (it’s important to note that the plotted lines do not reflect a multiple linear model that includes all the variables used in the plot). Light, transparent 90 percent CIs are included with each regression (<code>level=0.9</code> and <code>alpha=0.2</code>), and setting <code>fullrange=FALSE</code> restricts each regression line only to the width of the observed data for each month.</p>&#13;
<h4 class="h4" id="ch24lev2sec241"><span epub:type="pagebreak" id="page_619"/><strong><em>24.3.2 Facets Mapped to a Categorical Variable</em></strong></h4>&#13;
<p class="noindent">If you want independently created <code>ggplot2</code> graphics to appear in the same window, <code>grid.arrange</code> is arguably the best way to deal with them. However, the <code>ggplot2</code> package offers a flexible alternative to quickly view multiple plots. Often, when exploring a data set, you’ll want to create several plots of the same variables based on the levels of one or more important categorical variables. This behavior, referred to as <em>faceting</em>, is familiar territory for <code>ggplot2</code> using either the <code>facet_wrap</code> or the <code>facet_grid</code> command.</p>&#13;
<p class="indent">Let’s focus on the simplest case where you have one categorical variable. Remaining with the <code>air</code> data frame object, the following line creates a <code>ggplot2</code> object of the density plots of the New York temperatures shown on the right of <a href="ch24.xhtml#ch24fig3">Figure 24-3</a>:</p>&#13;
<pre>R&gt; ggp &lt;- ggplot(data=air,aes(x=Temp,fill=Month)) + geom_density(alpha=0.4) +<br/>              ggtitle("Monthly temperature probability densities") +<br/>              labs(x="Temp (F)",y="Kernel estimate")</pre>&#13;
<p class="indent">Rather than view all density estimates together, you can create a plot of each one separately, displaying them in the same device, with the following three uses of <code>facet_wrap</code>; the results are at the top left, top right, and bottom of <a href="ch24.xhtml#ch24fig5">Figure 24-5</a>.</p>&#13;
<pre>R&gt; ggp + facet_wrap(~Month)<br/>R&gt; ggp + facet_wrap(~Month,scales="free")<br/>R&gt; ggp + facet_wrap(~Month,nrow=1)</pre>&#13;
<div class="image"><img src="../images/f24-05.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch24fig5"/>Figure 24-5: Three examples of using</em> <code>facet_wrap</code> <em>to display kernel density estimates of the temperature data, split by month</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_620"/>The <code>facet_wrap</code> function automates the layout of the multiple plots; a formula specifies the faceting variable. In all the previous plots, this is set to <code>~Month</code>, to be read as “by Month.” The code for the first visualization, given at the top left, offers no additional arguments, and without arguments the <em>x-</em>and <em>y</em>-axes of each facet are fixed, so you can compare the plots on the same scale. If you don’t want that, you can instruct the axes to be “free,” which means each plot is produced on scales specific to its own contents. You can see this in the second plot, at the top right in <a href="ch24.xhtml#ch24fig5">Figure 24-5</a>, the line of code for which specifies <code>scales="free"</code>. You can also opt to free only the horizontal or vertical axis with <code>scales="free_x"</code> or <code>scales="free_y"</code>, respectively. Finally, note that facet placement can be tailored by using the <code>nrow</code> and <code>ncol</code> arguments. In the third plot, setting <code>nrow=1</code> instructs R to place the plots in one row only, giving the horizontal arrangement on the bottom of <a href="ch24.xhtml#ch24fig5">Figure 24-5</a>. For further details on placement, you can find the documentation for this command at <code>?facet_wrap</code>.</p>&#13;
<p class="indent">The alternative to <code>facet_wrap</code>, <code>facet_grid</code>, does much the same thing but isn’t able to wrap the plots if you’re faceting by only one categorical variable. The formula <code><span class="codeitalic">var1</code> ~ <span class="codeitalic">var2</span></span> is interpreted as “facet by <code><span class="codeitalic">var1</code></span> as rows and by <code><span class="codeitalic">var2</code></span> as columns.” If you are indeed interested in faceting by only one grouping variable in either columns or rows, then simply replace either <code><span class="codeitalic">var1</code></span> or <code><span class="codeitalic">var2</code></span> with a dot (<code>.</code>). The third image in <a href="ch24.xhtml#ch24fig5">Figure 24-5</a>, for example, can just as easily be achieved via <code>facet_grid</code> as follows:</p>&#13;
<pre>R&gt; ggp + facet_grid(.~Month)</pre>&#13;
<p class="indent">The next example, however, shows <code>facet_grid</code> in action with two grouping variables. Turn your attention again to the <code>diabetes</code> data frame in the <code>faraway</code> package. After loading the package, the following code creates the object with <code>diab</code> as the data frame of interest and with missing-value rows deleted, producing <a href="ch24.xhtml#ch24fig6">Figure 24-6</a>:</p>&#13;
<pre>R&gt; diab &lt;- na.omit(diabetes[,c("chol","weight","gender","frame","age",<br/>                               "height","location")])<br/>R&gt; ggplot(diab,aes(x=age,y=chol)) +<br/>       geom_point(aes(shape=location,size=weight,col=height)) +<br/>       facet_grid(gender~frame) + geom_smooth(method="lm") +<br/>       labs(y="cholesterol")</pre>&#13;
<p class="indent">The initial call to <code>ggplot</code> tells R to use <code>diab</code> and plot total cholesterol against age. Then an addition of <code>geom_point</code> sets the shape, size, and color of each plotted point to change according to the county location, the weight, and the height of the individuals, respectively (as you’ve already seen for point size based on a continuous variable, point color is also automatically changed to vary on a continuum if the correspondingly mapped aesthetic variable isn’t a factor).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_621"/><img src="../images/f24-06.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch24fig6"/>Figure 24-6: Illustrating two-way faceting in</em> <code>ggplot2</code><em>, using the</em> <code>diabetes</code> <em>data frame from the</em> <code>faraway</code> <em>package. Plots of cholesterol level against age, along with simple linear model fits, are faceted according to sex (rows) and body frame type (columns). Points are colored and sized according to weight and height, respectively, and two different point types differentiate the two county locations in Virginia of the study participants.</em></p>&#13;
<p class="indent">So far, those commands have still defined only a single scatterplot. With the addition of the call to <code>facet_grid</code>, the formula <code>gender~frame</code> separates the plots into a different scatterplot for males/females (as rows) and for each of the three body frame types: small/medium/large (as columns). You set simple linear model fits to accompany each plot based on the default aesthetic mapping (cholesterol on age) with a call to <code>geom_smooth</code>, and a final call to <code>labs</code> clarifies the vertical axis title.</p>&#13;
<p class="indent">The plots themselves reveal, generally, some of the trends you’ll have picked up on an earlier analysis of these data (<a href="ch21.xhtml#ch21lev2sec203">Section 21.5.2</a>). Increasing age tends to be associated with an increase in mean cholesterol, though that relationship seems, at least visually, less prominent for males. The overall smaller size of the points in the small frame column on the left makes sense—those with a smaller frame will typically weigh less than those with larger frames. There is also a tendency for the plots on the bottom row (females) to be of a darker shade than those along the top row—indicating that on average females are typically shorter than males. Any differences between the participants from the two counties, however, is difficult to discern—there doesn’t seem to be a systematic departure of the pattern of the Buckingham symbols (•) from that of the Louisa symbols (<span class="ent">▴</span>). (Remember, though, if you’re trying to understand the complex, potentially interactive relationships in your multivariate data, fitting an appropriate statistical model is preferable over plots alone.)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_622"/>These elegant plots serve to further highlight the relative ease with which the <code>ggplot2</code> package can produce complex graphics—typically involving partitioning the observations by one or more factors—both in terms of an individual image or an arrangement of images. Although similar plots are of course still possible using base R methods, that approach demands a somewhat finer or lower-level handling of the details of your data subsets, as well as any varying aesthetic features. This doesn’t mean base R graphics are redundant or should be ignored (you’ll see some nice new plots achieved with traditional commands in <a href="ch25.xhtml#ch25">Chapter 25</a>)—it’s just that you can create certain graphical displays with less coding effort (and usually a prettier end result) by utilizing Wickham’s well-received implementation of the grammar of graphics.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch24exc1"/><strong>Exercise 24.1</strong></p>&#13;
<p class="noindentz">Load the <code>MASS</code> package and inspect the help file for the <code>UScereal</code> data. This data frame provides nutritional and other information concerning breakfast cereals for sale in the United States in the early 1990s.</p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Create a copy of the data frame; name it <code>cereal</code>. To ease plotting, collapse the <code>mfr</code> column (manufacturer) of <code>cereal</code> to be a factor with only three levels, with the corresponding labels <code>"General Mills"</code>, <code>"Kelloggs"</code>, and <code>"Other"</code>. Also, convert the <code>shelf</code> variable (shelf number from floor) to a factor.</p></li>&#13;
<li><p class="noindents">Using <code>cereal</code>, construct and store two <code>ggplot</code> objects.</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">A scatterplot of calories on protein. Points should be colored according to shelf position and shaped according to manufacturer. Include simple linear regression lines for calories on protein, split according to shelf position. Ensure tidy axis and legend titles.</p></li>&#13;
<li><p class="noindents">A set of kernel estimates of calories, with filled color differentiating shelf positions. Use 50 percent opaque fills, and again ensure tidy axis and legend titles.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Arrange the two plots in (b) on a single device.</p></li>&#13;
<li><p class="noindents">Produce a faceted graphic of calories on protein, with each panel corresponding to a manufacturer as defined in your <code>cereal</code> object. A LOESS smoother with a 90 percent span should be superimposed upon each scatterplot. In addition, the points should be colored according to sugar content, sized according to sodium content, and shaped according to shelf position.</p></li>&#13;
</ol>&#13;
<p class="noindentz">Load the <code>car</code> package (downloading and installing it first if you haven’t already) and consider the <code>Salaries</code> object—a data frame detailing the salaries (in US dollars) of 397 academics working in <span epub:type="pagebreak" id="page_623"/>the United States during the 2008–2009 school year (<a href="ref.xhtml#ref25">Fox and Weisberg, 2011</a>). An inspection of the help file <code>?Salaries</code> informs you of the present variables, which, in addition to the salary figure, include each academic’s rank, sex, and research discipline (as factors) as well as the number of years of service.</p>&#13;
<ol type="a" start="5">&#13;
<li><p class="noindents">Produce a <code>ggplot</code> object, named <code>gg1</code>, of a scatterplot of salary on the vertical axis against years of service on the horizontal axis. Color should be used to distinguish between males and females, along with sex-specific LOESS trends, and ensure axis and legend titles are understandable. View your plot.</p></li>&#13;
<li><p class="noindents">Create the following three additional plot objects, again ensuring tidy axis and legend titles. Name the following <code>gg2</code>, <code>gg3</code>, and <code>gg4</code>, respectively:</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">Side-by-side boxplots of salary, split by rank. Each boxplot should be further split up according to sex (this can be done simply in the default aesthetic mapping—try assigning the sex variable to either <code>col</code> or <code>fill</code>).</p></li>&#13;
<li><p class="noindents">Side-by-side boxplots of salary, split by discipline, with each discipline split further by sex using color or fill.</p></li>&#13;
<li><p class="noindents">Kernel density estimates of salary, using 30 percent opaque fills to distinguish rank.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Display your four plot objects (<code>gg1</code>, <code>gg2</code>, <code>gg3</code>, and <code>gg4</code>) from (e) and (f) in a single device.</p></li>&#13;
<li><p class="noindents">Finally, plot the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">A series of kernel density estimates of salary using 70 percent opaque fills to distinguish between males and females, faceted by academic rank.</p></li>&#13;
<li><p class="noindents">Scatterplots of salary on years of service, using color to distinguish between males and females, faceted by discipline as rows and by academic rank as columns. Each scatterplot should have a sex-specific simple linear regression line with confidence band superimposed and have free horizontal scales.</p></li>&#13;
</ol></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch24lev1sec85"><strong>24.4 Interactive Tools in ggvis</strong></h3>&#13;
<p class="noindent">To wrap up this chapter, I’ll touch on a relatively new addition to the “gg” family, <code>ggvis</code>, by Chang and Wickham (<a href="ref.xhtml#ref10">2015</a>). The package enables you to design flexible statistical plots that the end user can interact with. The results are provided as web graphics. You’ll see the image pop up as a new tab in your default web browser (if you’re using the RStudio IDE—see <a href="app01.xhtml#app01">Appendix B</a>—the <code>ggvis</code> graphics are embedded within the Viewer pane).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_624"/>As a cautionary note, be aware that <code>ggvis</code> is, at the time of writing, still under development by its authors. New functionality is being added and bugs addressed. If you’re interested in the functionality, visit the <code>ggvis</code> website at <em><a href="http://ggvis.rstudio.com/">http://ggvis.rstudio.com/</a></em>. The site contains a beginner-friendly tutorial and recipe book of things that are currently possible. Here, I’ll just give you an overview of <code>ggvis</code>.</p>&#13;
<p class="indent">Install the <code>ggvis</code> package along with its dependencies and then load it with a call to <code>library("ggvis")</code>. Also make sure you have access to the student survey data, <code>survey</code>, by loading the <code>MASS</code> package. Create the following object to be used in the upcoming examples:</p>&#13;
<pre>R&gt; surv &lt;- na.omit(survey[,c("Sex","Wr.Hnd","Height","Smoke","Exer")])</pre>&#13;
<p class="indent">The common way to begin a <code>ggvis</code> graphic is to declare the data frame of interest, followed by a call to <code>ggvis</code> that defines the variables to be used and then to pile on the layers. When you use the variables from the data frame, they must be prefaced by a <code>~</code>, which explicitly tells R that you’re referring to a column of that data frame and not another object of the same name somewhere else. To add functions in the object definition, you don’t use <code>+</code> as in <code>ggplot2</code>, but <code>%&gt;%</code> (called a <em>pipe</em>). The equivalents of the <code>geom_</code> functions in <code>ggplot2</code> are prefaced by <code>layer_</code> in <code>ggvis</code>.</p>&#13;
<p class="indent">Let’s start with a simple static plot. The topmost image of <a href="ch24.xhtml#ch24fig7">Figure 24-7</a>, a histogram of the height measurements, can be obtained with the following execution:</p>&#13;
<pre>R&gt; surv %&gt;% ggvis(x=~Height) %&gt;% layer_histograms()<br/>Guessing width = 2 # range / 25</pre>&#13;
<p class="indent">The <code>surv</code> data frame is declared, and then you pipe to <code>ggvis</code>, which instructs the <code>~Height</code> variable to be mapped to the <em>x</em>-axis. Last, a pipe to <code>layer_histograms</code> produces the graphic, which assigns a default binwidth based on the range of the <em>x</em>-mapped data.</p>&#13;
<p class="indent">So what? You’ve already created lot of histograms. But wouldn’t it be great if you could play with the value of the binwidth without needing to create static plot after static plot? The <code>input_</code> collection of commands in <code>ggvis</code> allows you to instruct the resulting graphic to take interactive input. Consider the following code; <a href="ch24.xhtml#ch24fig7">Figure 24-7</a> shows my result.</p>&#13;
<pre>R&gt; surv %&gt;% ggvis(x=~Height) %&gt;%<br/>     layer_histograms(width=input_slider(1,15,label="Binwidth:"),fill:="gray")<br/>Showing dynamic visualisation. Press Escape/Ctrl + C to stop.</pre>&#13;
<div class="image"><span epub:type="pagebreak" id="page_625"/><img src="../images/f24-07.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch24fig7"/>Figure 24-7: Histograms of the height observations from the</em> <code>survey</code> <em>data frame, using</em> <code>ggvis</code><em>. Top: Default static plot. Bottom: The result of incorporating a slider button tied to the binwidth—the user can interact with, and immediately see, the effect of altering the bins.</em></p>&#13;
<p class="indent">Here, the <code>width</code> argument that controls the feature of interest is instructed to take the result of <code>input_slider</code>, which sets up an interactive slider button. The range of the slider values for <code>width</code> is set as <code>1</code> to <code>15</code> (inclusive), and the optional argument <code>label</code> provides a title for the interactive gadget. Last, using <code>fill</code> in <code>layer_histogram</code> sets the color of the bars. Note the particular assignment <code>fill:="gray"</code> uses <code>:=</code>, not just <code>=</code>. The <code>=</code> alone is used in <code>ggvis</code> for mapping variables, that is, when the feature of interest is to be passed a variable subject to change, essentially like an aesthetic mapping in <code>ggplot2</code>. The combination of <code>:=</code> should be interpreted as a set constant, that is, when you simply intend to universally fix a certain feature.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_626"/>Once the code successfully executes, you can experiment with sliding the button for smaller and larger binwidths. It’s interesting to gauge just how much your interpretation of the distribution changes along with it. As the text printed out beneath the executed commands in the console tells you, you have to exit the interactive plot to use R again. Pressing <small>ESC</small> will terminate the interactivity and return control to the user at the prompt.</p>&#13;
<p class="indent">Other kinds of interactive abilities include <code>input_select</code> (for a drop-down menu), <code>input_radiobuttons</code> (radio button options), and <code>input_checkbox</code> (for checkboxes). You can even set up interactive text or numeric input boxes with <code>input_numeric</code>. See the relevant help files or the <code>ggvis</code> website for further details.</p>&#13;
<p class="indent">As another example based on the <code>surv</code> data frame, let’s try a scatterplot. Starting again with a simple static plot, run the following:</p>&#13;
<pre>R&gt; surv %&gt;% ggvis(x=~Wr.Hnd,y=~Height,size:=200,opacity:=0.3) %&gt;%<br/>     layer_points()</pre>&#13;
<p class="indent">I won’t show this result here, but you can see from the call to <code>ggvis</code> that you’ll be plotting height against handspan and that you’re universally enlarging the points as well as setting a universal level of 30 percent opacity. The last pipe to <code>layer_points</code> produces the image. As with the static plot of the histogram, since there’s no interactivity, you don’t need to “exit” the plot—you’re returned control at the console prompt immediately.</p>&#13;
<p class="indent">For a more interesting graphic, try this:</p>&#13;
<pre>R&gt; filler &lt;- input_radiobuttons(c("Sex"="Sex","Smoking status"="Smoke",<br/>                                  "Exercise frequency"="Exer"),map=as.name,<br/>                                label="Color points by...")<br/>R&gt; sizer &lt;- input_slider(10,300,label="Point size:")<br/>R&gt; opacityer &lt;- input_slider(0.1,1,label="Opacity:")<br/>R&gt; surv %&gt;% ggvis(x=~Wr.Hnd,y=~Height,fill=filler,<br/>                  size:=sizer,opacity:=opacityer) %&gt;%<br/>     layer_points() %&gt;% add_axis("x",title="Handspan") %&gt;%<br/>     add_legend("fill",title="")<br/>Showing dynamic visualisation. Press Escape/Ctrl + C to stop.</pre>&#13;
<p class="indent">First, three objects are created for the interactive bits. A set of radio buttons specifies the color of the plotted points according to one of three possible categorical variables (<code>Sex</code>, <code>Smoke</code>, or <code>Exer</code>), and two slider buttons control the point size and opacity. Note that when you intend to use variables from the data frame as ingredients for interactive behavior, you need to supply their exact names as a vector of character strings and set the optional <code>map=as.name</code>; this is done when defining the <code>filler</code> object. In the subsequent call to <code>ggvis</code>, you pass <code>filler</code> to <code>fill</code>, using <code>=</code>. The two slider buttons in the objects <code>sizer</code> and <code>opacityer</code> are passed to the relevant arguments with <code>:=</code> since they don’t depend on variables in the data frame. The call to <code>layer_points</code> generates the plot, and additional pipes to <code>add_axis</code> and <code>add_legend</code> simply tidy up the <em>x</em>-axis and legend titles from their defaults.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_627"/>The top of <a href="ch24.xhtml#ch24fig8">Figure 24-8</a> shows a screenshot of the result, where I’ve selected the point color to vary according to the exercise frequency variable, reduced the point size, and chosen a moderate-to-high level of opacity.</p>&#13;
<div class="image"><img src="../images/f24-08.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch24fig8"/>Figure 24-8: Two examples of</em> <code>ggvis</code> <em>scatterplots of height on handspan of the student survey data. Top: Color (fill) changed using radio buttons based on sex, smoking status, or exercise frequency and slider buttons for point size and opacity. Bottom: Splitting points by sex using color and superimposing sex-specific LOESS smoothers and corresponding CIs; their smoothing span is controllable via a slider button.</em></p>&#13;
<p class="indent">Finally, let’s produce the same scatterplot but settle on using sex to color the points. You can add separate LOESS smoothers to males and females and dynamically control the degree of smoothing using a slider button. This last example, a screenshot of which appears on the bottom of <a href="ch24.xhtml#ch24fig8">Figure 24-8</a>, is the result of executing the following code:</p>&#13;
<pre>R&gt; surv %&gt;% ggvis(x=~Wr.Hnd,y=~Height,fill=~Sex) %&gt;% group_by(Sex) %&gt;%<br/>     layer_smooths(span=input_slider(0.3,1,value=0.75,<br/>                                     label="Smoothing span:"),<br/>                   se=TRUE) %&gt;% layer_points() %&gt;%<br/>     add_axis("x",title="Handspan")<br/>Showing dynamic visualisation. Press Escape/Ctrl + C to stop.</pre>&#13;
<p class="indent">LOESS smoothers are added with the <code>layer_smooths</code> command, whose <code>span</code> argument, the target parameter of interest, is assigned an <code>input_slider</code>. Its range of possible values is set as usual, and the optional <code>value</code> argument (also applicable in other <code>input_</code> functions) sets the starting value when the <span epub:type="pagebreak" id="page_628"/>plot is first initialized. Additionally, the <code>se=TRUE</code> argument to <code>layer_smooths</code> ensures 95 percent CIs accompany the smoothed trends. Note that the pipe to <code>layer_smooths</code> is preempted by a pipe through <code>group_by(Sex)</code>. Without it, the smoothers would simply be applied to the <code>x</code> and <code>y</code> data as a whole (also note, at the time of writing, you don’t preface the variable name with <code>~</code> in <code>group_by</code>).</p>&#13;
<p class="indent">As such, <code>ggvis</code> shows great potential for a more dynamic experience for visual data exploration. These tools are especially useful in activities such as presentations or website designs, where you can offer your audience an interactive appreciation of your data in a grammar of graphics style. If you’re interested in using these tools, I strongly encourage you to keep abreast of developments at the <code>ggvis</code> website.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch24exc2"/><strong>Exercise 24.2</strong></p>&#13;
<p class="noindentz">Ensure the <code>car</code> and <code>ggvis</code> packages are loaded. Revisit the <code>Salaries</code> data frame you looked at in <a href="ch24.xhtml#ch24exc1">Exercise 24.1</a>; inspect the help file <code>?Salaries</code> to remind yourself of the present variables.</p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Produce an interactive scatterplot of salary on the vertical axis and the years of service on the horizontal axis. Employ radio buttons to color points according to either academic rank, research discipline, or sex. Use pipes to <code>add_legend</code> and <code>add_axis</code> to omit a legend title and to tidy up the axis titles, respectively.</p></li>&#13;
<li><p class="noindents">A pipe to <code>layer_densities</code> (which you’ve not yet met) is used to produce kernel density estimates, similar to those appearing in <a href="ch24.xhtml#ch24fig5">Figure 24-5</a>.</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">Use <code>ggvis</code> to create a static plot of kernel density estimates of salary distributions, split up according to academic rank. To do this, assign the salary variable to <code>x</code> and the rank variable to <code>fill</code>, followed by a pipe to <code>group_by</code> to explicitly instruct grouping by the rank variable. Lastly, piping to <code>layer_densities</code> (just use all default argument values in this instance) will generate the graphic. Your result should resemble the <code>gg4</code> object from <a href="ch24.xhtml#ch24exc1">Exercise 24.1</a>.</p></li>&#13;
<li><p class="noindents">Just like the <code>width</code> argument to <code>layer_histograms</code> is used to control the appearance of a histogram, the <code>adjust</code> argument in <code>layer_densities</code> is used to control the degree of smoothness of the kernel estimates. Reproduce the rank-specific kernel estimates from the previous plot, but this time, the graphic should be interactive—implement a slider button with a range of 0.2 to 2 and a label of <code>"Smoothness"</code> to control the smoothing adjustment. At your discretion, either suppress or clarify the axis and legend titles of the result.</p></li>&#13;
</ol></li>&#13;
</ol>&#13;
<p class="noindentz"><span epub:type="pagebreak" id="page_629"/>Ensure you have the <code>MASS</code> package loaded, once more gaining access to the <code>UScereal</code> data frame. If you haven’t already done so, inspect the help file <code>?UScereal</code> and re-create the <code>cereal</code> object exactly as specified in <a href="ch24.xhtml#ch24exc1">Exercise 24.1</a> (a). Then do the following:</p>&#13;
<ol type="a" start="3">&#13;
<li><p class="noindents">Set up an object for radio buttons to choose among the manufacturer, the shelf, and the vitamins variables. Make sure the labels for each radio button are clear, and set up an appropriate title label for what will form the collection of options to color the points. Name the object <code>filler</code>.</p></li>&#13;
<li><p class="noindents">Borrowing the <code>sizer</code> and <code>opacityer</code> objects created in <a href="ch24.xhtml#ch24lev1sec85">Section 24.4</a> and using the object you just created in (c) to control <code>fill</code>, create an interactive scatterplot of calories on protein. Tidy up the axis titles and suppress the legend title for the point color fill. The result should essentially be the same, in terms of functionality, as the graphic appearing as the topmost screenshot in <a href="ch24.xhtml#ch24fig8">Figure 24-8</a>.</p></li>&#13;
<li><p class="noindents">Create a new object for the same radio buttons as specified in (c) that will control the shape of the points (in other words, the characters used to plot points). Modify the title label accordingly. Name this object <code>shaper</code>.</p></li>&#13;
<li><p class="noindents">Finally, re-create the interactive scatterplot of calories on protein exactly as in (d), but this time additionally assigning <code>shaper</code> from (e) to the <code>shape</code> modifier in your call to <code>ggvis</code>. To prevent the legends for the two sets of radio buttons from overlapping each other, you need to add the following pipes to your code:</p>&#13;
<p class="programs-b1">add_legend("shape",title="",<br/>           properties=legend_props(legend=list(y=100)))</p>&#13;
<p class="noindentz">and</p>&#13;
<p class="programs-b1">set_options(duration=0)</p>&#13;
<p class="indent">The first simply moves the legend for the <code>shape</code> modifier vertically downward, and the second eliminates the slight “animation delay” that occurs by default when switching between options in the interactive graphic. Once more, use additional calls to <code>add_axis</code> and <code>add_legend</code> to clarify or suppress axis and legend titles.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h5 class="h5" id="ch24lev3sec108"><span epub:type="pagebreak" id="page_630"/><strong>Important Code in This Chapter</strong></h5>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function/operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Brief description</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>First occurrence</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>ggplot</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Initialize <code>ggplot2</code> plot</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev1sec82">Section 24.1</a>, <a href="ch24.xhtml#page_610">p. 610</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>geom_smooth</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Trend line geom</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev2sec238">Section 24.2.1</a>, <a href="ch24.xhtml#page_612">p. 612</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>loess</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Calculate LOESS (base R)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev2sec238">Section 24.2.1</a>, <a href="ch24.xhtml#page_612">p. 612</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>rev</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Reverse vector elements</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev2sec238">Section 24.2.1</a>, <a href="ch24.xhtml#page_612">p. 612</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>adjustcolor</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Alter color opacity (base R)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev2sec238">Section 24.2.1</a>, <a href="ch24.xhtml#page_612">p. 612</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>geom_density</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Kernel density geom</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev2sec239">Section 24.2.2</a>, <a href="ch24.xhtml#page_614">p. 614</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>ggtitle</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Add <code>ggplot2</code> title</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev2sec239">Section 24.2.2</a>, <a href="ch24.xhtml#page_615">p. 615</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>grid.arrange</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Multiple <code>ggplot2</code> plots</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev2sec240">Section 24.3.1</a>, <a href="ch24.xhtml#page_616">p. 616</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>facet_wrap</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">One-factor faceting</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev2sec241">Section 24.3.2</a>, <a href="ch24.xhtml#page_619">p. 619</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>facet_grid</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Two-factor faceting</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev2sec241">Section 24.3.2</a>, <a href="ch24.xhtml#page_620">p. 620</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>ggvis</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Initialize <code>ggvis</code> plot</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev1sec85">Section 24.4</a>, <a href="ch24.xhtml#page_624">p. 624</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>%&gt;%</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Pipe to <code>ggvis</code> layer</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev1sec85">Section 24.4</a>, <a href="ch24.xhtml#page_624">p. 624</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>layer_histograms ggvis</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">histogram layer</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev1sec85">Section 24.4</a>, <a href="ch24.xhtml#page_624">p. 624</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>input_slider</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Interactive slider</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev1sec85">Section 24.4</a>, <a href="ch24.xhtml#page_624">p. 624</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>:=</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Constant <code>ggvis</code> assignment</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev1sec85">Section 24.4</a>, <a href="ch24.xhtml#page_624">p. 624</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>layer_points ggvis</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">points layer</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev1sec85">Section 24.4</a>, <a href="ch24.xhtml#page_626">p. 626</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>input_radiobuttons</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Interactive buttons</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev1sec85">Section 24.4</a>, <a href="ch24.xhtml#page_626">p. 626</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>add_legend</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Add/alter <code>ggvis</code> legend</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev1sec85">Section 24.4</a>, <a href="ch24.xhtml#page_626">p. 626</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>layer_smooths ggvis</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">trend line layer</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev1sec85">Section 24.4</a>, <a href="ch24.xhtml#page_627">p. 627</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>add_axis</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Add/alter <code>ggvis</code> axis</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch24.xhtml#ch24lev1sec85">Section 24.4</a>, <a href="ch24.xhtml#page_627">p. 627</a></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</body></html>