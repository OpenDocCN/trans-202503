<html><head></head><body><section class="chapter" title="Chapter&#xA0;8.&#xA0;Measuring Up" epub:type="chapter" id="measuring_up"><div class="titlepage"><div><div><h2 class="title">Chapter 8. Measuring Up</h2></div></div></div><p><a id="iddle1627" class="indexterm"/>It is all too easy to mix up units of measurement in a long, intricate computer program. When such a mix-up occurs, the consequences can be extremely costly, even tragic. One of the most famous examples is the crash of NASA’s <span class="emphasis"><em>Mars Climate Orbiter</em></span> in 1999. Investigation into the accident revealed that the crash was caused by a unit mismatch; pound-force seconds were used instead of newton seconds. This error led to an incorrect trajectory calculation and ultimately to the vehicle’s demise.</p><p>One can argue that proper testing should have detected the calculation error and thus prevented the crash, but a bigger question is whether the error would have even occurred if the programming language had enforced the proper units through its type system.</p><p><a id="iddle1544" class="indexterm"/><a id="iddle1637" class="indexterm"/><a id="iddle1925" class="indexterm"/><a id="iddle2074" class="indexterm"/><a id="iddle2076" class="indexterm"/>Over the years, people have tried enforcing units of measure in software systems, usually through external libraries, to varying degrees of success. F# is one of the first languages to include units of measure as a native part of its static type checking system. In addition to providing an extra level of safety beyond the basic type system, F#’s units of measure can enhance code readability by removing ambiguity about what is actually expected in the code without resorting to longer identifiers.</p><div class="sect1" title="Defining Measures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="defining_measures">Defining Measures</h2></div></div></div><p>To enable static measure checking, you first need to define a measure. <span class="emphasis"><em>Measures</em></span> are type-like constructs that are decorated with the <code class="literal">Measure</code> attribute to represent real-world measurements. They can include an optional <span class="emphasis"><em>measure formula</em></span> that describes the measure in terms of other measures. For example, the following definition creates a named unit of measure for a foot:</p><a id="pro_id00439"/><pre class="programlisting">[&lt;Measure&gt;] type foot</pre><div class="sidebar"><a id="international_system_of_units"/><div class="sidebar-title">International System of Units</div><p>F# 3.0 includes predefined measure types for the International System of Units (SI) units, including meters, kilograms, and amperes, among many others. You can find each SI unit in the <code class="literal">Microsoft.FSharp.Data.UnitSystems</code> namespace. Prior to F# 3.0, the SI units are included in the F# PowerPack and can be found in the <code class="literal">Microsoft.FSharp.Math</code> namespace.</p></div></div><div class="sect1" title="Measure Formulas"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="measure_formulas">Measure Formulas</h2></div></div></div><p>Measure formulas allow you to define derivative measures based on one or more previously defined measures. At their most basic, formulas serve as an easy way to create synonyms for types. For instance, if you’ve defined a measure named <code class="literal">foot</code> and want to abbreviate it as <code class="literal">ft</code>, you could write this:</p><a id="pro_id00440"/><pre class="programlisting">[&lt;Measure&gt;] type ft = foot</pre><p>Measure formulas aren’t always quite so simple, though; they can also be used to describe more complex relationships between types, such as a measurement of distance over time. For example, miles per hour could be defined as <code class="literal">m / h</code> (assuming that <code class="literal">m</code> and <code class="literal">h</code> were previously defined to represent miles and hours, respectively).</p><p><a id="iddle2072" class="indexterm"/><a id="iddle2078" class="indexterm"/>Here are some of the most notable guidelines to follow when composing measure formulas:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You can multiply measures by separating two measures with a space or an asterisk (<code class="literal">*</code>) to create a <span class="emphasis"><em>product measure</em></span>. For instance, torque is sometimes measured in pound-feet and could be represented in F# as:</p><a id="pro_id00441"/><pre class="programlisting">[&lt;Measure&gt;] type lb
[&lt;Measure&gt;] type ft
[&lt;Measure&gt;] type lbft = lb ft</pre></li><li class="listitem"><p>You can divide measures by separating two measures with a forward slash (/) to create a <span class="emphasis"><em>quotient measure</em></span>. For instance, a distance over time, such as miles per hour, could be expressed like this:</p><a id="pro_id00442"/><pre class="programlisting">[&lt;Measure&gt;] type m
[&lt;Measure&gt;] type h
[&lt;Measure&gt;] type mph = m / h</pre></li><li class="listitem"><p>Positive and negative integral values can be used to express an exponential relationship between two measures. For instance, square feet can be expressed like this:</p><a id="pro_id00443"/><pre class="programlisting">[&lt;Measure&gt;] type ft
[&lt;Measure&gt;] type sqft = ft ^ 2</pre></li></ul></div></div><div class="sect1" title="Applying Measures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="applying_measures">Applying Measures</h2></div></div></div><p>Once you’ve defined some measures you can apply them to values. Out of the box, F# defines measure-aware variations of the <code class="literal">sbyte</code>, <code class="literal">int16</code>, <code class="literal">int32</code>, <code class="literal">int64</code>, <code class="literal">float</code>, <code class="literal">float32</code>, and <code class="literal">decimal</code> primitive types. Values without measure annotations are said to be <span class="emphasis"><em>measureless</em></span> or <span class="emphasis"><em>dimensionless</em></span>.</p><p>To apply a measure to a constant value, you simply need to annotate the value as if the measure were a generic type parameter. For instance, you could define a length in feet and an area in square feet as follows:</p><a id="pro_id00444"/><pre class="programlisting">&gt; <span class="strong"><strong>let length = 10.0&lt;ft&gt;</strong></span>
<span class="strong"><strong>let area = 10.0&lt;sqft&gt;;;</strong></span>

val length : float&lt;ft&gt; = 10.0
val area : float&lt;sqft&gt; = 10.0</pre><p>As you can see, <code class="literal">length</code> is bound to <code class="literal">float&lt;ft&gt;</code> while <code class="literal">area</code> is bound to <code class="literal">float&lt;sqft&gt;</code>.</p><div class="sidebar"><a id="where_have_the_stars_gonequestion_mark"/><div class="sidebar-title">Where Have the Stars Gone?</div><p><a id="iddle1553" class="indexterm"/><a id="iddle2081" class="indexterm"/>Although units of measure play an important role within F#’s type system, they are erased during compilation and therefore have no impact on the compiled code. This is not to say that the measure types are not present in the compiled assembly; it means only that they’re not attached to any individual values. The net result of erasure is that units of measure can be enforced only within F# code, and any measure-aware functions or types used by assemblies written in other languages will be treated as measureless.</p></div><p>Measure annotations are great for constant values, but how can we apply measures to external data (such as something read from a database)? The easiest way to convert a measureless value to a measured one is to multiply it by a measured value, like this:</p><a id="pro_id00445"/><pre class="programlisting">[&lt;Measure&gt;] type dpi
let resolution = 300.0 * 1.0&lt;dpi&gt;</pre><p>Here, we define a measure representing dots per inch (<code class="literal">dpi</code>) and create a resolution by multiplying <code class="literal">300.0</code> by <code class="literal">1.0&lt;dpi&gt;</code>.</p><p>For a more verbose alternative, you can use one of the seven typed <code class="literal">WithMeasure</code> functions from the <code class="literal">LanguagePrimitives</code> module. Each <code class="literal">WithMeasure</code> function corresponds to one of the measured primitives. Here’s how to create a new measured value using the <code class="literal">FloatWithMeasure</code> function:</p><a id="pro_id00446"/><pre class="programlisting">[&lt;Measure&gt;] type dpi
let resolution = LanguagePrimitives.FloatWithMeasure&lt;dpi&gt; 300.0</pre><p>The <code class="literal">WithMeasure</code> functions are a bit more explicit in their intent and are definitely more verbose. Typically, their use is reserved for when type inference fails.</p></div><div class="sect1" title="Stripping Measures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="stripping_measures">Stripping Measures</h2></div></div></div><p>The vast majority of functions do not accept unitized values, so you may need to strip measures from values. Luckily, like applying measures, stripping measures is easy.</p><p>The typical way to strip measures is to simply divide the value by a measured <code class="literal">1</code>, like this:</p><a id="pro_id00447"/><pre class="programlisting">[&lt;Measure&gt;] type dpi
300.0&lt;dpi&gt; / 1.0&lt;dpi&gt;</pre><p><a id="iddle2042" class="indexterm"/><a id="iddle2075" class="indexterm"/>Alternatively, you can use the corresponding type conversion operator to achieve the same effect. For instance, we can strip the units from <code class="literal">300.0&lt;dpi&gt;</code> by calling the <code class="literal">float</code> function as follows:</p><a id="pro_id00448"/><pre class="programlisting">[&lt;Measure&gt;] type dpi
float 300.0&lt;dpi&gt;</pre></div><div class="sect1" title="Enforcing Measures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="enforcing_measures">Enforcing Measures</h2></div></div></div><p>Because units of measure are part of F#’s type system, you can enforce that values passed to a function use the correct units through type annotations on the parameters. Here we define a <code class="literal">getArea</code> function that requires the supplied width and height to be measured in feet:</p><a id="pro_id00449"/><pre class="programlisting">&gt; <span class="strong"><strong>let getArea (w : float&lt;ft&gt;) (h : float&lt;ft&gt;) = w * h;;</strong></span>

val getArea : w:float&lt;ft&gt; -&gt; h:float&lt;ft&gt; -&gt; float&lt;ft ^ 2&gt;</pre><p>If you were to call <code class="literal">getArea</code> with measureless arguments as shown here, you’d receive the following error:</p><a id="pro_id00450"/><pre class="programlisting">&gt; <span class="strong"><strong>getArea 10.0 10.0;;</strong></span>

  getArea 10.0 10.0;;
  --------^^^^

C:\Users\Dave\AppData\Local\Temp\stdin(9,9): error FS0001: This expression was expected to have type
    float&lt;ft&gt;
but here has type
    float</pre><p>Similarly, calling <code class="literal">getArea</code> with arguments annotated with the wrong measure (or no measure at all) will result in a compiler error. To correctly call the <code class="literal">getArea</code> function, you must provide values in the proper units, like this:</p><a id="pro_id00451"/><pre class="programlisting">&gt; <span class="strong"><strong>getArea 10.0&lt;ft&gt; 10.0&lt;ft&gt;;;</strong></span>
val it : float&lt;ft ^ 2&gt; = 100.0</pre><p>Notice that the function’s return value is <code class="literal">float&lt;ft ^ 2&gt;</code> despite our having defined <code class="literal">sqft</code> as <code class="literal">ft ^ 2</code>. The compiler doesn’t automatically convert the measures unless explicitly instructed to do so through a return type annotation, as shown here:</p><a id="pro_id00452"/><pre class="programlisting">&gt; <span class="strong"><strong>let getArea (w : float&lt;ft&gt;) (h : float&lt;ft&gt;) : float&lt;sqft&gt; = w * h;;</strong></span>

val getArea : w:float&lt;ft&gt; -&gt; h:float&lt;ft&gt; -&gt; float&lt;sqft&gt;

&gt; <span class="strong"><strong>getArea 10.0&lt;ft&gt; 10.0&lt;ft&gt;;;</strong></span>
val it : float&lt;sqft&gt; = 100.0</pre></div><div class="sect1" title="Ranges"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ranges">Ranges</h2></div></div></div><p><a id="iddle2073" class="indexterm"/><a id="iddle2080" class="indexterm"/>Measured units are permissible in range expressions, but there’s a catch: You must provide a step value. To create a measured range, you could write something like this:</p><a id="pro_id00453"/><pre class="programlisting">&gt; <span class="strong"><strong>let measuredRange = [1.0&lt;ft&gt;..1.0&lt;ft&gt;..10.0&lt;ft&gt;];;</strong></span>

val measuredRange : float&lt;ft&gt; list =
  [1.0; 2.0; 3.0; 4.0; 5.0; 6.0; 7.0; 8.0; 9.0; 10.0]</pre><p>Without an explicit step value, the compiler will try to create the range with the underlying type’s default, measureless value and will raise an error.</p></div><div class="sect1" title="Converting Between Measures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="converting_between_measures">Converting Between Measures</h2></div></div></div><p>While measure formulas allow you to create derivative units, they really aren’t flexible enough to allow arbitrary conversions between measures. To work around this limitation, you can define measure types with static members for both conversion factors and functions.</p><div class="sect2" title="Static Conversion Factors"><div class="titlepage"><div><div><h3 class="title" id="static_conversion_factors">Static Conversion Factors</h3></div></div></div><p>Defining a conversion factor on a measure type takes the same syntax as a static property. For instance, since there are 12 inches per foot, you could write something like this:</p><a id="pro_id00454"/><pre class="programlisting">[&lt;Measure&gt;] type ft
[&lt;Measure&gt;] type inch = static member perFoot = 12.0&lt;inch/ft&gt;</pre><p>The <code class="literal">perFoot</code> conversion can be accessed through the <code class="literal">inch</code> type like any static property. To convert from feet to inches, you would multiply a value measured in feet by <code class="literal">inch.perFoot</code>, as follows:</p><a id="pro_id00455"/><pre class="programlisting">&gt; <span class="strong"><strong>2.0&lt;ft&gt; * inch.perFoot;;</strong></span>
val it : float&lt;inch&gt; = 24.0</pre><p>Notice how the compiler inferred through the multiplication operation that the result should be measured in inches. Similarly, we can convert from inches to feet by dividing a value measured in inches by <code class="literal">inch.perFoot</code>:</p><a id="pro_id00456"/><pre class="programlisting">&gt; <span class="strong"><strong>36.0&lt;inch&gt; / inch.perFoot;;</strong></span>
val it : float&lt;ft&gt; = 3.0</pre></div><div class="sect2" title="Static Conversion Functions"><div class="titlepage"><div><div><h3 class="title" id="static_conversion_functions">Static Conversion Functions</h3></div></div></div><p>When you need more than a conversion factor, you can define static conversion functions (and their reciprocal conversions) directly on the measure types. Consistently defining the conversion functions on both measure types can help avoid confusion about where they’re defined.</p><p>To maximize code reuse, you can define the measure types as mutually recursive types by joining them together with the <code class="literal">and</code> keyword. Here, we define Fahrenheit and Celsius measures as mutually recursive types:</p><a id="pro_id00457"/><pre class="programlisting">[&lt;Measure&gt;]
type f =
  static member toCelsius (t : float&lt;f&gt;) = ((float t - 32.0) * (5.0/9.0)) * 1.0&lt;c&gt;
  static member fromCelsius (t : float&lt;c&gt;) = ((float t * (9.0/5.0)) + 32.0) * 1.0&lt;f&gt;
and
  [&lt;Measure&gt;]
  c =
    static member toFahrenheit = f.fromCelsius
    static member fromFahrenheit = f.toCelsius</pre><p>The Fahrenheit measure includes functions for converting to and from Celsius. Likewise, the Celsius measure includes functions for converting to and from Fahrenheit, but through the mutually recursive definition it can reuse the functions defined on the Fahrenheit type.</p><p>Depending on the complexity of your measure definitions or the conversion functions, you may find it cleaner to define the types independently and add the static methods later with intrinsic type extensions. This snippet shows one possible approach:</p><a id="pro_id00458"/><pre class="programlisting">[&lt;Measure&gt;] type f
[&lt;Measure&gt;] type c

let fahrenheitToCelsius (t : float&lt;f&gt;) =
  ((float t - 32.0) * (5.0/9.0)) * 1.0&lt;c&gt;

let celsiusToFahrenheit (t : float&lt;c&gt;) =
  ((float t * (9.0/5.0)) + 32.0) * 1.0&lt;f&gt;

type f with static member toCelsius = fahrenheitToCelsius
            static member fromCelsius = celsiusToFahrenheit

type c with static member toFahrenheit = celsiusToFahrenheit
            static member fromFahrenheit = fahrenheitToCelsius</pre><p>Here, the measure types are defined on their own (without mutual recursion) and immediately followed by the conversion functions. Since neither of the conversion functions has been attached to the measure types, we follow their definition by extending the measure types with static properties that expose the conversion functions.</p></div></div><div class="sect1" title="Generic Measures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="generic_measures">Generic Measures</h2></div></div></div><p><a id="iddle1470" class="indexterm"/><a id="iddle2077" class="indexterm"/><a id="iddle2079" class="indexterm"/>You’ve already seen numerous examples of how to write measure-aware functions for specific measure types, but it’s also possible to write functions against arbitrary measures using <span class="emphasis"><em>generic measures</em></span>. Writing such a function is the same as for specific measure types, except that instead of using a concrete unit value you use an underscore character (<code class="literal">_</code>). Alternatively, or when your function accepts multiple parameters that must use the same generic measure type, you can use a generic identifier (such as <code class="literal">'U</code>) instead of an underscore.</p><p>You might use generic measures when you need to perform the same operation against a variety of measures. For instance, you could write a function that computes the square of any measured <code class="literal">float</code> like this:</p><a id="pro_id00459"/><pre class="programlisting">let square (v : float&lt;_&gt;) = v * v</pre><p>Because <code class="literal">square</code> is defined to use a generic measure, its argument can accept any measured type. In fact, its argument can even be measureless. Here we use the square function to compute square inches, square feet, and a measureless square:</p><a id="pro_id00460"/><pre class="programlisting">&gt; <span class="strong"><strong>square 10.0&lt;inch&gt;;;</strong></span>
val it : float&lt;inch ^ 2&gt; = 100.0
&gt; <span class="strong"><strong>square 10.0&lt;ft&gt;;;</strong></span>
val it : float&lt;ft ^ 2&gt; = 100.0
&gt; <span class="strong"><strong>square 10.0;;</strong></span>
val it : float = 100.0</pre></div><div class="sect1" title="Custom Measure-Aware Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="custom_measure-aware_types">Custom Measure-Aware Types</h2></div></div></div><p>You can create your own measure-aware type by defining a generic type with a type parameter decorated with the <code class="literal">Measure</code> attribute. Consider the following record type:</p><a id="pro_id00461"/><pre class="programlisting">type Point&lt; ① [&lt;Measure&gt;] 'u &gt; = { X : ② float&lt;'u&gt;; Y : ③ float&lt;'u&gt; } with
  member ④ this.FindDistance other =
    let deltaX = other.X - this.X
    let deltaY = other.Y - this.Y
    sqrt ((deltaX * deltaX) + (deltaY * deltaY))</pre><p>The <code class="literal">Point</code> type behaves just like any other record type, except that its members are defined as generic measures. Rather than working only with measureless floats, <code class="literal">Point</code> includes a single measure, <code class="literal">'u</code>①, that is used by <code class="literal">X</code> ② and <code class="literal">Y</code> ③. <code class="literal">Point</code> also defines a <code class="literal">FindDistance</code> function ④ that performs a measure-safe calculation to find the distance between two points. Here we create a <code class="literal">Point</code> instance and invoke the <code class="literal">FindDistance</code> function against another <code class="literal">Point</code>:</p><a id="pro_id00462"/><pre class="programlisting">&gt; <span class="strong"><strong>let p = { X = 10.0&lt;inch&gt;; Y = 10.0&lt;inch&gt; }</strong></span>
<span class="strong"><strong>p.FindDistance { X = 20.0&lt;inch&gt;; Y = 15.0&lt;inch&gt; };;</strong></span>

val p : Point&lt;inch&gt; = {X = 10.0;
                       Y = 10.0;}
val it : float&lt;inch&gt; = 11.18033989</pre><p>If you try calling <code class="literal">FindDistance</code> with a <code class="literal">Point</code> that uses a different measure, the compiler will raise a type mismatch error like this:</p><a id="pro_id00463"/><pre class="programlisting">&gt; <span class="strong"><strong>p.FindDistance { X = 20.0&lt;ft&gt;; Y = 15.0&lt;ft&gt; };;</strong></span>

  p.FindDistance { X = 20.0&lt;ft&gt;; Y = 15.0&lt;ft&gt; };;
  ---------------------^^^^^^^^

C:\Users\Dave\AppData\Local\Temp\stdin(5,22): error FS0001: Type mismatch. Expecting a
    float&lt;inch&gt;
but given a
    float&lt;ft&gt;
The unit of measure 'inch' does not match the unit of measure 'ft'</pre><p>Custom measure-aware types aren’t restricted to record types, either. For instance, you could define an equivalent measure-aware class like this:</p><a id="pro_id00464"/><pre class="programlisting">type Point&lt; [&lt;Measure&gt;] 'u &gt; (x : float&lt;'u&gt;, y : float&lt;'u&gt;) =
  member this.X = x
  member this.Y = y
  member this.FindDistance (other : Point&lt;'u&gt;) =
    let deltaX = other.X - this.X
    let deltaY = other.Y - this.Y
    sqrt ((deltaX * deltaX) + (deltaY * deltaY))</pre></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00014">Summary</h2></div></div></div><p>Most programming languages rely on programmer discipline to ensure that measures are used correctly and consistently. One of the unique ways that F# helps developers produce more correct code is by including a rich syntax for units of measure directly within its type system.</p><p>F# not only includes predefined measure types for the International System of Units, but it also lets you define your own. You can enforce that the proper units are used in your calculations by annotating individual constant values with the appropriate measure or including them in type annotations in function definitions. Finally, you can define your own measure-aware types using a generic-like syntax.</p></div></section></body></html>