## 第四十九章. 内存映射

本章讨论了使用 *mmap()* 系统调用来创建内存映射。内存映射可以用于进程间通信（IPC），以及其他多种用途。在深入讨论 *mmap()* 之前，我们首先介绍一些基本概念。

## 概述

*mmap()* 系统调用在调用进程的虚拟地址空间中创建一个新的 *内存映射*。映射可以有两种类型：

+   *文件映射*：文件映射将文件的一部分直接映射到调用进程的虚拟内存中。文件一旦被映射，其内容可以通过在相应内存区域上的字节操作来访问。映射的页会根据需要（自动）从文件加载。此类型的映射也称为 *基于文件的映射* 或 *内存映射文件*。

+   *匿名映射*：匿名映射没有对应的文件。相反，映射的页被初始化为 0。

    ### 注意

    另一种看待匿名映射的方式（这也是接近真实的理解）是，它是一个虚拟文件的映射，该文件的内容始终被初始化为零。

一个进程的映射中的内存可能与其他进程的映射共享（即，每个进程的页表项指向相同的物理内存页）。这种情况可以通过两种方式发生：

+   当两个进程映射同一文件的相同区域时，它们共享相同的物理内存页。

+   由 *fork()* 创建的子进程继承父进程的映射副本，这些映射引用与父进程相应映射相同的物理内存页。

当两个或更多进程共享相同的内存页时，根据映射是 *私有* 还是 *共享*，每个进程可能会看到其他进程对该页内容所做的修改。

+   *私有映射* (`MAP_PRIVATE`)：对映射内容的修改对其他进程不可见，对于文件映射，这些修改不会传递到底层文件。尽管私有映射的页最初在上述情况下是共享的，但对映射内容的更改仍然对每个进程是私有的。内核通过写时复制技术实现这一点（fork() 的内存语义")）。这意味着，每当一个进程尝试修改页的内容时，内核会首先为该进程创建该页的一个新的独立副本（并调整该进程的页表）。因此，`MAP_PRIVATE` 映射有时被称为 *私有的写时复制映射*。

+   *共享映射* (`MAP_SHARED`)：对映射内容的修改对其他共享相同映射的进程可见，对于文件映射，这些修改会传递到底层文件。

上述描述的两种映射属性（文件与匿名，私有与共享）可以以四种不同的方式组合，如表 49-1 中总结。

表 49-1. 各种类型内存映射的用途

| 修改的可见性 | 映射类型 |
| --- | --- |
| 文件 | 匿名 |
| --- | --- |
| **私有** | 从文件内容初始化内存 | 内存分配 |
| **共享** | 内存映射 I/O；进程间共享内存（IPC） | 进程间共享内存（IPC） |

四种不同类型的内存映射的创建与使用如下：

+   *私有文件映射*：映射的内容是从文件区域初始化的。多个进程映射同一文件时，最初共享相同的物理内存页面，但采用写时复制技术，因此一个进程对映射的修改对其他进程是不可见的。这种映射方式的主要用途是从文件的内容初始化内存区域。一些常见的例子是从二进制可执行文件或共享库文件的相应部分初始化进程的文本段和已初始化的数据段。

+   *私有匿名映射*：每次调用*mmap()*创建私有匿名映射时，都会产生一个新的映射，它与其他由同一进程（或不同进程）创建的匿名映射不同（即不共享物理页面）。虽然子进程会继承父进程的映射，但写时复制语义确保在*fork()*之后，父进程和子进程不会看到对映射所做的任何更改。私有匿名映射的主要用途是为进程分配新的（零填充的）内存（例如，*malloc()*在分配大块内存时使用*mmap()*来实现）。

+   *共享文件映射*：所有映射同一文件区域的进程共享相同的物理内存页面，这些内存页面是从文件区域初始化的。对映射内容的修改会同步到文件中。这种映射方式有两个目的。首先，它允许*内存映射 I/O*。即，文件被加载到进程的虚拟内存区域中，对该内存的修改会自动写入文件。因此，内存映射 I/O 提供了一个替代*read()*和*write()*执行文件 I/O 的方式。第二个目的就是允许不相关的进程共享一块内存区域，以便进行（快速的）进程间通信（IPC），这种方式类似于 System V 共享内存段（第四十八章）。

+   *共享匿名映射*：与私有匿名映射一样，每次调用*mmap()*来创建共享匿名映射时，都会创建一个新的、独立的映射，不与其他映射共享页面。不同之处在于，该映射的页面不会进行写时复制。这意味着，当子进程在*fork()*之后继承映射时，父进程和子进程共享相同的 RAM 页面，一个进程对映射内容的修改对另一个进程可见。共享匿名映射允许类似于 System V 共享内存段的进程间通信（IPC），但仅限于相关进程之间。

我们将在本章的其余部分更详细地讨论这些类型的映射。

当进程执行*exec()*时，映射会丢失，但在*fork()*的子进程中会继承映射。映射类型（`MAP_PRIVATE`或`MAP_SHARED`）也会被继承。

有关进程所有映射的信息可以在 Linux 特定的`/proc/`*PID*`/maps`文件中查看，我们在第 48.5 节中描述了该文件。

### 注意

*mmap()*的另一个用途是与 POSIX 共享内存对象配合使用，它允许不同进程之间共享一块内存区域，而无需创建关联的磁盘文件（这对于共享文件映射是必需的）。我们在第五十四章中描述了 POSIX 共享内存对象。

## 创建映射：*mmap()*

*mmap()*系统调用在调用进程的虚拟地址空间中创建一个新的映射。

```
#include <sys/mman.h>

void *`mmap`(void **addr*, size_t *length*, int *prot*, int
 *flags*, int *fd*, off_t *offset*);
```

### 注意

成功时返回映射的起始地址，出错时返回`MAP_FAILED`

*addr*参数表示映射将位于的虚拟地址。如果我们将*addr*指定为`NULL`，内核将为映射选择一个合适的地址。这是创建映射的首选方式。或者，我们可以在*addr*中指定一个非`NULL`的值，内核将把它作为映射应该放置的地址的提示。在实践中，内核至少会将地址四舍五入到附近的页面边界。在任何情况下，内核都会选择一个与现有映射不冲突的地址。（如果*flags*中包含`MAP_FIXED`，则*addr*必须是页面对齐的。我们在 MAP_FIXED 标志中描述了这个标志。）

成功时，*mmap()*返回新映射的起始地址。出错时，*mmap()*返回`MAP_FAILED`。

### 注意

在 Linux（以及大多数其他 UNIX 实现）中，`MAP_FAILED`常量等于*((void *) -1)*。然而，SUSv3 指定了这个常量，因为 C 标准无法保证*((void *) -1)*与成功的*mmap()*返回值是不同的。

*length* 参数指定映射的大小，以字节为单位。尽管 *length* 不需要是系统页面大小的倍数（由 *sysconf(_SC_PAGESIZE)* 返回），但内核会以该大小为单位创建映射，因此 *length* 实际上会被向上舍入到下一个页面大小的倍数。

*prot* 参数是一个位掩码，用于指定要对映射施加的保护。它可以是 `PROT_NONE`，或者是表 49-2 中列出的其他三种标志的任意组合（按位或）。

表 49-2. 内存保护值

| 值 | 描述 |
| --- | --- |
| `PROT_NONE` | 该区域不能被访问 |
| `PROT_READ` | 该区域的内容可以被读取 |
| `PROT_WRITE` | 该区域的内容可以被修改 |
| `PROT_EXEC` | 该区域的内容可以被执行 |

*flags* 参数是一个位掩码，用于控制映射操作的各个方面。该掩码中必须包含以下值之一：

`MAP_PRIVATE`

创建一个私有映射。对该区域内容的修改不会对使用相同映射的其他进程可见，并且在文件映射的情况下，也不会传播到底层文件。

`MAP_SHARED`

创建一个共享映射。对该区域内容的修改会对其他映射相同区域的进程可见，并且在文件映射的情况下，会传播到底层文件。对文件的更新不一定会立即生效；请参见第 49.5 节中关于 *msync()* 系统调用的讨论。

除了`MAP_PRIVATE`和`MAP_SHARED`，其他标志值可以选择性地与*flags*进行按位或操作。我们在附加的 *mmap()* 标志 标志")和 `MAP_FIXED` 标志中讨论这些标志。

其余参数 *fd* 和 *offset* 用于文件映射（对于匿名映射会被忽略）。*fd* 参数是一个文件描述符，用于标识要映射的文件。*offset* 参数指定映射在文件中的起始位置，并且必须是系统页面大小的倍数。为了映射整个文件，我们会将 *offset* 指定为 0，将 *length* 指定为文件的大小。我们在第 49.5 节中详细讨论文件映射。

#### 内存保护的更多细节

如上所述，*mmap() prot* 参数指定对新内存映射的保护。它可以包含值 `PROT_NONE`，或者是一个或多个标志 `PROT_READ`、`PROT_WRITE` 和 `PROT_EXEC` 的按位掩码。如果一个进程尝试以违反区域保护的方式访问内存区域，内核会向该进程发送 `SIGSEGV` 信号。

### 注意

尽管 SUSv3 规定应使用 `SIGSEGV` 来信号化内存保护违规，但在某些实现中，`SIGBUS` 被用来代替。

标记为`PROT_NONE`的内存页的一种用途是作为进程分配的内存区域的开始或结束的保护页。如果进程不小心访问了标记为`PROT_NONE`的页面，内核将通过生成`SIGSEGV`信号通知进程这一情况。

内存保护位于进程私有的虚拟内存表中。因此，不同的进程可以以不同的保护方式映射相同的内存区域。

可以通过使用*mprotect()*系统调用来改变内存保护（更改内存保护: *mprotect()*")）。

在某些 UNIX 实现中，映射页上的实际保护可能与*prot*中指定的保护不完全相同。特别是，底层硬件的保护粒度限制（例如，较旧的 x86-32 架构）意味着在许多 UNIX 实现中，`PROT_READ`隐含着`PROT_EXEC`，反之亦然，在某些实现中，指定`PROT_WRITE`隐含着`PROT_READ`。然而，应用程序不应依赖这种行为；*prot*应该始终准确地指定所需的内存保护。

### 注意

现代的 x86-32 架构提供硬件支持，用于标记页表为*NX*（不可执行），并且自内核 2.6.8 以来，Linux 利用这一特性在 Linux/x86-32 上正确区分`PROT_READ`和`PROT_EXEC`权限。

#### 标准中指定的*offset*和*addr*的对齐限制

SUSv3 规定，*mmap()*的*offset*参数必须与页面对齐，并且如果指定了`MAP_FIXED`，*addr*参数也必须与页面对齐。Linux 遵循这些要求。然而，后来注意到 SUSv3 的要求与早期标准不同，后者对这些参数的要求更宽松。SUSv3 的措辞结果是（不必要地）使一些原本符合标准的实现变得不合规。SUSv4 则恢复了更宽松的要求：

+   实现可能要求*offset*是系统页面大小的倍数。

+   如果指定了`MAP_FIXED`，那么实现可能要求*addr*与页面对齐。

+   如果指定了`MAP_FIXED`，且*addr*非零，则*addr*和*offset*应该具有相同的余数，模系统页面大小。

    ### 注意

    对于*mprotect()*、*msync()*和*munmap()*的*addr*参数，也出现了类似的情况。SUSv3 规定该参数必须与页面对齐。SUSv4 则表示，某些实现可能要求该参数与页面对齐。

#### 示例程序

示例 49-1 创建私有文件映射")展示了如何使用*mmap()*来创建一个私有文件映射。这个程序是一个简单版的*cat(1)*。它映射命令行参数中指定的（整个）文件，然后将映射内容写入标准输出。

示例 49-1. 使用 *mmap()* 创建私有文件映射

```
`mmap/mmcat.c`
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    char *addr;
    int fd;
    struct stat sb;

    if (argc != 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s file\n", argv[0]);

    fd = open(argv[1], O_RDONLY);
    if (fd == -1)
        errExit("open");

    /* Obtain the size of the file and use it to specify the size of
       the mapping and the size of the buffer to be written */

    if (fstat(fd, &sb) == -1)
        errExit("fstat");

    addr = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (addr == MAP_FAILED)
        errExit("mmap");

    if (write(STDOUT_FILENO, addr, sb.st_size) != sb.st_size)
        fatal("partial/failed write");
    exit(EXIT_SUCCESS);
}
     `mmap/mmcat.c`
```

## 取消映射映射区域: *munmap()*

*munmap()* 系统调用执行 *mmap()* 的反向操作，从调用进程的虚拟地址空间中移除映射。

```
#include <sys/mman.h>

int `munmap`(void **addr*, size_t *length*);
```

### 注意

成功时返回 0，出错时返回 -1

*addr* 参数是要取消映射的地址范围的起始地址。它必须与页面边界对齐。（SUSv3 指定 *addr 必须* 与页面对齐。SUSv4 说实现 *可以* 要求此参数与页面对齐。）

*length* 参数是一个非负整数，指定要取消映射的区域大小（以字节为单位）。将取消映射直到下一个系统页面大小的倍数。

通常，我们取消映射整个映射。因此，我们将 *addr* 指定为之前 *mmap()* 调用返回的地址，并指定与 *mmap()* 调用中使用的相同的 *length* 值。下面是一个例子：

```
addr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
if (addr == MAP_FAILED)
    errExit("mmap");

/* Code for working with mapped region */

if (munmap(addr, length) == -1)
    errExit("munmap");
```

或者，我们可以取消映射映射的一部分，在这种情况下，映射将缩小或根据取消映射的位置被切割成两部分。也可以指定一个跨越多个映射的地址范围，在这种情况下，所有的映射都会被取消映射。

如果在 *addr* 和 *length* 指定的地址范围内没有映射，那么 *munmap()* 将不起作用，并返回 0（表示成功）。

在取消映射过程中，内核会移除进程在指定地址范围内持有的任何内存锁。（内存锁是通过 *mlock()* 或 *mlockall()* 建立的，详细说明见第 50.2 节。）

当一个进程终止或执行 *exec()* 时，它的所有映射会自动取消映射。

为了确保共享文件映射的内容被写入到底层文件，在使用 *munmap()* 取消映射之前，应该调用 *msync()* (同步映射区域: *msync()*"))。

## 文件映射

要创建文件映射，我们执行以下步骤：

1.  获取文件描述符，通常通过调用 *open()*。

1.  将该文件描述符作为 *fd* 参数传递给 *mmap()* 调用。

由于这些步骤，*mmap()* 将打开的文件内容映射到调用进程的地址空间中。调用了 *mmap()* 后，我们可以关闭文件描述符而不会影响映射。然而，在某些情况下，保持文件描述符打开可能是有用的——例如，参见 示例 49-1 创建私有文件映射")，以及 第五十四章。

### 注意

除了普通的磁盘文件外，还可以使用 *mmap()* 来映射各种真实和虚拟设备的内容，如硬盘、光盘以及 `/dev/mem`。

描述符 *fd* 所引用的文件必须已使用适当的权限打开，以便与 *prot* 和 *flags* 中指定的值匹配。特别是，文件必须始终以只读模式打开，如果在 *flags* 中指定了 `PROT_WRITE` 和 `MAP_SHARED`，则文件必须同时以读写模式打开。

*offset* 参数指定要从文件中映射的区域的起始字节，必须是系统页面大小的倍数。将 *offset* 指定为 0 会导致从文件开头开始映射。*length* 参数指定要映射的字节数。*offset* 和 *length* 参数共同确定要映射到内存的文件区域，如图 49-1 所示。

### 注意

在 Linux 中，文件映射的页面会在首次访问时被映射。这意味着，如果在 *mmap()* 调用后但在映射的相应部分（即页面）被访问之前对文件区域进行了更改，则如果该页面尚未加载到内存中，程序可能会看到这些更改。这种行为取决于实现；便携式应用程序应避免在这种情况下依赖特定的内核行为。

### 私有文件映射

私有文件映射的两种最常见用途如下：

+   允许多个执行相同程序或使用相同共享库的进程共享相同的（只读）文本段，该文本段是从底层可执行文件或库文件的相应部分映射过来的。

    ### 注意

    尽管可执行的文本段通常受到保护，只允许读取和执行访问（`PROT_READ | PROT_EXEC`），它是使用 `MAP_PRIVATE` 而非 `MAP_SHARED` 进行映射的，因为调试器或自修改程序可以修改程序文本（在首先更改内存保护后），这些修改不应该传递到底层文件中或影响其他进程。

+   映射可执行文件或共享库的初始化数据段。此类映射为私有，以便对映射数据段内容的修改不会传递到底层文件。

这两种* mmap() *的用途通常对程序是不可见的，因为这些映射是由程序加载器和动态链接器创建的。可以在第 48.5 节中看到这两种映射的示例，输出文件位于`/proc/`*PID*`/maps`中。

另一个较少见的私有文件映射用途是简化程序的文件输入逻辑。这类似于用于内存映射 I/O 的共享文件映射（将在下一节中描述），但仅允许文件输入。

![内存映射文件概览](img/49-1_MMAP-overview-scale90.png.jpg)图 49-1. 内存映射文件概览

### 共享文件映射

当多个进程创建相同文件区域的共享映射时，它们共享相同的物理内存页面。此外，对映射内容的修改会传递到文件中。实际上，文件被当作该内存区域的分页存储，如图 49-2 所示。（我们在此图中简化处理，省略了映射的页面在物理内存中通常不是连续的这一细节。）

共享文件映射有两个用途：内存映射 I/O 和进程间通信（IPC）。我们在下面将分别讨论这两种用途。

![两个进程共享同一文件区域的映射](img/49-2_MMAP-shared-mapping.png.jpg)图 49-2. 两个进程共享同一文件区域的映射

#### 内存映射 I/O

由于共享文件映射的内容是从文件初始化的，且对映射内容的任何修改都会自动传递到文件中，我们可以通过访问内存字节来执行文件 I/O，依靠内核确保内存的变化被传播到映射的文件中。（通常，一个程序会定义一个结构化数据类型，该数据类型对应磁盘文件的内容，然后使用该数据类型将映射的内容进行转换。）这种技术被称为*内存映射 I/O*，它是使用*read()*和*write()*访问文件内容的替代方案。

内存映射 I/O 有两个潜在的优点：

+   通过将*read()*和*write()*系统调用替换为内存访问，它可以简化某些应用程序的逻辑。

+   在某些情况下，它可以提供比使用传统 I/O 系统调用进行的文件 I/O 更好的性能。

内存映射 I/O 能够提供性能优势的原因如下：

+   正常的*read()*或*write()*操作涉及两个传输：一个是文件与内核缓冲区缓存之间的传输，另一个是缓冲区缓存与用户空间缓冲区之间的传输。使用*mmap()*可以消除第二个传输。对于输入，数据在内核将相应的文件块映射到内存中后，即可供用户进程使用。对于输出，用户进程只需修改内存内容，然后依靠内核内存管理器自动更新底层文件。

+   除了节省内核空间与用户空间之间的传输外，*mmap()*还可以通过降低内存需求来提高性能。当使用*read()*或*write()*时，数据会保存在两个缓冲区中：一个在用户空间，另一个在内核空间。而使用*mmap()*时，内核空间和用户空间之间共享一个缓冲区。此外，如果多个进程正在对同一文件进行 I/O 操作，那么使用*mmap()*时，它们可以共享同一个内核缓冲区，从而实现额外的内存节省。

在执行大文件的重复随机访问时，内存映射 I/O 的性能优势最为明显。如果我们在执行文件的顺序访问，那么 *mmap()* 可能不会比 *read()* 和 *write()* 提供更好的性能，前提是我们使用足够大的缓冲区大小，避免进行大量的 I/O 系统调用。之所以性能提升不明显，是因为无论使用哪种技术，文件的所有内容都会在磁盘和内存之间传输一次，而消除用户空间与内核空间之间的数据传输及减少内存使用的效率提升，通常与磁盘 I/O 所需的时间相比微不足道。

### 注意

内存映射 I/O 也可能有一些缺点。对于小型 I/O 操作，内存映射 I/O 的成本（即映射、页面错误、取消映射以及更新硬件内存管理单元的转换旁路缓存）可能实际上比简单的 *read()* 或 *write()* 更高。此外，内核有时可能难以高效地处理可写映射的写回操作（在这种情况下，使用 *msync()* 或 *sync_file_range()* 可以帮助提高效率）。

#### 使用共享文件映射进行进程间通信（IPC）

由于所有共享同一文件区域映射的进程共享相同的物理内存页面，第二次使用共享文件映射的方法就是作为一种（快速的）进程间通信（IPC）方式。这种共享内存区域与 System V 共享内存对象的区别在于（参见第四十八章")）的是，该区域内容的修改会反映到底层的映射文件中。这一特性在需要跨应用或系统重启保持共享内存内容的应用程序中非常有用。

#### 示例程序

示例 49-2 创建共享文件映射") 提供了一个使用 *mmap()* 创建共享文件映射的简单示例。该程序首先映射其第一个命令行参数指定的文件。然后打印映射区域起始处字符串的值。最后，如果提供了第二个命令行参数，该字符串将被复制到共享内存区域。

以下的 shell 会话日志演示了如何使用此程序。我们首先创建一个 1024 字节的文件，并用零填充：

```
$ `dd if=/dev/zero of=s.txt bs=1 count=1024`
1024+0 records in
1024+0 records out
```

然后，我们使用程序映射文件并将一个字符串复制到映射区域：

```
$ `./t_mmap s.txt hello`
Current string=
Copied "hello" to shared memory
```

程序没有显示当前字符串的内容，因为映射文件的初始值是一个空字节（即，零长度字符串）。

接下来，我们再次使用程序映射文件并将一个新的字符串复制到映射区域：

```
$ `./t_mmap s.txt goodbye`
Current string=hello
Copied "goodbye" to shared memory
```

最后，我们将文件内容按每行 8 个字符的方式转储，以验证其内容：

```
$ `od -c -w8 s.txt`
0000000   g   o   o   d   b   y   e nul
0000010 nul nul nul nul nul nul nul nul
*
0002000
```

我们的简单程序没有使用任何机制来同步多个进程对映射文件的访问。然而，现实世界的应用通常需要同步对共享映射的访问。这可以通过多种技术实现，包括信号量（第四十七章和第五十三章）以及文件锁定（第五十五章）。

我们在第 49.5 节中解释了在示例 49-2 创建共享文件映射")中使用的*msync()*系统调用。

示例 49-2. 使用*mmap()*创建共享文件映射

```
`mmap/t_mmap.c`
#include <sys/mman.h>
#include <fcntl.h>
#include "tlpi_hdr.h"

#define MEM_SIZE 10

int
main(int argc, char *argv[])
{
    char *addr;
    int fd;

    if (argc < 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s file [new-value]\n", argv[0]);

    fd = open(argv[1], O_RDWR);
    if (fd == -1)
        errExit("open");

    addr = mmap(NULL, MEM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED)
        errExit("mmap");

    if (close(fd) == -1)                /* No longer need 'fd' */
        errExit("close");

    printf("Current string=%.*s\n", MEM_SIZE, addr);
                /* Secure practice: output at most MEM_SIZE bytes */

    if (argc > 2) {                     /* Update contents of region */
        if (strlen(argv[2]) >= MEM_SIZE)
            cmdLineErr("'new-value' too large\n");

        memset(addr, 0, MEM_SIZE);      /* Zero out region */
        strncpy(addr, argv[2], MEM_SIZE - 1);
        if (msync(addr, MEM_SIZE, MS_SYNC) == -1)
            errExit("msync");

        printf("Copied \"%s\" to shared memory\n", argv[2]);
    }

    exit(EXIT_SUCCESS);
}
     `mmap/t_mmap.c`
```

### 边界情况

在许多情况下，映射的大小是系统页面大小的倍数，且映射完全位于映射文件的范围内。然而，这并非总是如此，我们现在来看当这些条件不成立时会发生什么。

图 49-3 描述了映射完全位于映射文件的范围内，但该区域的大小不是系统页面大小的倍数的情况（在本讨论中我们假设系统页面大小为 4096 字节）。

![内存映射长度不是系统页面大小的倍数](img/49-3_MMAP-size-part-1.png.jpg)图 49-3. 内存映射长度不是系统页面大小的倍数

由于映射的大小不是系统页面大小的倍数，它会被向上舍入到下一个系统页面大小的倍数。因为文件大于这个舍入后的大小，所以文件的相应字节会如图 49-3 所示进行映射。

尝试访问映射结束位置之后的字节会导致生成`SIGSEGV`信号（假设该位置没有其他映射）。此信号的默认动作是终止进程并生成核心转储。

当映射超出底层文件的末尾时（见图 49-4），情况会更复杂。如前所述，由于映射的大小不是系统页面大小的倍数，它会被向上舍入。然而，在这种情况下，尽管舍入区域（即图中的字节 2200 到 4095）是可访问的，但它们并没有映射到底层文件（因为文件中没有相应的字节）。相反，它们会被初始化为 0（SUSv3 要求这样做）。这些字节仍然会与映射该文件的其他进程共享，如果它们指定了足够大的*length*参数。这些字节的更改不会写入文件。

如果映射包含超出舍入区域的页（即，图 49-4 中的字节 4096 及以后），则尝试访问这些页面中的地址会生成 `SIGBUS` 信号，警告进程该文件中没有对应这些地址的区域。如前所述，尝试访问映射末尾之外的地址会生成 `SIGSEGV` 信号。

从上述描述来看，创建一个映射，其大小超出底层文件的大小似乎毫无意义。然而，通过扩展文件的大小（例如，使用 *ftruncate()* 或 *write()*），我们可以使该映射中之前无法访问的部分变得可用。

![超出映射文件末尾的内存映射](img/49-4_MMAP-size-part-2.png.jpg)图 49-4。超出映射文件末尾的内存映射

### 内存保护与文件访问模式的相互作用

我们至今尚未详细解释的一个要点是，*mmap() prot* 参数中指定的内存保护与映射文件打开模式之间的相互作用。作为一般原则，我们可以说，`PROT_READ` 和 `PROT_EXEC` 保护要求映射文件以 `O_RDONLY` 或 `O_RDWR` 模式打开，而 `PROT_WRITE` 保护要求映射文件以 `O_WRONLY` 或 `O_RDWR` 模式打开。

然而，情况因某些硬件架构提供的内存保护的粒度有限而变得复杂（创建映射：*mmap()*")）。对于这些架构，我们提出以下观察：

+   所有内存保护的组合都可以与 `O_RDWR` 标志一起打开文件。

+   没有任何内存保护的组合——即使是仅仅 `PROT_WRITE`——可以与以 `O_WRONLY` 模式打开的文件兼容（会导致错误 `EACCES`）。这与某些硬件架构不允许我们对页面进行只写访问这一事实一致。如创建映射：*mmap()*")中所述，`PROT_WRITE` 在这些架构上意味着 `PROT_READ`，即如果页面可以被写入，那么它也可以被读取。读取操作与 `O_WRONLY` 不兼容，因为 `O_WRONLY` 必须不会显示文件的原始内容。

+   使用`O_RDONLY`标志打开文件时的结果取决于在调用*mmap()*时是否指定了`MAP_PRIVATE`或`MAP_SHARED`。对于`MAP_PRIVATE`映射，可以在*mmap()*中指定任何组合的内存保护——因为对`MAP_PRIVATE`页面内容的修改永远不会写入文件，所以无法写入文件不是问题。对于`MAP_SHARED`映射，唯一与`O_RDONLY`兼容的内存保护是`PROT_READ`和`(PROT_READ | PROT_EXEC)`。这是合乎逻辑的，因为`PROT_WRITE`和`MAP_SHARED`映射允许更新映射的文件。

## 同步映射区域：*msync()*

内核会自动将`MAP_SHARED`映射的内容修改传递到底层文件中，但默认情况下，内核不保证同步操作何时发生。（SUSv3 并没有要求实现提供此类保证。）

*msync()*系统调用使应用程序可以显式控制何时将共享映射与映射文件同步。将映射与底层文件同步在多种场景中都非常有用。例如，为了确保数据完整性，数据库应用程序可能会调用*msync()*强制将数据写入磁盘。调用*msync()*还允许应用程序确保对可写映射的更新对其他执行*read()*操作的进程可见。

```
#include <sys/mman.h>

int `msync`(void **addr*, size_t *length*, int *flags*);
```

### 注

成功时返回 0，出错时返回-1

*msync()*的*addr*和*length*参数指定要同步的内存区域的起始地址和大小。*addr*指定的地址必须按页对齐，*len*会向上舍入到系统页面大小的下一个倍数。（SUSv3 规定*addr 必须*按页对齐。SUSv4 则表示实现*可以*要求此参数按页对齐。）

*flags*参数的可能值包括以下之一：

`MS_SYNC`

执行同步文件写入。调用会阻塞，直到内存区域的所有修改页面都写入磁盘。

`MS_ASYNC`

执行异步文件写入。内存区域的修改页面将在稍后的某个时间点写入磁盘，并且会立即对其他执行*read()*操作的进程可见。

区分这两个值的另一种方式是：在执行`MS_SYNC`操作后，内存区域与磁盘同步，而在执行`MS_ASYNC`操作后，内存区域仅与内核缓冲区缓存同步。

### 注

如果我们在`MS_ASYNC`操作后不采取进一步的行动，那么内存区域中修改的页面最终会作为自动缓冲区刷新的一部分被刷新，由*pdflush*内核线程执行（在 Linux 2.4 及更早版本中为*kupdated*）。在 Linux 上，有两种（非标准的）方法可以更早地启动输出。我们可以在调用*msync()*后，再调用对应映射文件描述符的*fsync()*（或*fdatasync()*）。该调用将阻塞，直到缓冲区缓存与磁盘同步。或者，我们可以通过*posix_fadvise()*的`POSIX_FADV_DONTNEED`操作来发起页面的异步写入。（这两种方法中的 Linux 特定细节没有在 SUSv3 中指定。）

还可以为*flags*指定其他一个值：

`MS_INVALIDATE`

使映射数据的缓存副本失效。在内存区域中的任何修改过的页面与文件同步后，所有与底层文件数据不一致的内存区域页面都会被标记为无效。当下次引用这些页面时，其内容将从文件中的相应位置复制过来。因此，任何由其他进程对文件进行的更新都会在内存区域中可见。

与许多现代 UNIX 实现一样，Linux 提供了所谓的*统一虚拟内存*系统。这意味着，在可能的情况下，内存映射和缓冲区缓存块共享相同的物理内存页面。因此，通过映射和通过 I/O 系统调用（*read()*、*write()*等）获得的文件视图始终是一致的，*msync()*的唯一用途是强制将映射区域的内容刷新到磁盘。

然而，SUSv3 并不要求统一的虚拟内存系统，并且并非所有 UNIX 实现都采用这一系统。在这样的系统上，需要调用*msync()*来使映射内容的更改对其他调用*read()*文件的进程可见，而`MS_INVALIDATE`标志则用于执行相反的操作，使另一个进程对文件的写入在映射区域内可见。使用*mmap()*和 I/O 系统调用操作同一文件的多进程应用程序，应当设计为适当地使用*msync()*，以确保能够在没有统一虚拟内存系统的系统上移植。

## 其他*mmap()*标志

除了`MAP_PRIVATE`和`MAP_SHARED`，Linux 还允许在*mmap()标志*参数中包含其他多个值（进行 OR 操作）。表 49-3 标志参数的位掩码值")总结了这些值。除了`MAP_PRIVATE`和`MAP_SHARED`，SUSv3 中只指定了`MAP_FIXED`标志。

表 49-3. mmap()标志参数的位掩码值

| 值 | 描述 | SUSv3 |
| --- | --- | --- |
| `MAP_ANONYMOUS` | 创建一个匿名映射 |   |
| `MAP_FIXED` | 精确解释 *addr* 参数（《MAP_FIXED 标志》） | • |
| `MAP_LOCKED` | 将映射的页面锁定到内存中（从 Linux 2.6 开始） |   |
| `MAP_HUGETLB` | 创建使用大页面的映射（从 Linux 2.6.32 开始） |   |
| `MAP_NORESERVE` | 控制交换空间的预留（`MAP_NORESERVE` 和交换空间过度分配） |   |
| `MAP_PRIVATE` | 对映射数据的修改是私有的 | • |
| `MAP_POPULATE` | 填充映射的页面（从 Linux 2.6 开始） | • |
| `MAP_SHARED` | 对映射数据的修改对其他进程可见，并传播到底层文件（与 `MAP_PRIVATE` 相对） | • |
| `MAP_UNINITIALIZED` | 不清除匿名映射（从 Linux 2.6.33 开始） |   |

以下列表提供了表 49-3 标志参数的位掩码值")中列出的*标志*值的更多细节（除了 `MAP_PRIVATE` 和 `MAP_SHARED`，它们已在前文中讨论过）：

`MAP_ANONYMOUS`

创建匿名映射——即没有文件支持的映射。我们将在第 49.7 节进一步描述此标志。

`MAP_FIXED`

我们在《`MAP_FIXED` 标志》中进一步描述了该标志。

`MAP_HUGETLB`（从 Linux 2.6.32 开始）

该标志与 *mmap()* 中的作用与 `SHM_HUGETLB` 标志在 System V 共享内存段中的作用相同。参见第 48.2 节。

`MAP_LOCKED`（从 Linux 2.6 开始）

以 *mlock()* 的方式预加载并锁定映射的页面到内存中。我们将在第 50.2 节描述使用此标志所需的权限和其操作的限制。

`MAP_NORESERVE`

该标志用于控制是否提前为映射预留交换空间。有关详细信息，请参见 `MAP_NORESERVE` 和交换空间过度分配。

`MAP_POPULATE`（从 Linux 2.6 开始）

填充映射的页面。对于文件映射，这将对文件执行预读操作。这意味着稍后访问映射内容时，不会因页面错误而阻塞（假设内存压力没有导致页面被交换出去）。

`MAP_UNINITIALIZED`（从 Linux 2.6.33 开始）

指定此标志会阻止匿名映射的页面被清零。它提供了性能上的优势，但带来了安全风险，因为分配的页面可能包含前一个进程留下的敏感信息。因此，这个标志仅适用于嵌入式系统，在这些系统中，性能可能是关键，并且整个系统由嵌入式应用程序控制。只有在内核配置了 `CONFIG_MMAP_ALLOW_UNINITIALIZED` 选项时，才会尊重此标志。

## 匿名映射

*匿名映射*是指没有对应文件的映射。在本节中，我们展示如何创建匿名映射，并讨论私有和共享匿名映射的用途。

#### `MAP_ANONYMOUS`和`/dev/zero`

在 Linux 中，有两种不同的等效方法可以使用*mmap()*创建匿名映射：

+   在*flags*中指定`MAP_ANONYMOUS`，并将*fd*指定为-1。（在 Linux 中，当指定`MAP_ANONYMOUS`时，*fd*的值会被忽略。然而，一些 UNIX 实现要求在使用`MAP_ANONYMOUS`时*fd*必须为-1，便于移植的应用程序应确保这样做。）

    ### 注意

    我们必须定义`_BSD_SOURCE`或`_SVID_SOURCE`功能测试宏，才能从`<sys/mman.h>`中获取`MAP_ANONYMOUS`的定义。为了与一些使用此替代名称的其他 UNIX 实现兼容，Linux 提供了常量`MAP_ANON`，作为`MAP_ANONYMOUS`的同义词。

+   打开`/dev/zero`设备文件，并将结果文件描述符传递给*mmap()*。

    ### 注意

    `/dev/zero`是一个虚拟设备，当我们从中读取时，它总是返回零。写入该设备的内容会被丢弃。`/dev/zero`的常见用途是用零填充文件（例如，使用*dd(1)*命令）。

使用`MAP_ANONYMOUS`和`/dev/zero`技术时，结果映射的字节会被初始化为 0。对于这两种技术，*offset*参数被忽略（因为没有基础文件可以指定偏移量）。我们很快将展示每种技术的示例。

### 注意

尽管大多数 UNIX 实现支持其中之一或两者，`MAP_ANONYMOUS`和`/dev/zero`技术在 SUSv3 中并未被指定。存在两种具有相同语义的不同技术的原因是，`MAP_ANONYMOUS`源自 BSD，而`/dev/zero`源自 System V。

#### `MAP_PRIVATE`匿名映射

`MAP_PRIVATE`匿名映射用于分配初始化为 0 的进程私有内存块。我们可以使用`/dev/zero`技术创建一个`MAP_PRIVATE`匿名映射，如下所示：

```
fd = open("/dev/zero", O_RDWR);
if (fd == -1)
    errExit("open");
addr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
if (addr == MAP_FAILED)
    errExit("mmap");
```

### 注意

*glibc*对*malloc()*的实现使用`MAP_PRIVATE`匿名映射来分配大于`MMAP_THRESHOLD`字节的内存块。这使得如果这些内存块后来被传递给*free()*，可以高效地释放它们（通过*munmap()*）。这也减少了在反复分配和释放大块内存时发生内存碎片的可能性。默认情况下，`MMAP_THRESHOLD`为 128 kB，但可以通过*mallopt()*库函数调整此参数。

#### `MAP_SHARED`匿名映射

`MAP_SHARED`匿名映射允许相关进程（例如父进程和子进程）共享一块内存区域，而无需对应的映射文件。

### 注意

`MAP_SHARED`匿名映射仅在 Linux 2.4 及更高版本中可用。

我们可以使用`MAP_ANONYMOUS`技术创建一个`MAP_SHARED`匿名映射，如下所示：

```
addr = mmap(NULL, length, PROT_READ | PROT_WRITE,
            MAP_SHARED | MAP_ANONYMOUS, -1, 0);
if (addr == MAP_FAILED)
    errExit("mmap");
```

如果上述代码后跟一个 *fork()* 调用，那么，由于 *fork()* 产生的子进程继承了映射，两个进程共享内存区域。

#### 示例程序

示例 49-3 中的程序演示了使用 `MAP_ANONYMOUS` 或 `/dev/zero` 来共享父子进程之间的映射区域。所选技术由编译程序时是否定义 `USE_MAP_ANON` 决定。父进程在调用 *fork()* 之前将共享区域中的整数初始化为 1。然后，子进程递增共享整数并退出，而父进程等待子进程退出并打印整数值。当我们运行此程序时，我们会看到以下内容：

```
$ `./anon_mmap`
Child started, value = 1
In parent, value = 2
```

示例 49-3. 在父进程和子进程之间共享匿名映射

```
`mmap/anon_mmap.c`
#ifdef USE_MAP_ANON
#define _BSD_SOURCE             /* Get MAP_ANONYMOUS definition */
#endif
#include <sys/wait.h>
#include <sys/mman.h>
#include <fcntl.h>
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int *addr;                  /* Pointer to shared memory region */

#ifdef USE_MAP_ANON             /* Use MAP_ANONYMOUS */
    addr = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE,
                MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (addr == MAP_FAILED)
        errExit("mmap");

#else                           /* Map /dev/zero */
    int fd;

    fd = open("/dev/zero", O_RDWR);
    if (fd == -1)
        errExit("open");

    addr = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED)
        errExit("mmap");

    if (close(fd) == -1)        /* No longer needed */
        errExit("close");
#endif

    *addr = 1;                  /* Initialize integer in mapped region */

    switch (fork()) {           /* Parent and child share mapping */
    case -1:
        errExit("fork");

    case 0:                     /* Child: increment shared integer and exit */
        printf("Child started, value = %d\n", *addr);
        (*addr)++;

        if (munmap(addr, sizeof(int)) == -1)
            errExit("munmap");
        exit(EXIT_SUCCESS);

    default:                    /* Parent: wait for child to terminate */
        if (wait(NULL) == -1)
            errExit("wait");
        printf("In parent, value = %d\n", *addr);
        if (munmap(addr, sizeof(int)) == -1)
            errExit("munmap");
        exit(EXIT_SUCCESS);
    }
}
      `mmap/anon_mmap.c`
```

## 重新映射已映射区域：*mremap()*

在大多数 UNIX 实现中，一旦创建了映射，其位置和大小是无法更改的。然而，Linux 提供了（不便携的）*mremap()* 系统调用，允许进行这种更改。

```
#define _GNU_SOURCE
#include <sys/mman.h>

void *`mremap`(void **old_address*, size_t *old_size*, size_t *new_size*,
 int *flags*, ...);
```

### 注意

成功时返回重新映射区域的起始地址，出错时返回 `MAP_FAILED`

*old_address* 和 *old_size* 参数指定了我们希望扩展或缩小的现有映射的地址和大小。*old_address* 中指定的地址必须是页对齐的，通常是通过先前调用 *mmap()* 返回的值。映射的期望新大小由 *new_size* 指定。*old_size* 和 *new_size* 中指定的值都被向上舍入到系统页大小的下一个倍数。

在执行重新映射时，内核可能会将映射重新定位到进程的虚拟地址空间内。是否允许这样做由 *flags* 参数控制，该参数是一个位掩码，可以是 0 或包括以下值：

`MREMAP_MAYMOVE`

如果指定了此标志，那么根据空间需求，内核可能会将映射重新定位到进程的虚拟地址空间内。如果未指定此标志，并且在当前地址位置没有足够的空间来扩展映射，那么会返回错误 `ENOMEM`。

`MREMAP_FIXED`（自 Linux 2.4 起）

此标志只能与 `MREMAP_MAYMOVE` 一起使用。它在 *mremap()* 中的作用类似于 `MAP_FIXED` 在 *mmap()* 中的作用（`MAP_FIXED` 标志）。如果指定此标志，那么 *mremap()* 会接受一个额外的参数 *void *new_address*，指定一个页对齐的地址，映射将被移动到该地址。任何位于 *new_address* 和 *new_size* 指定的地址范围内的先前映射都会被取消映射。

成功时，*mremap()* 返回映射的起始地址。由于（如果指定了 `MREMAP_MAYMOVE` 标志）这个地址可能与之前的起始地址不同，因此指向该区域的指针可能不再有效。因此，使用 *mremap()* 的应用程序应该仅使用偏移量（而非绝对指针）来引用映射区域中的地址（参见 存储指针在共享内存中）。

### 注意

在 Linux 上，*realloc()* 函数使用 *mremap()* 来高效地重新分配 *malloc()* 之前通过 *mmap()* `MAP_ANONYMOUS` 分配的大块内存。（我们在第 49.7 节中提到过 *glibc malloc()* 实现的这一特性。）使用 *mremap()* 来处理这一任务可以避免在重新分配过程中复制字节。

## `MAP_NORESERVE` 与交换空间过度分配

一些应用程序会创建大的（通常是私有匿名的）映射，但只使用映射区域的一小部分。例如，某些类型的科学应用会分配一个非常大的数组，但只操作数组中几个相距较远的元素（所谓的 *稀疏数组*）。

如果内核总是为这些映射的整个区域分配（或保留）足够的交换空间，那么很多交换空间可能会被浪费。相反，内核可以仅在实际需要时（即当应用程序访问某个页面时）为映射的页面保留交换空间。这种方法称为 *延迟交换空间预留*，其优点是应用程序使用的总虚拟内存可以超过物理内存加交换空间的总大小。

换句话说，延迟交换空间预留允许交换空间被过度分配。只要所有进程不试图访问它们映射的整个范围，这种方式是有效的。然而，如果所有应用程序都试图访问它们映射的完整范围，则内存和交换空间将被耗尽。在这种情况下，内核通过杀死系统中的一个或多个进程来减少内存压力。理想情况下，内核会尝试选择导致内存问题的进程（请参见下面关于 *OOM killer* 的讨论），但这并不能得到保证。出于这个原因，我们可能会选择禁止延迟交换空间预留，转而强制系统在创建映射时分配所有必要的交换空间。

内核如何处理交换空间的预留是通过在调用 *mmap()* 时使用 `MAP_NORESERVE` 标志来控制的，也通过影响系统范围内交换空间过度分配操作的 `/proc` 接口来控制。这些因素总结在 表 49-4 中的交换空间预留") 中。

表 49-4. 处理 *mmap()* 中的交换空间预留

| `overcommit_memory` 值 | 是否在 *mmap()* 调用中指定了 `MAP_NORESERVE`？ |
| --- | --- |
| 否 | 是 |
| --- | --- |
| 0 | 否定明显的超分配 | 允许超分配 |
| 1 | 允许超分配 | 允许超分配 |
| 2（自 Linux 2.6 起） | 严格超分配 |

Linux 特定的`/proc/sys/vm/overcommit_memory`文件包含一个整数值，用于控制内核处理交换空间超分配。Linux 2.6 之前的版本只区分该文件中的两个值：0，意味着否定明显的超分配（取决于使用`MAP_NORESERVE`标志），大于 0，意味着在所有情况下都允许超分配。

否定明显的超分配意味着允许新的映射，其大小不超过当前可用的空闲内存。现有的分配可能会超分配（因为它们可能没有使用所有已映射的页面）。

从 Linux 2.6 开始，值 1 与早期内核中的正值具有相同的含义，但值 2（或更大）会导致*严格超分配*的启用。在这种情况下，内核会对所有*mmap()*分配进行严格的计数，并将所有此类分配的系统范围总量限制为小于或等于：

```
[swap size] + [RAM size] * overcommit_ratio / 100
```

`overcommit_ratio`值是一个整数—表示为百分比—包含在 Linux 特定的`/proc/sys/vm/overcommit_ratio`文件中。此文件中的默认值为 50，意味着内核可以将系统 RAM 大小的 50%进行超分配，并且只要不是所有进程都试图使用它们的完整分配，这种做法是成功的。

注意，超分配监控仅适用于以下类型的映射：

+   私有可写映射（包括文件和匿名映射），对于这种映射，映射的交换“成本”是每个使用该映射的进程映射大小的大小；

+   共享匿名映射，对于这种映射，交换“成本”是映射的大小（因为所有进程共享该映射）。

为只读私有映射预留交换空间是没有必要的：因为该映射的内容无法修改，所以不需要使用交换空间。共享文件映射也不需要交换空间，因为映射的文件本身就充当了该映射的交换空间。

当一个子进程通过*fork()*继承一个映射时，它会继承该映射的`MAP_NORESERVE`设置。`MAP_NORESERVE`标志在 SUSv3 中没有指定，但它在其他一些 UNIX 实现中得到了支持。

### 注意

在本节中，我们讨论了由于系统对 RAM 和交换空间的限制，调用*mmap()*可能会导致进程地址空间无法增加。调用*mmap()*也可能失败，因为它遇到了每个进程的`RLIMIT_AS`资源限制（在具体资源限制详情中描述），该限制对调用进程的地址空间大小设置了上限。

#### OOM 杀手

如上所述，我们注意到，当我们采用懒性交换预留时，如果应用程序试图使用其映射的整个范围，内存可能会耗尽。在这种情况下，内核通过终止进程来缓解内存耗尽。

用于在内存耗尽时选择要终止的进程的内核代码通常称为内存耗尽 (OOM) Killer。OOM Killer 会尽力选择最合适的进程来终止，以缓解内存耗尽的情况，其中“最合适”的定义由多个因素决定。例如，进程消耗的内存越多，它成为 OOM Killer 终止候选进程的可能性就越大。其他增加进程被选中的因素包括创建许多子进程的分叉操作以及具有较低的 nice 值（即大于 0 的值）。内核不倾向于终止以下进程：

+   具有特权的进程，因为它们可能正在执行重要任务；

+   正在进行原始设备访问的进程，因为终止它们可能会使设备处于不可用状态；

+   已运行很长时间或消耗了大量 CPU 的进程，因为终止它们会导致大量“工作”丧失。

为了终止选定的进程，OOM Killer 会发送一个 `SIGKILL` 信号。

Linux 特定的 `/proc/`*PID*`/oom_score` 文件，自内核 2.6.11 版本以来可用，显示内核在需要调用 OOM Killer 时对进程的权重。该文件中的值越大，进程被 OOM Killer 选择的可能性越大，若有必要的话。另一个 Linux 特定的 `/proc/`*PID*`/oom_adj` 文件，也自内核 2.6.11 版本以来可用，可用于影响进程的 `oom_score`。该文件可以设置为 -16 到 +15 之间的任意值，其中负值会降低 `oom_score`，正值则会增加它。特殊值 -17 会完全将进程移除，排除在 OOM Killer 选择候选进程之外。有关详细信息，请参见 *proc(5)* 手册页。

## `MAP_FIXED` 标志

在 *mmap() flags* 参数中指定 `MAP_FIXED` 会强制内核严格按照 *addr* 中指定的地址解释，而不是将其作为提示。如果指定了 `MAP_FIXED`，*addr* 必须与页面对齐。

通常，便携式应用程序应该避免使用 `MAP_FIXED`，并将 *addr* 指定为 `NULL`，这样系统就可以选择映射的地址。这样做的原因与我们在 使用共享内存 中解释的相同，通常建议在使用 *shmat()* 附加一个 System V 共享内存段时将 *shmaddr* 指定为 `NULL`。

然而，有一种情况，便携式应用程序可能会使用 `MAP_FIXED`。如果在调用 *mmap()* 时指定了 `MAP_FIXED`，并且从 *addr* 开始并持续 *length* 字节的内存区域与任何先前映射的页面重叠，那么重叠的页面将被新映射替换。我们可以利用此功能将多个文件（或文件的不同部分）便携地映射到一个连续的内存区域，如下所示：

1.  使用 *mmap()* 创建匿名映射（匿名映射）。在 *mmap()* 调用中，我们将 *addr* 指定为 `NULL`，并且不指定 `MAP_FIXED` 标志。这样允许内核选择一个地址来进行映射。

1.  使用一系列带有 `MAP_FIXED` 标志的 *mmap()* 调用，将文件区域映射（即覆盖）到前一步创建的映射的不同部分。

尽管我们可以跳过第一步，直接使用一系列带有 `MAP_FIXED` 标志的 *mmap()* 操作，在应用程序选择的地址范围内创建一组连续的映射，但这种方法不如执行两个步骤更具可移植性。如上所述，便携式应用程序应避免在固定地址处尝试创建新映射。第一步避免了可移植性问题，因为我们让内核选择一个连续的地址范围，然后在该地址范围内创建新的映射。

从 Linux 2.6 开始，*remap_file_pages()* 系统调用（我们将在下一节中描述）也可以用来实现相同的效果。然而，使用 `MAP_FIXED` 比使用 *remap_file_pages()* 更具可移植性，因为后者是特定于 Linux 的。

## 非线性映射：*remap_file_pages()*

使用 *mmap()* 创建的文件映射是线性的：映射文件的页面与内存区域的页面之间存在顺序的一一对应关系。对于大多数应用程序来说，线性映射已足够。然而，一些应用程序需要创建大量的非线性映射——即文件的页面在连续内存中以不同的顺序出现。我们在图 49-5 中展示了一个非线性映射的示例。

我们在上一节中描述了创建非线性映射的一种方法：使用多个带有 `MAP_FIXED` 标志的 *mmap()* 调用。然而，这种方法的扩展性较差。问题在于，每个 *mmap()* 调用都会创建一个单独的内核虚拟内存区域（VMA）数据结构。每个 VMA 都需要时间来设置，并消耗一些不可交换的内核内存。此外，大量的 VMA 会降低虚拟内存管理器的性能；尤其是在存在数万个 VMA 时，处理每个页面错误的时间可能会显著增加。（这曾是一些大型数据库管理系统的一个问题，它们在数据库文件中维护多个不同的视图。）

### 注意

`/proc/`*PID*`/maps`文件中的每一行（虚拟内存中共享内存的位置）表示一个 VMA。

从 2.6 版本开始，Linux 提供了*remap_file_pages()*系统调用，可以在不创建多个 VMA 的情况下创建非线性映射。我们可以按以下方式进行操作：

1.  使用*mmap()*创建映射。

1.  使用一个或多个调用*remap_file_pages()*重新排列内存页面和文件页面之间的对应关系。（*remap_file_pages()*所做的只是操作进程的页面表。）

    ### 注意

    可以使用*remap_file_pages()*将同一文件页面映射到映射区域中的多个位置。

```
#define _GNU_SOURCE
#include <sys/mman.h>

int `remap_file_pages`(void **addr*, size_t *size*, int *prot*, size_t
 *pgoff*, int *flags*);
```

### 注意

成功时返回 0，出错时返回-1

*pgoff*和*size*参数标识要更改内存中位置的文件区域。*pgoff*参数指定文件区域的起始位置，以系统页面大小为单位（由*sysconf(_SC_PAGESIZE)*返回）。*size*参数指定文件区域的长度，单位为字节。*addr*参数有两个用途：

+   它标识我们希望重新排列的页面的现有映射。换句话说，*addr*必须是之前通过*mmap()*映射的某个区域内的地址。

+   它指定了文件页面的位置，这些文件页面由*pgoff*和*size*标识。

*addr*和*size*都应该指定为系统页面大小的倍数。如果不是，它们会向下舍入到页面大小的最接近倍数。

假设我们使用以下调用*mmap()*将描述符*fd*所引用的打开文件的三个页面映射，并且该调用将返回的地址`0x4001a000`分配给*addr*：

```
ps = sysconf(_SC_PAGESIZE);               /* Obtain system page size */
addr = mmap(0, 3 * ps, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
```

以下调用将创建图 49-5 中所示的非线性映射：

```
remap_file_pages(addr, ps, 0, 2, 0);
                            /* Maps page 0 of file into page 2 of region */
remap_file_pages(addr + 2 * ps, ps, 0, 0, 0);
                            /* Maps page 2 of file into page 0 of region */
```

![非线性文件映射](img/49-5_MMAP-nonlinear.png.jpg)图 49-5. 非线性文件映射

还有两个*remap_file_pages()*的其他参数我们尚未描述：

+   *prot*参数被忽略，必须指定为 0。将来，可能可以使用此参数来更改受*remap_file_pages()*影响的内存区域的保护状态。在当前的实现中，保护状态与整个 VMA 的保护状态保持一致。

    ### 注意

    虚拟机和垃圾回收器是使用多个 VMA 的其他应用程序。这些应用程序中的一些需要能够保护单个页面的写入权限。原本*remap_file_pages()*的设计是允许更改 VMA 内单个页面的权限，但这一功能目前尚未实现。

+   *flags*参数当前未使用。

根据当前的实现，*remap_file_pages()*只能应用于共享（`MAP_SHARED`）映射。

*remap_file_pages()* 系统调用是 Linux 特有的；它在 SUSv3 中没有指定，并且在其他 UNIX 实现中不可用。

## 摘要

*mmap()* 系统调用在调用进程的虚拟地址空间中创建一个新的内存映射。*munmap()* 系统调用执行相反的操作，从进程的地址空间中移除一个映射。

映射可以分为两种类型：基于文件的或匿名的。文件映射将文件区域的内容映射到进程的虚拟地址空间。匿名映射（通过使用 `MAP_ANONYMOUS` 标志或通过映射 `/dev/zero` 创建）没有对应的文件区域；映射的字节被初始化为 0。

映射可以是私有的（`MAP_PRIVATE`）或共享的（`MAP_SHARED`）。这一区别决定了对共享内存所做的更改的可见性，并且在文件映射的情况下，决定了内核是否将对映射内容的更改传播到底层文件。当进程使用 `MAP_PRIVATE` 标志映射文件时，对映射内容所做的任何更改不会对其他进程可见，也不会反映到映射的文件中。`MAP_SHARED` 文件映射则相反——对映射所做的更改对其他进程可见，并会传递到映射的文件中。

尽管内核会自动将对 `MAP_SHARED` 映射内容的更改传播到底层文件，但它并没有提供关于何时完成此操作的任何保证。应用程序可以使用 *msync()* 系统调用显式控制何时将映射的内容与映射文件同步。

内存映射有多种用途，包括：

+   分配进程私有内存（私有匿名映射）；

+   初始化进程的文本段和已初始化数据段的内容（私有文件映射）；

+   通过 *fork()* 共享内存的进程（共享匿名映射）；以及

+   执行内存映射 I/O，可选地与无关进程之间的内存共享结合使用（共享文件映射）。

在访问映射内容时，可能会触发两个信号。`SIGSEGV` 会在我们以违反映射保护的方式访问（或访问任何当前未映射的地址）时生成。对于基于文件的映射，如果我们访问映射的某个部分，而该部分在文件中没有对应区域（即映射大于底层文件），则会生成 `SIGBUS`。

交换空间过度分配允许系统分配比实际可用的内存和交换空间更多的内存给进程。过度分配之所以可能，是因为通常每个进程不会完全使用其分配的内存。可以通过在每个 *mmap()* 调用中使用 `MAP_NORESERVE` 标志，或者通过 `/proc` 文件在系统级别控制过度分配。

*mremap()* 系统调用允许调整现有映射的大小。*remap_file_pages()* 系统调用允许创建非线性的文件映射。

#### 进一步信息

关于 Linux 上*mmap()*实现的相关信息可以参考[Bovet & Cesati, 2005]。关于其他 UNIX 系统上*mmap()*实现的相关信息可以参考[McKusick et al., 1996]（BSD），[Goodheart & Cox, 1994]（System V Release 4）和[Vahalia, 1996]（System V Release 4）。

## 练习题

1.  编写一个程序，类似于*cp(1)*，该程序使用*mmap()*和*memcpy()*调用（而不是*read()*或*write()*）将源文件复制到目标文件中。（使用*fstat()*获取输入文件的大小，然后可以用它来设置所需的内存映射大小，并使用*ftruncate()*设置输出文件的大小。）

1.  重新编写 Example 48-2（`svshm_xfr_writer.c`，第 1003 页）和 Example 48-3（`svshm_xfr_reader.c`，第 1005 页）的程序，改为使用共享内存映射，而不是 System V 共享内存。

1.  编写程序验证在 Boundary Cases 中描述的情况下，`SIGBUS`和`SIGSEGV`信号是否会被传递。

1.  编写一个程序，使用 The `MAP_FIXED` Flag 中描述的`MAP_FIXED`技术，创建一个非线性映射，类似于 Figure 49-5 中所示的映射。
