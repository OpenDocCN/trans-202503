- en: '[13](nsp-boxall502581-0008.xhtml#rch13)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[13](nsp-boxall502581-0008.xhtml#rch13)'
- en: AVR and Character Liquid Crystal Displays
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AVR与字符液晶显示器
- en: '![](images/nsp-boxall502581-ct.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-boxall502581-ct.jpg)'
- en: In previous chapters you’ve used LEDs, numerical LED displays, and the larger
    MAX7219 to display numerical values. However, a common *liquid crystal display
    (LCD)* module can allow your AVR projects to show a more versatile range of output,
    including text, numerical data, and your own custom characters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你已经使用了LED、数字LED显示器和较大的MAX7219来显示数值。然而，一种常见的*液晶显示器（LCD）*模块可以让你的AVR项目显示更为多样化的输出，包括文本、数值数据以及你自己定义的字符。
- en: In this chapter, you’ll use character LCD modules to display all three types
    of data. To do so, you’ll learn to convert integers into string variables and
    display floating-point numbers on the LCD. Along the way, you’ll build your own
    digital clock and a digital thermometer that can display the minimum and maximum
    temperature over time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用字符LCD模块显示所有三种类型的数据。为此，你将学习如何将整数转换为字符串变量，并在LCD上显示浮动小数。在这个过程中，你将制作自己的数字时钟和数字温度计，可以显示温度的最小值和最大值。
- en: '[Introducing LCDs](nsp-boxall502581-0008.xhtml#rah1501)'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[介绍LCD](nsp-boxall502581-0008.xhtml#rah1501)'
- en: Our LCD-based projects will use inexpensive LCDs that can display 2 rows of
    16 characters. Any LCD with an HD44780- or KS0066-compatible interface and a 5
    V backlight, such as the one in [Figure 13-1](nsp-boxall502581-0023.xhtml#f13001)
    , should work with these projects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基于LCD的项目将使用廉价的LCD，它们可以显示2行16个字符。任何带有HD44780或KS0066兼容接口并配有5V背光的LCD，例如[图13-1](nsp-boxall502581-0023.xhtml#f13001)中的那款，都应该适用于这些项目。
- en: '![Photo of a 16×2-character LCD module](images/nsp-boxall502581-f13001.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![16×2字符LCD模块的照片](images/nsp-boxall502581-f13001.jpg)'
- en: 'Figure 13-1: A 16×2-character LCD module'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1：16×2字符LCD模块
- en: Some rare LCDs have a 4.5 V rather than a 5 V backlight. If this is true of
    your LCD, place a 1N4004 diode in series between the 5 V power supply and the
    LCD’s LED+ or A pin.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些较为罕见的LCD使用4.5V而不是5V的背光。如果你的LCD是这种情况，可以在5V电源与LCD的LED+或A引脚之间串联一个1N4004二极管。
- en: LCDs like the one in [Figure 13-1](nsp-boxall502581-0023.xhtml#f13001) usually
    come without any wiring or connectors. To use an LCD with a solderless breadboard,
    you’ll need to solder in some 0.1 inch / 2.54 mm pitch inline header pins (such
    as PMD Way part number 1242070A) like those shown in [Figure 13-2](nsp-boxall502581-0023.xhtml#f13002)
    . These are usually supplied in 40-pin lengths; however, you can easily trim them
    down to the required 16-pin length.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 像[图13-1](nsp-boxall502581-0023.xhtml#f13001)中的LCD通常没有任何接线或连接器。要在无焊面包板上使用LCD，你需要焊接一些0.1英寸
    / 2.54毫米间距的直插针脚（例如PMD Way零件号1242070A），就像[图13-2](nsp-boxall502581-0023.xhtml#f13002)中所示的那样。这些针脚通常是40针长的，但你可以轻松地将其裁剪为所需的16针长度。
- en: '![Photo of a stack of 40-pin inline header pins](images/nsp-boxall502581-f13002.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![一堆40针直插针脚的照片](images/nsp-boxall502581-f13002.jpg)'
- en: 'Figure 13-2: Inline header pins'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2：直插针脚
- en: Once assembled, your LCD will fit easily into the solderless breadboard, as
    shown in [Figure 13-3](nsp-boxall502581-0023.xhtml#f13003) . Note the labels on
    pins 1 through 16.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦组装完成，你的LCD将很容易安装到无焊面包板上，正如[图13-3](nsp-boxall502581-0023.xhtml#f13003)所示。请注意引脚1至16的标签。
- en: '![Photo of an LCD in a solderless breadboard](images/nsp-boxall502581-f13003.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![无焊面包板上的LCD照片](images/nsp-boxall502581-f13003.jpg)'
- en: 'Figure 13-3: An LCD in a solderless breadboard'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-3：安装在无焊面包板上的LCD
- en: The schematic symbol for our LCD is shown in [Figure 13-4](nsp-boxall502581-0023.xhtml#f13004)
    .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的LCD的原理图符号如[图13-4](nsp-boxall502581-0023.xhtml#f13004)所示。
- en: '![16×2-character LCD schematic symbol](images/nsp-boxall502581-f13004.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![16×2字符LCD原理图符号](images/nsp-boxall502581-f13004.jpg)'
- en: 'Figure 13-4: Schematic symbol for our 16×2-character LCD'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-4：我们16×2字符LCD的原理图符号
- en: Pins DB0 through DB7 constitute the 8-bit data interface of the LCD, which communicates
    with our ATmega328P-PU microcontroller. If you need to save wiring, you can also
    use the LCD in a 4-bit mode, which only requires DB4 through B7\. We’ll use this
    method in our projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚DB0至DB7构成LCD的8位数据接口，它与我们的ATmega328P-PU微控制器进行通信。如果你需要节省接线，还可以使用LCD的4位模式，这只需要DB4至DB7。我们将在项目中使用这种方法。
- en: Finally, you’ll also need a small 10 kΩ trimpot to control the contrast of the
    display. You can get breadboard-compatible trimpots that don’t require any extra
    soldering, like the one shown in [Figure 13-5](nsp-boxall502581-0023.xhtml#f13005)
    .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还需要一个小的10 kΩ可调电位器来控制显示的对比度。你可以使用不需要额外焊接的面包板兼容电位器，如[图13-5](nsp-boxall502581-0023.xhtml#f13005)中所示的那种。
- en: '![Photo of a breadboard-compatible trimpot](images/nsp-boxall502581-f13005.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![面包板兼容电位器的照片](images/nsp-boxall502581-f13005.jpg)'
- en: 'Figure 13-5: An example of a breadboard trimpot'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-5：一个面包板电位器的示例
- en: The schematic symbol for the trimpot in [Figure 13-5](nsp-boxall502581-0023.xhtml#f13005)
    is shown in [Figure 13-6](nsp-boxall502581-0023.xhtml#f13006) .
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-5](nsp-boxall502581-0023.xhtml#f13005)中电位器的原理图符号显示在[图13-6](nsp-boxall502581-0023.xhtml#f13006)中。'
- en: '![Breadboard trimpot schematic symbol](images/nsp-boxall502581-f13006.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![面包板电位器原理图符号](images/nsp-boxall502581-f13006.jpg)'
- en: 'Figure 13-6: Schematic symbol for our breadboard trimpot'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-6：我们面包板电位器的原理图符号
- en: 'Once you’ve gotten your LCD ready to use with a solderless breadboard, it’s
    time to understand how to display various kinds of data. To use the LCD in your
    projects, you will need functions for the following tasks:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好使用无焊面包板来使用LCD，就该了解如何显示各种类型的数据了。在你的项目中使用LCD时，你需要完成以下任务的函数：
- en: • Converting instructions into suitable control signals in order to send commands
    to the LCD
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 将指令转换为适当的控制信号，以便向LCD发送命令
- en: • Initializing the LCD for use
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 初始化LCD以供使用
- en: • Clearing all data from the LCD
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 清除LCD上的所有数据
- en: • Moving the cursor to the required position on the LCD
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 将光标移动到LCD上的指定位置
- en: • Displaying text on the LCD
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在LCD上显示文本
- en: As there are no functions to complete these tasks in our AVR toolchain, we’ll
    use the custom functions described in the following sections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在我们的AVR工具链中没有完成这些任务的现成函数，我们将使用以下部分中描述的自定义函数。
- en: You’ll notice that each of these functions sends values to the LCD to cause
    a given effect. For example, sending `0x01` to the LCD clears the screen. To determine
    which values we should use to accomplish certain tasks, we refer to the LCD’s
    instruction table, which is Table 6 in the HD44780’s data sheet (widely available
    and included with the book’s code download at [https://nostarch.com/avr-workshop/](https://nostarch.com/avr-workshop/)
    ). This table shows the status of the RS and R/_W pins required for a particular
    command, along with the binary representation of the command. [Figure 13-7](nsp-boxall502581-0023.xhtml#f13007)
    shows the clear display command, `0x01` .
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，这些函数每次都会向LCD发送值以实现某种效果。例如，向LCD发送`0x01`会清除屏幕。为了确定我们应该使用哪些值来完成特定的任务，我们参考LCD的指令表，这张表格是HD44780数据表中的第6表格（该表格广泛可用，并包含在本书的代码下载中，地址为[https://nostarch.com/avr-workshop/](https://nostarch.com/avr-workshop/)）。该表格显示了执行特定命令所需的RS和R/_W引脚的状态，以及该命令的二进制表示。[图13-7](nsp-boxall502581-0023.xhtml#f13007)显示了清除显示命令`0x01`。
- en: '![The “clear display” row from Table 6 in the HD44780’s data sheet](images/nsp-boxall502581-f13007.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![HD44780数据表中第6表格的“清除显示”行](images/nsp-boxall502581-f13007.jpg)'
- en: 'Figure 13-7: A numerical description of the LCD’s “clear screen” command'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-7：LCD“清屏”命令的数字描述
- en: As the figure shows, to clear the display we need to set the LCD pins RS and
    R/_W to low, then send `0b00000001` (or `0x01` ) to the LCD. We’ll do this with
    the `commandLCD()` function (introduced in the following section), which is then
    called from the `clearLCD()` function (described shortly in “Clear the LCD”).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，为了清除显示，我们需要将LCD的引脚RS和R/_W设置为低电平，然后将`0b00000001`（或`0x01`）发送到LCD。我们将通过`commandLCD()`函数来完成这一操作（该函数将在接下来的部分介绍），并通过`clearLCD()`函数（稍后在“清除LCD”部分中描述）调用它。
- en: In the following sections, refer to the table in the HD44780’s data sheet to
    understand which values I use to construct the other LCD commands. Later, you
    can use the table to create commands to suit your own needs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，请参考HD44780数据表中的表格，了解我用来构建其他LCD命令的值。之后，你可以使用该表格创建符合你需求的命令。
- en: '[Send Commands to the LCD](nsp-boxall502581-0008.xhtml#rbh1501)'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[向LCD发送命令](nsp-boxall502581-0008.xhtml#rbh1501)'
- en: 'All information sent to the LCD, be it setup commands or data to display, is
    sent in bytes. However, as we’re using the LCD in 4-bit mode to save on hardware
    connections, we’ll need to use the following function to split the bytes of data
    into nibbles (4 bits) and send them to the LCD in the correct order:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有发送到 LCD 的信息，无论是设置命令还是显示数据，都是按字节发送的。然而，由于我们使用的是 4 位模式的 LCD 来节省硬件连接，我们需要使用以下函数将数据字节拆分成半字节（4
    位），并按正确的顺序将它们发送到 LCD：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To understand what’s happening in this code, recall that a byte of data consists
    of 8 bits, or 2 nibbles: the higher nibble, which consists of bits 7 to 4, and
    the lower nibble, which consists of bits 3 to 0\. For example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这段代码的作用，回想一下一个字节的数据由 8 位组成，或者说由 2 个半字节（nibble）组成：高半字节，由第 7 位到第 4 位组成，和低半字节，由第
    3 位到第 0 位组成。例如：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `commandLCD()` function first takes the upper nibble of the command byte
    `_command` ❶ and uses bitwise arithmetic (see [Chapter 2](nsp-boxall502581-0012.xhtml#ch02)
    ) to clear the GPIO pins back to low. It then ensures the GPIO pins are set to
    match the upper nibble, the first half of the command byte.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`commandLCD()` 函数首先获取命令字节 `_command` 的高半字节 ❶，并使用位运算（参见 [第 2 章](nsp-boxall502581-0012.xhtml#ch02)）将
    GPIO 引脚恢复为低电平。然后它确保 GPIO 引脚设置为与命令字节的高半字节匹配，即命令字节的前半部分。'
- en: Next, it sets the RS pin on the LCD to low ❷, which tells the LCD we need to
    send data to its instruction register, and quickly sets the LCD’s E pin on ❸ and
    off ❹, which tells the LCD more data is coming.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将 LCD 的 RS 引脚设置为低 ❷，这告诉 LCD 我们需要向其指令寄存器发送数据，并迅速将 LCD 的 E 引脚设置为高 ❸ 和低 ❹，这告诉
    LCD 将有更多数据到来。
- en: The function then uses bitwise arithmetic to shift the 4 bits of the lower nibble
    up into the higher nibble ❺, which will match the GPIO pins used for sending data
    to the LCD. Finally, it again sets the LCD’s E pin on ❻ and off ❼ to finalize
    the data transmission. We use the `_delay_us()` (delay in microseconds, not milliseconds)
    function to give the LCD time to process the changes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后该函数使用位运算将低半字节的 4 位上移到高半字节 ❺，这将与用于向 LCD 发送数据的 GPIO 引脚相匹配。最后，它再次设置 LCD 的 E 引脚为高
    ❻ 和低 ❼，以完成数据传输。我们使用 `_delay_us()`（微秒延迟，而非毫秒）函数为 LCD 提供时间来处理这些变化。
- en: '[Initialize the LCD for Use](nsp-boxall502581-0008.xhtml#rbh1502)'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[初始化 LCD 使用](nsp-boxall502581-0008.xhtml#rbh1502)'
- en: 'Like many other devices, the LCD needs to be initialized with various parameters
    before we first use it in our code. We’ll use the `initLCD()` function to do this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多其他设备一样，LCD 在我们首次在代码中使用之前需要初始化各种参数。我们将使用 `initLCD()` 函数来完成这个操作：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function first sets the required GPIO pins to digital outputs ❶. After
    a short delay to give the LCD time to wake up, it then sends the command to set
    the cursor (the position at which data is first displayed) back to the top left
    of the screen ❷. The next command configures the LCD’s controller IC to use it
    as a 16×2-character unit with a 4-bit data interface and to select a default font
    with characters that consist of 5×8 pixels ❸.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先将所需的 GPIO 引脚设置为数字输出 ❶。经过短暂延迟以便给 LCD 足够时间唤醒后，它发送命令将光标位置（数据首次显示的位置）重新设置到屏幕的左上角
    ❷。接下来的命令配置 LCD 控制器 IC，将其设置为 16×2 字符单元，并使用 4 位数据接口，同时选择一个默认字体，该字体由 5×8 像素的字符组成
    ❸。
- en: The following command ❹ tells the LCD to not use a block cursor, to not blink
    the cursor, and to turn the display on. We then tell the LCD controller we need
    the cursor to move in incremental stages ❺ so that if we wish to display more
    than one character in turn, we don’t need to explicitly set the cursor position
    after each character. Finally, we clear the LCD of all characters ❻ and give it
    a little time to process the change.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的命令 ❹ 告诉 LCD 不使用块状光标、不闪烁光标，并开启显示。然后我们告诉 LCD 控制器，需要使光标按增量方式移动 ❺，这样如果我们希望依次显示多个字符，就不需要在每个字符后显式设置光标位置。最后，我们清除
    LCD 上的所有字符 ❻，并给它一点时间处理这个变化。
- en: '[Clear the LCD](nsp-boxall502581-0008.xhtml#rbh1503)'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[清除 LCD](nsp-boxall502581-0008.xhtml#rbh1503)'
- en: 'The convenient `clearLCD()` function simply clears the LCD of all data:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的 `clearLCD()` 函数会清除 LCD 上的所有数据：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We send the command to clear the screen ❶, then the command to return the cursor
    to the top left of the LCD ❷.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送清屏命令 ❶，然后发送将光标返回到 LCD 左上角的命令 ❷。
- en: '[Set the Cursor](nsp-boxall502581-0008.xhtml#rbh1504)'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置光标](nsp-boxall502581-0008.xhtml#rbh1504)'
- en: 'The `cursorLCD()` function sets the cursor to a given location on the LCD,
    following which you can display data starting from that position:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`cursorLCD()` 函数将光标设置到 LCD 上的指定位置，之后你可以从该位置开始显示数据：'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With our LCD, we have 2 rows of 16 characters: rows 0 and 1, with 16 columns
    numbered 0 to 15\. This function creates the required LCD command based on the
    position data received for a row 0 location ❶ and for a row 1 location ❷.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 LCD 有 2 行 16 个字符：第 0 行和第 1 行，列编号为 0 到 15。该函数根据接收到的位置数据创建所需的 LCD 命令，用于第 0
    行位置 ❶ 和第 1 行位置 ❷。
- en: '[Print to the LCD](nsp-boxall502581-0008.xhtml#rbh1505)'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[向 LCD 打印](nsp-boxall502581-0008.xhtml#rbh1505)'
- en: 'The `printLCD()` function is used to display data on the LCD, such as text
    or numbers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`printLCD()` 函数用于在 LCD 上显示数据，如文本或数字：'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This function can accept text in quotes, like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数可以接受带引号的文本，如下所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'or an array of characters, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者字符数组，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The function sends each character in turn from the array using its `for` loop
    ❶, representing characters as numerical values from a standard ASCII table (discussed
    in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) ). All LCD displays on the market
    should support the values 33 to 125, which includes the lower- and uppercase alphabet, numbers,
    and standard popular symbols and punctuation marks. We set the location of the
    first (or only) character to display using the `cursorLCD()` or `clearLCD()` functions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用其 `for` 循环 ❶ 逐个发送数组中的每个字符，将字符表示为标准 ASCII 表中的数字值（在 [第 4 章](nsp-boxall502581-0014.xhtml#ch04)
    讨论）。市场上所有 LCD 显示器应支持值为 33 到 125，包括小写和大写字母、数字以及标准常用符号和标点符号。我们使用 `cursorLCD()` 或
    `clearLCD()` 函数设置第一个（或唯一）要显示的字符位置。
- en: The `printLCD()` function is very similar to the `commandLCD()` function. It
    first takes the upper nibble of the character byte `_string[i]` ❷ and uses bitwise
    arithmetic to clear the GPIO pins back to low. It then ensures the GPIO pins are
    set to match the upper nibble, the first half of the command byte.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`printLCD()` 函数与 `commandLCD()` 函数非常相似。它首先获取字符字节 `_string[i]` 的高位半字节 ❷，并使用位运算将
    GPIO 引脚清零至低电平。然后确保 GPIO 引脚设置与高位半字节（命令字节的前半部分）匹配。'
- en: Next, it sets the RS pin on the LCD to high ❸, which tells the LCD we need to
    send data to its instruction register, and quickly sets the LCD’s E pin on ❹ and
    off ❺, which tells the LCD more data is coming.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将 LCD 的 RS 引脚设置为高电平 ❸，告诉 LCD 我们需要向其指令寄存器发送数据，并迅速将 LCD 的 E 引脚打开 ❹ 和关闭 ❺，告诉
    LCD 将有更多数据到来。
- en: The function then uses bitwise arithmetic to shift the 4 bits of the lower nibble
    up into the higher nibble ❻, which will match the GPIO pins used for sending data
    to the LCD. Finally, it again sets the LCD’s E pin on ❼ and off ❽ to finalize
    the data transmission. We use the `_delay_us()` (delay in microseconds) function
    to give the LCD time to process the changes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接着使用位运算将低半字节的 4 位移位至高半字节 ❻，这将与用于向 LCD 发送数据的 GPIO 引脚匹配。最后，它再次将 LCD 的 E 引脚打开
    ❼ 和关闭 ❽，完成数据传输。我们使用 `_delay_us()` 函数（延时微秒）让 LCD 有时间处理这些变化。
- en: Note To use `printLCD()` to display the contents of an integer variable, first
    convert the variable to an array of characters with `itoa(` `a` `,` `b` `,` `c`
    `)` . This takes the integer `a` and places it in an array of characters `b` with
    a maximum length of `c` characters. You’ll need to include the *stdlib.h* library
    along with the other `include` statements in your code, as it contains the `itoa()`
    function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要使用 `printLCD()` 显示整数变量的内容，请先使用 `itoa(` `a` `,` `b` `,` `c` `)` 将变量 `a` 转换为字符数组
    `b`，数组长度最大为 `c` 个字符。您需要在代码中包含 *stdlib.h* 库以及其他 `include` 语句，因为它包含 `itoa()` 函数。
- en: In the following projects, you’ll put the LCD to use.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的项目中，您将把 LCD 应用到实际中。
- en: '[Project 52: Using a Character LCD with Your AVR](nsp-boxall502581-0008.xhtml#rpro52)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 52：使用 AVR 控制字符 LCD](nsp-boxall502581-0008.xhtml#rpro52)'
- en: In this project you’ll consolidate the information presented so far about controlling
    the LCD by building your own LCD circuit and displaying various information. This
    will introduce you to using LCDs in your own projects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在此项目中，通过构建自己的 LCD 电路并显示各种信息，您将巩固迄今为止关于控制 LCD 的信息。这将为您在自己的项目中使用 LCD 提供介绍。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1506)'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh1506)'
- en: 'To build your circuit, you’ll need the following hardware:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建您的电路，您将需要以下硬件：
- en: • USBasp programmer
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 程序员
- en: • Solderless breadboard
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • 5 V breadboard power supply
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 5 V 面包板电源
- en: • ATmega328P-PU microcontroller
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • 16×2-character LCD with fitted inline header pins
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 16×2 字符 LCD，配有内联引脚头
- en: • 10 kΩ breadboard-compatible trimpot (variable resistor)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 10 kΩ 面包板兼容可调电阻器
- en: • Two 22 pF ceramic capacitors (C1–C2)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个 22 pF 陶瓷电容器（C1–C2）
- en: • 470 μF 16 V electrolytic capacitor (C3)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16 MHz crystal oscillator
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 13-8](nsp-boxall502581-0023.xhtml#f13008)
    .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 52](images/nsp-boxall502581-f13008.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-8: Schematic for [Project 52](nsp-boxall502581-0023.xhtml#pro52)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve finished with this circuit, keep it assembled, as you’ll use it
    again for [Project 55](nsp-boxall502581-0023.xhtml#pro55) .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1507)'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 52* subfolder of this book’s
    *Chapter 13* folder, and enter the command `make flash` as usual. After a few
    moments, the LCD should show the text in [Figure 13-9](nsp-boxall502581-0023.xhtml#f13009)
    .
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the LCD displaying the initial message from Project 52](images/nsp-boxall502581-f13009.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-9: First example of text displayed using [Project 52](nsp-boxall502581-0023.xhtml#pro52)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: That text should soon be replaced with an incrementing digit, as shown in [Figure
    13-10](nsp-boxall502581-0023.xhtml#f13010) .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the LCD displaying “counting up:” and the numbers from 0 to 9](images/nsp-boxall502581-f13010.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-10: Example of the counting display routine from [Project 52](nsp-boxall502581-0023.xhtml#pro52)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the code and review the functions that make this possible:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code puts the LCD functions described earlier to use. In the main section
    of the code, we first initialize the LCD ❶, then declare a character array for
    displaying numbers ❷ and the required variable for counting ❸.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up the display operation. We position and display text using the
    `cursorLCD()` and `printLCD()` functions ❹, then clear the display with `clearLCD()`
    ❺. The `for` loop ❻ displays the numbers from zero to nine along the second row
    of the LCD (as shown in [Figure 13-10](nsp-boxall502581-0023.xhtml#f13010) ).
    We use `itoa()` ❼ to convert the integer variable `i` into a character array of
    numbers, then display that array using `printLCD()` ❽.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to set up and use a character LCD, let’s put this skill
    to good use by creating a digital clock.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 53: Building an AVR-Based LCD Digital Clock](nsp-boxall502581-0008.xhtml#rpro53)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll combine the DS3231 real-time clock module and an LCD
    to build your own digital clock.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1508)'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build your circuit, you’ll need the following hardware:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16×2-character LCD with fitted inline header pins
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 10 kΩ breadboard-compatible trimpot (variable resistor)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • DS3231 RTC module with backup battery
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 22 pF ceramic capacitors (C1–C2)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 470 μF 16 V electrolytic capacitor (C3)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16 MHz crystal oscillator
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 13-11](nsp-boxall502581-0023.xhtml#f13011)
    . Don’t forget to connect the DS3231 board to 5 V and GND as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图 13-11](nsp-boxall502581-0023.xhtml#f13011)所示组装电路。别忘了将DS3231模块连接到5V和GND。
- en: '![Schematic diagram for Project 53](images/nsp-boxall502581-f13011.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![项目 53 的示意图](images/nsp-boxall502581-f13011.jpg)'
- en: 'Figure 13-11: Schematic for [Project 53](nsp-boxall502581-0023.xhtml#pro53)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-11：[项目 53](nsp-boxall502581-0023.xhtml#pro53)的电路图
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1509)'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh1509)'
- en: As with [Project 51](nsp-boxall502581-0022.xhtml#pro51) from [Chapter 12](nsp-boxall502581-0022.xhtml#ch12)
    , you’ll first need to set the time and date in the DS3231 module. In your text
    editor, open the *main.c* file in the *Project 53* subfolder of this book’s *Chapter
    13* folder and remove the comment slashes in front of the function `setTimeDS3231()`
    . Update the parameters in that function to match your current date and time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与[项目 51](nsp-boxall502581-0022.xhtml#pro51)在[第 12 章](nsp-boxall502581-0022.xhtml#ch12)中的内容一样，你首先需要在DS3231模块中设置时间和日期。在文本编辑器中，打开*Chapter
    13*文件夹中*Project 53*子文件夹中的*main.c*文件，并去掉`setTimeDS3231()`函数前的注释符号。更新该函数中的参数以匹配你当前的日期和时间。
- en: Now save the file, then use the `make flash` command as usual from the terminal
    window. Reopen the *main.c* file and place the comment slashes in front of the
    same function, save the file, and reflash the code. Once you’ve done so, you should
    see the current time and date displayed on your LCD module. An example of this
    is shown in [Figure 13-12](nsp-boxall502581-0023.xhtml#f13012) . Congratulations—you’ve
    made your own LCD digital clock!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存文件，然后像往常一样在终端窗口中使用`make flash`命令。重新打开*main.c*文件，在相同的函数前放置注释符号，保存文件并重新烧录代码。完成后，你应该会看到当前的时间和日期显示在LCD模块上。如下图
    13-12所示，恭喜你——你已经制作了自己的LCD数字时钟！
- en: '![Photo of the LCD clock from Project 53](images/nsp-boxall502581-f13012.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![项目 53 LCD 时钟的照片](images/nsp-boxall502581-f13012.jpg)'
- en: 'Figure 13-12: Example operation of [Project 53](nsp-boxall502581-0023.xhtml#pro53)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-12： [项目 53](nsp-boxall502581-0023.xhtml#pro53)的操作示例
- en: 'Let’s examine the code to see how this works:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下代码，看看它是如何工作的：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first section of the code includes all the I ² C functions required to read
    and write data with our DS3231 RTC module as described in [Project 51](nsp-boxall502581-0022.xhtml#pro51)
    in [Chapter 12](nsp-boxall502581-0022.xhtml#ch12) , using the same method of working
    with the time and date information we employed with the MAX7219 display module.
    It also includes each LCD function explained previously in this chapter. Then
    we need to ensure the time and date are set using the `setTimeDS3231()` function
    ❶, and retrieve that information and display it in a nice format on the LCD.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分包括所有I²C功能，用于与我们的DS3231 RTC模块读取和写入数据，正如在[项目 51](nsp-boxall502581-0022.xhtml#pro51)中所描述的，在[第
    12 章](nsp-boxall502581-0022.xhtml#ch12)中，使用与MAX7219显示模块相同的方式处理时间和日期信息。它还包括本章之前解释的每个LCD函数。接下来，我们需要确保通过`setTimeDS3231()`函数❶设置时间和日期，然后获取这些信息并以良好的格式在LCD上显示。
- en: The code displays time in 24-hour format, using two digits to represent each
    of the hour, minute, and second parts. It first retrieves the data from the DS3231
    ❷ in the same way as [Project 51](nsp-boxall502581-0022.xhtml#pro51) in [Chapter
    12](nsp-boxall502581-0022.xhtml#ch12) . then converts the hour, minute and second
    information using `itoa()` ❸ and displays each part at the correct place on the
    LCD with `cursorLCD()` .
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码以24小时制显示时间，使用两位数字表示小时、分钟和秒。它首先以与[项目 51](nsp-boxall502581-0022.xhtml#pro51)在[第
    12 章](nsp-boxall502581-0022.xhtml#ch12)中相同的方式从DS3231❷获取数据，然后使用`itoa()`❸将小时、分钟和秒信息转换，并通过`cursorLCD()`在LCD的正确位置显示每个部分。
- en: To maintain correct spacing and display of information, we must ensure the LCD
    displays single-digit values with a zero preceding them (representing the sixth
    day of the month as 06, for example). To do so, the code checks if the value from
    the time clock is zero ❹ or between one and nine ❺, then writes the required zeros
    before any single-digit time data. It does this for the hours, minutes, seconds,
    day of month, and month values.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持正确的间距和信息显示，我们必须确保LCD显示单数字值时前面加上零（例如，表示每月的第六天为06）。为此，代码会检查时间时钟的值是否为零❹或在1到9之间❺，然后在任何单数字的时间数据前写入所需的零。它会对小时、分钟、秒、日期和月份值进行此操作。
- en: The `switch...case` statement ❻ then takes the day of week data—a value from
    1 to 7 corresponding to Sunday through Saturday or Monday through Sunday, depending
    on your region and preference—and displays the day in abbreviated form. After
    all the information has been displayed, the clock waits for 900 ms ❼ before clearing
    the display, then starting over.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`switch...case`语句 ❻ 获取星期几数据——一个值从 1 到 7，代表星期日到星期六（或者根据你的地区和偏好，星期一到星期天）——并以缩写形式显示星期几。在所有信息显示完毕后，时钟会等待
    900 毫秒 ❼，然后清除显示器，并重新开始。
- en: For a challenge, you might convert this project into a 12-hour clock with an
    AM/PM display, or perhaps add an alarm that sounds a piezo buzzer at a certain
    time every day.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为挑战，你可以将这个项目转换成一个带 AM/PM 显示的 12 小时钟，或者添加一个在每天特定时间响起压电蜂鸣器的闹钟。
- en: '[Displaying Floating-Point Numbers on the LCD](nsp-boxall502581-0008.xhtml#rah1502)'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[在 LCD 上显示浮点数](nsp-boxall502581-0008.xhtml#rah1502)'
- en: Our [next project](nsp-boxall502581-0023.xhtml#pro54) requires us to display
    a floating-point number on the LCD. As with integers, floating-point numbers first
    need to be converted from floats to character arrays. To do this we use the `dtostrf()`
    function, as described in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) , then
    display the character array as usual with the `printLCD()` function. Always ensure
    you declare your character array with enough space to cover the entire number
    and fraction.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的[下一个项目](nsp-boxall502581-0023.xhtml#pro54)需要在 LCD 上显示一个浮点数。与整数类似，浮点数首先需要从浮点数转换为字符数组。为此，我们使用`dtostrf()`函数，如[第
    4 章](nsp-boxall502581-0014.xhtml#ch04)中所述，然后像往常一样使用`printLCD()`函数显示字符数组。始终确保为字符数组声明足够的空间，以覆盖整个数字和小数部分。
- en: 'For example, to display the numbers 1.2345678 and 12345.678, replace the `int
    main()` loop from [Project 54](nsp-boxall502581-0023.xhtml#pro54) with the following
    code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要显示数字 1.2345678 和 12345.678，可以将[项目 54](nsp-boxall502581-0023.xhtml#pro54)中的`int
    main()`循环替换为以下代码：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We declare variables holding two sample numbers to display on the LCD for the
    purposes of demonstration ❶, and the character array used in the display process
    ❷. We then initialize the LCD as usual ❸ and move the cursor to the top left of
    the display ❹.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个变量，用于在 LCD 上显示两个示范用的数字 ❶，以及在显示过程中使用的字符数组 ❷。然后，我们像往常一样初始化 LCD ❸，并将光标移动到显示器的左上角
    ❹。
- en: The code then converts the number 1.2345678 to a string displayed using 10 characters,
    with 7 of them after the decimal point ❺. Finally, it displays the number 12345.678
    using 9 characters, this time with 3 of them after the decimal point ❻.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将数字 1.2345678 转换为一个字符串，使用 10 个字符显示，其中 7 个字符位于小数点后 ❺。最后，它使用 9 个字符显示数字 12345.678，这次有
    3 个字符位于小数点后 ❻。
- en: Flash the code and you should see a display like the one in [Figure 13-13](nsp-boxall502581-0023.xhtml#f13013)
    .
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新代码后，你应该看到类似[图 13-13](nsp-boxall502581-0023.xhtml#f13013)中的显示效果。
- en: '![Photo of the LCD displaying floating-point numbers](images/nsp-boxall502581-f13013.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![显示浮点数的 LCD 照片](images/nsp-boxall502581-f13013.jpg)'
- en: 'Figure 13-13: Floating-point numbers on the LCD'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-13：LCD 上的浮点数
- en: This example displayed two positive numbers. If you’d like to display negative
    numbers, remember to allow one character space for the negative sign in front
    of the first digit. For example, to display −123.45, you would need to allocate
    seven character spaces.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例显示了两个正数。如果你想显示负数，请记得为负号留出一个字符空间，位于第一个数字前面。例如，要显示−123.45，你需要分配七个字符空间。
- en: You’ll put this new skill to work in the [next project](nsp-boxall502581-0023.xhtml#pro54)
    .
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[下一个项目](nsp-boxall502581-0023.xhtml#pro54)中运用这一新技能。
- en: '[Project 54: LCD Digital Thermometer with Min/Max Display](nsp-boxall502581-0008.xhtml#rpro54)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 54：带最小/最大显示的 LCD 数字温度计](nsp-boxall502581-0008.xhtml#rpro54)'
- en: With this project you’ll make a digital thermometer that can display the minimum
    and maximum temperature over time along with the current and average temperature
    over time. This project is another example of how to incorporate functions from
    previous chapters into new and more complicated projects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将制作一个数字温度计，能够显示一段时间内的最小和最大温度，以及当前和平均温度。这个项目是如何将前几章的函数结合到新的、更复杂的项目中的另一个示例。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1510)'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh1510)'
- en: 'To build your circuit, you’ll need the following hardware:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建你的电路，你需要以下硬件：
- en: • USBasp programmer
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • 5 V breadboard power supply
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 5V 面包板电源
- en: • ATmega328P-PU microcontroller
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • 16×2-character LCD with fitted inline header pins
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 16×2字符LCD，带有内嵌头针
- en: • 10 kΩ breadboard-compatible trimpot (variable resistor)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 10 kΩ 面包板兼容调节电位器（可变电阻）
- en: • One TMP36 temperature sensor
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个TMP36温度传感器
- en: • Two 22 pF ceramic capacitors (C1–C2)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个 22 pF 陶瓷电容（C1–C2）
- en: • 470 μF 16 V electrolytic capacitor (C3)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 470 μF 16 V 电解电容（C3）
- en: • 0.1 μF ceramic capacitor (C4)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 0.1 μF 陶瓷电容（C4）
- en: • 16 MHz crystal oscillator
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 16 MHz晶体振荡器
- en: • Jumper wires
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: Assemble your circuit as shown in [Figure 13-14](nsp-boxall502581-0023.xhtml#f13014)
    . Don’t forget to connect the microcontroller’s AV [CC] pin to 5 V!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图13-14](nsp-boxall502581-0023.xhtml#f13014)中的示意图组装电路。别忘了将微控制器的AV [CC]引脚连接到5V！
- en: '![Schematic diagram for Project 54](images/nsp-boxall502581-f13014.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![项目54的原理图](images/nsp-boxall502581-f13014.jpg)'
- en: 'Figure 13-14: Schematic for [Project 54](nsp-boxall502581-0023.xhtml#pro54)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-14：项目[54](nsp-boxall502581-0023.xhtml#pro54)原理图
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1511)'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh1511)'
- en: Open a terminal window, navigate to the *Project 54* subfolder of this book’s
    *Chapter 13* folder, and enter the command `make flash` as usual. After a moment
    or two, the LCD should alternate between showing the minimum and maximum temperatures,
    as shown in [Figure 13-15](nsp-boxall502581-0023.xhtml#f13015) , and the current
    and average temperatures, as shown in [Figure 13-16](nsp-boxall502581-0023.xhtml#f13016)
    . The temperature readings are in degrees Celsius and cover the period since the
    project was last reset or turned on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到本书*第13章*文件夹下的*项目54*子文件夹，并像往常一样输入命令`make flash`。片刻后，LCD应交替显示最小和最大温度，如[图13-15](nsp-boxall502581-0023.xhtml#f13015)所示，以及当前和平均温度，如[图13-16](nsp-boxall502581-0023.xhtml#f13016)所示。温度读数以摄氏度为单位，涵盖了自上次重置或开启项目以来的时间段。
- en: '![Photo of the LCD displaying minimum and maximum temperatures](images/nsp-boxall502581-f13015.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![LCD显示最小和最大温度的照片](images/nsp-boxall502581-f13015.jpg)'
- en: 'Figure 13-15: The LCD displaying the minimum and maximum temperatures'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-15：LCD显示最小和最大温度
- en: '![Photo of the LCD displaying current and average temperatures](images/nsp-boxall502581-f13016.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![LCD显示当前和平均温度的照片](images/nsp-boxall502581-f13016.jpg)'
- en: 'Figure 13-16: The LCD displaying the current and average temperatures'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-16：LCD显示当前和平均温度
- en: 'Let’s take a look at the code to see how this works:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下代码，看看它是如何工作的：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code for this project breaks down into two concepts: determining the temperature
    from the TMP36 sensor (as demonstrated in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03)
    ), then displaying the temperature values using the LCD.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的代码分为两个部分：从TMP36传感器获取温度（如[第3章](nsp-boxall502581-0013.xhtml#ch03)所示），然后使用LCD显示温度值。
- en: We first use a series of functions and commands to activate the ADC on pin 28
    and call it into action in the main code ❶. The `startADC()` function is slightly
    different from its equivalent in previous projects; since we’re now operating
    the microcontroller at 16 MHz rather than 1 MHz, we need a larger prescaler to
    operate the ADC. Therefore, we set the ADCSRA register to use a prescaler of 128
    ❷. We arrive at this value by dividing 16 MHz by 200 kHz (the ideal speed for
    the ADC), which results in 80; the closest prescaler value is 128, so we use that.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用一系列函数和命令来激活28号引脚上的ADC，并在主代码中调用它 ❶。`startADC()`函数与之前项目中的对应函数略有不同；由于我们现在在16
    MHz的频率下操作微控制器，而不是1 MHz，我们需要一个更大的分频器来操作ADC。因此，我们将ADCSRA寄存器设置为使用128的分频器 ❷。我们通过将16
    MHz除以200 kHz（ADC的理想速度）得到80；最接近的分频器值是128，因此我们使用它。
- en: The code reads the raw data from the ADC ❹ and converts it to degrees Celsius
    ❺. It then determines if the current temperature is a minimum or maximum ❻ and
    calculates the average temperature measured since the last reset ❼. Note that
    the variable `minimum` is declared with a value of −273 degrees ❸. If we leave
    it without an initial value, it will default to 0 and we won’t get a true minimum
    temperature value (unless the sensor is outside and the temperature never goes
    below freezing!). Finally, we display all this temperature data over two screens,
    using the LCD functions from earlier in this chapter ❽.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从ADC ❹读取原始数据，并将其转换为摄氏度 ❺。然后，它会判断当前温度是最小值还是最大值 ❻，并计算自上次重置以来测得的平均温度 ❼。请注意，变量`minimum`的初始值被设置为−273度
    ❸。如果我们没有给它初始值，它将默认为0，这样我们就无法得到真实的最小温度值（除非传感器在户外，温度从未低于冰点！）。最后，我们使用本章前面提到的LCD函数
    ❽，在两个屏幕上显示所有这些温度数据。
- en: You can of course change the temperature values displayed to Fahrenheit by multiplying
    them by 1.8 and adding 32\. Or, if you feel like a challenge, why not modify this
    project by combining it with what you learned in [Project 53](nsp-boxall502581-0023.xhtml#pro53)
    to build a clock that shows the current temperature?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’ve finished experimenting, let’s move on to creating our final type
    of output: custom characters.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[Displaying Custom Characters on the LCD](nsp-boxall502581-0008.xhtml#rah1503)'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to using the standard letters, numbers, and symbols available on
    most keyboards, you can define up to eight of your own characters in each project.
    As you know, each character in the LCD module is made up of eight rows of five
    pixels, as shown in [Figure 13-17](nsp-boxall502581-0023.xhtml#f13017) .
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of an LCD with contrast adjusted to maximum in order to display individual
    character pixels](images/nsp-boxall502581-f13017.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-17: Each LCD character is made up of eight rows of five pixels.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: To display your own custom characters, you must first define each character
    using an array consisting of eight elements (one element per character line).
    The value of the element defines the state of the pixels in that line. For example,
    to create a simple “smiley face,” plan out the pixels on a grid as shown in [Figure
    13-18](nsp-boxall502581-0023.xhtml#f13018) .
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram illustrating numerical composition of custom LCD characters](images/nsp-boxall502581-f13018.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-18: Elements of a custom smiley face character'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert each horizontal line into a value by converting it from a binary number
    matching the pixels’ on or off state to a decimal number. Then create an array
    to define your custom character by entering in the eight decimal values, as shown
    below for the elements in [Figure 13-18](nsp-boxall502581-0023.xhtml#f13018) :'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code for this chapter includes a spreadsheet that simplifies this array
    creation process.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created the array, you need to program it into the LCD’s *character
    generator RAM (CGRAM)* . This is a type of RAM used in the LCD’s controller chip
    that stores the design of the characters to display. There are eight possible
    positions in our LCD’s CGRAM. To write this character data and use the custom
    characters, we’ll use the three custom functions defined in the following sections.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Data to CGRAM](nsp-boxall502581-0008.xhtml#rbh1512)'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `writeLCD()` function writes an individual line of data to the LCD’s CGRAM:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function operates in the same way as our `commandLCD()` function, except
    that `writeLCD()` sets the RS pin on the LCD high instead of low, which tells
    the LCD that the incoming data is for the CGRAM and not a regular command. It’s
    used in conjunction with the following two functions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[Send Custom Character Data to LCD](nsp-boxall502581-0008.xhtml#rbh1513)'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `createCC()` function directs the custom character data array ( `ccdata[]`
    ) into the specified CGRAM memory position ( `slot` ), from 0 to 7:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`createCC()`函数将自定义字符数据数组（`ccdata[]`）导入指定的CGRAM内存位置（`slot`），范围从0到7：'
- en: '[PRE14]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We command the LCD to prepare for character data and to store it in the character
    position in the variable `slot` ❶, then send each element of the character array
    in turn to the LCD’s CGRAM with the `writeLCD()` function ❷.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指示LCD准备字符数据，并将其存储在变量`slot`中的字符位置❶，然后使用`writeLCD()`函数依次将字符数组的每个元素发送到LCD的CGRAM❷。
- en: '[Display Custom Characters on LCD](nsp-boxall502581-0008.xhtml#rbh1514)'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[在LCD上显示自定义字符](nsp-boxall502581-0008.xhtml#rbh1514)'
- en: 'The `printCCLCD()` function displays one of the LCD’s eight custom characters,
    storing it in position `slot` :'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`printCCLCD()`函数显示LCD的八个自定义字符中的一个，并将其存储在位置`slot`：'
- en: '[PRE15]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function operates similarly to `printLCD()` , but it doesn’t need the string
    decoding and goes straight to showing the character in CGRAM location 0 through
    7 ( `slot` ) at the current cursor position.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的操作方式类似于`printLCD()`，但它不需要字符串解码，直接在当前光标位置的CGRAM位置0到7（`slot`）显示字符。
- en: The [next project](nsp-boxall502581-0023.xhtml#pro55) demonstrates how to use
    these functions to display custom characters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[下一个项目](nsp-boxall502581-0023.xhtml#pro55)演示了如何使用这些函数显示自定义字符。'
- en: '[Project 55: Displaying Custom LCD Characters](nsp-boxall502581-0008.xhtml#rpro55)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目55：显示自定义LCD字符](nsp-boxall502581-0008.xhtml#rpro55)'
- en: In this project, you’ll reuse the hardware from [Project 52](nsp-boxall502581-0023.xhtml#pro52)
    to practice creating and displaying custom characters on an LCD. Open a terminal
    window, navigate to the *Project 55* subfolder of this book’s *Chapter 13* folder,
    and enter the command `make flash` as usual. After a moment or two, the LCD should
    display eight custom characters, as shown in [Figure 13-19](nsp-boxall502581-0023.xhtml#f13019)
    .
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，你将重复使用[项目52](nsp-boxall502581-0023.xhtml#pro52)的硬件，练习在LCD上创建并显示自定义字符。打开一个终端窗口，导航到本书*第13章*文件夹中的*项目55*子文件夹，然后像往常一样输入命令`make
    flash`。片刻后，LCD应显示八个自定义字符，如[图13-19](nsp-boxall502581-0023.xhtml#f13019)所示。
- en: '![Photo of the LCD displaying custom characters from Project 55](images/nsp-boxall502581-f13019.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![显示自定义字符的LCD照片，来自项目55](images/nsp-boxall502581-f13019.jpg)'
- en: 'Figure 13-19: The results of [Project 55](nsp-boxall502581-0023.xhtml#pro55)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-19： [项目55](nsp-boxall502581-0023.xhtml#pro55)的结果
- en: 'Let’s look at the code to see how this works:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码，了解它是如何工作的：
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This project demonstrates how easy it is to create custom characters when we
    use the three custom functions described previously to do the heavy lifting: respectively,
    they write the custom character data ❶, send commands to the LCD ❷, and send the
    custom character data to the LCD ❸. We simply insert the required data for the
    characters ❹, then feed that data to each location in the LCD’s CGRAM in turn
    with the `createCC()` function ❺. Finally, we position the cursor and display
    each custom character in turn with the `cursorLCD()` and `printCCLCD()` functions
    ❻.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目演示了使用前面描述的三个自定义函数来完成繁重工作时，创建自定义字符是多么简单：它们分别负责写入自定义字符数据❶、向LCD发送命令❷以及将自定义字符数据发送到LCD❸。我们只需插入所需的字符数据❹，然后通过`createCC()`函数依次将数据输入LCD的CGRAM的每个位置❺。最后，我们通过`cursorLCD()`和`printCCLCD()`函数依次定位光标并显示每个自定义字符❻。
- en: After working through this chapter you have the skills required to display all
    sorts of text and numerical data, as well as your own custom characters, on inexpensive
    and popular LCD modules. For a challenge, try creating your own AVR LCD library
    to make this code easier to include in your own future projects; every time you
    want to use the LCD, this library will save you development time and reduce complexity.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章内容后，你将具备在廉价且流行的LCD模块上显示各种文本和数字数据以及你自己创建的自定义字符的技能。作为挑战，尝试创建自己的AVR LCD库，以便在未来的项目中更轻松地包含此代码；每次想使用LCD时，这个库将节省开发时间并降低复杂性。
- en: 'In the [next and final chapter](nsp-boxall502581-0024.xhtml#ch14) , you’ll
    add yet another tool to your growing AVR toolbox: the ability to control servos.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在[下一章也是最后一章](nsp-boxall502581-0024.xhtml#ch14)，你将为你不断增长的AVR工具箱添加另一个工具：控制伺服电机的能力。
