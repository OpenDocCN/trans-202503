- en: '[13](nsp-boxall502581-0008.xhtml#rch13)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AVR and Character Liquid Crystal Displays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-ct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In previous chapters you’ve used LEDs, numerical LED displays, and the larger
    MAX7219 to display numerical values. However, a common *liquid crystal display
    (LCD)* module can allow your AVR projects to show a more versatile range of output,
    including text, numerical data, and your own custom characters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll use character LCD modules to display all three types
    of data. To do so, you’ll learn to convert integers into string variables and
    display floating-point numbers on the LCD. Along the way, you’ll build your own
    digital clock and a digital thermometer that can display the minimum and maximum
    temperature over time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Introducing LCDs](nsp-boxall502581-0008.xhtml#rah1501)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our LCD-based projects will use inexpensive LCDs that can display 2 rows of
    16 characters. Any LCD with an HD44780- or KS0066-compatible interface and a 5
    V backlight, such as the one in [Figure 13-1](nsp-boxall502581-0023.xhtml#f13001)
    , should work with these projects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a 16×2-character LCD module](images/nsp-boxall502581-f13001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: A 16×2-character LCD module'
  prefs: []
  type: TYPE_NORMAL
- en: Some rare LCDs have a 4.5 V rather than a 5 V backlight. If this is true of
    your LCD, place a 1N4004 diode in series between the 5 V power supply and the
    LCD’s LED+ or A pin.
  prefs: []
  type: TYPE_NORMAL
- en: LCDs like the one in [Figure 13-1](nsp-boxall502581-0023.xhtml#f13001) usually
    come without any wiring or connectors. To use an LCD with a solderless breadboard,
    you’ll need to solder in some 0.1 inch / 2.54 mm pitch inline header pins (such
    as PMD Way part number 1242070A) like those shown in [Figure 13-2](nsp-boxall502581-0023.xhtml#f13002)
    . These are usually supplied in 40-pin lengths; however, you can easily trim them
    down to the required 16-pin length.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a stack of 40-pin inline header pins](images/nsp-boxall502581-f13002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: Inline header pins'
  prefs: []
  type: TYPE_NORMAL
- en: Once assembled, your LCD will fit easily into the solderless breadboard, as
    shown in [Figure 13-3](nsp-boxall502581-0023.xhtml#f13003) . Note the labels on
    pins 1 through 16.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of an LCD in a solderless breadboard](images/nsp-boxall502581-f13003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: An LCD in a solderless breadboard'
  prefs: []
  type: TYPE_NORMAL
- en: The schematic symbol for our LCD is shown in [Figure 13-4](nsp-boxall502581-0023.xhtml#f13004)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![16×2-character LCD schematic symbol](images/nsp-boxall502581-f13004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: Schematic symbol for our 16×2-character LCD'
  prefs: []
  type: TYPE_NORMAL
- en: Pins DB0 through DB7 constitute the 8-bit data interface of the LCD, which communicates
    with our ATmega328P-PU microcontroller. If you need to save wiring, you can also
    use the LCD in a 4-bit mode, which only requires DB4 through B7\. We’ll use this
    method in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll also need a small 10 kΩ trimpot to control the contrast of the
    display. You can get breadboard-compatible trimpots that don’t require any extra
    soldering, like the one shown in [Figure 13-5](nsp-boxall502581-0023.xhtml#f13005)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a breadboard-compatible trimpot](images/nsp-boxall502581-f13005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: An example of a breadboard trimpot'
  prefs: []
  type: TYPE_NORMAL
- en: The schematic symbol for the trimpot in [Figure 13-5](nsp-boxall502581-0023.xhtml#f13005)
    is shown in [Figure 13-6](nsp-boxall502581-0023.xhtml#f13006) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Breadboard trimpot schematic symbol](images/nsp-boxall502581-f13006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: Schematic symbol for our breadboard trimpot'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve gotten your LCD ready to use with a solderless breadboard, it’s
    time to understand how to display various kinds of data. To use the LCD in your
    projects, you will need functions for the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: • Converting instructions into suitable control signals in order to send commands
    to the LCD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Initializing the LCD for use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Clearing all data from the LCD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Moving the cursor to the required position on the LCD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Displaying text on the LCD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As there are no functions to complete these tasks in our AVR toolchain, we’ll
    use the custom functions described in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that each of these functions sends values to the LCD to cause
    a given effect. For example, sending `0x01` to the LCD clears the screen. To determine
    which values we should use to accomplish certain tasks, we refer to the LCD’s
    instruction table, which is Table 6 in the HD44780’s data sheet (widely available
    and included with the book’s code download at [https://nostarch.com/avr-workshop/](https://nostarch.com/avr-workshop/)
    ). This table shows the status of the RS and R/_W pins required for a particular
    command, along with the binary representation of the command. [Figure 13-7](nsp-boxall502581-0023.xhtml#f13007)
    shows the clear display command, `0x01` .
  prefs: []
  type: TYPE_NORMAL
- en: '![The “clear display” row from Table 6 in the HD44780’s data sheet](images/nsp-boxall502581-f13007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-7: A numerical description of the LCD’s “clear screen” command'
  prefs: []
  type: TYPE_NORMAL
- en: As the figure shows, to clear the display we need to set the LCD pins RS and
    R/_W to low, then send `0b00000001` (or `0x01` ) to the LCD. We’ll do this with
    the `commandLCD()` function (introduced in the following section), which is then
    called from the `clearLCD()` function (described shortly in “Clear the LCD”).
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, refer to the table in the HD44780’s data sheet to
    understand which values I use to construct the other LCD commands. Later, you
    can use the table to create commands to suit your own needs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Send Commands to the LCD](nsp-boxall502581-0008.xhtml#rbh1501)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All information sent to the LCD, be it setup commands or data to display, is
    sent in bytes. However, as we’re using the LCD in 4-bit mode to save on hardware
    connections, we’ll need to use the following function to split the bytes of data
    into nibbles (4 bits) and send them to the LCD in the correct order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand what’s happening in this code, recall that a byte of data consists
    of 8 bits, or 2 nibbles: the higher nibble, which consists of bits 7 to 4, and
    the lower nibble, which consists of bits 3 to 0\. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `commandLCD()` function first takes the upper nibble of the command byte
    `_command` ❶ and uses bitwise arithmetic (see [Chapter 2](nsp-boxall502581-0012.xhtml#ch02)
    ) to clear the GPIO pins back to low. It then ensures the GPIO pins are set to
    match the upper nibble, the first half of the command byte.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it sets the RS pin on the LCD to low ❷, which tells the LCD we need to
    send data to its instruction register, and quickly sets the LCD’s E pin on ❸ and
    off ❹, which tells the LCD more data is coming.
  prefs: []
  type: TYPE_NORMAL
- en: The function then uses bitwise arithmetic to shift the 4 bits of the lower nibble
    up into the higher nibble ❺, which will match the GPIO pins used for sending data
    to the LCD. Finally, it again sets the LCD’s E pin on ❻ and off ❼ to finalize
    the data transmission. We use the `_delay_us()` (delay in microseconds, not milliseconds)
    function to give the LCD time to process the changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Initialize the LCD for Use](nsp-boxall502581-0008.xhtml#rbh1502)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like many other devices, the LCD needs to be initialized with various parameters
    before we first use it in our code. We’ll use the `initLCD()` function to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function first sets the required GPIO pins to digital outputs ❶. After
    a short delay to give the LCD time to wake up, it then sends the command to set
    the cursor (the position at which data is first displayed) back to the top left
    of the screen ❷. The next command configures the LCD’s controller IC to use it
    as a 16×2-character unit with a 4-bit data interface and to select a default font
    with characters that consist of 5×8 pixels ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The following command ❹ tells the LCD to not use a block cursor, to not blink
    the cursor, and to turn the display on. We then tell the LCD controller we need
    the cursor to move in incremental stages ❺ so that if we wish to display more
    than one character in turn, we don’t need to explicitly set the cursor position
    after each character. Finally, we clear the LCD of all characters ❻ and give it
    a little time to process the change.
  prefs: []
  type: TYPE_NORMAL
- en: '[Clear the LCD](nsp-boxall502581-0008.xhtml#rbh1503)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The convenient `clearLCD()` function simply clears the LCD of all data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We send the command to clear the screen ❶, then the command to return the cursor
    to the top left of the LCD ❷.
  prefs: []
  type: TYPE_NORMAL
- en: '[Set the Cursor](nsp-boxall502581-0008.xhtml#rbh1504)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `cursorLCD()` function sets the cursor to a given location on the LCD,
    following which you can display data starting from that position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With our LCD, we have 2 rows of 16 characters: rows 0 and 1, with 16 columns
    numbered 0 to 15\. This function creates the required LCD command based on the
    position data received for a row 0 location ❶ and for a row 1 location ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Print to the LCD](nsp-boxall502581-0008.xhtml#rbh1505)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `printLCD()` function is used to display data on the LCD, such as text
    or numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can accept text in quotes, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'or an array of characters, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The function sends each character in turn from the array using its `for` loop
    ❶, representing characters as numerical values from a standard ASCII table (discussed
    in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) ). All LCD displays on the market
    should support the values 33 to 125, which includes the lower- and uppercase alphabet, numbers,
    and standard popular symbols and punctuation marks. We set the location of the
    first (or only) character to display using the `cursorLCD()` or `clearLCD()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `printLCD()` function is very similar to the `commandLCD()` function. It
    first takes the upper nibble of the character byte `_string[i]` ❷ and uses bitwise
    arithmetic to clear the GPIO pins back to low. It then ensures the GPIO pins are
    set to match the upper nibble, the first half of the command byte.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it sets the RS pin on the LCD to high ❸, which tells the LCD we need to
    send data to its instruction register, and quickly sets the LCD’s E pin on ❹ and
    off ❺, which tells the LCD more data is coming.
  prefs: []
  type: TYPE_NORMAL
- en: The function then uses bitwise arithmetic to shift the 4 bits of the lower nibble
    up into the higher nibble ❻, which will match the GPIO pins used for sending data
    to the LCD. Finally, it again sets the LCD’s E pin on ❼ and off ❽ to finalize
    the data transmission. We use the `_delay_us()` (delay in microseconds) function
    to give the LCD time to process the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note To use `printLCD()` to display the contents of an integer variable, first
    convert the variable to an array of characters with `itoa(` `a` `,` `b` `,` `c`
    `)` . This takes the integer `a` and places it in an array of characters `b` with
    a maximum length of `c` characters. You’ll need to include the *stdlib.h* library
    along with the other `include` statements in your code, as it contains the `itoa()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: In the following projects, you’ll put the LCD to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 52: Using a Character LCD with Your AVR](nsp-boxall502581-0008.xhtml#rpro52)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll consolidate the information presented so far about controlling
    the LCD by building your own LCD circuit and displaying various information. This
    will introduce you to using LCDs in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1506)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build your circuit, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16×2-character LCD with fitted inline header pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 10 kΩ breadboard-compatible trimpot (variable resistor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 22 pF ceramic capacitors (C1–C2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 470 μF 16 V electrolytic capacitor (C3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16 MHz crystal oscillator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 13-8](nsp-boxall502581-0023.xhtml#f13008)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 52](images/nsp-boxall502581-f13008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-8: Schematic for [Project 52](nsp-boxall502581-0023.xhtml#pro52)'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve finished with this circuit, keep it assembled, as you’ll use it
    again for [Project 55](nsp-boxall502581-0023.xhtml#pro55) .
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1507)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 52* subfolder of this book’s
    *Chapter 13* folder, and enter the command `make flash` as usual. After a few
    moments, the LCD should show the text in [Figure 13-9](nsp-boxall502581-0023.xhtml#f13009)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the LCD displaying the initial message from Project 52](images/nsp-boxall502581-f13009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-9: First example of text displayed using [Project 52](nsp-boxall502581-0023.xhtml#pro52)'
  prefs: []
  type: TYPE_NORMAL
- en: That text should soon be replaced with an incrementing digit, as shown in [Figure
    13-10](nsp-boxall502581-0023.xhtml#f13010) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the LCD displaying “counting up:” and the numbers from 0 to 9](images/nsp-boxall502581-f13010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-10: Example of the counting display routine from [Project 52](nsp-boxall502581-0023.xhtml#pro52)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the code and review the functions that make this possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code puts the LCD functions described earlier to use. In the main section
    of the code, we first initialize the LCD ❶, then declare a character array for
    displaying numbers ❷ and the required variable for counting ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up the display operation. We position and display text using the
    `cursorLCD()` and `printLCD()` functions ❹, then clear the display with `clearLCD()`
    ❺. The `for` loop ❻ displays the numbers from zero to nine along the second row
    of the LCD (as shown in [Figure 13-10](nsp-boxall502581-0023.xhtml#f13010) ).
    We use `itoa()` ❼ to convert the integer variable `i` into a character array of
    numbers, then display that array using `printLCD()` ❽.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to set up and use a character LCD, let’s put this skill
    to good use by creating a digital clock.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 53: Building an AVR-Based LCD Digital Clock](nsp-boxall502581-0008.xhtml#rpro53)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll combine the DS3231 real-time clock module and an LCD
    to build your own digital clock.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1508)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build your circuit, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16×2-character LCD with fitted inline header pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 10 kΩ breadboard-compatible trimpot (variable resistor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • DS3231 RTC module with backup battery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 22 pF ceramic capacitors (C1–C2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 470 μF 16 V electrolytic capacitor (C3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16 MHz crystal oscillator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 13-11](nsp-boxall502581-0023.xhtml#f13011)
    . Don’t forget to connect the DS3231 board to 5 V and GND as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 53](images/nsp-boxall502581-f13011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-11: Schematic for [Project 53](nsp-boxall502581-0023.xhtml#pro53)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1509)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with [Project 51](nsp-boxall502581-0022.xhtml#pro51) from [Chapter 12](nsp-boxall502581-0022.xhtml#ch12)
    , you’ll first need to set the time and date in the DS3231 module. In your text
    editor, open the *main.c* file in the *Project 53* subfolder of this book’s *Chapter
    13* folder and remove the comment slashes in front of the function `setTimeDS3231()`
    . Update the parameters in that function to match your current date and time.
  prefs: []
  type: TYPE_NORMAL
- en: Now save the file, then use the `make flash` command as usual from the terminal
    window. Reopen the *main.c* file and place the comment slashes in front of the
    same function, save the file, and reflash the code. Once you’ve done so, you should
    see the current time and date displayed on your LCD module. An example of this
    is shown in [Figure 13-12](nsp-boxall502581-0023.xhtml#f13012) . Congratulations—you’ve
    made your own LCD digital clock!
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the LCD clock from Project 53](images/nsp-boxall502581-f13012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-12: Example operation of [Project 53](nsp-boxall502581-0023.xhtml#pro53)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the code to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first section of the code includes all the I ² C functions required to read
    and write data with our DS3231 RTC module as described in [Project 51](nsp-boxall502581-0022.xhtml#pro51)
    in [Chapter 12](nsp-boxall502581-0022.xhtml#ch12) , using the same method of working
    with the time and date information we employed with the MAX7219 display module.
    It also includes each LCD function explained previously in this chapter. Then
    we need to ensure the time and date are set using the `setTimeDS3231()` function
    ❶, and retrieve that information and display it in a nice format on the LCD.
  prefs: []
  type: TYPE_NORMAL
- en: The code displays time in 24-hour format, using two digits to represent each
    of the hour, minute, and second parts. It first retrieves the data from the DS3231
    ❷ in the same way as [Project 51](nsp-boxall502581-0022.xhtml#pro51) in [Chapter
    12](nsp-boxall502581-0022.xhtml#ch12) . then converts the hour, minute and second
    information using `itoa()` ❸ and displays each part at the correct place on the
    LCD with `cursorLCD()` .
  prefs: []
  type: TYPE_NORMAL
- en: To maintain correct spacing and display of information, we must ensure the LCD
    displays single-digit values with a zero preceding them (representing the sixth
    day of the month as 06, for example). To do so, the code checks if the value from
    the time clock is zero ❹ or between one and nine ❺, then writes the required zeros
    before any single-digit time data. It does this for the hours, minutes, seconds,
    day of month, and month values.
  prefs: []
  type: TYPE_NORMAL
- en: The `switch...case` statement ❻ then takes the day of week data—a value from
    1 to 7 corresponding to Sunday through Saturday or Monday through Sunday, depending
    on your region and preference—and displays the day in abbreviated form. After
    all the information has been displayed, the clock waits for 900 ms ❼ before clearing
    the display, then starting over.
  prefs: []
  type: TYPE_NORMAL
- en: For a challenge, you might convert this project into a 12-hour clock with an
    AM/PM display, or perhaps add an alarm that sounds a piezo buzzer at a certain
    time every day.
  prefs: []
  type: TYPE_NORMAL
- en: '[Displaying Floating-Point Numbers on the LCD](nsp-boxall502581-0008.xhtml#rah1502)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our [next project](nsp-boxall502581-0023.xhtml#pro54) requires us to display
    a floating-point number on the LCD. As with integers, floating-point numbers first
    need to be converted from floats to character arrays. To do this we use the `dtostrf()`
    function, as described in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) , then
    display the character array as usual with the `printLCD()` function. Always ensure
    you declare your character array with enough space to cover the entire number
    and fraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to display the numbers 1.2345678 and 12345.678, replace the `int
    main()` loop from [Project 54](nsp-boxall502581-0023.xhtml#pro54) with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We declare variables holding two sample numbers to display on the LCD for the
    purposes of demonstration ❶, and the character array used in the display process
    ❷. We then initialize the LCD as usual ❸ and move the cursor to the top left of
    the display ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The code then converts the number 1.2345678 to a string displayed using 10 characters,
    with 7 of them after the decimal point ❺. Finally, it displays the number 12345.678
    using 9 characters, this time with 3 of them after the decimal point ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Flash the code and you should see a display like the one in [Figure 13-13](nsp-boxall502581-0023.xhtml#f13013)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the LCD displaying floating-point numbers](images/nsp-boxall502581-f13013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-13: Floating-point numbers on the LCD'
  prefs: []
  type: TYPE_NORMAL
- en: This example displayed two positive numbers. If you’d like to display negative
    numbers, remember to allow one character space for the negative sign in front
    of the first digit. For example, to display −123.45, you would need to allocate
    seven character spaces.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll put this new skill to work in the [next project](nsp-boxall502581-0023.xhtml#pro54)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 54: LCD Digital Thermometer with Min/Max Display](nsp-boxall502581-0008.xhtml#rpro54)'
  prefs: []
  type: TYPE_NORMAL
- en: With this project you’ll make a digital thermometer that can display the minimum
    and maximum temperature over time along with the current and average temperature
    over time. This project is another example of how to incorporate functions from
    previous chapters into new and more complicated projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1510)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build your circuit, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16×2-character LCD with fitted inline header pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 10 kΩ breadboard-compatible trimpot (variable resistor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One TMP36 temperature sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 22 pF ceramic capacitors (C1–C2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 470 μF 16 V electrolytic capacitor (C3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 0.1 μF ceramic capacitor (C4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16 MHz crystal oscillator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 13-14](nsp-boxall502581-0023.xhtml#f13014)
    . Don’t forget to connect the microcontroller’s AV [CC] pin to 5 V!
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 54](images/nsp-boxall502581-f13014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-14: Schematic for [Project 54](nsp-boxall502581-0023.xhtml#pro54)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1511)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 54* subfolder of this book’s
    *Chapter 13* folder, and enter the command `make flash` as usual. After a moment
    or two, the LCD should alternate between showing the minimum and maximum temperatures,
    as shown in [Figure 13-15](nsp-boxall502581-0023.xhtml#f13015) , and the current
    and average temperatures, as shown in [Figure 13-16](nsp-boxall502581-0023.xhtml#f13016)
    . The temperature readings are in degrees Celsius and cover the period since the
    project was last reset or turned on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the LCD displaying minimum and maximum temperatures](images/nsp-boxall502581-f13015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-15: The LCD displaying the minimum and maximum temperatures'
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the LCD displaying current and average temperatures](images/nsp-boxall502581-f13016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-16: The LCD displaying the current and average temperatures'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the code to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for this project breaks down into two concepts: determining the temperature
    from the TMP36 sensor (as demonstrated in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03)
    ), then displaying the temperature values using the LCD.'
  prefs: []
  type: TYPE_NORMAL
- en: We first use a series of functions and commands to activate the ADC on pin 28
    and call it into action in the main code ❶. The `startADC()` function is slightly
    different from its equivalent in previous projects; since we’re now operating
    the microcontroller at 16 MHz rather than 1 MHz, we need a larger prescaler to
    operate the ADC. Therefore, we set the ADCSRA register to use a prescaler of 128
    ❷. We arrive at this value by dividing 16 MHz by 200 kHz (the ideal speed for
    the ADC), which results in 80; the closest prescaler value is 128, so we use that.
  prefs: []
  type: TYPE_NORMAL
- en: The code reads the raw data from the ADC ❹ and converts it to degrees Celsius
    ❺. It then determines if the current temperature is a minimum or maximum ❻ and
    calculates the average temperature measured since the last reset ❼. Note that
    the variable `minimum` is declared with a value of −273 degrees ❸. If we leave
    it without an initial value, it will default to 0 and we won’t get a true minimum
    temperature value (unless the sensor is outside and the temperature never goes
    below freezing!). Finally, we display all this temperature data over two screens,
    using the LCD functions from earlier in this chapter ❽.
  prefs: []
  type: TYPE_NORMAL
- en: You can of course change the temperature values displayed to Fahrenheit by multiplying
    them by 1.8 and adding 32\. Or, if you feel like a challenge, why not modify this
    project by combining it with what you learned in [Project 53](nsp-boxall502581-0023.xhtml#pro53)
    to build a clock that shows the current temperature?
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’ve finished experimenting, let’s move on to creating our final type
    of output: custom characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Displaying Custom Characters on the LCD](nsp-boxall502581-0008.xhtml#rah1503)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to using the standard letters, numbers, and symbols available on
    most keyboards, you can define up to eight of your own characters in each project.
    As you know, each character in the LCD module is made up of eight rows of five
    pixels, as shown in [Figure 13-17](nsp-boxall502581-0023.xhtml#f13017) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of an LCD with contrast adjusted to maximum in order to display individual
    character pixels](images/nsp-boxall502581-f13017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-17: Each LCD character is made up of eight rows of five pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: To display your own custom characters, you must first define each character
    using an array consisting of eight elements (one element per character line).
    The value of the element defines the state of the pixels in that line. For example,
    to create a simple “smiley face,” plan out the pixels on a grid as shown in [Figure
    13-18](nsp-boxall502581-0023.xhtml#f13018) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram illustrating numerical composition of custom LCD characters](images/nsp-boxall502581-f13018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-18: Elements of a custom smiley face character'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert each horizontal line into a value by converting it from a binary number
    matching the pixels’ on or off state to a decimal number. Then create an array
    to define your custom character by entering in the eight decimal values, as shown
    below for the elements in [Figure 13-18](nsp-boxall502581-0023.xhtml#f13018) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code for this chapter includes a spreadsheet that simplifies this array
    creation process.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created the array, you need to program it into the LCD’s *character
    generator RAM (CGRAM)* . This is a type of RAM used in the LCD’s controller chip
    that stores the design of the characters to display. There are eight possible
    positions in our LCD’s CGRAM. To write this character data and use the custom
    characters, we’ll use the three custom functions defined in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Data to CGRAM](nsp-boxall502581-0008.xhtml#rbh1512)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `writeLCD()` function writes an individual line of data to the LCD’s CGRAM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This function operates in the same way as our `commandLCD()` function, except
    that `writeLCD()` sets the RS pin on the LCD high instead of low, which tells
    the LCD that the incoming data is for the CGRAM and not a regular command. It’s
    used in conjunction with the following two functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Send Custom Character Data to LCD](nsp-boxall502581-0008.xhtml#rbh1513)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `createCC()` function directs the custom character data array ( `ccdata[]`
    ) into the specified CGRAM memory position ( `slot` ), from 0 to 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We command the LCD to prepare for character data and to store it in the character
    position in the variable `slot` ❶, then send each element of the character array
    in turn to the LCD’s CGRAM with the `writeLCD()` function ❷.
  prefs: []
  type: TYPE_NORMAL
- en: '[Display Custom Characters on LCD](nsp-boxall502581-0008.xhtml#rbh1514)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `printCCLCD()` function displays one of the LCD’s eight custom characters,
    storing it in position `slot` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function operates similarly to `printLCD()` , but it doesn’t need the string
    decoding and goes straight to showing the character in CGRAM location 0 through
    7 ( `slot` ) at the current cursor position.
  prefs: []
  type: TYPE_NORMAL
- en: The [next project](nsp-boxall502581-0023.xhtml#pro55) demonstrates how to use
    these functions to display custom characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 55: Displaying Custom LCD Characters](nsp-boxall502581-0008.xhtml#rpro55)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll reuse the hardware from [Project 52](nsp-boxall502581-0023.xhtml#pro52)
    to practice creating and displaying custom characters on an LCD. Open a terminal
    window, navigate to the *Project 55* subfolder of this book’s *Chapter 13* folder,
    and enter the command `make flash` as usual. After a moment or two, the LCD should
    display eight custom characters, as shown in [Figure 13-19](nsp-boxall502581-0023.xhtml#f13019)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the LCD displaying custom characters from Project 55](images/nsp-boxall502581-f13019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-19: The results of [Project 55](nsp-boxall502581-0023.xhtml#pro55)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the code to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This project demonstrates how easy it is to create custom characters when we
    use the three custom functions described previously to do the heavy lifting: respectively,
    they write the custom character data ❶, send commands to the LCD ❷, and send the
    custom character data to the LCD ❸. We simply insert the required data for the
    characters ❹, then feed that data to each location in the LCD’s CGRAM in turn
    with the `createCC()` function ❺. Finally, we position the cursor and display
    each custom character in turn with the `cursorLCD()` and `printCCLCD()` functions
    ❻.'
  prefs: []
  type: TYPE_NORMAL
- en: After working through this chapter you have the skills required to display all
    sorts of text and numerical data, as well as your own custom characters, on inexpensive
    and popular LCD modules. For a challenge, try creating your own AVR LCD library
    to make this code easier to include in your own future projects; every time you
    want to use the LCD, this library will save you development time and reduce complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the [next and final chapter](nsp-boxall502581-0024.xhtml#ch14) , you’ll
    add yet another tool to your growing AVR toolbox: the ability to control servos.'
  prefs: []
  type: TYPE_NORMAL
