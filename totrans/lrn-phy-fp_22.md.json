["```\n{-# OPTIONS -Wall #-}\n\nmodule MOExamples where\n\nimport SimpleVec\n   ( R, Vec, (^+^), (^-^), (*^), vec, zeroV, magnitude\n   , sumV, iHat, jHat, kHat, xComp, yComp, zComp )\nimport Mechanics1D ( TimeStep, NumericalMethod, euler, rungeKutta4 )\nimport Mechanics3D\n   ( ParticleState(..), HasTime(..), defaultParticleState\n   , earthSurfaceGravity, customLabel, orient, disk )\nimport MultipleObjects\n   ( MultiParticleState(..), DMultiParticleState, Force(..), TwoBodyForce\n   , newtonSecondMPS, updateMPS, statesMPS, eulerCromerMPS\n   , linearSpring, fixedLinearSpring, billiardForce )\nimport Graphics.Gnuplot.Simple\nimport qualified Graphics.Gloss as G\nimport qualified Vis as V\n```", "```\ntwoSpringsForces :: [Force]\ntwoSpringsForces\n    = [ExternalForce 0 (fixedLinearSpring 100 0.5 zeroV)\n      ,InternalForce 0 1 (linearSpring 100 0.5)\n      ,ExternalForce 0 earthSurfaceGravity\n      ,ExternalForce 1 earthSurfaceGravity\n      ]\n```", "```\ntwoSpringsInitial :: MultiParticleState\ntwoSpringsInitial\n    = MPS [defaultParticleState\n           { mass   = 2\n           , posVec = 0.4 *^ jHat ^-^ 0.3 *^ kHat }\n          ,defaultParticleState\n           { mass   = 3\n           , posVec = 0.4 *^ jHat ^-^ 0.8 *^ kHat }\n          ]\n```", "```\ntwoSpringsUpdate :: TimeStep\n                 -> MultiParticleState  -- old state\n                 -> MultiParticleState  -- new state\ntwoSpringsUpdate dt = updateMPS (eulerCromerMPS dt) twoSpringsForces\n```", "```\n➊ {-# OPTIONS -Wall #-}\n\n   import SimpleVec ( R, zeroV )\n   import Mechanics3D ( posVec, simulateVis, v3FromVec )\n   import MultipleObjects ( MultiParticleState(..) )\n   import MOExamples ( twoSpringsInitial, twoSpringsUpdate )\n   import Vis ( VisObject(..), Flavour(..), red, green, blue )\n\n   main :: IO ()\n   main = simulateVis 1 20 twoSpringsInitial twoSpringsVisObject twoSpringsUpdate\n\n   twoSpringsVisObject :: MultiParticleState -> VisObject R\n➋ twoSpringsVisObject (MPS sts)\n    ➌ = let r0 = posVec (sts !! 0)\n          ➍ r1 = posVec (sts !! 1)\n          ➎ springsObj = Line Nothing [v3FromVec zeroV\n                                       ,v3FromVec r0\n                                       ,v3FromVec r1] ➏ blue\n          ➐ objs = [Trans (v3FromVec r0) (Sphere 0.1 Solid red)\n                    ,Trans (v3FromVec r1) (Sphere 0.1 Solid green)\n                    ,springsObj\n                    ]\n          ➑ vpm = 1  -- Vis units per meter\n      ➒ in Scale (vpm,vpm,vpm) $ VisObjects objs\n```", "```\nPrelude Graphics.Gloss>  :m Vis Linear.V3\nPrelude Vis Linear.V3>  :t Line\nLine :: Maybe a -> [V3 a] -> Color -> VisObject a\n```", "```\nkineticEnergy :: ParticleState -> R\nkineticEnergy st = let m = mass st\n                       v = magnitude (velocity st)\n                   in (1/2) * m * v**2\n```", "```\nsystemKE :: MultiParticleState -> R\nsystemKE (MPS sts) = sum [kineticEnergy st | st <- sts]\n```", "```\nlinearSpringPE :: R              -- spring constant\n               -> R              -- equilibrium length\n               -> ParticleState  -- state of particle at one end of spring\n               -> ParticleState  -- state of particle at other end of spring\n               -> R              -- potential energy of the spring\nlinearSpringPE k re st1 st2\n    = let r1 = posVec st1\n          r2 = posVec st2\n          r21 = r2 ^-^ r1\n          r21mag = magnitude r21\n      in k * (r21mag - re)**2 / 2\n```", "```\n-- z direction is toward the sky\n-- assumes SI units\nearthSurfaceGravityPE :: ParticleState -> R\nearthSurfaceGravityPE st\n    = let g = 9.80665  -- m/s^2\n          m = mass st\n          z = zComp (posVec st)\n      in m * g * z\n```", "```\ntwoSpringsPE :: MultiParticleState -> R\ntwoSpringsPE (MPS sts)\n    = linearSpringPE 100 0.5 defaultParticleState (sts !! 0)\n      + linearSpringPE 100 0.5 (sts !! 0) (sts !! 1)\n      + earthSurfaceGravityPE (sts !! 0)\n      + earthSurfaceGravityPE (sts !! 1)\n```", "```\ntwoSpringsME :: MultiParticleState -> R\ntwoSpringsME mpst = systemKE mpst + twoSpringsPE mpst\n```", "```\nbilliardForces :: R -> [Force]\nbilliardForces k = [InternalForce 0 1 (billiardForce k (2*ballRadius))]\n```", "```\nballRadius :: R\nballRadius = 0.03  -- 6cm diameter = 0.03m radius\n```", "```\nbilliardDiffEq :: R -> MultiParticleState -> DMultiParticleState\nbilliardDiffEq k = newtonSecondMPS $ billiardForces k\n```", "```\nbilliardUpdate\n    :: (TimeStep -> NumericalMethod MultiParticleState DMultiParticleState)\n    -> R         -- k\n    -> TimeStep  -- dt\n    -> MultiParticleState -> MultiParticleState\nbilliardUpdate nMethod k dt = updateMPS (nMethod dt) (billiardForces k)\n```", "```\nbilliardEvolver\n    :: (TimeStep -> NumericalMethod MultiParticleState DMultiParticleState)\n    -> R         -- k\n    -> TimeStep  -- dt\n    -> MultiParticleState -> [MultiParticleState]\nbilliardEvolver nMethod k dt = statesMPS (nMethod dt) (billiardForces k)\n```", "```\nbilliardInitial :: MultiParticleState\nbilliardInitial\n    = let ballMass = 0.160  -- 160g\n      in MPS [defaultParticleState { mass     = ballMass\n                                   , posVec   = zeroV\n                                   , velocity = 0.2 *^ iHat }\n             ,defaultParticleState { mass     = ballMass\n                                   , posVec   = iHat ^+^ 0.02 *^ jHat\n                                   , velocity = zeroV }\n             ]\n```", "```\nbilliardStates nMethod k dt\n```", "```\nbilliardStates\n    :: (TimeStep -> NumericalMethod MultiParticleState DMultiParticleState)\n    -> R         -- k\n    -> TimeStep  -- dt\n    -> [MultiParticleState]\nbilliardStates nMethod k dt\n    = statesMPS (nMethod dt) (billiardForces k) billiardInitial\n```", "```\nbilliardStatesFinite\n    :: (TimeStep -> NumericalMethod MultiParticleState DMultiParticleState)\n    -> R         -- k\n    -> TimeStep  -- dt\n    -> [MultiParticleState]\nbilliardStatesFinite nMethod k dt\n    = takeWhile (\\st -> timeOf st <= 10) (billiardStates nMethod k dt)\n```", "```\nmomentum :: ParticleState -> Vec\nmomentum st = let m = mass st\n                  v = velocity st\n              in m *^ v\n```", "```\nsystemP :: MultiParticleState -> Vec\nsystemP (MPS sts) = sumV [momentum st | st <- sts]\n```", "```\npercentChangePMag :: [MultiParticleState] -> R\npercentChangePMag mpsts\n    = let p0 = systemP (head mpsts)\n          p1 = systemP (last mpsts)\n      in 100 * magnitude (p1 ^-^ p0) / magnitude p0\n```", "```\nsigFigs :: Int -> R -> Float\nsigFigs n x = let expon :: Int\n                  expon = floor (logBase 10 x) - n + 1\n                  toInt :: R -> Int\n                  toInt = round\n              in (10^^expon *) $ fromIntegral $ toInt (10^^(-expon) * x)\n```", "```\ndata Justification = LJ | RJ deriving Show\n\ndata Table a = Table Justification [[a]]\n```", "```\ninstance Show a => Show (Table a) where\n    show (Table j xss)\n        = let pairWithLength x = let str = show x in (str, length str)\n              pairss = map (map pairWithLength) xss\n              maxLength = maximum (map maximum (map (map snd) pairss))\n              showPair (str,len)\n                  = case j of\n                      LJ -> str ++ replicate (maxLength + 1 - len) ' '\n                      RJ -> replicate (maxLength + 1 - len) ' ' ++ str\n              showLine pairs = concatMap showPair pairs ++ \"\\n\"\n          in init $ concatMap showLine pairss\n```", "```\npTable :: (TimeStep -> NumericalMethod MultiParticleState DMultiParticleState)\n       -> [R]         -- ks\n       -> [TimeStep]  -- dts\n       -> Table Float\npTable nMethod ks dts\n    = Table LJ [[sigFigs 2 $\n                 percentChangePMag (billiardStatesFinite nMethod k dt)\n                     | dt <- dts] | k <- ks]\n\npTableEu :: [R]         -- ks\n         -> [TimeStep]  -- dts\n         -> Table Float\npTableEu = pTable euler\n```", "```\nPrelude Vis>  :m\nPrelude>  :l MOExamples\n[1 of 6] Compiling Newton2          ( Newton2.hs, interpreted )\n[2 of 6] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )\n[3 of 6] Compiling SimpleVec        ( SimpleVec.hs, interpreted )\n[4 of 6] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )\n[5 of 6] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )\n[6 of 6] Compiling MOExamples       ( MOExamples.hs, interpreted )\nOk, six modules loaded.\n*MOExamples> pTable euler [10,30,100] [0.003,0.01,0.03,0.1]\n4.3e-14 0.0     0.0     0.0\n0.0     0.0     0.0     0.0\n2.2e-14 0.0     0.0     8.7e-14\n*MOExamples> pTable eulerCromerMPS [10,30,100] [0.003,0.01,0.03,0.1]\n0.0 0.0 0.0 0.0\n0.0 0.0 0.0 0.0\n0.0 0.0 0.0 0.0\n*MOExamples> pTable rungeKutta4 [10,30,100] [0.003,0.01,0.03,0.1]\n4.3e-14 2.2e-14 0.0     0.0\n2.2e-14 0.0     2.2e-14 0.0\n0.0     0.0     0.0     0.0\n```", "```\nsystemKEWithTime :: IO ()\nsystemKEWithTime\n    = let timeKEPairsEC\n              = [(timeOf mpst, systemKE mpst)\n                     | mpst <- billiardStatesFinite eulerCromerMPS 30 0.03]\n          timeKEPairsRK4\n              = [(timeOf mpst, systemKE mpst)\n                     | mpst <- billiardStatesFinite rungeKutta4    30 0.03]\n      in plotPaths [Key Nothing\n                   ,Title \"System Kinetic Energy versus Time\"\n                   ,XLabel \"Time (s)\"\n                   ,YLabel \"System Kinetic Energy (J)\"\n                   ,XRange (4,6)\n                   ,PNG \"SystemKE.png\"\n                   ,customLabel (4.1,0.0026) \"dt = 0.03 s\"\n                   ,customLabel (4.1,0.0025) \"k = 30 N/m\"\n                   ,customLabel (5.4,0.00329) \"Euler-Cromer\"\n                   ,customLabel (5.4,0.00309) \"Runge-Kutta 4\"\n                   ] [timeKEPairsEC,timeKEPairsRK4]\n```", "```\npercentChangeKE :: [MultiParticleState] -> R\npercentChangeKE mpsts\n    = let ke0 = systemKE (head mpsts) ke1 = systemKE (last mpsts)\n      in 100 * (ke1 - ke0) / ke0\n```", "```\ntenths :: R -> Float\ntenths = let toInt :: R -> Int\n             toInt = round\n         in (/ 10) . fromIntegral . toInt . (* 10)\n```", "```\nkeTable\n    :: (TimeStep -> NumericalMethod MultiParticleState DMultiParticleState)\n    -> [R]         -- ks\n    -> [TimeStep]  -- dts\n    -> Table Float\nkeTable nMethod ks dts\n    = Table RJ [[tenths $\n                 percentChangeKE (billiardStatesFinite nMethod k dt)\n                     | dt <- dts] | k <- ks]\n```", "```\n*MOExamples> keTable euler [10,30,100] [0.003,0.01,0.03,0.1]\n     4.2    15.9    68.7   705.7\n     8.3    34.1   185.4  3117.9\n    16.9    82.9   642.2 39907.1\n*MOExamples> keTable eulerCromerMPS [10,30,100] [0.003,0.01,0.03,0.1]\n    0.0    0.0   -0.3    6.2\n    0.0    0.1    1.1  154.1\n    0.0    0.3   -8.9 3705.2\n\n*MOExamples> keTable rungeKutta4 [10,30,100] [0.003,0.01,0.03,0.1]\n   0.0   0.0   0.0  -2.8\n   0.0  -0.1  -1.4 -14.6\n   0.0  -0.5  -1.6  90.3\n```", "```\ncontactSteps :: [MultiParticleState] -> Int\ncontactSteps = length . takeWhile inContact . dropWhile (not . inContact)\n```", "```\ninContact :: MultiParticleState -> Bool\ninContact (MPS sts)\n    = let r = magnitude $ posVec (sts !! 0) ^-^ posVec (sts !! 1)\n      in r < 2 * ballRadius\n```", "```\ncontactTable\n    :: (TimeStep -> NumericalMethod MultiParticleState DMultiParticleState)\n    -> [R]         -- ks\n    -> [TimeStep]  -- dts\n    -> Table Int\ncontactTable nMethod ks dts\n    = Table RJ [[contactSteps (billiardStatesFinite nMethod k dt)\n                     | dt <- dts] | k <- ks]\n```", "```\n*MOExamples> contactTable euler [10,30,100] [0.003,0.01,0.03,0.1]\n 89 27  9  3\n 53 16  6  2\n 29  9  3  2\n*MOExamples> contactTable eulerCromerMPS [10,30,100] [0.003,0.01,0.03,0.1]\n 89 27  9  2\n 53 16  5  1\n 29  9  3  1\n*MOExamples> contactTable rungeKutta4 [10,30,100] [0.003,0.01,0.03,0.1]\n 89 27  9  2\n 53 16  5  1\n 29  9  3  0\n```", "```\nclosest :: [MultiParticleState] -> R\nclosest = minimum . map separation\n```", "```\nseparation :: MultiParticleState -> R\nseparation (MPS sts)\n    = magnitude $ posVec (sts !! 0) ^-^ posVec (sts !! 1)\n```", "```\nclosestTable\n    :: (TimeStep -> NumericalMethod MultiParticleState DMultiParticleState)\n    -> [R]         -- ks\n    -> [TimeStep]  -- dts\n    -> Table Float\nclosestTable nMethod ks dts\n    = Table RJ [[tenths $ (100*) $\n                 closest (billiardStatesFinite nMethod k dt)\n                     | dt <- dts] | k <- ks]\n```", "```\n*MOExamples> closestTable euler [10,30,100] [0.003,0.01,0.03,0.1]\n 4.4 4.3 4.0 2.8\n 5.0 4.9 4.6 2.8\n 5.4 5.3 5.0 2.8\n*MOExamples> closestTable eulerCromerMPS [10,30,100] [0.003,0.01,0.03,0.1]\n 4.4 4.4 4.4 4.5\n 5.1 5.1 5.0 4.5\n 5.5 5.5 5.5 4.5\n*MOExamples> closestTable rungeKutta4 [10,30,100] [0.003,0.01,0.03,0.1]\n 4.4 4.4 4.4 4.7\n 5.1 5.1 5.1 5.2\n 5.5 5.5 5.5 6.3\n```", "```\nbilliardPicture :: MultiParticleState -> G.Picture\nbilliardPicture (MPS sts)\n    = G.scale ppm ppm $ G.pictures [place st | st <- sts]\n      where\n        ppm = 300  -- pixels per meter\n        place st = G.translate (xSt st) (ySt st) blueBall\n        xSt = realToFrac . xComp . posVec\n        ySt = realToFrac . yComp . posVec\n        blueBall = G.Color G.blue (disk $ realToFrac ballRadius)\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Mechanics3D ( simulateGloss )\nimport MultipleObjects (eulerCromerMPS )\n\nimport MOExamples ( billiardInitial, billiardPicture, billiardUpdate )\n\nmain :: IO ()\nmain = simulateGloss 1 100 billiardInitial billiardPicture\n       (billiardUpdate eulerCromerMPS 30)\n```", "```\n-- 64 masses (0 to 63)\n-- There are 63 internal springs, 2 external springs\nforcesString :: [Force]\nforcesString\n    = [ExternalForce  0 (fixedLinearSpring 5384 0 (vec    0 0 0))\n      ,ExternalForce 63 (fixedLinearSpring 5384 0 (vec 0.65 0 0))] ++\n      [InternalForce n (n+1) (linearSpring 5384 0) | n <- [0..62]]\n```", "```\nstringUpdate :: TimeStep\n             -> MultiParticleState  -- old state\n             -> MultiParticleState  -- new state\nstringUpdate dt = updateMPS (rungeKutta4 dt) forcesString\n```", "```\nstringInitialOvertone :: Int -> MultiParticleState\nstringInitialOvertone n\n    = MPS [defaultParticleState\n           { mass     = 0.8293e-3 * 0.65 / 64\n           , posVec   = x *^ iHat ^+^ y *^ jHat\n           , velocity = zeroV\n           } | x <- [0.01, 0.02 .. 0.64],\n           let y = 0.005 * sin (fromIntegral n * pi * x / 0.65)]\n```", "```\nstringInitialPluck :: MultiParticleState\nstringInitialPluck = MPS [defaultParticleState\n             { mass     = 0.8293e-3 * 0.65 / 64\n             , posVec   = x *^ iHat ^+^ y *^ jHat\n             , velocity = zeroV\n             } | x <- [0.01, 0.02 .. 0.64], let y = pluckEq x]\n    where\n      pluckEq :: R -> R\n      pluckEq x\n          | x <= 0.51  = 0.005 / (0.51 - 0.00) * (x - 0.00)\n          | otherwise  = 0.005 / (0.51 - 0.65) * (x - 0.65)\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport SimpleVec ( zeroV, iHat, (*^), xComp, yComp )\nimport Mechanics3D ( ParticleState(..), simulateGloss )\nimport MultipleObjects ( MultiParticleState(..) )\nimport MOExamples\nimport Graphics.Gloss ( Picture(..), scale, blue )\n\nstringPicture :: MultiParticleState -> Picture\nstringPicture (MPS sts)\n    = let rs = [zeroV] ++ [posVec st | st <- sts] ++ [0.65 *^ iHat]\n          xy r = (realToFrac $ xComp r, realToFrac $ yComp r)\n          xys = map xy rs\n          ppm = 400  -- pixels per meter\n      in scale ppm (20*ppm) $ Color blue $ Line xys\n\nmain :: IO ()\nmain = let initialState = stringInitialOvertone 3\n       in simulateGloss 0.001 40 initialState stringPicture stringUpdate\n```", "```\nmpsPos (iterate (stringUpdate 100e-6) (stringInitialOvertone 1) !! 10)\nmpsPos (iterate (stringUpdate 100e-6) (stringInitialOvertone 1) !! 11)\nmpsPos (iterate (stringUpdate 100e-6) (stringInitialOvertone 1) !! 12)\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport SimpleVec ( R, zeroV, iHat, (*^), xComp, yComp )\nimport Mechanics3D ( ParticleState(..) )\nimport MultipleObjects ( MultiParticleState(..) )\nimport MOExamples\nimport Graphics.Gnuplot.Simple\n\nmakePNG :: (Int,MultiParticleState) -> IO ()\nmakePNG (n,MPS sts)\n    = let rs = [zeroV] ++ [posVec st | st <- sts] ++ [0.65 *^ iHat]\n          xy r = (xComp r, yComp r)\n          xys :: [(R,R)]\n          xys = map xy rs\n          threeDigitString = reverse $ take 3 $ reverse (\"00\" ++ show n)\n          pngFilePath = \"GnuplotWave\" ++ threeDigitString ++ \".png\"\n      in plotPath [Title \"Wave\"\n                  ,XLabel \"Position (m)\"\n                  ,YLabel \"Displacement (m)\"\n                  ,XRange (0,0.65)\n                  ,YRange (-0.01,0.01)\n                  ,PNG pngFilePath\n                  ,Key Nothing\n                  ] xys\n\nmain :: IO ()\nmain = sequence_ $ map makePNG $ zip [0..999] $\n       iterate (stringUpdate 25e-6) (stringInitialOvertone 3)\n```", "```\niterate (stringUpdate 25e-6) (stringInitialOvertone 3)\n```", "```\n*MOExamples>  :t sequence_\nsequence_ :: (Foldable t, Monad m) => t (m a) -> m ()\n```", "```\nsequence_ :: [IO ()] -> IO ()\n```", "```\n$ ffmpeg -framerate 40 -i GnuplotWave%03d.png GnuplotWave.mp4\n```", "```\n(zipWith place sts (cycle [G.blue, G.red]))\n```", "```\nmpsPos :: MultiParticleState -> IO ()\nmpsPos = undefined\n\nmpsVel :: MultiParticleState -> IO ()\nmpsVel = undefined\n```", "```\nanimateGloss :: HasTime s => R  -- time-scale factor\n             -> (s -> G.Picture)\n             -> [s]\n             -> IO ()\nanimateGloss tsFactor displayFunc mpsts\n    = let dtp = timeOf (mpsts !! 1) - timeOf (mpsts !! 0)\n          n tp = round (tp / dtp)\n          picFromAnimTime :: Float -> G.Picture\n          picFromAnimTime ta = displayFunc (mpsts !! n (tsFactor * realToFrac ta))\n          displayMode = G.InWindow \"My Window\" (1000, 700) (10, 10)\n      in G.animate displayMode G.black picFromAnimTime\n\nanimateVis :: HasTime s => R  -- time-scale factor\n           -> (s -> V.VisObject R)\n           -> [s]\n           -> IO ()\nanimateVis tsFactor displayFunc mpsts\n    = let dtp = timeOf (mpsts !! 1) - timeOf (mpsts !! 0)\n          n tp = round (tp / dtp)\n          picFromAnimTime :: Float -> V.VisObject R\n          picFromAnimTime ta = displayFunc (mpsts !! n (tsFactor * realToFrac ta))\n      in V.animate V.defaultOpts (orient . picFromAnimTime)\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport MultipleObjects ( eulerCromerMPS )\nimport MOExamples\n    ( animateGloss, billiardPicture, billiardStates )\n\nmain :: IO ()\nmain = animateGloss 1 billiardPicture (billiardStates eulerCromerMPS 30 0.01)\n```", "```\ndissipation :: R  -- damping constant\n            -> R  -- threshold center separation\n            -> TwoBodyForce\ndissipation b re st1 st2\n    = let r1 = posVec st1\n          r2 = posVec st2\n          v1 = velocity st1\n          v2 = velocity st2\n          r21 = r2 ^-^ r1\n          v21 = v2 ^-^ v1\n      in if magnitude r21 >= re\n         then zeroV\n         else (-b) *^ v21\n```"]