- en: '**12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: INSTRUCTION DETAILS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg255_Image_259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapters 2](ch02.xhtml) and [3](ch03.xhtml), you learned how bit patterns
    can be used to represent data. Then, in [Chapters 4](ch04.xhtml) to [8](ch08.xhtml),
    you learned how bits can be implemented in hardware and used to perform computations.
    In this chapter, I’ll explain some of the details of how instructions are encoded
    in bit patterns that specify the operations and the locations of the data they
    operate on.
  prefs: []
  type: TYPE_NORMAL
- en: The primary goal of this chapter is to give you an overall view of how computer
    instructions know where the data they operate on is located. The details of the
    machine code for each instruction are not the sort of thing that people memorize—you’ll
    need to consult the manual for those—but being able to interpret them has helped
    me to better understand and debug many of my programs during my career.
  prefs: []
  type: TYPE_NORMAL
- en: The *Arm Architecture Reference Manual for A-Profile Architecture*, available
    at *[https://developer.arm.com/documentation/ddi0487/latest](https://developer.arm.com/documentation/ddi0487/latest)*,
    gives an in-depth description of how each bit in a given instruction affects what
    the instruction does, which can be a little daunting to read. To help you learn
    how to read the details in the manual, I’ll cover several instructions here, adding
    my own explanations to the manual’s descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in [Chapter 10](ch10.xhtml), A64 instructions fall into three
    general categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load and store** These instructions are used to transfer data between memory
    and general-purpose registers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data processing** These instructions operate on data items in registers and
    constants that are encoded as part of the instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program flow control** These instructions are used to change the order of
    instruction execution from the order they are loaded into memory.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at a few examples of each type of instruction in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Looking at Machine Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *assembly listing* is a specific type of file generated by the assembler
    from assembly language source code that shows the machine code corresponding to
    each assembly language instruction. I’ll use the program in [Listing 12-1](ch12.xhtml#ch12list1)
    to show the machine language for several instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '*add_consts.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-1: A program to add some constants*'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is a silly program—all the data is constant—but it does allow
    me to illustrate a few points. For example, I’ve used two different instructions,
    `mov` ❶ and `orr` ❷, to copy the value in `w20` into `w2`. This will allow us
    to compare the machine code for two ways of accomplishing the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: We can produce an assembly listing by passing the `-al` option to the assembler.
    This causes the assembly listing to be written to standard output, which defaults
    to the screen. We can capture this with the redirection operator, `>`. For example,
    I used the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: to produce the assembly listing file shown in [Listing 12-2](ch12.xhtml#ch12list2).
  prefs: []
  type: TYPE_NORMAL
- en: '*add_consts.lst*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-2: The assembly listing file for the program in [Listing 12-1](ch12.xhtml#ch12list1)*'
  prefs: []
  type: TYPE_NORMAL
- en: The first column in the assembly listing file shows the corresponding line number
    in the source file. The next column shows the 16-bit relative address from the
    beginning of each section, in hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: The third column gives the machine code for the instruction or data, also in
    hexadecimal. All A64 instructions are 32 bits wide. The assembly listing shows
    the 4 bytes in each instruction in the order that they’ll be stored in memory.
    Since ours is a little-endian environment, the 4 bytes appear backward in the
    assembly listing. For example, the first instruction in this program ❶ is the
    32-bit word `0xa9827bfd`. (We’ll look at the other instructions that I’ve called
    out in this listing a bit later, in “Moving Data from Register to Register” on
    [page 232](ch12.xhtml#ch12lev2sec1).)
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, the names for the bit fields in my descriptions are different
    from those in the manual. Note that some of the names I use might have a different
    meaning in other places in the manual. Here are the names I’m using:'
  prefs: []
  type: TYPE_NORMAL
- en: sf The size flag. The operands are 32-bit values when it’s `0` or 64-bit when
    it’s `1`.
  prefs: []
  type: TYPE_NORMAL
- en: imm A constant integer used by the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: hw The number of halfwords (16 bits) to shift a 16-bit `imm` value left before
    loading it into a register.
  prefs: []
  type: TYPE_NORMAL
- en: b_offset The number of bytes from the current instruction to an address.
  prefs: []
  type: TYPE_NORMAL
- en: b_offset:hi The high-order part of a `b_offset`.
  prefs: []
  type: TYPE_NORMAL
- en: b:lo The low-order part of a `b_offset`.
  prefs: []
  type: TYPE_NORMAL
- en: w_offset The number of 32-bit words from the current instruction to an address.
  prefs: []
  type: TYPE_NORMAL
- en: rb The number of a register holding a 64-bit base address for this instruction.
  prefs: []
  type: TYPE_NORMAL
- en: rd The number of the destination register, which will hold the result of the
    instruction’s operation. Where there are two destination registers, I use `rd1`
    and `rd2`.
  prefs: []
  type: TYPE_NORMAL
- en: rs The number of a source register, which holds a value used in the instruction’s
    operation. Where there are two source registers, I use `rs1` and `rs2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'pi Tells the instruction how to treat the base register: `01` for post-index,
    `11` for pre-index, or `10` for don’t change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'sh Tells the instruction whether to shift an operand before using it in the
    operation: yes if it’s `1`, and no if it’s `0`. For a 2-bit `sh` field, `00` is
    `lsl`, `01` is `lsr`, `10` is `asr`, and `11` is `ror`.'
  prefs: []
  type: TYPE_NORMAL
- en: shft_amnt The number of bits to shift an operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bits 28 to 25 show which group the instruction is in: load and store (`0x4,
    0x6, 0xc, 0xe`), data processing (`0x5, 0x7, 0x8, 0x9, 0xd, 0xf`), or program
    flow control (`0xa, 0xb`). Many instructions have variants. The assembler will
    pick the variant appropriate for the operands we use. I’ll start by showing you
    the load and store instructions in [Listing 12-1](ch12.xhtml#ch12list1).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encoding Load and Store Instructions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 12-1](ch12.xhtml#ch12fig1) shows the basic load instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg259_Image_260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: A basic load instruction: `Idr w3, [sp, z]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-2](ch12.xhtml#ch12fig2) shows the basic store instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg259_Image_261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: A basic store instruction:* str w22, [sp, z]'
  prefs: []
  type: TYPE_NORMAL
- en: In both instructions, bit 24 is `1`, which shows us that the assembler has used
    the immediate, unsigned offset variant. Other variants have `0` in bit 24\. Both
    instructions use `sp` as the base address register, giving `11111` in the `rb`
    field, and in both instructions the offset from the base register is the number
    of 32-bit words. The offset in [Listing 12-1](ch12.xhtml#ch12list1) is `z`, which
    equates to 28\. We use the number of bytes in assembly language, but the assembler
    divides this value by 4 to encode the number of words in the machine code for
    the instruction, giving 7 in the `w_offset` field.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 12-1](ch12.xhtml#ch12fig1), the `0` in the `sf` field together with
    `00011` in the `rd` field tells the CPU to use `w3` for the destination register,
    and the `0` in the `sf` field together with `10110` in the `rs` field in [Figure
    12-2](ch12.xhtml#ch12fig2) tells the CPU to use `w22` for the source register.
  prefs: []
  type: TYPE_NORMAL
- en: The stack frame is created with the `stp` instruction, shown in [Figure 12-3](ch12.xhtml#ch12fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg260_Image_262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The instruction to push* fp *and* sp *onto the stack:* stp fp,
    lr, [sp, FRAME]!'
  prefs: []
  type: TYPE_NORMAL
- en: It is deleted with the `ldp` instruction, shown in [Figure 12-4](ch12.xhtml#ch12fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg260_Image_263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: The instruction to pop* fp *and* sp *from the stack:* ldp fp,
    lr, [sp], FRAME'
  prefs: []
  type: TYPE_NORMAL
- en: Both of these instructions use `sp` for their base register. In [Figure 12-3](ch12.xhtml#ch12fig3),
    the `11` in the `pi` field tells the CPU to subtract the `w_offset`, 4 words (32
    bytes), from `sp` before (pre-index) storing the contents of registers `x29` and
    `x30` at that address. The CPU stores the entire 64 bits of each register because
    `sf` is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The `pi` field is `01` in [Figure 12-4](ch12.xhtml#ch12fig4), so 32 is added
    to `sp` after (post-index) the two 64-bit values are loaded into registers `x29`
    and `x30`. The CPU loads 64 bits from memory into each register because `sf` is
    `1`. Next, I’ll explain the data processing instructions in [Listing 12-2](ch12.xhtml#ch12list2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Encoding Data Processing Instructions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data processing instructions operate on values that are already in the CPU,
    either in registers or as part of the instruction itself. They are used to move
    data or perform arithmetic and logic operations on data. In some cases, these
    operations overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '***Moving Data from Register to Register***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start by looking at the instruction that moves the value from the `sp`
    register to the `fp` register, shown in [Figure 12-5](ch12.xhtml#ch12fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg260_Image_264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-5: A basic register-to-register move instruction:* mov fp, sp'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at an instruction that uses a logical operation to effectively
    move a value from one register to another, shown in [Figure 12-6](ch12.xhtml#ch12fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg261_Image_265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: A logical operation to move data:* orr w2, wzr, w20'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `rs` field in [Figure 12-5](ch12.xhtml#ch12fig5) is the same
    as the `rs1` field in [Figure 12-6](ch12.xhtml#ch12fig6), but in the first case
    it’s the code for the stack pointer and in the second it’s the zero register.
    This shows that the way register 31 is treated, as a stack pointer or zero register,
    depends on the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: You’re probably wondering why I’m showing an `orr` instruction instead of a
    `mov` instruction in [Figure 12-6](ch12.xhtml#ch12fig6). As you might guess from
    the name, the `orr` instruction performs a bitwise OR operation between the values
    in the two source registers, `rs1` and `rs2`, and stores the result in the destination
    register, `rd`. Since `rs1` is the zero register in our instruction, this operation
    simply moves the value in `rs2` to `rd`, which is equivalent to `mov w2, w20`
    here. I’ll describe the `orr` instruction in more detail when we look at logic
    operators in [Chapter 16](ch16.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The `mov w2, w20` ❷ and `orr w2, wzr, w20` ❸ instructions in [Listing 12-2](ch12.xhtml#ch12list2)
    (on [page 229](ch12.xhtml#page_229)) use exactly the same machine code. The two
    names for the same instruction are said to be *aliases*. For the instructions
    that have aliases, you should use the name that better expresses your intent in
    the algorithm. In our example program, `mov w2, w20` is a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: '***Moving a Constant to a Register***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 12-7](ch12.xhtml#ch12fig7) shows the instruction for moving a positive
    or unsigned constant into a register.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg261_Image_266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-7: The instruction for moving a positive constant:* mov w19, 123'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-8](ch12.xhtml#ch12fig8) shows the instruction for moving a negative
    constant into a register.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg261_Image_267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-8: The instruction for moving a negative constant:* mov w20, -123'
  prefs: []
  type: TYPE_NORMAL
- en: Although both instructions use the `mov` mnemonic, in [Figure 12-7](ch12.xhtml#ch12fig7)
    bit 30 is `1`, and in [Figure 12-8](ch12.xhtml#ch12fig8) it’s `0`. The difference
    is that the first instruction is moving a positive number and the second a negative
    number. When the constant in a `mov` instruction is negative, the assembler uses
    the `movn` (move with NOT) instruction from [Chapter 10](ch10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 12-7](ch12.xhtml#ch12fig7), the constant +123 is encoded as `0x007b`,
    as we would expect, but in [Figure 12-8](ch12.xhtml#ch12fig8) we see that –123
    is encoded as `0x007a`, which is +122 in decimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned in [Chapter 3](ch03.xhtml) that in the two’s complement notation,
    the negative of a number can be computed by taking the complement of the number
    and adding 1\. In other words, –123 is the complement of +122 in two’s complement
    notation. The `mov` instruction in [Figure 12-8](ch12.xhtml#ch12fig8) computes
    the NOT of the value in the `imm` field and sign-extends it to the size of the
    destination register before storing the result there. So, this instruction uses
    the `0x007a` to store `0xffffff85` in the `w20` register, as shown in the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In both instructions, the constant has to fit within the 16-bit immediate value.
    The range for positive numbers is 0 to +65,535, and for negative numbers it’s
    –1 to –65,536.
  prefs: []
  type: TYPE_NORMAL
- en: '***Performing Arithmetic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at the instruction for adding a constant to a value in a register,
    shown in [Figure 12-9](ch12.xhtml#ch12fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg262_Image_268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-9: The instruction for adding a constant to a value:* add w22, w21,
    456'
  prefs: []
  type: TYPE_NORMAL
- en: This instruction adds the 12-bit `imm` value to the value in `rs` and stores
    the result in the `rd` register. When the shift bit, `sh`, is `1`, the `imm` value
    is shifted left 12 bits before performing the addition. The shift option allows
    us to add a 24-bit constant in two `add` operations. The first will add the low-order
    12 bits and the second the high-order 12 bits.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing [Figure 12-9](ch12.xhtml#ch12fig9) with [Figure 12-5](ch12.xhtml#ch12fig5),
    you can see another example of an alias. If `imm` is 0 and one of `rd` or `rs`
    is 31, this `add` instruction is the same as a `mov` to or from the `sp` register.
  prefs: []
  type: TYPE_NORMAL
- en: '***Computing Addresses***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, let’s look at the instruction that loads the address of the `printf` format
    string into the `x0` register, as shown in [Figure 12-10](ch12.xhtml#ch12fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg263_Image_269.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-10: The instruction to load an address:* adr x0, format'
  prefs: []
  type: TYPE_NORMAL
- en: You learned in [Chapter 11](ch11.xhtml) that this instruction computes the address
    of `format` by adding the offset from this instruction to `format` and the value
    in `pc`, then loads the result into `x0`. The `b_offset` field in this instruction
    shows that all 21 bits are `0` (don’t forget to include the two low-order bits
    in the `b:lo` field). This seems to indicate that the `format` text string is
    located at the same place as this instruction, which is clearly not possible.
    This text string is in the `.rodata` section. The linker will decide where to
    locate that section and fill in the `b_offset:hi` and `b:lo` fields during the
    linking process.
  prefs: []
  type: TYPE_NORMAL
- en: '***Looking at the Details of an Executable File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use a program called `objdump` to look at the code in an executable
    program file. For example, to dump the contents of the *add_consts* file, you
    can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `-D` option dumps all the sections in the file, assumes that they all contain
    instructions, and disassembles them as such. I’m showing only the two sections
    that interest us here.
  prefs: []
  type: TYPE_NORMAL
- en: The first column shows the relative address where each instruction will be loaded
    into memory. The operating system will decide the base loading address when loading
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: The second column shows the machine code of the instruction at that address.
    Note that `objdump` displays the machine code in 32-bit instruction order, not
    in the little-endian byte order we see in assembly listing files.
  prefs: []
  type: TYPE_NORMAL
- en: The linker has filled in the offset to the `format` text string in the `adr`
    instruction ❶. Per [Figure 12-10](ch12.xhtml#ch12fig10), the offset is `000000000000010110100`.
    Adding this to the relative address of the instruction gives `0x7a4` + `0x0b4`
    = `0x858`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The machine code at relative address `0x858` begins with the bytes `0x25`,
    `0x69`, `0x20`, `0x2b`, which are the code points for the first four characters
    in the format text string: `%`, `i`, space, and `+`. The assembly listing file,
    shown in [Listing 12-2](ch12.xhtml#ch12list2), displays the bytes in the proper
    order. Next, I’ll show you the two instructions in this program that cause program
    flow to go someplace other than the next instruction in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encoding Program Flow Control Instructions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ll start with the instruction used to call the `printf` function, shown in
    [Figure 12-11](ch12.xhtml#ch12fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg264_Image_270.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-11: The function call instruction:* bl printf'
  prefs: []
  type: TYPE_NORMAL
- en: The `bl` instruction copies the address in `pc`, plus 4, to the link register,
    `x30`. It then shifts `w_offset` 2 bits to the left to give a byte offset, sign-extends
    it to 64 bits, and adds the result to `pc`. The result is to save the address
    of the instruction immediately after the `bl` instruction in memory to the link
    register and then transfer program flow to `w_offset` words from the address of
    the `bl` instruction. Since `w_offset` is 26 bits wide, the offset in bytes is
    limited to 28 bits, giving a transfer limit of ±128MB away in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The last instruction we’ll look at is `ret`, shown in [Figure 12-12](ch12.xhtml#ch12fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg264_Image_271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-12: The return from function instruction:* ret'
  prefs: []
  type: TYPE_NORMAL
- en: The `ret` instruction moves the address from the register specified in the `rs`
    field to `pc`. Although I didn’t specify a register in [Listing 12-2](ch12.xhtml#ch12list2),
    the assembler uses `x30` by default. We could use another register, but that would
    be inconsistent with the published standards and likely lead to program bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 12.1     Enter the program in [Listing 12-1](ch12.xhtml#ch12list1) and use the
    debugger to determine when the `adr` instruction knows the address of the format
    text string.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2     Experiment with the constants in the program in [Listing 12-1](ch12.xhtml#ch12list1)
    to find the magnitude limits of the constants.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3     Modify the program in [Listing 12-1](ch12.xhtml#ch12list1) to use 64-bit
    integers (`long int` in C). Does this allow you to use larger constants?
  prefs: []
  type: TYPE_NORMAL
- en: 12.4     Write a program in C that does the same thing as our assembly language
    program in [Listing 12-1](ch12.xhtml#ch12list1). Does your C program allow you
    to use larger constants? If so, why?
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what machine code looks like, we’ll look at how an assembler
    program translates assembly language into machine code. The general algorithm
    is similar for linking functions together; I’ll cover that too.
  prefs: []
  type: TYPE_NORMAL
- en: '**Translating Assembly into Machine Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The presentation in this section is meant to be an overview, so it ignores most
    of the details. My intention is to give you only a rough idea of how an assembler
    translates the source code into machine language and how a linker connects the
    different modules that make up an entire program.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Assembler***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest approach for an assembler to translate assembly language into machine
    code would be to go through the source one line at a time, translating each one
    in turn. This would work fine, except for situations where an instruction refers
    to a label on a line after the current line.
  prefs: []
  type: TYPE_NORMAL
- en: To see how the assembler deals with these forward references, I’ll make a forward
    reference to [Listing 13-11](ch13.xhtml#ch13list11) in [Chapter 13](ch13.xhtml),
    where we’ll be making use of them. [Listing 12-3](ch12.xhtml#ch12list3) shows
    a portion of the assembly listing file from that program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-3: Part of the listing file for the program in [Listing 13-11](ch13.xhtml#ch13list11)
    from [Chapter 13](ch13.xhtml)*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll cover the details in [Chapter 13](ch13.xhtml), but this section of code
    compares the values in registers `w0` and `w1`. If the value in `w1` is higher,
    the `b.hi` instruction causes the program flow to branch to the address labeled
    `tails`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-13](ch12.xhtml#ch12fig13) shows the machine code that the assembler
    produced for the `b.hi` instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg266_Image_272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-13: A conditional branch:* b.hi tails'
  prefs: []
  type: TYPE_NORMAL
- en: The `tails` label is at relative location `0x38`, which is `0x10` bytes beyond
    the `b.hi` instruction at `0x28`. In [Figure 12-13](ch12.xhtml#ch12fig13), the
    `w_offset` is `0x00004`, or `0x10` bytes. The question is how the assembler knew
    the location of the forward reference to the `tails` label.
  prefs: []
  type: TYPE_NORMAL
- en: A common way to deal with forward references is to use a *two-pass assembler*,
    which scans the program twice. During the first pass, the assembler creates a
    *local symbol table*, associating each symbol with a numerical value. Those symbols
    defined with a `.equ` directive are entered directly in the table.
  prefs: []
  type: TYPE_NORMAL
- en: For the labeled locations in the code, the assembler needs to determine the
    location of each label relative to the beginning of the module being assembled
    and then enter that value and the label in the table. A separate local symbol
    table is created for each `.text` and `.data` segment in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the general algorithm for the first pass of a two-pass assembler, which
    generates a local symbol table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once the local symbol table is created, the assembler does a second pass through
    the source code file. It uses a built-in *opcode table* to determine the machine
    code, and when a symbol is used in an instruction, it looks up the value of the
    symbol in the local symbol table. If it does not find the symbol in the local
    symbol table, it leaves space in the instruction for a number and records the
    symbol and its location in the object file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general algorithm looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As an alternative, we could create a *one-pass assembler*. It would need to
    maintain a list of the locations of each forward reference and, when the label
    is found, use the table to go back and fill in the appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, this is a highly simplified overview of the assembly process that is
    intended only to show you the general idea of how an assembler works. [Chapter
    7](ch07.xhtml) in Andrew S. Tanenbaum and Todd Austin’s *Structured Computer Organization*,
    6th edition (Pearson, 2012), has a section that provides more details about the
    assembly process. There is a thorough discussion of the design of assembler programs
    in [Chapter 2](ch02.xhtml) of Leland Beck’s *System Software: An Introduction
    to Systems Programming*, 3rd edition (Pearson, 1997).'
  prefs: []
  type: TYPE_NORMAL
- en: Most functions will have function calls, which are references to labels in `.text`
    segments defined in other files that cannot be resolved by the assembler. The
    same is true of any labels in `.data` segments, even if they’re defined in the
    same source code file. I’ll show you the program that resolves these references
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Linker***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The job of the linker is to figure out the relative locations of the labels
    in a program so it can enter the offset to each label wherever there is a reference
    to the label. A linker works in much the same way as an assembler, except the
    basic unit is a block of machine code instead of a line of assembly language.
    A typical program comprises many object files, each of which often has more than
    one `.text` segment and may have `.data` segments, all of which must be linked
    together. As with an assembler, two passes can be used to resolve forward references.
  prefs: []
  type: TYPE_NORMAL
- en: An object file created by the assembler includes the size of each segment in
    the file, together with a list of all the global symbols and where they are used
    in the segment. During the first pass, the linker reads each object file and creates
    a *global symbol table* that contains the relative location of each global symbol
    from the beginning of the program. In the second pass, the linker creates an executable
    file that includes all the machine code from the object files with the relative
    location values from the global symbol table plugged into the locations where
    they are referenced.
  prefs: []
  type: TYPE_NORMAL
- en: This process resolves all the references to names defined in the modules that
    comprise the program, but it will leave unresolved all references to externally
    defined names, such as function or variable names that are defined in the C standard
    library. The linker enters these unresolved references into the *global offset
    table (GOT)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the external reference is a function call, the linker also enters this information
    into the *procedure linkage table (PLT)*, along with the location in the machine
    code where the reference is made. You can see how the linker has done this by
    looking at how we wrote a call to a C standard library function in [Listing 12-1](ch12.xhtml#ch12list1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `objdump` program to look at the contents of the executable file
    for this program, we see what the linker has added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From the encoding of the `bl` instruction in [Figure 12-11](ch12.xhtml#ch12fig11),
    we see that the `w_offset` is the 26-bit value `0x3ffffab`. There are 4 bytes
    in a word, so this is equal to the 28-bit byte offset of `0xffffeac`. Adding the
    byte offset to the relative address of the instruction gives `0x00007a4` + `0xffffeac`
    = `0x0000650`. (Don’t forget that these are signed integers, so the carry from
    this addition is irrelevant.) This is the offset from this `bl` instruction to
    where the link to `printf` is located in the PLT.
  prefs: []
  type: TYPE_NORMAL
- en: When the program runs, the operating system also loads the GOT and the PLT for
    the program. During execution, if the program accesses an external variable, the
    operating system loads the library module where the variable is defined and enters
    its relative address in the GOT. When the program calls one of the functions in
    the PLT, if the function has not already been loaded, the operating system loads
    it, inserts its address into the program’s GOT, and adjusts the corresponding
    entry in the PLT accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: I want to reemphasize that, as with the previous discussion of assemblers, this
    is only a rough overview of how linkers work. If you would like to learn more
    about linkers, I recommend John R. Levine’s *Linkers & Loaders* (Morgan Kaufmann,
    1999).
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Machine code** The instruction bit patterns that control the CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembly listing** The machine code corresponding to each instruction in
    a program, optionally generated by the assembler.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registers** The number of the register is encoded in 5 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Register size** A single bit encodes whether the full 64 bits or the low-order
    32 bits is used.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Immediate data** A constant encoded within the instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address offset** The distance from the referencing instruction to a memory
    address, which can be encoded within the referencing instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aliases** The assembler can have more than one name for some instructions,
    to better show the intent of using the instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembler** A program that translates assembly language to machine code and
    creates a global symbol table.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linker** A program that resolves cross-references between the segments in
    the program and creates a procedure linkage table that is used by the operating
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, all our programs have used sequential program flow and called subfunctions.
    In the next chapter, we’ll return to programming and you’ll learn about the other
    two necessary program flow constructs: repetition and two-way branching.'
  prefs: []
  type: TYPE_NORMAL
