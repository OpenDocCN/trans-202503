- en: '**LEDs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LED Light Bar**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll flash a row of LEDs back and forth in sequence, sort of
    like KITT from the 1980s TV series *Knight Rider*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0016-01.jpg)![Image](../images/p0017-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**8 LEDs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**8 220-ohm resistors**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An LED emits light when a small current is passed through it. LEDs are *polarized*,
    which means one side is positive and one side is negative. This is because the
    LED will work only with current flowing in one direction, from positive to negative.
    The longer leg of the LED is positive and must connect to a positive power connection.
    The Arduino sketch controls the sequence of flashes.
  prefs: []
  type: TYPE_NORMAL
- en: LEDs are delicate parts, requiring only a small amount of voltage to light up—smaller
    than the voltage the Arduino provides. To prevent the LEDs from being overloaded
    with voltage and burning out, we use *resistors*, which limit the amount of voltage
    passing through them to the LED on the other end.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the color of your LEDs and use this light bar to decorate a car,
    scooter, bike, picture frame, subwoofer, or almost anything else you choose. You
    can add up to 10 LEDs on the Uno before you run out of pins.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Insert the LEDs into the breadboard with their shorter, negative legs in the
    GND rail at the top of your breadboard. Then connect this rail to GND on the Arduino,
    as shown in [Figure 1-1](ch01.xhtml#ch1fig1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 1-1:** The LEDs flash back and forth in sequence. The short leg of
    the LED is in the GND rail of the breadboard, and the long leg is connected to
    the Arduino via a resistor.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f1-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Connect the LEDs in sequence to Arduino digital pins 2–9, as shown in the following
    circuit diagram. Place a 220-ohm resistor between each LED and digital pin, ensuring
    that the resistors bridge the center divide in the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LEDS** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Positive legs | Pins 2–9 via resistor |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Negative legs | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Check your setup against [Figure 1-2](ch01.xhtml#ch1fig2), and then upload the
    code in “[The Sketch](ch01.xhtml#ch00lev1sec5)” below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 1-2:** The circuit diagram for the LED light bar'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f1-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch sets the pins connected to the LEDs as outputs, and then defines
    a function to turn all the LEDs off at the same time. This function is called
    in the loop cycle to turn the LEDs off, and then the LEDs are turned on one at
    a time—with a 200-millisecond delay between each one—to create a sweeping effect.
    Another loop sends the sequence back the other way.
  prefs: []
  type: TYPE_NORMAL
- en: // Used with kind permission from
  prefs: []
  type: TYPE_NORMAL
- en: // Warwick A Smith, startingelectronics.com
  prefs: []
  type: TYPE_NORMAL
- en: // Knight Rider display on eight LEDs
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 2; i < 10; i++) { // Choose pins 2-9
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(i, OUTPUT); // Set the pins as outputs
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Define function to turn off all LEDs at the same time
  prefs: []
  type: TYPE_NORMAL
- en: void allLEDsOff(void) {
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 2; i < 10; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(i, LOW);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Switch on LEDs in sequence from left to right
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 2; i < 9; i++) { // Run loop once for each LED
  prefs: []
  type: TYPE_NORMAL
- en: allLEDsOff(); // Turn off all LEDs
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(i, HIGH); // Turn on current LED
  prefs: []
  type: TYPE_NORMAL
- en: delay(200); // Delay of 200 ms,
  prefs: []
  type: TYPE_NORMAL
- en: // then repeat loop to move on to next LED
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 9; i > 2; i--) { // Light LEDs from right to left
  prefs: []
  type: TYPE_NORMAL
- en: allLEDsOff();
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(i, HIGH);
  prefs: []
  type: TYPE_NORMAL
- en: delay(200);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but some or all of the LEDs do not light up as expected.*'
  prefs: []
  type: TYPE_NORMAL
- en: • If none of the LEDs light, make sure you’ve connected the GND wire from the
    Arduino to the correct breadboard power rail and that the Arduino has power connected.
  prefs: []
  type: TYPE_NORMAL
- en: • If only some LEDs light, check that the LEDs are inserted the correct way,
    with the longer wire to positive power and the shorter wire to GND. Because LEDs
    are polarized, they must be connected the correct way. Check that the resistors
    are inserted fully and lined up in the same row as the corresponding LED leg.
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure the LEDs are connected to the Arduino pins defined in “[The Sketch](ch01.xhtml#ch00lev1sec5)”
    on [page 19](ch01.xhtml#page_19). The first part of the sketch defines pins 2–9
    as outputs, so these are the pins you should use.
  prefs: []
  type: TYPE_NORMAL
- en: • If an LED still fails to light, it may have burnt out or be faulty. An easy
    way to check is to swap the LED with another in the sequence and see if that resolves
    the issue. If you find that the LED works in another position, it means the resistor
    is either faulty or not inserted fully. Depending on the outcome, replace the
    LED or resistor with a functioning component.
  prefs: []
  type: TYPE_NORMAL
- en: '**2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Light-Activated Night-Light**
  prefs: []
  type: TYPE_NORMAL
- en: 'This project is a simple test of a photoresistor’s functionality: we’ll create
    a night light that gets brighter depending on the amount of light detected.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0021-01.jpg)![Image](../images/p0022-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Photoresistor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**10k-ohm resistor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *photoresistor* is a variable resistor that reacts to light; the less light
    that shines on it, the higher the resistance it provides. This resistance value
    varies the voltage that’s sent to the input pin of the Arduino, which in turn
    sends that voltage value to the output pin as the power level of the LED, so in
    low light the LED will be bright. There are different styles of photoresistors,
    but they usually have a small, clear, oval head with wavy lines (see [Figure 2-1](ch02.xhtml#ch2fig1)).
    Photoresistors do not have polarity, so it doesn’t matter which way you connect
    the legs.
  prefs: []
  type: TYPE_NORMAL
- en: The principles at work here are similar to those of a child’s night-light. You
    can use a photoresistor to control more than just LEDs, as we’ll see in upcoming
    chapters. Since we only have two power and GND connections, we won’t be using
    the breadboard power rails here.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 2-1:** A photoresistor'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f2-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Place your photoresistor in the breadboard, connecting one leg to GND directly
    on the Arduino and the other leg to Arduino A0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one leg of the 10k-ohm resistor to +5V, and connect the other leg to
    the A0 photoresistor leg, as shown in the circuit diagram in [Figure 2-2](ch02.xhtml#ch2fig2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 2-2:** The circuit diagram for the light-activated LED'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f2-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Insert the longer, positive leg of the LED directly into pin 13 on the Arduino
    and the shorter, negative leg directly into Arduino GND. We would normally use
    a resistor to limit the current to an LED, but we don’t need one here because
    pin 13 on the Arduino has one built in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the code in “[The Sketch](ch02.xhtml#ch00lev1sec9)” below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch first connects the photoresistor to Arduino pin A0 as our `INPUT`
    and the LED to pin 13 as our `OUTPUT`. We run the serial communication with `Serial.begin(9600)`,
    which (when your Arduino is connected to your PC) will send information to the
    Arduino’s Serial Monitor. This means the resistance value of the photoresistor
    will be displayed in the Serial Monitor on your computer, as shown in [Figure
    2-3](ch02.xhtml#ch2fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 2-3:** The Serial Monitor will display the resistance of the photoresistor.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f2-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The loop reads the photoresistor’s analog value and sends it to the LED as a
    voltage value. The A0 pin can read 1,024 values, which means there are 1,024 possible
    brightness levels for the LED. Minuscule changes between this many levels aren’t
    very visible, so we divide that number by 4 to scale down to only 256 values,
    making it easier to detect when there is a change in voltage to the LED.
  prefs: []
  type: TYPE_NORMAL
- en: int lightPin = A0; // Pin connected to the photoresistor
  prefs: []
  type: TYPE_NORMAL
- en: int ledPin = 13; // Pin connected to the LED
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: Serial.begin(9600); // Begin serial communication
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(ledPin, OUTPUT); // Setting the LED pin as an output
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // This loop reads the analog pin value and
  prefs: []
  type: TYPE_NORMAL
- en: // sends that to the LED as an output
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: // Read the value of the photoresistor
  prefs: []
  type: TYPE_NORMAL
- en: Serial.println(analogRead(lightPin));
  prefs: []
  type: TYPE_NORMAL
- en: // Write the value to the Serial Monitor
  prefs: []
  type: TYPE_NORMAL
- en: // Send the value to the ledPin and divide by 4
  prefs: []
  type: TYPE_NORMAL
- en: analogWrite(ledPin, analogRead(lightPin) / 4);
  prefs: []
  type: TYPE_NORMAL
- en: delay(10); // Short delay before the sequence loops again
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but the LED does not light when it’s dark.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure that the LED is inserted with the long, positive leg in pin 13 and
    the short, negative leg in GND next to it.
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure the photoresistor is connected to Arduino A0 as shown in the circuit
    diagram in [Figure 2-2](ch02.xhtml#ch2fig2). Open the Serial Monitor to see if
    there’s a reading. If you’re getting a reading but the LED doesn’t light, the
    LED may be faulty, so try replacing it with another one.
  prefs: []
  type: TYPE_NORMAL
- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Seven-Segment LED Count Down Timer**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll create a simple timer that counts down from 9 to 0\. This
    can be used in any number of useful projects!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0027-01.jpg)![Image](../images/p0028-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Seven-segment, single-digit common-cathode LED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**8 220-ohm resistors**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A seven-segment LED display shows a single digit or character using LED segments.
    Each segment is an individual LED, and by controlling which segments are lit at
    any time, we can display numeric values. We’re using a single-digit display in
    this project, shown in [Figure 3-1](ch03.xhtml#ch3fig1), but there are also two-,
    three-, four-, and eight-digit variations available.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 3-1:** A seven-segment LED'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f3-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* cathode *of a device is the negative connection, usually indicated with
    a minus sign (–) and sometimes referred to as* ground *(abbreviated* GND*). It
    is connected to negative power. The* anode *of a device is the positive connection,
    usually indicated with a plus sign (+) and connected to positive power.*'
  prefs: []
  type: TYPE_NORMAL
- en: This project will create a simple timer to count down from 9 to 0\. The seven-segment
    LED has 10 pins. Seven pins control the seven LEDs that light up to form each
    digit, and the eighth pin controls the decimal point. The other two pins are the
    common-cathode (–) or common-anode (+) pins, which add power to the project. Our
    seven-segment LED is common cathode, meaning one side of each LED needs to connect
    to ground. It’s important to note that the code will work only with a common-cathode
    LED. If you have a common-anode LED you want to use, check the troubleshooting
    section at the end of this chapter before uploading the sketch. Each LED segment
    requires a resistor to limit the current; otherwise, it will burn out.
  prefs: []
  type: TYPE_NORMAL
- en: The pins are labeled with a letter, as shown in [Figure 3-2](ch03.xhtml#ch3fig2).
    The numbered pins control the segments as shown on the right. The Arduino creates
    the number by turning the LEDs off or on in different combinations.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 3-2:** A typical pin layout for a seven-segment LED'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f3-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Place the seven-segment display in a breadboard as shown in [Figure 3-3](ch03.xhtml#ch3fig3),
    making sure the pins straddle either side of the center break. Connect LED pins
    3 and 8 to the GND rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 3-3:** The seven-segment LED pins should straddle the center break
    of the breadboard.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f3-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Connect LED pins 1, 2, 4, 5, 6, 7, and 9 as shown in the following table, remembering
    to insert a 220-ohm resistor between the LED and the Arduino connection. It’s
    important that the resistors straddle the center break on the breadboard, as shown
    in the circuit diagram in [Figure 3-4](ch03.xhtml#ch3fig4).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **ARDUINO** | **SEVEN-SEGMENT LED SECTION** | **SEVEN-SEGMENT LED DISPLAY**
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 2 | A | Pin 7 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 3 | B | Pin 6 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 4 | C | Pin 4 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 5 | D | Pin 2 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 6 | E | Pin 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 7 | F | Pin 9 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 8 | G | Pin 10 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 9 | DP | Pin 5 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**FIGURE 3-4:** The circuit diagram for the seven-segment LED countdown timer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f3-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Upload the code in “[The Sketch](ch03.xhtml#ch00lev1sec13)” on [page 32](ch03.xhtml#page_32).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch starts by defining the digits 0 to 9 as combinations of off (`0`)
    and on (`1`) LEDs. The pins controlling the LEDs are set as output, so they can
    set their corresponding LEDs to either `HIGH` or `LOW`. The combination of `1`
    and `0` values lights up to form the digit.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these patterns are for common-cathode displays. For common-anode displays,
    change each `1` to `0` and each `0` to `1`. In the code, a value of `1` means
    the LED is on, and `0` means the LED is off.
  prefs: []
  type: TYPE_NORMAL
- en: // Arduino seven-segment display example software
  prefs: []
  type: TYPE_NORMAL
- en: // [http://hacktronics.com/Tutorials/arduino-and-7-segment-led.html](http://hacktronics.com/Tutorials/arduino-and-7-segment-led.html)
  prefs: []
  type: TYPE_NORMAL
- en: '// License: [http://www.opensource.org/licenses/mit-license.php](http://www.opensource.org/licenses/mit-license.php)'
  prefs: []
  type: TYPE_NORMAL
- en: // Define the LEDs to be lit to create a number
  prefs: []
  type: TYPE_NORMAL
- en: byte seven_seg_digits[10][7] = { { 1, 1, 1, 1, 1, 1, 0 }, // = 0
  prefs: []
  type: TYPE_NORMAL
- en: '{ 0, 1, 1, 0, 0, 0, 0 }, // = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 1, 1, 0, 1, 1, 0, 1 }, // = 2'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 1, 1, 1, 1, 0, 0, 1 }, // = 3'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 0, 1, 1, 0, 0, 1, 1 }, // = 4'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 1, 0, 1, 1, 0, 1, 1 }, // = 5'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 1, 0, 1, 1, 1, 1, 1 }, // = 6'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 1, 1, 1, 0, 0, 0, 0 }, // = 7'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 1, 1, 1, 1, 1, 1, 1 }, // = 8'
  prefs: []
  type: TYPE_NORMAL
- en: '{ 1, 1, 1, 0, 0, 1, 1 }  // = 9'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: // Set the seven-segment LED pins as output
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(2, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(3, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(4, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(5, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(6, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(7, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(8, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(9, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: writeDot(0); // Start with the decimal point off
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void writeDot(byte dot) {
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(9, dot);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void sevenSegWrite(byte digit) {
  prefs: []
  type: TYPE_NORMAL
- en: byte pin = 2;
  prefs: []
  type: TYPE_NORMAL
- en: for (byte segCount = 0; segCount < 7; ++segCount) {
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(pin, seven_seg_digits[digit][segCount]);
  prefs: []
  type: TYPE_NORMAL
- en: ++pin;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: for (byte count = 10; count > 0; --count) { // Start the countdown
  prefs: []
  type: TYPE_NORMAL
- en: delay(1000); // 1 second between each digit
  prefs: []
  type: TYPE_NORMAL
- en: sevenSegWrite(count - 1); // Counting down by 1
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: delay(4000);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *Some LED segments do not light up.*'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the LEDs’ wires are inserted securely and line up with the resistors
    on the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** *The display is not showing numbers correctly and looks erratic.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Recheck that your wiring matches the diagrams as shown, as it’s easy to insert
    some wires in the wrong place.
  prefs: []
  type: TYPE_NORMAL
- en: '• If all wiring is in the correct place and the timer’s still not working,
    the configuration of your seven-segment LED may be different from the one used
    here. Check the data sheet for your part and use that to direct your circuit along
    with the seven-segment pin table. You can also check which pin corresponds to
    each LED by connecting it up: attach the GND pin of the seven-segment LED to the
    negative end of a battery; connect a jumper wire to the positive end of the battery,
    via a 220-ohm resistor; and touch each pin in turn to light the segments individually.
    Note which segment each pin lights up.'
  prefs: []
  type: TYPE_NORMAL
- en: • Remember, this wiring is for a seven-segment, common-cathode LED; for common-anode
    displays, change each `1` to `0` and each `0` to `1` in the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '**4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LED Scrolling Marquee**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll use a built-in driver module to create a scrolling message
    on an 8×8 matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0034-01.jpg)![Image](../images/p0035-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Female-to-male jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**8×8 LED Maxim 7219 matrix module**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARY REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**MaxMatrix**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An LED matrix is an array of LEDs that you can control individually to make
    patterns, text, images, or whatever you can program. The 8×8 LED matrix we’ll
    use in this project comes prebuilt with a *driver module*—a board, driven by a
    Maxim 7219 chip, that lets you control the entire matrix with only five pins connected
    to your Arduino. These modules are inexpensive and can be chained together so
    you have multiple matrices running from one sketch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The matrix module has three pins: DIN, CS, and CLK, shown in [Figure 4-1](ch04.xhtml#ch4fig1).
    *DIN* stands for Data IN, *CS* for Chip Select, and *CLK* for CLocK. The remaining
    two pins connected to your Arduino power the matrix. The CLK pin senses pulses
    and controls the speed at which the Arduino and matrix communicate with each other
    in sync. The matrix uses a *serial peripheral interface (SPI)* communication protocol
    to speak with the Arduino, and the CS pin detects which SPI device is in use.
    DIN reads the data—in this case, the project’s sketch—from the Arduino.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 4-1:** The Maxim 7219 chip controls the LED matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f4-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each module has extra connections so you can add another module. By chaining
    together modules and changing the number of matrices in the code, you could scroll
    a message over a larger area.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Connect the module directly to the Arduino using the female-to-male jumper wires,
    connecting the female end to the module. As shown in the following table, connect
    VCC on the LED matrix module to +5V on the Arduino, GND to GND, DIN to Arduino
    pin 8, CS to Arduino pin 9, and CLK to Arduino pin 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LED MATRIX MODULE** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| DIN | Pin 8 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| CS | Pin 9 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| CLK | Pin 10 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Confirm that your setup matches the circuit diagram in [Figure 4-2](ch04.xhtml#ch4fig2),
    and upload the code in “[The Sketch](ch04.xhtml#ch00lev1sec17)” on [page 38](ch04.xhtml#page_38).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 4-2:** The circuit diagram for the scrolling LED marquee'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f4-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This sketch works by calling on the MaxMatrix library to control the matrix
    module. We then define the characters to display, and set the Arduino pins that
    control the matrix. Your message will be displayed in a continuous loop on the
    LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: '#include <MaxMatrix.h> // Call on the MaxMatrix library'
  prefs: []
  type: TYPE_NORMAL
- en: PROGMEM const unsigned char CH[] = {
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B00000000, B00000000, B00000000, B00000000, B00000000, // space
  prefs: []
  type: TYPE_NORMAL
- en: 1, 8, B01011111, B00000000, B00000000, B00000000, B00000000, // !
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B00000011, B00000000, B00000011, B00000000, B00000000, // "
  prefs: []
  type: TYPE_NORMAL
- en: '5, 8, B00010100, B00111110, B00010100, B00111110, B00010100, // #'
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00100100, B01101010, B00101011, B00010010, B00000000, // $
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B01100011, B00010011, B00001000, B01100100, B01100011, // %
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B00110110, B01001001, B01010110, B00100000, B01010000, // &
  prefs: []
  type: TYPE_NORMAL
- en: 1, 8, B00000011, B00000000, B00000000, B00000000, B00000000, // '
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B00011100, B00100010, B01000001, B00000000, B00000000, // (
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B01000001, B00100010, B00011100, B00000000, B00000000, // )
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B00101000, B00011000, B00001110, B00011000, B00101000, // *
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B00001000, B00001000, B00111110, B00001000, B00001000, // +
  prefs: []
  type: TYPE_NORMAL
- en: 2, 8, B10110000, B01110000, B00000000, B00000000, B00000000, // ,
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00001000, B00001000, B00001000, B00001000, B00000000, // -
  prefs: []
  type: TYPE_NORMAL
- en: 2, 8, B01100000, B01100000, B00000000, B00000000, B00000000, // .
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01100000, B00011000, B00000110, B00000001, B00000000, // /
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111110, B01000001, B01000001, B00111110, B00000000, // 0
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B01000010, B01111111, B01000000, B00000000, B00000000, // 1
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01100010, B01010001, B01001001, B01000110, B00000000, // 2
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00100010, B01000001, B01001001, B00110110, B00000000, // 3
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00011000, B00010100, B00010010, B01111111, B00000000, // 4
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00100111, B01000101, B01000101, B00111001, B00000000, // 5
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111110, B01001001, B01001001, B00110000, B00000000, // 6
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01100001, B00010001, B00001001, B00000111, B00000000, // 7
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00110110, B01001001, B01001001, B00110110, B00000000, // 8
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00000110, B01001001, B01001001, B00111110, B00000000, // 9
  prefs: []
  type: TYPE_NORMAL
- en: '2, 8, B01010000, B00000000, B00000000, B00000000, B00000000, // :'
  prefs: []
  type: TYPE_NORMAL
- en: 2, 8, B10000000, B01010000, B00000000, B00000000, B00000000, // ;
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B00010000, B00101000, B01000100, B00000000, B00000000, // <
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B00010100, B00010100, B00010100, B00000000, B00000000, // =
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B01000100, B00101000, B00010000, B00000000, B00000000, // >
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00000010, B01011001, B00001001, B00000110, B00000000, // ?
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B00111110, B01001001, B01010101, B01011101, B00001110, // @
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111110, B00010001, B00010001, B01111110, B00000000, // A
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B01001001, B01001001, B00110110, B00000000, // B
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111110, B01000001, B01000001, B00100010, B00000000, // C
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B01000001, B01000001, B00111110, B00000000, // D
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B01001001, B01001001, B01000001, B00000000, // E
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B00001001, B00001001, B00000001, B00000000, // F
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111110, B01000001, B01001001, B01111010, B00000000, // G
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B00001000, B00001000, B01111111, B00000000, // H
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B01000001, B01111111, B01000001, B00000000, B00000000, // I
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00110000, B01000000, B01000001, B00111111, B00000000, // J
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B00001000, B00010100, B01100011, B00000000, // K
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B01000000, B01000000, B01000000, B00000000, // L
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B01111111, B00000010, B00001100, B00000010, B01111111, // M
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B01111111, B00000100, B00001000, B00010000, B01111111, // N
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111110, B01000001, B01000001, B00111110, B00000000, // O
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B00001001, B00001001, B00000110, B00000000, // P
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111110, B01000001, B01000001, B10111110, B00000000, // Q
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B00001001, B00001001, B01110110, B00000000, // R
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01000110, B01001001, B01001001, B00110010, B00000000, // S
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B00000001, B00000001, B01111111, B00000001, B00000001, // T
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111111, B01000000, B01000000, B00111111, B00000000, // U
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B00001111, B00110000, B01000000, B00110000, B00001111, // V
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B00111111, B01000000, B00111000, B01000000, B00111111, // W
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B01100011, B00010100, B00001000, B00010100, B01100011, // X
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B00000111, B00001000, B01110000, B00001000, B00000111, // Y
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01100001, B01010001, B01001001, B01000111, B00000000, // Z
  prefs: []
  type: TYPE_NORMAL
- en: 2, 8, B01111111, B01000001, B00000000, B00000000, B00000000, // [
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00000001, B00000110, B00011000, B01100000, B00000000, // \
  prefs: []
  type: TYPE_NORMAL
- en: 2, 8, B01000001, B01111111, B00000000, B00000000, B00000000, // ]
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B00000010, B00000001, B00000010, B00000000, B00000000, // hat
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01000000, B01000000, B01000000, B01000000, B00000000, // _
  prefs: []
  type: TYPE_NORMAL
- en: 2, 8, B00000001, B00000010, B00000000, B00000000, B00000000, // `
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00100000, B01010100, B01010100, B01111000, B00000000, // a
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B01000100, B01000100, B00111000, B00000000, // b
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111000, B01000100, B01000100, B00101000, B00000000, // c
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111000, B01000100, B01000100, B01111111, B00000000, // d
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111000, B01010100, B01010100, B00011000, B00000000, // e
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B00000100, B01111110, B00000101, B00000000, B00000000, // f
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B10011000, B10100100, B10100100, B01111000, B00000000, // g
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B00000100, B00000100, B01111000, B00000000, // h
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B01000100, B01111101, B01000000, B00000000, B00000000, // i
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01000000, B10000000, B10000100, B01111101, B00000000, // j
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111111, B00010000, B00101000, B01000100, B00000000, // k
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B01000001, B01111111, B01000000, B00000000, B00000000, // l
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B01111100, B00000100, B01111100, B00000100, B01111000, // m
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111100, B00000100, B00000100, B01111000, B00000000, // n
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111000, B01000100, B01000100, B00111000, B00000000, // o
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B11111100, B00100100, B00100100, B00011000, B00000000, // p
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00011000, B00100100, B00100100, B11111100, B00000000, // q
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01111100, B00001000, B00000100, B00000100, B00000000, // r
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B01001000, B01010100, B01010100, B00100100, B00000000, // s
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B00000100, B00111111, B01000100, B00000000, B00000000, // t
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00111100, B01000000, B01000000, B01111100, B00000000, // u
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B00011100, B00100000, B01000000, B00100000, B00011100, // v
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B00111100, B01000000, B00111100, B01000000, B00111100, // w
  prefs: []
  type: TYPE_NORMAL
- en: 5, 8, B01000100, B00101000, B00010000, B00101000, B01000100, // x
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B10011100, B10100000, B10100000, B01111100, B00000000, // y
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B01100100, B01010100, B01001100, B00000000, B00000000, // z
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B00001000, B00110110, B01000001, B00000000, B00000000, // {
  prefs: []
  type: TYPE_NORMAL
- en: 1, 8, B01111111, B00000000, B00000000, B00000000, B00000000, // |
  prefs: []
  type: TYPE_NORMAL
- en: 3, 8, B01000001, B00110110, B00001000, B00000000, B00000000, // }
  prefs: []
  type: TYPE_NORMAL
- en: 4, 8, B00001000, B00000100, B00001000, B00000100, B00000000, // ~
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: int data = 8;   // Pin connected to DIN pin of MAXIM7219 module
  prefs: []
  type: TYPE_NORMAL
- en: int load = 9;   // Pin connected to CS pin of MAXIM7219 module
  prefs: []
  type: TYPE_NORMAL
- en: int clock = 10; // Pin connected to CLK pin of MAXIM7219 module
  prefs: []
  type: TYPE_NORMAL
- en: ➊ int maxInUse = 1; // Set the number of matrices you are using
  prefs: []
  type: TYPE_NORMAL
- en: MaxMatrix m(data, load, clock, maxInUse); // Define the module
  prefs: []
  type: TYPE_NORMAL
- en: byte buffer[10];
  prefs: []
  type: TYPE_NORMAL
- en: // Set message to scroll on the screen
  prefs: []
  type: TYPE_NORMAL
- en: ➋ char string1[] = " Arduino Project Handbook . . . ";
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: m.init(); // Start module
  prefs: []
  type: TYPE_NORMAL
- en: m.setIntensity(0);
  prefs: []
  type: TYPE_NORMAL
- en: Serial.begin(9600); // Start serial communication
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: byte c;
  prefs: []
  type: TYPE_NORMAL
- en: while (Serial.available() > 0) {
  prefs: []
  type: TYPE_NORMAL
- en: byte c = Serial.read();
  prefs: []
  type: TYPE_NORMAL
- en: Serial.println(c, DEC);
  prefs: []
  type: TYPE_NORMAL
- en: printCharWithShift(c, 100);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: m.shiftLeft(false, true);
  prefs: []
  type: TYPE_NORMAL
- en: printStringWithShift(string1, 100);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // The remainder of this sketch moves the scrolling characters
  prefs: []
  type: TYPE_NORMAL
- en: // depending on the number of matrices that are attached
  prefs: []
  type: TYPE_NORMAL
- en: void printCharWithShift(char c, int shift_speed) {
  prefs: []
  type: TYPE_NORMAL
- en: if (c < 32) return;
  prefs: []
  type: TYPE_NORMAL
- en: c -= 32;
  prefs: []
  type: TYPE_NORMAL
- en: memcpy_P(buffer, CH + 7 * c, 7);
  prefs: []
  type: TYPE_NORMAL
- en: m.writeSprite(maxInUse * 8, 0, buffer);
  prefs: []
  type: TYPE_NORMAL
- en: m.setColumn(maxInUse * 8 + buffer[0], 0);
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < buffer[0] + 1; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: delay(shift_speed);
  prefs: []
  type: TYPE_NORMAL
- en: m.shiftLeft(false, false);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void printStringWithShift(char* s, int shift_speed) {
  prefs: []
  type: TYPE_NORMAL
- en: while (*s != 0) {
  prefs: []
  type: TYPE_NORMAL
- en: printCharWithShift(*s, shift_speed);
  prefs: []
  type: TYPE_NORMAL
- en: s++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void printString(char* s) {
  prefs: []
  type: TYPE_NORMAL
- en: int col = 0;
  prefs: []
  type: TYPE_NORMAL
- en: while (*s != 0) {
  prefs: []
  type: TYPE_NORMAL
- en: if (*s < 32) continue;
  prefs: []
  type: TYPE_NORMAL
- en: char c = *s - 32;
  prefs: []
  type: TYPE_NORMAL
- en: memcpy_P(buffer, CH + 7 * c, 7);
  prefs: []
  type: TYPE_NORMAL
- en: m.writeSprite(col, 0, buffer);
  prefs: []
  type: TYPE_NORMAL
- en: m.setColumn(col + buffer[0], 0);
  prefs: []
  type: TYPE_NORMAL
- en: col += buffer[0] + 1;
  prefs: []
  type: TYPE_NORMAL
- en: s++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: You can change the message on the LED matrix by altering the text inside the
    quotation marks at ➋. If you want to chain your matrices together, change the
    number at ➊ to the number you have (the maximum number of matrices you can chain
    together is seven).
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The matrix does not light up or the LED shows erratic symbols.*'
  prefs: []
  type: TYPE_NORMAL
- en: • If none of the LEDs light, make sure you have connected the matrix as shown
    in the circuit diagram in [Figure 4-2](ch04.xhtml#ch4fig2); the pins must match
    exactly.
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure that your Arduino is powered and the TX light is flashing. If not,
    recheck your batteries or power supply.
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure the Maxim 7219 chip is securely inserted in the module.
  prefs: []
  type: TYPE_NORMAL
- en: '**5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mood Light**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll create a soothing mood light using a single multicolored
    LED.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0042-01.jpg)![Image](../images/p0043-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**RGB common-cathode LED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3 220-ohm resistors**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LEDs come in many different colors and forms, but one of the most useful is
    the RGB LED. As its name implies, an RGB LED is actually three LEDs in one: red,
    green, and blue (see [Figure 5-1](ch05.xhtml#ch5fig1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 5-1:** The primary colors of the RGB LED'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f5-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: RGB is an *additive* color model, which means that by combining the light of
    two or more colors we can create other colors. Red, green, and blue are the additive
    primary colors used as the base for other colors, as shown in [Figure 5-2](ch05.xhtml#ch5fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 5-2:** RGB is an additive color model.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f5-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s look at an RGB LED in a bit more detail in [Figure 5-3](ch05.xhtml#ch5fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 5-3:** An RGB LED'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f5-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You’ll see that the RGB LED has four legs instead of the usual two: one each
    for red, green, and blue, and the fourth one is either the cathode or anode. We’ll
    be using a *common-cathode* RGB LED like the one in the figure, where the longest
    leg is the cathode and connects to ground.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use our RGB LED to create a random-color output that cycles through the
    colors of the rainbow, fading each one in and out. This lighting effect is used
    quite often in clubs or bars to create a relaxing mood. You could also place the
    LED in an opaque vase or box for a soothing night-light.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Begin by placing the common-cathode RGB LED into your breadboard with the red
    leg in the hole to the left of the long GND (or cathode) leg. Connect a 220-ohm
    resistor to each of the three color legs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*On some RGB LEDs the green and blue legs are the other way around.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connect the red leg to Arduino pin 11, GND to Arduino GND, green to Arduino
    pin 10, and blue to Arduino pin 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|  **COMMON-CATHODE RGB LED**  | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Red | Pin 11 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Green | Pin 10 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Blue | Pin 9 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Confirm that your setup matches the circuit diagram in [Figure 5-4](ch05.xhtml#ch5fig4),
    and upload the code in “[The Sketch](ch05.xhtml#ch00lev1sec21)” on [page 47](ch05.xhtml#page_47).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 5-4:** The circuit diagram for the mood light'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f5-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch first sets Arduino pins 9, 10, and 11 as outputs. This sketch varies
    the brightness (power) value of each light on the RGB LED in turn by switching
    them on and off incredibly quickly—the longer an LED is lit for, the brighter
    it appears. To do this the Arduino uses a technique called *pulse width modulation
    (PWM)*. The Arduino creates a pulse by switching the power on and off very quickly.
    The duration that the power is on or off (known as the *pulse width*) in the cycle
    determines the average output, and by varying this pulse width the Arduino can
    simulate voltages between full on (5 volts) and off (0 volts). If the signal from
    the Arduino is on for half the time and off for half, the average output will
    be 2.5 volts, halfway between 0 and 5\. If the signal is on for 80 percent and
    off for 20 percent, the voltage is 4 volts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We define an RGB value between `0` and `255`, with an increment of `5` volts,
    to create a fade effect. In simple terms, each color of the LED brightens from
    0 to 5 volts in sequence, and then fades out when it reaches its maximum value
    of `255`. The Arduino can handle values between `0` and `1023` (1,024 values in
    total), but because this is such a high number we divide it by 4 and use `255`
    as the maximum LED value so the color change is more noticeable.
  prefs: []
  type: TYPE_NORMAL
- en: int redPin = 11;   // Pin connected to red leg of the RGB LED
  prefs: []
  type: TYPE_NORMAL
- en: int greenPin = 10; // Pin connected to green leg of the RGB LED
  prefs: []
  type: TYPE_NORMAL
- en: int bluePin = 9;   // Pin connected to blue leg of the RGB LED
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: setRgb(0, 0, 0); // Set all colors at 0
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: int Rgb[3]; // 3 RGB pins
  prefs: []
  type: TYPE_NORMAL
- en: Rgb[0] = 0; // A value for each
  prefs: []
  type: TYPE_NORMAL
- en: Rgb[1] = 0;
  prefs: []
  type: TYPE_NORMAL
- en: Rgb[2] = 0;
  prefs: []
  type: TYPE_NORMAL
- en: // Colors increase and decrease in value
  prefs: []
  type: TYPE_NORMAL
- en: for (int decrease = 0; decrease < 3; decrease += 1) {
  prefs: []
  type: TYPE_NORMAL
- en: 'int increase = decrease == 2 ? 0 : decrease + 1;'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < 255; i += 1) { // Fade the colors
  prefs: []
  type: TYPE_NORMAL
- en: Rgb[decrease] -= 1;
  prefs: []
  type: TYPE_NORMAL
- en: Rgb[increase] += 1;
  prefs: []
  type: TYPE_NORMAL
- en: setRgb(Rgb[0], Rgb[1], Rgb[2]);
  prefs: []
  type: TYPE_NORMAL
- en: delay(20);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void setRgb (int red, int green, int blue) {
  prefs: []
  type: TYPE_NORMAL
- en: analogWrite(redPin, red);
  prefs: []
  type: TYPE_NORMAL
- en: analogWrite(greenPin, green);
  prefs: []
  type: TYPE_NORMAL
- en: analogWrite(bluePin, blue);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but the RGB LED does not light up as expected.*'
  prefs: []
  type: TYPE_NORMAL
- en: • If the RGB LED does not light at all, make sure you’ve connected the GND wire
    from the Arduino to the correct leg on the RGB LED—the long cathode leg—and that
    the Arduino has power connected.
  prefs: []
  type: TYPE_NORMAL
- en: • If you have a common-anode RGB LED, then you should connect the long leg to
    +5V on the Arduino. Check the data sheet for your part to find out which kind
    of RGB LED you have.
  prefs: []
  type: TYPE_NORMAL
- en: • If the colors don’t appear as expected, your RGB LED may have a different
    pin configuration; check your data sheet or try swapping the connections to the
    green and blue legs around.
  prefs: []
  type: TYPE_NORMAL
- en: '**6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rainbow Strip Light**
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll use an RGB LED strip light to create a decorative ambient
    strip of rainbow colors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0049-01.jpg)![Image](../images/p0050-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solid-core wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**RGB LED strip (WS2812B 5V 32-LED strip)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARY REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PololuLedStrip**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LED strip lights are often used to create ambiance as a decorative feature,
    such as backlighting for a TV or lighting beneath kitchen cabinets. They are low-powered,
    typically between 5 and 12 volts, so they’re easy to install anywhere with their
    own power supply—and they look good too!
  prefs: []
  type: TYPE_NORMAL
- en: Strip lights generally come in two varieties. Single-color or multicolor *nonaddressable*
    strips can only light all the LEDs in one color at a time. RGB multicolored strips
    are generally *addressable*, which means that each LED has its own chip and can
    be individually controlled, allowing multiple colors on different LEDs to light
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using a strip light of addressable RGB LEDs. Unlike the RGB LED from
    Project 5, the LEDs on a strip light are *surface mounted*. This means that the
    components are placed directly onto the surface of a printed circuit board—in
    this case, a flexible strip—rather than being individually inserted into a circuit.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main kinds of addressable RGB strip lights. Three-pin RGB LED
    strips have GND, Data, and +5V connections to control the LEDs. The Data pin connects
    to the Arduino and uses the same *pulse width modulation (PWM)* function explained
    in Project 5 to create the colors and sequence on the strip. Four-pin RGB LED
    strips have GND, Clock, Data In, and +5V connections and use *Serial Peripheral
    Interface (SPI)* to control their LEDs. SPI is a communication method that allows
    the two-way transfer of data between devices.
  prefs: []
  type: TYPE_NORMAL
- en: Our addressable RGB LED strip, shown in [Figure 6-1](ch06.xhtml#ch6fig1), is
    the three-pin type using PWM. It calls on the PololuLedStrip library, created
    by Pololu Robotics and Electronics (*[https://www.pololu.com/](https://www.pololu.com/)*),
    to control the LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 6-1:** A three-pin addressable RGB LED strip light'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f6-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ll use our RGB LED strip to create a color output that cycles through the
    colors of the rainbow, fading each color in and out, as shown in [Figure 6-2](ch06.xhtml#ch6fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 6-2:** RGB LED strip cycling through the colors of the rainbow'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f6-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Download and add the PololuLedStrip library to your Arduino IDE (check the primer
    for guidance on saving libraries).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The setup for this project is very simple and doesn’t take long to complete.
    Most three-pin addressable RGB LED strips come without wires attached to the strip
    connections, so you’ll have to connect them. With the LEDs facing upward, begin
    by soldering solid-core wire to the three connections at the left end of the strip,
    as shown in [Figure 6-3](ch06.xhtml#ch6fig3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 6-3:** Soldering wires to the left-side connections'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f6-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Connect the LED’s GND pin to Arduino GND, DI to Arduino pin 12, and +5V to Arduino
    +5V, as shown in the following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **RGB LED STRIP** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| DI (data in) | Pin 12 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| +5V | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Check your setup against the circuit diagram in [Figure 6-4](ch06.xhtml#ch6fig4),
    and then upload the code in “[The Sketch](ch06.xhtml#ch00lev1sec25)” below and
    power the Arduino using your battery pack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 6-4:** The circuit diagram for the rainbow strip light'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f6-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch first calls on the PololuLedStrip library, which we use to control
    the individual LEDs. Next, it defines the pin to control the data going from the
    Arduino to the LED strip as 12 and sets the number of LEDs on the strip to 32—you
    would change this if your strip had a different number of LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: Next is a calculation to control the hue, saturation, and value (HSV) of our
    LEDs to generate the RGB colors. You can change these using an HSV chart if you
    want; just do a quick internet search to find a chart for reference.
  prefs: []
  type: TYPE_NORMAL
- en: The WS2812B data sheet states that the color of each LED is encoded as three
    LED brightness values, which must be sent in GRB (green-red-blue) order. The first
    color transmitted applies to the LED that is closest to the data input connector,
    the second color transmitted applies to the next LED in the strip, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: /* PololuLedStrip Library Copyright (c) 2012 Pololu Corporation.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, see [http://www.pololu.com/](http://www.pololu.com/);
  prefs: []
  type: TYPE_NORMAL
- en: '[http://forum.pololu.com/](http://forum.pololu.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Permission is hereby granted, free of charge, to any person
  prefs: []
  type: TYPE_NORMAL
- en: obtaining a copy of this software and associated documentation files
  prefs: []
  type: TYPE_NORMAL
- en: (the "Software"), to deal in the Software without restriction,
  prefs: []
  type: TYPE_NORMAL
- en: including without limitation the rights to use, copy, modify, merge,
  prefs: []
  type: TYPE_NORMAL
- en: publish, distribute, sublicense, and/or sell copies of the Software,
  prefs: []
  type: TYPE_NORMAL
- en: and to permit persons to whom the Software is furnished to do so,
  prefs: []
  type: TYPE_NORMAL
- en: 'subject to the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The above copyright notice and this permission notice shall be
  prefs: []
  type: TYPE_NORMAL
- en: included in all copies or substantial portions of the Software.
  prefs: []
  type: TYPE_NORMAL
- en: THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  prefs: []
  type: TYPE_NORMAL
- en: EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  prefs: []
  type: TYPE_NORMAL
- en: OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON
  prefs: []
  type: TYPE_NORMAL
- en: INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  prefs: []
  type: TYPE_NORMAL
- en: BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  prefs: []
  type: TYPE_NORMAL
- en: ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  prefs: []
  type: TYPE_NORMAL
- en: CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  prefs: []
  type: TYPE_NORMAL
- en: SOFTWARE.
  prefs: []
  type: TYPE_NORMAL
- en: 'LedStripRainbow: Example Arduino sketch that shows how to make a'
  prefs: []
  type: TYPE_NORMAL
- en: moving rainbow pattern on an Addressable RGB LED Strip from Pololu.
  prefs: []
  type: TYPE_NORMAL
- en: To use this, you will need to plug an Addressable RGB LED strip from
  prefs: []
  type: TYPE_NORMAL
- en: Pololu into pin 12.  After uploading the sketch, you should see a
  prefs: []
  type: TYPE_NORMAL
- en: moving rainbow. */
  prefs: []
  type: TYPE_NORMAL
- en: '#include <PololuLedStrip.h>'
  prefs: []
  type: TYPE_NORMAL
- en: // Create an ledStrip object and specify the pin it will use.
  prefs: []
  type: TYPE_NORMAL
- en: PololuLedStrip<12> ledStrip;
  prefs: []
  type: TYPE_NORMAL
- en: // Create a buffer for holding the colors (3 bytes per color).
  prefs: []
  type: TYPE_NORMAL
- en: '#define LED_COUNT 32'
  prefs: []
  type: TYPE_NORMAL
- en: rgb_color colors[LED_COUNT];
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Converts a color from HSV to RGB.
  prefs: []
  type: TYPE_NORMAL
- en: // h is hue, as a number between 0 and 360.
  prefs: []
  type: TYPE_NORMAL
- en: // s is saturation, as a number between 0 and 255.
  prefs: []
  type: TYPE_NORMAL
- en: // v is value, as a number between 0 and 255.
  prefs: []
  type: TYPE_NORMAL
- en: rgb_color hsvToRgb(uint16_t h, uint8_t s, uint8_t v) {
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t f = (h % 60) * 255 / 60;
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t p = (255 - s) * (uint16_t)v / 255;
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t q = (255 - f * (uint16_t)s / 255) * (uint16_t)v / 255;
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t t = (255 - (255 - f) * (uint16_t)s / 255) * (uint16_t)v / 255;
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t r = 0, g = 0, b = 0;
  prefs: []
  type: TYPE_NORMAL
- en: switch((h / 60) % 6) {
  prefs: []
  type: TYPE_NORMAL
- en: 'case 0: r = v; g = t; b = p; break;'
  prefs: []
  type: TYPE_NORMAL
- en: 'case 1: r = q; g = v; b = p; break;'
  prefs: []
  type: TYPE_NORMAL
- en: 'case 2: r = p; g = v; b = t; break;'
  prefs: []
  type: TYPE_NORMAL
- en: 'case 3: r = p; g = q; b = v; break;'
  prefs: []
  type: TYPE_NORMAL
- en: 'case 4: r = t; g = p; b = v; break;'
  prefs: []
  type: TYPE_NORMAL
- en: 'case 5: r = v; g = p; b = q; break;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return (rgb_color) {
  prefs: []
  type: TYPE_NORMAL
- en: r, g, b
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: // Update the colors.
  prefs: []
  type: TYPE_NORMAL
- en: uint16_t time = millis() >> 2;
  prefs: []
  type: TYPE_NORMAL
- en: for (uint16_t i = 0; i < LED_COUNT; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: byte x = (time >> 2) - (i << 3);
  prefs: []
  type: TYPE_NORMAL
- en: colors[i] = hsvToRgb((uint32_t)x * 359 / 256, 255, 255);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Write the colors to the LED strip.
  prefs: []
  type: TYPE_NORMAL
- en: ledStrip.write(colors, LED_COUNT);
  prefs: []
  type: TYPE_NORMAL
- en: delay(10);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but the RGB LED does not light up as expected.*'
  prefs: []
  type: TYPE_NORMAL
- en: • If the RGB LED strip does not light, make sure that your wires are connected
    as shown in [Figure 6-4](ch06.xhtml#ch6fig4), and that your LED strip is the WS2812B
    type specified.
  prefs: []
  type: TYPE_NORMAL
- en: • If you aren’t doing so already, use an external power source for the RGB LED
    strip.
  prefs: []
  type: TYPE_NORMAL
- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NeoPixel Compass**
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll use a three-axis sensor and an RGB LED ring to create
    a compass that indicates north by lighting the LEDs in that direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0056-01.jpg)![Image](../images/p0057-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HMC5883L three-axis sensor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adafruit NeoPixel ring with 16 RGB LEDs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**9V battery pack with 6 AA batteries**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARIES REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wire**'
  prefs: []
  type: TYPE_NORMAL
- en: '**FastLED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HMC5883L**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HMC5883L three-axis sensor ([Figure 7-1](ch07.xhtml#ch7fig1)) is a multichip
    module that senses magnetic force. The module measures both the direction and
    the magnitude of Earth’s magnetic fields. We will use the HMC5883L library to
    turn our project into an electronic compass.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 7-1:** The HMC5883L three-axis module runs on 3.3V rather than 5V.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f7-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Earth’s magnetic field is believed to be generated by electric currents in the
    conductive material of its core that are created by heat escaping. Since Earth
    is effectively a magnet, the north end of a compass magnet is drawn to align with
    its magnetic field.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize our compass direction we will use the Adafruit NeoPixel ring, shown
    in [Figure 7-2](ch07.xhtml#ch7fig2). The NeoPixel ring is made up of 16 RGB LEDs,
    each of which has its own driver chip and so can be controlled individually. A
    single data line controls the LEDs, and we’ll use the FastLED library to control
    the colors.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 7-2:** The Adafruit 16 RGB NeoPixel ring'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f7-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the project is powered up, the HMC5883L module will detect magnetic north
    and display it on the NeoPixel ring by lighting the LEDs in that direction. If
    you turn around while holding the powered NeoPixel compass, the LED lights will
    move to always point north.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The pin labeled DRDY on the compass module is not used in this project.*'
  prefs: []
  type: TYPE_NORMAL
- en: Your HMC5883L module may arrive with the header pins loose, so the first step
    is to solder the header pins into the module. You will need the strip of five
    header pins that should come with the module. Insert the header pins into the
    five available holes on the module and solder each pin for a couple of seconds
    (check the “[Quick Soldering Guide](pref02.xhtml#ch00lev1sec123)” on [page 12](pref02.xhtml#page_12)
    if you need help). The module communicates with the Arduino using I2C and the
    Wire library.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use the compass properly you need to calibrate the HMC5883L module.
    Connect the module to the Arduino as shown in the following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **HMC5883L MODULE** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +3.3V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| SCL | Pin A5 (SLC) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| SDA | Pin A4 (SDA) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Download the HMC5883L library and add it to the Arduino library folder on your
    PC. Check the library section in the primer if you need a reminder of how to do
    this. Once you have the library saved, restart your Arduino IDE. When it opens
    again, it should have the library saved in *Examples*. Select **File** ▸ **Examples**
    ▸ **Arduino-HMC5883L-Master** ▸ **HMC5883L_calibrate**. If you can’t see the sketch,
    make sure you’ve saved the library in your Arduino library folder. The following
    sketch will be shown in the IDE main window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: /*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Calibrate HMC5883L. Output for HMC5883L_calibrate_processing.pde
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Read more: [http://www.jarzebski.pl/arduino/czujniki-i-sensory/3-osiowy-magnetometr-hmc5883l.html](http://www.jarzebski.pl/arduino/czujniki-i-sensory/3-osiowy-magnetometr-hmc5883l.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'GIT: [https://github.com/jarzebski/Arduino-HMC5883L](https://github.com/jarzebski/Arduino-HMC5883L)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Web: [http://www.jarzebski.pl](http://www.jarzebski.pl)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (c) 2014 by Korneliusz Jarzebski
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*/'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <Wire.h>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <HMC5883L.h>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: HMC5883L compass;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: int minX = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: int maxX = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: int minY = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: int maxY = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: int offX = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: int offY = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void setup() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.begin(9600);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Initialize Initialize HMC5883L
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: while (!compass.begin()) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: delay(500);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Set measurement range
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: compass.setRange(HMC5883L_RANGE_1_3GA);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Set measurement mode
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: compass.setMeasurementMode(HMC5883L_CONTINOUS);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Set data rate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: compass.setDataRate(HMC5883L_DATARATE_30HZ);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Set number of samples averaged
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: compass.setSamples(HMC5883L_SAMPLES_8);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void loop() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Vector mag = compass.readRaw();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Determine Min / Max values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (mag.XAxis < minX) minX = mag.XAxis;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (mag.XAxis > maxX) maxX = mag.XAxis;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (mag.YAxis < minY) minY = mag.YAxis;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (mag.YAxis > maxY) maxY = mag.YAxis;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Calculate offsets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: offX = (maxX + minX)/2;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: offY = (maxY + minY)/2;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /*Serial.print(mag.XAxis);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(":");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(mag.YAxis);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(":");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(minX);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(":");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(maxX);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(":");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(minY);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(":");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(maxY);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(":"); */
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(offX);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(":");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(offY);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print("\n");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We only need the X and Y `Serial.print` lines in this last bunch of `Serial.print`
    commands, so comment out the `Serial.print` lines of the sketch shown in bold.
    Upload the sketch to the Arduino and open the Serial Monitor. A series of numbers
    will display, as shown in [Figure 7-3](ch07.xhtml#ch7fig3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 7-3:** The calibration numbers will be shown in the IDE Serial Monitor
    window.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f7-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Rotate the sensor 360 degrees while it’s connected to the Arduino IDE Serial
    Monitor, and you should see two digits displayed; in [Figure 7-3](ch07.xhtml#ch7fig3),
    they’re 13 and –294\. You’ll need these calibration numbers in the sketch later,
    so make a note of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can improve the accuracy of your compass by finding the *magnetic declination*
    for your location. The magnetic declination, or variation, is the angle on the
    horizontal plane between magnetic north (where a compass points) and true north
    (the direction toward the geographic North Pole). You can find your magnetic declination
    by visiting *[http://www.magnetic-declination.com/](http://www.magnetic-declination.com/)*
    and entering your location in the search bar at the top left. Your result will
    appear as shown in [Figure 7-4](ch07.xhtml#ch7fig4).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 7-4:** The magnetic declination for your location can be found at
    *[http://www.magnetic-declination.com/](http://www.magnetic-declination.com/)*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f7-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The values you need are the magnetic declination and the declination; in [Figure
    7-4](ch07.xhtml#ch7fig4), they’re –2° 26'' and NEGATIVE (WEST), respectively,
    but yours will be different. Record these values too, as we’ll use them in the
    sketch at the end of the project—with one minor change. For example, my values
    were –2 and 26\. We don’t put the negative (minus) sign before the first value
    but instead put it after, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: float declinationAngle = (2 - (26.0 / 60.0)) / (180 / M_PI);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If your location’s declination were POSITIVE (WEST), then you would add the
    positive (plus) sign instead:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: float declinationAngle = (2 + (26.0 / 60.0)) / (180 / M_PI);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, add the NeoPixel ring to the Arduino by connecting V on the NeoPixel to
    +5V on the Arduino, GND to GND, and In on the NeoPixel to pin 3 on the Arduino.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| **NEOPIXEL** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| V | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| In | Pin 3 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Check your setup against the circuit diagram in [Figure 7-5](ch07.xhtml#ch7fig5),
    and then upload the code in “[The Sketch](ch07.xhtml#ch00lev1sec29)” below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 7-5:** The circuit diagram for the NeoPixel compass'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f7-05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First we call on the Wire, FastLED, and HMC5883L libraries. The Wire library
    is installed with the Arduino IDE, but you need to add the others. Download them
    in the book’s resources at *[http://www.nostarch.com/arduinohandbook2/](http://www.nostarch.com/arduinohandbook2/)*,
    and follow the guide in the primer for more information on adding libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Next we declare the number of LEDs on the NeoPixel ring (16) and assign pin
    3 on the Arduino to control it. We then call on a number of settings in the HMC5883L
    library to control the compass module. At ➊ we add the compass offset values for
    `X` and `Y`, which should match your calibration from Step 4 earlier; mine were
    13, –294, respectively. At ➋ we add the magnetic declination from Step 6\. Again,
    remember to change it to the one for your location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next set of calculations allows the sensor to map to a 360-degree rotation.
    Then we set the LEDs on the NeoPixel to move depending on the readings of the
    sensor to point north. Three LEDs are lit: one red LED that points north and a
    green LED on either side of it. The compass is best used outdoors with the module,
    away from any strong electrical or magnetic sources, and should be powered from
    a battery pack rather than a USB connection.'
  prefs: []
  type: TYPE_NORMAL
- en: // Code by brainy-bits.com and used with kind permission
  prefs: []
  type: TYPE_NORMAL
- en: // [https://brainy-bits.com/tutorials/find-your-way-using-the-hmc5883l/](https://brainy-bits.com/tutorials/find-your-way-using-the-hmc5883l/)
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Wire.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "FastLED.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <HMC5883L.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#define NUM_LEDS 16  // Number of LEDs on Ring'
  prefs: []
  type: TYPE_NORMAL
- en: '#define DATA_PIN_RING 3 // Pin 3 connected to RGB Ring'
  prefs: []
  type: TYPE_NORMAL
- en: CRGB leds_RING[NUM_LEDS];
  prefs: []
  type: TYPE_NORMAL
- en: HMC5883L compass;
  prefs: []
  type: TYPE_NORMAL
- en: int fixedHeadingDegrees; // Used to store Heading value
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: Serial.begin(9600);
  prefs: []
  type: TYPE_NORMAL
- en: Wire.begin(); //Setup I2C
  prefs: []
  type: TYPE_NORMAL
- en: // Set up the FastLED library with the neopixel ring data
  prefs: []
  type: TYPE_NORMAL
- en: FastLED.addLeds<NEOPIXEL,DATA_PIN_RING>(leds_RING, NUM_LEDS);
  prefs: []
  type: TYPE_NORMAL
- en: // Set measurement range
  prefs: []
  type: TYPE_NORMAL
- en: compass.setRange(HMC5883L_RANGE_1_3GA);
  prefs: []
  type: TYPE_NORMAL
- en: // Set measurement mode
  prefs: []
  type: TYPE_NORMAL
- en: compass.setMeasurementMode(HMC5883L_CONTINOUS);
  prefs: []
  type: TYPE_NORMAL
- en: // Set data rate
  prefs: []
  type: TYPE_NORMAL
- en: compass.setDataRate(HMC5883L_DATARATE_30HZ);
  prefs: []
  type: TYPE_NORMAL
- en: // Set number of samples averaged
  prefs: []
  type: TYPE_NORMAL
- en: compass.setSamples(HMC5883L_SAMPLES_8);
  prefs: []
  type: TYPE_NORMAL
- en: // Set calibration offset. See HMC5883L_calibration.ino
  prefs: []
  type: TYPE_NORMAL
- en: ➊ compass.setOffset(13, -224);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: Vector norm = compass.readNormalize();
  prefs: []
  type: TYPE_NORMAL
- en: // Calculate heading
  prefs: []
  type: TYPE_NORMAL
- en: float heading = atan2(norm.YAxis, norm.XAxis);
  prefs: []
  type: TYPE_NORMAL
- en: // Set declination angle on your location and fix heading
  prefs: []
  type: TYPE_NORMAL
- en: // Find your declination on http://magnetic-declination.com/
  prefs: []
  type: TYPE_NORMAL
- en: // (+) Positive or (-) for negative
  prefs: []
  type: TYPE_NORMAL
- en: // For Dumfries, Scotland declination angle is -2 '26W (negative)
  prefs: []
  type: TYPE_NORMAL
- en: '// Formula: (deg + (min / 60.0)) / (180 / M_PI);'
  prefs: []
  type: TYPE_NORMAL
- en: float declinationAngle = (2.0 – (26.0 / 60.0)) / (180 / M_PI);
  prefs: []
  type: TYPE_NORMAL
- en: ➋  heading -= declinationAngle;
  prefs: []
  type: TYPE_NORMAL
- en: // Correct for heading < 0deg and heading > 360deg
  prefs: []
  type: TYPE_NORMAL
- en: if (heading < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: heading += 2 * PI;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (heading > 2 * PI) {
  prefs: []
  type: TYPE_NORMAL
- en: heading -= 2 * PI;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Convert to degrees
  prefs: []
  type: TYPE_NORMAL
- en: float headingDegrees = heading * 180 / M_PI;
  prefs: []
  type: TYPE_NORMAL
- en: // To fix rotation speed of HMC5883L compass module
  prefs: []
  type: TYPE_NORMAL
- en: if (headingDegrees >= 1 && headingDegrees < 240) {
  prefs: []
  type: TYPE_NORMAL
- en: fixedHeadingDegrees = map(headingDegrees * 100, 0, 239 * 100, 0, 179 * 100)
    / 100.00;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else {
  prefs: []
  type: TYPE_NORMAL
- en: if (headingDegrees >= 240) {
  prefs: []
  type: TYPE_NORMAL
- en: fixedHeadingDegrees = map(headingDegrees*100, 240*100, 360*100, 180*100, 360*100)
    / 100.00;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int headvalue = fixedHeadingDegrees / 18;
  prefs: []
  type: TYPE_NORMAL
- en: int ledtoheading = map(headvalue, 0, 15, 15, 0);
  prefs: []
  type: TYPE_NORMAL
- en: // Clear the ring
  prefs: []
  type: TYPE_NORMAL
- en: FastLED.clear();
  prefs: []
  type: TYPE_NORMAL
- en: // New heading
  prefs: []
  type: TYPE_NORMAL
- en: if (ledtoheading == 0) {
  prefs: []
  type: TYPE_NORMAL
- en: leds_RING[15] = CRGB::Red;
  prefs: []
  type: TYPE_NORMAL
- en: leds_RING[0] = CRGB::Green;
  prefs: []
  type: TYPE_NORMAL
- en: leds_RING[14] = CRGB::Green;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else {
  prefs: []
  type: TYPE_NORMAL
- en: if (ledtoheading == 15) {
  prefs: []
  type: TYPE_NORMAL
- en: leds_RING[0] = CRGB::Red;
  prefs: []
  type: TYPE_NORMAL
- en: leds_RING[15] = CRGB::Green;
  prefs: []
  type: TYPE_NORMAL
- en: leds_RING[1] = CRGB::Green;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else {
  prefs: []
  type: TYPE_NORMAL
- en: leds_RING[ledtoheading] = CRGB::Red;
  prefs: []
  type: TYPE_NORMAL
- en: leds_RING[ledtoheading+1] = CRGB::Green;
  prefs: []
  type: TYPE_NORMAL
- en: leds_RING[ledtoheading-1] = CRGB::Green;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: FastLED.setBrightness(50);
  prefs: []
  type: TYPE_NORMAL
- en: FastLED.show();
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but the RGB LEDs do not light up as expected.*'
  prefs: []
  type: TYPE_NORMAL
- en: • If no LEDs are lit, double-check your wiring, particularly that the data pin
    of the NeoPixel is connected to pin 3 on the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: • Check that your power for the NeoPixel is connected to GND and +5V. The compass
    module should be connected to GND and +3.3V. The Arduino should be powered by
    your battery pack, not the USB cable from your PC.
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure you have calibrated the module and entered the values using the
    steps shown earlier. The compass module should be held horizontally and in line
    with the RGB ring. The ring and the module should always be moved together.
  prefs: []
  type: TYPE_NORMAL
- en: • The module is best used outdoors, as it is very sensitive to metal and electrical
    interference.
  prefs: []
  type: TYPE_NORMAL
- en: • Try to keep the power for your Arduino and the sensor as far apart as possible
    to avoid interference.
  prefs: []
  type: TYPE_NORMAL
