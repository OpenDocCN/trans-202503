["```\n lea   x1, longZString\n          mov   x2, x1         // Save pointer to string.\nwhileLp:  ldrb  w0, [x1], #1   // Fetch next char and inc X1.\n          cmp   w0, #0         // See if 0 byte.\n          bne   whileLp        // Repeat while not 0.\n          sub   x0, x1, x2     // X0 = X1 - X2\n          sub   x0, x0, #1     // Adjust for extra increment.\n\n// String length is now in X0.\n```", "```\n// strlen.S\n//\n// Copyright (C) 2012-2022 Free Software Foundation, Inc.\n// This file is part of the GNU C Library. The GNU C\n// Library is free software; you can redistribute it\n// and/or modify it under the terms of the GNU Lesser\n// General Public License as published by the Free\n// Software Foundation; either version 2.1 of the License,\n// or (at your option) any later version. The GNU C\n// Library is distributed in the hope that it will be\n// useful, but WITHOUT ANY WARRANTY; without even the\n// implied warranty of MERCHANTABILITY or FITNESS FOR A\n// PARTICULAR PURPOSE. See the GNU Lesser General Public\n// License for more details. You should have received a\n// copy of the GNU Lesser General Public License along\n// with the GNU C Library. If not, see\n// <https://www.gnu.org/licenses/>.\n\n#include <sysdep.h>\n\n// Assumptions:\n//\n// ARMv8-a, AArch64, Advanced SIMD\n// MTE compatible\n\n❶ #define srcin       x0\n#define result      x0\n\n#define src         x1\n#define synd        x2\n#define tmp         x3\n#define shift       x4\n\n#define data        q0\n#define vdata       v0\n#define vhas_nul    v1\n#define vend        v2\n#define dend        d2\n\n// Core algorithm: For each 16-byte chunk, calculate a\n// 64-bit nibble mask value with 4 bits per byte. This code\n// take 4 bits of every comparison byte with shift right\n// and narrow by 4 instruction. Since the bits in the\n// nibble mask reflect the order in which things occur in\n// the original string, counting trailing 0s identifies\n// exactly which byte matched.\n\n// On input, X0 contains a pointer to a zero-terminated string.\n// On return, X0 contains the string length.\n\nSTRLEN:\n      ❷ bic     src, srcin, 15\n        ld1     {vdata.16b}, [src]\n        cmeq    vhas_nul.16b, vdata.16b, 0\n        lsl     shift, srcin, 2\n        shrn    vend.8b, vhas_nul.8h, 4     /* 128 -> 64 */\n        fmov    synd, dend\n        lsr     synd, synd, shift\n        cbz     synd, zloop\n\n      ❸ rbit    synd, synd\n        clz     result, synd\n        lsr     result, result, 2\n        ret\n\n        .p2align 5\nzloop:\n      ❹ ldr     data, [src, 16]!\n        cmeq    vhas_nul.16b, vdata.16b, 0\n        umaxp   vend.16b, vhas_nul.16b, vhas_nul.16b\n        fmov    synd, dend\n        cbz     synd, zloop\n\n      ❺ shrn    vend.8b, vhas_nul.8h, 4     /* 128 -> 64 */\n        sub     result, src, srcin\n        fmov    synd, dend\n        rbit    synd, synd\n        clz     tmp, synd\n        add     result, result, tmp, lsr 2\n        ret\n```", "```\nstruct  string, -8\nword    string.maxlen\nword    string.len\nbyte    string.chars  // Note: up to 4GB chars\nends    string\n```", "```\nldr  w1, [x0, #string.maxlen]  // Fetch the maxlen field.\nldr  w2, [x0, #string.len]     // Fetch the current length.\n```", "```\n .macro  str.buf strName, maxSize\n            .align  4   // Align on 16-byte boundary.\n            .word   \\maxSize\n            .word   0\n\\strName:   .space  ((\\maxSize+16) & 0xFFFFFFF0), 0\n            .endm\n\n            .macro  str.literal strName, strChars\n            .align  4   // Align on 16-byte boundary.\n            .word   len_\\strName    // string.maxlen\n            .word   len_\\strName    // string.len\n\n            // Emit the string data and compute the\n            // string's length:\n\n\\strName:   .ascii  \"\\strChars\"\nlen_\\strName=       .-\\strName\n .byte   0   // Zero-terminating byte\n\n            // Ensure object is multiple of 16 bytes:\n\n            .align  4\n            .endm\n```", "```\nstr.buf  myString, 100  // Maximum of 100 chars in string\n```", "```\nstr.literal hwStr, \"Hello, World!\\n\"\n```", "```\nstruct  string, -16\ndword   string.allocPtr // At offset -16\nword    string.maxlen   // At offset -8\nword    string.len      // At offset -4\nbyte    string.chars    // At offset 0\n\n// Note: characters in string occupy offsets\n// 0 ... in this structure.\n\nends    string\n```", "```\n// Structure to hold the volatile registers saved by functions\n// that call C stdlib funcs\n//\n// Note: size of this structure must be a multiple of 16 bytes!\n\n            struct  volatile_save\n            qword   volatile_save.x0x1\n qword   volatile_save.x2x3\n            qword   volatile_save.x4x5\n            qword   volatile_save.x6x7\n            qword   volatile_save.x8x9\n            qword   volatile_save.x10x11\n            qword   volatile_save.x12x13\n            qword   volatile_save.x14x15\n            qword   volatile_save.v0\n            qword   volatile_save.v1\n            qword   volatile_save.v2\n            qword   volatile_save.v3\n            qword   volatile_save.v4\n            qword   volatile_save.v5\n            qword   volatile_save.v6\n            qword   volatile_save.v7\n            qword   volatile_save.v8\n            qword   volatile_save.v9\n            qword   volatile_save.v10\n            qword   volatile_save.v11\n            qword   volatile_save.v12\n            qword   volatile_save.v13\n            qword   volatile_save.v14\n            qword   volatile_save.v15\n            ends    volatile_save\n```", "```\n// Listing14-1.S\n//\n// String initialization, allocation, and deallocation functions and macros\n\n            #include    \"aoaa.inc\"\n\n// Assembly language string data structure:\n\n            struct  string, -16\n            dword   string.allocPtr // At offset -16\n            word    string.maxlen   // At offset -8\n            word    string.len      // At offset -4\n            byte    string.chars    // At offset 0\n\n            // Note: characters in string occupy offsets\n            // 0 ... in this structure.\n\n            ends    string\n```", "```\n// Listing14-1.S (cont.)\n//\n// str.buf\n//\n// Allocate storage for an empty string\n// with the specified maximum size:\n\n            .macro  str.buf strName, maxSize\n            .align  4         // Align on 16-byte boundary.\n            .dword  0         // NULL ptr for allocation ptr\n            .word   \\maxSize  // Maximum string size\n            .word   0         // Current string length\n\\strName:   .space  ((\\maxSize+16) & 0xFFFFFFF0), 0\n            .endm\n\n// str.literal\n//\n// Allocate storage for a string buffer and initialize\n// it with a string literal:\n\n            .macro  str.literal strName, strChars\n            .align  4   // Align on 16-byte boundary.\n            .dword  0   // NULL ptr for allocation ptr\n            .word   len_\\strName    // string.maxlen\n            .word   len_\\strName    // string.len\n\n            // Emit the string data and compute the\n            // string's length:\n\n\\strName:   .ascii  \"\\strChars\"\nlen_\\strName=       .-\\strName\n            .byte   0   // Zero-terminating byte\n\n            // Ensure object is multiple of 16 bytes:\n\n            .align  4\n            .endm\n```", "```\n// Listing14-1.S (cont.)\n\n            .code\n            .global malloc\n            .global free\n\nttlStr:     wastr  \"Listing14-1\"\n\n// Standard getTitle function\n// Returns pointer to program name in X0\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n```", "```\n// Listing14-1.S (cont.)\n//\n// str.bufInit\n//\n// Initializes a raw memory buffer for use as an assembly\n// language string object\n//\n// On entry:\n//\n//  X0- Pointer to the first byte of a buffer\n//  W1- Buffer length\n//\n// On return:\n//\n//  X0- Pointer to string variable object\n//  X1- Maximum string length\n//\n//  Carry flag clear if success, set if error\n\n            proc    str.bufInit\n\n            locals  str_bufInit_l\n            dword   str_bufInit_l.saveX2\n            byte    str_bufInit_l.stkSpace, 64\n            endl    str_bufInit_l\n\n            enter   str_bufInit_l.size\n            str     x2, [fp, #str_bufInit_l.saveX2]\n\n            // Clear HO 32 bits of X1:\n\n          ❶ and     x1, x1, #0xFFFFFFFF\n\n            // Ensure that the pointer is aligned\n            // on a 16-byte boundary:\n\n          ❷ add     x2, x0, #15\n            bic     x2, x2, #0xf\n\n            // Point X2 at the start of the\n            // character data:\n\n ❸ add     x2, x2, #string.chars-string.allocPtr\n\n            // Compute the new maxlen value:\n\n          ❹ sub     x0, x2, x0\n            subs    x1, x1, x0\n            bmi     str.bufInit.bad\n\n            // Force maxlen to be a multiple of 16:\n\n          ❺ bic     x1, x1, #0xf\n\n            // Error if maxlen is 0:\n\n            cbz     x1, str.bufInit.bad\n\n            // Initialize the string struct fields:\n\n          ❻ str     xzr, [x2, #string.allocPtr] // NULL\n            str     w1,  [x2, #string.maxlen]\n            str     wzr, [x2, #string.len]      // Empty str\n            strb    wzr, [x2, #string.chars]    // 0 byte\n\n            mov     x0, x2      // Return str ptr in X0.\n\n            ldr     x2, [fp, #str_bufInit_l.saveX2]\n            adds    xzr, xzr, xzr     // Clear the carry flag.\n            leave\n\n// Error return (sets the carry flag):\n\nstr.bufInit.bad:\n            ldr     x2, [fp, #str_bufInit_l.saveX2]\n            cmp     x2, #0  // Set the carry flag.\n            leave\n            endp    str.bufInit\n```", "```\nadds    xzr, xzr, xzr\n```", "```\ncmp     x2, #0\n```", "```\n// Listing14-1.S (cont.)\n//\n// str.alloc\n//\n// Allocates storage for an assembly language string\n// object on the heap (C stdlib malloc heap)\n//\n// On entry:\n//\n//  W0- Maximum string length for string object\n//\n// On exit:\n//\n//  X0- Pointer to string object (NULL if error)\n//\n//  Carry clear if successful, set if error\n\n            proc    str.alloc\n\n            locals  str_alloc\n            dword   str_alloc.maxlen    // Really only a word\n            dword   str_alloc.saveX1\n            salign  4   // 16-byte align vsave\n          ❶ byte    str_alloc.vsave, volatile_save.size\n            byte    str_alloc.stkSpace, 64\n            endl    str_alloc\n\n enter   str_alloc.size\n\n            // Preserve X1 and point it at the\n            // volatile_save.x0x1 entry in str_alloc.vsave:\n\n            str     x1, [fp, #str_alloc.saveX1]\n\n            // Load X1 with the effective address of\n            // str_alloc.vsave (which will be the\n            // volatile_save.x0x1 element):\n\n          ❷ add     x1, fp, #str_alloc.vsave\n\n            // Preserve all the volatile registers (call to\n            // malloc may change these). Note that X1 is\n            // currently pointing at volatile_save.x0x1 in\n            // str_alloc.vsave (volatile_save). You don't know\n            // that you *have* to save all the registers (it's\n            // unlikely malloc will modify them all), but just\n            // to be safe ...\n\n            // The following code stores away X2, ..., X15 and\n            // V0..V15 in successive memory locations in the\n            // volatile_save structure. X1 was already preserved,\n            // and it returns the result in X0.\n\n          ❸ stp     x2,  x3,  [x1, #16]!\n            stp     x4,  x5,  [x1, #16]!\n            stp     x6,  x7,  [x1, #16]!\n            stp     x8,  x9,  [x1, #16]!\n            stp     x10, x11, [x1, #16]!\n            stp     x12, x13, [x1, #16]!\n            stp     x14, x15, [x1, #16]!\n\n            str     q0,  [x1, #16]!\n            str     q1,  [x1, #16]!\n            str     q2,  [x1, #16]!\n            str     q3,  [x1, #16]!\n            str     q4,  [x1, #16]!\n            str     q5,  [x1, #16]!\n            str     q6,  [x1, #16]!\n            str     q7,  [x1, #16]!\n            str     q8,  [x1, #16]!\n            str     q9,  [x1, #16]!\n            str     q10, [x1, #16]!\n            str     q11, [x1, #16]!\n            str     q12, [x1, #16]!\n            str     q13, [x1, #16]!\n            str     q14, [x1, #16]!\n            str     q15, [x1, #16]!\n\n            // Save maxlen value for now:\n\n            str     w0, [fp, #str_alloc.maxlen]\n\n // Force maxlen to be a multiple of 16 and\n            // add in 16 extra bytes so you can ensure\n            // that the storage is 16-byte aligned.\n            // Also add in the size of the string.struct\n            // fields:\n\n          ❹ add     x0, x0, #31 + (string.chars-string.allocPtr)\n            and     x0, x0, #0xffffffff // Fix at 32 bits.\n            bic     x0, x0, #0xf        // Force to multiple of 16.\n\n            // Call C stdlib malloc function to allocate the\n            // storage:\n\n          ❺ bl      malloc\n            cmp     x0, x0              // Set carry flag on error.\n            cbz     x0, str.alloc.bad   // Error if NULL return.\n\n            mov     x1, x0              // Save allocation pointer.\n\n            // Adjust pointer to point at start of characters\n            // in string struct and 16-byte align the pointer:\n\n          ❻ add     x0, x0, #15+(string.chars-string.allocPtr)\n            bic     x0, x0, #0xf\n\n            // Initialize the string struct fields:\n\n            str     x1,  [x0, #string.allocPtr] // Save alloc ptr.\n            ldr     w2,  [fp, #str_alloc.maxlen]\n            str     w2,  [x0, #string.maxlen]   // Save maxlen.\n            str     wzr, [x0, #string.len]      // Empty string.\n            strb    wzr, [x0, #string.chars]    // Zero terminator\n\n            // Restore all the volatile general-\n            // purpose registers:\n\n            adds    xzr, xzr, xzr   // Clear carry for success.\n\nstr.alloc.bad:\n\n            // Restore all the volatile registers.\n            // From this point forward, the code must\n            // not change the carry flag.\n\n          ❼ add     x1, fp, #str_alloc.vsave\n            ldp     x2,  x3,  [x1, #16]!\n            ldp     x4,  x5,  [x1, #16]!\n            ldp     x6,  x7,  [x1, #16]!\n            ldp     x8,  x9,  [x1, #16]!\n            ldp     x10, x11, [x1, #16]!\n            ldp     x12, x13, [x1, #16]!\n            ldp     x14, x15, [x1, #16]!\n\n ldr     q0,  [x1, #16]!\n            ldr     q1,  [x1, #16]!\n            ldr     q2,  [x1, #16]!\n            ldr     q3,  [x1, #16]!\n            ldr     q4,  [x1, #16]!\n            ldr     q5,  [x1, #16]!\n            ldr     q6,  [x1, #16]!\n            ldr     q7,  [x1, #16]!\n            ldr     q8,  [x1, #16]!\n            ldr     q9,  [x1, #16]!\n            ldr     q10, [x1, #16]!\n            ldr     q11, [x1, #16]!\n            ldr     q12, [x1, #16]!\n            ldr     q13, [x1, #16]!\n            ldr     q14, [x1, #16]!\n            ldr     q15, [x1, #16]!\n\n            ldr     x1, [fp, #str_alloc.saveX1]\n\n            leave\n            endp    str.alloc\n```", "```\n// Listing14-1.S (cont.)\n//\n// str.free\n//\n// Deallocates storage for an assembly language string\n// object that was previously allocated via str.alloc\n//\n// On entry:\n//\n//  W0- Pointer to string object to deallocate\n\n            proc    str.free\n\n            locals  str_free\n            dword   str_free.maxlen // Really a word\n            dword   str_free.saveX1\n            salign  4   // 16-byte align vsave\n            byte    str_free.vsave, volatile_save.size\n            byte    str_free.stkSpace,64\n            endl    str_free\n\n            enter   str_free.size\n\n            // Preserve X1:\n\n            str     x1, [fp, #str_free.saveX1]\n\n            // Load X1 with the effective address of\n            // str_alloc.vsave (which will be the\n            // volatile_save.x0x1 element):\n\n            add     x1, fp, #str_free.vsave\n\n            // Preserve all the volatile registers (call to free\n            // may change these):\n\n          ❶ stp     x2,  x3,  [x1, #16]!\n            stp     x4,  x5,  [x1, #16]!\n            stp     x6,  x7,  [x1, #16]!\n            stp     x8,  x9,  [x1, #16]!\n            stp     x10, x11, [x1, #16]!\n            stp     x12, x13, [x1, #16]!\n            stp     x14, x15, [x1, #16]!\n\n            str     q0,  [x1, #16]!\n            str     q1,  [x1, #16]!\n            str     q2,  [x1, #16]!\n            str     q3,  [x1, #16]!\n            str     q4,  [x1, #16]!\n            str     q5,  [x1, #16]!\n            str     q6,  [x1, #16]!\n            str     q7,  [x1, #16]!\n str     q8,  [x1, #16]!\n            str     q9,  [x1, #16]!\n            str     q10, [x1, #16]!\n            str     q11, [x1, #16]!\n            str     q12, [x1, #16]!\n            str     q13, [x1, #16]!\n            str     q14, [x1, #16]!\n            str     q15, [x1, #16]!\n\n            // Fetch the allocation pointer from the\n            // string struct data type:\n\n          ❷ ldr     x1, [x0, #string.allocPtr]\n\n            // Make sure it's not NULL (non-allocated\n            // pointer):\n\n          ❸ cbz     x1, str.free.done\n\n            // Defensive code, set the allocPtr field to\n            // NULL:\n\n            str     xzr, [x0, #string.allocPtr]\n\n            // Deallocate the storage:\n\n          ❹ mov     x0, x1\n            bl      free\n\nstr.free.done:\n\n            // Restore the volatile register before\n            // returning:\n\n            add     x1, fp, #str_free.vsave\n          ❺ ldp     x2,  x3,  [x1, #16]!\n            ldp     x4,  x5,  [x1, #16]!\n            ldp     x6,  x7,  [x1, #16]!\n            ldp     x8,  x9,  [x1, #16]!\n            ldp     x10, x11, [x1, #16]!\n            ldp     x12, x13, [x1, #16]!\n            ldp     x14, x15, [x1, #16]!\n\n            ldr     q0,  [x1, #16]!\n            ldr     q1,  [x1, #16]!\n            ldr     q2,  [x1, #16]!\n            ldr     q3,  [x1, #16]!\n            ldr     q4,  [x1, #16]!\n            ldr     q5,  [x1, #16]!\n            ldr     q6,  [x1, #16]!\n            ldr     q7,  [x1, #16]!\n            ldr     q8,  [x1, #16]!\n            ldr     q9,  [x1, #16]!\n            ldr     q10, [x1, #16]!\n ldr     q11, [x1, #16]!\n            ldr     q12, [x1, #16]!\n            ldr     q13, [x1, #16]!\n            ldr     q14, [x1, #16]!\n            ldr     q15, [x1, #16]!\n\n            ldr     x1, [fp, #str_free.saveX1]\n            leave\n            endp    str.free\n```", "```\n// Listing14-1.S (cont.)\n//\n// Some read-only strings:\n\nfmtStr:     wastr   \"hwStr=%s\"\nfmtStr2:    wastr   \"hwDynamic=%s\"\nfmtStr3:    wastr   \"strBufInit error\\n\"\n\n            str.literal hwLiteral, \"Hello, world!\\n\"\n\n///////////////////////////////////////////////////////////\n//\n// Main program to test the code:\n\n            proc    asmMain, public\n\n            locals  lcl\n            qword   hwStr\n            qword   hwDynamic\n            byte    hwBuffer, 256\n            byte    stkSpace, 64\n            endl    lcl\n\n enter   lcl.size      // Reserve space for locals.\n\n            // Demonstrate call to str.bufInit:\n\n            // Initialize hwBuffer as a string object and\n            // save pointer in hwStr:\n\n            add     x0, fp, #hwBuffer\n            mov     x1, #256    // Buffer size\n            bl      str.bufInit\n            str     x0, [fp, #hwStr]\n\n            // Force copy of hwLiteral into hwStr:\n\n            lea     x2, hwLiteral\n            ldr     w3, [x2, #string.len]   // Get length.\n            str     w3, [x0, #string.len]   // Save hwStr len.\n\n            // Cheesy string copy. You know the length is less\n            // than 16 bytes and both string objects have a\n            // minimum of 16 character locations available.\n\n            ldr     q0, [x2]    // Copy \"Hello, world!\\n\" string.\n            str     q0, [x0]\n\n            // Now, hwStr contains a copy of hwLiteral.\n            // Print hwStr (because the assembly language\n            // string format always includes a zero-terminating\n            // byte, you can just call printf to print the string).\n            // Note that X0 still contains the hwStr pointer.\n\n            mov     x1, x0\n            lea     x0, fmtStr\n            mstr    x1, [sp]\n            bl      printf\n\n            // Demonstrate call to str.alloc and str.free:\n\n            mov     x0, #256    // String size\n            bl      str.alloc\n            bcs     badAlloc\n            str     x0, [fp, #hwDynamic]\n\n            // Force copy of hwLiteral into hwDynamic:\n\n            lea     x2, hwLiteral\n            ldr     w3, [x2, #string.len]   // Get length.\n            str     w3, [x0, #string.len]   // Save hwDynamic len.\n\n            // Cheesy string copy. You know the length is less\n            // than 16 bytes and both string objects have a\n            // minimum of 16 character locations available.\n\n ldr     q0, [x2]    // Copy \"Hello, world!\\n\" string.\n            str     q0, [x0]\n\n            // Now hwDynamic contains a copy of hwLiteral.\n            // Print hwDynamic (because the assembly language\n            // string format always includes a zero-terminating\n            // byte, you can just call printf to print the string).\n            // Note that X0 still contains the hwDynamic pointer.\n\n            mov     x1, x0\n            lea     x0, fmtStr2\n            mstr    x1, [sp]\n            bl      printf\n\n            // Free the string storage:\n\n            ldr     x0, [fp, #hwDynamic]\n            bl      str.free\n\nAllDone:    leave\n\nbadAlloc:   lea     x0, fmtStr3\n            bl      printf\n            leave\n            endp    asmMain\n```", "```\n% ./build Listing14-1\n% ./Listing14-1\nCalling Listing14-1:\nhwStr=Hello, world!\nhwDynamic=Hello, world!\nListing14-1 terminated\n```", "```\n// Listing14-2.S\n//\n// A str.cpy string copy function\n\n            #include    \"aoaa.inc\"\n\n// Assembly language string data structure:\n\n            struct  string, -16\n            dword   string.allocPtr // At offset -16\n            word    string.maxlen   // At offset -8\n            word    string.len      // At offset -4\n            byte    string.chars    // At offset 0\n\n            // Note: characters in string occupy offsets\n            // 0 ... in this structure\n\n            ends    string\n\n// str.buf\n//\n// Allocate storage for an empty string\n// with the specified maximum size:\n\n            .macro  str.buf strName, maxSize\n            .align  4   // Align on 16-byte boundary.\n            .dword  0   // NULL ptr for allocation ptr\n            .word   \\maxSize\n            .word   0\n\\strName:   .space  ((\\maxSize+16) & 0xFFFFFFF0), 0\n            .endm\n\n// str.literal:\n//\n// Allocate storage for a string buffer and initialize\n// it with a string literal:\n\n            .macro  str.literal strName, strChars\n            .align  4   // Align on 16-byte boundary.\n            .dword  0   // NULL ptr for allocation ptr\n            .word   len_\\strName    // string.maxlen\n            .word   len_\\strName    // string.len\n\n // Emit the string data and compute the\n            // string's length:\n\n\\strName:   .ascii  \"\\strChars\"\nlen_\\strName=       .-\\strName\n            .byte   0   // Zero-terminating byte\n\n            // Ensure object is multiple of 16 bytes:\n\n            .align  4\n            .endm\n\n///////////////////////////////////////////////////////////\n\n            .data\n            str.buf     destination, 256\n            str.literal source, \"String to copy\"\n\n///////////////////////////////////////////////////////////\n\n            .code\n            .global malloc\n            .global free\n\nttlStr:     wastr  \"Listing14-2\"\n\n// Standard getTitle function\n// Returns pointer to program name in X0\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n///////////////////////////////////////////////////////////\n//\n// str.cpy\n//\n// Copies the data from one string variable to another.\n//\n// On entry:\n//\n//  X0- Pointer to source string (string struct variable)\n//  X1- Pointer to destination string\n//\n// On exit:\n//\n//  Carry flag clear if no errors; carry is set if\n//  the source string will not fit in the destination.\n\n            proc    str.cpy\n\n            locals  str_cpy\n            qword   str_cpy.saveV0\n qword   str_cpy.saveX2X3\n            dword   str_cpy.saveX4\n            byte    str_cpy.stkSpace,64 // Not actually needed\n            endl    str_cpy\n\n            enter   str_cpy.size\n\n            // Preserve X2 ... X4 and V0:\n\n            str     q0,     [fp, #str_cpy.saveV0]\n            stp     x2, x3, [fp, #str_cpy.saveX2X3]\n            str     x4,     [fp, #str_cpy.saveX4]\n\n            // Ensure the source will fit in the destination\n            // string object:\n\n          ❶ ldr     w4, [x0, #string.len]\n            ldr     w3, [x1, #string.maxlen]\n            cmp     w4, w3\n            bhi     str.cpy.done    // Note: carry is set.\n\n            // Set the length of the destination string\n            // to the length of the source string:\n\n          ❷ str     w4, [x1, #string.len]\n\n            // X4 contains the number of characters to copy.\n            // While this is greater than 16, copy 16 bytes\n            // at a time from source to dest:\n\n          ❸ mov     x2, x0  // Preserve X0 and X1.\n            mov     x3, x1\ncpy16:      ldr     q0, [x2], #16\n            str     q0, [x3], #16\n            subs    w4, w4, #16\n            bhi     cpy16\n\n// At this point, you have fewer than 16 bytes to copy. If\n// W4 is not 0, just copy 16 remaining bytes (you know,\n// because of the string data structure, that if you have at\n// least 1 byte left to copy, you can safely copy\n// 16 bytes):\n\n          ❹ beq     setZByte    // Skip if 0 bytes.\n\n            ldr     q0, [x2]\n            str     q0, [x3]\n\n// Need to add a zero-terminating byte to the end of\n// the string. Note that maxlen does not include the\n// 0 byte, so it's always safe to append the 0\n// byte to the end of the string.\n\nsetZByte:   ldr     w4,  [x0, #string.len]\n          ❺ strb    wzr, [x1, w4, uxtw]\n\n            adds    wzr, wzr, wzr   // Clears the carry\n\nstr.cpy.done:\n            ldr     q0,     [fp, #str_cpy.saveV0]\n            ldp     x2, x3, [fp, #str_cpy.saveX2X3]\n            ldr     x4,     [fp, #str_cpy.saveX4]\n            leave\n            endp    str.cpy\n\n///////////////////////////////////////////////////////////\n//\n// A read-only format string:\n\nfmtStr:     wastr   \"source='%s', destination='%s'\\n\"\n\n///////////////////////////////////////////////////////////\n//\n// Main program to test the code:\n\n            proc    asmMain, public\n\n            locals  lcl\n            byte    stkSpace, 64\n            endl    lcl\n\n            enter   lcl.size      // Reserve space for locals.\n\n            lea     x0, source\n            lea     x1, destination\n            bl      str.cpy\n\n            mov     x2, x1\n            mov     x1, x0\n            lea     x0, fmtStr\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\nAllDone:    leave\n            endp    asmMain\n```", "```\n% ./build Listing14-2\n% ./Listing14-2\nCalling Listing14-2:\nsource='String to copy', destination='String to copy'\nListing14-2 terminated\n```", "```\ncmpLp:\n    ldrb w2, [x0], #1\n    ldrb w3, [x1], #1\n    cmp  w2, w3\n    bne  strNE\n    cbnz w2, cmpLp\n\n// At this point, the strings are equal.\n    .\n    .\n    .\nstrNE:\n    // At this point, the strings are not equal.\n```", "```\n// Listing14-3.S\n//\n// GNU glibc strcmp function\n//\n// Copyright (C) 2013 ARM Ltd.\n// Copyright (C) 2013 Linaro.\n//\n// This code is based on glibc cortex strings work originally\n// authored by Linaro and relicensed under GPLv2 for the\n// Linux kernel. The original code can be found @\n//\n// http://bazaar.launchpad.net/~linaro-toolchain-dev/\n// cortex-strings/trunk/\n//\n// files/head:/src/aarch64/\n//\n// This program is free software; you can redistribute it\n// and/or modify it under the terms of the GNU General Public\n// License version 2 as published by the Free Software\n// Foundation.\n//\n// This program is distributed in the hope that it will be\n// useful, but WITHOUT ANY WARRANTY; without even the implied\n// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n// PURPOSE. See the GNU General Public License for more\n// details.\n//\n// You should have received a copy of the GNU General Public\n// License along with this program. If not, see\n// <http://www.gnu.org/licenses/>.\n\n#include <linux/linkage.h>\n#include <asm/assembler.h>\n\n// Compare two strings\n//\n// Parameters:\n//  X0 - Const string 1 pointer\n//  X1 - Const string 2 pointer\n//\n// Returns:\n//  X0 - An integer less than, equal to, or greater\n//       than zero if S1 is found, respectively, to be\n//       less than, to match, or to be greater than S2\n\n#define REP8_01 0x0101010101010101\n#define REP8_7f 0x7f7f7f7f7f7f7f7f\n#define REP8_80 0x8080808080808080\n\n// Parameters and result\n\nsrc1        .req    x0\nsrc2        .req    x1\nresult      .req    x0\n\n// Internal variables\n\ndata1       .req    x2\ndata1w      .req    w2\ndata2       .req    x3\ndata2w      .req    w3\nhas_nul     .req    x4\ndiff        .req    x5\nsyndrome    .req    x6\ntmp1        .req    x7\ntmp2        .req    x8\ntmp3        .req    x9\nzeroones    .req    x10\npos         .req    x11\n\nstrcmp:\n    eor tmp1, src1, src2\n    mov zeroones, #REP8_01\n    tst tmp1, #7\n    b.ne    .Lmisaligned8\n    ands    tmp1, src1, #7\n    b.ne    .Lmutual_align\n\n// NUL detection works on the principle that (X - 1) &\n// (~X) & 0x80 (=> (X - 1) & ~(X | 0x7f)) is nonzero if\n// a byte is 0, and can be done in parallel across the\n// entire word.\n\n.Lloop_aligned:\n    ldr data1, [src1], #8\n    ldr data2, [src2], #8\n.Lstart_realigned:\n    sub tmp1, data1, zeroones\n    orr tmp2, data1, #REP8_7f\n    eor diff, data1, data2  // Nonzero if differences found\n    bic has_nul, tmp1, tmp2 // Nonzero if NUL terminator\n    orr syndrome, diff, has_nul\n    cbz syndrome, .Lloop_aligned\n    b   .Lcal_cmpresult\n.Lmutual_align:\n\n// Sources are mutually aligned but are not currently at\n// an alignment boundary. Round down the addresses and\n// then mask off the bytes that precede the start point:\n\n    bic src1, src1, #7\n    bic src2, src2, #7\n    lsl tmp1, tmp1, #3  // Bytes beyond alignment -> bits\n    ldr data1, [src1], #8\n    neg tmp1, tmp1      // (Bits to align) - 64\n    ldr data2, [src2], #8\n    mov tmp2, #~0\n\n    lsr tmp2, tmp2, tmp1 // Shift (tmp1 & 63)\n    orr data1, data1, tmp2\n    orr data2, data2, tmp2\n b   .Lstart_realigned\n.Lmisaligned8:\n\n// Get the align offset length to compare per byte first.\n// After this process, one string's address will be\n// aligned.\n\n    and     tmp1, src1, #7\n    neg     tmp1, tmp1\n    add     tmp1, tmp1, #8\n    and     tmp2, src2, #7\n    neg     tmp2, tmp2\n    add     tmp2, tmp2, #8\n    subs    tmp3, tmp1, tmp2\n    csel    pos, tmp1, tmp2, hi // Choose the maximum.\n.Ltinycmp:\n    ldrb    data1w, [src1], #1\n    ldrb    data2w, [src2], #1\n    subs    pos, pos, #1\n    ccmp    data1w, #1, #0, ne      // NZCV = 0b0000\n    ccmp    data1w, data2w, #0, cs  // NZCV = 0b0000\n    b.eq    .Ltinycmp\n    cbnz    pos, 1f  // Find the null or unequal ...\n    cmp     data1w, #1\n    ccmp    data1w, data2w, #0, cs\n    b.eq    .Lstart_align  // The last bytes are equal.\n1:\n    sub result, data1, data2\n    ret\n.Lstart_align:\n    ands    xzr, src1, #7\n    b.eq    .Lrecal_offset\n\n    // Process more leading bytes to make str1 aligned:\n\n    add src1, src1, tmp3\n    add src2, src2, tmp3\n\n    // Load 8 bytes from aligned str1 and nonaligned str2:\n\n    ldr data1, [src1], #8\n    ldr data2, [src2], #8\n    sub tmp1, data1, zeroones\n    orr tmp2, data1, #REP8_7f\n    bic has_nul, tmp1, tmp2\n    eor diff, data1, data2 // Nonzero if differences found\n    orr syndrome, diff, has_nul\n    cbnz    syndrome, .Lcal_cmpresult\n\n    // How far is the current str2 from the alignment boundary?\n\n    and tmp3, tmp3, #7\n.Lrecal_offset:\n    neg pos, tmp3\n.Lloopcmp_proc:\n\n// Divide the 8 bytes into two parts. First, adjust the src\n// to the previous alignment boundary, load 8 bytes from\n// from the SRC2 alignment boundary, then compare with the\n// relative bytes from SRC1\\. If all 8 bytes are equal,\n// start the second part's comparison. Otherwise, finish\n// the comparison. This special handle can guarantee all\n// the accesses are in the thread/task space in order to\n// avoid overrange access.\n\n    ldr data1, [src1,pos]\n    ldr data2, [src2,pos]\n    sub tmp1, data1, zeroones\n    orr tmp2, data1, #REP8_7f\n    bic has_nul, tmp1, tmp2\n    eor diff, data1, data2  // Nonzero if differences found\n    orr syndrome, diff, has_nul\n    cbnz    syndrome, .Lcal_cmpresult\n\n    // The second part of the process:\n\n    ldr data1, [src1], #8\n    ldr data2, [src2], #8\n    sub tmp1, data1, zeroones\n    orr tmp2, data1, #REP8_7f\n    bic has_nul, tmp1, tmp2\n    eor diff, data1, data2  // Nonzero if differences found\n    orr syndrome, diff, has_nul\n    cbz syndrome, .Lloopcmp_proc\n.Lcal_cmpresult:\n\n// Reverse the byte order as big-endian, so CLZ can find\n// the most significant 0 bits:\n\n    rev syndrome, syndrome\n    rev data1, data1\n    rev data2, data2\n\n    clz pos, syndrome\n\n// The MS-nonzero bit of the syndrome marks either the\n// first bit that is different or the top bit of the\n// first 0 byte. Shifting left now will bring the\n// critical information into the top bits.\n\n    lsl data1, data1, pos\n    lsl data2, data2, pos\n\n// But you need to zero-extend (char is unsigned) the value\n// and then perform a signed 32-bit subtraction:\n\n    lsr data1, data1, #56\n    sub result, data1, data2, lsr #56\n    ret\n```", "```\n// Listing14-4.S\n//\n// A str.cmp string comparison function\n\n            #include    \"aoaa.inc\"\n\n// Assembly language string data structure:\n\n            struct  string, -16\n            dword   string.allocPtr // At offset -16\n            word    string.maxlen   // At offset -8\n            word    string.len      // At offset -4\n            byte    string.chars    // At offset 0\n\n            // Note: characters in string occupy offsets\n            // 0 ... in this structure.\n\n            ends    string\n\n// str.buf\n//\n// Allocate storage for an empty string\n// with the specified maximum size:\n\n            .macro  str.buf strName, maxSize\n            .align  4   // Align on 16-byte boundary.\n            .dword  0   // NULL ptr for allocation ptr\n            .word   \\maxSize\n            .word   0\n\\strName:   .space  ((\\maxSize+16) & 0xFFFFFFF0), 0\n            .endm\n\n// str.literal\n//\n// Allocate storage for a string buffer and initialize\n// it with a string literal:\n\n            .macro  str.literal strName, strChars\n            .align  4   // Align on 16-byte boundary.\n            .dword  0   // NULL ptr for allocation ptr\n            .word   len_\\strName    // string.maxlen\n            .word   len_\\strName    // string.len\n\n // Emit the string data and compute the\n            // string's length:\n\n\\strName:   .ascii  \"\\strChars\"\nlen_\\strName=       .-\\strName\n            .byte   0   // Zero-terminating byte\n\n            // Ensure object is multiple of 16 bytes:\n\n            .align  4\n            .endm\n\n///////////////////////////////////////////////////////////\n\n            .data\n            str.buf     destination, 256\n            str.literal left,   \"some string\"\n            str.literal right1, \"some string\"\n            str.literal right2, \"some string.\"\n            str.literal right3, \"some string\"\n            str.literal right4, \"\"\n            str.literal right5, \"t\"\n            str.literal right6, \" \"\n\n            str.literal left2,  \"some string 16..\"\n            str.literal right7, \"some string 16..\"\n            str.literal right8, \"some string 16.\"\n            str.literal right9, \"some string 16...\"\n\n///////////////////////////////////////////////////////////\n\n            .code\n            .global malloc\n            .global free\n\nttlStr:     wastr   \"Listing14-4\"\n\n// Standard getTitle function\n// Returns pointer to program name in X0\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n///////////////////////////////////////////////////////////\n//\n// str.cmp\n//\n// Compares two string objects\n//\n// On entry:\n//\n//  X0- Pointer to left string\n//  X1- Pointer to right string\n//\n//      left op right\n//\n//  Where op is the string comparison operation\n//\n// On exit:\n//\n//  Condition code flags contain state of comparison\n\n            proc    str.cmp\n\n            locals  str_cmp\n            qword   str_cmp.saveX2X3\n            dword   str_cmp.saveX4X5\n            dword   str_cmp.saveX6X7\n            byte    str_cmp.stkSpace,64\n            endl    str_cmp\n\n            enter   str_cmp.size\n\n            // Preserve X2 ... X7:\n\n          ❶ stp     x2, x3, [fp, #str_cmp.saveX2X3]\n            stp     x4, x5, [fp, #str_cmp.saveX4X5]\n            stp     x6, x7, [fp, #str_cmp.saveX6X7]\n\n            mov     x2, x0  // Preserve X0 and X1.\n            mov     x3, x1\n\n            // Compute the minimum of the string lengths:\n\n          ❷ ldr     w6, [x2, #string.len]\n            ldr     w7, [x3, #string.len]\n            cmp     w6, w7\n            csel    w6, w6, w7, hs\n            b.al    cmpLen\n\ncmp8:\n          ❸ ldr     x4, [x2], #8\n            ldr     x5, [x3], #8\n            rev     x4, x4\n            rev     x5, x5\n            cmp     x4, x5\n            bne     str.cmp.done\ncmpLen:\n          ❹ subs    w6, w6, #8      // Also compares W6 to 8\n            bhs     cmp8\n\n            // Fewer than eight characters left (and more\n            // than zero). Cheapest to just compare them\n            // one at a time:\n\n          ❺ adds    w6, w6, #8\n            beq     str.cmp.done  // If lens are equal\n\ncmp1:\n          ❻ ldrb    w4, [x2], #1\n            ldrb    w5, [x3], #1\n            cmp     w4, w5\n            bne     str.cmp.done\n            subs    w6, w6, #1\n            bne     cmp1\n\n            // At this point, the strings are equal\n            // through the length of the shorter\n            // string. The comparison is thus based\n            // on the result of comparing the lengths\n            // of the two strings.\n\ncmpLens:\n          ❼ ldr     w6, [x0, #string.len]   // Fetch left len.\n            cmp     w6, w7                  // Right len\n\nstr.cmp.done:\n            ldp     x2, x3, [fp, #str_cmp.saveX2X3]\n            ldp     x4, x5, [fp, #str_cmp.saveX4X5]\n            ldp     x6, x7, [fp, #str_cmp.saveX6X7]\n            leave\n            endp    str.cmp\n\n///////////////////////////////////////////////////////////\n//\n// Some read-only strings:\n\nltFmtStr:   wastr   \"Left ('%s') is less than right ('%s')\\n\"\ngtFmtStr:   wastr   \"Left ('%s') is greater than right ('%s')\\n\"\neqFmtStr:   wastr   \"Left ('%s') is equal to right ('%s')\\n\"\n\n///////////////////////////////////////////////////////////\n//\n// prtResult\n//\n// Utility function to print the result of a string\n// comparison\n\n          ❽ proc    prtResult\n\n            mov     x2, x1\n            mov     x1, x0\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            beq     strsEQ\n            bhi     strGT\n\n            // Must be LT at this point\n\n            lea     x0, ltFmtStr\n            b       printf\n\nstrsEQ:     lea     x0, eqFmtStr\n            b       printf\n\nstrGT:      lea     x0, gtFmtStr\n            b       printf\n\n            endp    prtResult\n\n///////////////////////////////////////////////////////////\n//\n// Main program to test the code:\n\n            proc    asmMain, public\n\n            locals  lcl\n            byte    stkSpace, 64\n            endl    lcl\n\n            enter   lcl.size      // Reserve space for locals.\n\n            lea     x0, left\n            lea     x1, right1\n            bl      str.cmp\n            bl      prtResult\n\n            lea     x0, left\n            lea     x1, right2\n            bl      str.cmp\n            bl      prtResult\n\n            lea     x0, left\n            lea     x1, right3\n            bl      str.cmp\n            bl      prtResult\n\n            lea     x0, left\n            lea     x1, right4\n            bl      str.cmp\n            bl      prtResult\n\n            lea     x0, left\n            lea     x1, right5\n            bl      str.cmp\n            bl      prtResult\n\n            lea     x0, left\n            lea     x1, right6\n            bl      str.cmp\n            bl      prtResult\n\n            lea     x0, left2\n            lea     x1, right7\n            bl      str.cmp\n            bl      prtResult\n\n lea     x0, left2\n            lea     x1, right8\n            bl      str.cmp\n            bl      prtResult\n\n            lea     x0, left2\n            lea     x1, right9\n            bl      str.cmp\n            bl      prtResult\n\nAllDone:    leave\n            endp    asmMain\n```", "```\nif(leftStr <= rightStr) then ...\n```", "```\n% ./build Listing14-4\n% ./Listing14-4\nCalling Listing14-4:\nLeft ('some string') is equal to right ('some string')\nLeft ('some string') is less than right ('some string.')\nLeft ('some string') is greater than right ('some string')\nLeft ('some string') is greater than right ('')\nLeft ('some string') is less than right ('t')\nLeft ('some string') is greater than right (' ')\nLeft ('some string 16..') is equal to right ('some string 16..')\nLeft ('some string 16..') is greater than right ('some string 16.')\nLeft ('some string 16..') is less than right ('some string 16..')\nListing14-4 terminated\n```", "```\n// Listing14-5.S\n//\n// A str.substr substring function\n\n #include    \"aoaa.inc\"\n\n// Assembly language string data structure:\n\n            struct  string, -16\n            dword   string.allocPtr // At offset -16\n            word    string.maxlen   // At offset -8\n            word    string.len      // At offset -4\n            byte    string.chars    // At offset 0\n\n            // Note: characters in string occupy offsets\n            // 0 ... in this structure\n\n            ends    string\n\n// str.buf\n//\n// Allocate storage for an empty string\n// with the specified maximum size:\n\n            .macro  str.buf strName, maxSize\n            .align  4   // Align on 16-byte boundary.\n            .dword  0   // NULL ptr for allocation ptr\n            .word   \\maxSize\n            .word   0\n\\strName:   .space  ((\\maxSize+16) & 0xFFFFFFF0), 0\n            .endm\n\n// str.literal\n//\n// Allocate storage for a string buffer and initialize\n// it with a string literal:\n\n            .macro  str.literal strName, strChars\n            .align  4   // Align on 16-byte boundary.\n            .dword  0   // NULL ptr for allocation ptr\n            .word   len_\\strName    // string.maxlen\n            .word   len_\\strName    // string.len\n\n            // Emit the string data and compute the\n            // string's length:\n\n\\strName:   .ascii  \"\\strChars\"\nlen_\\strName=       .-\\strName\n            .byte   0   // Zero-terminating byte\n\n            // Ensure object is multiple of 16 bytes:\n\n            .align  4\n            .endm\n\n///////////////////////////////////////////////////////////\n\n .data\nfmtStr:     .ascii      \"Source string:\\n\\n\"\n            .ascii      \"          1111111111222222222233333\\n\"\n            .ascii      \"01234567890123456789012345678901234\\n\"\n            .asciz      \"%s\\n\\n\"\n\n            str.buf     smallDest, 32\n            str.literal dest,   \"Initial destination string\"\n\n//                             1111111111222222222233333\n//                   01234567890123456789012345678901234\nstr.literal source, \"Hello there, world! How's it going?\"\n\n///////////////////////////////////////////////////////////\n\n            .code\n\nttlStr:     wastr  \"listing14-5\"\n\n// Standard getTitle function\n// Returns pointer to program name in X0\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n///////////////////////////////////////////////////////////\n//\n// str.substr\n//\n// Extracts a substring\n//\n// On entry:\n//\n//  X0- Pointer to source string\n//  W1- Starting index into source string\n//  W2- Length of substring\n//  X3- Destination string\n//\n// On exit:\n//\n//  Carry clear on success and result stored at X3\n//\n//  If the substring will not fit in X3, return with\n//  the carry set (and no data copied).\n\n            proc    str.substr\n\n            locals  str_substr\n            qword   str_substr.saveV0\n            qword   str_substr.saveX0X1\n            qword   str_substr.saveX2X3\n            qword   str_substr.saveX6X7\n byte    str_substr.stkSpace,64  // Not needed\n            endl    str_substr\n\n            enter   str_substr.size\n\n            // Preserve X0 ... X7 and V0:\n\n            str     q0,     [fp, #str_substr.saveV0]\n            stp     x0, x1, [fp, #str_substr.saveX0X1]\n            stp     x2, x3, [fp, #str_substr.saveX2X3]\n            stp     x6, x7, [fp, #str_substr.saveX6X7]\n\n            // Handle the exceptional conditions:\n            //\n            // 1\\. Index >= source.len   (return empty string)\n\n          ❶ ldr     w6, [x0, #string.len]\n            cmp     w1, w6\n            bhs     returnEmpty\n\n            // 2\\. Index + substr length > source length\n            // If so, reduce the length to match the end\n            // of the string:\n\n          ❷ add     w7, w1, w2      // W7 = index + substr length\n            cmp     w6, w7\n            csel    w6, w6, w7, ls  // W6 = min(source len, sum)\n            sub     w6, w6, w1      // W6 = actual length\n\n            // 3\\. Substr length > destination maxlen\n            //    (fail):\n\n          ❸ ldr     w7, [x3, #string.maxlen]\n            cmp     w6, w7          // Carry set if\n            bhi     str.sub.exit    // W6 >= W7.\n\n            // At this point, W6 contains the actual number of\n            // characters to copy from the source\n            // to the destination. This could be less than the\n            // length passed in W2 if the index + substr length\n            // exceeded the length of the source string.\n\n          ❹ str     w6, [x3, #string.len]   // Save as dest len.\n\n            // Point X0 at the first character of the substring\n            // to copy to the destination string (base address\n            // plus starting index):\n\n          ❺ add     x0, x0, w1, uxtw\n            b.al    test16\n\n // Copy the substring 16 bytes at a time:\n\ncopy16:\n          ❻ ldr     q0, [x0], #16   // Get bytes to copy.\n            str     q0, [x3], #16   // Store into dest.\n\n            // Decrement the number of characters to copy by\n            // 16\\. Quit if the result is negative (meaning\n            // fewer than 16 characters were left to\n            // copy). Remember, subs sets the flags the same\n            // as cmp, so the following compares the value in\n            // W6 against 16 and branches to copy16 if\n            // 16 or more characters are left to copy:\ntest16:\n            subs    w6, w6, #16\n            bhs     copy16\n\n            // W6 has gone negative. Need to add 16 to determine\n            // the number of bytes left to copy:\n\n          ❼ add     w6, w6, #16     // Now W6 contains 0 to 15.\n\n            // Switch statement based on the number of characters\n            // left to copy in the substring. Handle as a special\n            // case each of the 0 ... 15 bytes to copy:\n\n            and     x6, x6, #0xFFFFFFFF  // Zero-extend to 64 bits.\n            adr     x7, JmpTbl\n            ldr     w6, [x7, x6, lsl #2] // *4 for 32-bit entries\n            add     x7, x7, w6, sxtw     // Sign-extend to 64 bits.\n            br      x7\n\nJmpTbl:     .word   str.sub.success-JmpTbl  // _0bytesToCopy\n            .word   _1byteToCopy-JmpTbl\n            .word   _2bytesToCopy-JmpTbl\n            .word   _3bytesToCopy-JmpTbl\n            .word   _4bytesToCopy-JmpTbl\n            .word   _5bytesToCopy-JmpTbl\n            .word   _6bytesToCopy-JmpTbl\n            .word   _7bytesToCopy-JmpTbl\n            .word   _8bytesToCopy-JmpTbl\n            .word   _9bytesToCopy-JmpTbl\n            .word   _10bytesToCopy-JmpTbl\n            .word   _11bytesToCopy-JmpTbl\n            .word   _12bytesToCopy-JmpTbl\n            .word   _13bytesToCopy-JmpTbl\n            .word   _14bytesToCopy-JmpTbl\n            .word   _15bytesToCopy-JmpTbl\n\n// Special case copying 1-15 bytes:\n\n❽ _14bytesToCopy:\n            ldr     x7, [x0], #8\n            str     x7, [x3], #8\n_6bytesToCopy:\n            ldr     w7, [x0], #4\n            str     w7, [x3], #4\n\n_2bytesToCopy:\n            ldrh    w7, [x0], #2\n            strh    w7, [x3], #2\n            b.al    str.sub.success\n\n_13bytesToCopy:\n            ldr     x7, [x0], #8\n            str     x7, [x3], #8\n\n_5bytesToCopy:\n            ldr     w7, [x0], #4\n            str     w7, [x3], #4\n            ldrb    w7, [x0], #1\n            strb    w7, [x3], #1\n            b.al    str.sub.success\n\n_12bytesToCopy:\n            ldr     x7, [x0], #8\n            str     x7, [x3], #8\n\n_4bytesToCopy:\n            ldr     w7, [x0], #4\n            str     w7, [x3], #4\n            b.al    str.sub.success\n\n_11bytesToCopy:\n            ldr     x7, [x0], #8\n            str     x7, [x3], #8\n            ldrh    w7, [x0], #2\n            strh    w7, [x3], #2\n            ldrb    w7, [x0], #1\n            strb    w7, [x3], #1\n            b.al    str.sub.success\n\n_10bytesToCopy:\n            ldr     x7, [x0], #8\n            str     x7, [x3], #8\n            ldrh    w7, [x0], #2\n            strh    w7, [x3], #2\n            b.al    str.sub.success\n\n_9bytesToCopy:\n            ldr     x7, [x0], #8\n            str     x7, [x3], #8\n            ldrb    w7, [x0], #1\n            strb    w7, [x3], #1\n            b.al    str.sub.success\n\n_8bytesToCopy:\n            ldr     x7, [x0], #8\n            str     x7, [x3], #8\n            b.al    str.sub.success\n\n_15bytesToCopy:\n            ldr     x7, [x0], #8\n            str     x7, [x3], #8\n\n_7bytesToCopy:\n            ldr     w7, [x0], #4\n            str     w7, [x3], #4\n\n_3bytesToCopy:\n            ldrh    w7, [x0], #2\n            strh    w7, [x3], #2\n\n_1byteToCopy:\n            ldrb    w7, [x0], #1\n            strb    w7, [x3], #1\n\n// Branch here after copying all string data.\n// Need to add a zero-terminating byte to the\n// end of the destination string:\n\nstr.sub.success:\n          ❾ strb    wzr, [x3]       // Zero-terminating byte\n            adds    wzr, wzr, wzr   // Clear carry for success.\n\nstr.sub.exit:\n            ldr     q0,     [fp, #str_substr.saveV0]\n            ldp     x0, x1, [fp, #str_substr.saveX0X1]\n            ldp     x2, x3, [fp, #str_substr.saveX2X3]\n            ldp     x6, x7, [fp, #str_substr.saveX6X7]\n            leave\n\n// Special case where the code just returns an empty string:\n\nreturnEmpty:\n          ❿ strh    wzr, [x3, #string.len]\n            b.al    str.sub.success\n\n            endp    str.substr\n\n///////////////////////////////////////////////////////////\n//\n// testSubstr\n//\n//  Utility function to test call to str.substr\n//\n// On entry:\n//  X0, X1, X2, X3 -- str.substr parameters\n\nsuccessStr: wastr   \"substr('%s', %2d, %3d)= '%s'\\n\"\nfailureStr: wastr   \"substr('%s', %2d, %3d) failed\\n\"\n\n            proc    testSubstr\n\n            locals  testSS\n            byte    testSS.stkspace, 64\n            endl    testSS\n\n enter   testSS.size\n\n            lea     x5, successStr\n            bl      str.substr\n            bcc     success\n            lea     x5, failureStr\n\nsuccess:\n            mov     x4, x3\n            mov     x3, x2\n            mov     x2, x1\n            mov     x1, x0\n            mov     x0, x5\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            mstr    x3, [sp, #16]\n            mstr    x4, [sp, #24]\n            bl      printf\n            leave\n            endp    testSubstr\n\n///////////////////////////////////////////////////////////\n//\n// Main program to test the code:\n\n            proc    asmMain, public\n\n            locals  lcl\n            byte    stkSpace, 64\n            endl    lcl\n\n            enter   lcl.size      // Reserve space for locals.\n\n            lea     x0, fmtStr\n            lea     x1, source\n            mstr    x1, [sp]\n            bl      printf\n\n            lea     x0, source\n            mov     x1, #0\n            mov     x2, #11\n            lea     x3, dest\n            bl      testSubstr\n\n            lea     x0, source\n            mov     x1, #20\n            mov     x2, #15\n            lea     x3, dest\n            bl      testSubstr\n\n            lea     x0, source\n            mov     x1, #20\n            mov     x2, #20\n            lea     x3, dest\n            bl      testSubstr\n\n lea     x0, source\n            mov     x1, #40\n            mov     x2, #20\n            lea     x3, dest\n            bl      testSubstr\n\n            lea     x0, source\n            mov     x1, #0\n            mov     x2, #100\n            lea     x3, smallDest\n            bl      testSubstr\n\nAllDone:    leave\n            endp    asmMain\n```", "```\n% ./build Listing14-5\n% ./Listing14-5\nCalling Listing14-5:\nSource string:\n\n          1111111111222222222233333\n01234567890123456789012345678901234\nHello there, world! How's it going?\n\nsubstr('Hello there, world! How's it going?',  0,  11)= 'Hello there'\nsubstr('Hello there, world! How's it going?', 20,  15)= 'How's it going?'\nsubstr('Hello there, world! How's it going?', 20,  20)= 'How's it going?'\nsubstr('Hello there, world! How's it going?', 40,  20)= ''\nsubstr('Hello there, world! How's it going?',  0, 100) failed\nListing14-5 terminated\n```", "```\nimport Foundation\nlet eAccent  :String = \"e\\u{301}\"\nprint(eAccent)\nprint(\"eAccent.count=\\(eAccent.count)\")\nprint(\"eAccent.utf16.count=\\(eAccent.utf16.count)\")\n```", "```\nimport Foundation\nlet eAccent  :String = \"\\u{E9}\"\nprint(eAccent)\nprint(\"eAccent.count=\\(eAccent.count)\")\nprint(\"eAccent.utf16.count=\\(eAccent.utf16.count)\")\n```", "```\né\neAccent.count=1\neAccent.utf16.count=1\n```", "```\nlet eAccent1 :String = \"\\u{E9}\"\nlet eAccent2 :String = \"e\\u{301}\"\n```", "```\nlet chars: [Character] = [\n    \"\\u{1ECD}\\u{300}\",\n    \"\\u{F2}\\u{323}\",\n    \"\\u{6F}\\u{323}\\u{300}\",\n]\nprint(chars)\n```", "```\nprint(\"\\u{1ECD} + \\u{300} = \\u{1ECD}\\u{300}\")\nprint(\"\\u{F2} + \\u{323} = \\u{F2}\\u{323}\")\nprint(\"\\u{6F} + \\u{323} + \\u{300} = \\u{6F}\\u{323}\\u{300}\")\nprint(\"\\u{6F} + \\u{300} + \\u{323} = \\u{6F}\\u{300}\\u{323}\")\nprint(chars[0] == chars[1]) // Outputs true.\nPrint(chars[0] == chars[2]) // Outputs true.\nprint(chars[0] == chars[3]) // Outputs true.\nPrint(chars[1] == chars[2]) // Outputs true.\nprint(chars[1] == chars[3]) // Outputs true.\nPrint(chars[2] == chars[3]) // Outputs true.\n```", "```\nsetlocale(LC_ALL, \"en_US.UTF-8\");\n```", "```\nlocale -a\n```", "```\nC                   en_NZ.ISO8859-1     it_IT\nPOSIX               en_NZ.ISO8859-15    it_IT.ISO8859-1\naf_ZA               en_NZ.US-ASCII      it_IT.ISO8859-15\naf_ZA.ISO8859-1     en_NZ.UTF-8         it_IT.UTF-8\naf_ZA.ISO8859-15    en_US               ja_JP\n\n`Many entries snipped ...`\n\nzh_TW.Big5\nzh_TW.UTF-8\n```", "```\n// c-utf8.cpp\n//\n// (Rename to c.cpp to use with build script.)\n//\n// Generic C++ driver program to demonstrate returning function\n// results from assembly language to C++. Also includes a\n// \"readLine\" function that reads a string from the user and\n// passes it on to the assembly language code.\n//\n// Need to include stdio.h so this program can call \"printf\"\n// and stdio.h so this program can call strlen.\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <locale.h>\n\n// extern \"C\" namespace prevents \"name mangling\" by the C++\n// compiler.\n\nextern \"C\"\n{\n    // asmMain is the assembly language code's \"main program\":\n\n    void asmMain(void);\n\n    // getTitle returns a pointer to a string of characters\n    // from the assembly code that specifies the title of that\n    // program (which makes this program generic and usable\n    // with a large number of sample programs in \"The Art of\n    // ARM Assembly Language\").\n\n    char *getTitle(void);\n\n    // C++ function that the assembly\n    // language program can call:\n\n    int readLine(char *dest, int maxLen);\n\n};\n\n// readLine reads a line of text from the user (from the\n// console device) and stores that string into the destination\n// buffer the first argument specifies. Strings are limited in\n// length to the value specified by the second argument\n// (minus 1).\n//\n// This function returns the number of characters actually\n// read, or -1 if there was an error.\n//\n// Note that if the user enters too many characters (maxlen or\n// more), this function returns only the first maxlen - 1\n// characters. This is not considered an error.\n\nint readLine(char *dest, int maxLen)\n{\n    // Note: fgets returns NULL if there was an error, else\n    // it returns a pointer to the string data read (which\n    // will be the value of the dest pointer).\n\n    char *result = fgets(dest, maxLen, stdin);\n    if(result != NULL)\n    {\n        // Wipe out the newline character at the\n        // end of the string:\n\n        int len = strlen(result);\n        if(len > 0)\n        {\n            dest[len - 1] = 0;\n        }\n return len;\n    }\n    return -1; // If there was an error\n}\n\nint main(void)\n{\n    // Get the assembly language program's title:\n\n    char *title = getTitle();\n\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n    asmMain();\n    printf(\"%s terminated\\n\", title);\n}\n```", "```\n// Listing14-6.S\n//\n// Simple program to demonstrate UTF-8 output\n\n            #include    \"aoaa.inc\"\n\n            .data\nfmtStr:     .ascii  \"Unicode='\"\n\n            // e followed by U+301 (0xCC, 0x81 in UTF-8)\n\n            .ascii  \"e\"\n            .byte   0xCC, 0x81\n\n            .asciz  \"'\\n\"\n\n            .code\nttlStr:     wastr  \"Listing14-6.S\"\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n            proc    asmMain, public\n\n            locals  lcl\n            qword   saveX20_X21\n            byte    stkSpace, 64\n            endl    lcl\n\n            enter   lcl.size      // Reserve space for locals.\n\n lea     x0, fmtStr\n            bl      printf\n\nAllDone:    leave\n            endp    asmMain\n```", "```\n1 1 0 b11 b10 b9 b8 b7,    1 0 b6 b5 b4 b3 b2 b1 b0\n```", "```\n% ./build Listing14-6\n% ./Listing14-6\nUnicode='é'\nListing14-6.S terminated\n```"]