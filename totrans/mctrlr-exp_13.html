<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2a" id="ch13"><span epub:type="pagebreak" id="page_131"/><strong>13  Basics of Glitching</strong></h2>&#13;
<p class="noindent">Dear reader, please indulge me in a little mythology. After that, we’ll move on to modern clock and voltage glitching attacks.</p>&#13;
<p class="indent">Way back in the good old days, so the story says, a satellite TV smart card was vulnerable to memory corruption. The people did rejoice, as a memory corruption exploit was sufficient to unlock all of the channels and extract all of the card’s memory. Then from the heavens came a message—an EEPROM update, rather than a prophecy—and the cards were patched to spin in an infinite loop rather than decode Captain Picard’s latest fight with the Borg. The exact patch and the exact card are lost to time, but in C we might say the code looked something like the following.</p>&#13;
<div class="imagel"><img src="../images/f0131-01.jpg" alt="Image" width="811" height="163"/></div>&#13;
<p class="indent">Because the card spins in an infinite loop rather than doing its job, pirates called it “looped.” From this they invented “unlooping,” the technique of messing with the card’s voltage or clock to jump out of the infinite loop. Today we call these techniques “fault injection” or “glitching,” and they are still brutally effective at removing protections from chips.</p>&#13;
<p class="indent">The trick is to very briefly drop the voltage supply to the chip, or to introduce a very brief additional cycle to the clock supply line. Like running the chip too fast or on too little power, this causes instructions to be mis-executed. But because the violation <span epub:type="pagebreak" id="page_132"/>is so brief, as little as one instruction will be corrupted while everything else remains fine.</p>&#13;
<p class="indent">In our example, the smart card will spin forever executing the <span class="literal">while</span> loop on line 3. Optimizations and assembly languages will express it differently, but imagine it becomes the following pseudo-assembly.</p>&#13;
<div class="imagel"><img src="../images/f0132-01.jpg" alt="Image" width="812" height="136"/></div>&#13;
<p class="indent">When the device is looped, the microcontroller will execute lines 2 and 3 in sequence forever. If we shorten the clock so that the jump-if-equal instruction on line 3 does not write over the program counter, execution will continue on line 5, calling the main method as if this chip weren’t locked. Because the loop runs continuously, the chip is helpfully giving us many tries before each reboot.</p>&#13;
<p class="indent">Another good target is a copy loop. At startup, a smart card often presents its Answer To Reset (ATR) string. If the <span class="literal">for</span> loop that sends the string is like this, we might leak extra bytes of memory out of the card by glitching as <span class="literal">i</span> is compared to <span class="literal">16</span> after the last byte. When the comparison is exact (<em>i</em> ≠ 16) instead of a range (<em>i &lt;</em> 16), this might dump a lot of extra memory!</p>&#13;
<div class="imagel"><img src="../images/f0132-02.jpg" alt="Image" width="811" height="113"/></div>&#13;
<p class="indent">In the early 2000s, unlooper hardware was commercially sold to hobbyists and schematics for home designs were passed around on forums. Most consisted of an Atmel AT90 microcontroller with 7400 series chips to insert glitches on the clock and data lines against the DirecTV HU Card.<sup><a id="ch13fn_1" href="footnotes.xhtml#ch13fn1">1</a></sup> See <a href="ch13.xhtml#ch13fig1">Figure 13.1</a> for an example, and search eBay for “Mikobu” if you’d prefer to purchase one already made.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_133"/><img id="ch13fig1" src="../images/f0133-01.jpg" alt="Image" width="1075" height="648"/></div>&#13;
<p class="figcap">Figure 13.1: Smart Card Unlooper from PLC77 (2001)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_134"/>As far as software goes, most of these unlooper designs require firmware to be loaded into the AT90 through the MAX232 chip over a serial port. While many glitching programs were shared as source code or black box binaries, there was also a tradition of sharing them as commented VBScript for a program called WinExplorer.</p>&#13;
<h3 class="h3" id="ch00lev1sec45"><strong>Clock Glitching</strong></h3>&#13;
<p class="noindent">When a microcontroller is designed, there’s a matter of timing closure. For any given chip, there is some maximum clock rate, beneath which the design behaves as specified. Beneath this speed, all of the combinational logic gets the right result in time to be latched by the sequential logic.</p>&#13;
<p class="indent">Above this rate, things fail, but not all at once. Maybe multiplication is the bottleneck of the clock rate, and exceeding that rate by a little bit causes some multiplications to fail while everything else works fine. If you never need multiplication, you might exceed this clock rate to get more performance in other functions.</p>&#13;
<p class="indent">When a chip takes its raw clock input from an external pin, and it doesn’t smooth that clock out with a phase-locked loop, we have the opportunity to perform some clock glitching. We do this by inserting a short clock pulse, one single edge or cycle that is far above the maximum rate of the chip.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_135"/>In a multi-cycle design, this can be thought of as one piece of one instruction being given time to finish. Maybe the wrong opcode is latched in the first cycle of the instruction, or maybe a jump never writes back to the program counter at the end of the instruction.</p>&#13;
<p class="indent">I usually begin with a range of time in which the firmware makes an important decision, then attempt to fault random points in that range until I get the chip to misbehave. Because we control the clock itself, this timing can be extremely accurate and reliable.</p>&#13;
<h3 class="h3" id="ch00lev1sec46"><strong>Voltage Glitching</strong></h3>&#13;
<p class="noindent">When the raw clock input isn’t available, voltage glitching might still be an option. The idea is to abruptly shift the voltage, raising or lowering it for such a brief moment that the chip does not crash but it also doesn’t execute its instruction properly.</p>&#13;
<p class="indent">Dropping the voltage has many effects. One is that the transistors flip more slowly, so that a device might be well within its timing closure is suddenly unable to calculate its results in time, somewhat like clock glitching. An Atmega328P, for example, safely runs at 20MHz at 4.5V only 10MHz at 2.7V. Other effects include failures in memories and mistaken instruction decoding.</p>&#13;
<p class="indent">Calibration of a voltage glitch can be tricky. The first axis will be the time offset from an observable trigger, like a pin rising high. The duration of change and the target voltage will be two more axes, and clock drift will make things less reliable the longer we wait after the trigger for the glitch to occur.</p>&#13;
<p class="indent">To keep things simple, many modern glitching attacks simply short circuit the core voltage to ground and rely on very short <span epub:type="pagebreak" id="page_136"/>timing to prevent a crash.<sup><a id="ch13fn_2" href="footnotes.xhtml#ch13fn2">2</a></sup></p>&#13;
<p class="indent">However you arrange things, it’s important to calibrate your glitching on one axis at a time. I do this on a development board with the same chip as my target, first running a tight <span class="literal">while</span> loop that adds up a bunch of numbers and prints a warning when they disagree. I can then search for a duration and voltage that make the warnings appear, without yet worrying about when to apply the glitch. I remove most of the decoupling capacitors, then add them back individually if things become too unstable.</p>&#13;
<p class="indent">Only after successfully injecting faults in this easy target do I bother switching over to my real target. It’s there that my trigger and offset matter, and it’s best that the other parameters already be dialed in.</p>&#13;
</div>
</div>
</body></html>