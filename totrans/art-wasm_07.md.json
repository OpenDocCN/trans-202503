["```\nnpm install connect --save-dev\n```", "```\nnpm install serve-static --save-dev\n```", "```\nvar connect = require('connect');\nvar serveStatic = require('serve-static');\nconnect().use(serveStatic(__dirname + \"/\")).listen(8080, function(){\n  console.log('localhost:8080');\n});\n```", "```\n<html>\n  <head></head>\n  <body>\n    <h1>OUR SERVER WORKS!</h1>\n  </body>\n</html>\n```", "```\nnode server.js\n```", "```\n(module\n1 (import \"env\" \"log_add_message\"\n    (func $log_add_message (param i32 i32 i32)))\n\n2 (func (export \"add_message\")\n    3 (param $a i32) (param $b i32)\n      (local $sum i32)\n\n      local.get $a\n      local.get $b\n    4 i32.add\n      local.set $sum\n\n    5 (call $log_add_message\n      6 (local.get $a) (local.get $b) (local.get $sum))\n  )\n)\n```", "```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\"\n        content=\"width=device-width, initial-scale=1.0\">\n  <title>Add Message</title>\n...\n```", "```\n...\n  <script>\n  1 //const sleep = m => new Promise(r => setTimeout(r, m));\n    var output = null;\n    var add_message_function;\n\n  2 var log_add_message = (a, b, sum) => {\n      if (output == null) {\n        console.log(\"page load not complete: log_add_message\");\n        return;\n      }\n 3 output.innerHTML += `${a} + ${b} = ${sum}<br>`;\n    };\n\n    let importObject = {\n      env: {\n      4 log_add_message: log_add_message,\n      }\n    };\n\n    (async () => {\n    5 // await sleep(5000);\n      let obj = await\n    6 WebAssembly.instantiateStreaming(fetch('add_message.wasm'),\n                                        importObject);\n      add_message_function = obj.instance.exports.add_message;\n    7 let btn = document.getElementById(\"add_message_button\");\n      btn.style.display = \"block\";\n    })();\n\n  8 function onPageLoad() {\n      //(async () => {\n    9 //await sleep(5000);\n    a output = document.getElementById(\"output\");\n      //})();\n    }\n  </script>\n...\n```", "```\n...\n</head>\n1 <body onload=\"onPageLoad()\"\n      style=\"font-family: 'Courier New', Courier, monospace;\">\n2 <input type=\"number\" id=\"a_val\" value=\"0\"><br><br>\n3 <input type=\"number\" id=\"b_val\" value=\"0\"><br><br>\n4 <button id=\"add_message_button\" type=\"button\" style=\"display:none\"\n5 onclick=\"add_message_function(  \n                document.getElementById('a_val').value,\n                document.getElementById('b_val').value )\">\n    Add Values\n  </button>\n  <br>\n6 <p id=\"output\" style=\"float:left; width:200px; min-height:300px;\">\n  </p>\n</body>\n</html>\n```", "```\nnode server.js\n```", "```\nError: listen EADDRINUSE: address already in use :::8080\n```", "```\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\"\n content=\"width=device-width, initial-scale=1.0\">\n  <title> 1 Hex and Binary</title>\n...\n```", "```\n...\n  <script>\n // allocate a 64K block of memory\n    const memory = new WebAssembly.Memory({ initial: 1 });\n    var output = null;\n\n // function will change when WebAssembly module is instantiated\n  1 var setOutput = (number) => {\n // this message will appear if you run the function\n // before the WebAssembly module is instantiated.\n    2 console.log(\"function not available\");\n      return 0;\n    };\n\n // This function will be called from a button click and runs\n // the setOutput function in the WebAssembly module.\n  3 function setNumbers(number) {\n    4 if (output == null) {\n // if page has not fully loaded return\n        return;\n      }\n\n // calling WebAssembly setOutput function generates the HTML\n // string and puts it in linear memory returning its length\n    5 let len = setOutput(number);\n\n // we know the position and length of the HTML string in\n // linear memory so we can take it out of the memory buffer\n    6 let bytes = new Uint8Array(memory.buffer, 1024, len);\n\n // convert the bytes taken from linear memory into a\n // JavaScript string and use it to set the HTML in output\n    7 output.innerHTML = new TextDecoder('utf8').decode(bytes);\n    }\n\n  8 function onPageLoad() {\n // when the page load is complete, set the output variable\n // to the element with an id of \"output\"\n    9 output = document.getElementById(\"output\");\n      var message_num = 0;\n    }\n\n    let importObject = {\n      env: {\n buffer: memory\n      }\n    };\n\n    (async () => {\n // use WebAssembly.instantiateStreaming in combination with\n // fetch instead of WebAssembly.instantiate and fs.readFileSync\n      let obj = await WebAssembly.instantiateStreaming(\n                        fetch('hex_and_binary.wasm'),\n                        importObject);\n // reset the setOutput variable to the setOutput\n // function from the WASM module\n    a setOutput = obj.instance.exports.setOutput;\n         let btn = document.getElementById(\"set_numbers_button\");\n         btn.style.display = \"block\";\n    })();\n\n  </script>\n</head>\n...\n```", "```\n...\n<!-- body tag calls onPageLoad when the body load is complete -->\n1 <body onload=\"onPageLoad()\"\n      style=\"font-family: 'Courier New', Courier, monospace;\">\n2 <div id=\"output\"><!-- displays output from WebAssembly -->\n    <h1>0</h1>\n    <h4>0x0</h4>\n    <h4> 0000 0000 0000 0000 0000 0000 0000 0000</h4>\n  </div>\n  <br>\n <!-- user enters input to convert to hex and binary here -->\n3 <input type=\"number\" id=\"val\" value=\"0\"><br><br>\n <!-- when user clicks this button, the WASM function is run -->\n4 <button id=\"set_numbers_button\" type=\"button\" style=\"display:none\"\n  5 onclick=\"setNumbers( document.getElementById('val').value )\">\n    Set Numbers\n  </button>\n</body>\n</html>\n```", "```\n(module\n  (import \"env\" \"buffer\" (memory 1))\n\n ;; hexadecimal digits\n1 (global $digit_ptr i32 (i32.const 128))\n  (data (i32.const 128) \"0123456789ABCDEF\")\n ;; the decimal string pointer, length and data section\n2 (global $dec_string_ptr  i32 (i32.const 256))\n(global $dec_string_len  i32 (i32.const 16))\n  (data (i32.const 256) \"               0\")\n\n ;; the hexadecimal string pointer, length and data section\n3 (global $hex_string_ptr  i32 (i32.const 384))\n(global $hex_string_len  i32 (i32.const 16))\n(data (i32.const 384) \"             0x0\")\n\n ;; the binary string pointer, length and data section\n4 (global $bin_string_ptr  i32 (i32.const 512))\n(global $bin_string_len  i32 (i32.const 40))\n(data (i32.const 512) \" 0000 0000 0000 0000 0000 0000 0000 0000\")\n\n ;; the h1 open tag string pointer, length and data section\n5 (global $h1_open_ptr i32  (i32.const 640))\n(global $h1_open_len i32  (i32.const 4))\n(data (i32.const 640) \"<H1>\")\n\n ;; the h1 close tag string pointer, length and data section\n6 (global $h1_close_ptr i32  (i32.const 656))\n(global $h1_close_len i32  (i32.const 5))\n(data (i32.const 656) \"</H1>\")\n\n ;; the h4 open tag string pointer, length and data section\n7 (global $h4_open_ptr i32  (i32.const 672))\n(global $h4_open_len i32  (i32.const 4))\n(data (i32.const 672) \"<H4>\")\n\n ;; the h4 close tag string pointer, length and data section\n8 (global $h4_close_ptr i32  (i32.const 688))\n(global $h4_close_len i32  (i32.const 5))\n(data (i32.const 688) \"</H4>\")\n\n ;; the output string length and data section\n9 (global $out_str_ptr i32 (i32.const 1024))\n(global $out_str_len (mut i32) (i32.const 0))\n\n...\n```", "```\n...\n1 (func $set_bin_string (param $num i32) (param $string_len i32)\n  ;; $set_bin_string defined in listing 5-35\n...\n)\n\n2 (func $set_hex_string (param $num i32) (param $string_len i32)\n  ;; $set_hex_string defined in listing 5-30\n...\n) ;; end $set_hex_string\n\n3 (func $set_dec_string (param $num i32) (param $string_len i32)\n  ;; $set_dec_string defined in listing 5-24\n...\n)\n\n4 (func $byte_copy\n  (param $source i32) (param $dest i32) (param $len i32)\n  ;; $byte_copy defined in listing 5-17\n...\n)\n\n5 (func $byte_copy_i64\n  (param $source i32) (param $dest i32) (param $len i32)\n  ;; $byte_copy_i64 defined in listing 5-18\n...\n)\n\n6 (func $string_copy\n  (param $source i32) (param $dest i32) (param $len i32)\n  ;; $string_copy defined in listing 5-19\n...\n  )\n...\n```", "```\n...\n ;; append the source string to the output string\n1 (func $append_out (param $source i32) (param $len i32)\n 2 (call $string_copy\n   (local.get $source)\n     (i32.add\n      (global.get $out_str_ptr)\n      (global.get $out_str_len)\n    )\n   (local.get $len)\n  )\n\n ;; add length to the output string length\n  global.get $out_str_len\n  local.get $len\n  i32.add\n  3 global.set $out_str_len\n)\n...\n```", "```\n...\n(func (export \"setOutput\") (param $num i32) (result i32)\n ;; create a decimal string from $num value\n1 (call $set_dec_string\n    (local.get $num) (global.get $dec_string_len))    \n ;; create a hexadecimal string from $num value\n2 (call $set_hex_string\n    (local.get $num) (global.get $hex_string_len))    \n ;; create a binary string from $num value\n3 (call $set_bin_string\n    (local.get $num) (global.get $bin_string_len))    \n\n    i32.const 0\n  4 global.set $out_str_len ;; set $out_str_len to 0\n\n ;; append <h1>${decimal_string}</h1> to output string\n  5 (call $append_out\n      (global.get $h1_open_ptr) (global.get $h1_open_len))\n    (call $append_out\n (global.get $dec_string_ptr) (global.get $dec_string_len))\n    (call $append_out\n      (global.get $h1_close_ptr) (global.get $h1_close_len))\n\n ;; append <h4>${hexadecimal_string}</h4> to output string\n  6 (call $append_out\n      (global.get $h4_open_ptr) (global.get $h4_open_len))\n    (call $append_out\n      (global.get $hex_string_ptr) (global.get $hex_string_len))\n    (call $append_out\n      (global.get $h4_close_ptr) (global.get $h4_close_len))\n\n ;; append <h4>${binary_string}</h4> to output string\n  7 (call $append_out\n      (global.get $h4_open_ptr) (global.get $h4_open_len))\n    (call $append_out\n      (global.get $bin_string_ptr) (global.get $bin_string_len))\n    (call $append_out\n      (global.get $h4_close_ptr) (global.get $h4_close_len))\n\n ;; return output string length\n  8 global.get $out_str_len\n  )\n)\n```", "```\nwat2wasm hex_and_binary.wat\n```"]