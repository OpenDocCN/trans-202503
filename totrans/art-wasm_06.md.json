["```\n(memory 1)\n```", "```\n(memory 32_767)\n```", "```\nconst memory = new WebAssembly.Memory({initial: 1});\n```", "```\n(import \"js\" \"mem\" (memory 1))\n```", "```\nconst fs = require('fs');\nconst bytes = fs.readFileSync(__dirname + '/pointer.wasm');\nconst memory = new WebAssembly.Memory({1initial: 1, 2maximum: 4});\n\nconst importObject = {\n  env: {\n  3 mem: memory,\n  }\n};\n\n( async () => {\n let obj = await WebAssembly.instantiate(new Uint8Array(bytes),\n                                        4 importObject);\n  let pointer_value = obj.instance.exports.get_ptr();\n  console.log(`pointer_value=${pointer_value}`);\n})();\n```", "```\nint x = 25;\nint *ptr = &x;\n```", "```\n(module\n1 (memory 1)\n2 (global $pointer i32 (i32.const 128))\n3 (func $init\n  4 (i32.store\n  5 (global.get $pointer)  ;; store at address $pointer\n  6 (i32.const 99)         ;; value stored\n    )\n  )\n7 (func (export \"get_ptr\") (result i32)\n8 (i32.load (global.get $pointer)) ;; return value at location $pointer\n  )\n9 (start $init)\n)\n```", "```\npointer_value=99\n```", "```\n(module\n1 (import \"env\" \"mem\" (memory 1))\n2 (global $data_addr (import \"env\" \"data_addr\") i32)\n3 (global $data_count (import \"env\" \"data_count\") i32)\n\n4 (func $store_data (param $index i32) (param $value i32)\n    (i32.store\n     (i32.add\n      (global.get $data_addr) ;; add $data_addr to the $index*4 (i32=4 bytes)\n      (i32.mul (i32.const 4) (local.get $index)) ;; multiply $index by 4\n     )\n     (local.get $value) ;; value stored\n    )\n  )\n\n5 (func $init\n    (local $index i32)\n\n  6 (loop $data_loop\n      local.get $index\n\n      local.get $index\n      i32.const 5\n      i32.mul      \n\n    7 call $store_data ;; called with parameters $index and $index * 5\n\n      local.get $index\n      i32.const 1\n      i32.add          ;; $index++\n\n      local.tee $index\n    8 global.get $data_count\n      i32.lt_u\n      br_if $data_loop\n    )\n\n 9 (call $store_data (i32.const 0) (i32.const 1))\n\n  )\n\na (start $init)\n)\n```", "```\nnpm i colors\n```", "```\nconst colors = require('colors');\n\nconsole.log('RED COLOR'.red.bold);  // logs bold red text\nconsole.log('blue color'.blue); // logs blue text\n```", "```\nnode colors.js\n```", "```\n**RED COLOR**\nblue color\n```", "```\n const colors = require('colors'); // allow console logs with color\n  const fs = require('fs');\n  const bytes = fs.readFileSync(__dirname + '/store_data.wasm');\n\n// allocate a 64K block of memory\n1 const memory = new WebAssembly.Memory({initial: 1 });\n// 32-bit data view of the memory buffer\n2 const mem_i32 = new Uint32Array(memory.buffer);\n\n3 const data_addr = 32; // the address of the first byte of our data\n\n// The 32-bit index of the beginning of our data\n4 const data_i32_index = data_addr / 4;\n5 const data_count = 16; // the number of 32-bit integers to set\n\n6 const importObject = { // The objects WASM imports from JavaScript\n    env: {\n      mem: memory,\n data_addr: data_addr,\n      data_count: data_count\n    }\n  };\n...\n```", "```\n...\n( async () => {\n1 let obj = await WebAssembly.instantiate(new Uint8Array(bytes),\n                                          importObject );\n\n2 for( let i = 0; i < data_i32_index + data_count + 4; i++ ) {\n    let data = mem_i32[i];\n    if (data !== 0) {\n    3 console.log(`data[${i}]=${data}`.red.bold);\n    }\n    else {\n    4 console.log(`data[${i}]=${data}`);\n    }\n\n  }\n})();\n```", "```\ndata[0]=0\ndata[1]=0\ndata[2]=0\ndata[3]=0\ndata[4]=0\ndata[5]=0\ndata[6]=0\ndata[7]=0\n**data[8]=1**\n**data[9]=5**\n**data[10]=10**\n**data[11]=15**\n**data[12]=20**\n**data[13]=25**\n**data[14]=30**\n**data[15]=35**\n**data[16]=40**\n**data[17]=45**\n**data[18]=50**\n**data[19]=55**\n**data[20]=60**\n**data[21]=65**\n**data[22]=70**\n**data[23]=75**\ndata[24]=0\ndata[25]=0\ndata[26]=0\ndata[27]=0\n```", "```\nconst colors = require('colors'); // allow console logs with color\nconst fs = require('fs');\nconst bytes = fs.readFileSync(__dirname + '/data_structures.wasm');\n // allocate a 64K block of memory\n1 const memory = new WebAssembly.Memory({initial: 1});\n\n // 32-bit view of memory buffer\n  const mem_i32 = new Uint32Array(memory.buffer);\n\n  const obj_base_addr = 0; // the address of the first byte of our data\n2 const obj_count = 32;    // the number of structures\n3 const obj_stride = 16;   // 16-byte stride\n\n  // structure attribute offsets\n4 const x_offset = 0;\n5 const y_offset = 4;\n  const radius_offset = 8;\t\t\t\n  const collision_offset = 12;\t\t\t\n\n  // 32-bit integer indexes\n  const obj_i32_base_index = obj_base_addr / 4; // 32-bit data index\n  const obj_i32_stride = obj_stride / 4;        // 32-bit stride\n\n // offsets in the 32-bit integer array\n6 const x_offset_i32 = x_offset / 4;\n  const y_offset_i32 = y_offset / 4;\n const radius_offset_i32 = radius_offset / 4;\n  const collision_offset_i32 = collision_offset / 4;\n\n7 const importObject = { // The objects WASM imports from JavaScript\n    env: {\n      mem: memory,\n      obj_base_addr: obj_base_addr,\n      obj_count: obj_count,\n      obj_stride: obj_stride,\n      x_offset: x_offset,\t\t\t\n      y_offset: y_offset,\n      radius_offset: radius_offset,\n      collision_offset: collision_offset,\n    }\n  };\n...\n```", "```\n...\n  for( let i = 0; i < obj_count; i++ ) {\n  1 let index = obj_i32_stride * i + obj_i32_base_index;\n\n 2 let x = Math.floor( Math.random() * 100 );\n    let y = Math.floor( Math.random() * 100 );\n    let r = Math.ceil( Math.random() * 10 );\n\n  3 mem_i32[index + x_offset_i32] = x;\n    mem_i32[index + y_offset_i32] = y;\n    mem_i32[index + radius_offset_i32] = r;\n  }\n...\n```", "```\n...\n( async () => {\n1 let obj = await WebAssembly.instantiate(new Uint8Array(bytes),\n                                          importObject );\n\n2 for( let i = 0; i < obj_count; i++ ) {\n  3 let index = obj_i32_stride * i + obj_i32_base_index;\n\n  4 let x = mem_i32[index+x_offset_i32].toString().padStart(2, ' ');\n    let y = mem_i32[index+y_offset_i32].toString().padStart(2, ' ');\n    let r = mem_i32[index+radius_offset_i32].toString()\n                   .padStart(2,' ');\n    let i_str = i.toString().padStart(2, '0');\n    let c = !!mem_i32[index + collision_offset_i32];\n\n    if (c) {\n    5 console.log(`obj[${i_str}] x=${x} y=${y} r=${r} collision=${c}`\n          .red.bold);\n    }\n    else {\n    6 console.log(`obj[${i_str}] x=${x} y=${y} r=${r} collision=${c}`\n          .green);\n    }\n  }\n})();\n```", "```\n(module\n  (import \"env\" \"mem\" (memory 1))           \n1 (global $obj_base_addr  (import \"env\" \"obj_base_addr\") i32)\n2 (global $obj_count    (import \"env\" \"obj_count\") i32)\n3 (global $obj_stride   (import \"env\" \"obj_stride\") i32)\n\n ;; attribute offset locations\n4 (global $x_offset     (import \"env\" \"x_offset\") i32)\n5 (global $y_offset     (import \"env\" \"y_offset\") i32)\n6 (global $radius_offset  (import \"env\" \"radius_offset\") i32)\n7 (global $collision_offset (import \"env\" \"collision_offset\") i32)\n...\n```", "```\n...\n1 (func $collision_check\n    (param $x1 i32) (param $y1 i32) (param $r1 i32)\n    (param $x2 i32) (param $y2 i32) (param $r2 i32)\n    (result i32)\n\n    (local $x_diff_sq i32)\n    (local $y_diff_sq i32)\n    (local $r_sum_sq i32)\n\n    local.get $x1\n    local.get $x2\n    i32.sub\n    local.tee $x_diff_sq\n    local.get $x_diff_sq\n    i32.mul\n      2 local.set $x_diff_sq  ;; ($x1 - $x2) * ($x1 - $x2)\n\n    local.get $y1\n local.get $y2\n    i32.sub\n    local.tee $y_diff_sq\n    local.get $y_diff_sq\n    i32.mul\n      3 local.set $y_diff_sq  ;; ($y1 - $y2) * ($y1 - $y2)\n\n    local.get $r1\n    local.get $r2\n    i32.add\n    local.tee $r_sum_sq\n    local.get $r_sum_sq\n    i32.mul\n      4 local.tee $r_sum_sq   ;; ($r1 + $r2) * ($r1 + $r2)\n\n    local.get $x_diff_sq\n    local.get $y_diff_sq\n      5 i32.add  ;; pythagorean theorem A squared + B squared = C squared\n\n      6 i32.gt_u ;; if distance is less than sum of the radii return true\n)\n...\n```", "```\n...\n1 (func $get_attr (param $obj_base i32) (param $attr_offset i32)\n    (result i32)\n    local.get $obj_base\n    local.get $attr_offset\n  2 i32.add         ;; add attribute offset to base address\n  3 i32.load        ;; load the address and return it\n  )\n...\n```", "```\n...\n1 (func $set_collision\n    (param $obj_base_1 i32) (param $obj_base_2 i32)\n    local.get $obj_base_1\n    global.get $collision_offset\n  2 i32.add   ;; address = $obj_base_1 + $collision_offset\n    i32.const 1\n  3 i32.store ;; store 1 as true in the collision attribute for this object\n\n    local.get $obj_base_2\n    global.get $collision_offset\n  4 i32.add   ;; address = $obj_base_2 + $collision_offset\n    i32.const 1\n  5 i32.store ;; store 1 as true in the collision attribute for this object\n  )\n...\n```", "```\n...\n(func $init\n1 (local $i i32)     ;; outer loop counter\n  (local $i_obj i32) ;; address of ith object\n  (local $xi i32)(local $yi i32)(local $ri i32) ;; x,y,r for object i\n\n2 (local $j i32)     ;; inner loop counter\n  (local $j_obj i32) ;; address of the jth object\n  (local $xj i32)(local $yj i32)(local $rj i32) ;; x,y,r for object j\n\n  (loop $outer_loop\n  (local.set $j (i32.const 0))  ;; $j = 0\n\n  (loop $inner_loop\n    (block $inner_continue\n    ;; if $i == $j continue\n  3 (br_if $inner_continue (i32.eq (local.get $i) (local.get $j) ) )\n\n ;; $i_obj = $obj_base_addr + $i * $obj_stride\n    (i32.add (global.get $obj_base_addr)\n           4 (i32.mul (local.get $i) (global.get $obj_stride) ) )\n\n ;; load $i_obj + $x_offset and store in $xi\n  5 (call $get_attr (local.tee $i_obj) (global.get $x_offset) )\n    local.set $xi    \n\n ;; load $i_obj + $y_offset and store in $yi\n    (call $get_attr (local.get $i_obj) (global.get $y_offset) )\n    local.set $yi    \n\n ;; load $i_obj + $radius_offset and store in $ri\n    (call $get_attr (local.get $i_obj) (global.get $radius_offset) )\n    local.set $ri    \n\n ;; $j_obj = $obj_base_addr + $j * $obj_stride\n  6 (i32.add (global.get $obj_base_addr)\n             (i32.mul (local.get $j)(global.get $obj_stride)))\n\n ;; load $j_obj + $x_offset and store in $xj\n    (call $get_attr (local.tee $j_obj) (global.get $x_offset) )\n    local.set $xj    \n\n ;; load $j_obj + $y_offset and store in $yj\n    (call $get_attr (local.get $j_obj) (global.get $y_offset) )\n    local.set $yj    \n\n ;; load $j_obj + $radius_offset and store in $rj\n    (call $get_attr (local.get $j_obj) (global.get $radius_offset) )\n    local.set $rj    \n\n ;; check for collision between ith and jth objects\n  7 (call $collision_check\n      (local.get $xi)(local.get $yi)(local.get $ri)\n      (local.get $xj)(local.get $yj)(local.get $rj))\n\n    if ;; if there is a collision\n    8 (call $set_collision (local.get $i_obj) (local.get $j_obj))\n    end\n  )\n\n  9 (i32.add (local.get $j) (i32.const 1)) ;; $j++\n\n ;; if $j < $obj_count loop\n    (br_if $inner_loop\n      (i32.lt_u (local.tee $j) (global.get $obj_count)))\n  )\n\n  a (i32.add (local.get $i) (i32.const 1)) ;; $i++\n\n ;; if $i < $obj_count loop\n  (br_if $outer_loop\n (i32.lt_u (local.tee $i) (global.get $obj_count) ) )\n )\n)\n...\n```", "```\n...\n  (start $init)\n)\n```", "```\nwat2wasm data_structures.wat\n```", "```\nnode data_structures.js\n```", "```\n**obj[00] x=48 y=65 r= 4 collision=true**\n**obj[01] x=46 y=71 r= 6 collision=true**\n**obj[02] x=12 y=75 r= 3 collision=true**\nobj[03] x=54 y=43 r= 2 collision=false\nobj[04] x=16 y= 6 r= 1 collision=false\n**obj[05] x= 5 y=21 r= 9 collision=true**\nobj[06] x=71 y=50 r= 5 collision=false\n**obj[07] x=11 y=13 r= 5 collision=true**\n**obj[08] x=43 y=70 r= 7 collision=true**\nobj[09] x=88 y=60 r= 9 collision=false\n**obj[10] x=96 y=21 r= 9 collision=true**\n**obj[11] x= 5 y=87 r= 2 collision=true**\nobj[12] x=64 y=39 r= 3 collision=false\n**obj[13] x=75 y=74 r= 6 collision=true**\n**obj[14] x= 2 y=74 r= 8 collision=true**\n**obj[15] x=12 y=85 r= 7 collision=true**\nobj[16] x=60 y=27 r= 5 collision=false\n**obj[17] x=43 y=67 r= 2 collision=true**\nobj[18] x=38 y=53 r= 3 collision=false\nobj[19] x=34 y=39 r= 5 collision=false\n**obj[20] x=42 y=62 r= 2 collision=true**\nobj[21] x=72 y=93 r= 7 collision=false\n**obj[22] x=78 y=79 r= 8 collision=true**\nobj[23] x=50 y=96 r= 7 collision=false\n**obj[24] x=34 y=18 r=10 collision=true**\nobj[25] x=19 y=44 r= 8 collision=false\n**obj[26] x=92 y=82 r= 7 collision=true**\nobj[27] x=59 y=56 r= 3 collision=false\n**obj[28] x=41 y=75 r= 9 collision=true**\n**obj[29] x=28 y=29 r= 6 collision=true**\n**obj[30] x=32 y=10 r= 1 collision=true**\n**obj[31] x=83 y=15 r= 6 collision=true**\n```"]