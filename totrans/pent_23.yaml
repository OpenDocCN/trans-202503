- en: Chapter 18. Structured Exception Handler Overwrites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When something goes wrong and causes a program to crash, it has caused an exception.
    Accessing an invalid memory location is one type of exception a program can encounter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows systems use a method called *structured exception handlers (SEH)* to
    deal with program exceptions as they arise. SEH are similar to try/catch blocks
    in Java: Code is executed, and if something goes wrong, the function stops executing
    and passes execution to SEH.'
  prefs: []
  type: TYPE_NORMAL
- en: Each function can have its own SEH registration entry. An *SEH registration
    record* is eight bytes long, consisting of a pointer to the next SEH record (NSEH)
    followed by the memory address of the exception handler, as illustrated in [Figure 18-1](ch18.xhtml#seh_structure
    "Figure 18-1. SEH structure"). The list of all the SEH entries is the *SEH chain*.
  prefs: []
  type: TYPE_NORMAL
- en: '![SEH structure](httpatomoreillycomsourcenostarchimages2030540.png)Figure 18-1. SEH
    structure'
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, an application uses only the operating system’s SEH entry to
    handle exceptions. You are probably already familiar with this usage; it puts
    up a message box with something like “Application X has encountered a problem
    and needs to close.” However, programs can also specify custom SEH entries. When
    an exception is encountered, execution will be passed to the SEH chain to look
    for an entry that can handle the exception. To view the SEH chain for an application
    in Immunity Debugger, go to **View** ▸ **SEH chain**, as illustrated in [Figure 18-2](ch18.xhtml#viewing_the_seh_chain
    "Figure 18-2. Viewing the SEH chain").
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the SEH chain](httpatomoreillycomsourcenostarchimages2030542.png)Figure 18-2. Viewing
    the SEH chain'
  prefs: []
  type: TYPE_NORMAL
- en: SEH Overwrite Exploits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s look at using SEH entries to take control of a program. A natural
    question when working through the War-FTP buffer overflow example in [Chapter 17](ch17.xhtml
    "Chapter 17. A Stack-Based Buffer Overflow in Windows") would be, Why are we limited
    to 607 bytes for our shellcode? Why can’t we write an even longer attack string
    and create a payload that’s as long as we like?
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin our exploration of SEH overwrites with the exploit we used to crash
    War-FTP. Instead of the 1,100-byte exploit string that we used in the example
    in [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow in Windows"),
    let’s try crashing War-FTP with a 1,150-byte string of *A*s, as shown in [Example 18-1](ch18.xhtml#war-ftp_exploit_with_1comma150_as
    "Example 18-1. War-FTP exploit with 1,150 As").
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-1. War-FTP exploit with 1,150 As
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As shown in [Figure 18-3](ch18.xhtml#program_crashes_without_eip_controldot
    "Figure 18-3. A program crashes without EIP control."), the program crashes as
    expected, but this time our access violation is a bit different from the one in
    [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow in Windows").
    EIP points to `0x77C3F973`, a valid instruction inside *MSVCRT.dll*. Instead of
    overwriting the saved return pointer and crashing the program with EIP control,
    War-FTP crashed writing to memory address `0x00B00000`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the CPU pane that the instruction at `0x77C3F973` is `MOV BYTE PTR`
    `DS:[EAX], 0`. Basically, the program is trying to write to the memory location
    of the value of `EAX`. Looking at the top right of Immunity Debugger, the Registers
    pane, we see `EAX` contains the value `00B00000`. Something about our attack string
    seems to have corrupted `EAX`, because the program is now trying to write to a
    memory location that is not writable. Without EIP control, is this crash still
    viable? Really long attack strings frequently cause an exception by trying to
    write data off the end of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Before we write off this exploit and move on, take a look at the SEH chain.
    As shown in [Figure 18-4](ch18.xhtml#seh_overwritten "Figure 18-4. SEH overwritten"),
    the structured exception handler has been overwritten with *A*s. Recall that in
    the event of a crash, execution is passed to SEH. Though we were not able to control
    EIP directly at the time of the crash, perhaps controlling SEH will allow us to
    still hijack execution.
  prefs: []
  type: TYPE_NORMAL
- en: '![A program crashes without EIP control.](httpatomoreillycomsourcenostarchimages2030544.png.jpg)Figure 18-3. A
    program crashes without EIP control.![SEH overwritten](httpatomoreillycomsourcenostarchimages2030546.png.jpg)Figure 18-4. SEH
    overwritten'
  prefs: []
  type: TYPE_NORMAL
- en: Just as we used Mona to create a cyclic pattern to see which four bytes overwrote
    the saved return pointer in the previous chapter, we will find which four *A*s
    are overwriting SEH using the command `!mona pattern_create 1150` in Immunity
    Debugger, as shown in [Figure 18-5](ch18.xhtml#generating_a_cyclic_pattern_with_mona
    "Figure 18-5. Generating a cyclic pattern with Mona").
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a cyclic pattern with Mona](httpatomoreillycomsourcenostarchimages2030548.png.jpg)Figure 18-5. Generating
    a cyclic pattern with Mona'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the resulting pattern from *C:\logs\war-ftpd\pattern.txt* into the exploit
    in place of the 1,150 *A*s, as shown in [Example 18-2](ch18.xhtml#using_pattern_generation_to_pinpoint_the
    "Example 18-2. Using pattern generation to pinpoint the SEH overwrite in the attack
    string").
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-2. Using pattern generation to pinpoint the SEH overwrite in the
    attack string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve generated a 1,150-character pattern and replaced the string of *A*s
    at ❶. Next, restart War-FTP in Immunity Debugger, and run the exploit again. As
    shown in [Figure 18-6](ch18.xhtml#seh_overwritten_with_monaapostrophes_pat "Figure 18-6. SEH
    overwritten with Mona’s pattern"), SEH is overwritten with `41317441`.
  prefs: []
  type: TYPE_NORMAL
- en: '![SEH overwritten with Mona’s pattern](httpatomoreillycomsourcenostarchimages2030550.png.jpg)Figure 18-6. SEH
    overwritten with Mona’s pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Now use `!mona findmsp` to find out where in our 1,150-character attack string
    the SEH entry is overwritten, as shown in [Figure 18-7](ch18.xhtml#finding_the_seh_overwrite_in_the_cyclic
    "Figure 18-7. Finding the SEH overwrite in the cyclic pattern").
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the SEH overwrite in the cyclic pattern](httpatomoreillycomsourcenostarchimages2030552.png.jpg)Figure 18-7. Finding
    the SEH overwrite in the cyclic pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Looking through the log output at *C:\logs\war-ftpd\findmsp.txt*, shown in part
    here, we find that the NSEH entry is overwritten 569 bytes into the attack string.
    Recall from [Figure 18-1](ch18.xhtml#seh_structure "Figure 18-1. SEH structure")
    that SEH chain entries are made up of eight bytes (the NSEH entry followed by
    the SEH pointer). Thus our SEH overwrite is at 573 bytes into our attack string
    (four bytes after NSEH).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Passing Control to SEH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back on the Windows XP target, the bottom of the Immunity Debugger screen shows
    the access violation and also notes that you can type shift-F7/F8/F9 to pass an
    exception to the program. In this case, the program will attempt to execute the
    memory address `41317441`, the string that has overwritten SEH. Use shift-F9 to
    run the program until the next error occurs. As shown in [Figure 18-8](ch18.xhtml#execution_is_passed_to_the_overwritten_s
    "Figure 18-8. Execution is passed to the overwritten SEH."), the program receives
    an access violation when attempting to access the memory address `41317441`. As
    in the previous examples, we will put a useful memory address in the place of
    `41317441` to successfully hijack execution.
  prefs: []
  type: TYPE_NORMAL
- en: Also note in [Figure 18-8](ch18.xhtml#execution_is_passed_to_the_overwritten_s
    "Figure 18-8. Execution is passed to the overwritten SEH.") that when execution
    is passed to SEH, many of our registers have been zeroed out. This might make
    jumping to an attacker-controlled register more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: '![Execution is passed to the overwritten SEH.](httpatomoreillycomsourcenostarchimages2030554.png.jpg)Figure 18-8. Execution
    is passed to the overwritten SEH.'
  prefs: []
  type: TYPE_NORMAL
- en: Of the registers that have not been zeroed out, none appears to point to a portion
    of our attack string. Clearly, a simple `JMP ESP` in SEH will not work to redirect
    execution to attacker-controlled memory. Things are still looking pretty bleak
    in our search for exploitability.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Attack String in Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, in this case, we already have a working saved return pointer overwrite
    exploit. However, some programs will be vulnerable only to SEH overwrites, so
    developing a method to exploit these issues is of the utmost importance. Luckily,
    an attacker-controlled memory address is on the horizon for SEH overwrites. As
    shown in [Figure 18-9](ch18.xhtml#following_esp_on_the_stack "Figure 18-9. Following
    ESP on the stack"), highlight the ESP register in Immunity Debugger, right-click,
    and select **Follow in Stack**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Following ESP on the stack](httpatomoreillycomsourcenostarchimages2030556.png.jpg)Figure 18-9. Following
    ESP on the stack'
  prefs: []
  type: TYPE_NORMAL
- en: Though the contents of the ESP register do not point to any part of our cyclic
    pattern, two steps down from ESP, at ESP+8, we see that memory address `00AFD94`
    points to our cyclic pattern in memory, as shown in [Figure 18-10](ch18.xhtml#cyclic_pattern_eight_bytes_higher_than_e
    "Figure 18-10. Cyclic pattern eight bytes higher than ESP"). If we can find a
    way to remove two elements from the stack and then execute the contents of this
    memory address, we can execute shellcode in place of the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cyclic pattern eight bytes higher than ESP](httpatomoreillycomsourcenostarchimages2030558.png.jpg)Figure 18-10. Cyclic
    pattern eight bytes higher than ESP'
  prefs: []
  type: TYPE_NORMAL
- en: The location of NSEH is `00AFFD94`, as noted by the output of Mona’s `findmsp`
    command. We can verify this by right-clicking `00AFFD94` in the stack pane and
    clicking **Follow in Stack**, as shown in [Figure 18-11](ch18.xhtml#cyclic_pattern_in_the_pointer_to_the_nex
    "Figure 18-11. Cyclic pattern in the pointer to the next SEH record").
  prefs: []
  type: TYPE_NORMAL
- en: '![Cyclic pattern in the pointer to the next SEH record](httpatomoreillycomsourcenostarchimages2030560.png.jpg)Figure 18-11. Cyclic
    pattern in the pointer to the next SEH record'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, SEH entries are eight-byte-long linked lists consisting
    of a pointer to the next SEH record in the chain and the memory address of the
    handler on the stack. If we can load ESP+8 into EIP, we can execute some shellcode.
    Unfortunately, it looks like we have only four bytes to work with before we hit
    the SEH entry itself, but let’s deal with one problem at a time. We need to find
    a viable way of getting to our shellcode, and then we will return to making our
    shellcode fit into the space available.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let’s verify that our offsets are correct, as shown in [Example 18-3](ch18.xhtml#verifying_overwrite_offsets
    "Example 18-3. Verifying overwrite offsets").
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-3. Verifying overwrite offsets
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Edit your exploit program to send over 569 *A*s, followed by 4 *B*s, followed
    by 4 *C*s, and rounding out the 1,150 byte attack string with 573 *D*s at ❶. Restart
    War-FTP and run the exploit again. We see in [Figure 18-12](ch18.xhtml#seh_is_overwritten_by_four_csdot
    "Figure 18-12. SEH is overwritten by four Cs.") that SEH is overwritten by our
    4 *C*s.
  prefs: []
  type: TYPE_NORMAL
- en: '![SEH is overwritten by four Cs.](httpatomoreillycomsourcenostarchimages2030562.png.jpg)Figure 18-12. SEH
    is overwritten by four Cs.'
  prefs: []
  type: TYPE_NORMAL
- en: If we again type shift-F9 to pass the exception handler to the crashed program,
    War-FTP crashes a second time when accessing the memory address `43434343`, our
    *C*s. Now follow the ESP register in the stack. As shown in [Figure 18-13](ch18.xhtml#espplus8_is_attacker_controlleddot
    "Figure 18-13. ESP+8 is attacker controlled."), ESP+8 points to a memory address
    filled with the four *B*s followed by our four *C*s and then the *D*s.
  prefs: []
  type: TYPE_NORMAL
- en: '![ESP+8 is attacker controlled.](httpatomoreillycomsourcenostarchimages2030564.png.jpg)Figure 18-13. ESP+8
    is attacker controlled.'
  prefs: []
  type: TYPE_NORMAL
- en: Our offsets are correct. Now to find a way to redirect execution to ESP+8\.
    Unfortunately, a simple `JMP ESP` won’t cut it this time.
  prefs: []
  type: TYPE_NORMAL
- en: POP POP RET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need an instruction, or series of instructions, that will allow us to move
    eight bytes down the stack and then execute the contents of the memory address
    located at ESP+8\. To figure out the assembly instructions we need, we must consider
    how the stack works.
  prefs: []
  type: TYPE_NORMAL
- en: The stack is a last-in, first-out (LIFO) structure. The analogy of a stack of
    trays in a cafeteria is often used for this concept. The last tray put on the
    stack by cafeteria staff is the first one grabbed by a cafeteria patron. The assembly
    command equivalents of the tray being added to the stack and then picked up by
    a patron are `PUSH` and `POP`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that ESP points to the top (lowest memory address) of the current stack
    frame. If we use the `POP` instruction to pop one entry (four bytes) off the stack,
    ESP will now point to ESP+4\. Thus, if we execute two `POP` instructions in succession,
    ESP will now point to ESP+8, which is exactly what we are going for.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to redirect our execution to our attacker-controlled string, we need
    to load the value of ESP+8 (now in ESP after our two `POP` instructions) into
    EIP (the next memory address to be executed). Luckily, there’s an instruction
    for that, namely, the `RET` instruction. By design, `RET` takes the contents of
    the ESP register and loads them into EIP to be executed next.
  prefs: []
  type: TYPE_NORMAL
- en: If we can find these three instructions, `POP` *`<some register>`*, `POP` *`<some
    register>`*, `RET` (often abbreviated by exploit developers as `POP POP RET`),
    we should be able to redirect the program’s execution by overwriting SEH with
    the memory address of the first `POP` instruction. The contents of ESP will then
    be popped into the register indicated by the instruction. We don’t particularly
    care which register gets the honor of holding the popped-off data, as long as
    it’s not ESP itself. We care only about burning things off the stack until we
    get to ESP+8.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the second `POP` instruction is executed. Now ESP points to the original
    ESP+8\. Then, the `RET` instruction is executed, and ESP (ESP+8 when the SEH was
    executed) is loaded into EIP. Recall from the previous section that ESP+8 held
    a memory address that points to byte 569 of our attacker-controlled string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with `JMP ESP`, it is not a hard requirement that we find `POP POP RET` instructions.
    Logical equivalents, such as adding eight bytes to ESP followed by a `RET` and
    others, would work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: Though this technique is a little more complicated, it’s similar to the saved
    return pointer buffer overflow exercise we completed in [Chapter 17](ch17.xhtml
    "Chapter 17. A Stack-Based Buffer Overflow in Windows"). We are hijacking the
    program’s execution and redirecting it to our shellcode. Now we need to find an
    instance of `POP POP RET` instructions in War-FTP or its executable modules.
  prefs: []
  type: TYPE_NORMAL
- en: SafeSEH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As SEH overwrite attacks have become prevalent, Microsoft has come up with ways
    to stop them from working. One such example is SafeSEH. Programs compiled with
    SafeSEH record the memory locations that will be used for structured exception
    handling, which means that attempts to redirect execution to a memory location
    with `POP POP RET` instructions will fail the SafeSEH check.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to realize that even if DLLs in Windows XP SP2 and later are
    compiled with SafeSEH, third-party software doesn’t have to implement this mitigation
    technique. If War-FTP or any of its custom DLLs do not use SafeSEH, we may not
    have to deal with this check.
  prefs: []
  type: TYPE_NORMAL
- en: Mona will determine which modules are not compiled with SafeSEH in the process
    of finding the `POP POP RET` instructions when we use the command `!mona seh`,
    as shown in [Figure 18-14](ch18.xhtml#running_the_seh_command_in_mona "Figure 18-14. Running
    the SEH command in Mona").
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the SEH command in Mona](httpatomoreillycomsourcenostarchimages2030566.png.jpg)Figure 18-14. Running
    the SEH command in Mona'
  prefs: []
  type: TYPE_NORMAL
- en: The results of `!mona seh` are written to *C:\logs\war-ftpd\seh.txt*, as shown
    in part here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, the only modules without SafeSEH are the War-FTP
    executable itself and a War-FTP-included DLL called *MFC42.dll*. We need to choose
    an instance of `POP POP RET` (or a logical equivalent) from Mona’s output that
    avoids the four bad characters discussed in [Chapter 17](ch17.xhtml "Chapter 17. A
    Stack-Based Buffer Overflow in Windows") (\x00, \x40, \x0a, \x0d). (To have Mona
    automatically exclude entries with bad characters during the search, enter **`!mona
    seh -cpb "\x00\x40\x0a\x0d"`**. One such address is `5F4580CA`. The instructions
    are `POP` `EBX`, `POP EBP`, `RET`. Again, we don’t care where the instructions
    are stored, as long as we `POP` two entries off the stack. If we overwrite SEH
    with the address `5F4580CA`, these instructions will be executed, and we will
    redirect execution to our attack string.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, set a breakpoint at `5F4580CA` with `bp 0x5F4580CA`, as shown
    in [Figure 18-15](ch18.xhtml#breakpoint_at_the_pop_pop_ret "Figure 18-15. Breakpoint
    at the POP POP RET").
  prefs: []
  type: TYPE_NORMAL
- en: '![Breakpoint at the POP POP RET](httpatomoreillycomsourcenostarchimages2030568.png.jpg)Figure 18-15. Breakpoint
    at the `POP POP RET`'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the four *C*s in the previous exploit with the `POP POP RET` memory
    address in little-endian format, as shown in [Example 18-4](ch18.xhtml#replacing_the_seh_overwrite_with_pop_pop
    "Example 18-4. Replacing the SEH overwrite with POP POP RET").
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-4. Replacing the SEH overwrite with `POP POP RET`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now run the exploit again. As you can see in [Figure 18-16](ch18.xhtml#seh_overwritten_with_a_pop_pop_ret_addre
    "Figure 18-16. SEH overwritten with a POP POP RET address"), the program crashes
    again, and, as expected, SEH is overwritten with `5F4580CA`.
  prefs: []
  type: TYPE_NORMAL
- en: '![SEH overwritten with a POP POP RET address](httpatomoreillycomsourcenostarchimages2030570.png.jpg)Figure 18-16. SEH
    overwritten with a `POP POP RET` address'
  prefs: []
  type: TYPE_NORMAL
- en: Type shift-F9 to let the program pass the overwritten exception handler. As
    expected, we hit our breakpoint, as shown in [Figure 18-17](ch18.xhtml#we_hit_our_breakpointdot
    "Figure 18-17. We hit our breakpoint.").
  prefs: []
  type: TYPE_NORMAL
- en: '![We hit our breakpoint.](httpatomoreillycomsourcenostarchimages2030572.png.jpg)Figure 18-17. We
    hit our breakpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: The CPU pane (top left) shows that the next instructions to be executed are
    the `POP POP RET`. Press **F7** to step through the instructions one at a time,
    and watch what happens to the stack (bottom right) as you do. You will see ESP
    move down to a higher address as we execute the `POP` instructions. As you can
    see in [Figure 18-18](ch18.xhtml#execution_is_redirected_to_your_attack_s "Figure 18-18. Execution
    is redirected to your attack string."), when we execute the `RET` instruction
    we end up in our attack string, at the pointer to the NSEH record, which is currently
    filled with four *B*s.
  prefs: []
  type: TYPE_NORMAL
- en: '![Execution is redirected to your attack string.](httpatomoreillycomsourcenostarchimages2030574.png.jpg)Figure 18-18. Execution
    is redirected to your attack string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have solved our first problem: We have redirected the program’s execution
    to our attack string. Unfortunately, as we can see in [Figure 18-18](ch18.xhtml#execution_is_redirected_to_your_attack_s
    "Figure 18-18. Execution is redirected to your attack string."), we only have
    four useable bytes before we run into our SEH overwrite address, `5F4580CA`. We
    have a long string of *D*s after the SEH address, but currently we are stuck with
    only four bytes to work with. We won’t be able to do much with only four bytes
    of shellcode.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a Short Jump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to somehow bypass the return address and get to our long string of *D*s,
    which has plenty of space for our final shellcode. We can use the `short jump`
    assembly instruction to move EIP a short distance. This method is ideal for our
    purposes because we need to jump over the four bytes of the SEH overwrite.
  prefs: []
  type: TYPE_NORMAL
- en: The hexadecimal representation of a short jump is `\xEB` *`<length to jump>`*.
    Padding the short jump instruction `\xEB` *`<length to jump>`* with two bytes
    to take up all four bytes before the SEH overwrite, we can jump forward six bytes
    over the padding and the SEH overwrite.
  prefs: []
  type: TYPE_NORMAL
- en: Edit the attack string to include a short jump, as shown in [Example 18-5](ch18.xhtml#adding_a_short_jump
    "Example 18-5. Adding a short jump").
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-5. Adding a short jump
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As shown in [Example 18-5](ch18.xhtml#adding_a_short_jump "Example 18-5. Adding
    a short jump"), this time we replace the NSEH (previously four *B*s) with `"\xEB\x06"
    + "B" * 2`. Reset your breakpoint at the `POP POP RET` before running the exploit
    again, and when you hit the breakpoint, step through the program line by line
    (F7) to see what is happening. Now after the `POP POP RET` we have a six-byte
    short jump, as shown in [Figure 18-19](ch18.xhtml#execution_is_redirected_to_the_short_jum
    "Figure 18-19. Execution is redirected to the short jump.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Execution is redirected to the short jump.](httpatomoreillycomsourcenostarchimages2030576.png.jpg)Figure 18-19. Execution
    is redirected to the short jump.'
  prefs: []
  type: TYPE_NORMAL
- en: Now press **F7** to execute the short jump. As shown in [Figure 18-20](ch18.xhtml#short_jump_gets_us_past_the_seh_overwrit
    "Figure 18-20. The short jump gets us past the SEH overwrite."), the short jump
    successfully bypasses the SEH overwrite address and redirects execution to the
    rest of our attack string (*D*s).
  prefs: []
  type: TYPE_NORMAL
- en: '![The short jump gets us past the SEH overwrite.](httpatomoreillycomsourcenostarchimages2030578.png.jpg)Figure 18-20. The
    short jump gets us past the SEH overwrite.'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Payload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now redirected execution a second time, to a longer part of our controlled
    memory—an ideal place for our shellcode. Now to choose a payload and generate
    it with Msfvenom, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember to tell Msfvenom to use a maximum size of 573 bytes and exclude our
    bad characters for the FTP username. (Again, you might be able to go a little
    bit longer, but our original exception occurs because we are writing off the end
    of the stack. We want to make sure all of our shellcode is executed.) Now add
    the shellcode to our exploit in place of the *D*s. To make the exploit long enough
    to trigger the SEH overwrite (instead of the saved return pointer overwrite we
    saw in [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow in Windows")),
    pad the exploit string out to 1,150 characters with *D*s. The finished exploit
    is shown in [Example 18-6](ch18.xhtml#finished_seh_overwrite_exploit "Example 18-6. The
    finished SEH overwrite exploit"). Our shellcode goes directly after our SEH overwrite.
    (In this example, we again use a Windows bind shell.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-6. The finished SEH overwrite exploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When War-FTP is attached to Immunity Debugger, we have to manually tell the
    debugger to pass SEH to the program. When we run War-FTP without a debugger and
    an error is encountered, execution is automatically passed to SEH, executing `POP
    POP RET`, the short jump, and finally our shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully built an SEH overwrite exploit for War-FTP. Though War-FTP
    allowed us to exploit the buffer overflow vulnerability by directly overwriting
    a return address or SEH, some vulnerable programs will not crash in a way that
    will allow you to control EIP but will allow you to overwrite SEH. In such cases,
    knowing the steps to exploit this sort of crash is paramount to creating a working
    exploit. Due to the way structured exception handlers work, you can count on NSEH
    being at ESP+8 every time you encounter this type of crash. When you overwrite
    SEH, you will find the pointer to the next SEH record at ESP+8\. After executing
    a `POP POP RET` series of instructions from a module that is not compiled with
    SafeSEH, you will need to execute a short jump to get to your shellcode in the
    attack string. If you continue in exploit development, you may run into another
    challenge where `\xEB` is a bad character, so you will need to find other ways
    of performing a jump.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will finish up our study of the basics of exploit development
    with a few odds and ends, such as first discovering a crash using a technique
    called *fuzzing*, porting public exploit code to meet our needs, and writing our
    own Metasploit modules.
  prefs: []
  type: TYPE_NORMAL
