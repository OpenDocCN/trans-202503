- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'THE PI CAMERA: SELFIE SNAPPER'
  prefs: []
  type: TYPE_NORMAL
- en: PHOTOGRAPHS HAVE BECOME A STAPLE OF OUR DAILY LIVES, THANKS TO THE WIDESPREAD
    INTRODUCTION OF CAMERAS INTO EVERYDAY MOBILE PHONES. IN 2016, THE NUMBER OF PHOTOS
    TAKEN EXCEEDED THE TOTAL NUMBER EVER TAKEN SINCE THE INVENTION OF THE CAMERA.
    IN THIS CHAPTER, YOU’LL LEARN HOW TO TAKE PHOTOS WITH THE RASPBERRY PI CAMERA
    MODULE MADE EXCLUSIVELY FOR THE RASPBERRY PI HARDWARE.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll set up and configure the Pi Camera to take photos. Next, you’ll move
    on to some of the more advanced features, such as adding filters, customizing
    photo quality, and adding a trigger button. Then you’ll learn how to use the Pi
    Camera to record video. As a final project, you’ll create a time-lapse video that
    you can use to capture a sunrise or sunset, a plant growing, a candle burning,
    or whatever you fancy.
  prefs: []
  type: TYPE_NORMAL
- en: WHAT YOU’LL NEED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the items you’ll need for this simple introduction to the Pi Camera:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pi Camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pi Camera ribbon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 male-to-female jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A push button (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alligator clips or soldering iron and solder (to attach wires to the buttons)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VERSIONS AND SPECIFICATIONS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A few models of the Pi Camera are available, including one designed specifically
    for night vision. All versions of the Raspberry Pi support the Pi Camera hardware
    as well as the camera ribbon used to connect your Pi to the camera. The ribbon
    is available in a variety of lengths so you can position the camera exactly where
    you need it to get the photos or video you want. This table contains the Pi Camera
    specifications.
  prefs: []
  type: TYPE_NORMAL
- en: '| **VERSION** | **IMAGE RESOLUTION** | **SENSOR RESOLUTION** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Camera Module v1 | 5 megapixels | 2592 × 1944 pixels |'
  prefs: []
  type: TYPE_TB
- en: '| Camera Module v2 | 8 megapixels | 3280 × 2464 pixels |'
  prefs: []
  type: TYPE_TB
- en: '| Pi NoIR Camera Module v2 | Used for nighttime photography |'
  prefs: []
  type: TYPE_TB
- en: The official Pi Zero case comes with a smaller ribbon and a camera housing built
    into the top of the case’s lid, providing you with a neat, small, and portable
    camera.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, you’ll need either the regular Camera Module v1 or v2.
  prefs: []
  type: TYPE_NORMAL
- en: PHOTOGRAPHY WITH THE PI CAMERA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll first put the camera together, and then you’ll learn to take and store
    photos. Next, I’ll show you how to customize your photography by altering the
    resolution, resizing images, using filters, and adding text. Then you’ll make
    the camera more user-friendly by adding a button to take the shot.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Hardware and Software
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s begin by attaching and enabling the Pi Camera hardware and then writing
    a small test program to check that it works correctly. Before you begin, *ensure
    that no power is connected to your Pi* and that your Pi is unplugged. Then follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attach the camera:** Connect the ribbon cable to the Pi Camera ([Figure 4-1](ch04.xhtml#ch04fig01)).
    Depending on where you purchased your Pi Camera, this might already be done for
    you. If not, gently pull the small plastic clasp on the back of the camera downward
    and slide the ribbon in with the blue strip facing you. Gently push the clasp
    up, securing the ribbon.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the Pi Camera socket on the Pi, which is located between the HDMI socket
    and the audio jack. Notice that it also has a clasp similar to the clasp on the
    Pi Camera. Gently pull up this clasp to open it. Take the other end of the ribbon
    and place it into the socket, with the blue strip facing toward the audio jack
    and away from the HDMI socket. Gently push the clasp back down to secure the ribbon
    in place. Be very gentle when you’re handling the camera ribbon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/04fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-1** Attaching the Pi Camera to the Raspberry Pi'
  prefs: []
  type: TYPE_NORMAL
- en: '**Install the Pi Camera software:** Boot up your Pi, open the terminal window,
    and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once that command has run, enter this command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Pi Camera software comes preinstalled with the operating system image and
    includes a Python package that interfaces with the camera. In the future, you
    might need to reinstall or update the package when newer versions are released,
    which you can do using the following commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Enable the Pi Camera:** By default, the camera is set to *off*. You can’t
    use it until you configure it to turn on. To do this, return to the terminal window
    and enter the following command to open the Configuration tool ([Figure 4-2](ch04.xhtml#ch04fig02)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Image](../images/04fig02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 4-2** Enabling the Pi Camera'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the Configuration tool, select **Interfacing Options**. Then select the option
    to enable the connection to the Pi Camera ([Figure 4-3](ch04.xhtml#ch04fig03)).
    Use the arrow keys to select **Exit** and press ENTER. You’ll be prompted to restart
    the Raspberry Pi before the Pi Camera is enabled. Select **Yes** to restart. Now
    you can test that the camera is connected and working correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/04fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-3** Selecting the Pi Camera option'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Pi Camera
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To test the camera, you’ll run the preview feature. Open a new Python file and
    enter the program in [Listing 4-1](ch04.xhtml#ch04ex01). This simple code triggers
    the camera to display on your monitor for 10 seconds whatever the camera captures.
    By using this code, you’ll test that the camera is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 4-1** Testing the camera'
  prefs: []
  type: TYPE_NORMAL
- en: First, you import the `PiCamera` class from the `picamera` library ❶. This provides
    code that lets you control the camera. Next, you import the `sleep``(``)` function
    ❷ so you can add the 10-second delay to make the image display on your screen
    for 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Then you create a variable called `camera` to store the `PiCamera``(``)` instruction
    ❸. This lets you call the Pi Camera and control it without having to write out
    `PiCamera``(``)` each time. *Variables* are placeholders representing a location
    in the Raspberry Pi’s memory that stores content. For example, if you make a `name`
    variable such as `name = "Dan` `Aldred``"`, whenever you use `name` in your code,
    Python will use the content of `name` and insert `Dan` `Aldred` into the program
    instead of `name`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you trigger the preview by telling the camera to start ❹ and add the 10-second
    delay ❺. The last step stops the preview ❻, turning off the camera.
  prefs: []
  type: TYPE_NORMAL
- en: To run the program, press **F5** on your keyboard; you’ll be asked to save the
    file. Name and save your program; then it will execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can see the preview on your screen, your hardware and software are working.
    If you don’t see the preview, the camera doesn’t work: check that the cable is
    attached to the camera correctly and connected to your Raspberry Pi. Then check
    that the camera is enabled in the Configuration tool.'
  prefs: []
  type: TYPE_NORMAL
- en: The program will stop after 10 seconds. But if you want to end the program sooner,
    close the Python window by clicking the **X** at the top right of the window.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a Selfie
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once your camera is working, you can create a program to take your first picture,
    a selfie ([Figure 4-4](ch04.xhtml#ch04fig04)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-4** Take that selfie!'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new text editor window, save the file as *selfie.py*, and then enter
    the program in [Listing 4-2](ch04.xhtml#ch04ex02). This program starts a preview
    for 5 seconds, allowing you time to get in front of the camera, fix your hair,
    and practice your pose before the camera automatically takes the picture.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 4-2** Taking a selfie'
  prefs: []
  type: TYPE_NORMAL
- en: Again, you import the `P``i``C``amera` class and `sleep``(``)` function, and
    then you use the `camera` variable to store the `PiCamera``()` command. Then you
    start a preview and add a 5-second delay (or longer if you like). You trigger
    the camera to capture the image ❶ and save it to the desktop so it’s easy to locate.
    The file is saved and named *selfie.jpg*.
  prefs: []
  type: TYPE_NORMAL
- en: The preview stops, and the program ends. Save and run the program, snap a selfie,
    and then return to your desktop and open the image to check out your photo.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the File Location Where the Image Is Saved
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you take several selfies at once, they’ll soon clutter your desktop space.
    To keep your selfies organized, it’s best to create a new folder to neatly store
    and save all your images.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new folder, open the terminal and enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The command `mkdir`, which is short for *make a directory*, creates a new folder
    in your home directory called *my_photos*. Now go back to your *selfie.py* file
    and edit the line `camera.capture(''/home/pi/`Desktop`/selfie.jpg'')` ❶, replacing
    the word *Desktop* with the name of your new folder. Unless you’ve used a different
    folder name, the new line should read as follows: `camera.capture``(``''/home/pi/``my_photos``/selfie.jpg'')`.'
  prefs: []
  type: TYPE_NORMAL
- en: Saving Each Image as a New File
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Notice that each time you take a new photo and save the image, the program overwrites
    the previous image file. This isn’t a very useful feature if you want to keep
    all your photos. This happens because your program saves each image by using the
    same filename. You can solve this problem by adding a date stamp to the image
    filename.
  prefs: []
  type: TYPE_NORMAL
- en: '*Date stamps* contain the date and time information indicating when the image
    was taken. The information is retrieved from the Raspberry Pi’s clock and, because
    time always moves forward, each filename is always unique. Alter the *selfie.py*
    file to match the program in [Listing 4-3](ch04.xhtml#ch04ex03).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 4-3** Saving all the images'
  prefs: []
  type: TYPE_NORMAL
- en: Most of this code is similar to the previous selfie program in [Listing 4-2](ch04.xhtml#ch04ex02).
    The code you need to change is at ❶, ❷, and ❸.
  prefs: []
  type: TYPE_NORMAL
- en: You import the `datetime` module ❶ to pull the current date and time from the
    clock. You create a loop that makes the Pi Camera take a photo every 10 seconds.
    This will give you enough time to check the preview and then pose for your next
    photo. Then you create a variable called `current_time` ❷ and use `datetime.datetime.now``(``)`
    to grab the current date and time and store the result in the variable.
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the code applies the date stamp value as the image’s filename
    ❸. You use the `camera.capture` code from [Listing 4-2](ch04.xhtml#ch04ex02) followed
    by the file location to store the image. But this time, you add the value stored
    in the `current_time` variable. Because the date stamp is numerical, you need
    to convert it to a string before using it as a filename. This code will now save
    all image names with a unique date stamp!
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Your Images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve set up the Pi Camera’s hardware and software, you’re ready to
    learn about customizing your images. Let’s start by reviewing some image terminology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Images are made up of picture elements more commonly referred to as *pixels*.
    These tiny dots are turned on or off in a pattern that creates the overall image.
    The *image quality* is determined by the number of pixels the image contains compared
    to its size: consider the difference between 1000 pixels on a small 1 × 1–inch
    square and 1000 pixels on a large sheet of ledger paper. The quality of the image
    on the ledger sheet would be lower, even though the pixel number is the same.'
  prefs: []
  type: TYPE_NORMAL
- en: An image’s size and number of pixels is referred to as its *resolution*. For
    example, an image with a resolution of 100 × 100 contains 100 rows, each containing
    100 pixels, for a total of 10,000 pixels. A standard, true HD TV resolution is
    1080 × 1080, meaning the screen contains 1,166,400 pixels. If you were watching
    a program that contained only a million pixels on this set, the picture would
    be 166,400 pixels short of the full potential of the TV screen, and the image
    quality would decrease. But if you were watching the same program on a tablet
    device, you wouldn’t notice a decrease in image quality because the tablet is
    smaller and the pixels would be less spread out.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll learn how to control the quality of your pictures by changing the
    resolution. Later in this section, you’ll further customize your images by resizing,
    using filters, and adding text.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Resolution
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can alter the resolution of the Pi Camera by using the code `camera.resolution
    = (500 x 500)`, which sets the image to a height and width of 500 pixels. This
    is useful because the Pi Camera v2 has a resolution of 3280 × 2464 pixels, meaning
    that every image you take contains 8,081,920 pixels. The adjusted image of 500
    × 500 will now contain only 250,000 pixels, so the file will be smaller and consume
    less storage space.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that different resolutions are more suitable for different screen sizes.
    Adjusting the resolution ensures that you save storage space on your Raspberry
    Pi. You might not always need an image that contains 8,081,920 pixels!
  prefs: []
  type: TYPE_NORMAL
- en: Open your *selfie.py* file and edit it to look like the program in [Listing
    4-4](ch04.xhtml#ch04ex04) to try out different camera resolutions and find one
    suitable for your screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 4-4** Changing the resolution of the image'
  prefs: []
  type: TYPE_NORMAL
- en: The program sets the camera resolution to 1024 × 768 ❶, takes a single photo,
    and then names and saves the file as the current date and time when the photo
    was taken. This size is the standard resolution setting for a 17-inch screen;
    each image will contain only 786,432 pixels, compared to the maximum resolution
    of 8,081,920 pixels. This image has approximately nine times fewer pixels than
    the full capability of the Pi Camera v2\. Try different resolution settings by
    adjusting the values on line ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing an Image
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Resizing an image is optional, but it’s a good skill to learn. If you size the
    image inappropriately for the number of pixels it contains, the pixels will start
    to crowd each other out and overlap, distorting the image. A lower resolution
    is useful for small screens, and a higher resolution is suitable for large screens.
    4K screens require 8,294,400 pixels to fill the screen and look clear. If you
    had half these pixels, the pixels would space out and lower the image quality.
    In order to keep a similar image quality, you would need to reduce the size of
    the image and display it on a smaller screen.
  prefs: []
  type: TYPE_NORMAL
- en: One workaround is to resize the image after you take the photograph. Adjusting
    resolution and resizing images are particularly useful skills for projects for
    which you’re capturing images over a long period of time, like the nature box
    project in [Chapter 11](ch11.xhtml#ch11).
  prefs: []
  type: TYPE_NORMAL
- en: Open your program from [Listing 4-4](ch04.xhtml#ch04ex04) and alter it to look
    like [Listing 4-5](ch04.xhtml#ch04ex05). This program resizes the image to be
    more appropriate for the resolution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 4-5** Changing the size of the image'
  prefs: []
  type: TYPE_NORMAL
- en: 'You make the line `camera.resolution` at ❶ into a comment, which stops the
    line of coding from running. After you capture the image, you add the code to
    resize the image: `resize=(600, 600)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Try altering the values within the parentheses to suit your screen size. Generally,
    the smaller the screen is, the lower the resize values are; the larger the screen
    is, the larger the values are. Experiment with the values to find a balance between
    the quality of the image and the amount of storage (memory) required to save each
    image. Remember that the higher the image quality is, the more space is required
    to store it; the lower the quality is, the less space is required to store it.
  prefs: []
  type: TYPE_NORMAL
- en: Using Filters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Filters* instantly change a picture’s style. Most likely, you’ve used filters
    like the classic sepia, beauty shot, and retro filters on camera apps. The Pi
    Camera also boasts a range of easy-to-use filters ([Figure 4-5](ch04.xhtml#ch04fig05)).
    To apply a filter, you use the code `camera.image_effect` and then add the name
    of the filter.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-5** Applying filters: emboss, watercolor, and negative'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the *emboss* filter, which makes the image appear raised, similar
    to the design you find on coins. Open your program code from [Listing 4-5](ch04.xhtml#ch04ex05),
    and add the line at ❶ in [Listing 4-6](ch04.xhtml#ch04ex06).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 4-6** Adding a filter'
  prefs: []
  type: TYPE_NORMAL
- en: This program saves each file as *photo.jpg*, so each time you run it, the previous
    image file will be overwritten with the new one. If you want to keep each copy
    of your filtered image, change the filename that you use to save the image at
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also could use other filters. Try each of the following filters by replacing
    `''``emboss``''` at ❶ with a keyword listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''``watercolor''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``cartoon''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``negative''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``sketch''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``denoise``''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``oilpaint``''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``hatch''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``pastel''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``film''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``blur''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``colorswap``''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``washedout``''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''``posterise``''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Text to an Image
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s look at how to overlay text on your images to add a message, a title,
    or just a reminder. You can also combine this feature with the date stamp so the
    date and time the photo was taken are included in the final image.
  prefs: []
  type: TYPE_NORMAL
- en: Return to your code from [Listing 4-5](ch04.xhtml#ch04ex05) and add the line
    in bold in [Listing 4-7](ch04.xhtml#ch04ex07).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 4-7** Adding a text overlay'
  prefs: []
  type: TYPE_NORMAL
- en: The line of code to add text is `camera.annotate_text`; you just need to replace
    THIS IS A TEXT OVERLAY at ❶ with your own message, and then save and run the program
    ([Figure 4-6](ch04.xhtml#ch04fig06)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-6** Adding a text overlay to an image'
  prefs: []
  type: TYPE_NORMAL
- en: Triggering the Camera with a Button
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ve written a program to take photos, but you need to run the program each
    time you want to take a photo. If you want to take 100 photos, you’ll need to
    run the program 100 times. Let’s make the camera more camera-like by hooking up
    a simple button that, when pressed, triggers the camera to take a photo.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the Button
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You’ll use a push button and the two jumper wires to connect it. You can wire
    the button in various ways depending on what type of button you have:'
  prefs: []
  type: TYPE_NORMAL
- en: Use wires with alligator clips and attach the clips to the button’s legs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tape the wire and legs together, making sure they’re touching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slide wires onto the legs of the button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solder the wires to the legs of the button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soldering is a more permanent but trickier option. This technique requires you
    to superheat *solder* (typically, a metal alloy made of lead and tin) until it
    turns to liquid. You then use the liquid to join the wire and the arm. When you
    remove the heat, the solder hardens again, fusing the wires together. You need
    special equipment to solder, including a soldering iron and a safe surface to
    solder on. If you’ve never soldered before, check out the Raspberry Pi Foundation’s
    excellent guide at *[https://projects.raspberrypi.org/en/projects/getting-started-with-soldering](https://projects.raspberrypi.org/en/projects/getting-started-with-soldering)*/.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose the soldering method, carefully solder each male end of the jumper
    wire onto one of the arms. Once the solder has cooled down and set, attach the
    female end of one of the wires to GPIO pin 2\. Attach the female end of the other
    wire to one of the ground pins ([Figure 4-7](ch04.xhtml#ch04fig07)). It doesn’t
    matter which wire attaches to pin 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-7** Wiring the button'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you don’t have a button, you can still create a trigger by attaching one
    end of the wires to the required GPIO pins and then touching the other end of
    the two wires together. This makes a circuit that acts like a button press and
    triggers the Pi Camera to take a photo.*'
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Button
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To code the button, return to your Python editor and create a new file. Then
    enter the program in [Listing 4-8](ch04.xhtml#ch04ex08) and save this file as
    *selfie_snapper.py*. This program uses `gpiozero` to set up the button and trigger
    the Pi Camera to take a photo each time the button is pressed (or the wires touch
    each other). This is a library of code that makes it easy to interact with your
    Raspberry Pi hardware and the GPIO pins. You can read more about it here: *[https://gpiozero.readthedocs.io/en/stable/index.html](https://gpiozero.readthedocs.io/en/stable/index.html)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 4-8** Coding the trigger'
  prefs: []
  type: TYPE_NORMAL
- en: You import the `Button` class from the `gpiozero` library ❶, which provides
    commands to control the button. You then import the usual `P``i``C``amera` class
    and `datetime` module that you use to take photos and create unique filenames.
    The code at ❷ is used to keep the program looping and checking for the button
    being pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you tell the program which GPIO pin the button is connected to ❸, which
    is GPIO pin 2.
  prefs: []
  type: TYPE_NORMAL
- en: Then you start the main part of the program, which begins with the `capture``(``)`
    function. Here, you’re making your own function! You create a new custom function
    when a function that does what you want isn’t available. The `capture``(``)` function
    will capture, name, and save the image ❹.
  prefs: []
  type: TYPE_NORMAL
- en: To create a function, you use the `def` command, which means *define*, and then
    name the function. In this case, you call the function `capture`. You then need
    to add parentheses and a colon. *Don’t forget the colon*; it tells Python that
    the next few indented lines are part of the function, and the function won’t work
    without it.
  prefs: []
  type: TYPE_NORMAL
- en: On the next few lines, you list the function’s instructions. You need to indent
    these instructions by four spaces so Python knows they belong to the function.
    In this example, the instructions take a current date and time reading, save this
    data, capture the image, and save it to your folder. Because this reading returns
    the date and time, you can take photos the next day without overwriting the previous
    day’s photos. The filename will be combined with the date–time data to make sure
    it’s unique each time you take an image.
  prefs: []
  type: TYPE_NORMAL
- en: But you must convert the data to a string to use it with the filename, because
    date data has a value and can’t be combined with the *.jpg* extension. To do this,
    you use the code `/%s.jpg" %` `current_time`. The `%` symbol holds the `current_time`
    value, and the `s` converts the data to a string.
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the function prints a short message to let you know when a
    photo has been taken. Because that’s the last instruction in the `capture(``)`
    function, you don’t indent the following line so Python knows it isn’t part of
    `capture()`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve built the function, but to take a photo, you need to *call* the function
    in your code. You use the simple code `button.when_pressed = capture` ❺ from the
    `gpiozero` library to assign the function to the button so the button takes the
    photo.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you use the `pause(``)` command to ensure that the program runs again
    ❻, and you can take another picture.
  prefs: []
  type: TYPE_NORMAL
- en: Save your program and press **F5** to run it. Now, each time you press the button,
    it will take a new photo and save the image with a unique filename. Well done!
    You’ve built your own camera.
  prefs: []
  type: TYPE_NORMAL
- en: VIDEOS WITH THE PI CAMERA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code for taking videos using the Pi Camera is similar to the code for taking
    photos, and you can apply the same filters and settings that you learned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Video
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create a video, open a new Python file, name it *video.py*, and save it to
    your *my_photos* folder. Enter the program in [Listing 4-9](ch04.xhtml#ch04ex09)
    to record a short clip.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 4-9** The video-recording code'
  prefs: []
  type: TYPE_NORMAL
- en: You import all of the modules of the `picamera` library ❶ and assign the Pi
    Camera to the `camera` variable ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, you can then set the resolution of the video ❸. Remember that a
    high resolution increases the overall quality of the video but also creates a
    larger file that demands more storage space.
  prefs: []
  type: TYPE_NORMAL
- en: Then you add the code to start the video recording ❹ and provide the folder
    location you want to save the video file to. You need to include a filename (in
    this case *video_test*) and the file format for saving the video; the format I’ve
    used here is `.h264`, which is a good format for high-definition video.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you add the length of time you want the video to record ❺. Recording time
    is measured in seconds, so to record for 1 minute, you change 10 to 60; to record
    for 5 minutes, change the value to 300 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: At ❻, you stop the video recording, which stops the camera and saves the video
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Run the program and take some video! Start with a short time to test the program,
    and then adjust the number of seconds on line ❺ to change the recording length.
    Press **F5** to save your recorded video.
  prefs: []
  type: TYPE_NORMAL
- en: Playing the Video
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you have a recording, navigate to the folder where you saved your video
    by opening the terminal and entering the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Press ENTER to go to the folder. Once you’re inside the media folder, you can
    see all the files in that folder by entering this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see your *video_test* file. To play the video, enter the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command opens the OMXPlayer and displays your video. The OMXPlayer uses
    the hardware of the Raspberry Pi to play back many popular audio and video file
    formats. Remember that size and quality will depend on the resolution that you
    set and recorded at.
  prefs: []
  type: TYPE_NORMAL
- en: Playing the Video on a Computer or Other Device
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You might want to share your video masterpiece with your friends and family
    or even upload it to a social media account. But in its current format, the video
    file won’t play on other devices (which won’t have OMXPlayer installed) unless
    they have a specific video *codec*, a program that reads a wide range of video
    file formats. So, you’ll convert the video file into the more common *.mp4* format,
    which will play on most tablets, phones, and smart TVs. Return to the terminal
    window and enter this command to install the converter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then enter this command to convert the video file to the *.mp4* format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once the conversion has completed, copy the file onto a memory stick, and you’re
    ready to play, edit, and share your video!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*VLC media player is a free video player that works across most devices and
    operating systems. On your Raspberry Pi, you can find VLC media player under Start*
    ▶ *Sound and Video. If you’re viewing your video on another device, you can download
    and access VLC media player from* [https://www.videolan.org/](https://www.videolan.org/)
    and play the video without having to convert it.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Time-Lapse Video
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *time-lapse video* is crafted from several hundred individual photos that,
    when combined, create a kind of animation effect. For example, you could take
    a time-lapse video of a candle burning over several hours by taking a photo every
    few minutes, and the video would show the burning process in just a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The more photos you take, the smoother the video will appear. But if you take
    too many images, you’ll lose the overall impact of the video.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project has two main phases: taking the photos and piecing together the
    time-lapse video. Let’s work through the steps to set up the project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the time-lapse program, it will potentially capture several hundred
    photos. So, before you write the program, you need to create a new folder for
    storing the images, to make sure they’re in one place and don’t get mixed up with
    other images from previous shoots. Return to the terminal and enter this command
    to return to the *home* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create a folder called *my_timelapse* by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you rename this folder, remember to change the file location and replace
    it with your folder name.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Time-Lapse Video Taker
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `picamera` library provides all the code you need to easily capture a time-lapse
    video. When you execute the program, it will run continuously until you stop it.
    You’ll tell the program how often to take a photo, and it will keep taking pictures.
    Open a new Python file, save it as *time_lapse.py*, and add the program in [Listing
    4-10](ch04.xhtml#ch04ex10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 4-10** The time-lapse code'
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be familiar with the first three lines of the code, which
    import the code you need to use and save the `PiCamera``(``)` command.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you add a small delay ❶ to allow the camera to prepare before it starts
    taking pictures.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you use a `for` *loop* ❷ to take a picture, rename it, print a message,
    and then wait 10 seconds. This loop spares you from having to write the same code
    over and over; without it, you’d have to add the same lines of code 1000 times
    to capture 1000 images. Recall that a loop doesn’t stop until either you stop
    the program or the program meets a specific condition or point.
  prefs: []
  type: TYPE_NORMAL
- en: After the loop, you use the standard `camera.capture``(``)` code to take photos
    ❷. But this time you also add `_continuous`, which ensures that the camera keeps
    taking photos forever or until you stop the program.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of that line, `/home/pi/my_timelapse/`, tells the Pi where to
    store the photos. Then it gives instructions on how to name the files so they’re
    not overwritten. Let’s break down how this code works.
  prefs: []
  type: TYPE_NORMAL
- en: First, you add the filename, which is *img*. Then you use the `counter(``)`
    function to count from 0 upward. Each time a photo is taken, the counter value
    is added to the filename *img*. The counter is set to a maximum number of digits;
    in this program, it’s set to `04d`, which means a maximum of four digits.
  prefs: []
  type: TYPE_NORMAL
- en: When the program executes, the first photo taken is saved as *img0000*, the
    next photo is saved as *img0001*, then *img0002*, and so on. Because you can use
    up to four digits, you can take 9999 images before they start overwriting each
    other. This number should be plenty! Depending on what you’re capturing, you might
    want to take fewer (or more) images. If so, all you have to do is adjust the `04d`
    value to `03d` for three digits, `02d` for two digits, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once the program has saved the image file, it prints the filename ❸ to your
    screen so you can check that the program is saving the files correctly. You can
    also see at a glance how many pictures the program has taken.
  prefs: []
  type: TYPE_NORMAL
- en: The final line of the program sets the time delay between each photo taken.
    A delay of 10 seconds ❹ allows you to test that the program is working correctly
    before deploying a longer time lapse. The camera will take a photo every 10 seconds
    until you terminate the program. In your real time-lapse video, you’ll want to
    use a longer delay time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run a test version of the program and create a time-lapse video. Save
    the program and press **F5** to run it. After about a minute or so, stop the program:
    remember, this is just to test it and create a time-lapse sequence ([Figure 4-8](ch04.xhtml#ch04fig08)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-8** Running the program and collecting the images'
  prefs: []
  type: TYPE_NORMAL
- en: Figuring Out the Delay Time
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The time delay you set should depend on what you’re filming. For example, consider
    that a candle takes three hours to burn. You could take a photo every minute by
    setting a delay of 60 seconds, which would result in 180 images. You could even
    set the delay to 30 seconds and take 360 images. Both settings would produce a
    good time-lapse video, depending on how long and how smooth you want it to be.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s consider filming a flower growing. This might take five days or more.
    Using the same settings would result in 14,400 images, which, at a rate of 30
    frames per second, would produce an 8-minute video clip. This is too long. Setting
    a delay of 1200 seconds would be more suitable and would take a photo every 20
    minutes. Your video would total 360 images and last for 12 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you set up your camera to take time-lapse images, make sure you consider
    the number of images and choose a suitable delay.
  prefs: []
  type: TYPE_NORMAL
- en: Putting Together the Video
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To make the time-lapse video, you need to stitch the photos together so they
    create the illusion of time passing. You’ll use the Libav software, which will
    convert, manipulate, and stream a wide range of multimedia formats for you. Here
    are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Install Libav:** Open the terminal and enter the following command to download
    all the Libav tools you’ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Navigate to the time-lapse folder:** Once the program has been installed,
    navigate to the *my_timelapse* folder that holds all your images by entering this
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Create the time lapse:** Enter this code in the terminal to run the Libav
    software and create the video (be sure to enter this line exactly as it appears):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The process locates each *.h264* image in the designated folder and then uses
    a codec to join it with the previous *.h264* file. Libav then converts the completed
    file to *.mp4* format and saves it as a file named *timelapse.mp4*. The conversion
    might take a while if you have hundreds of images. This is another reason for
    testing the setup before you deploy it on a five-day shoot!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Play the time lapse:** Now that your time-lapse test video is in *.mp4* format,
    you can copy it onto a memory stick or transfer it onto a laptop or other device
    and play it like any video file! Notice the speed at which the images are shown
    and how smooth it seems. You can use this test to decide how long you want the
    delay to be in the future.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making Your Own Time-Lapse Movie
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now you’re ready to set up your time-lapse camera. Calculate the number of images
    you need to take as well as the time period—whether it’s an hour, a day, or a
    week. Set the Pi Camera into position, and then start running the program. In
    my experience, it’s also worth leaving a note to let others know what your Pi
    is doing so they’re not tempted to turn it off. After the required time period,
    stop the program, move to the image folder, stitch the images together, and enjoy
    your video. Don’t forget to share your time-lapse creations so others can admire
    them.
  prefs: []
  type: TYPE_NORMAL
- en: WRAPPING UP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered some of the basics of using the Pi Camera, such as adding
    filters, changing settings, and taking photos, videos, and a time-lapse video.
    You can use the Pi Camera for many projects. How about making a stop-motion animation
    or setting up the camera to keep an eye on your pet and see what it gets up to
    while you are out? In [Chapter 11](ch11.xhtml#ch11), you’ll combine the Pi Camera
    with a motion sensor to remotely capture images of wildlife and upload them to
    Dropbox.
  prefs: []
  type: TYPE_NORMAL
