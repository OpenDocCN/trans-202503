<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_63"/><strong>6 NipPEr Is a buTt liCkeR</strong></h2>&#13;
<p class="noindent">In this chapter, we’ll discuss a buffer overflow vulnerability in a Dish Network smart-card, which was the subject of the famous lawsuit between EchoStar and NDS. The first public explanation of this bug was a short forum post, NipperClauz (2000), but thanks to the trial, we have far more detailed documentation in the form of a secret NDS internal tech report, Mordinson (1998).</p>&#13;
<p class="indent">First, let’s set the stage. This smart-card was used in North America for Dish Network’s satellite TV service, where it would calculate a short-lived decryption key for the receiver. The chip inside is an ST16CF54 chip from ST Microelectronics, then known as SGS Thomson. The instruction set is mostly compatible with Motorola 6805, except for the additional instructions TSA (<span class="literal">0x9E</span>) and MUL (<span class="literal">0x42</span>). The chip contains 16kB of user ROM, 8kB of system ROM, 4kB of EEPROM/OTP, and 480 bytes of SRAM. The user ROM was developed by Nagra while the system ROM was developed by SGS Thomson.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch6fig1">Figure 6.1</a> shows the memory layout of the chip, and <a href="ch06.xhtml#ch6fig2">Figure 6.2</a> the EEPROM layout. Note that the EEPROM is mirrored to three additional address ranges, such that each EEPROM byte can be read from four unique addresses. A similar mirroring effect, sometimes called ghosting, will become very important later in this chapter, just as it was in <a href="ch05.xhtml#ch05">Chapter 5</a>.</p>&#13;
<p class="indent">EEPROM patches consist of a single byte for the patch number, and a byte pair for the handler address of that patch. They are called before sensitive functions in a switch table, but there is no mechanism for patching ROM bugs that are not preceded by calls to the patch handler.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_64"/><img id="ch6fig1" src="../images/f0064-01.jpg" alt="Image" width="557" height="702"/></div>&#13;
<p class="figcap">Figure 6.1: ST16CF54 Memory Map</p>&#13;
<div class="image"><img id="ch6fig2" src="../images/f0064-02.jpg" alt="Image" width="570" height="185"/></div>&#13;
<p class="figcap">Figure 6.2: Nagra1/Rom3 EEPROM Map</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_65"/><img id="ch6fig3" src="../images/f0065-01.jpg" alt="Image" width="778" height="935"/></div>&#13;
<p class="figcap">Figure 6.3: Delayered ST16CF54A</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_66"/>A treasure trove of documentation for this card can be found in Guy (2000b), and an annotated disassembly of the complete ROM is available in Guy (2000a). The only public documentation used to be a three-page marketing brief, but a copy of the real datasheet was exposed in court records in STMicro (1996). It is complete except for a missing companion document that describes the system ROM.</p>&#13;
<h3 class="h3" id="ch00lev1sec19"><strong>The Bug</strong></h3>&#13;
<p class="noindent">The bug itself is an overflow in a statically allocated byte buffer that first holds the incoming APDU packet, and is later reused for the outgoing reply. That much is a textbook buffer overflow, but there are a few complications to work around.</p>&#13;
<p class="indent">First, the buffer sits at <span class="literal">0x019C</span>, where it is the very last thing in SRAM. Smart-card packets can be up to 255 bytes long, but there are only 100 bytes before SRAM ends at <span class="literal">0x01FF</span>. After that, the official memory map shows a large gap before the system ROM.</p>&#13;
<p class="indent">The trick here, which makes the bug exploitable, is that SRAM is ghosted in memory. Past the end of SRAM and 132 bytes into our 100-byte buffer, a write to <span class="literal">0x0220</span> is the same as a write to <span class="literal">0x0020</span> or a write to <span class="literal">0x0420</span>. So even though the buffer that we are overflowing comes <em>after</em> global variables and the call stack, we can use the ghosting effect to loop back to the beginning of memory and corrupt useful things.</p>&#13;
<p class="indent">There is no ghosting effect for the registers that sit from <span class="literal">0x00</span> to <span class="literal">0x1F</span>, so we won’t need to carefully choose those values in the same way that we’ll try to preserve SRAM.</p>&#13;
<p class="indent">One other effect worth watching is that a global variable early in SRAM holds the index into the receive buffer. The packet is received one byte at a time; when that variable is overwritten, the target location will jump for the rest of the byte copies. This is useful for shaving some bytes off of the packet, but if you ignore it, your exploit will go off the rails and land in the wrong location.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_67"/><img id="ch6fig4" src="../images/f0067-01.jpg" alt="Image" width="823" height="995"/></div>&#13;
<p class="figcap">Figure 6.4: Forum Posting of NipperClauz (2000)</p>&#13;
<h3 class="h3" id="ch00lev1sec20"><span epub:type="pagebreak" id="page_68"/><strong>NipperClauz Exploit</strong></h3>&#13;
<p class="noindent">Now that we’ve covered the theory, let’s dig into the first public example, NipperClauz (2000). The forum posting is reproduced in <a href="ch06.xhtml#ch6fig4">Figure 6.4</a>, and in this section we’ll disassemble it to understand how it works.</p>&#13;
<p class="indent">These first three bytes are the transaction header, where <span class="literal">0xC4</span> is the length.</p>&#13;
<div class="imagel"><img src="../images/f0068-01.jpg" alt="Image" width="821" height="43"/></div>&#13;
<p class="indent">After that, we have many lines of counting bytes that look like garbage, sometimes interrupted by a more meaningful byte. Many of these bytes don’t matter, but the latter ones do overwrite global variables, and having the wrong value there might break the exploit by crashing the application or adjusting UART timing.</p>&#13;
<p class="indent">Shellcode begins halfway through line 35, and it calls back into the ROM’s function for transmitting a byte at <span class="literal">0x42d7</span> to remain quite short.</p>&#13;
<div class="imagel"><img src="../images/f0068-02.jpg" alt="Image" width="821" height="113"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_69"/><img src="../images/f0069-01.jpg" alt="Image" width="821" height="391"/></div>&#13;
<p class="indent">The exploit ends with some filler and a checksum byte.</p>&#13;
<div class="imagel"><img src="../images/f0069-02.jpg" alt="Image" width="822" height="89"/></div>&#13;
<div class="imagel"><img src="../images/f0069-03.jpg" alt="Image" width="751" height="362"/></div>&#13;
<h3 class="h3" id="ch00lev1sec21"><span epub:type="pagebreak" id="page_70"/><strong>NDS Headend Exploit</strong></h3>&#13;
<p class="noindent">Appendix F of Mordinson (1998) describes a different exploit for the same bug. The following is the original exploit from that report in the <span class="literal">nasm</span> assembler format, with minor changes to comments.</p>&#13;
<p class="indent">Note how clean the comments are, explaining nearly every instruction and providing the exact address at which it is loaded into memory. Rather than call back into the ROM’s function for transmitting a byte, it instead implements its own function for this at <span class="literal">0x01c8</span>.</p>&#13;
<div class="imagel"><img src="../images/f0070-01.jpg" alt="Image" width="819" height="743"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_71"/><img src="../images/f0071-01.jpg" alt="Image" width="827" height="1109"/></div>&#13;
<h3 class="h3" id="ch00lev1sec22"><span epub:type="pagebreak" id="page_72"/><strong>A Modern Exploit in Go</strong></h3>&#13;
<p class="noindent">Both of those exploits will successfully dump the card’s EEPROM. This book is about writing exploits, not running them, so I ordered a dozen satellite receivers and assorted card collections until I found some that were vulnerable. In this section, we’ll cover Goodspeed (2022), my exploit for the cards, which runs on modern computers with USB smart-card adapters, dumping not just the EEPROM but also the user ROM and what SRAM it doesn’t corrupt.</p>&#13;
<p class="indent">To get your own card, simply collect a bunch of them and then read the Answer To Reset (ATR) of the cards. You’re looking for one whose ROM reads as <span class="literal">DNASP003</span> (meaning ROM3) and whose EEPROM version reads as <span class="literal">Rev272</span> or earlier. A few of my cards falsely present a later EEPROM revision to pretend that they have been patched, so don’t always believe the version number when it tells you the card is not vulnerable.</p>&#13;
<p class="indent">These cards have already been hacked for TV piracy, of course. Hacked cards can also be recognized when the electronic serial number disagrees with the printed serial number.</p>&#13;
<p class="indent">The first complication is that the Headend and NipperClauze exploits dump back all EEPROM in a single transaction. Smart-card transactions have a one byte length field and a checksum, so the response is a lot more data than the length field ought to allow and the checksum is always wrong. That wasn’t a problem when these were written in the Nineties, but modern smart-card adapters use USB instead of a serial port. USB’s smart-card standard (CCID) abstracts away packets, requiring that all lengths and checksums be correct.</p>&#13;
<p class="indent">To solve this, I reduced my transactions to 64 bytes and wrote shellcode that accepts a base address for the dump. Like the other exploits, mine does not support clean continuation. I found it convenient to avoid continuation hassles by simply resetting the card for every transaction.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_73"/><img id="ch6fig5" src="../images/f0073-01.jpg" alt="Image" width="818" height="421"/></div>&#13;
<p class="figcap">Figure 6.5: Revision 369 EEPROM Dump</p>&#13;
<p class="indent">You will note that my shellcode does not include the three byte header or one byte footer of the other examples. This is because the PCSC daemon automatically applies the header and checksum to the transaction. As the shellcode dumps just 64 bytes per execution, the start address must be written into the <span class="literal">ld a, (target+1, x)</span> instruction in the loop, where <span class="literal">0xFFFF</span> sits in the listing.</p>&#13;
<p class="indent">To transmit a reply back to the host, the shellcode jumps into a user ROM function at <span class="literal">0x757f</span>. This is the normal function that the ROM uses for transmitting its messages, which is a little smaller than reusing the function for transmitting a byte, as the NipperClauz shellcode does. It’s also smaller than implementing a completely custom transmitting function, as in the Headend exploit.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_74"/><img src="../images/f0074-01.jpg" alt="Image" width="821" height="670"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_75"/><img src="../images/f0075-01.jpg" alt="Image" width="822" height="787"/><span epub:type="pagebreak" id="page_76"/></div>&#13;
</div>
</div>
</body></html>