- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computational Geometry for Safety Resource Distribution
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In enterprise security work, you’ll often be asked to assist with a wide variety
    of infrastructure planning and deployment tasks that have more to do with providing
    safety than the traditional CIA (confidentiality, integrity, availability) triad
    we commonly think of as guiding information security. But fear not—with the mathematical
    tools you’re collecting, you’ll be able to adapt to the changing challenges and
    thrive under them. In this chapter we’ll focus on one of the most commonly applied
    tools from computational geometry, and one of my personal favorite algorithms:
    Voronoi tessellation.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to help the city of Portland, Oregon, plan the location of a new
    fire station using the locations of the current stations to inform our risk assessment.
    I picked this project because it shows how applied security concepts can scale;
    the same type of analysis can be applied to police stations, hospitals, burger
    joints, or any other public resource distributed throughout a city, state, country,
    or geographic region, making this one of the most flexible analysis tools in your
    arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the high-level plan: first we’ll create a polygon that represents the
    city, and then we’ll place points within the polygon representing the locations
    of the current fire stations. We’ll split up the city into smaller polygons that
    represent the areas closest to a given fire station. Finally, we’ll compare the
    areas of the smaller polygons to determine which fire station is responsible for
    covering the most area, and make our recommendation for the new fire station accordingly
    to improve response time in that area. Along the way, we’ll examine Voronoi tessellations
    and discuss some of the limitations of our implementation. By the end of this
    chapter, you should have a solid understanding of how to use computational geometry
    for resource distribution plans. You should also feel comfortable retrieving and
    manipulating geospatial information using the OpenStreetMaps API, which will allow
    you to scale your resource planning to whatever geographic size you need.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Voronoi Tessellation for Resource Distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You already saw tessellation in action when we placed the security assets around
    the park in [Chapter 7](c07.xhtml). In that case we divided the plane into triangles
    based on the vertices of the polygon, then placed a point in some of these regions
    representing the guard. We would expect the guard to respond to any incident that
    was within their zone. A *Voronoi tessellation* works in reverse, where we have
    a set of points (called *seeds* or *generators*) distributed throughout a plane,
    and we want to split up the area into regions that contain a single point. Take
    a look at [Figure 9-1](#figure9-1), which shows an example of a Voronoi tessellation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c09/f09001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: Randomly generated Voronoi tessellation'
  prefs: []
  type: TYPE_NORMAL
- en: The gray circles represent 10 randomly selected (*x*, *y*) coordinates that
    serve as the generators for our Voronoi tessellation. Each line segment represents
    the place in the plane that is equidistant from two or more generators. Points
    along the lines are the same distance from more than one generator point, so we
    mark them as the border between generators. After marking all the borders between
    generators, we end up with a polygonal mosaic. Each polygon represents a subregion
    of the plane. In each polygon region there’s exactly one generator point, so we
    can classify any arbitrary point in the plane that doesn’t fall on a border line
    segment based on which generator point is closest.
  prefs: []
  type: TYPE_NORMAL
- en: In the park example from [Chapter 7](c07.xhtml), this would be like spreading
    the guards through the park and then dividing up the park into areas of responsibility
    based on their positions. Approaching the problem this way is useful in a lot
    of cases, especially when examining the distribution of resources that are already
    in place or can’t be moved easily.
  prefs: []
  type: TYPE_NORMAL
- en: Formally speaking, a Voronoi tessellation divides a plane into regions of space
    where all the points in one region are closer to the generator for that region
    than any other generator. Points that are equidistant from two or more generators
    define the boundary between the regions. To perform the Voronoi tessellation for
    the fire station project, we need to define a *metric space X*, which is simply
    a set (in this case, of generator points in a plane defined by a 2D polygon) and
    a metric function that operates on the set (here, a function *d* to calculate
    distance between points). Our metric space—that is, the plane we’ll be tessellating—is
    bounded by the shape of the city limits. The generator points will be the locations
    of the current stations that divide the city up into areas of responsibility.
    Both the boundary data and the generating points need to be in the same coordinate
    system. Rather than having to manually project the coordinates, like we did in
    the previous project, we’ll take advantage of a purpose-built library called geovoronoi,
    which handles the back-and-forth projections under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Proof of Concept: Analyzing Fire Station Coverage'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proof of concept for this project is pretty straightforward. Our goal is
    to produce an application that shows the current division of fire service coverage
    for the city of Portland, using a Voronoi tessellation to define the service areas
    programmatically. We want our program to find the largest service area and produce
    this as the recommended area to split up. To achieve this, we need to define three
    pieces of information. First, we need shape data representing the area we plan
    to analyze, in this case Portland. I’ve included a copy of this data in the file
    *portland_geodata.json* in the book’s supplemental materials. You can also get
    the data from web services like OpenStreetMap API, which is how I retrieved it
    initially. The second thing we need is the location of our generator points, which,
    for this project, are the addresses of the various fire stations around Portland.
    I’ve included the 10 addresses I used for this analysis in the file *station_addresses_portland.csv
    in the supplemental materials. Third, we need to define the function we’ll use
    to measure distance between points when performing the Voronoi tessellation.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Once we’ve defined these three pieces of information, we’re ready to perform
    the Voronoi analysis. Then it’s just a matter of finding the generated region
    with the largest area; for this, we’ll again rely on Shapely. We’re going to start
    by discussing the distance function. Loading the area shape and generator points
    are interesting data retrieval tasks, but the distance function defines how the
    borders between regions will be calculated, so it’s where the bulk of the math
    magic happens.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Distance Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The metric space contains the distance function *d*(*p*, *q*), which is used
    to determine the distance between points in the plane. This is how the algorithm
    decides which points belong to which regions. There are several choices for the
    distance function: Manhattan distance, Chebychev distance, sum of absolute difference,
    sum of squared difference, and more. Each has advantages and disadvantages, so
    we’ll stick with the most basic and intuitive option, Euclidean distance or, colloquially,
    “as the crow flies.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Euclidean distance between points *p* and *q* is the length of the line
    segment connecting them (pq). If we treat the latitude and longitude as Cartesian
    coordinates, we can approach the problem as a 2D Euclidean geometry question,
    which we can solve using the Pythagorean theorem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c09/m09001.png)'
  prefs: []
  type: TYPE_IMG
- en: Here *n* is the number of dimensions the problem is mapped to, or more generally
    the length of the vector that defines a point. So, if you were working in 10 dimensions,
    each point would be defined by a vector of length 10\. In our case, we have two
    dimensions, so *n* = 2\. We simply need to square the difference between the end
    point and the beginning point, sum the squared difference across both dimensions,
    and then find the square root of the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a drawback to Euclidean distance in this scenario: in reality, you
    can rarely move straight through a geographic area without worrying about obstructions
    like trees and buildings. Furthermore, vehicles like fire engines are confined
    to streets and subject to traffic and other conditions that dictate the path they
    take to their destination. I encourage you to expand on my simplification to make
    the results more accurate and useful in your own implementation. For now, we’ve
    defined everything we need to start diving into the question. It’s time to start
    collecting the data required to define our geometric plane, starting with the
    shape of the city limits.'
  prefs: []
  type: TYPE_NORMAL
- en: Determining the City Shape
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get the polygon that represents the bounds of the plane, I like to use a
    web tool from the OpenStreetMap team called Nominatim ([https://nominatim.org](https://nominatim.org)).
    Its simple and free interface allows you to get several important pieces of information,
    like the place ID, the localized spellings of the name, and more. You can view
    the information on the website directly or request a JSON response to parse in
    your own programs, as we do here. [Listing 9-1](#listing9-1) shows how to request
    the information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-1: Retrieving the JSON data for Portland, Oregon, via Nominatim'
  prefs: []
  type: TYPE_NORMAL
- en: When we call the Nominatim API, the `q` parameter holds the query string we’re
    searching; here, we set it to a string containing the city name and state abbreviation,
    `"Portland OR"`. The `polygon_geojson` parameter tells the API to return the geoJSON
    representation of the polygon indicating the boundaries of the city. This is the
    part we’re most interested in at the moment, since it gets the shape data we need
    to define the city limits. The `format` parameter tells the API how we want the
    response data encoded. Whenever JSON is an option, it’s a good choice for Python,
    as it handles the parsed data like a dictionary. We have to encode the parameter
    dictionary into a string that can be appended to the URL, using the `urllib.parse.urlencode`
    function. We then submit the query string as part of a GET request and parse the
    data using the function `json.loads` on the text value of the response. The value
    should come back as a list with one or more entries representing the places that
    match our query. In this case, there should be only one result, representing the
    city of Portland. [Figure 9-2](#figure9-2) shows the polygon.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c09/f09002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: The city of Portland as a polygon'
  prefs: []
  type: TYPE_NORMAL
- en: The gray area represents the municipal boundaries of the city. This is the section
    that must be protected by the city’s fire service. We need to convert the coordinates
    into a shape, but first let’s format the data as geoJSON, as shown in [Listing
    9-2](#listing9-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-2: Converting the coordinates to a geoJSON feature collection'
  prefs: []
  type: TYPE_NORMAL
- en: The data structure here is the top-level definition of a geoJSON object, which
    has the type property `FeatureCollection` to indicate that there can be a list
    of features nested under the appropriately named `features` key. Each feature
    is a nested JSON object with the type `Feature`. Each feature needs a set of coordinates
    that define its geometry; here we use `resp_data["geojson"]`, the geoJSON that
    was returned from the API in [Listing 9-1](#listing9-1). We can also add further
    properties to store custom information that can be used for organization or to
    inform our analysis. The `properties` key is followed by a nested dictionary of
    property and value definitions, where the dictionary’s key represents the property
    name and the value represents the property value. Keys are restricted to string
    literals, but the values can be any legal JSON object, so you can get pretty creative
    with the property information you attach to the features.
  prefs: []
  type: TYPE_NORMAL
- en: The next step, shown in [Listing 9-3](#listing9-3), is to convert the resulting
    geoJSON information into `shape` objects stored together in a `GeometryCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-3: Converting the city geometry into a collection of Shapely shapes'
  prefs: []
  type: TYPE_NORMAL
- en: First we create a `GeometryCollection` by passing in a list of geometric objects
    making up the collection. We use a list comprehension to loop over each feature
    in the `city_gj` variable created in [Listing 9-2](#listing9-2). For each feature,
    we pass the geometry parameter to the `shape` constructor. The result is a `shape`
    object representing the coordinates of the geoJSON feature. Some cities are represented
    by more than one polygon, so this function will loop over all of the polygons
    that make up the city and convert each one into a `shape` object. The `city_shape`
    is now a `GeometryCollection` containing a single `MultiPolygon` object. We can
    access the `MultiPolygon` with another list comprehension. Since there’s only
    one item, we can extract it from the list using index `0`. If you had more `MultiPolygon`
    objects to process, you’d want to loop over each individually. The `MultiPolygon`
    data in the `city_shape` variable now represents the plane we’ll be tessellating
    using the metric space we’ve defined. Now it’s time to get the locations for the
    stations to create our list of generators.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering the Locations of Existing Fire Stations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned previously, we’ll be using the geographic location of the existing
    fire stations as the regional generators in our analysis. The file *station_addresses_portland.csv*,
    provided in the book’s supplemental materials, contains the names and addresses
    of 10 fire stations within the city limits. The pandas library offers a convenient
    function for loading data from a CSV file into a `DataFrame`, shown in [Listing
    9-4](#listing9-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-4: Loading the data into a `DataFrame` the quick-and-dirty way'
  prefs: []
  type: TYPE_NORMAL
- en: Although there are libraries specifically for handling CSV data, I prefer to
    leverage pandas’s built-in `read_csv` function, as it is flexible and comes packaged
    in a library I already use often. When I was preparing the data for this project,
    I compiled the station address list manually, using Google Maps. I didn’t bother
    to include a header, which is why we pass in a list of columns using the `names`
    parameter. In an actual consultation, I’d expect the client to provide the addresses
    for you, so you’ll likely need to adjust the file parsing to match the data format
    you’re provided. Next we create a convenient `addr` column to hold the whole street
    address as a string by applying a function called `row_to_str`, which simply returns
    the concatenation of the `street`, `city`, `state`, and `zip` columns separated
    by a space character. We pass `axis=1` to tell pandas we want to apply the function
    to the whole row, instead of all the values in a column. We’ll use the `addr`
    column to make it easier to search the geolocation API.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve gathered the addresses into a `DataFrame`, we can again leverage
    the OpenStreetMaps API (via the geocoder library) to turn these into geodesic
    points. In [Listing 9-5](#listing9-5) we define the `locate` function to turn
    a single address into location info.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-5: Converting an address to a geodesic point'
  prefs: []
  type: TYPE_NORMAL
- en: The main work of calling the API is abstracted away for us by the `geocoder.osm`
    function ❶. Passing in a query string (in this case, the address) returns an object
    containing the API’s response. The library supplies a convenient `json` parameter
    on the response object. If the JSON response is `None` ❷, we return `None` to
    indicate that the API couldn’t locate anything for the input query. If a JSON
    object is returned, we grab a subset of the data containing the important information
    from the response, such as the latitude and longitude, and return it as a dictionary
    ❸. We also record the `osm_id`, so we can use it to shortcut future lookups or
    choose between multiple results for a query.
  prefs: []
  type: TYPE_NORMAL
- en: To collect the points for all the stations, we’ll call the `locate` function
    in a loop over the addresses and store the results as a list. Since we previously
    created a `DataFrame` from the station data (the `stations_df` variable from [Listing
    9-4](#listing9-4)), we can leverage pandas’s `apply` function to handle the messy
    work behind the scenes. We’ll then convert the location information into its own
    `GeoDataFrame` object. [Listing 9-6](#listing9-6) shows how to handle the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-6: Creating a `DataFrame` from the station locations'
  prefs: []
  type: TYPE_NORMAL
- en: After we call `apply`, the `locations` variable contains a list of dictionary
    objects, one for each station, to hold the geodesic coordinates we need for our
    analysis. We filter out any instances where the location is `None` and then use
    this data to create a location `DataFrame` named `loc_df`. Finally, we can convert
    this regular pandas `DataFrame` into a more suitable `GeoDataFrame` object from
    the GeoPandas library. [Figure 9-3](#figure9-3) shows the results plotted on the
    map.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c09/f09003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: The fire station locations as points'
  prefs: []
  type: TYPE_NORMAL
- en: The dark circles inside the previously defined polygon show the station locations.
    If you count the locations on the map, only 8 of the 10 stations are present.
    The `locate` function failed to locate coordinates for two of the addresses. If
    this project were meant for production, we’d probably want to have multiple sources
    from which to retrieve the coordinates to increase the likelihood of success.
    You could also look them up manually or ask a client to provide the missing information.
    For now, we’ll just drop these two from the analysis and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve collected all the necessary data, we’re ready to perform the
    actual tessellation.
  prefs: []
  type: TYPE_NORMAL
- en: Performing the Voronoi Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As usual, there are several options for performing a Voronoi tessellation in
    Python, but the easiest by far when working with geographic information is a library
    named geovoronoi, which handles the coordinate projection and boundary work for
    us. It takes a list of coordinates and calculates the Voronoi regions using SciPy
    behind the scenes. At the edges of a typical Voronoi diagram, the region boundaries
    continue out to infinity, which isn’t always the desired behavior, so the geovoronoi
    library allows us to take the shape of the surrounding area (in this case, the
    shape of a city as a polygon) to cut the Voronoi regions so that they fit into
    the provided shape, making the regions at the edges finite. The library also uses
    Shapely for managing the shape manipulation operations, making it a perfect fit
    for this project.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-7](#listing9-7) shows how to use the library along with the previously
    collected data to create the tessellation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-7: Converting an address to a geodesic point'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to convert the points representing the fire stations into
    a NumPy array using a list comprehension to iterate over the `geometry` column
    of the previously created `geo_df` `DataFrame` object. We can then call the `voronoi_regions_from_coords`
    function from the geovoronoi library with the array of points (`points`) as the
    first argument and the boundary polygon (`city_shape`) as the second.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the function is a tuple containing three useful pieces of information.
    The `poly_shapes` variable holds a list of Shapely `Polygon` objects representing
    the shape of the Voronoi regions created during the tessellation algorithm. The
    `pts` variable holds a set of `Point` objects representing the coordinates of
    the generators. These are for convenience if you haven’t already created them
    using GeoPandas or some other method. The `poly_to_pt` variable holds a nested
    list for each region in `poly_shapes` that contains a list of indices into `pts`.
    The indices indicate the generators that belong to this Voronoi region. Usually,
    this is only a single point for our problem, because multiple fire stations shouldn’t
    share the same location, but there may be cases where this isn’t true and multiple
    generator points have the exact same location. In these situations, all of the
    points will be indexed in `poly_to_pt`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-4](#figure9-4) shows the regions that were created along with the
    generators for each region.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c09/f09004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-4: A Voronoi tessellation showing each station’s area of responsibility'
  prefs: []
  type: TYPE_NORMAL
- en: The eight regions are divided by the black outlines. The area inside each polygon
    can be viewed as the naive area of responsibility (AOR) for the fire station that
    generated the region. It is naive because it doesn’t take into account obstructions
    (like the water) that might make a different station the better choice to respond.
    Still, the information is a good starting point for you to build on. We can already
    see how the distribution of the stations near the center of the city leaves the
    edge stations with the largest AORs. Visually, the top-left AOR appears to be
    the largest, but we can easily verify this using the `area` parameter, as shown
    in [Listing 9-8](#listing9-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-8: Finding the largest AOR'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by looping over each shape in the `poly_shapes` variable, iterating
    over the length of the list ❶. Looping this way allows us to keep track of the
    index as the function progresses. There may be cases (albeit unlikely) where more
    than one region has the same area. In such a case, we convert the `winner` variable
    into a list and keep track of the ties ❷. In the more likely scenario, the two
    areas aren’t equal, so we check if the current area is greater than the current
    winning area ❸. If so, we update the `winning` amount and the `winner` index.
    Once all regions have been checked, the `winner` variable will contain one or
    more region indices, which we can use to look up the shape (or shapes) in `poly_shapes`.
    We can also use it to look up the station (or stations) in `poly_to_pt`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-5](#figure9-5) shows the region plotted to the map along with the
    station location responsible for it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c09/f09005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-5: The largest region and its generator location'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the darker gray area represents the region of interest and the dark
    gray circle shows the location of the responding fire station. Therefore, you
    could reasonably argue that placing another station somewhere within that region
    would improve response time and resource availability in that area.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the proof-of-concept code by navigating to the chapter’s supplemental
    materials directory and running the *Emergency_service_poc.py* script like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once the code finishes loading the data and performing the Voronoi analysis,
    it will open a browser tab to *http://127.0.0.1*, which displays the solution
    using Plotly and the MapBox API.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of the Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we’ve focused solely on the geographic portion of the problem,
    which is an excellent starting point. The narrow scope does present some limitations,
    though. I’ve already mentioned the limitations of the distance function, but there
    are other factors to consider if you’re asked to make a recommendation like this
    in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: For one, not all fire stations are equipped the same. Some have more trucks,
    some have different types of specialty equipment (like a plane for surveying large
    wooded areas, or a boat for doing harbor patrols), and so on. The diversity of
    equipment means that different stations may be better equipped to handle different
    problems. Putting a specially equipped station in a region where it isn’t needed
    would be a terrible waste of resources. Another problem with the distribution
    of resources is that some stations are more equipped to deal with larger regions.
    For example, a station with a large area but 10 fire trucks at its disposal may
    be able to patrol its region more effectively than a station with a medium-sized
    region but only two trucks. You can improve upon this analysis by adding more
    information about the resources and specializations for the stations. You would
    want to ask your contacts in the city about the equipment plan for the new station
    and then factor that in when creating the Voronoi regions.
  prefs: []
  type: TYPE_NORMAL
- en: The final consideration is that fire stations don’t see these boundaries. A
    fire in one region may bring responders from nearby regions as well. The fire
    department does a lot to try to distribute the load for any given area across
    two or more stations so that large fires can be controlled more quickly. The larger
    the fire, the more resources it will take to battle, and therefore it may be necessary
    to direct resources from one region to assist in another. Strictly dividing the
    region into AORs may lead you to suggest a station location that perfectly distributes
    the AORs but nevertheless doesn’t allow the new station to assist the existing
    stations in a meaningful way.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this limitation, I suggest performing multiple analyses. For each station
    in the data, you can check how each other station affects its region by removing
    them one at a time from the list and recalculating the regions. This is similar
    to asking, “How would the responsibilities for station A change if station B weren’t
    able to respond?” By overlaying the resulting regions, you’ll see which stations
    take on the most shared responsibility because that region will have the largest
    overall change in area after all the other stations have been removed. A station
    with a lot of shared responsibility may suffer from equipment fatigue or physical
    exhaustion, so you may suggest that another station located somewhere closer to
    the overworked station could distribute the load better. Again, the station with
    the most shared responsibilities may have the proper equipment and personnel to
    handle the extra work.
  prefs: []
  type: TYPE_NORMAL
- en: All of this is meant to show you that, although Voronoi diagrams are extremely
    useful, they’re not always the final answer. As with all analyses, the more accuracy
    and detail you add to your model, the more applicable the results will be to the
    real world. When performing any type of resource analysis, it’s just as important
    to understand how those resources interact with their region as with each other.
    Doing so will allow you to make intelligent choices for your model and overcome
    some of the limitations of this basic framework.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ve covered one of the most famous computational geometry
    algorithms, the Voronoi tessellation. We’ve seen how it can be applied to real-world
    problems related to the distribution of resources and how it can be scaled to
    fit the problem. We’ve also discussed some of the limitations to this implementation
    and ways you can improve upon it yourself. My hope is that you’ll take this framework
    and expand upon it to suit your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot of excellent research material available on the different applications
    of these tessellations, from security to neurology and everywhere in between.
    I recommend you read the research paper “Rationalizing Police Patrol Beats Using
    Voronoi Tessellations”^([2](b01.xhtml#c09-endnote-002)) for another example of
    applying this analysis to improve emergency services. As a security analyst, you’ll
    find plenty of opportunities to show off your resource distribution knowledge.
    In the final part of the book, we’ll revisit tessellations to plan the distribution
    of security resources for the art gallery problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll conclude our look into the world of computational
    geometry for security with one of my favorite projects of all time, facial recognition
    systems. Although the size and geometry are drastically different from anything
    we’ve dealt with so far, the basic ideas are the same. We’ll continue to use Shapely
    to handle the geometry, but now we’ll add some machine learning to the mix, giving
    us the tools needed to build the highly sophisticated analysis required to recognize
    facial features programmatically.*
  prefs: []
  type: TYPE_NORMAL
