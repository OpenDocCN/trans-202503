<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_77"/><span class="big">3</span><br/>TURING MACHINES AND TURING COMPLETENESS</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">Spend enough time around programming languages, and two phrases inevitably appear: “Turing machine” and “Turing completeness.” In this chapter, we’ll explain what these phrases mean and why they are important. Specifically, we’ll introduce the halting problem and discuss Alan Turing’s fantastic solution to it. That will set the stage for discussing Turing machines and Turing completeness. We’ll end by simulating a Turing machine in Python.</p>&#13;
<p class="indent">The topics of this chapter fall under the heading “theoretical computer science,” which is a branch of mathematics, not software engineering. As we’ll see below, theoretical computer science predates the availability of physical computers.</p>&#13;
<h3 class="h3" id="lev1sec29"><span epub:type="pagebreak" id="page_78"/><strong>The Halting Problem</strong></h3>&#13;
<p class="noindent">Early 20th-century mathematicians had a problem. They were several decades into a serious effort to put all of mathematics on a logical foundation. As part of this program, in 1928, David Hilbert and Wilhelm Ackermann issued their “Entscheidungsproblem” (German for “decision problem”). When given a statement in some formal system, the problem asked for an algorithm that would infallibly return “yes” or “no” as to the validity of that statement. In other words, the problem asked for an algorithm that would say whether the statement can be proven from the axioms of the system, which are those statements accepted as true without proof. It’s important to note that Hilbert and Ackermann’s challenge was for a universal algorithm, that is, one that will always give the correct answer for all applications.</p>&#13;
<p class="indent">In 1936, a young Alan Turing, not quite 24 years old, published what became the foundational paper of theoretical computer science: “On Computable Numbers, with an Application to the Entscheidungsproblem.” In this paper, Turing demonstrated that there is no general solution to the Entscheidungsproblem. That is, there is no algorithm that can always correctly decide on the validity of a statement.</p>&#13;
<p class="indent">To do this, Turing addressed a specific problem: the <em>halting problem</em>. There are different ways to describe the halting problem, but we’ll use this definition:</p>&#13;
<div class="bq">&#13;
<p class="noindent">Find a program, <em>P</em>, that when given as input the source code of another program, <em>T</em>, and an input for that program, <em>I</em>, will always output “yes” if <em>T</em> will eventually stop for input <em>I</em>, or “no” if <em>T</em> will run forever for input <em>I</em>.</p>&#13;
</div>&#13;
<p class="noindent">This is a halting problem. We want to know if a program will eventually stop, or run forever for a given input. The program in question is <em>T</em> and the input is <em>I</em>. The program that decides, that outputs “yes” or “no,” is <em>P</em>. The definition above uses the word <em>program</em> for <em>P</em>, with the implicit understanding that algorithms can be encoded in programs. After all, that is what programming is all about: encoding algorithms (thought) in a form that can instruct a machine. We’ll come back to this equivalence between algorithm and program below.</p>&#13;
<p class="indent">Turing’s paper, which is quite readable and easily found online with a search for the title above, showed that there is no <em>P</em>. It doesn’t exist. As the halting problem is a decision problem, Turing thereby established that the Entscheidungsproblem has no solution either.</p>&#13;
<p class="indent">At virtually the same time as Turing, indeed, slightly before, Alonzo Church arrived at the same conclusion using a formal system known as <em>λ</em>-calculus (lambda calculus). If you read Turing’s 1936 paper, the introduction concludes with a reference to Church’s “recent paper” using <em>λ</em>-calculus to show what Turing was about to demonstrate. In the end, Turing became Church’s student at Princeton, completing his PhD there in 1938.</p>&#13;
<p class="indent">Turing’s proof that there is no solution for the halting problem required several iterations. The version in his 1936 paper is somewhat buggy. The essence of the proof is by contradiction.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_79"/>Assume we have a program, <em>P</em>, a program that accepts another program, <em>T</em>, and an input for it, <em>I</em>. <em>P</em> tells us whether <em>T</em> will halt on <em>I</em>. The output of <em>P</em>, as we stated above, is “yes” or “no.”</p>&#13;
<p class="indent">Now, we make a slight change to <em>P</em> so it accepts a single input and uses that input as both <em>T</em> and <em>I</em>. Additionally, when <em>P</em> is about to return “yes” to indicate that <em>T</em> does halt on input <em>I</em>, we add an infinite loop before the return. If we call this slightly edited program <em>Q</em>, what happens when we use <em>Q</em> as the argument to itself?</p>&#13;
<p class="indent">There are two cases. Suppose <em>Q</em> does halt with <em>Q</em> as input. If so, <em>P</em> would return “yes.” However, we added an infinite loop before the return, so <em>Q</em> doesn’t halt. Now suppose that <em>Q</em> doesn’t halt with <em>Q</em> as input. In that case, <em>P</em> returns “no” to indicate that <em>Q</em> with <em>Q</em> as input doesn’t halt. However, by issuing “no,” <em>Q</em> does, in fact, halt. We’re left with a contradiction: <em>Q</em> given <em>Q</em> as input halts if and only if <em>Q</em> given <em>Q</em> as input does not halt. This is an impossibility, and as <em>Q</em> is really <em>P</em> with a tiny addition to the case where the argument does halt, it means that <em>P</em> cannot exist either. Thus, the halting problem has no solution.</p>&#13;
<p class="indent">Turing’s proof that the halting problem has no solution is foundational, but what concerns us more, practically, is what he introduced along the way. He introduced, in 1936, before any physical computer existed, a <em>model of computation</em>. That is, a straightforward machine that captures the essence of what we mean by the word <em>algorithm</em>—in other words, a Turing machine. Let’s take a look.</p>&#13;
<h3 class="h3" id="lev1sec30"><strong>Turing Machines</strong></h3>&#13;
<p class="noindent">A <em>Turing machine</em> is a simple computer consisting of an infinite tape partitioned into squares and a read/write head that moves along the tape. A table of states, sometimes called the <em>instruction table</em>, specifies the operation of the machine. Each step involves searching the instruction table for a match between the current state and the symbol presently on the tape beneath the head. For each match, the table specifies an action, a direction to move, and a new state. There are three allowed actions: print a symbol on the tape, erase the symbol already on the tape, or do nothing. The direction is either move left, move right, or don’t move. The machine is initialized by loading a tape, which may be blank or already marked, and positioning the head over the starting position, usually the beginning of the tape. <a href="ch03.xhtml#ch03fig1">Figure 3-1</a> presents an abstract representation of a Turing machine.</p>&#13;
<div class="image"><img id="ch03fig1" src="Images/03fig01.jpg" alt="Image" width="679" height="135"/></div>&#13;
<p class="figcap"><em>Figure 3-1: A conceptual Turing machine</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>To run the machine, we follow these steps:</p>&#13;
<ol>&#13;
<li class="noindent">Search the table for a match between the current state and the  symbol beneath the tape head.</li>&#13;
<li class="noindent">Perform the action given for that combination: do nothing, print  a symbol, or erase a symbol.</li>&#13;
<li class="noindent">Move the tape head to the left or right one square if specified in  the table.</li>&#13;
<li class="noindent">Set the current state to the new state read from the table and repeat  from Step 1.</li>&#13;
</ol>&#13;
<p class="indent">As simple as this machine is, it can implement any algorithm; but no one said anything about efficiency or ease of implementation. The <em>Church–Turing thesis</em> goes even further and states that the very definition of algorithm is that which can be implemented by a Turing machine. That is, a problem can be solved by an algorithm if (and only if) it can be solved by a Turing machine. Note that this statement is a <em>thesis</em> and not a <em>theorem</em>. A thesis is something believed, with good reason, to be true, but a theorem is something that has been proven to be true.</p>&#13;
<p class="indent">Section 3 of Turing’s paper lists example machines. His first example is a machine that fills the tape with the pattern “0 1 0 1 0 <em>…</em> ” The machine prints a 0, moves to the right twice to leave a blank space, prints a 1, and then moves to the right twice, repeating forever.</p>&#13;
<p class="indent">The tape is initially empty, meaning there is no input to this machine. The head starts at the first square and the initial state is 0. To make a move, we need the instruction table that tells us what the next step is. The instructions for this machine are in <a href="ch03.xhtml#ch03tab1">Table 3-1</a>.</p>&#13;
<p class="tabcap" id="ch03tab1"><strong>Table 3-1:</strong> Turing’s First Example</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>State</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Symbol</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Print</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Move</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>New state</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>blank</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">R</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>blank</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>blank</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">R</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">2</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>blank</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">R</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><em>blank</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><em>blank</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">R</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">0</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The machine starts in state 0 with a blank tape. Searching the table for this configuration produces a match with “0 <em>blank</em>.” For this case, the table says to print a 0, move to the right, and set the machine to state 1.</p>&#13;
<p class="indent">The next step searches for state 1 and whatever is under the tape head, which is a blank. There is a match for this configuration. The match says to print a blank, move to the right, and set the machine to state 2. State 2 matches, prints a 1, moves to the right, and moves to state 3. Lastly, state 3 matches, prints a blank, moves to the right, and goes back to state 0. At this point, the process repeats forever as there is no halt state. We’ll explore other Turing machine examples below.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_81"/>It isn’t immediately obvious or, for that matter, obvious in any sense of the word, that a Turing machine embodies the concept of an algorithm. In fact, Turing himself believed that the Church–Turing thesis was not amenable to mathematical proof. In its favor, beyond multiple approaches leading to the same situation, is the fact that decades of attempts to disprove the thesis have been unsuccessful.</p>&#13;
<p class="indent">In his 1936 paper, Turing makes several arguments to help convince the reader that a Turing machine can implement any algorithm. My favorite is his comparison between a human computer (someone who performs calculations and the original meaning of the word <em>computer</em>) and a Turing machine. Turing describes a situation where a human computer is working on a problem in a manner similar to the configuration of a Turing machine and using a tape to hold results. He then describes a situation where the computer interrupts the work in progress:</p>&#13;
<div class="bq">&#13;
<p class="noindent">It is always possible for the computer to break off from his work, to go away and forget all about it, and later to come back and go on with it. If he does this, he must leave a note of instructions (written in some standard form) explaining how the work is to be continued. This note is the counterpart of the “state of mind.” We will suppose that the computer works in such a desultory manner that he never does more than one step at a sitting. The note of instructions must enable him to carry out one step and write the next note. Thus the state of progress of the computation at any stage is completely determined by the note of instructions and the symbols on the tape.</p>&#13;
</div>&#13;
<p class="indent">Here, Turing is appealing to our intuition. If a human can implement any algorithm with pen and paper, and a human is capable of following the process a Turing machine follows, then we should expect a Turing machine to be able to implement any algorithm as well.</p>&#13;
<h3 class="h3" id="lev1sec31"><strong>Universal Turing Machine</strong></h3>&#13;
<p class="noindent">If a Turing machine is capable of implementing any algorithm, then a Turing machine should be able to implement another Turing machine. In other words, it should be possible to construct a <em>universal Turing machine (UTM)</em> that accepts another Turing machine and tape as input and executes it. Turing introduces this idea in Sections 5 through 7 of his paper.</p>&#13;
<p class="indent">A Turing machine includes an instruction table and an input tape, which may be blank. A UTM accepts two things: a Turing machine, meaning the instruction table, and an input tape. The input Turing machine must be encoded in some way and Turing developed such an encoding in Section 5 of his paper.</p>&#13;
<p class="indent">A Turing machine described by an instruction table like <a href="ch03.xhtml#ch03tab1">Table 3-1</a> can be mapped to what Turing called the <em>standard description (S.D.)</em>. The sequence of instructions are written one after the other using letters with a semicolon between them.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_82"/>For example, the instructions of <a href="ch03.xhtml#ch03tab1">Table 3-1</a> are 5-tuples that Turing writes in <em>standard form</em> as <em>q</em><sub><em>i</em></sub><em>S</em><sub><em>j</em></sub><em>S</em><sub><em>k</em></sub><em>Rq</em><sub><em>m</em></sub>;, where <em>q</em><sub><em>i</em></sub> is the current state, <em>S</em><sub><em>j</em></sub> is a symbol under the read head, <em>S</em><sub><em>k</em></sub> is a symbol to print, <em>R</em> means move right (there’s also <em>L</em> for left or <em>N</em> for stay put), and <em>q</em><sub><em>m</em></sub> is the new state. The semicolon ends the instruction.</p>&#13;
<p class="indent">To find the S.D. of an instruction, <em>q</em><sub><em>i</em></sub> is written as <em>D</em> followed by <em>i A</em>s. Similarly, the <em>S</em><sub><em>j</em></sub> symbol is written as <em>D</em> followed by <em>j C</em>s. The movement letter is written as itself: <em>R</em>, <em>L</em>, or <em>N</em>. Thus, the first instruction of <a href="ch03.xhtml#ch03tab1">Table 3-1</a> is</p>&#13;
<p class="equationc">0     <em>blank</em>     0     R     1</p>&#13;
<p class="noindent">which Turing would write as <em>q</em><sub>1</sub><em>S</em><sub>0</sub><em>S</em><sub>1</sub><em>Rq</em><sub>2</sub>;, as he numbers states from one and uses a set of allowed symbols, <em>S</em> = {blank, 0, 1}. Here, <em>S</em><sub>0</sub> is a blank, <em>S</em><sub>1</sub> is zero, and <em>S</em><sub>2</sub> is one. The S.D. of this instruction is therefore <em>DADDCRDAA</em>;, and the entire S.D. of the machine specified by <a href="ch03.xhtml#ch03tab1">Table 3-1</a> is</p>&#13;
<p class="equationc"><em>DADDCRDAA;DAADDRDAAA;DAAADDCCRDAAAA;DAAAADDRDA;</em></p>&#13;
<p class="indent">After calculating the S.D. of a machine, Turing goes further to generate what he calls a <em>description number (D.N.)</em>, which is a single integer that fully specifies the Turing machine. To calculate the D.N., begin with the S.D. and replace each possible letter in the S.D. with an integer.</p>&#13;
<p class="equationc"><em>A</em> → 1, <em>C</em> → 2, <em>D</em> → 3, <em>L</em> → 4, <em>R</em> → 5, <em>N</em> → 6, ;→ 7</p>&#13;
<p class="noindent">For example, the S.D. above becomes</p>&#13;
<p class="equationc">31332531173113353111731113322531111731111335317</p>&#13;
<p class="indent">The D.N. mapping means that every computable sequence, that is, anything computable by a Turing machine, has at least one D.N., and each D.N. specifies only one computable sequence. The net result is that the number of Turing machines is enumerable. Turing is writing about computable numbers, which are real numbers that can be computed by an algorithm, but by showing that the number of Turing machines is enumerable (could be counted), he shows that there are infinitely many real numbers that are not computable, that is, numbers for which no algorithm exists. Here he’s building on Georg Cantor’s famous proof that the real numbers are not countable. For a summary of Cantor’s proof, see <em><a href="https://mathworld.wolfram.com/CantorDiagonalMethod.html">https://mathworld.wolfram.com/CantorDiagonalMethod.html</a></em>.</p>&#13;
<p class="indent">In Section 8 of his paper, Turing uses the fact that the number of Turing machines is countable to contemplate a machine for checking description numbers, a machine that knows whether or not the Turing machine associated with the description number will halt or not for all possible inputs. Through an attempt to apply a mathematical process used by Cantor, Turing arrives at a contradiction, proving that no such machine exists. This is his proof that the halting problem is undecidable—that there exists no algorithm that will tell you if program <em>P</em> halts on input <em>I</em> for all possible inputs.</p>&#13;
<p class="indent">To recap, a UTM is a Turing machine that accepts encoded Turing machines and input tapes as its input. The UTM then runs the supplied Turing <span epub:type="pagebreak" id="page_83"/>machine on the provided tape to produce the output of the Turing machine. Thus, a UTM is a program that runs other programs. Does this sound familiar? The UTM is a general-purpose computing machine—a computer—and it can run programs given as inputs. The UTM is a stored-program computer, that is, a computer that puts programs and data in the same memory (its input) and executes the program. This is what every modern computer does: specifically, every <em>von Neumann architecture</em> computer. For those familiar with computers—presumably everyone reading this book—this is a no-brainer idea; that’s just what computers do. However, the idea wasn’t a no-brainer in 1936. It was foundational and groundbreaking.</p>&#13;
<p class="indent">Turing machines are not the only possible models of computation. Others, like <em>finite-state machines</em> and <em>Minsky register machines</em>, do exist. At best, these other models are equivalent to Turing machines (Minsky machines) or demonstrably less powerful (finite-state machines). Comparing models of computation is part of <em>automata theory</em>. The significant result for us is that Turing machines are the top of the heap, and there are no models of computation that can perform actions beyond what a Turing machine can implement. This most likely includes quantum computers. We’ll encounter a Minsky register machine in <a href="ch08.xhtml#ch08">Chapter 8</a> when we discuss FRACTRAN.</p>&#13;
<p class="indent">Turing machines are the best known model of computation, and perhaps the best model possible if the Church–Turing thesis is correct. Let’s see how equivalence to a Turing machine is helpful for our exploration of esolangs.</p>&#13;
<h3 class="h3" id="lev1sec32"><strong>Turing Completeness</strong></h3>&#13;
<p class="noindent">A Turing machine can implement any algorithm. If a programming language can do the same, the language is called <em>Turing complete</em>. Specifically,</p>&#13;
<div class="bq">&#13;
<p class="noindent">A <em>Turing complete</em> system can simulate all Turing machines, that is, can simulate a universal Turing machine.</p>&#13;
</div>&#13;
<p class="indent">If a programming language is Turing complete, it can, in theory, implement anything a Turing machine can, and therefore any algorithm at all. As you might expect, widely used programming languages are Turing complete. In the next section, we’ll implement a Turing machine simulator in Python, which demonstrates that Python is Turing complete.</p>&#13;
<p class="indent">Imperative programming languages need only two things to be Turing complete:</p>&#13;
<ol>&#13;
<li class="noindent">Some form of looping based on a conditional, like a <code>while</code> loop or a  combination of <code>if</code> and <code>goto</code>.</li>&#13;
<li class="noindent">The ability to manipulate an arbitrarily large amount of memory.</li>&#13;
</ol>&#13;
<p class="indent">The second requirement is, of course, not met for any real-world programming language <em>as implemented</em>, but it is easily met when the language is <em>specified</em>. For example, there is nothing in Python’s specification that says “a list may contain at most one million items.” In the language itself, there is <span epub:type="pagebreak" id="page_84"/>no limit on how many items a list may contain, even if an implementation must, to be realized in the physical world, have such a limit.</p>&#13;
<p class="indent">Why should we care about Turing completeness? Turing completeness is particularly interesting when dealing with esolangs. Esolangs are all about pushing boundaries and thinking in novel ways. Therefore, it makes sense to ask whether an esolang is Turing complete. If it is, then a design goal might well have been achieved: the language is, in theory, capable of implementing any algorithm, regardless of how difficult it might be to do so in practice. Not every language we’ll explore in this book is Turing complete; however, not being Turing complete does not mean useless. By itself, HTML is not Turing complete; yet, HTML is, as the basis for web pages, extremely useful.</p>&#13;
<p class="indent">It is also possible to demonstrate Turing completeness by providing a translator between the language in question and another language known to be Turing complete. This is often used to illustrate Turing completeness for different esolangs. For example, the Nopfunge esolang (<em><a href="https://esolangs.org/wiki/Nopfunge">https://esolangs.org/wiki/Nopfunge</a></em>), which is based on the Befunge esolang we’ll explore in <a href="ch11.xhtml#ch11">Chapter 11</a>, shows Turing completeness by translating a Minsky machine into Nopfunge. Minsky machines are known to be Turing complete. Therefore, if Nopfunge can implement a Minsky machine, then Nopfunge can implement any Turing machine.</p>&#13;
<p class="indent">The requirements for Turing completeness are so minimal that many systems not originally intended to be Turing complete have been shown to be so. For example, each of the following is Turing complete:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>mov</code> instruction for the x86 architecture (see <em><a href="https://github.com/xoreaxeaxeax/movfuscator/">https://github.com/xoreaxeaxeax/movfuscator/</a></em> for a C compiler that generates only <code>mov</code> instructions)</li>&#13;
<li class="noindent">Minecraft</li>&#13;
<li class="noindent"><em>Magic: The Gathering</em> card game</li>&#13;
<li class="noindent">The Dwarf Fortress video game (see <em><a href="https://youtu.be/j2cMHwo3nAU/">https://youtu.be/j2cMHwo3nAU/</a></em> for a video showing Space Invaders running in Dwarf Fortress)</li>&#13;
<li class="noindent">PowerPoint (see <em><a href="http://www.andrew.cmu.edu/user/twildenh/PowerPointTM/Paper.pdf">http://www.andrew.cmu.edu/user/twildenh/PowerPointTM/Paper.pdf</a></em>)</li>&#13;
<li class="noindent">The vim text editor (see <em><a href="https://github.com/ealter/vim_turing_machine/">https://github.com/ealter/vim_turing_machine/</a></em>)</li>&#13;
</ul>&#13;
<p class="noindent">This list is by no means exhaustive.</p>&#13;
<p class="indent">Let’s put theory into practice and implement a basic Turing machine simulator in Python.</p>&#13;
<h3 class="h3" id="lev1sec33"><strong>Let’s Build a Turing Machine</strong></h3>&#13;
<p class="noindent">Perhaps the best way to understand how a Turing machine works is to implement one. In a way, Turing machines are the first esolangs. They are capable of everything, but are impractical for serious use. Turing machines are rather general, as they work with an arbitrary set of symbols, but we’ll restrict ourselves to a machine using only 0 and 1 as symbols, along with blank for an empty space. Likewise, we’ll represent the instruction table as shown in <a href="ch03.xhtml#ch03tab1">Table 3-1</a>, where each row of the table is a 5-tuple describing the state and <span epub:type="pagebreak" id="page_85"/>tape condition followed by the action, move, and new state. For example, we’ll express <a href="ch03.xhtml#ch03tab1">Table 3-1</a> in Python with <a href="ch03.xhtml#ch03list1">Listing 3-1</a>.</p>&#13;
<pre>((0,' ','0','R',1),&#13;
 (1,' ',' ','R',2),&#13;
 (2,' ','1','R',3),&#13;
 (3,' ',' ','R',0))</pre>&#13;
<p class="caption" id="ch03list1"><em>Listing 3-1: Turing’s first example in Python</em></p>&#13;
<p class="indent">The rows of <a href="ch03.xhtml#ch03tab1">Table 3-1</a> match the rows of <a href="ch03.xhtml#ch03list1">Listing 3-1</a>. The first entry in the table describes state 0 and a blank. The action is to print a 0, move right, transfer to state 1, and then repeat. For our machines, all actions are to print something, and all movements are to the right or left; there is no standing still. All possible combinations of state and the current symbol, the first two elements of every instruction, should be present in the table; otherwise, the program is incomplete because there are state and symbol combinations with no defined actions.</p>&#13;
<p class="indent">Let’s take our Turing machine for a spin and then dive into the code.</p>&#13;
<h4 class="h4" id="lev2sec29"><strong><em>The Simulator</em></strong></h4>&#13;
<p class="noindent">The code for our Turing machine simulator is in <em>turing.py</em>. It begins with a small catalog of example programs in <code>PROGS</code> along with a brief description in <code>NAMES</code>.</p>&#13;
<p class="indent">Running <em>turing.py</em> without arguments gives us</p>&#13;
<pre>&gt; <span class="codestrong1">python3 turing.py</span>&#13;
turing &lt;prog&gt; [&lt;M&gt; | &lt;list&gt;] [-t]&#13;
&#13;
  &lt;prog&gt; - program # [0,4]&#13;
  &lt;M&gt;    - blank tape of size M&#13;
  &lt;list&gt; - initial tape (list: 0,1,2=blank)&#13;
  &lt;-t&gt;   - trace, if present&#13;
&#13;
programs:&#13;
    0: Turing's first example&#13;
    1: change 0's to 1's&#13;
    2: unary increment: 111 -&gt; 1111&#13;
    3: binary increment&#13;
    4: unary subtraction: 11111 111 -&gt; 5 - 3</pre>&#13;
<p class="noindent">The output tells us to select an example program from the list below and then specify the size of the blank tape, or manually enter an initial tape configuration as input. The optional final argument, <code>-t</code>, enables tracing, allowing us to step through the program to see the effect of each instruction.</p>&#13;
<p class="indent">Let’s run Turing’s first example (Program 0).</p>&#13;
<pre>&gt; <span class="codestrong1">python3 turing.py 0 20</span>&#13;
Program complete: (state=0, tc=20)<span epub:type="pagebreak" id="page_86"/>&#13;
[0 1 0 1 0 1 0 1 0 1 ]&#13;
&#13;
Program:&#13;
     0, ' ' ==&gt; '0', 'R',  1&#13;
     1, ' ' ==&gt; ' ', 'R',  2&#13;
     2, ' ' ==&gt; '1', 'R',  3&#13;
     3, ' ' ==&gt; ' ', 'R',  0</pre>&#13;
<p class="indent">We told the simulator to use a blank tape with 20 spaces. As conceived, Turing machines never run out of tape. The output shows the pattern of 0s and 1s as expected. We’re also told that the machine stopped in state 0 and that the tape counter (<code>tc</code>) was at position 20. In other words, we ran out of tape, so the simulation stopped. The selected program’s instruction table is printed below the output showing the state and symbol matched followed by the print action, movement, and new state.</p>&#13;
<p class="indent">In <em>turing.py</em>, the <code>main</code> function parses the command line arguments to select the program run along with the size of the blank tape or the initial tape configuration entered by the user. We’ll see how to enter a tape below. The machine itself is contained in the class <code>TuringMachine</code>.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03list2">Listing 3-2</a> shows the <code>TuringMachine</code> class with the <code>Result</code> method omitted to save space.</p>&#13;
<pre>class TuringMachine:&#13;
    def Step(self):&#13;
        found = False&#13;
     <span class="ent">➊</span> for p in self.prog:&#13;
            if (p[0] == self.c) and (self.tape[self.tc] == p[1]):&#13;
                found = True&#13;
                break&#13;
        if (not found):&#13;
            raise ValueError("No match found for current state: &#13;
                (%d,'%s')" % (self.c,self.tape[self.tc]))&#13;
     <span class="ent">➋</span> w,m,c = p[2:]&#13;
        if (w != ''):&#13;
            self.tape[self.tc] = w&#13;
        if (m == 'R'):&#13;
            self.tc += 1&#13;
        elif (m == 'L'):&#13;
            self.tc -= 1&#13;
        self.c = c&#13;
&#13;
 <span class="ent">➌</span> def Done(self):&#13;
        if (self.c == -1) or (self.tc &lt; 0) or (self.tc == self.M):&#13;
            return True  # end state or fell off the tape&#13;
        return False<span epub:type="pagebreak" id="page_87"/>&#13;
&#13;
 <span class="ent">➍</span> def Run(self):&#13;
        while (not self.Done()):&#13;
            if (self.trace):&#13;
                s = "".join(self.tape)&#13;
                t = " "*self.tc + "^"&#13;
                print("%s, (state=%d, tc=%d)" % (s,self.c,self.tc))            &#13;
                print("%s" % t)&#13;
                _ = input("?")&#13;
                if (_.lower() == "q"):&#13;
                    quit()&#13;
            self.Step()&#13;
&#13;
    def Result(self):&#13;
        <span class="codeitalic1">--snip--</span>&#13;
&#13;
<span class="ent">➎</span> def __init__(self, prog, tape=None, M=100, trace=False):&#13;
        if (tape is None):&#13;
            self.tape = [' ']*M&#13;
            self.M = M&#13;
        else:&#13;
            tape.append(' ')  # extra blank added&#13;
            self.tape = tape&#13;
            self.M = len(tape)&#13;
&#13;
        self.c = 0          # start in state 0&#13;
        self.tc = 0         # start at position 0&#13;
        self.prog = prog    # state table, i.e. the program&#13;
        self.trace = trace  # trace or not</pre>&#13;
<p class="caption" id="ch03list2"><em>Listing 3-2: The <span class="codeitalic1">TuringMachine</span> class</em></p>&#13;
<p class="indent">The constructor <span class="ent">➎</span> accepts the program (<code>prog</code>) and the initial tape (<code>tape</code>), if any, or the size of the blank tape. If a tape is supplied, we add an extra blank as several example programs expect an ending blank. The constructor sets up the default state (<code>c</code>) and tape counter position (<code>tc</code>) and then saves the program.</p>&#13;
<p class="indent">The <code>Run</code> method is short and sweet as most of it implements tracing <span class="ent">➍</span>. Running a program is performing step after step until done. <code>Done</code> returns <code>True</code> if we fall off the tape or hit a negative state, which we’ll interpret as a halt instruction <span class="ent">➌</span>. All the action takes place in <code>Step</code>.</p>&#13;
<p class="indent"><code>Step</code> first locates the instruction table entry corresponding to the current state and the symbol under the tape head <span class="ent">➊</span>. Once found, we then extract the action, movement, and next state <span class="ent">➋</span>. We then update the current tape position with the action. After that, we increment or decrement the tape counter based on the move character (<code>R</code> or <code>L</code>). Lastly, we update the state to complete the instruction step.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>There are additional comments in <em>turing.py</em> explaining the code in more detail. Please review them. The catalog of examples is in <code>PROGS</code>. To add more examples, place them there and add a description in <code>NAMES</code>. Note that our machine follows Turing’s original paper, meaning we move the tape head along the tape. If you examine other Turing machine simulators, and there are many far more sophisticated than ours, be aware that many move the <em>tape</em> instead. Therefore, if you want to transfer a program for such an implementation to <em>turing.py</em>, you must change all <code>R</code> characters to <code>L</code> and vice versa.</p>&#13;
<h4 class="h4" id="lev2sec30"><strong><em>The Examples</em></strong></h4>&#13;
<p class="noindent">We described Turing’s Program 0 above. Now let’s walk through the other examples using a sufficient level of detail to understand the process encoded in the instruction table.</p>&#13;
<h5 class="h5" id="lev3sec7"><strong>Program 1: Change 0s to 1s</strong></h5>&#13;
<p class="noindent">This example is straightforward. The instructions convert all 0s to 1s and the program stops when a blank or one is encountered.</p>&#13;
<pre>((0,'0','1','R', 0),&#13;
 (0,'1','1','R',-1),&#13;
 (0,' ',' ','L',-1)),</pre>&#13;
<p class="indent">There is only one state, state 0, with a rule for all allowed symbols: 0, 1, and blank. To be specific, the first row of the table says, “if in state 0 and the symbol under the tape head is a 0, print a 1, move to the right, and remain in state 0.” This instruction will continue for as long as the symbol under the tape head is 0. It replaces the 0 with a 1 and moves to the next symbol again and again.</p>&#13;
<p class="indent">The remaining two instructions capture what to do if the symbol under the tape head is a one or a blank. In both cases, the matched symbol is printed again to leave that square unchanged. The critical point is that the next state is <em>–</em>1. Our machine stops if the state is negative, so <em>–</em>1 means “halt.”</p>&#13;
<p class="indent">Combined, these states move to the right along the tape, changing every 0 into a 1 until the program reads a 1 or a blank. Let’s see if our interpretation is correct by running the program with different input tapes. Initial tape configurations are passed on the command line as Python lists using 0 and 1, with 2 representing a blank. For example:</p>&#13;
<pre>&gt; <span class="codestrong1">python3 turing.py 1 [0,0,0,0,0]</span>&#13;
&#13;
Program complete: (state=-1, tc=4)&#13;
&#13;
[11111 ]&#13;
&#13;
&gt; <span class="codestrong1">python3 turing.py 1 [0,0,0,0,0,1,1]</span><span epub:type="pagebreak" id="page_89"/>&#13;
&#13;
Program complete: (state=-1, tc=6)&#13;
&#13;
[1111111 ]&#13;
&#13;
&gt; <span class="codestrong1">python3 turing.py 1 [0,0,0,0,0,2,1]</span>&#13;
&#13;
Program complete: (state=-1, tc=4)&#13;
&#13;
[11111 1 ]</pre>&#13;
<p class="indent">In each case above, the output matches what we expect from the program. All consecutive 0s are now 1s and blanks, and 1s are unchanged.</p>&#13;
<h5 class="h5" id="lev3sec8"><strong>Program 2: Unary Increment</strong></h5>&#13;
<p class="noindent">Binary numbers use two digits: 0 and 1. Unary numbers are tallies, that is, repeated instances of 1.</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_right"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_right"><p class="taba">2</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">11</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_right"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">111</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_right"><p class="taba">4</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">1111</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_right"><p class="taba">5</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">11111</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">Program 2 increments the unary number already on the tape:</p>&#13;
<pre>((0,'1','1','R', 0),&#13;
 (0,'0','1','L',-1),&#13;
 (0,' ','1','L',-1)),</pre>&#13;
<p class="indent">This program is quite similar to the program to map 0s to 1s. The first instruction marches along the tape, keeping every 1 a 1 and moving right until it finds a 0 or blank. The program turns the first 0 or blank into a 1 and then halts.</p>&#13;
<p class="indent">Let’s run this program with tracing to see how it moves. Press ENTER at each prompt to continue.</p>&#13;
<pre>&gt; <span class="codestrong1">python3 turing.py 2 [1,1,1] -t</span>&#13;
&#13;
111 , (state=0, tc=0)&#13;
^&#13;
?&#13;
111 , (state=0, tc=1)&#13;
 ^&#13;
?&#13;
111 , (state=0, tc=2)&#13;
  ^&#13;
?&#13;
111 , (state=0, tc=3)<span epub:type="pagebreak" id="page_90"/>&#13;
   ^&#13;
?&#13;
&#13;
Program complete: (state=-1, tc=2)&#13;
&#13;
[1111]</pre>&#13;
<p class="indent">Tracing shows the current tape, three 1s, and a blank added at the end as well as the current state and tape counter. The following line prints a carat under the current tape position. Pressing ENTER three times moves along the 1 to the blank. Pressing ENTER one more time fills that blank with a 1, after which the program halts. The initial input was 3 (<code>111</code>), and the output tape is now 4 (<code>1111</code>).</p>&#13;
<h5 class="h5" id="lev3sec9"><strong>Program 3: Binary Increment</strong></h5>&#13;
<p class="noindent">Binary numbers use 0 and 1 as digits. The addition rules for binary are simple and can be expressed as</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:100%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0 + 0 = 0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0 + 1 = 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">1 + 0 = 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">1 + 1 = 10 (carry)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">Note that the sum of 1 and 1 produces a carry. Program 3 implements a Turing machine that adds one to the binary number on the input tape. Its instruction table is</p>&#13;
<pre>((0,' ',' ','L', 1),&#13;
 (0,'0','0','R', 0),&#13;
 (0,'1','1','R', 0),&#13;
 (1,' ','1','R', 2),&#13;
 (1,'0','1','L', 2),&#13;
 (1,'1','0','L', 1),&#13;
 (2,' ',' ','L',-1),&#13;
 (2,'0','0','R', 2),&#13;
 (2,'1','1','R', 2)),</pre>&#13;
<p class="noindent">Program 3 uses three states. It isn’t readily evident from looking at the instruction table alone what the states are doing. So let’s run an example with tracing to see the instructions in action. We’ll add one to 1011<sub>2</sub> = 11<sub>10</sub>. The command line is</p>&#13;
<pre>&gt; <span class="codestrong1">python3 turing.py 3 [1,0,1,1] -t</span></pre>&#13;
<p class="indent"><a href="ch03.xhtml#ch03tab2">Table 3-2</a> contains the trace, step by step. The program generates 1100<sub>2</sub> = 12<sub>10</sub>, as expected.</p>&#13;
<p class="tabcap" id="ch03tab2"><span epub:type="pagebreak" id="page_91"/><strong>Table 3-2:</strong> Tracing Binary Increment for 1011</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:100%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa_top-border"><p class="taba"><code>1011 , (state=0, tc=0)</code></p>&#13;
<p class="taba"> <code>^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1011 , (state=0, tc=1)</code></p>&#13;
<p class="taba"> <code>^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1011 , (state=0, tc=2)</code></p>&#13;
<p class="taba"> <code> ^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1011 , (state=0, tc=3)</code></p>&#13;
<p class="taba"> <code>  ^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1011 , (state=0, tc=4)</code></p>&#13;
<p class="taba"> <code>   ^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1011 , (state=1, tc=3)</code></p>&#13;
<p class="taba"> <code>  ^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1010 , (state=1, tc=2)</code></p>&#13;
<p class="taba"> <code> ^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1000 , (state=1, tc=1)</code></p>&#13;
<p class="taba"> <code>^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1100 , (state=2, tc=0)</code></p>&#13;
<p class="taba"><code>^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1100 , (state=2, tc=1)</code></p>&#13;
<p class="taba"> <code>^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>1100 , (state=2, tc=2)</code></p>&#13;
<p class="taba"> <code> ^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1100 , (state=2, tc=3)</code></p>&#13;
<p class="taba"> <code>  ^</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa_bottom-border"><p class="taba"><code>1100 , (state=2, tc=4)</code></p>&#13;
<p class="taba"> <code>   ^</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The first five steps of <a href="ch03.xhtml#ch03tab2">Table 3-2</a> move along the input, looking for a blank marking the end of the binary number. state 0 is sufficient for this part. When the program finds the blank in this state, it decrements the tape counter to look at the rightmost digit of the binary number, after which state 1 becomes active.</p>&#13;
<p class="indent">With state 1 active, if the symbol under the tape head is a 0, it is replaced by a 1, the tape head moves to the left, and state 2 becomes active. This is equivalent to adding 1. If the symbol under the tape head is a 1, the program replaces it with 0 as 1 + 1 = 0 with a carry of 1. The machine then remains in state 1 after moving left. The carry is implied by state 1 and the fact that the state moves left, replacing 1s with 0s. The 0 and 1 instructions of state 1 together process the number right to left and handle the carry by remaining in state 1 until a 0 is found. Adding 1 to 0 does not produce a carry, so the machine would move to state 2 and the increment would be complete.</p>&#13;
<p class="indent">State 2 moves the tape head back right along the number until a terminating blank is found, at which point the state becomes <em>–</em>1 and the machine halts. The action of state 2 is only to position the tape head. If we’re not interested in positioning the head at the end of the number, we could transition to <em>–</em>1 from state 1 as soon as a 0 is updated to a 1. Try this example with different inputs until you are comfortable with how it works.</p>&#13;
<h5 class="h5" id="lev3sec10"><span epub:type="pagebreak" id="page_92"/><strong>Program 4: Unary Subtraction</strong></h5>&#13;
<p class="noindent">Adding 1 to a unary number was quite simple. This next example implements unary subtraction with the larger number first, followed by a blank, and then the smaller number. For example, an input of <code>[11111 111]</code> returns <code>[11        ]</code>, which is 5 <em>–</em> 3 = 2, using blanks to overwrite any extra digits.</p>&#13;
<p class="indent">Let’s run this example with tracing. We won’t list the many steps required, but I suspect that you will see for yourself what the instructions are doing. It’s quite clever. Run the example with the following command:</p>&#13;
<pre>&gt; <span class="codestrong1">python3 turing.py 4 [1,1,1,1,1,2,1,1,1] -t</span></pre>&#13;
<p class="indent">State 0 finds the blank between the first and second number and then transitions to state 1. State 1 finds the blank after the second number and transitions to state 2. State 2 moves left over the smaller number, changing the first 1 found into a 0 and then moving to state 3. State 3 finds the blank between the two numbers and moves to state 7. State 7 makes the first 1 of the larger number a 0 and moves back to state 0. This state 0, 1, 2, 3, 7 cycle repeats until state 2 no longer finds a 1 in the smaller number.</p>&#13;
<p class="indent">At this point, all the 1s of the smaller number are 0s, as are the same number of rightmost 1s of the larger number. In essence, the subtraction is complete. The remainder of the program changes 0s to blanks, so the only symbols on the tape when the program ends are the remaining 1s of the larger unary number. States 4, 5, and 6 accomplish this and then transition from state 6 to –1 when there are no more 0s.</p>&#13;
<h5 class="h5" id="lev3sec11"><strong>Try Your Hand</strong></h5>&#13;
<p class="noindent">Running <em>turing.py</em> without command line arguments shows five example programs. There is actually a sixth, Program 5, but it was intentionally left out of the list as an exercise. Program 5 calculates the two’s complement of the binary number on the input tape. Computers store negative integers in two’s complement format so hardware only needs to implement addition. Subtraction of two integers is addition using two’s complement form.</p>&#13;
<p class="indent">Finding the two’s complement of a binary number is easy: change all 0 bits to 1s and all the 1s to 0s, and then add 1 to that result. For example:</p>&#13;
<p class="equationc">01011011 → 10100100 + 1 → 10100101</p>&#13;
<p class="indent">The challenge of this section is to create the instruction table for a Turing machine that converts its input to two’s complement format. We have a Turing machine that adds 1 to a binary number. We also have a Turing machine that converts 0s to 1s. The required machine will flip 0s and 1s before adding 1. Try writing the two’s complement instruction table yourself. When ready, take a look at the last entry in <code>PROGS</code> and compare it with your table. You can run Program 5 easily enough.<span epub:type="pagebreak" id="page_93"/></p>&#13;
<pre>&gt; <span class="codestrong1">python3 turing.py 5 [0,1,0,1,1,0,1,1]</span>&#13;
&#13;
Program complete: (state=-1, tc=7)&#13;
&#13;
[10100101 ]</pre>&#13;
<p class="noindent">The output is what we found for the example above.</p>&#13;
<h3 class="h3" id="lev1sec34"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter explored Turing machines and the idea of Turing completeness. We began with the halting problem and then moved on to Turing machines, the mechanism Turing used in his famous 1936 paper where he demonstrated that the halting problem was undecidable. We then explored the idea of a UTM, which led directly to the concept of a stored-program computer.</p>&#13;
<p class="indent">Next, we discussed the concept of Turing completeness, something we’ll refer to throughout the book as we explore esolangs. The idea that many systems are accidentally Turing complete is simple enough. Lastly, we implemented a Turing machine simulator in Python and worked through several example programs.</p>&#13;
<p class="indent">This chapter concludes <a href="part01.xhtml#part01">Part I</a> of the book. We move on now to consider what I’m calling “atypical programming languages,” by which I mean languages meant for serious use but that are sufficiently different from the pack in their approach to warrant a detailed examination as a precursor to the esolangs that follow. We will begin with Forth, a stack-based language.<span epub:type="pagebreak" id="page_94"/></p>&#13;
</div></body></html>