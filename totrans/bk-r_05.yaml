- en: '**4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**NON-NUMERIC VALUES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, you’ve been working almost exclusively with numeric values. But statistical
    programming also requires non-numeric values. In this chapter, we’ll consider
    three important non-numeric data types: logicals, characters, and factors. These
    data types play an important role in effective use of R, especially as we get
    into more complex R programming in [Part II](part02.xhtml#part02).'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.1 Logical Values**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Logical values (also simply called *logicals*) are based on a simple premise:
    a logical-valued object can only be either `TRUE` or `FALSE`. These can be interpreted
    as yes/no, one/zero, satisfied/not satisfied, and so on. This is a concept that
    appears across all programming languages, and logical values have many important
    uses. Often, they signal whether a condition has been satisfied or whether a parameter
    should be switched on or off.'
  prefs: []
  type: TYPE_NORMAL
- en: You encountered logical values briefly when you used the `sort` function in
    [Section 2.3.2](ch02.xhtml#ch02lev2sec21) and the `matrix` function in [Section
    3.1](ch03.xhtml#ch03lev1sec12). When using `sort`, setting `decreasing=TRUE` returns
    a vector ordered from largest to smallest, and `decreasing=FALSE` sorts the vector
    the other way around. Similarly, when constructing a matrix, `byrow=TRUE` fills
    the matrix entries row-wise; otherwise, the matrix is filled column-wise. Now,
    you’ll take a more detailed look at ways to use logicals.
  prefs: []
  type: TYPE_NORMAL
- en: '***4.1.1 TRUE or FALSE?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Logical values in R are written fully as `TRUE` and `FALSE`, but they are frequently
    abbreviated as `T` or `F`. The abbreviated version has no effect on the execution
    of the code, so, for example, using `decreasing=T` is equivalent to `decreasing=TRUE`
    in the `sort` function. (But do not create objects named `T` or `F` if you want
    to make use of this convenience—see [Section 9.1.3](ch09.xhtml#ch09lev2sec81).)
  prefs: []
  type: TYPE_NORMAL
- en: Assigning logical values to an object is the same as assigning numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This gives you one object with the value `TRUE` and one with the value `FALSE`.
    Similarly, vectors can be filled with logical values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Matrices (and other higher-dimensional arrays) can be created with these values
    too. Using `foo` and `baz` from earlier, you could construct something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '***4.1.2 A Logical Outcome: Relational Operators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Logicals are commonly used to check relationships between values. For example,
    you might want to know whether some number *a* is greater than a predefined threshold
    *b*. For this, you use the standard *relational operators* shown in [Table 4-1](ch04.xhtml#ch4tab1),
    which produce logical values as results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-1:** Relational Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Interpretation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | Equal to |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | Not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Greater than |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Less than |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: 'Typically, these operators are used on numeric values (though you’ll look at
    some other possibilities in [Section 4.2.1](ch04.xhtml#ch04lev2sec42)). Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The results should be unsurprising: `1` being equal to `2` is `FALSE` and `1`
    being greater than `2` is also `FALSE`, while the result of `2-1` being less than
    or equal to `2` is `TRUE` and it is also `TRUE` that `1` is not equal to `5` (`2+3`).
    These kinds of operations are much more useful when used on numbers that are variable
    in some way, as you’ll see shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: You’re already familiar with R’s element-wise behavior when working with vectors.
    The same rules apply when using relational operators. To illustrate this, let’s
    first create two vectors and double-check that they’re of equal length.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the following four evaluations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first line checks whether the entries in `foo` are equal to the corresponding
    entries in `bar`, which is true only for the fifth and ninth entries. The returned
    vector will contain a logical result for each pair of elements, so it will be
    the same length as the vectors being compared. The second line compares `foo`
    and `bar` in the same way, this time checking whether the entries in `foo` are
    less than the entries in `bar`. Contrast this result with the third comparison,
    which asks whether entries are less than *or equal to* one another. Finally, the
    fourth line checks whether `foo`’s members are less than or equal to `bar`, when
    the elements of `bar` are increased by `10`. Naturally, the results are all `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: Vector recycling also applies to logicals. Let’s use `foo` from earlier, along
    with a shorter vector, `baz`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you create `baz` as a vector of length 2 comprised of the 10th and 3rd
    elements of `foo`. Now consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the two elements of `baz` are recycled and checked against the 10 elements
    of `foo`. Elements `1` and `2` of `foo` are checked against `1` and `2` of `baz`,
    elements `3` and `4` of `foo` are checked against `1` and `2` of `baz`, and so
    on. You can also check all the values of a vector against a single value. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is a typical operation when handling data sets in R.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s rewrite the contents of `foo` and `bar` as 5 × 2 column-filled matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The same element-wise behavior applies here; if you compare the matrices, you
    get a matrix of the same size filled with logicals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This kind of evaluation also applies to arrays of more than two dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two useful functions you can use to quickly inspect a collection
    of logical values: `any` and `all`. When examining a vector, `any` returns `TRUE`
    if any of the logicals in the vector are `TRUE` and returns `FALSE` otherwise.
    The function `all` returns a `TRUE` only if *all* of the logicals are `TRUE`,
    and returns `FALSE` otherwise. As a quick example, let’s work with two of the
    logical vectors formed by the comparisons of `foo` and `bar` from the beginning
    of this section.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `qux` contains two `TRUE`s, and the rest are `FALSE`—so the result
    of `any` is of course `TRUE`, but the result of `all` is `FALSE`. Following the
    same rules, you get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `any` and `all` functions do the same thing for matrices and arrays of logical
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 4.1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Store the following vector of 15 values as an object in your workspace: `c(6,9,7,3,6,7,9,6,3,6,6,7,1,9,1)`.
    Identify the following elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Those equal to 6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Those greater than or equal to 6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Those less than 6 + 2
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Those not equal to 6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new vector from the one used in (a) by deleting its first three elements.
    With this new vector, fill a 2 × 2 × 3 array. Examine the array for the following
    entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Those less than or equal to 6 divided by 2, plus 4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Those less than or equal to 6 divided by 2, plus 4, *after* increasing every
    element in the array by 2
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm the specific locations of elements equal to 0 in the 10 × 10 identity
    matrix *I[10]* (see [Section 3.3](ch03.xhtml#ch03lev1sec14)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether *any* of the values of the logical arrays created in (b) are `TRUE`.
    If they are, check whether they are *all* `TRUE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By extracting the diagonal elements of the logical matrix created in (c), use
    `any` to confirm there are no `TRUE` entries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***4.1.3 Multiple Comparisons: Logical Operators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Logicals are especially useful when you want to examine whether multiple conditions
    are satisfied. Often you’ll want to perform certain operations only if a number
    of different conditions have been met.
  prefs: []
  type: TYPE_NORMAL
- en: The previous section looked at relational operators, used to compare the literal
    values (that is, numeric or otherwise) of stored R objects. Now you’ll look at
    *logical operators*, which are used to compare two `TRUE` or `FALSE` objects.
    These operators are based on the statements AND and OR. [Table 4-2](ch04.xhtml#ch4tab2)
    summarizes the R syntax and the behavior of logical operators. The AND and OR
    operators each have a “single” and “element-wise” version—you’ll see how they’re
    different in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-2:** Logical Operators Comparing Two Logical Values'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Interpretation** | **Results** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | AND (element-wise) | `TRUE & TRUE` is `TRUE` `TRUE & FALSE` is `FALSE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`FALSE & TRUE` is `FALSE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`FALSE & FALSE` is `FALSE` |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `&&` | AND (single comparison) | Same as `&` above |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | OR (element-wise) | `TRUE&#124;TRUE` is `TRUE` `TRUE&#124;FALSE`
    is `TRUE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`FALSE&#124;TRUE` is `TRUE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`FALSE&#124;FALSE` is `FALSE` |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `&#124;&#124;` | OR (single comparison) | Same as `&#124;` above |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | NOT | `!TRUE` is `FALSE !FALSE` is `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: The result of using any logical operator is a logical value. An AND comparison
    is true only if *both* logicals are `TRUE`. An OR comparison is true if at least
    one of the logicals is `TRUE`. The NOT operator (`!`) simply returns the opposite
    of the logical value it’s used on. You can combine these operators to examine
    multiple conditions at once.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As with numeric arithmetic, there is an order of importance for logical operations
    in R. An AND statement has a higher precedence than an OR statement. It’s helpful
    to place each comparative pair in parentheses to preserve the correct order of
    evaluation and make the code more readable. You can see this in the first line
    of this code, where the innermost comparison is the first to be carried out: `T&&TRUE`
    results in `TRUE`; this is then provided as one of the logical values for the
    next bracketed comparison where `TRUE||FALSE` results in `TRUE`. The final comparison
    is then `FALSE||TRUE`, and the result, `TRUE`, is printed to the console. The
    second line reads as NOT `TRUE` AND `TRUE`, which of course returns `FALSE`. In
    the third line, once again the innermost pair is evaluated first: `TRUE||F` is
    `TRUE`; `T&&TRUE` is `TRUE`; and finally `TRUE&&FALSE` is `FALSE`. The fourth
    and final example evaluates two distinct conditions in parentheses, which are
    then compared using a logical operator. Since `6<4` is `FALSE` and `3!=1` is `TRUE`,
    that gives you a logical comparison of `FALSE||TRUE` and a final result of `TRUE`.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 4-2](ch04.xhtml#ch4tab2), there is a short (`&`, `|`) and long (`&&`,
    `||`) version of the AND and OR operators. The short versions are meant for element-wise
    comparisons, where you have two logical vectors and you want multiple logicals
    as a result. The long versions, which you’ve been using so far, are meant for
    comparing two individual values and will return a single logical value. This is
    important when programming conditional checks in R in an `if` statement, which
    you’ll look at in [Chapter 10](ch10.xhtml#ch10). It’s possible to compare a single
    pair of logicals using the short version—though it’s considered better practice
    to use the longer versions when a single `TRUE`/`FALSE` result is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some examples of element-wise comparisons. Suppose you have two
    vectors of equal length, `foo` and `bar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The short versions of the logical operators match each pair of elements by position
    and return the result of the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using the long version of the operators, on the other hand, means R carries
    out the comparison only on the first pair of logicals in the two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the last two results match the first entries of the vectors you
    got using the short versions of the logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 4.2**'
  prefs: []
  type: TYPE_NORMAL
- en: Store the vector `c(7,1,7,10,5,9,10,3,10,8)` as `foo`. Identify the elements
    greater than 5 OR equal to 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the vector `c(8,8,4,4,5,1,5,6,6,8)` as `bar`. Identify the elements less
    than or equal to 6 AND not equal to 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the elements that satisfy (a) in `foo` AND satisfy (b) in `bar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Store a third vector called `baz` that is equal to the element-wise sum of
    `foo` and `bar`. Determine the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The elements of `baz` greater than or equal to 14 but not equal to 15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The elements of the vector obtained via an element-wise division of `baz` by
    `foo` that are greater than 4 OR less than or equal to 2
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that using the long version in all of the preceding exercises performs
    only the first comparison (that is, the results each match the first entries of
    the previously obtained vectors).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***4.1.4 Logicals Are Numbers!***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because of the binary nature of logical values, they’re often represented with
    `TRUE` as 1 and `FALSE` as 0\. In fact, in R, if you perform elementary numeric
    operations on logical values, `TRUE` is treated like `1`, and `FALSE` is treated
    like `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These operations turn out the same as if you had used the digits 1 and 0\. In
    some situations when you’d use logicals, you can substitute the numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Being able to interpret logicals as zeros and ones means you can use a variety
    of functions to summarize a logical vector, and you’ll explore this further in
    [Part III](part03.xhtml#part03).
  prefs: []
  type: TYPE_NORMAL
- en: '***4.1.5 Logical Subsetting and Extraction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Logicals can also be used to extract and subset elements in vectors and other
    objects, in the same way as you’ve done so far with index vectors. Rather than
    entering explicit indexes in the square brackets, you can supply logical *flag*
    vectors, where an element is extracted if the corresponding entry in the flag
    vector is `TRUE`. As such, logical flag vectors should be the same length as the
    vector that’s being accessed (though recycling does occur for shorter flag vectors,
    as a later example shows).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of [Section 2.3.3](ch02.xhtml#ch02lev2sec22) you defined a
    vector of length 10 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to extract the two negative elements, you could either enter
    `myvec[c(2,10)]`, or you could do the following using logical flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This particular example may seem far too cumbersome for practical use. It becomes
    useful, however, when you want to extract elements based on whether they satisfy
    a certain condition (or several conditions). For example, you can easily use logicals
    to find negative elements in `myvec` by applying the condition `<0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This a perfectly valid flag vector that you can use to subset `myvec` to get
    the same result as earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, R recycles the flag vector if it’s too short. To extract every
    second element from `myvec`, starting with the first, you could enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do more complicated extractions using relational and logical operators,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This returns the positive elements that are less than 1,000\. You can also overwrite
    specific elements using a logical flag vector, just as with index vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This replaces all existing negative entries with −200\. Note, though, that you
    cannot directly use negative logical flag vectors to delete specific elements;
    this can be done only with numeric index vectors.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, logicals are therefore very useful for element extraction. You
    don’t need to know beforehand which specific index positions to return, since
    the conditional check can find them for you. This is particularly valuable when
    you’re dealing with large data sets and you want to inspect records or recode
    entries that match certain criteria.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you might want to convert a logical flag vector into a numeric
    index vector. This is helpful when you need the explicit indexes of elements that
    were flagged `TRUE`. The R function `which` takes in a logical vector as the argument
    `x` and returns the indexes corresponding to the positions of any and all `TRUE`
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this to identify the index positions of `myvec` that meet a certain
    condition; for example, those containing negative numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be done for the other `myvec` selections you experimented with.
    Note that a line of code such as `myvec[which(x=myvec<0)]` is redundant because
    that extraction can be made using the condition by itself, that is, via `myvec[myvec<0]`,
    without using `which`. On the other hand, using `which` lets you delete elements
    based on logical flag vectors. You can simply use `which` to identify the numeric
    indexes you want to delete and render them negative. To omit the negative entries
    of `myvec`, you could execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be done with matrices and other arrays. In [Section 3.2](ch03.xhtml#ch03lev1sec13),
    you stored a 3 × 3 matrix as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the second and third column elements of the first row of `A` using
    numeric indexes, you could execute `A[1,2:3]`. To do this with logical flags,
    you could enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, though, you usually wouldn’t explicitly specify the logical vectors.
    Suppose for example you want to replace all elements in `A` that are less than
    1 with −7\. Performing this using numeric indexes is rather fiddly. It’s much
    easier to use the logical flag matrix created with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can supply this logical matrix to the square bracket operators, and the
    replacement is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is the first time you’ve subsetted a matrix without having to list row
    or column positions inside the square brackets, using commas to separate out dimensions
    (see [Section 3.2](ch03.xhtml#ch03lev1sec13)). This is because the flag matrix
    has the same number of rows and columns as the target matrix, thereby providing
    all the relevant structural information.
  prefs: []
  type: TYPE_NORMAL
- en: If you use `which` to identify numeric indexes based on a logical flag structure,
    you have to be a little more careful when dealing with two-dimensional objects
    or higher. Suppose you want the index positions of the elements that are greater
    than 25\. The appropriate logical matrix is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, say you ask R the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This returns the four indexes of the elements that satisfied the relational
    check, but they are provided as scalar values. How do these correspond to the
    row/column positioning of the matrix?
  prefs: []
  type: TYPE_NORMAL
- en: The answer lies in R’s default behavior for the `which` function, which essentially
    treats the multidimensional object as a single vector (laid out column after column)
    and then returns the vector of corresponding indexes. Say the matrix `A` was arranged
    as a vector by stacking the columns first through third, using `c(A[,1],A[,2],A[,3])`.
    Then the indexes returned make more sense.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With the columns laid out end to end, the elements that return `TRUE` are the
    third, fourth, sixth, and ninth elements in the list. This can be difficult to
    interpret, though, especially when dealing with higher-dimensional arrays. In
    this kind of situation, you can make `which` return dimension-specific indexes
    using the optional argument `arr.ind` (array indexes). By default, this argument
    is set to `FALSE`, resulting in the vector converted indexes. Setting `arr.ind`
    to `TRUE`, on the other hand, treats the object as a matrix or array rather than
    a vector, providing you with the row and column positions of the elements you
    requested.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The returned object is now a matrix, where each row represents an element that
    satisfied the logical comparison and each column provides the position of the
    element. Comparing the output here with `A`, you can see these positions do indeed
    correspond to elements where `A>25`.
  prefs: []
  type: TYPE_NORMAL
- en: Both versions of the output (with `arr.ind=T` or `arr.ind=F`) can be useful—the
    correct choice depends on the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 4.3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Store this vector of 10 values: `foo <- c(7,5,6,1,2,10,8,3,8,2)`. Then, do
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the elements greater than or equal to 5, storing the result as `bar`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the vector containing those elements from `foo` that remain after omitting
    all elements that are greater than or equal to 5.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `bar` from (a)(i) to construct a 2 × 3 matrix called `baz`, filled in a
    row-wise fashion. Then, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace any elements that are equal to 8 with the *squared* value of the element
    in row 1, column 2 of `baz` itself.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that *all* values in `baz` are now less than or equal to 25 AND greater
    than 4.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a 3 × 2 × 3 array called `qux` using the following vector of 18 values:
    `c(10,5,1,4,7,4,3,3,1,3,4,3,1,7,8,3,7,3)`. Then, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the dimension-specific index positions of elements that are either
    3 OR 4.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace all elements in `qux` that are less than 3 OR greater than or equal
    to 7 with the value 100.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to `foo` from (a). Use the vector `c(F,T)` to extract every second value
    from `foo`. In [Section 4.1.4](ch04.xhtml#ch04lev2sec40), you saw that in some
    situations, you can substitute `0` and `1` for `TRUE` and `FALSE`. Can you perform
    the same extraction from `foo` using the vector `c(0,1)`? Why or why not? What
    does R return in this case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**4.2 Characters**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Character strings are another common data type, and are used to represent text.
    In R, strings are often used to specify folder locations or software options (as
    shown briefly in [Section 1.2](ch01.xhtml#ch01lev1sec06)); to supply an argument
    to a function; and to annotate stored objects, provide textual output, or help
    clarify plots and graphics. In a simple way, they can also be used to define different
    groups making up a categorical variable, though as you’ll see in see [Section
    4.3](ch04.xhtml#ch04lev1sec18), *factors* are better suited for that.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There are three different string formats in the R environment. The default
    string format is called an* extended regular expression*; the other variants are
    named* Perl *and* literal regular expressions*. The intricacies of these variants
    are beyond the scope of this book, so any mention of character strings from here
    on refers to an extended regular expression. For more technical details about
    other string formats, enter* `?regex` *at the prompt.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***4.2.1 Creating a String***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Character strings are indicated by double quotation marks, `"`. To create a
    string, just enter text between a pair of quotes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'R treats the string as a single entity. In other words, `foo` is a vector of
    length 1 because R counts only the total number of distinct strings rather than
    individual words or characters. To count the number of individual characters,
    you can use the `nchar` function. Here’s an example using `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Almost any combination of characters, including numbers, can be a valid character
    string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this form, the string has no numeric meaning, and it won’t be treated
    like the number 23.3\. Attempting to multiply it by 2, for example, results in
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This error occurs because `*` is expecting to operate on two numeric values
    (not one number and one string, which makes no sense).
  prefs: []
  type: TYPE_NORMAL
- en: Strings can be compared in several ways, the most common comparison being a
    check for equality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Other relational operators work as you might expect. For example, R considers
    letters that come later in the alphabet to be greater than earlier letters, meaning
    it can determine whether one string of letters is greater than another with respect
    to alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, uppercase letters are considered greater than lowercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Most symbols can also be used in a string. The following string is valid, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: One important exception is the backslash `\`, also called an *escape*. When
    a backslash is used within the quotation marks of a string, it initiates some
    simple control over the printing or display of the string itself. You’ll see how
    this works in a moment in [Section 4.2.3](ch04.xhtml#ch04lev2sec44). First let’s
    look at two useful functions for combining strings.
  prefs: []
  type: TYPE_NORMAL
- en: '***4.2.2 Concatenation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two main functions used to *concatenate* (or glue together) one or
    more strings: `cat` and `paste`. The difference between the two lies in how their
    contents are returned. The first function, `cat`, sends its output directly to
    the console screen and doesn’t formally *return* anything. The `paste` function
    concatenates its contents and then returns the final character string as a usable
    R object. This is useful when the result of a string concatenation needs to be
    passed to another function or used in some secondary way, as opposed to just being
    displayed. Consider the following vector of character strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As with numbers and logicals, you can also store any number of strings in a
    matrix or array structure if you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling `cat` or `paste`, you pass arguments to the function in the order
    you want them combined. The following lines show identical usage yet different
    types of output from the two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, you’ve used the three elements of `qux` as well as two additional strings,
    `"totally"` and `"!"`, to produce the final concatenated string. In the output,
    note that `cat` has simply concatenated and printed the text to the screen. This
    means you cannot directly assign the result to a new variable and treat it as
    a character string. For `paste`, however, the `[1]` to the left of the output
    and the presence of the `"` quotes indicate the returned item is a vector containing
    a character string, and this can be assigned to an object and used in other functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There’s a slight difference between OS X and Windows in the default handling
    of string concatenation when using the R GUI. After calling* `cat` *in Windows,
    the new R prompt awaiting your next command appears on the same line as the printed
    string, in which case you can just hit* ENTER *to move to the next line, or use
    an* escape sequence*, which you’ll look at in [Section 4.2.3](ch04.xhtml#ch04lev2sec44).
    In OS X, the new prompt appears on the next line as usual.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'These two functions have an optional argument, `sep`, that’s used as a separator
    between strings as they’re concatenated. You pass `sep` a character string, and
    it will place this string between all other strings you’ve provided to `paste`
    or `cat`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The same behavior would occur for `cat`. Note that if you don’t want any separation,
    you set `sep=""`, an empty string, as shown in the second example. The empty string
    separator can be used to achieve correct sentence spacing; note the gap between
    `awesome` and the exclamation mark in the previous code when you first used `paste`
    and `cat`. If the `sep` argument isn’t included, R will insert a space between
    strings by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using manual insertion of spaces where necessary, you can write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenation can be useful when you want to neatly summarize the results from
    a certain function or set of calculations. Many kinds of R objects can be passed
    directly to `paste` or `cat`; the software will attempt to automatically *coerce*
    these items into character strings. This means R will convert the input into a
    string so the values can be included in the final concatenated string. This works
    particularly well with numeric objects, as the following examples demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, the values of the non-string objects are placed where you want them in
    the final string output. The results of calculations can also appear as fields,
    as shown with the arithmetic `a+b` and the logical comparison `a+b<10`. You’ll
    see more details about coercion from one kind of value to another in [Section
    6.2.4](ch06.xhtml#ch06lev2sec62).
  prefs: []
  type: TYPE_NORMAL
- en: '***4.2.3 Escape Sequences***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Section 4.2.1](ch04.xhtml#ch04lev2sec42), I noted that a stand-alone backslash
    doesn’t act like a normal character within a string. The `\` is used to invoke
    an *escape sequence*. An escape sequence lets you enter characters that control
    the format and spacing of the string, rather than being interpreted as normal
    text. [Table 4-3](ch04.xhtml#ch4tab3) describes some of the most common escape
    sequences, and you can find a full list by entering `?Quotes` at the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-3:** Common Escape Sequences for Use in Character Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Escape sequence** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | Starts a newline |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | Horizontal tab |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Invokes a backspace |'
  prefs: []
  type: TYPE_TB
- en: '| `\\` | Used as a single backslash |'
  prefs: []
  type: TYPE_TB
- en: '| `\"` | Includes a double quote |'
  prefs: []
  type: TYPE_TB
- en: Escape sequences add flexibility to the display of character strings, which
    can be useful for summaries of results and plot annotations. You enter the sequence
    precisely where you want it to take effect. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since the signal for an escape is `\` and the signal to begin and end a string
    is `"`, if you want either of these characters to be included in a string, you
    must also use an escape to have them be interpreted as a normal character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: These escape sequences mean that you can’t use a stand-alone backslash in file
    path strings in R. As noted in [Section 1.2.3](ch01.xhtml#ch01lev2sec08) (where
    you used `getwd` to print the current working directory and `setwd` to change
    it), folder separation must use a forward slash `/` and not a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: File path specification crops up when reading and writing files, which you’ll
    explore in [Chapter 8](ch08.xhtml#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: '***4.2.4 Substrings and Matching***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Pattern matching* lets you inspect a given string to identify smaller strings
    within it.'
  prefs: []
  type: TYPE_NORMAL
- en: The function `substr` takes a string `x` and extracts the part of the string
    between two character positions (inclusive), indicated with numbers passed as
    `start` and `stop` arguments. Let’s try it on the object `foo` from [Section 4.2.1](ch04.xhtml#ch04lev2sec42).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, you’ve extracted the characters between positions 21 and 27, inclusive,
    to get `"string!"`. The function `substr` can also be used with the assignment
    operator to directly substitute in a new set of characters. In this case, the
    replacement string should contain the same number of characters as the selected
    area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If the replacement string is longer than the number of characters indicated
    by `start` and `stop`, then replacement still takes place, beginning at `start`
    and ending at `stop`. It cuts off any characters that overrun the number of characters
    you’re replacing. If the string is shorter than the number of characters you’re
    replacing, then replacement ends when the string is fully inserted, leaving the
    original characters up to `stop` untouched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Substitution is more flexible using the functions `sub` and `gsub`. The `sub`
    function searches a given string `x` for a smaller string `pattern` contained
    within. It then replaces the first instance with a new string, given as the argument
    `replacement`. The `gsub` function does the same thing, but it replaces *every*
    instance of `pattern`. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: With `sub` and `gsub`, the `replacement` value need not have the same number
    of characters as the `pattern` being replaced. These functions also have search
    options like case-sensitivity. The help files `?substr` and `?sub` have more details,
    as well as noting a handful of other pattern-matching functions and techniques.
    You might also want to check out the `grep` command and its variants; see the
    relevant help file `?grep`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 4.4**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Re-create exactly the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Suppose you’ve stored the values `num1 <- 4` and `num2 <- 0.75`. Write a line
    of R code that returns the following string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure your code produces a string with the correct multiplication result
    for *any* two numbers stored as `num1` and `num2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On my local machine, the directory for my work on this book is specified in
    R as `"/Users/tdavies/Documents/RBook/"`. Imagine it is your machine—write a line
    of code that replaces `tdavies` in this string with your first initial and surname.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In [Section 4.2.4](ch04.xhtml#ch04lev2sec45), you stored the following string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Store a new string by gluing onto `bar` the words `"if a woodchuck could chuck
    wood"`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the result of (i), replace all instances of `wood` with `metal`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Store the string `"Two 6-packs for $12.99"`. Then do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a check for equality to confirm that the substring beginning with character
    5 and ending with character 10 is `"6-pack"`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make it a better deal by changing the price to $10.99.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**4.3 Factors**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll look at some simple functions related to creating, handling,
    and inspecting *factors*. Factors are R’s most natural way of representing data
    points that fit in only one of a finite number of distinct categories, rather
    than belonging to a continuum. Categorical data like this can play an important
    role in data science, and you’ll look at factors again in more detail from a statistical
    perspective in [Chapter 13](ch13.xhtml#ch13).
  prefs: []
  type: TYPE_NORMAL
- en: '***4.3.1 Identifying Categories***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To see how factors work, let’s start with a simple data set. Suppose you find
    eight people and record their first name, sex, and month of birth in [Table 4-4](ch04.xhtml#ch4tab4).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-4:** An Example Data Set of Eight Individuals'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Person** | **Sex** | **Month of birth** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Liz | Female | April |'
  prefs: []
  type: TYPE_TB
- en: '| Jolene | Female | January |'
  prefs: []
  type: TYPE_TB
- en: '| Susan | Female | December |'
  prefs: []
  type: TYPE_TB
- en: '| Boris | Male | September |'
  prefs: []
  type: TYPE_TB
- en: '| Rochelle | Female | November |'
  prefs: []
  type: TYPE_TB
- en: '| Tim | Male | July |'
  prefs: []
  type: TYPE_TB
- en: '| Simon | Male | July |'
  prefs: []
  type: TYPE_TB
- en: '| Amy | Female | June |'
  prefs: []
  type: TYPE_TB
- en: There’s really only one sensible way to represent the name of each person in
    R—as a vector of character strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You have more flexibility when it comes to recording sex, however. Coding females
    as 0 and males as 1, a numeric option would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Of course, character strings are also possible, and many prefer this because
    you don’t need to remember the numeric code for each group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: There is, however, a fundamental difference between an individual’s name and
    their sex when stored as data. Where a person’s name is a unique identifier that
    can take any one of an infinite number of possibilities, there are generally only
    two options for recording a person’s sex. These kinds of data, where all possible
    values fall into a finite number of categories, are best represented in R using
    factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Factors are typically created from a numeric or a character vector (note that
    you cannot fill matrices or multidimensional arrays using factor values; factors
    can only take the form of vectors). To create a factor vector, use the function
    `factor`, as in this example working with `sex.num` and `sex.char`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, you obtain factor versions of the two vectors storing gender values.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, these objects don’t look much different from the character
    and numeric vectors from which they were created. Indeed, factor objects work
    in much the same way as vectors, but with a little extra information attached
    (R’s internal representation of factor objects is a little different as well).
    Functions like `length` and `which` work the same way on factor objects as with
    vectors, for example.
  prefs: []
  type: TYPE_NORMAL
- en: The most important extra piece of information (or *attribute*; see [Section
    6.2.1](ch06.xhtml#ch06lev2sec59)) that a factor object contains is its *levels*,
    which store the possible values in the factor. These levels are printed at the
    bottom of each factor vector. You can extract the levels as a vector of character
    strings using the `levels` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also relabel a factor using `levels`. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This relabels the females `1` and the males `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Factor-valued vectors are subsetted in the same way as any other vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note that after subsetting a factor object, the object continues to store *all*
    defined levels even if some of the levels are no longer represented in the subsetted
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to subset from a factor using a logical flag vector, keep in mind
    that the levels of a factor are stored as character strings, even if the original
    data vector was numeric, so you need to use a string when requesting or testing
    for a particular level. To, for example, identify all the men using the newly
    relabeled `sex.num.fac`, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Since the elements in `firstname` and `sex` have corresponding positions in
    their factor vectors, you can then use this logical vector to obtain the names
    of all the men (this time using the `"male"`/`"female"` factor vector).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this simple subsetting could have been achieved in much the same
    way with the raw numeric vector `sex.num` or the raw character vector `sex.char`.
    In the next section, you’ll explore some more distinctive advantages to having
    categorical data represented as a factor in R.
  prefs: []
  type: TYPE_NORMAL
- en: '***4.3.2 Defining and Ordering Levels***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The sex factor from the previous section represents the simplest kind of factor
    variable—there are only two possible levels with no ordering, in that one level
    is not intuitively considered “higher than” or “following” the other. Here you’ll
    look at factors with levels that can be logically ordered; for example, month
    of birth (MOB), where there are 12 levels that have a natural order. Let’s store
    the observed MOB data from earlier as a character vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two problems with the data in this vector. First, not all possible
    categories are represented since `mob` contains only seven unique months. Second,
    this vector doesn’t reflect the natural order of the months. If you compare January
    and December to see which is greater, you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Alphabetically, this result is of course correct—*J* doesn’t occur before *D*.
    But in terms of the order of the calendar months, which is what we’re interested
    in, the `FALSE` result is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: If you create a factor object from these values, you can deal with both of these
    problems by supplying additional arguments to the `factor` function. You can define
    additional levels by supplying a character vector of all possible values to the
    `levels` argument and then instruct R to order the values precisely as they appear
    in `levels` by setting the argument `ordered` to `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `mob.fac` vector contains the same individual entries at the same
    index positions as the `mob` vector from earlier. But notice that this variable
    has 12 levels, even though you have not made any observations for the levels `"Feb"`,
    `"Mar"`, `"May"`, `"Aug"`, or `"Oct"`. (Note that if your R console window is
    too narrow to print all the levels to the screen, you may see a `...`, indicating
    there’s more output that’s been hidden. Just widen your window and reprint the
    object to see the hidden levels.) Also, the strict order of these levels is shown
    by the `<` symbol in the object output. Using this new factor object, you can
    perform the relational comparison from earlier and get the result you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: These improvements are far from just cosmetic. There’s a big difference, for
    example, between a data set with zero observations in some of the categories and
    the same data set defined with fewer categories to begin with. The choice of whether
    to instruct R to formally order a factor vector can also have important consequences
    in the implementation of various statistical methods, such as regression and other
    types of modeling.
  prefs: []
  type: TYPE_NORMAL
- en: '***4.3.3 Combining and Cutting***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you’ve seen, it’s usually simple to combine multiple vectors of the same
    kind (whether numeric, logical, or character) using the `c` function. Here’s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This combines the two numeric vectors into one.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `c` function doesn’t work the same way with factor-valued vectors.
    Let’s see what happens when you use it on the data in [Table 4-4](ch04.xhtml#ch4tab4)
    and the MOB factor vector `mob.fac`, from [Section 4.3.2](ch04.xhtml#ch04lev2sec47).
    Suppose you now observe three more individuals with MOB values `"Oct"`, `"Feb"`,
    and `"Feb"`, which are stored as a factor object, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now you have `mob.fac` with the original eight observations and `new.values`
    with an additional three. Both are factor objects, defined with identical, ordered
    levels. You might expect that you can just use `c` to combine the two as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, this has not done what you want it to do. Combining the two factor
    objects resulted in a numeric vector. This is because the `c` function interprets
    factors as integers. Comparing this with the defined levels, you can see that
    the numbers refer to the index of each month within the ordered levels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This means you can use these integers with `levels(mob.fac)` to retrieve a character
    vector of the complete observed data—the original eight observations plus the
    additional three.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Now you have all the observations stored in a vector, but they are currently
    stored as strings, not factor values. The final step is to turn this vector into
    a factor object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: As this example shows, combining factors requires you to essentially deconstruct
    the two objects, obtaining the numeric index positions of each entry with respect
    to the factor levels, and then rebuild them together. This helps ensure that the
    levels are consistent and the observations are valid in the final product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Factors are also often created from data that was originally measured on a
    continuum, for example the weight of a set of adults or the amount of a drug given
    to a patient. Sometimes you’ll need to group (or *bin*) these types of observations
    into categories, like Small/Medium/Large or Low/High. In R, you can mold this
    kind of data into discrete factor categories using the `cut` function. Consider
    the following numeric vector of length 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to bin the data as follows: *Small* refers to observations
    in the interval [0,2), *Medium* refers to [2,4), and *Large* refers to [4,6].
    A square bracket refers to *inclusion* of its nearest value, and a parenthesis
    indicates *exclusion*, so an observation *y* will fall in the Small interval if
    0 ≤ *y* < 2, in Medium if 2 ≤ *y* < 4, or in Large if 4 ≤ *y* ≤ 6\. For this you’d
    use `cut` and supply your desired break intervals to the `breaks` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This gives you a factor, with each observation now assigned an interval. However,
    notice that your boundary intervals are back-to-front—you want the boundary levels
    on the left like [0,2), rather than the right as they appear by default, (0,2].
    You can fix this by setting the logical argument `right` to `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you’ve swapped which boundaries are inclusive and exclusive. This is important
    because it changes which categories the values fall into. Notice that the seventh
    observation has changed categories. But there’s still a problem: the final interval
    currently *excludes* 6, and you want this maximum value to be *included* in the
    highest level. You can fix this with another logical argument: `include.lowest`.
    Even though it’s called “`include.lowest`,” this argument can also be used to
    include the *highest* value if `right` is `FALSE`, as indicated in the help file
    `?cut`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The intervals are now defined how you want. Finally, you want to add better
    labels to the categories, rather than using the interval levels that R applies
    by default, by passing a character string vector to the `labels` argument. The
    order of labels must match the order of the levels in the factor object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 4.5**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The New Zealand government consists of the political parties National, Labour,
    Greens, and Māori, with several smaller parties labeled as Other. Suppose you
    asked 20 New Zealanders which of these they identified most with and obtained
    the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: • There were 12 males and 8 females; the individuals numbered 1, 5–7, 12, and
    14–16 were females.
  prefs: []
  type: TYPE_NORMAL
- en: • The individuals numbered 1, 4, 12, 15, 16, and 19 identified with Labour;
    no one identified with Māori; the individuals numbered 6, 9, and 11 identified
    with Greens; 10 and 20 identified with Other; and the rest identified with National.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your knowledge of vectors (for example, subsetting and overwriting) to
    create two character vectors: `sex` with entries `"M"` (male) and `"F"` (female)
    and `party` with entries `"National"`, `"Labour"`, `"Greens"`, `"Maori"`, and
    `"Other"`. Make sure the entries are placed in the correct positions as outlined
    earlier.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two different factor vectors based on `sex` and `party`. Does it make
    any sense to use `ordered=TRUE` in either case? How has R appeared to arrange
    the levels?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use factor subsetting to do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the factor vector of chosen parties for only the male participants.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the factor vector of genders for those who chose National.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Another six people joined the survey, with the results `c("National","Maori","Maori","Labour","Greens","Labour")`
    for the preferred party and `c("M","M","F","F","F","M")` as their gender. Combine
    these results with the original factors from (b).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suppose you also asked all individuals to state how confident they were that
    Labour will win more seats in Parliament than National in the next election and
    to attach a subjective percentage to that confidence. The following 26 results
    were obtained: 93, 55, 29, 100, 52, 84, 56, 0, 33, 52, 35, 53, 55, 46, 40, 40,
    56, 45, 64, 31, 10, 29, 40, 95, 18, 61.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a factor with levels of confidence as follows: Low for percentages [0,30];
    Moderate for percentages (30,70]; and High for percentages (70,100].'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From (e), extract the levels corresponding to those individuals who originally
    said they identified with Labour. Do this also for National. What do you notice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUE`, `FALSE` | Reserved logical values | [Section 4.1.1](ch04.xhtml#ch04lev2sec37),
    [p. 60](ch04.xhtml#page_60) |'
  prefs: []
  type: TYPE_TB
- en: '| `T`, `F` | Unreserved versions of above | [Section 4.1.1](ch04.xhtml#ch04lev2sec37),
    [p. 60](ch04.xhtml#page_60) |'
  prefs: []
  type: TYPE_TB
- en: '| `==`, `!=`, `>`, `<`, `>=`, `<=` | relational operators | [Section 4.1.2](ch04.xhtml#ch04lev2sec38),
    [p. 61](ch04.xhtml#page_61) |'
  prefs: []
  type: TYPE_TB
- en: '| `any` | Checks whether any entries are `TRUE` | [Section 4.1.2](ch04.xhtml#ch04lev2sec38),
    [p. 63](ch04.xhtml#page_63) |'
  prefs: []
  type: TYPE_TB
- en: '| `all` | Checks whether all entries are `TRUE` | [Section 4.1.2](ch04.xhtml#ch04lev2sec38),
    [p. 63](ch04.xhtml#page_63) |'
  prefs: []
  type: TYPE_TB
- en: '| `&&`, `&`, `&#124;&#124;`, `&#124;`, `!` | logical operators | [Section 4.1.3](ch04.xhtml#ch04lev2sec39),
    [p. 65](ch04.xhtml#page_65) |'
  prefs: []
  type: TYPE_TB
- en: '| `which` | Determines indexes of `TRUE`s | [Section 4.1.5](ch04.xhtml#ch04lev2sec41),
    [p. 69](ch04.xhtml#page_69) |'
  prefs: []
  type: TYPE_TB
- en: '| `" "` | Creates a character string | [Section 4.2.1](ch04.xhtml#ch04lev2sec42),
    [p. 73](ch04.xhtml#page_73) |'
  prefs: []
  type: TYPE_TB
- en: '| `nchar` | Gets number of characters in a string | [Section 4.2.1](ch04.xhtml#ch04lev2sec42),
    [p. 73](ch04.xhtml#page_73) |'
  prefs: []
  type: TYPE_TB
- en: '| `cat` | Concatenates strings (no return) | [Section 4.2.2](ch04.xhtml#ch04lev2sec43),
    [p. 74](ch04.xhtml#page_74) |'
  prefs: []
  type: TYPE_TB
- en: '| `paste` | Pastes strings (returns a string) | [Section 4.2.2](ch04.xhtml#ch04lev2sec43),
    [p. 74](ch04.xhtml#page_74) |'
  prefs: []
  type: TYPE_TB
- en: '| `\` | String escape | [Section 4.2.3](ch04.xhtml#ch04lev2sec44), [p. 76](ch04.xhtml#page_76)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `substr` | Subsets a string | [Section 4.2.4](ch04.xhtml#ch04lev2sec45),
    [p. 77](ch04.xhtml#page_77) |'
  prefs: []
  type: TYPE_TB
- en: '| `sub`, `gsub` | String matching and replacement | [Section 4.2.4](ch04.xhtml#ch04lev2sec45),
    [p. 78](ch04.xhtml#page_78) |'
  prefs: []
  type: TYPE_TB
- en: '| `factor` | Creates a factor vector | [Section 4.3.1](ch04.xhtml#ch04lev2sec46),
    [p. 80](ch04.xhtml#page_80) |'
  prefs: []
  type: TYPE_TB
- en: '| `levels` | Gets levels of a factor | [Section 4.3.1](ch04.xhtml#ch04lev2sec46),
    [p. 81](ch04.xhtml#page_81) |'
  prefs: []
  type: TYPE_TB
- en: '| `cut` | Creates factor from continuum | [Section 4.3.3](ch04.xhtml#ch04lev2sec48),
    [p. 85](ch04.xhtml#page_85) |'
  prefs: []
  type: TYPE_TB
