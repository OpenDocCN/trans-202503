- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EVENT
    TRACING FOR WINDOWS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the Event Tracing for Windows (ETW) logging facility, developers can program
    their applications to emit events, consume events from other components, and control
    event-tracing sessions. This allows them to trace the execution of their code
    and monitor or debug potential issues. It may be helpful to think of ETW as an
    alternative to *printf*-based debugging; the messages are emitted over a common
    channel using a standard format rather than printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: In a security context, ETW provides valuable telemetry that wouldn’t otherwise
    be available to an endpoint agent. For example, the common language runtime, which
    is loaded into every .NET process, emits unique events using ETW that can provide
    more insight than any other mechanism into the nature of managed code executing
    on the host. This allows an EDR agent to collect novel data from which to create
    new alerts or enrich existing events.
  prefs: []
  type: TYPE_NORMAL
- en: ETW is rarely praised for its simplicity and ease of use, thanks in no small
    part to the tremendously complicated technical documentation that Microsoft provides
    for it. Luckily, while ETW’s inner workings and implementation details are fascinating,
    you don’t need a full understanding of its architecture. This chapter covers the
    parts of ETW that are relevant to those interested in telemetry. We’ll walk through
    how an agent might collect telemetry from ETW and how to evade this collection.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Architecture</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three main components involved in ETW: providers, consumers, and
    controllers. Each of these components serves a distinct purpose in an event-tracing
    session. The following overview describes how each component fits into the larger
    ETW architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Providers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simply put, providers are the software components that emit events. These might
    include parts of the system, such as the Task Scheduler, a third-party application,
    or even the kernel itself. Generally, the provider isn’t a separate application
    or image but rather the primary image associated with the component.
  prefs: []
  type: TYPE_NORMAL
- en: When this provider image follows some interesting or concerning code path, the
    developer can opt to have it emit an event related to its execution. For example,
    if the application handles user authentication, it might emit an event whenever
    authentication fails. These events contain any data the developer deems necessary
    to debug or monitor the application, ranging from a simple string to complex structures.
  prefs: []
  type: TYPE_NORMAL
- en: ETW providers have GUIDs that other software can use to identify them. In addition,
    providers have more user-friendly names, most often defined in their manifest,
    that allow humans to identify them more easily. There are around 1,100 providers
    registered in default Windows 10 installations. [Table 8-1](#tab8-1) includes
    those that endpoint security products might find helpful.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Default
    ETW Providers Relevant to Security Monitoring</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Provider name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">GUID</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Antimalware-Scan-Interface</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{2A576B87-09A7-520E-C21A-4942F0271D67}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Supplies details about the data passed
    through the Antimalware Scan Interface (AMSI)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-DotNETRuntime</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides events related to .NET assemblies
    executing on the local host</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Audit-CVE</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{85A62A0D-7E17-485F-9D4F-749A287193A6}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides a mechanism for software to report
    attempts to exploit known vulnerabilities</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-DNS-Client</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{1C95126E-7EEA-49A9-A3FE-A378B03DDB4D}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Details the results of domain name resolution
    on the host</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Kernel-Process</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides information related to the creation
    and termination of processes (similar to what a driver</samp> <samp class="SANS_Futura_Std_Book_11">can
    obtain using a process-cre</samp><samp class="SANS_Futura_Std_Book_11">ation callback
    routine)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-PowerShell</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{A0C1853B-5C40-4B15-8766-3CF1C58F985A}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides PowerShell script block-logging
    functionality</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-RPC</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">{6AD52B32-D609-4BE9-AE07-CE8DAE937E39}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Contains information related to RPC operations
    on the local system</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Security-Kerberos</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{98E6CFCB-EE0A-41E0-A57B-622D4E1B30B1}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides information related to Kerberos
    authentication on the host</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Services</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">{0063715B-EEDA-4007-9429-AD526F62696E}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Emits events related to the installation,
    operation, and removal of services</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-SmartScreen</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{3CB2A168-FE34-4A4E-BDAD-DCF422F34473}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides events related to Microsoft Defender
    SmartScreen and its interaction with files downloaded from the internet</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-TaskScheduler</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{DE7B24EA-73C8-4A09-985D-5BDADCFA9017}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Supplies information related to scheduled
    tasks</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-WebIO</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">{50B3E73C-9370-461D-BB9F-26F32D68887D}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides visibility into web requests
    being made by users of the system</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-WMI-Activity</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{1418EF04-B0B4-4623-BF7E-D74AB47BBDAA}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Supplies telemetry related to the operation
    of WMI, including event subscriptions</samp> |'
  prefs: []
  type: TYPE_TB
- en: ETW providers are securable objects, meaning a security descriptor can be applied
    to them. A *security descriptor* provides a way for Windows to restrict access
    to the object through a discretionary access control list or log access attempts
    via a system access control list. [Listing 8-1](#list8-1) shows the security descriptor
    applied to the Microsoft-Windows-Services provider.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: Evaluating the security descriptor applied to a provider'
  prefs: []
  type: TYPE_NORMAL
- en: This command parses the binary security descriptor from the provider’s registry
    configuration using its GUID. It then uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32
    _SecurityDescriptorHelper</samp> WMI class to convert the byte array in the registry
    to a security descriptor definition language string. This string is then passed
    to the PowerShell cmdlet <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-SddlString</samp>
    to return the human-readable details of the security descriptor. By default, this
    security descriptor only allows access to *NT AUTHORITY\SYSTEM*, *NT AUTHORITY\LOCAL
    SERVICE*, and members of the local Administrators group. This means that controller
    code must be running as admin to directly interact with providers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Emitting Events</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Currently, four main technologies allow developers to emit events from their
    provider applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Managed Object Format (MOF)**'
  prefs: []
  type: TYPE_NORMAL
- en: MOF is the language used to define events so that consumers know how to ingest
    and process them. To register and write events using MOF, providers use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> functions,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows Software Trace Preprocessor (WPP)**'
  prefs: []
  type: TYPE_NORMAL
- en: Like the Windows Event Log, WPP is a system that lets the provider log an event
    ID and event data, initially in binary but later formatted to be human readable.
    WPP supports more complex data types than MOF, including timestamps and GUIDs,
    and acts as a supplement to MOF-based providers. Like MOF-based providers, WPP
    providers use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> functions
    to register and write events. WPP providers can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">WPP_INIT_TRACING</samp>
    macro to register the provider GUID.
  prefs: []
  type: TYPE_NORMAL
- en: '**Manifests**'
  prefs: []
  type: TYPE_NORMAL
- en: Manifests are XML files containing the elements that define the provider, including
    details about the format of events and the provider itself. These manifests are
    embedded in the provider binary at compilation time and registered with the system.
    Providers that use manifests rely on the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp>
    function to register events and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventWrite()</samp>
    to write them. Today, this seems to be the most common way to register providers,
    especially those that ship with Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '**TraceLogging**'
  prefs: []
  type: TYPE_NORMAL
- en: Introduced in Windows 10, TraceLogging is the newest technology for providing
    events. Unlike the other technologies, TraceLogging allows for *self-describing*
    events, meaning that no class or manifest needs to be registered with the system
    for the consumer to know how to process them. The consumer uses the Trace Data
    Helper (TDH) APIs to decode and work with events. These providers use <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingRegister()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingWrite()</samp>
    to register and write events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of which method a developer chooses, the result is the same: events
    being emitted by their application for consumption by other applications.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Locating Event Sources</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To understand why a provider is emitting certain events, it’s often helpful
    to look at the provider itself. Unfortunately, Windows doesn’t provide an easy
    way to translate a provider’s name or GUID into an image on disk. You can sometimes
    collect this information from the event’s metadata, but in many cases, such as
    when the event source is a DLL or a driver, discovering it requires more effort.
    In these situations, try considering the following attributes of ETW providers:'
  prefs: []
  type: TYPE_NORMAL
- en: The provider’s PE file must reference its GUID, most commonly in the *.rdata*
    section, which holds read-only initialized data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provider must be an executable code file, typically a *.exe*, *.dll*, or
    *.sys*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provider must call a registration API (specifically, <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventRegister()</samp>
    for user-mode applications and <samp class="SANS_TheSansMonoCd_W5Regular_11">ntoskrnl!EtwRegister()</samp>
    for kernel-mode components).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If using a manifest registered with the system, the provider image will be in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResourceFileName</samp> value
    in the registry key *HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers\<PROVIDER_GUID>.*
    This file will contain a *WEVT_TEMPLATE* resource, which is the binary representation
    of the manifest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could conduct a scan of files on the operating system and return those that
    satisfy these requirements. The *FindETWProviderImage* open source tool available
    on GitHub makes this process easy. [Listing 8-2](#list8-2) uses it to locate images
    that reference the GUID of the Microsoft-Windows-TaskScheduler provider.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: Using FindETWProviderImage to locate provider binaries'
  prefs: []
  type: TYPE_NORMAL
- en: If you consider the output, you’ll see that this approach has some gaps. For
    example, the tool returned the true provider of the events, *schedsvc.dll*, but
    also three other images. These false positives might occur because images consume
    events from the target provider and so contain the provider’s GUID, or because
    they produce their own events and so import one of the registration APIs. This
    method might also produce false negatives; for example, when the source of an
    event is *ntoskrnl.exe*, the image won’t be found in the registry or import either
    of the registration functions.
  prefs: []
  type: TYPE_NORMAL
- en: To confirm the identity of the provider, you must investigate an image further.
    You can do this using a relatively simple methodology. In a disassembler, navigate
    to the offset or relative virtual address reported by *FindETWProviderImage* and
    look for any references to the GUID coming from a function that calls a registration
    API. You should see the address of the GUID being passed to the registration function
    in the RCX register, as shown in [Listing 8-3](#list8-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: Disassembly of the provider registration function inside schedsvc.dll'
  prefs: []
  type: TYPE_NORMAL
- en: In this disassembly, there are two instructions of interest to us. The first
    is the address of the provider GUID being loaded into RCX ❶. This is immediately
    followed by a call to the imported <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventRegister()</samp>
    function ❷ to register the provider with the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Figuring Out Why an Event
    Was Emitted</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this point, you’ve identified the provider. From here, many detection engineers
    begin looking into what conditions triggered the provider to emit the event. The
    details of this process are outside the scope of this book, as they can differ
    substantially based on the provider, although we’ll cover the topic in greater
    depth in [Chapter 12](chapter12.xhtml). Typically, however, the workflow looks
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: In a disassembler, mark the <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>
    returned from the event registration API, then look for references to this <samp
    class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp> from a function that
    writes ETW events, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ntoskrnl!EtwWrite()</samp>.
    Step through the function, looking for the source of the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp>
    parameter passed to it. Follow execution from this source to the event-writing
    function, checking for conditional branches that would prevent the event from
    being emitted. Repeat these steps for each unique reference to the global <samp
    class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Controllers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Controllers are the components that define and control *trace sessions*, which
    record events written by providers and flush them to the event consumers. The
    controller’s job includes starting and stopping sessions, enabling or disabling
    providers associated with a session, and managing the size of the event buffer
    pool, among other things. A single application might contain both controller and
    consumer code; alternatively, the controller can be a separate application entirely,
    as in the case of Xperf and logman, two utilities that facilitate collecting and
    processing ETW events.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers create trace sessions using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp>
    API and configure them using <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ControlTrace()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EnableTraceEx()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>.
    On Windows XP and later, controllers can start and manage a maximum of 64 simultaneous
    trace sessions. To view these trace sessions, use logman, as shown in [Listing
    8-4](#list8-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-4: Enumerating trace sessions with logman.exe'
  prefs: []
  type: TYPE_NORMAL
- en: Each name under the Data Collector Set column represents a unique controller
    with its own subordinate trace sessions. The controllers shown in [Listing 8-4](#list8-4)
    are built into Windows, as the operating system also makes heavy use of ETW for
    activity monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers can also query existing traces to get information. [Listing 8-5](#list8-5)
    shows this in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-5: Using logman.exe to query a specific trace'
  prefs: []
  type: TYPE_NORMAL
- en: This query provides us with information about the providers enabled in the session
    ❷ and the filtering keywords in use ❸, whether it is a real-time or file-based
    trace ❶, and performance figures. With this information, we can start to understand
    whether the trace is a form of performance monitoring or telemetry collection
    by an EDR.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Consumers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consumers are the software components that receive events after they’ve been
    recorded by a trace session. They can either read events from a logfile on disk
    or consume them in real time. Because nearly every EDR agent is a real-time consumer,
    we’ll focus exclusively on those.
  prefs: []
  type: TYPE_NORMAL
- en: Consumers use <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>
    to connect to the real-time session and <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>
    to start consuming events from it. Each time the consumer receives a new event,
    an internally defined callback function parses the event data based on information
    supplied by the provider, such as the event manifest. The consumer can then choose
    to do whatever it likes with the information. In the case of endpoint security
    software, this may mean creating an alert, taking some preventive actions, or
    correlating the activity with telemetry collected by another sensor.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a Consumer to Identify Malicious
    .NET Assemblies</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s walk through the process of developing a consumer and working with events.
    In this section, we’ll identify the use of malicious in-memory .NET framework
    assemblies, such as those employed by Cobalt Strike’s Beacon <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp>
    functionality. One strategy for identifying these assemblies is to look for class
    names belonging to known offensive C# projects. Although attackers can easily
    defeat this technique by changing the names of their malware’s classes and methods,
    it can be an effective way to identify the use of unmodified tools by less sophisticated
    actors.
  prefs: []
  type: TYPE_NORMAL
- en: Our consumer will ingest filtered events from the Microsoft-Windows-DotNETRuntime
    provider, specifically watching for classes associated with Seatbelt, a post-exploitation
    Windows reconnaissance tool.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Trace
    Session</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To begin consuming events, we must first create a trace session using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp> API. This
    function takes a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES</samp>
    structure, defined in [Listing 8-6](#list8-6). (On systems running versions of
    Windows later than 1703, the function could choose to take a pointer to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES_V2</samp> structure
    instead.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-6: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_PROPERTIES</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: This structure describes the trace session. The consumer will populate it and
    pass it to a function that starts the trace session, as shown in [Listing 8-7](#list8-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-7: Configuring trace properties'
  prefs: []
  type: TYPE_NORMAL
- en: We populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">WNODE_HEADER</samp>
    structure pointed to in the trace properties. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>
    member contains the GUID of the trace session, not of the desired provider. Additionally,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogFileMode</samp> member of
    the trace properties structure is usually set to <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_REAL_TIME_MODE</samp>
    to enable real-time event tracing.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enabling Providers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The trace session isn’t yet collecting events, as no providers have been enabled
    for it. To add providers, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    API. This function takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>
    returned earlier as a parameter and is defined in [Listing 8-8](#list8-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-8: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sechost!EnableTraceEx2()</samp>
    function definition'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ProviderId</samp> parameter
    is the target provider’s GUID, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Level</samp>
    parameter determines the severity of the events passed to the consumer. It can
    range from <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_LEVEL_VERBOSE</samp>
    (*5*) to <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_LEVEL_CRITICAL</samp>
    (*1*). The consumer will receive any events whose level is less than or equal
    to the specified value.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAllKeyword</samp> parameter
    is a bitmask that allows an event to be written only if the event’s keyword bits
    match all the bits set in this value (or if the event has no keyword bits set).
    In most cases, this member is set to zero. The <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAnyKeyword</samp>
    parameter is a bitmask that allows an event to be written only if the event’s
    keyword bits match any of the bits set in this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableParameters</samp> parameter
    allows the consumer to receive one or more extended data items in each event,
    including but not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_PROCESS_START_KEY</samp>   A
    sequence number that identifies the process, guaranteed to be unique to the current
    boot session
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_SID</samp>   The
    security identifier of the principal, such as a user of the system, under which
    the event was emitted
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_TS_ID</samp>   The
    terminal session identifier under which the event was emitted
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_STACK_TRACE</samp>   Value
    that adds a call stack if the event was written using the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventWrite()</samp>
    API
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    API can add any number of providers to a trace session, each with its own filtering
    configurations. [Listing 8-9](#list8-9) continues the code in [Listing 8-7](#list8-7)
    by demonstrating how this API is commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-9: Configuring a provider for the trace session'
  prefs: []
  type: TYPE_NORMAL
- en: We add the Microsoft-Windows-DotNETRuntime provider ❶ to the trace session and
    set <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAnyKeyword</samp> to use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interop</samp> (0x2000), <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NGen</samp> (0x20), <samp class="SANS_TheSansMonoCd_W5Regular_11">Jit</samp>
    (0x10), and <samp class="SANS_TheSansMonoCd_W5Regular_11">Loader</samp> (0x8)
    keywords ❷. These keywords allow us to filter out events that we’re not interested
    in and collect only those relevant to what we’re trying to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Starting the Trace
    Session</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After we’ve completed all of these preparatory steps, we can start the trace
    session. To do so, an EDR agent would call <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>
    with a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_LOGFILE</samp>,
    defined in [Listing 8-10](#list8-10), as its only parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-10: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_LOGFILE</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-11](#list8-11) demonstrates how to use this structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-11: Passing the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_LOGFILE</samp>
    structure to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sechost!OpenTrace()</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: While this is a relatively large structure, only three of the members are immediately
    relevant to us. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LoggerName</samp>
    member is the name of the trace session ❶, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTraceMode</samp>
    is a bitmask containing the values for <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TRACE_MODE_EVENT_RECORD</samp>
    (0x10000000), to indicate that events should use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    format introduced in Windows Vista, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TRACE_MODE_REAL_TIME</samp>
    (0x100), to indicate that events should be received in real time ❷. Lastly, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EventRecordCallback</samp> is a pointer
    to the internal callback function ❸ (covered shortly) that ETW calls for each
    new event, passing it an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>
    completes, it returns a new <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">hSession</samp>, in our example).
    We can then pass this handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>,
    as shown in [Listing 8-12](#list8-12), to start processing events.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-12: Creating the thread to process events'
  prefs: []
  type: TYPE_NORMAL
- en: We pass the current system time ❶ to <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>
    to tell the system that we want to capture events occurring after this time only.
    When called, this function will take control of the current thread, so to avoid
    completely blocking the rest of the application, we create a new thread ❷ just
    for the trace session.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming no errors were returned, events should start flowing from the provider
    to the consumer, where they’ll be processed by the internal callback function
    specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EventRecordCallback</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_LOGFILE</samp>
    structure. We’ll cover this function in “Processing Events” on [page 158](#sec13).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Stopping the Trace
    Session</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we need a way to stop the trace as needed. One way to do this is to
    use a global Boolean value that we can flip when we need the trace to stop, but
    any technique that signals a thread to exit would work. However, if an outside
    user can invoke the method used (in the case of an unchecked RPC function, for
    example), a malicious user might be able to stop the agent from collecting events
    via the trace session altogether. [Listing 8-13](#list8-13) shows how stopping
    the trace might work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-13: Using a console control handler to signal a thread exit'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use an internal console control handler routine, <samp class="SANS_TheSansMonoCd_W5Regular_11">ConsoleCtrlHandler()</samp>,
    and an event object that watches for the CTRL-C keyboard combination ❶. When the
    handler observes this keyboard combination, the internal function notifies the
    *event object* ❷, a synchronization object commonly used to tell a thread that
    some event has occurred, and returns. Because the event object has been signaled,
    the application resumes its execution and closes the trace session ❸.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Processing Events</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the consumer thread receives a new event, its callback function (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OnEvent()</samp> in our example code)
    is invoked with a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    structure. This structure, defined in [Listing 8-14](#list8-14), represents the
    entirety of the event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_RECORD</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: This structure might seem simple at first glance, but it could contain a huge
    amount of information. The first field, <samp class="SANS_TheSansMonoCd_W5Regular_11">EventHeader</samp>,
    holds basic event metadata, such as the process ID of the provider binary; a timestamp;
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DESCRIPTOR</samp>,
    which describes the event itself in detail. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedData</samp>
    member matches the data passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableProperty</samp>
    parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>.
    This field is a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_HEADER_EXTENDED_DATA_ITEM</samp>,
    defined in [Listing 8-15](#list8-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-15: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_HEADER_EXTENDED_DATA_ITEM</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtType</samp> member contains
    an identifier (defined in *eventcons.h* and shown in [Listing 8-16](#list8-16))
    that tells the consumer to which data type the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataPtr</samp>
    member points. Note that a significant number of values defined in the headers
    are not formally supported for the callers of the API in Microsoft’s documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_HEADER_EXT_TYPE</samp>
    constants'
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedData</samp> member
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp> contains
    valuable data, but agents typically use it to supplement other sources, particularly
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> member of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>. This is where
    things get a little tricky, as Microsoft states that, in almost all cases, we
    must retrieve this data using the TDH APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll walk through this process in our callback function, but keep in mind that
    this example represents only one approach to extracting relevant information and
    may not reflect production code. To begin processing the event data, the agent
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventInformation()</samp>,
    as shown in [Listing 8-17](#list8-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-17: Beginning to process event data'
  prefs: []
  type: TYPE_NORMAL
- en: After allocating memory of the required size, we pass a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_EVENT_INFO</samp>
    structure, as the first parameter to the function. [Listing 8-18](#list8-18) defines
    this structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-18: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">TRACE_EVENT_INFO</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: When the function returns, it will populate this structure with useful metadata,
    such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">DecodingSource</samp>
    ❶, used to identify how the event is defined (in an instrumentation manifest,
    MOF class, or WPP template). But the most important value is <samp class="SANS_TheSansMonoCd_W5Regular_11">EventPropertyInfoArray</samp>
    ❷, an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_PROPERTY_INFO</samp>
    structures, defined in [Listing 8-19](#list8-19), that provides information about
    each property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> member.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-19: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_PROPERTY_INFO</samp>
    struct'
  prefs: []
  type: TYPE_NORMAL
- en: We must parse each structure in the array individually. First, it gets the length
    of the property with which it is working. This length is dependent on the way
    in which the event is defined (for example, MOF versus manifest). Generally, we
    derive the size of the property either from the <samp class="SANS_TheSansMonoCd_W5Regular_11">length</samp>
    member ❸, from the size of a known data type (such as the size of an unsigned
    long, or <samp class="SANS_TheSansMonoCd_W5Regular_11">ulong</samp>), or by calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetPropertySize()</samp>.
    If the property itself is an array, we need to retrieve its size by either evaluating
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> member ❷ or calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetPropertySize()</samp>
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to determine whether the data being evaluated is itself a structure.
    Since the caller typically knows the format of the data with which they’re working,
    this isn’t difficult in most cases and generally only becomes relevant when parsing
    events from unfamiliar providers. If an agent does need to work with structures
    inside events, however, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>
    member ❶ will include the <samp class="SANS_TheSansMonoCd_W5Regular_11">PropertyStruct</samp>
    (0x1) flag.
  prefs: []
  type: TYPE_NORMAL
- en: When the data isn’t a structure, as in the case of the Microsoft-Windows-DotNETRuntime
    provider, it will be a simple value mapping, and we can get this map information
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventMapInformation()</samp>.
    This function takes a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_EVENT_INFO</samp>,
    as well as a pointer to the map name offset, which it can access via the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MapNameOffset</samp> member. On completion,
    it receives a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_MAP_INFO</samp>
    structure, defined in [Listing 8-20](#list8-20), which defines the metadata about
    the event map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-20: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_MAP_INFO</samp>
    structure definition'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-21](#list8-21) shows how our callback function uses this structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-21: Parsing the event map information'
  prefs: []
  type: TYPE_NORMAL
- en: To parse the events that the provider emits, we iterate over every top-level
    property in the event by using the total count of properties found in <samp class="SANS_TheSansMonoCd_W5Regular_11">TopLevelPropertyCount</samp>
    for the trace event information structure ❶. Then, if we’re not dealing with a
    structure ❷ and the offset to the name of the member is present ❸, we pass the
    offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventMapInformation()</samp>❹
    to get the event map information.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve collected all the pieces of information required to fully
    parse the event data. Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhFormatProperty()</samp>,
    passing in the information we collected previously. [Listing 8-22](#list8-22)
    shows this function in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-22: Retrieving event data with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tdh!TdhFormatProperty()</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After the function completes, the name of the property (as in the *key* portion
    of the key-value pair) will be stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NameOffset</samp>
    member of the event map information structure (which we’ve stored in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pszPropertyName</samp> variable ❷, for
    brevity). Its value will be stored in the buffer passed into <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhFormatProperty()</samp>
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> parameter ❶
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">pszValue</samp>, in our example).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Consumer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The snippet shown in [Listing 8-23](#list8-23) comes from our .NET event consumer.
    It shows the assembly-load event for the Seatbelt reconnaissance tool being loaded
    into memory via a command-and-control agent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-23: Consumer of the Microsoft-Windows-DotNETRuntime provider detecting
    Seatbelt being loaded'
  prefs: []
  type: TYPE_NORMAL
- en: From here, the agent can use the values as it pleases. If, for instance, the
    agent wanted to terminate any process that loads the Seatbelt assembly, it could
    use this event to trigger that preventive action. To instead act more passively,
    it could take the information collected from this event, supplement it with additional
    information about the originating process, and create its own event to feed into
    detection logic.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading ETW-Based Detections</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve demonstrated, ETW can be an incredibly useful method for collecting
    information from system components that would otherwise be impossible to get.
    The technology isn’t without its limitations, however. Because ETW was built for
    monitoring or debugging and not as a critical security component, its protections
    aren’t as robust as those of other sensor components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2021, Claudiu Teodorescu, Igor Korkin, and Andrey Golchikov of Binarly gave
    a great presentation at Black Hat Europe in which they cataloged existing ETW
    evasion techniques and introduced new ones. Their talk identified 36 unique tactics
    for bypassing ETW providers and trace sessions. The presenters split these techniques
    into five groups: attacks from inside an attacker-controlled process; attacks
    on ETW environment variables, the registry, and files; attacks on user-mode ETW
    providers; attacks on kernel-mode ETW providers; and attacks on ETW sessions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of these techniques overlap in other ways. Moreover, while some work across
    most providers, others target specific providers or trace sessions. Several of
    the techniques are also covered in Palantir’s blog post “Tampering with Windows
    Event Tracing: Background, Offense, and Defense.” To summarize both groups’ findings,
    this section breaks down the evasions into broader categories and discusses the
    pros and cons of each.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Patching</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arguably the most common technique for evading ETW in the offensive world is
    patching critical functions, structures, and other locations in memory that play
    some role in the emission of events. These patches aim to either completely prevent
    the provider from emitting events or selectively filter the events that it sends.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll most commonly see this patching take the form of function hooking, but
    attackers can tamper with numerous other components to alter event flow. For example,
    an attacker could null out the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>
    used by the provider or modify its <samp class="SANS_TheSansMonoCd_W5Regular_11">TraceLevel</samp>
    to prevent certain types of events from being emitted. In the kernel, an attacker
    could also modify structures such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp>,
    the kernel’s representation of an event registration object. We’ll discuss this
    technique in greater detail in “Bypassing a .NET Consumer” on [page 166](#sec20).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Configuration Modification</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another common technique involves modifying persistent attributes of the system,
    including registry keys, files, and environment variables. A vast number of procedures
    fall into this category, but all generally aim to prevent a trace session or provider
    from functioning as expected, typically by abusing something like a registry-based
    “off” switch.
  prefs: []
  type: TYPE_NORMAL
- en: Two examples of “off” switches are the <samp class="SANS_TheSansMonoCd_W5Regular_11">COMPlus_ETWEnabled</samp>
    environment variable and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETWEnabled</samp>
    value under the *HKCU:\Software\Microsoft\.NETFramework* registry key. By setting
    either of these values to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    an adversary can instruct *clr.dll*, the image for the Microsoft-Windows-DotNETRuntime
    provider, not to register any <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>,
    preventing the provider from emitting ETW events.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trace-Session Tampering</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next technique involves interfering with trace sessions already running
    on the system. While this typically requires system-level privileges, an attacker
    who has elevated their access can interact with a trace session of which they
    are not the explicit owner. For example, an adversary may remove a provider from
    a trace session using <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    or, more simply, using logman with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Even more directly, the attacker may opt to stop the trace entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trace-Session Interference</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final technique complements the previous one: it focuses on preventing
    trace sessions, most commonly autologgers, from functioning as expected before
    they are started, resulting in persistent changes to the system.'
  prefs: []
  type: TYPE_NORMAL
- en: One example of this technique is the manual removal of a provider from an autologger
    session through a modification of the registry. By deleting the subkey tied to
    the provider, *HKLM:\SYSTEM\CurrentControlSet\Control\WMI\Autologger\<AUTOLOGGER_NAME>\<PROVIDER_GUID>*,
    or by setting its <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>
    value to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the attacker
    can remove the provider from the trace session after the next reboot.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers could also take advantage of ETW’s mechanisms to prevent sessions
    from working as expected. For example, only one trace session per host can enable
    a legacy provider (as in MOF- or TMF-based WPP). If a new session enabled this
    provider, the original session would no longer receive the desired events. Similarly,
    an adversary could create a trace session with the same name as the target before
    the security product has a chance to start its session. When the agent attempts
    to start its session, it will be met with an <samp class="SANS_TheSansMonoCd_W5Regular_11">ERROR_ALREADY_EXISTS</samp>
    error code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bypassing a .NET Consumer</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s practice evading ETW-based telemetry sources by targeting a .NET runtime
    consumer similar to the one we wrote earlier in this chapter. In his blog post
    “Hiding Your .NET—ETW,” Adam Chester describes how to prevent the common language
    runtime from emitting ETW events, keeping a sensor from identifying the loading
    of SharpHound, a C# tool that collects the data to be fed into the path-mapping
    attacker tool BloodHound.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bypass works by patching the function responsible for emitting the ETW
    event, <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>,
    and instructing it to return immediately upon entry. Chester discovered that this
    function was ultimately responsible for emitting the event by setting a breakpoint
    on this function in WinDbg and watching for calls from *clr.dll*. The syntax for
    setting this conditional breakpoint is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The conditional logic in this command tells WinDbg to parse the call stack (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">k</samp>) and inspect each line of the
    output. If any lines begin with <samp class="SANS_TheSansMonoCd_W5Regular_11">clr!</samp>,
    indicating that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    originated from the common language runtime, a break is triggered. If there are
    no instances of this substring in the call stack, the application simply continues.
  prefs: []
  type: TYPE_NORMAL
- en: If we view the call stack when the substring is detected, shown in [Listing
    8-24](#list8-24), we can observe the common language runtime emitting events.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-24: An abbreviated call stack showing the emission of ETW events
    in the common language runtime'
  prefs: []
  type: TYPE_NORMAL
- en: Reading from bottom to top, we can see that the event originates in <samp class="SANS_TheSansMonoCd_W5Regular_11">System.AppDomain.Load()</samp>,
    the function responsible for loading an assembly into the current application
    domain ❸. A chain of internal calls leads into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW::Loaderlog</samp>
    class ❷, which ultimately calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: While Microsoft doesn’t intend for developers to call this function directly,
    the practice is documented. The function is expected to return a Win32 error code.
    Therefore, if we can manually set the value in the EAX register (which serves
    as the return value on Windows) to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">ERROR_SUCCESS</samp>, the function
    should immediately return, appearing to always complete successfully without emitting
    an event.
  prefs: []
  type: TYPE_NORMAL
- en: Patching this function is a relatively straightforward four-step process. Let’s
    dive into it in [Listing 8-25](#list8-25).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-25: Patching the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!EtwEventWrite()</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: We locate the entry point to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    in the currently loaded copy of *ntdll.dll* using <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!GetProcAddress()</samp>
    ❶. After locating the function, we change the memory protections of the first
    three bytes (the size of our patch) from read-execute (<samp class="SANS_TheSansMonoCd_W5Regular_11">rx</samp>)
    to read-write (<samp class="SANS_TheSansMonoCd_W5Regular_11">rw</samp>) ❷ to allow
    us to overwrite the entry point. Now all we have to do is copy in the patch using
    something like <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy()</samp> ❸
    and then revert the memory protections to their original state ❹. At this point,
    we can execute our assembly loader functionality without worrying about generating
    common language runtime loader events.
  prefs: []
  type: TYPE_NORMAL
- en: We can use WinDbg to validate that <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    will no longer emit events, as shown in [Listing 8-26](#list8-26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-26: The patched <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!EtwEventWrite()</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: When this function is called, it will immediately clear the EAX register by
    setting it to 0 and return. This prevents the logic for producing ETW events from
    ever being reached and effectively stops the provider’s telemetry from flowing
    to the EDR agent.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, this bypass has limitations. Because *clr.dll* and *ntdll.dll* are
    mapped into their own processes, they have the ability to tamper with the provider
    in a very direct manner. In most cases, however, the provider is running as a
    separate process outside the attacker’s immediate control. Patching the event-emission
    function in the mapped *ntdll.dll* won’t prevent the emission of events in another
    process.
  prefs: []
  type: TYPE_NORMAL
- en: In his blog post “Universally Evading Sysmon and ETW,” Dylan Halls describes
    a different technique for preventing ETW events from being emitted that involves
    patching <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtTraceEvent()</samp>,
    the syscall that ultimately leads to the ETW event, in kernel mode. This means
    that any ETW event on the system routed through this syscall won’t be emitted
    while the patch is in place. This technique relies on the use of Kernel Driver
    Utility (KDU) to subvert Driver Signature Enforcement and InfinityHook to mitigate
    the risk of PatchGuard crashing the system if the patch were detected. While this
    technique expands the ability to evade ETW-based detections, it requires a driver
    to be loaded and protected kernel-mode code to be modified, making it subject
    to any mitigations to the techniques leveraged by KDU or InfinityHook.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ETW is one of the most important technologies for collecting host-based telemetry
    on Windows. It provides an EDR with visibility into components and processes,
    such as the Task Scheduler and local DNS client, that no other sensor can monitor.
    An agent can consume events from nearly any providers it finds and use that information
    to gain an immense amount of context about system activities. Evasion of ETW is
    well researched, with most strategies focusing on disabling, unregistering, or
    otherwise rendering a provider or consumer unable to handle events.
  prefs: []
  type: TYPE_NORMAL
