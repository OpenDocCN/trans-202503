- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EVENT
    TRACING FOR WINDOWS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS
    事件追踪</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Using the Event Tracing for Windows (ETW) logging facility, developers can program
    their applications to emit events, consume events from other components, and control
    event-tracing sessions. This allows them to trace the execution of their code
    and monitor or debug potential issues. It may be helpful to think of ETW as an
    alternative to *printf*-based debugging; the messages are emitted over a common
    channel using a standard format rather than printed to the console.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Windows 事件追踪（ETW）日志记录功能，开发人员可以编写应用程序，发出事件、从其他组件接收事件，并控制事件追踪会话。这使得他们能够追踪代码的执行，监控或调试潜在问题。可以将
    ETW 看作是 *printf* 调试的替代方案；这些消息通过一个公共通道，使用标准格式发出，而不是打印到控制台。
- en: In a security context, ETW provides valuable telemetry that wouldn’t otherwise
    be available to an endpoint agent. For example, the common language runtime, which
    is loaded into every .NET process, emits unique events using ETW that can provide
    more insight than any other mechanism into the nature of managed code executing
    on the host. This allows an EDR agent to collect novel data from which to create
    new alerts or enrich existing events.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全环境中，ETW 提供了宝贵的遥测数据，否则终端代理无法获取。例如，通用语言运行时（CLR），它被加载到每个 .NET 进程中，利用 ETW 发出独特的事件，能够比任何其他机制提供更多关于托管代码执行情况的洞察。这使得
    EDR 代理能够收集新的数据，从中创建新的警报或丰富现有事件。
- en: ETW is rarely praised for its simplicity and ease of use, thanks in no small
    part to the tremendously complicated technical documentation that Microsoft provides
    for it. Luckily, while ETW’s inner workings and implementation details are fascinating,
    you don’t need a full understanding of its architecture. This chapter covers the
    parts of ETW that are relevant to those interested in telemetry. We’ll walk through
    how an agent might collect telemetry from ETW and how to evade this collection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ETW 很少因其简单性和易用性而受到赞扬，这在很大程度上归功于微软为其提供的极其复杂的技术文档。幸运的是，尽管 ETW 的内部工作原理和实现细节非常有趣，但你不需要完全理解其架构。本章将介绍
    ETW 中与遥测相关的部分。我们将演示代理如何从 ETW 收集遥测数据，以及如何避免此类收集。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Architecture</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">架构</samp>
- en: 'There are three main components involved in ETW: providers, consumers, and
    controllers. Each of these components serves a distinct purpose in an event-tracing
    session. The following overview describes how each component fits into the larger
    ETW architecture.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ETW 涉及三个主要组件：提供者、消费者和控制器。这些组件在事件追踪会话中各自发挥独特的作用。以下概述了每个组件在 ETW 架构中的作用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Providers</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">提供者</samp>
- en: Simply put, providers are the software components that emit events. These might
    include parts of the system, such as the Task Scheduler, a third-party application,
    or even the kernel itself. Generally, the provider isn’t a separate application
    or image but rather the primary image associated with the component.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，提供者是发出事件的软件组件。这些组件可能包括系统的各个部分，如任务调度程序、第三方应用程序，甚至是内核本身。通常，提供者不是一个单独的应用程序或镜像，而是与该组件关联的主要镜像。
- en: When this provider image follows some interesting or concerning code path, the
    developer can opt to have it emit an event related to its execution. For example,
    if the application handles user authentication, it might emit an event whenever
    authentication fails. These events contain any data the developer deems necessary
    to debug or monitor the application, ranging from a simple string to complex structures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个提供者镜像执行一些有趣或令人担忧的代码路径时，开发人员可以选择让其发出与执行相关的事件。例如，如果应用程序处理用户身份验证，当身份验证失败时，它可能会发出事件。这些事件包含开发人员认为调试或监控应用程序所需的任何数据，从简单的字符串到复杂的结构体。
- en: ETW providers have GUIDs that other software can use to identify them. In addition,
    providers have more user-friendly names, most often defined in their manifest,
    that allow humans to identify them more easily. There are around 1,100 providers
    registered in default Windows 10 installations. [Table 8-1](#tab8-1) includes
    those that endpoint security products might find helpful.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ETW 提供者具有 GUID，其他软件可以使用这些 GUID 来识别它们。此外，提供者还具有更为用户友好的名称，通常在它们的清单中定义，便于人类更轻松地识别它们。在默认的
    Windows 10 安装中，约有 1,100 个注册的提供者。[表 8-1](#tab8-1) 包含了终端安全产品可能会觉得有用的提供者。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Default
    ETW Providers Relevant to Security Monitoring</samp>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-1：</samp> <samp class="SANS_Futura_Std_Book_11">与安全监控相关的默认
    ETW 提供者</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Provider name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">GUID</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">提供者名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">GUID</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Antimalware-Scan-Interface</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{2A576B87-09A7-520E-C21A-4942F0271D67}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Supplies details about the data passed
    through the Antimalware Scan Interface (AMSI)</samp> |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Antimalware-Scan-Interface</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{2A576B87-09A7-520E-C21A-4942F0271D67}</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供有关通过反恶意软件扫描接口（AMSI）传递的数据的详细信息</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-DotNETRuntime</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides events related to .NET assemblies
    executing on the local host</samp> |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-DotNETRuntime</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4}</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供与在本地主机上执行的 .NET 程序集相关的事件</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Audit-CVE</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{85A62A0D-7E17-485F-9D4F-749A287193A6}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides a mechanism for software to report
    attempts to exploit known vulnerabilities</samp> |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Audit-CVE</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{85A62A0D-7E17-485F-9D4F-749A287193A6}</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供一种机制，供软件报告尝试利用已知漏洞的行为</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-DNS-Client</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{1C95126E-7EEA-49A9-A3FE-A378B03DDB4D}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Details the results of domain name resolution
    on the host</samp> |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-DNS-Client</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{1C95126E-7EEA-49A9-A3FE-A378B03DDB4D}</samp>
    | <samp class="SANS_Futura_Std_Book_11">详细说明主机上的域名解析结果</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Kernel-Process</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides information related to the creation
    and termination of processes (similar to what a driver</samp> <samp class="SANS_Futura_Std_Book_11">can
    obtain using a process-cre</samp><samp class="SANS_Futura_Std_Book_11">ation callback
    routine)</samp> |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Kernel-Process</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716}</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供与进程的创建和终止相关的信息（类似于驱动程序可以使用的进程创建回调例程）</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-PowerShell</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{A0C1853B-5C40-4B15-8766-3CF1C58F985A}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides PowerShell script block-logging
    functionality</samp> |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-PowerShell</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{A0C1853B-5C40-4B15-8766-3CF1C58F985A}</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供 PowerShell 脚本块日志记录功能</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-RPC</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">{6AD52B32-D609-4BE9-AE07-CE8DAE937E39}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Contains information related to RPC operations
    on the local system</samp> |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-RPC</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">{6AD52B32-D609-4BE9-AE07-CE8DAE937E39}</samp>
    | <samp class="SANS_Futura_Std_Book_11">包含与本地系统上 RPC 操作相关的信息</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Security-Kerberos</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{98E6CFCB-EE0A-41E0-A57B-622D4E1B30B1}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides information related to Kerberos
    authentication on the host</samp> |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Security-Kerberos</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{98E6CFCB-EE0A-41E0-A57B-622D4E1B30B1}</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供与主机上的 Kerberos 认证相关的信息</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Services</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">{0063715B-EEDA-4007-9429-AD526F62696E}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Emits events related to the installation,
    operation, and removal of services</samp> |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Services</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">{0063715B-EEDA-4007-9429-AD526F62696E}</samp>
    | <samp class="SANS_Futura_Std_Book_11">发出与服务的安装、操作和移除相关的事件</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-SmartScreen</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{3CB2A168-FE34-4A4E-BDAD-DCF422F34473}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides events related to Microsoft Defender
    SmartScreen and its interaction with files downloaded from the internet</samp>
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-SmartScreen</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{3CB2A168-FE34-4A4E-BDAD-DCF422F34473}</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供与 Microsoft Defender SmartScreen 相关的事件，以及其与从互联网下载的文件的交互</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-TaskScheduler</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{DE7B24EA-73C8-4A09-985D-5BDADCFA9017}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Supplies information related to scheduled
    tasks</samp> |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-TaskScheduler</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{DE7B24EA-73C8-4A09-985D-5BDADCFA9017}</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供与计划任务相关的信息</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-WebIO</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">{50B3E73C-9370-461D-BB9F-26F32D68887D}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides visibility into web requests
    being made by users of the system</samp> |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-WebIO</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">{50B3E73C-9370-461D-BB9F-26F32D68887D}</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供对系统用户发起的网页请求的可见性</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-WMI-Activity</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{1418EF04-B0B4-4623-BF7E-D74AB47BBDAA}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Supplies telemetry related to the operation
    of WMI, including event subscriptions</samp> |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-WMI-Activity</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{1418EF04-B0B4-4623-BF7E-D74AB47BBDAA}</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供与 WMI 操作相关的遥测信息，包括事件订阅</samp> |'
- en: ETW providers are securable objects, meaning a security descriptor can be applied
    to them. A *security descriptor* provides a way for Windows to restrict access
    to the object through a discretionary access control list or log access attempts
    via a system access control list. [Listing 8-1](#list8-1) shows the security descriptor
    applied to the Microsoft-Windows-Services provider.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ETW 提供者是可安全控制的对象，这意味着可以应用安全描述符。*安全描述符*为 Windows 提供了一种通过自主访问控制列表限制对该对象的访问，或者通过系统访问控制列表记录访问尝试的方式。[列表
    8-1](#list8-1) 显示了应用于 Microsoft-Windows-Services 提供者的安全描述符。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: Evaluating the security descriptor applied to a provider'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-1：评估应用于提供者的安全描述符
- en: This command parses the binary security descriptor from the provider’s registry
    configuration using its GUID. It then uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32
    _SecurityDescriptorHelper</samp> WMI class to convert the byte array in the registry
    to a security descriptor definition language string. This string is then passed
    to the PowerShell cmdlet <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-SddlString</samp>
    to return the human-readable details of the security descriptor. By default, this
    security descriptor only allows access to *NT AUTHORITY\SYSTEM*, *NT AUTHORITY\LOCAL
    SERVICE*, and members of the local Administrators group. This means that controller
    code must be running as admin to directly interact with providers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令通过提供者的 GUID 解析提供者注册表配置中的二进制安全描述符。然后，它使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32
    _SecurityDescriptorHelper</samp> WMI 类将注册表中的字节数组转换为安全描述符定义语言字符串。该字符串随后传递给 PowerShell
    cmdlet <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-SddlString</samp>，以返回安全描述符的可读详细信息。默认情况下，该安全描述符仅允许
    *NT AUTHORITY\SYSTEM*、*NT AUTHORITY\LOCAL SERVICE* 和本地管理员组成员访问。这意味着控制器代码必须以管理员身份运行，才能直接与提供者交互。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Emitting Events</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">发出事件</samp>
- en: 'Currently, four main technologies allow developers to emit events from their
    provider applications:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，有四种主要技术允许开发人员从其提供者应用程序中发出事件：
- en: '**Managed Object Format (MOF)**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**托管对象格式 (MOF)**'
- en: MOF is the language used to define events so that consumers know how to ingest
    and process them. To register and write events using MOF, providers use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> functions,
    respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MOF 是定义事件的语言，使消费者知道如何接收和处理这些事件。为了使用 MOF 注册和写入事件，提供者分别使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> 函数。
- en: '**Windows Software Trace Preprocessor (WPP)**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 软件跟踪预处理器 (WPP)**'
- en: Like the Windows Event Log, WPP is a system that lets the provider log an event
    ID and event data, initially in binary but later formatted to be human readable.
    WPP supports more complex data types than MOF, including timestamps and GUIDs,
    and acts as a supplement to MOF-based providers. Like MOF-based providers, WPP
    providers use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> functions
    to register and write events. WPP providers can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">WPP_INIT_TRACING</samp>
    macro to register the provider GUID.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Windows 事件日志，WPP 是一种系统，允许提供者记录事件 ID 和事件数据，最初以二进制格式存储，稍后格式化为可供人类阅读的形式。WPP
    支持比 MOF 更复杂的数据类型，包括时间戳和 GUID，并作为 MOF 基于提供者的补充。与基于 MOF 的提供者类似，WPP 提供者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> 函数来注册和写入事件。WPP
    提供者还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WPP_INIT_TRACING</samp>
    宏来注册提供者 GUID。
- en: '**Manifests**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单**'
- en: Manifests are XML files containing the elements that define the provider, including
    details about the format of events and the provider itself. These manifests are
    embedded in the provider binary at compilation time and registered with the system.
    Providers that use manifests rely on the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp>
    function to register events and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventWrite()</samp>
    to write them. Today, this seems to be the most common way to register providers,
    especially those that ship with Windows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 清单是包含定义提供者元素的 XML 文件，其中包括有关事件格式和提供者本身的详细信息。这些清单在编译时嵌入到提供者二进制文件中并注册到系统。使用清单的提供者依赖于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp> 函数来注册事件，并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventWrite()</samp> 函数来写入事件。如今，这似乎是注册提供者的最常见方式，特别是那些随
    Windows 一起发布的提供者。
- en: '**TraceLogging**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**跟踪日志记录 (TraceLogging)**'
- en: Introduced in Windows 10, TraceLogging is the newest technology for providing
    events. Unlike the other technologies, TraceLogging allows for *self-describing*
    events, meaning that no class or manifest needs to be registered with the system
    for the consumer to know how to process them. The consumer uses the Trace Data
    Helper (TDH) APIs to decode and work with events. These providers use <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingRegister()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingWrite()</samp>
    to register and write events.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 10 中引入的 TraceLogging 是提供事件的最新技术。与其他技术不同，TraceLogging 允许*自描述*事件，这意味着消费者无需为事件注册任何类或清单，便能知道如何处理这些事件。消费者使用
    Trace 数据助手（TDH）API 来解码和处理事件。这些提供者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingRegister()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingWrite()</samp>
    来注册和写入事件。
- en: 'Regardless of which method a developer chooses, the result is the same: events
    being emitted by their application for consumption by other applications.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无论开发者选择哪种方法，结果都是一样的：应用程序发出的事件供其他应用程序使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Locating Event Sources</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">定位事件源</samp>
- en: 'To understand why a provider is emitting certain events, it’s often helpful
    to look at the provider itself. Unfortunately, Windows doesn’t provide an easy
    way to translate a provider’s name or GUID into an image on disk. You can sometimes
    collect this information from the event’s metadata, but in many cases, such as
    when the event source is a DLL or a driver, discovering it requires more effort.
    In these situations, try considering the following attributes of ETW providers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么提供者会发出某些事件，通常查看提供者本身会很有帮助。不幸的是，Windows 并没有提供一种简单的方法将提供者的名称或 GUID 转换为磁盘上的映像。有时，你可以从事件的元数据中收集这些信息，但在许多情况下，尤其是当事件源是
    DLL 或驱动程序时，发现它需要更多的努力。在这些情况下，可以考虑以下 ETW 提供者的属性：
- en: The provider’s PE file must reference its GUID, most commonly in the *.rdata*
    section, which holds read-only initialized data.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者的 PE 文件必须引用其 GUID，通常是在 *.rdata* 区段，该区段保存只读初始化数据。
- en: The provider must be an executable code file, typically a *.exe*, *.dll*, or
    *.sys*.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者必须是可执行代码文件，通常是 *.exe*、*.dll* 或 *.sys* 文件。
- en: The provider must call a registration API (specifically, <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventRegister()</samp>
    for user-mode applications and <samp class="SANS_TheSansMonoCd_W5Regular_11">ntoskrnl!EtwRegister()</samp>
    for kernel-mode components).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者必须调用注册 API（具体来说，对于用户模式应用程序是 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventRegister()</samp>，对于内核模式组件是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ntoskrnl!EtwRegister()</samp>）。
- en: If using a manifest registered with the system, the provider image will be in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResourceFileName</samp> value
    in the registry key *HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers\<PROVIDER_GUID>.*
    This file will contain a *WEVT_TEMPLATE* resource, which is the binary representation
    of the manifest.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用系统注册的清单，提供者的映像将位于注册表项 *HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers\<PROVIDER_GUID>*
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ResourceFileName</samp> 值。该文件将包含
    *WEVT_TEMPLATE* 资源，这是清单的二进制表示。
- en: You could conduct a scan of files on the operating system and return those that
    satisfy these requirements. The *FindETWProviderImage* open source tool available
    on GitHub makes this process easy. [Listing 8-2](#list8-2) uses it to locate images
    that reference the GUID of the Microsoft-Windows-TaskScheduler provider.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对操作系统中的文件进行扫描，并返回符合这些要求的文件。GitHub 上的开源工具 *FindETWProviderImage* 可以简化这个过程。[清单
    8-2](#list8-2) 使用它来定位引用 Microsoft-Windows-TaskScheduler 提供者 GUID 的映像。
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 8-2: Using FindETWProviderImage to locate provider binaries'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-2：使用 FindETWProviderImage 定位提供者二进制文件
- en: If you consider the output, you’ll see that this approach has some gaps. For
    example, the tool returned the true provider of the events, *schedsvc.dll*, but
    also three other images. These false positives might occur because images consume
    events from the target provider and so contain the provider’s GUID, or because
    they produce their own events and so import one of the registration APIs. This
    method might also produce false negatives; for example, when the source of an
    event is *ntoskrnl.exe*, the image won’t be found in the registry or import either
    of the registration functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑一下输出，你会发现这种方法存在一些漏洞。例如，工具返回了事件的真实提供者，*schedsvc.dll*，但也返回了另外三个镜像。这些误报可能是因为镜像从目标提供者中消耗了事件，因此包含了提供者的GUID，或者是因为它们产生了自己的事件，因此调用了其中一个注册API。这个方法也可能会产生漏报；例如，当事件的来源是*ntoskrnl.exe*时，镜像在注册表中找不到，或者没有导入任何注册函数。
- en: To confirm the identity of the provider, you must investigate an image further.
    You can do this using a relatively simple methodology. In a disassembler, navigate
    to the offset or relative virtual address reported by *FindETWProviderImage* and
    look for any references to the GUID coming from a function that calls a registration
    API. You should see the address of the GUID being passed to the registration function
    in the RCX register, as shown in [Listing 8-3](#list8-3).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认提供者的身份，你需要进一步调查该镜像。你可以使用一种相对简单的方法。在反汇编器中，导航到*FindETWProviderImage*报告的偏移量或相对虚拟地址，并查找任何来自调用注册API的函数的GUID引用。你应该能够看到GUID的地址被传递到注册函数的RCX寄存器中，如[清单8-3](#list8-3)所示。
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-3: Disassembly of the provider registration function inside schedsvc.dll'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 清单8-3：在schedsvc.dll内部的提供者注册函数的反汇编
- en: In this disassembly, there are two instructions of interest to us. The first
    is the address of the provider GUID being loaded into RCX ❶. This is immediately
    followed by a call to the imported <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventRegister()</samp>
    function ❷ to register the provider with the operating system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段反汇编代码中，有两个指令对我们很重要。第一个是提供者GUID的地址被加载到RCX寄存器中 ❶。紧接着是调用导入的<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventRegister()</samp>函数
    ❷，将提供者注册到操作系统中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Figuring Out Why an Event
    Was Emitted</samp>
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">弄清楚为什么一个事件被触发</samp>
- en: At this point, you’ve identified the provider. From here, many detection engineers
    begin looking into what conditions triggered the provider to emit the event. The
    details of this process are outside the scope of this book, as they can differ
    substantially based on the provider, although we’ll cover the topic in greater
    depth in [Chapter 12](chapter12.xhtml). Typically, however, the workflow looks
    as follows.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经确定了提供者。从这里开始，许多检测工程师会开始调查是什么条件触发了提供者发出事件。这个过程的细节超出了本书的范围，因为它们根据提供者的不同可能会有很大的差异，尽管我们将在[第12章](chapter12.xhtml)中更深入地探讨这个话题。然而，通常来说，工作流程如下所示。
- en: In a disassembler, mark the <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>
    returned from the event registration API, then look for references to this <samp
    class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp> from a function that
    writes ETW events, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ntoskrnl!EtwWrite()</samp>.
    Step through the function, looking for the source of the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp>
    parameter passed to it. Follow execution from this source to the event-writing
    function, checking for conditional branches that would prevent the event from
    being emitted. Repeat these steps for each unique reference to the global <samp
    class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在反汇编器中，标记从事件注册API返回的<samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>，然后查找该<samp
    class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>的引用，来自一个写入ETW事件的函数，例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntoskrnl!EtwWrite()</samp>。逐步执行该函数，查找传递给它的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp>参数的来源。跟踪从这个来源到事件写入函数的执行，检查是否存在任何条件分支会阻止事件的发出。对每一个指向全局<samp
    class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>的独特引用重复这些步骤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Controllers</samp>
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">控制器</samp>
- en: Controllers are the components that define and control *trace sessions*, which
    record events written by providers and flush them to the event consumers. The
    controller’s job includes starting and stopping sessions, enabling or disabling
    providers associated with a session, and managing the size of the event buffer
    pool, among other things. A single application might contain both controller and
    consumer code; alternatively, the controller can be a separate application entirely,
    as in the case of Xperf and logman, two utilities that facilitate collecting and
    processing ETW events.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是定义和控制*跟踪会话*的组件，跟踪会话记录由提供程序写入的事件，并将其刷新到事件消费者。控制器的任务包括启动和停止会话，启用或禁用与会话关联的提供程序，管理事件缓冲池的大小等。单个应用程序可能包含控制器和消费者代码；或者，控制器也可以是一个完全独立的应用程序，例如
    Xperf 和 logman，它们是收集和处理 ETW 事件的两个工具。
- en: Controllers create trace sessions using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp>
    API and configure them using <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ControlTrace()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EnableTraceEx()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>.
    On Windows XP and later, controllers can start and manage a maximum of 64 simultaneous
    trace sessions. To view these trace sessions, use logman, as shown in [Listing
    8-4](#list8-4).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp>
    API 创建跟踪会话，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ControlTrace()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EnableTraceEx()</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    进行配置。在 Windows XP 及以后的版本中，控制器最多可以启动并管理 64 个同时的跟踪会话。要查看这些跟踪会话，可以使用 logman，如 [Listing
    8-4](#list8-4) 所示。
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 8-4: Enumerating trace sessions with logman.exe'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-4：使用 logman.exe 枚举跟踪会话
- en: Each name under the Data Collector Set column represents a unique controller
    with its own subordinate trace sessions. The controllers shown in [Listing 8-4](#list8-4)
    are built into Windows, as the operating system also makes heavy use of ETW for
    activity monitoring.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Data Collector Set 列下的每个名称表示一个独特的控制器，具有自己的下属跟踪会话。 [Listing 8-4](#list8-4) 中显示的控制器是内置于
    Windows 中的，因为操作系统也大量使用 ETW 进行活动监控。
- en: Controllers can also query existing traces to get information. [Listing 8-5](#list8-5)
    shows this in action.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器还可以查询现有的跟踪以获取信息。 [Listing 8-5](#list8-5) 展示了这一过程。
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 8-5: Using logman.exe to query a specific trace'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-5：使用 logman.exe 查询特定的跟踪
- en: This query provides us with information about the providers enabled in the session
    ❷ and the filtering keywords in use ❸, whether it is a real-time or file-based
    trace ❶, and performance figures. With this information, we can start to understand
    whether the trace is a form of performance monitoring or telemetry collection
    by an EDR.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询为我们提供了有关会话中启用的提供程序❷以及使用的过滤关键字❸的信息，是否为实时跟踪或基于文件的跟踪❶，以及性能数据。通过这些信息，我们可以开始理解该跟踪是否为
    EDR 进行的性能监控或遥测收集。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Consumers</samp>
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">消费者</samp>
- en: Consumers are the software components that receive events after they’ve been
    recorded by a trace session. They can either read events from a logfile on disk
    or consume them in real time. Because nearly every EDR agent is a real-time consumer,
    we’ll focus exclusively on those.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者是接收事件的软件组件，这些事件在被跟踪会话记录后送达。它们可以从磁盘上的日志文件中读取事件，也可以实时消费事件。由于几乎每个 EDR 代理都是实时消费者，我们将专注于这类消费者。
- en: Consumers use <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>
    to connect to the real-time session and <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>
    to start consuming events from it. Each time the consumer receives a new event,
    an internally defined callback function parses the event data based on information
    supplied by the provider, such as the event manifest. The consumer can then choose
    to do whatever it likes with the information. In the case of endpoint security
    software, this may mean creating an alert, taking some preventive actions, or
    correlating the activity with telemetry collected by another sensor.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>
    连接到实时会话，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>
    开始从中消费事件。每次消费者收到新事件时，一个内部定义的回调函数根据提供者提供的信息（如事件清单）解析事件数据。消费者然后可以选择对这些信息执行任意操作。在端点安全软件的情况下，这可能意味着创建警报、采取一些预防措施，或将活动与其他传感器收集的遥测数据关联起来。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a Consumer to Identify Malicious
    .NET Assemblies</samp>
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建一个消费者来识别恶意 .NET 程序集</samp>
- en: Let’s walk through the process of developing a consumer and working with events.
    In this section, we’ll identify the use of malicious in-memory .NET framework
    assemblies, such as those employed by Cobalt Strike’s Beacon <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp>
    functionality. One strategy for identifying these assemblies is to look for class
    names belonging to known offensive C# projects. Although attackers can easily
    defeat this technique by changing the names of their malware’s classes and methods,
    it can be an effective way to identify the use of unmodified tools by less sophisticated
    actors.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解开发消费者并处理事件的过程。在本节中，我们将识别恶意内存中的 .NET 框架程序集的使用，例如 Cobalt Strike 的 Beacon
    <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp> 功能使用的那些程序集。识别这些程序集的一种策略是寻找属于已知攻击性
    C# 项目的类名。尽管攻击者可以通过更改恶意软件的类名和方法轻松绕过此技巧，但它仍然是识别不修改工具的较低技术水平攻击者使用工具的一种有效方式。
- en: Our consumer will ingest filtered events from the Microsoft-Windows-DotNETRuntime
    provider, specifically watching for classes associated with Seatbelt, a post-exploitation
    Windows reconnaissance tool.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消费者将从 Microsoft-Windows-DotNETRuntime 提供者中获取过滤后的事件，特别是关注与 Seatbelt 相关的类，Seatbelt
    是一种后期利用的 Windows 侦察工具。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Trace
    Session</samp>
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建追踪会话</samp>
- en: To begin consuming events, we must first create a trace session using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp> API. This
    function takes a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES</samp>
    structure, defined in [Listing 8-6](#list8-6). (On systems running versions of
    Windows later than 1703, the function could choose to take a pointer to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES_V2</samp> structure
    instead.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始消费事件，我们必须首先使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp>
    API 创建一个追踪会话。此函数接受一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES</samp>
    结构体的指针，该结构体在[示例 8-6](#list8-6)中定义。（在运行 Windows 1703 版本之后的系统上，函数可能会选择接受一个指向 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES_V2</samp> 结构体的指针。）
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 8-6: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_PROPERTIES</samp>
    structure definition'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-6：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_PROPERTIES</samp>
    结构体定义
- en: This structure describes the trace session. The consumer will populate it and
    pass it to a function that starts the trace session, as shown in [Listing 8-7](#list8-7).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构体描述了追踪会话。消费者将填充该结构体并将其传递给一个启动追踪会话的函数，如[示例 8-7](#list8-7)所示。
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-7: Configuring trace properties'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-7：配置追踪属性
- en: We populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">WNODE_HEADER</samp>
    structure pointed to in the trace properties. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>
    member contains the GUID of the trace session, not of the desired provider. Additionally,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogFileMode</samp> member of
    the trace properties structure is usually set to <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_REAL_TIME_MODE</samp>
    to enable real-time event tracing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们填充指向跟踪属性中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">WNODE_HEADER</samp>
    结构。请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> 成员包含的是跟踪会话的 GUID，而不是所需提供者的
    GUID。此外，跟踪属性结构中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LogFileMode</samp>
    成员通常设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_REAL_TIME_MODE</samp>，以启用实时事件跟踪。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enabling Providers</samp>
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">启用提供者</samp>
- en: The trace session isn’t yet collecting events, as no providers have been enabled
    for it. To add providers, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    API. This function takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>
    returned earlier as a parameter and is defined in [Listing 8-8](#list8-8).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该跟踪会话尚未开始收集事件，因为没有为其启用任何提供者。为了添加提供者，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    API。此函数将先前返回的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>
    作为参数，并在 [Listing 8-8](#list8-8) 中定义。
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 8-8: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sechost!EnableTraceEx2()</samp>
    function definition'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-8: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sechost!EnableTraceEx2()</samp>
    函数定义'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ProviderId</samp> parameter
    is the target provider’s GUID, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Level</samp>
    parameter determines the severity of the events passed to the consumer. It can
    range from <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_LEVEL_VERBOSE</samp>
    (*5*) to <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_LEVEL_CRITICAL</samp>
    (*1*). The consumer will receive any events whose level is less than or equal
    to the specified value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ProviderId</samp> 参数是目标提供者的 GUID，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Level</samp> 参数决定了传递给消费者的事件的严重性。它的范围可以从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_LEVEL_VERBOSE</samp> (*5*)
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_LEVEL_CRITICAL</samp> (*1*)。消费者将接收所有级别小于或等于指定值的事件。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAllKeyword</samp> parameter
    is a bitmask that allows an event to be written only if the event’s keyword bits
    match all the bits set in this value (or if the event has no keyword bits set).
    In most cases, this member is set to zero. The <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAnyKeyword</samp>
    parameter is a bitmask that allows an event to be written only if the event’s
    keyword bits match any of the bits set in this value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAllKeyword</samp> 参数是一个位掩码，只有当事件的关键字位与该值中设置的所有位匹配时，事件才会被写入（或者如果事件没有设置关键字位）。在大多数情况下，该成员设置为零。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MatchAnyKeyword</samp> 参数是一个位掩码，只有当事件的关键字位与该值中设置的任意位匹配时，事件才会被写入。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableParameters</samp> parameter
    allows the consumer to receive one or more extended data items in each event,
    including but not limited to the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableParameters</samp> 参数允许消费者在每个事件中接收一个或多个扩展数据项，包括但不限于以下内容：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_PROCESS_START_KEY</samp>   A
    sequence number that identifies the process, guaranteed to be unique to the current
    boot session
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_PROCESS_START_KEY</samp>   标识进程的序列号，保证在当前启动会话中唯一
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_SID</samp>   The
    security identifier of the principal, such as a user of the system, under which
    the event was emitted
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_SID</samp>   事件发出时的主体的安全标识符，例如系统的用户
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_TS_ID</samp>   The
    terminal session identifier under which the event was emitted
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_TS_ID</samp>   事件发出时的终端会话标识符
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_STACK_TRACE</samp>   Value
    that adds a call stack if the event was written using the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventWrite()</samp>
    API
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_STACK_TRACE</samp>   如果事件是使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventWrite()</samp> API写入的，则该值会添加调用堆栈。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    API can add any number of providers to a trace session, each with its own filtering
    configurations. [Listing 8-9](#list8-9) continues the code in [Listing 8-7](#list8-7)
    by demonstrating how this API is commonly used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    API 可以将任意数量的提供程序添加到跟踪会话中，每个提供程序都有自己的过滤配置。[列表 8-9](#list8-9) 继续展示了 [列表 8-7](#list8-7)
    中的代码，并演示了此 API 的常见用法。
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-9: Configuring a provider for the trace session'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-9：为跟踪会话配置提供程序
- en: We add the Microsoft-Windows-DotNETRuntime provider ❶ to the trace session and
    set <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAnyKeyword</samp> to use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interop</samp> (0x2000), <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NGen</samp> (0x20), <samp class="SANS_TheSansMonoCd_W5Regular_11">Jit</samp>
    (0x10), and <samp class="SANS_TheSansMonoCd_W5Regular_11">Loader</samp> (0x8)
    keywords ❷. These keywords allow us to filter out events that we’re not interested
    in and collect only those relevant to what we’re trying to monitor.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Microsoft-Windows-DotNETRuntime 提供程序 ❶ 添加到跟踪会话，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAnyKeyword</samp>
    设置为使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Interop</samp> (0x2000)、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NGen</samp> (0x20)、<samp class="SANS_TheSansMonoCd_W5Regular_11">Jit</samp>
    (0x10) 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Loader</samp> (0x8) 关键字
    ❷。这些关键字使我们能够过滤掉不感兴趣的事件，只收集与我们试图监视的内容相关的事件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Starting the Trace
    Session</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">启动跟踪会话</samp>
- en: After we’ve completed all of these preparatory steps, we can start the trace
    session. To do so, an EDR agent would call <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>
    with a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_LOGFILE</samp>,
    defined in [Listing 8-10](#list8-10), as its only parameter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些准备工作后，我们可以启动跟踪会话。为此，EDR 代理会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>，并将指向
    [列表 8-10](#list8-10) 中定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_LOGFILE</samp>
    结构的指针作为唯一参数传递。
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 8-10: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_LOGFILE</samp>
    structure definition'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-10：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_LOGFILE</samp>
    结构定义
- en: '[Listing 8-11](#list8-11) demonstrates how to use this structure.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-11](#list8-11) 演示了如何使用此结构。'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 8-11: Passing the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_LOGFILE</samp>
    structure to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sechost!OpenTrace()</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-11：将 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_LOGFILE</samp>
    结构传递给 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sechost!OpenTrace()</samp>
- en: While this is a relatively large structure, only three of the members are immediately
    relevant to us. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LoggerName</samp>
    member is the name of the trace session ❶, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTraceMode</samp>
    is a bitmask containing the values for <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TRACE_MODE_EVENT_RECORD</samp>
    (0x10000000), to indicate that events should use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    format introduced in Windows Vista, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TRACE_MODE_REAL_TIME</samp>
    (0x100), to indicate that events should be received in real time ❷. Lastly, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EventRecordCallback</samp> is a pointer
    to the internal callback function ❸ (covered shortly) that ETW calls for each
    new event, passing it an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    structure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个相对较大的结构体，但只有三个成员与我们直接相关。<samp class="SANS_TheSansMonoCd_W5Regular_11">LoggerName</samp>
    成员是跟踪会话的名称 ❶，<samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTraceMode</samp>
    是一个位掩码，包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TRACE_MODE_EVENT_RECORD</samp>（0x10000000）的值，表示事件应使用
    Windows Vista 中引入的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    格式，以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TRACE_MODE_REAL_TIME</samp>（0x100），表示事件应实时接收
    ❷。最后，<samp class="SANS_TheSansMonoCd_W5Regular_11">EventRecordCallback</samp>
    是指向内部回调函数的指针 ❸（稍后介绍），ETW 在每个新事件发生时会调用该函数，并将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    结构体传递给它。
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>
    completes, it returns a new <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">hSession</samp>, in our example).
    We can then pass this handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>,
    as shown in [Listing 8-12](#list8-12), to start processing events.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp> 完成时，它返回一个新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>（在我们的示例中是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">hSession</samp>）。然后我们可以将这个句柄传递给 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>，如[列表 8-12](#list8-12)所示，开始处理事件。
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 8-12: Creating the thread to process events'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-12：创建处理事件的线程
- en: We pass the current system time ❶ to <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>
    to tell the system that we want to capture events occurring after this time only.
    When called, this function will take control of the current thread, so to avoid
    completely blocking the rest of the application, we create a new thread ❷ just
    for the trace session.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将当前系统时间 ❶ 传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>，告诉系统我们只想捕获此时间之后发生的事件。当调用此函数时，它将接管当前线程，因此，为了避免完全阻塞应用程序的其他部分，我们为跟踪会话创建一个新的线程
    ❷。
- en: Assuming no errors were returned, events should start flowing from the provider
    to the consumer, where they’ll be processed by the internal callback function
    specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EventRecordCallback</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_LOGFILE</samp>
    structure. We’ll cover this function in “Processing Events” on [page 158](#sec13).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设没有返回错误，事件应该开始从提供者流向消费者，并在 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_LOGFILE</samp>
    结构体的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EventRecordCallback</samp>
    成员指定的内部回调函数中进行处理。我们将在“处理事件”一节中讲解这个函数，见[第158页](#sec13)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Stopping the Trace
    Session</samp>
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">停止跟踪会话</samp>
- en: Finally, we need a way to stop the trace as needed. One way to do this is to
    use a global Boolean value that we can flip when we need the trace to stop, but
    any technique that signals a thread to exit would work. However, if an outside
    user can invoke the method used (in the case of an unchecked RPC function, for
    example), a malicious user might be able to stop the agent from collecting events
    via the trace session altogether. [Listing 8-13](#list8-13) shows how stopping
    the trace might work.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一种方式来在需要时停止跟踪。一个方法是使用全局布尔值，当需要停止跟踪时，我们可以改变这个值，但任何可以通知线程退出的技术都可以使用。不过，如果外部用户能够调用此方法（例如在未检查的
    RPC 函数的情况下），恶意用户可能会通过跟踪会话完全停止代理收集事件。[列表 8-13](#list8-13)展示了停止跟踪的可能方式。
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 8-13: Using a console control handler to signal a thread exit'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-13：使用控制台控制处理程序来信号线程退出
- en: In this example, we use an internal console control handler routine, <samp class="SANS_TheSansMonoCd_W5Regular_11">ConsoleCtrlHandler()</samp>,
    and an event object that watches for the CTRL-C keyboard combination ❶. When the
    handler observes this keyboard combination, the internal function notifies the
    *event object* ❷, a synchronization object commonly used to tell a thread that
    some event has occurred, and returns. Because the event object has been signaled,
    the application resumes its execution and closes the trace session ❸.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用一个内部控制台控制处理程序例程 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConsoleCtrlHandler()</samp>，并且使用一个事件对象来监视
    CTRL-C 键盘组合 ❶。当处理程序检测到此键盘组合时，内部函数会通知 *事件对象* ❷，这是一种常用于通知线程某些事件已经发生的同步对象，然后返回。由于事件对象已经被信号通知，应用程序恢复执行并关闭跟踪会话
    ❸。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Processing Events</samp>
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">处理事件</samp>
- en: When the consumer thread receives a new event, its callback function (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OnEvent()</samp> in our example code)
    is invoked with a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    structure. This structure, defined in [Listing 8-14](#list8-14), represents the
    entirety of the event.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当消费者线程接收到一个新事件时，它的回调函数（在我们的示例代码中为 <samp class="SANS_TheSansMonoCd_W5Regular_11">OnEvent()</samp>）会被调用，并传递一个指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp> 结构的指针。这个结构在[列表
    8-14](#list8-14)中定义，表示整个事件。
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 8-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_RECORD</samp>
    structure definition'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 8-14: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_RECORD</samp>
    结构定义'
- en: This structure might seem simple at first glance, but it could contain a huge
    amount of information. The first field, <samp class="SANS_TheSansMonoCd_W5Regular_11">EventHeader</samp>,
    holds basic event metadata, such as the process ID of the provider binary; a timestamp;
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DESCRIPTOR</samp>,
    which describes the event itself in detail. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedData</samp>
    member matches the data passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableProperty</samp>
    parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>.
    This field is a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_HEADER_EXTENDED_DATA_ITEM</samp>,
    defined in [Listing 8-15](#list8-15).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构乍看之下可能很简单，但它可能包含大量信息。第一个字段 <samp class="SANS_TheSansMonoCd_W5Regular_11">EventHeader</samp>
    包含基本的事件元数据，例如提供者二进制文件的进程 ID、时间戳，以及一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DESCRIPTOR</samp>，它详细描述了事件本身。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ExtendedData</samp> 成员与传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableProperty</samp> 参数的数据匹配。该字段是指向一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_HEADER_EXTENDED_DATA_ITEM</samp>
    的指针，在[列表 8-15](#list8-15)中定义。
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 8-15: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_HEADER_EXTENDED_DATA_ITEM</samp>
    structure definition'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 8-15: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_HEADER_EXTENDED_DATA_ITEM</samp>
    结构定义'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtType</samp> member contains
    an identifier (defined in *eventcons.h* and shown in [Listing 8-16](#list8-16))
    that tells the consumer to which data type the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataPtr</samp>
    member points. Note that a significant number of values defined in the headers
    are not formally supported for the callers of the API in Microsoft’s documentation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtType</samp> 成员包含一个标识符（在 *eventcons.h*
    中定义，并在[列表 8-16](#list8-16)中显示），它告诉消费者 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataPtr</samp>
    成员指向的数据类型。请注意，许多在头文件中定义的值在微软文档中并没有正式支持作为 API 调用者使用。
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 8-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_HEADER_EXT_TYPE</samp>
    constants'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 8-16: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_HEADER_EXT_TYPE</samp>
    常量'
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedData</samp> member
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp> contains
    valuable data, but agents typically use it to supplement other sources, particularly
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> member of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>. This is where
    things get a little tricky, as Microsoft states that, in almost all cases, we
    must retrieve this data using the TDH APIs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedData</samp>
    成员包含有价值的数据，但代理通常会用它来补充其他来源，特别是 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> 成员。这部分比较复杂，因为微软表示，几乎在所有情况下，我们必须通过
    TDH API 来检索这些数据。
- en: We’ll walk through this process in our callback function, but keep in mind that
    this example represents only one approach to extracting relevant information and
    may not reflect production code. To begin processing the event data, the agent
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventInformation()</samp>,
    as shown in [Listing 8-17](#list8-17).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在回调函数中逐步完成这个过程，但请记住，这个例子只是提取相关信息的一种方法，可能并不代表生产代码。为了开始处理事件数据，代理调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventInformation()</samp>，如[列表
    8-17](#list8-17)所示。
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 8-17: Beginning to process event data'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-17：开始处理事件数据
- en: After allocating memory of the required size, we pass a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_EVENT_INFO</samp>
    structure, as the first parameter to the function. [Listing 8-18](#list8-18) defines
    this structure.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配了所需大小的内存后，我们将指针传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_EVENT_INFO</samp>
    结构体，作为函数的第一个参数。[列表 8-18](#list8-18) 定义了这个结构体。
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 8-18: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">TRACE_EVENT_INFO</samp>
    structure definition'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-18：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">TRACE_EVENT_INFO</samp>
    结构体定义
- en: When the function returns, it will populate this structure with useful metadata,
    such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">DecodingSource</samp>
    ❶, used to identify how the event is defined (in an instrumentation manifest,
    MOF class, or WPP template). But the most important value is <samp class="SANS_TheSansMonoCd_W5Regular_11">EventPropertyInfoArray</samp>
    ❷, an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_PROPERTY_INFO</samp>
    structures, defined in [Listing 8-19](#list8-19), that provides information about
    each property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> member.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数返回时，它将用有用的元数据填充此结构体，例如用于标识事件定义方式（在仪表清单、MOF 类或 WPP 模板中）的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DecodingSource</samp>
    ❶。但最重要的值是 <samp class="SANS_TheSansMonoCd_W5Regular_11">EventPropertyInfoArray</samp>
    ❷，这是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_PROPERTY_INFO</samp>
    结构体数组，在[列表 8-19](#list8-19)中定义，提供有关 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> 成员每个属性的信息。
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 8-19: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_PROPERTY_INFO</samp>
    struct'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-19：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_PROPERTY_INFO</samp>
    结构体
- en: We must parse each structure in the array individually. First, it gets the length
    of the property with which it is working. This length is dependent on the way
    in which the event is defined (for example, MOF versus manifest). Generally, we
    derive the size of the property either from the <samp class="SANS_TheSansMonoCd_W5Regular_11">length</samp>
    member ❸, from the size of a known data type (such as the size of an unsigned
    long, or <samp class="SANS_TheSansMonoCd_W5Regular_11">ulong</samp>), or by calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetPropertySize()</samp>.
    If the property itself is an array, we need to retrieve its size by either evaluating
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> member ❷ or calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetPropertySize()</samp>
    again.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须逐一解析数组中的每个结构体。首先，它获取所操作属性的长度。这个长度依赖于事件的定义方式（例如，MOF 或清单）。通常，我们通过以下方式来推导属性的大小：从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">length</samp> 成员 ❸，从已知数据类型的大小（例如无符号长整型或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ulong</samp>），或通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetPropertySize()</samp>。如果属性本身是一个数组，我们需要通过评估
    <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> 成员 ❷ 或再次调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetPropertySize()</samp>
    来获取它的大小。
- en: Next, we need to determine whether the data being evaluated is itself a structure.
    Since the caller typically knows the format of the data with which they’re working,
    this isn’t difficult in most cases and generally only becomes relevant when parsing
    events from unfamiliar providers. If an agent does need to work with structures
    inside events, however, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>
    member ❶ will include the <samp class="SANS_TheSansMonoCd_W5Regular_11">PropertyStruct</samp>
    (0x1) flag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定正在评估的数据是否本身是一个结构。由于调用者通常知道他们正在处理的数据格式，在大多数情况下这并不困难，通常只有在解析来自不熟悉提供者的事件时才变得重要。然而，如果代理确实需要处理事件中的结构，则
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> 成员❶将包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">PropertyStruct</samp>
    (0x1) 标志。
- en: When the data isn’t a structure, as in the case of the Microsoft-Windows-DotNETRuntime
    provider, it will be a simple value mapping, and we can get this map information
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventMapInformation()</samp>.
    This function takes a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_EVENT_INFO</samp>,
    as well as a pointer to the map name offset, which it can access via the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MapNameOffset</samp> member. On completion,
    it receives a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_MAP_INFO</samp>
    structure, defined in [Listing 8-20](#list8-20), which defines the metadata about
    the event map.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据不是结构时，例如在 Microsoft-Windows-DotNETRuntime 提供者的情况下，它将是一个简单的值映射，我们可以使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventMapInformation()</samp>
    获取这个映射信息。此函数接受指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_EVENT_INFO</samp>
    的指针，以及指向映射名称偏移量的指针，它可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">MapNameOffset</samp>
    成员进行访问。完成后，它返回指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_MAP_INFO</samp>
    结构的指针，该结构在 [列表 8-20](#list8-20) 中定义，描述了事件映射的元数据。
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 8-20: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_MAP_INFO</samp>
    structure definition'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 8-20: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_MAP_INFO</samp>
    结构定义'
- en: '[Listing 8-21](#list8-21) shows how our callback function uses this structure.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-21](#list8-21) 显示了我们的回调函数如何使用这个结构。'
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 8-21: Parsing the event map information'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 8-21: 解析事件映射信息'
- en: To parse the events that the provider emits, we iterate over every top-level
    property in the event by using the total count of properties found in <samp class="SANS_TheSansMonoCd_W5Regular_11">TopLevelPropertyCount</samp>
    for the trace event information structure ❶. Then, if we’re not dealing with a
    structure ❷ and the offset to the name of the member is present ❸, we pass the
    offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventMapInformation()</samp>❹
    to get the event map information.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析提供者发出的事件，我们通过使用在跟踪事件信息结构中找到的属性总数 <samp class="SANS_TheSansMonoCd_W5Regular_11">TopLevelPropertyCount</samp>，遍历事件中的每个顶级属性❶。然后，如果我们不是在处理结构❷，并且成员名称的偏移量存在❸，我们将偏移量传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventMapInformation()</samp>❹，以获取事件映射信息。
- en: At this point, we’ve collected all the pieces of information required to fully
    parse the event data. Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhFormatProperty()</samp>,
    passing in the information we collected previously. [Listing 8-22](#list8-22)
    shows this function in action.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经收集了完全解析事件数据所需的所有信息。接下来，我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhFormatProperty()</samp>，并传入我们之前收集的信息。[列表
    8-22](#list8-22) 显示了该函数的实际应用。
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 8-22: Retrieving event data with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tdh!TdhFormatProperty()</samp>'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 8-22: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tdh!TdhFormatProperty()</samp>
    检索事件数据'
- en: After the function completes, the name of the property (as in the *key* portion
    of the key-value pair) will be stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NameOffset</samp>
    member of the event map information structure (which we’ve stored in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pszPropertyName</samp> variable ❷, for
    brevity). Its value will be stored in the buffer passed into <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhFormatProperty()</samp>
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> parameter ❶
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">pszValue</samp>, in our example).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 函数完成后，属性的名称（如键值对中的 *key* 部分）将存储在事件映射信息结构的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NameOffset</samp>
    成员中（我们已将其存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">pszPropertyName</samp>
    变量中 ❷，为了简洁起见）。其值将存储在传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhFormatProperty()</samp>
    的缓冲区中，作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 参数 ❶（在我们的示例中是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pszValue</samp>）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Consumer</samp>
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">测试消费者</samp>
- en: The snippet shown in [Listing 8-23](#list8-23) comes from our .NET event consumer.
    It shows the assembly-load event for the Seatbelt reconnaissance tool being loaded
    into memory via a command-and-control agent.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-23](#list8-23) 中展示的代码来自我们的 .NET 事件消费者。它显示了 Seatbelt 侦察工具通过命令与控制代理加载到内存中的程序集加载事件。'
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 8-23: Consumer of the Microsoft-Windows-DotNETRuntime provider detecting
    Seatbelt being loaded'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-23：Microsoft-Windows-DotNETRuntime 提供者的消费者检测到 Seatbelt 被加载
- en: From here, the agent can use the values as it pleases. If, for instance, the
    agent wanted to terminate any process that loads the Seatbelt assembly, it could
    use this event to trigger that preventive action. To instead act more passively,
    it could take the information collected from this event, supplement it with additional
    information about the originating process, and create its own event to feed into
    detection logic.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，代理可以根据需要使用这些值。例如，如果代理想要终止加载 Seatbelt 程序集的任何进程，它可以利用这个事件来触发预防性操作。或者，如果想采取更为被动的措施，它可以将从这个事件收集到的信息，结合关于源进程的其他信息，创建自己的事件并将其输入到检测逻辑中。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading ETW-Based Detections</samp>
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避基于 ETW 的检测</samp>
- en: As we’ve demonstrated, ETW can be an incredibly useful method for collecting
    information from system components that would otherwise be impossible to get.
    The technology isn’t without its limitations, however. Because ETW was built for
    monitoring or debugging and not as a critical security component, its protections
    aren’t as robust as those of other sensor components.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所示，ETW 是从系统组件收集信息的一种非常有用的方法，否则这些信息是无法获取的。然而，这项技术也有其局限性。由于 ETW 是为监控或调试而设计的，而不是作为关键的安全组件，因此其保护机制不如其他传感器组件那样强大。
- en: 'In 2021, Claudiu Teodorescu, Igor Korkin, and Andrey Golchikov of Binarly gave
    a great presentation at Black Hat Europe in which they cataloged existing ETW
    evasion techniques and introduced new ones. Their talk identified 36 unique tactics
    for bypassing ETW providers and trace sessions. The presenters split these techniques
    into five groups: attacks from inside an attacker-controlled process; attacks
    on ETW environment variables, the registry, and files; attacks on user-mode ETW
    providers; attacks on kernel-mode ETW providers; and attacks on ETW sessions.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2021 年，Claudiu Teodorescu、Igor Korkin 和 Andrey Golchikov（来自 Binarly）在 Black
    Hat Europe 上进行了精彩的演讲，他们对现有的 ETW 规避技术进行了分类，并介绍了新的技术。他们的演讲确定了 36 种绕过 ETW 提供者和跟踪会话的独特策略。演讲者将这些技术分为五大类：来自攻击者控制的进程的攻击；对
    ETW 环境变量、注册表和文件的攻击；对用户模式 ETW 提供者的攻击；对内核模式 ETW 提供者的攻击；以及对 ETW 会话的攻击。
- en: 'Many of these techniques overlap in other ways. Moreover, while some work across
    most providers, others target specific providers or trace sessions. Several of
    the techniques are also covered in Palantir’s blog post “Tampering with Windows
    Event Tracing: Background, Offense, and Defense.” To summarize both groups’ findings,
    this section breaks down the evasions into broader categories and discusses the
    pros and cons of each.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术在其他方面也有所重叠。此外，尽管一些技术适用于大多数提供者，另一些则针对特定提供者或跟踪会话。几种技术也在 Palantir 的博客文章《篡改
    Windows 事件跟踪：背景、攻击与防御》中进行了讨论。为了总结这两组的发现，本节将这些规避技术分为更广泛的类别，并讨论每种方法的优缺点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Patching</samp>
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">修补</samp>
- en: Arguably the most common technique for evading ETW in the offensive world is
    patching critical functions, structures, and other locations in memory that play
    some role in the emission of events. These patches aim to either completely prevent
    the provider from emitting events or selectively filter the events that it sends.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，在攻击领域中，绕过ETW的最常见技术是修补关键功能、结构和其他内存中与事件发射相关的地方。这些修补程序的目的是完全阻止提供者发射事件，或有选择地过滤它发送的事件。
- en: You’ll most commonly see this patching take the form of function hooking, but
    attackers can tamper with numerous other components to alter event flow. For example,
    an attacker could null out the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>
    used by the provider or modify its <samp class="SANS_TheSansMonoCd_W5Regular_11">TraceLevel</samp>
    to prevent certain types of events from being emitted. In the kernel, an attacker
    could also modify structures such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp>,
    the kernel’s representation of an event registration object. We’ll discuss this
    technique in greater detail in “Bypassing a .NET Consumer” on [page 166](#sec20).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你最常见到的这种修补方式是函数钩取，但攻击者也可以篡改许多其他组件来改变事件流。例如，攻击者可以将提供者使用的<samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>置为无效，或者修改其<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TraceLevel</samp>，以防止某些类型的事件被发射。在内核中，攻击者还可以修改如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp>这样的结构，这是内核中表示事件注册对象的方式。我们将在“绕过.NET消费者”一节中更详细地讨论这一技术，见[第166页](#sec20)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Configuration Modification</samp>
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">配置修改</samp>
- en: Another common technique involves modifying persistent attributes of the system,
    including registry keys, files, and environment variables. A vast number of procedures
    fall into this category, but all generally aim to prevent a trace session or provider
    from functioning as expected, typically by abusing something like a registry-based
    “off” switch.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的技术涉及修改系统的持久属性，包括注册表键、文件和环境变量。许多程序都属于这一类，但它们的共同目标通常是通过滥用类似注册表中的“关闭”开关来防止跟踪会话或提供者按预期功能工作。
- en: Two examples of “off” switches are the <samp class="SANS_TheSansMonoCd_W5Regular_11">COMPlus_ETWEnabled</samp>
    environment variable and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETWEnabled</samp>
    value under the *HKCU:\Software\Microsoft\.NETFramework* registry key. By setting
    either of these values to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    an adversary can instruct *clr.dll*, the image for the Microsoft-Windows-DotNETRuntime
    provider, not to register any <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>,
    preventing the provider from emitting ETW events.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: “关闭”开关的两个例子是<samp class="SANS_TheSansMonoCd_W5Regular_11">COMPlus_ETWEnabled</samp>环境变量和*HKCU:\Software\Microsoft\.NETFramework*注册表键下的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ETWEnabled</samp>值。通过将这两个值中的任何一个设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，攻击者可以指示*clr.dll*，即Microsoft-Windows-DotNETRuntime提供者的镜像，不注册任何<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>，从而防止该提供者发射ETW事件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trace-Session Tampering</samp>
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">跟踪会话篡改</samp>
- en: 'The next technique involves interfering with trace sessions already running
    on the system. While this typically requires system-level privileges, an attacker
    who has elevated their access can interact with a trace session of which they
    are not the explicit owner. For example, an adversary may remove a provider from
    a trace session using <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    or, more simply, using logman with the following syntax:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技术涉及干扰系统上已经运行的跟踪会话。虽然这通常需要系统级的权限，但已经提升权限的攻击者可以与他们不是显式拥有者的跟踪会话进行交互。例如，攻击者可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>，或者更简单地使用logman和以下语法，来从跟踪会话中移除提供者：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Even more directly, the attacker may opt to stop the trace entirely:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更直接地说，攻击者可能选择完全停止跟踪：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trace-Session Interference</samp>
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">跟踪会话干扰</samp>
- en: 'The final technique complements the previous one: it focuses on preventing
    trace sessions, most commonly autologgers, from functioning as expected before
    they are started, resulting in persistent changes to the system.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个技巧是对前一个技巧的补充：它侧重于在跟踪会话开始之前，防止自动记录器等跟踪会话按预期工作，从而对系统进行持久性更改。
- en: One example of this technique is the manual removal of a provider from an autologger
    session through a modification of the registry. By deleting the subkey tied to
    the provider, *HKLM:\SYSTEM\CurrentControlSet\Control\WMI\Autologger\<AUTOLOGGER_NAME>\<PROVIDER_GUID>*,
    or by setting its <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>
    value to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the attacker
    can remove the provider from the trace session after the next reboot.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的一个例子是通过修改注册表手动从自动记录器会话中移除提供者。通过删除与提供者相关的子项 *HKLM:\SYSTEM\CurrentControlSet\Control\WMI\Autologger\<AUTOLOGGER_NAME>\<PROVIDER_GUID>*，或者将其
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp> 值设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，攻击者可以在下一次重启后从跟踪会话中移除提供者。
- en: Attackers could also take advantage of ETW’s mechanisms to prevent sessions
    from working as expected. For example, only one trace session per host can enable
    a legacy provider (as in MOF- or TMF-based WPP). If a new session enabled this
    provider, the original session would no longer receive the desired events. Similarly,
    an adversary could create a trace session with the same name as the target before
    the security product has a chance to start its session. When the agent attempts
    to start its session, it will be met with an <samp class="SANS_TheSansMonoCd_W5Regular_11">ERROR_ALREADY_EXISTS</samp>
    error code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者还可以利用 ETW 的机制来阻止会话按预期工作。例如，每个主机每次只能启用一个遗留提供者（如 MOF 或 TMF 基于 WPP）。如果新会话启用了该提供者，原始会话将不再接收到所需的事件。同样，攻击者可以在安全产品有机会启动会话之前，创建一个与目标同名的跟踪会话。当代理尝试启动其会话时，它将遇到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ERROR_ALREADY_EXISTS</samp> 错误代码。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bypassing a .NET Consumer</samp>
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">绕过 .NET 消费者</samp>
- en: Let’s practice evading ETW-based telemetry sources by targeting a .NET runtime
    consumer similar to the one we wrote earlier in this chapter. In his blog post
    “Hiding Your .NET—ETW,” Adam Chester describes how to prevent the common language
    runtime from emitting ETW events, keeping a sensor from identifying the loading
    of SharpHound, a C# tool that collects the data to be fed into the path-mapping
    attacker tool BloodHound.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过瞄准一个类似本章早些时候编写的 .NET 运行时消费者来练习规避基于 ETW 的遥测源。在他的博客文章《隐藏你的 .NET—ETW》中，Adam
    Chester 介绍了如何阻止公共语言运行时发出 ETW 事件，从而使传感器无法识别 SharpHound 的加载。SharpHound 是一个 C# 工具，用于收集将输入到路径映射攻击工具
    BloodHound 中的数据。
- en: 'The bypass works by patching the function responsible for emitting the ETW
    event, <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>,
    and instructing it to return immediately upon entry. Chester discovered that this
    function was ultimately responsible for emitting the event by setting a breakpoint
    on this function in WinDbg and watching for calls from *clr.dll*. The syntax for
    setting this conditional breakpoint is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过技术通过修补负责发出 ETW 事件的函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    来实现，并指示该函数在进入时立即返回。Chester 发现，通过在 WinDbg 中设置断点并观察来自 *clr.dll* 的调用，最终发现该函数负责发出该事件。设置此条件断点的语法如下：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The conditional logic in this command tells WinDbg to parse the call stack (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">k</samp>) and inspect each line of the
    output. If any lines begin with <samp class="SANS_TheSansMonoCd_W5Regular_11">clr!</samp>,
    indicating that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    originated from the common language runtime, a break is triggered. If there are
    no instances of this substring in the call stack, the application simply continues.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令中的条件逻辑指示 WinDbg 解析调用堆栈（<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>）并检查每一行输出。如果某些行以
    <samp class="SANS_TheSansMonoCd_W5Regular_11">clr!</samp> 开头，表示对 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    的调用来源于公共语言运行时，则触发断点。如果调用堆栈中没有这个子字符串的实例，应用程序将继续执行。
- en: If we view the call stack when the substring is detected, shown in [Listing
    8-24](#list8-24), we can observe the common language runtime emitting events.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看检测到子字符串时的调用堆栈，如 [Listing 8-24](#list8-24) 所示，我们可以观察到公共语言运行时发出了事件。
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 8-24: An abbreviated call stack showing the emission of ETW events
    in the common language runtime'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-24：一个简略的调用堆栈，显示在公共语言运行时中生成 ETW 事件
- en: Reading from bottom to top, we can see that the event originates in <samp class="SANS_TheSansMonoCd_W5Regular_11">System.AppDomain.Load()</samp>,
    the function responsible for loading an assembly into the current application
    domain ❸. A chain of internal calls leads into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW::Loaderlog</samp>
    class ❷, which ultimately calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    ❶.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从下往上阅读，我们可以看到事件源自 <samp class="SANS_TheSansMonoCd_W5Regular_11">System.AppDomain.Load()</samp>，这是负责将程序集加载到当前应用程序域中的函数
    ❸。一连串内部调用最终进入 <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW::Loaderlog</samp>
    类 ❷，该类最终调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    ❶。
- en: While Microsoft doesn’t intend for developers to call this function directly,
    the practice is documented. The function is expected to return a Win32 error code.
    Therefore, if we can manually set the value in the EAX register (which serves
    as the return value on Windows) to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">ERROR_SUCCESS</samp>, the function
    should immediately return, appearing to always complete successfully without emitting
    an event.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微软并不希望开发人员直接调用此函数，但该实践是有文档记录的。此函数预计会返回一个 Win32 错误代码。因此，如果我们可以手动将 EAX 寄存器中的值（它作为
    Windows 上的返回值）设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>（表示 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ERROR_SUCCESS</samp>），函数应该会立即返回，表现得总是成功完成，而不会生成事件。
- en: Patching this function is a relatively straightforward four-step process. Let’s
    dive into it in [Listing 8-25](#list8-25).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 修补此函数是一个相对简单的四步过程。我们在 [Listing 8-25](#list8-25) 中深入了解这一过程。
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 8-25: Patching the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!EtwEventWrite()</samp>
    function'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-25：修补 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!EtwEventWrite()</samp>
    函数
- en: We locate the entry point to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    in the currently loaded copy of *ntdll.dll* using <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!GetProcAddress()</samp>
    ❶. After locating the function, we change the memory protections of the first
    three bytes (the size of our patch) from read-execute (<samp class="SANS_TheSansMonoCd_W5Regular_11">rx</samp>)
    to read-write (<samp class="SANS_TheSansMonoCd_W5Regular_11">rw</samp>) ❷ to allow
    us to overwrite the entry point. Now all we have to do is copy in the patch using
    something like <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy()</samp> ❸
    and then revert the memory protections to their original state ❹. At this point,
    we can execute our assembly loader functionality without worrying about generating
    common language runtime loader events.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!GetProcAddress()</samp>
    ❶ 在当前加载的 *ntdll.dll* 中定位 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    的入口点。定位到函数后，我们将前 3 个字节（即我们的补丁大小）的内存保护从只读执行（<samp class="SANS_TheSansMonoCd_W5Regular_11">rx</samp>）更改为读写（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">rw</samp>） ❷，以便我们能够覆盖入口点。现在，我们只需要使用像 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy()</samp> ❸ 之类的函数复制补丁，然后将内存保护恢复到原始状态
    ❹。此时，我们可以执行我们的汇编加载器功能，而不必担心生成公共语言运行时加载器事件。
- en: We can use WinDbg to validate that <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    will no longer emit events, as shown in [Listing 8-26](#list8-26).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 WinDbg 来验证 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    不再生成事件，如 [Listing 8-26](#list8-26) 所示。
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 8-26: The patched <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!EtwEventWrite()</samp>
    function'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-26：修补后的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!EtwEventWrite()</samp>
    函数
- en: When this function is called, it will immediately clear the EAX register by
    setting it to 0 and return. This prevents the logic for producing ETW events from
    ever being reached and effectively stops the provider’s telemetry from flowing
    to the EDR agent.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此函数时，它会立即通过将 EAX 寄存器设置为 0 来清除该寄存器，然后返回。这样可以防止生成 ETW 事件的逻辑被执行，从而有效地阻止提供程序的遥测数据流向
    EDR 代理。
- en: Even so, this bypass has limitations. Because *clr.dll* and *ntdll.dll* are
    mapped into their own processes, they have the ability to tamper with the provider
    in a very direct manner. In most cases, however, the provider is running as a
    separate process outside the attacker’s immediate control. Patching the event-emission
    function in the mapped *ntdll.dll* won’t prevent the emission of events in another
    process.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，这种绕过方式也有其局限性。因为*clr.dll*和*ntdll.dll*被映射到各自的进程中，它们能够以非常直接的方式篡改提供者。然而，在大多数情况下，提供者作为一个独立的进程运行，超出了攻击者的直接控制范围。修补映射的*ntdll.dll*中的事件发射功能并不能阻止其他进程中的事件发射。
- en: In his blog post “Universally Evading Sysmon and ETW,” Dylan Halls describes
    a different technique for preventing ETW events from being emitted that involves
    patching <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtTraceEvent()</samp>,
    the syscall that ultimately leads to the ETW event, in kernel mode. This means
    that any ETW event on the system routed through this syscall won’t be emitted
    while the patch is in place. This technique relies on the use of Kernel Driver
    Utility (KDU) to subvert Driver Signature Enforcement and InfinityHook to mitigate
    the risk of PatchGuard crashing the system if the patch were detected. While this
    technique expands the ability to evade ETW-based detections, it requires a driver
    to be loaded and protected kernel-mode code to be modified, making it subject
    to any mitigations to the techniques leveraged by KDU or InfinityHook.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的博客文章《普遍绕过Sysmon和ETW》中，Dylan Halls描述了一种不同的技术，防止ETW事件被发射，该技术涉及修补<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtTraceEvent()</samp>，这个系统调用最终会导致ETW事件在内核模式下被触发。这意味着，在修补程序生效期间，系统上通过该系统调用路由的任何ETW事件都不会被发射。这种技术依赖于使用内核驱动工具（KDU）来规避驱动程序签名强制执行，以及使用InfinityHook来降低PatchGuard检测到补丁后崩溃系统的风险。虽然这种技术扩展了绕过ETW检测的能力，但它需要加载驱动程序并修改受保护的内核模式代码，因此会受到KDU或InfinityHook所依赖的任何缓解技术的影响。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: ETW is one of the most important technologies for collecting host-based telemetry
    on Windows. It provides an EDR with visibility into components and processes,
    such as the Task Scheduler and local DNS client, that no other sensor can monitor.
    An agent can consume events from nearly any providers it finds and use that information
    to gain an immense amount of context about system activities. Evasion of ETW is
    well researched, with most strategies focusing on disabling, unregistering, or
    otherwise rendering a provider or consumer unable to handle events.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ETW（事件跟踪 Windows）是收集 Windows 主机基础遥测数据的最重要技术之一。它为EDR（端点检测与响应）提供对组件和进程的可视性，比如任务调度器和本地
    DNS 客户端，这些是其他传感器无法监控的。一个代理可以消费它找到的几乎所有提供者的事件，并使用这些信息来获得关于系统活动的大量上下文。绕过ETW的技术已经有很多研究，绝大多数策略集中在禁用、注销或以其他方式使提供者或消费者无法处理事件。
