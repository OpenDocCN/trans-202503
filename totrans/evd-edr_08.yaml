- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EVENT
    TRACING FOR WINDOWS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS
    事件追踪</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Using the Event Tracing for Windows (ETW) logging facility, developers can program
    their applications to emit events, consume events from other components, and control
    event-tracing sessions. This allows them to trace the execution of their code
    and monitor or debug potential issues. It may be helpful to think of ETW as an
    alternative to *printf*-based debugging; the messages are emitted over a common
    channel using a standard format rather than printed to the console.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Windows 事件追踪（ETW）日志记录功能，开发人员可以编写应用程序，发出事件、从其他组件接收事件，并控制事件追踪会话。这使得他们能够追踪代码的执行，监控或调试潜在问题。可以将
    ETW 看作是 *printf* 调试的替代方案；这些消息通过一个公共通道，使用标准格式发出，而不是打印到控制台。
- en: In a security context, ETW provides valuable telemetry that wouldn’t otherwise
    be available to an endpoint agent. For example, the common language runtime, which
    is loaded into every .NET process, emits unique events using ETW that can provide
    more insight than any other mechanism into the nature of managed code executing
    on the host. This allows an EDR agent to collect novel data from which to create
    new alerts or enrich existing events.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全环境中，ETW 提供了宝贵的遥测数据，否则终端代理无法获取。例如，通用语言运行时（CLR），它被加载到每个 .NET 进程中，利用 ETW 发出独特的事件，能够比任何其他机制提供更多关于托管代码执行情况的洞察。这使得
    EDR 代理能够收集新的数据，从中创建新的警报或丰富现有事件。
- en: ETW is rarely praised for its simplicity and ease of use, thanks in no small
    part to the tremendously complicated technical documentation that Microsoft provides
    for it. Luckily, while ETW’s inner workings and implementation details are fascinating,
    you don’t need a full understanding of its architecture. This chapter covers the
    parts of ETW that are relevant to those interested in telemetry. We’ll walk through
    how an agent might collect telemetry from ETW and how to evade this collection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ETW 很少因其简单性和易用性而受到赞扬，这在很大程度上归功于微软为其提供的极其复杂的技术文档。幸运的是，尽管 ETW 的内部工作原理和实现细节非常有趣，但你不需要完全理解其架构。本章将介绍
    ETW 中与遥测相关的部分。我们将演示代理如何从 ETW 收集遥测数据，以及如何避免此类收集。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Architecture</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">架构</samp>
- en: 'There are three main components involved in ETW: providers, consumers, and
    controllers. Each of these components serves a distinct purpose in an event-tracing
    session. The following overview describes how each component fits into the larger
    ETW architecture.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ETW 涉及三个主要组件：提供者、消费者和控制器。这些组件在事件追踪会话中各自发挥独特的作用。以下概述了每个组件在 ETW 架构中的作用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Providers</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">提供者</samp>
- en: Simply put, providers are the software components that emit events. These might
    include parts of the system, such as the Task Scheduler, a third-party application,
    or even the kernel itself. Generally, the provider isn’t a separate application
    or image but rather the primary image associated with the component.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，提供者是发出事件的软件组件。这些组件可能包括系统的各个部分，如任务调度程序、第三方应用程序，甚至是内核本身。通常，提供者不是一个单独的应用程序或镜像，而是与该组件关联的主要镜像。
- en: When this provider image follows some interesting or concerning code path, the
    developer can opt to have it emit an event related to its execution. For example,
    if the application handles user authentication, it might emit an event whenever
    authentication fails. These events contain any data the developer deems necessary
    to debug or monitor the application, ranging from a simple string to complex structures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个提供者镜像执行一些有趣或令人担忧的代码路径时，开发人员可以选择让其发出与执行相关的事件。例如，如果应用程序处理用户身份验证，当身份验证失败时，它可能会发出事件。这些事件包含开发人员认为调试或监控应用程序所需的任何数据，从简单的字符串到复杂的结构体。
- en: ETW providers have GUIDs that other software can use to identify them. In addition,
    providers have more user-friendly names, most often defined in their manifest,
    that allow humans to identify them more easily. There are around 1,100 providers
    registered in default Windows 10 installations. [Table 8-1](#tab8-1) includes
    those that endpoint security products might find helpful.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Default
    ETW Providers Relevant to Security Monitoring</samp>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Provider name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">GUID</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Antimalware-Scan-Interface</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{2A576B87-09A7-520E-C21A-4942F0271D67}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Supplies details about the data passed
    through the Antimalware Scan Interface (AMSI)</samp> |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-DotNETRuntime</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides events related to .NET assemblies
    executing on the local host</samp> |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Audit-CVE</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{85A62A0D-7E17-485F-9D4F-749A287193A6}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides a mechanism for software to report
    attempts to exploit known vulnerabilities</samp> |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-DNS-Client</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{1C95126E-7EEA-49A9-A3FE-A378B03DDB4D}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Details the results of domain name resolution
    on the host</samp> |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Kernel-Process</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides information related to the creation
    and termination of processes (similar to what a driver</samp> <samp class="SANS_Futura_Std_Book_11">can
    obtain using a process-cre</samp><samp class="SANS_Futura_Std_Book_11">ation callback
    routine)</samp> |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-PowerShell</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{A0C1853B-5C40-4B15-8766-3CF1C58F985A}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides PowerShell script block-logging
    functionality</samp> |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-RPC</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">{6AD52B32-D609-4BE9-AE07-CE8DAE937E39}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Contains information related to RPC operations
    on the local system</samp> |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Security-Kerberos</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{98E6CFCB-EE0A-41E0-A57B-622D4E1B30B1}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides information related to Kerberos
    authentication on the host</samp> |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Services</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">{0063715B-EEDA-4007-9429-AD526F62696E}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Emits events related to the installation,
    operation, and removal of services</samp> |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-SmartScreen</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{3CB2A168-FE34-4A4E-BDAD-DCF422F34473}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides events related to Microsoft Defender
    SmartScreen and its interaction with files downloaded from the internet</samp>
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-TaskScheduler</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{DE7B24EA-73C8-4A09-985D-5BDADCFA9017}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Supplies information related to scheduled
    tasks</samp> |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-WebIO</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">{50B3E73C-9370-461D-BB9F-26F32D68887D}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides visibility into web requests
    being made by users of the system</samp> |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-WMI-Activity</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">{1418EF04-B0B4-4623-BF7E-D74AB47BBDAA}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Supplies telemetry related to the operation
    of WMI, including event subscriptions</samp> |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: ETW providers are securable objects, meaning a security descriptor can be applied
    to them. A *security descriptor* provides a way for Windows to restrict access
    to the object through a discretionary access control list or log access attempts
    via a system access control list. [Listing 8-1](#list8-1) shows the security descriptor
    applied to the Microsoft-Windows-Services provider.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: Evaluating the security descriptor applied to a provider'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: This command parses the binary security descriptor from the provider’s registry
    configuration using its GUID. It then uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32
    _SecurityDescriptorHelper</samp> WMI class to convert the byte array in the registry
    to a security descriptor definition language string. This string is then passed
    to the PowerShell cmdlet <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-SddlString</samp>
    to return the human-readable details of the security descriptor. By default, this
    security descriptor only allows access to *NT AUTHORITY\SYSTEM*, *NT AUTHORITY\LOCAL
    SERVICE*, and members of the local Administrators group. This means that controller
    code must be running as admin to directly interact with providers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令通过提供者的 GUID 解析提供者注册表配置中的二进制安全描述符。然后，它使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32
    _SecurityDescriptorHelper</samp> WMI 类将注册表中的字节数组转换为安全描述符定义语言字符串。该字符串随后传递给 PowerShell
    cmdlet <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-SddlString</samp>，以返回安全描述符的可读详细信息。默认情况下，该安全描述符仅允许
    *NT AUTHORITY\SYSTEM*、*NT AUTHORITY\LOCAL SERVICE* 和本地管理员组成员访问。这意味着控制器代码必须以管理员身份运行，才能直接与提供者交互。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Emitting Events</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">发出事件</samp>
- en: 'Currently, four main technologies allow developers to emit events from their
    provider applications:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，有四种主要技术允许开发人员从其提供者应用程序中发出事件：
- en: '**Managed Object Format (MOF)**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**托管对象格式 (MOF)**'
- en: MOF is the language used to define events so that consumers know how to ingest
    and process them. To register and write events using MOF, providers use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> functions,
    respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MOF 是定义事件的语言，使消费者知道如何接收和处理这些事件。为了使用 MOF 注册和写入事件，提供者分别使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> 函数。
- en: '**Windows Software Trace Preprocessor (WPP)**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 软件跟踪预处理器 (WPP)**'
- en: Like the Windows Event Log, WPP is a system that lets the provider log an event
    ID and event data, initially in binary but later formatted to be human readable.
    WPP supports more complex data types than MOF, including timestamps and GUIDs,
    and acts as a supplement to MOF-based providers. Like MOF-based providers, WPP
    providers use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> functions
    to register and write events. WPP providers can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">WPP_INIT_TRACING</samp>
    macro to register the provider GUID.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Windows 事件日志，WPP 是一种系统，允许提供者记录事件 ID 和事件数据，最初以二进制格式存储，稍后格式化为可供人类阅读的形式。WPP
    支持比 MOF 更复杂的数据类型，包括时间戳和 GUID，并作为 MOF 基于提供者的补充。与基于 MOF 的提供者类似，WPP 提供者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> 函数来注册和写入事件。WPP
    提供者还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WPP_INIT_TRACING</samp>
    宏来注册提供者 GUID。
- en: '**Manifests**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单**'
- en: Manifests are XML files containing the elements that define the provider, including
    details about the format of events and the provider itself. These manifests are
    embedded in the provider binary at compilation time and registered with the system.
    Providers that use manifests rely on the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp>
    function to register events and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventWrite()</samp>
    to write them. Today, this seems to be the most common way to register providers,
    especially those that ship with Windows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 清单是包含定义提供者元素的 XML 文件，其中包括有关事件格式和提供者本身的详细信息。这些清单在编译时嵌入到提供者二进制文件中并注册到系统。使用清单的提供者依赖于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp> 函数来注册事件，并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventWrite()</samp> 函数来写入事件。如今，这似乎是注册提供者的最常见方式，特别是那些随
    Windows 一起发布的提供者。
- en: '**TraceLogging**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**跟踪日志记录 (TraceLogging)**'
- en: Introduced in Windows 10, TraceLogging is the newest technology for providing
    events. Unlike the other technologies, TraceLogging allows for *self-describing*
    events, meaning that no class or manifest needs to be registered with the system
    for the consumer to know how to process them. The consumer uses the Trace Data
    Helper (TDH) APIs to decode and work with events. These providers use <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingRegister()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingWrite()</samp>
    to register and write events.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 10 中引入的 TraceLogging 是提供事件的最新技术。与其他技术不同，TraceLogging 允许*自描述*事件，这意味着消费者无需为事件注册任何类或清单，便能知道如何处理这些事件。消费者使用
    Trace 数据助手（TDH）API 来解码和处理事件。这些提供者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingRegister()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingWrite()</samp>
    来注册和写入事件。
- en: 'Regardless of which method a developer chooses, the result is the same: events
    being emitted by their application for consumption by other applications.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无论开发者选择哪种方法，结果都是一样的：应用程序发出的事件供其他应用程序使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Locating Event Sources</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">定位事件源</samp>
- en: 'To understand why a provider is emitting certain events, it’s often helpful
    to look at the provider itself. Unfortunately, Windows doesn’t provide an easy
    way to translate a provider’s name or GUID into an image on disk. You can sometimes
    collect this information from the event’s metadata, but in many cases, such as
    when the event source is a DLL or a driver, discovering it requires more effort.
    In these situations, try considering the following attributes of ETW providers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么提供者会发出某些事件，通常查看提供者本身会很有帮助。不幸的是，Windows 并没有提供一种简单的方法将提供者的名称或 GUID 转换为磁盘上的映像。有时，你可以从事件的元数据中收集这些信息，但在许多情况下，尤其是当事件源是
    DLL 或驱动程序时，发现它需要更多的努力。在这些情况下，可以考虑以下 ETW 提供者的属性：
- en: The provider’s PE file must reference its GUID, most commonly in the *.rdata*
    section, which holds read-only initialized data.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者的 PE 文件必须引用其 GUID，通常是在 *.rdata* 区段，该区段保存只读初始化数据。
- en: The provider must be an executable code file, typically a *.exe*, *.dll*, or
    *.sys*.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者必须是可执行代码文件，通常是 *.exe*、*.dll* 或 *.sys* 文件。
- en: The provider must call a registration API (specifically, <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventRegister()</samp>
    for user-mode applications and <samp class="SANS_TheSansMonoCd_W5Regular_11">ntoskrnl!EtwRegister()</samp>
    for kernel-mode components).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者必须调用注册 API（具体来说，对于用户模式应用程序是 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventRegister()</samp>，对于内核模式组件是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ntoskrnl!EtwRegister()</samp>）。
- en: If using a manifest registered with the system, the provider image will be in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResourceFileName</samp> value
    in the registry key *HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers\<PROVIDER_GUID>.*
    This file will contain a *WEVT_TEMPLATE* resource, which is the binary representation
    of the manifest.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用系统注册的清单，提供者的映像将位于注册表项 *HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers\<PROVIDER_GUID>*
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ResourceFileName</samp> 值。该文件将包含
    *WEVT_TEMPLATE* 资源，这是清单的二进制表示。
- en: You could conduct a scan of files on the operating system and return those that
    satisfy these requirements. The *FindETWProviderImage* open source tool available
    on GitHub makes this process easy. [Listing 8-2](#list8-2) uses it to locate images
    that reference the GUID of the Microsoft-Windows-TaskScheduler provider.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对操作系统中的文件进行扫描，并返回符合这些要求的文件。GitHub 上的开源工具 *FindETWProviderImage* 可以简化这个过程。[清单
    8-2](#list8-2) 使用它来定位引用 Microsoft-Windows-TaskScheduler 提供者 GUID 的映像。
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 8-2: Using FindETWProviderImage to locate provider binaries'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-2：使用 FindETWProviderImage 定位提供者二进制文件
- en: If you consider the output, you’ll see that this approach has some gaps. For
    example, the tool returned the true provider of the events, *schedsvc.dll*, but
    also three other images. These false positives might occur because images consume
    events from the target provider and so contain the provider’s GUID, or because
    they produce their own events and so import one of the registration APIs. This
    method might also produce false negatives; for example, when the source of an
    event is *ntoskrnl.exe*, the image won’t be found in the registry or import either
    of the registration functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: To confirm the identity of the provider, you must investigate an image further.
    You can do this using a relatively simple methodology. In a disassembler, navigate
    to the offset or relative virtual address reported by *FindETWProviderImage* and
    look for any references to the GUID coming from a function that calls a registration
    API. You should see the address of the GUID being passed to the registration function
    in the RCX register, as shown in [Listing 8-3](#list8-3).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-3: Disassembly of the provider registration function inside schedsvc.dll'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: In this disassembly, there are two instructions of interest to us. The first
    is the address of the provider GUID being loaded into RCX ❶. This is immediately
    followed by a call to the imported <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventRegister()</samp>
    function ❷ to register the provider with the operating system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Figuring Out Why an Event
    Was Emitted</samp>
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this point, you’ve identified the provider. From here, many detection engineers
    begin looking into what conditions triggered the provider to emit the event. The
    details of this process are outside the scope of this book, as they can differ
    substantially based on the provider, although we’ll cover the topic in greater
    depth in [Chapter 12](chapter12.xhtml). Typically, however, the workflow looks
    as follows.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In a disassembler, mark the <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>
    returned from the event registration API, then look for references to this <samp
    class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp> from a function that
    writes ETW events, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ntoskrnl!EtwWrite()</samp>.
    Step through the function, looking for the source of the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp>
    parameter passed to it. Follow execution from this source to the event-writing
    function, checking for conditional branches that would prevent the event from
    being emitted. Repeat these steps for each unique reference to the global <samp
    class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Controllers</samp>
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Controllers are the components that define and control *trace sessions*, which
    record events written by providers and flush them to the event consumers. The
    controller’s job includes starting and stopping sessions, enabling or disabling
    providers associated with a session, and managing the size of the event buffer
    pool, among other things. A single application might contain both controller and
    consumer code; alternatively, the controller can be a separate application entirely,
    as in the case of Xperf and logman, two utilities that facilitate collecting and
    processing ETW events.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是定义和控制*跟踪会话*的组件，跟踪会话记录由提供程序写入的事件，并将其刷新到事件消费者。控制器的任务包括启动和停止会话，启用或禁用与会话关联的提供程序，管理事件缓冲池的大小等。单个应用程序可能包含控制器和消费者代码；或者，控制器也可以是一个完全独立的应用程序，例如
    Xperf 和 logman，它们是收集和处理 ETW 事件的两个工具。
- en: Controllers create trace sessions using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp>
    API and configure them using <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ControlTrace()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EnableTraceEx()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>.
    On Windows XP and later, controllers can start and manage a maximum of 64 simultaneous
    trace sessions. To view these trace sessions, use logman, as shown in [Listing
    8-4](#list8-4).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp>
    API 创建跟踪会话，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ControlTrace()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EnableTraceEx()</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    进行配置。在 Windows XP 及以后的版本中，控制器最多可以启动并管理 64 个同时的跟踪会话。要查看这些跟踪会话，可以使用 logman，如 [Listing
    8-4](#list8-4) 所示。
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 8-4: Enumerating trace sessions with logman.exe'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-4：使用 logman.exe 枚举跟踪会话
- en: Each name under the Data Collector Set column represents a unique controller
    with its own subordinate trace sessions. The controllers shown in [Listing 8-4](#list8-4)
    are built into Windows, as the operating system also makes heavy use of ETW for
    activity monitoring.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Data Collector Set 列下的每个名称表示一个独特的控制器，具有自己的下属跟踪会话。 [Listing 8-4](#list8-4) 中显示的控制器是内置于
    Windows 中的，因为操作系统也大量使用 ETW 进行活动监控。
- en: Controllers can also query existing traces to get information. [Listing 8-5](#list8-5)
    shows this in action.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器还可以查询现有的跟踪以获取信息。 [Listing 8-5](#list8-5) 展示了这一过程。
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 8-5: Using logman.exe to query a specific trace'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-5：使用 logman.exe 查询特定的跟踪
- en: This query provides us with information about the providers enabled in the session
    ❷ and the filtering keywords in use ❸, whether it is a real-time or file-based
    trace ❶, and performance figures. With this information, we can start to understand
    whether the trace is a form of performance monitoring or telemetry collection
    by an EDR.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询为我们提供了有关会话中启用的提供程序❷以及使用的过滤关键字❸的信息，是否为实时跟踪或基于文件的跟踪❶，以及性能数据。通过这些信息，我们可以开始理解该跟踪是否为
    EDR 进行的性能监控或遥测收集。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Consumers</samp>
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">消费者</samp>
- en: Consumers are the software components that receive events after they’ve been
    recorded by a trace session. They can either read events from a logfile on disk
    or consume them in real time. Because nearly every EDR agent is a real-time consumer,
    we’ll focus exclusively on those.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者是接收事件的软件组件，这些事件在被跟踪会话记录后送达。它们可以从磁盘上的日志文件中读取事件，也可以实时消费事件。由于几乎每个 EDR 代理都是实时消费者，我们将专注于这类消费者。
- en: Consumers use <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>
    to connect to the real-time session and <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>
    to start consuming events from it. Each time the consumer receives a new event,
    an internally defined callback function parses the event data based on information
    supplied by the provider, such as the event manifest. The consumer can then choose
    to do whatever it likes with the information. In the case of endpoint security
    software, this may mean creating an alert, taking some preventive actions, or
    correlating the activity with telemetry collected by another sensor.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>
    连接到实时会话，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>
    开始从中消费事件。每次消费者收到新事件时，一个内部定义的回调函数根据提供者提供的信息（如事件清单）解析事件数据。消费者然后可以选择对这些信息执行任意操作。在端点安全软件的情况下，这可能意味着创建警报、采取一些预防措施，或将活动与其他传感器收集的遥测数据关联起来。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a Consumer to Identify Malicious
    .NET Assemblies</samp>
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建一个消费者来识别恶意 .NET 程序集</samp>
- en: Let’s walk through the process of developing a consumer and working with events.
    In this section, we’ll identify the use of malicious in-memory .NET framework
    assemblies, such as those employed by Cobalt Strike’s Beacon <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp>
    functionality. One strategy for identifying these assemblies is to look for class
    names belonging to known offensive C# projects. Although attackers can easily
    defeat this technique by changing the names of their malware’s classes and methods,
    it can be an effective way to identify the use of unmodified tools by less sophisticated
    actors.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解开发消费者并处理事件的过程。在本节中，我们将识别恶意内存中的 .NET 框架程序集的使用，例如 Cobalt Strike 的 Beacon
    <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp> 功能使用的那些程序集。识别这些程序集的一种策略是寻找属于已知攻击性
    C# 项目的类名。尽管攻击者可以通过更改恶意软件的类名和方法轻松绕过此技巧，但它仍然是识别不修改工具的较低技术水平攻击者使用工具的一种有效方式。
- en: Our consumer will ingest filtered events from the Microsoft-Windows-DotNETRuntime
    provider, specifically watching for classes associated with Seatbelt, a post-exploitation
    Windows reconnaissance tool.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消费者将从 Microsoft-Windows-DotNETRuntime 提供者中获取过滤后的事件，特别是关注与 Seatbelt 相关的类，Seatbelt
    是一种后期利用的 Windows 侦察工具。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Trace
    Session</samp>
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建追踪会话</samp>
- en: To begin consuming events, we must first create a trace session using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp> API. This
    function takes a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES</samp>
    structure, defined in [Listing 8-6](#list8-6). (On systems running versions of
    Windows later than 1703, the function could choose to take a pointer to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES_V2</samp> structure
    instead.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始消费事件，我们必须首先使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp>
    API 创建一个追踪会话。此函数接受一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES</samp>
    结构体的指针，该结构体在[示例 8-6](#list8-6)中定义。（在运行 Windows 1703 版本之后的系统上，函数可能会选择接受一个指向 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES_V2</samp> 结构体的指针。）
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 8-6: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_PROPERTIES</samp>
    structure definition'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-6：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_PROPERTIES</samp>
    结构体定义
- en: This structure describes the trace session. The consumer will populate it and
    pass it to a function that starts the trace session, as shown in [Listing 8-7](#list8-7).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构体描述了追踪会话。消费者将填充该结构体并将其传递给一个启动追踪会话的函数，如[示例 8-7](#list8-7)所示。
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-7: Configuring trace properties'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-7：配置追踪属性
- en: We populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">WNODE_HEADER</samp>
    structure pointed to in the trace properties. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>
    member contains the GUID of the trace session, not of the desired provider. Additionally,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogFileMode</samp> member of
    the trace properties structure is usually set to <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_REAL_TIME_MODE</samp>
    to enable real-time event tracing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enabling Providers</samp>
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The trace session isn’t yet collecting events, as no providers have been enabled
    for it. To add providers, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    API. This function takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>
    returned earlier as a parameter and is defined in [Listing 8-8](#list8-8).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 8-8: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sechost!EnableTraceEx2()</samp>
    function definition'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ProviderId</samp> parameter
    is the target provider’s GUID, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Level</samp>
    parameter determines the severity of the events passed to the consumer. It can
    range from <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_LEVEL_VERBOSE</samp>
    (*5*) to <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_LEVEL_CRITICAL</samp>
    (*1*). The consumer will receive any events whose level is less than or equal
    to the specified value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAllKeyword</samp> parameter
    is a bitmask that allows an event to be written only if the event’s keyword bits
    match all the bits set in this value (or if the event has no keyword bits set).
    In most cases, this member is set to zero. The <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAnyKeyword</samp>
    parameter is a bitmask that allows an event to be written only if the event’s
    keyword bits match any of the bits set in this value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableParameters</samp> parameter
    allows the consumer to receive one or more extended data items in each event,
    including but not limited to the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_PROCESS_START_KEY</samp>   A
    sequence number that identifies the process, guaranteed to be unique to the current
    boot session
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_SID</samp>   The
    security identifier of the principal, such as a user of the system, under which
    the event was emitted
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_TS_ID</samp>   The
    terminal session identifier under which the event was emitted
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_STACK_TRACE</samp>   Value
    that adds a call stack if the event was written using the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventWrite()</samp>
    API
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    API can add any number of providers to a trace session, each with its own filtering
    configurations. [Listing 8-9](#list8-9) continues the code in [Listing 8-7](#list8-7)
    by demonstrating how this API is commonly used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-9: Configuring a provider for the trace session'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We add the Microsoft-Windows-DotNETRuntime provider ❶ to the trace session and
    set <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAnyKeyword</samp> to use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interop</samp> (0x2000), <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NGen</samp> (0x20), <samp class="SANS_TheSansMonoCd_W5Regular_11">Jit</samp>
    (0x10), and <samp class="SANS_TheSansMonoCd_W5Regular_11">Loader</samp> (0x8)
    keywords ❷. These keywords allow us to filter out events that we’re not interested
    in and collect only those relevant to what we’re trying to monitor.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Starting the Trace
    Session</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After we’ve completed all of these preparatory steps, we can start the trace
    session. To do so, an EDR agent would call <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>
    with a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_LOGFILE</samp>,
    defined in [Listing 8-10](#list8-10), as its only parameter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 8-10: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_LOGFILE</samp>
    structure definition'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-11](#list8-11) demonstrates how to use this structure.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 8-11: Passing the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_LOGFILE</samp>
    structure to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sechost!OpenTrace()</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: While this is a relatively large structure, only three of the members are immediately
    relevant to us. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LoggerName</samp>
    member is the name of the trace session ❶, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTraceMode</samp>
    is a bitmask containing the values for <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TRACE_MODE_EVENT_RECORD</samp>
    (0x10000000), to indicate that events should use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    format introduced in Windows Vista, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TRACE_MODE_REAL_TIME</samp>
    (0x100), to indicate that events should be received in real time ❷. Lastly, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EventRecordCallback</samp> is a pointer
    to the internal callback function ❸ (covered shortly) that ETW calls for each
    new event, passing it an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    structure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp>
    completes, it returns a new <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">hSession</samp>, in our example).
    We can then pass this handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>,
    as shown in [Listing 8-12](#list8-12), to start processing events.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 8-12: Creating the thread to process events'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We pass the current system time ❶ to <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>
    to tell the system that we want to capture events occurring after this time only.
    When called, this function will take control of the current thread, so to avoid
    completely blocking the rest of the application, we create a new thread ❷ just
    for the trace session.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Assuming no errors were returned, events should start flowing from the provider
    to the consumer, where they’ll be processed by the internal callback function
    specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EventRecordCallback</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_LOGFILE</samp>
    structure. We’ll cover this function in “Processing Events” on [page 158](#sec13).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Stopping the Trace
    Session</samp>
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we need a way to stop the trace as needed. One way to do this is to
    use a global Boolean value that we can flip when we need the trace to stop, but
    any technique that signals a thread to exit would work. However, if an outside
    user can invoke the method used (in the case of an unchecked RPC function, for
    example), a malicious user might be able to stop the agent from collecting events
    via the trace session altogether. [Listing 8-13](#list8-13) shows how stopping
    the trace might work.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 8-13: Using a console control handler to signal a thread exit'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use an internal console control handler routine, <samp class="SANS_TheSansMonoCd_W5Regular_11">ConsoleCtrlHandler()</samp>,
    and an event object that watches for the CTRL-C keyboard combination ❶. When the
    handler observes this keyboard combination, the internal function notifies the
    *event object* ❷, a synchronization object commonly used to tell a thread that
    some event has occurred, and returns. Because the event object has been signaled,
    the application resumes its execution and closes the trace session ❸.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Processing Events</samp>
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the consumer thread receives a new event, its callback function (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OnEvent()</samp> in our example code)
    is invoked with a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>
    structure. This structure, defined in [Listing 8-14](#list8-14), represents the
    entirety of the event.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 8-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_RECORD</samp>
    structure definition'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: This structure might seem simple at first glance, but it could contain a huge
    amount of information. The first field, <samp class="SANS_TheSansMonoCd_W5Regular_11">EventHeader</samp>,
    holds basic event metadata, such as the process ID of the provider binary; a timestamp;
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DESCRIPTOR</samp>,
    which describes the event itself in detail. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedData</samp>
    member matches the data passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableProperty</samp>
    parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>.
    This field is a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_HEADER_EXTENDED_DATA_ITEM</samp>,
    defined in [Listing 8-15](#list8-15).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 8-15: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_HEADER_EXTENDED_DATA_ITEM</samp>
    structure definition'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtType</samp> member contains
    an identifier (defined in *eventcons.h* and shown in [Listing 8-16](#list8-16))
    that tells the consumer to which data type the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataPtr</samp>
    member points. Note that a significant number of values defined in the headers
    are not formally supported for the callers of the API in Microsoft’s documentation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 8-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_HEADER_EXT_TYPE</samp>
    constants'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedData</samp> member
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp> contains
    valuable data, but agents typically use it to supplement other sources, particularly
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> member of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>. This is where
    things get a little tricky, as Microsoft states that, in almost all cases, we
    must retrieve this data using the TDH APIs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: We’ll walk through this process in our callback function, but keep in mind that
    this example represents only one approach to extracting relevant information and
    may not reflect production code. To begin processing the event data, the agent
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventInformation()</samp>,
    as shown in [Listing 8-17](#list8-17).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 8-17: Beginning to process event data'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: After allocating memory of the required size, we pass a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_EVENT_INFO</samp>
    structure, as the first parameter to the function. [Listing 8-18](#list8-18) defines
    this structure.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 8-18: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">TRACE_EVENT_INFO</samp>
    structure definition'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: When the function returns, it will populate this structure with useful metadata,
    such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">DecodingSource</samp>
    ❶, used to identify how the event is defined (in an instrumentation manifest,
    MOF class, or WPP template). But the most important value is <samp class="SANS_TheSansMonoCd_W5Regular_11">EventPropertyInfoArray</samp>
    ❷, an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_PROPERTY_INFO</samp>
    structures, defined in [Listing 8-19](#list8-19), that provides information about
    each property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> member.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 8-19: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_PROPERTY_INFO</samp>
    struct'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: We must parse each structure in the array individually. First, it gets the length
    of the property with which it is working. This length is dependent on the way
    in which the event is defined (for example, MOF versus manifest). Generally, we
    derive the size of the property either from the <samp class="SANS_TheSansMonoCd_W5Regular_11">length</samp>
    member ❸, from the size of a known data type (such as the size of an unsigned
    long, or <samp class="SANS_TheSansMonoCd_W5Regular_11">ulong</samp>), or by calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetPropertySize()</samp>.
    If the property itself is an array, we need to retrieve its size by either evaluating
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> member ❷ or calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetPropertySize()</samp>
    again.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to determine whether the data being evaluated is itself a structure.
    Since the caller typically knows the format of the data with which they’re working,
    this isn’t difficult in most cases and generally only becomes relevant when parsing
    events from unfamiliar providers. If an agent does need to work with structures
    inside events, however, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>
    member ❶ will include the <samp class="SANS_TheSansMonoCd_W5Regular_11">PropertyStruct</samp>
    (0x1) flag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: When the data isn’t a structure, as in the case of the Microsoft-Windows-DotNETRuntime
    provider, it will be a simple value mapping, and we can get this map information
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventMapInformation()</samp>.
    This function takes a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_EVENT_INFO</samp>,
    as well as a pointer to the map name offset, which it can access via the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MapNameOffset</samp> member. On completion,
    it receives a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_MAP_INFO</samp>
    structure, defined in [Listing 8-20](#list8-20), which defines the metadata about
    the event map.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 8-20: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_MAP_INFO</samp>
    structure definition'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-21](#list8-21) shows how our callback function uses this structure.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 8-21: Parsing the event map information'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: To parse the events that the provider emits, we iterate over every top-level
    property in the event by using the total count of properties found in <samp class="SANS_TheSansMonoCd_W5Regular_11">TopLevelPropertyCount</samp>
    for the trace event information structure ❶. Then, if we’re not dealing with a
    structure ❷ and the offset to the name of the member is present ❸, we pass the
    offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventMapInformation()</samp>❹
    to get the event map information.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve collected all the pieces of information required to fully
    parse the event data. Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhFormatProperty()</samp>,
    passing in the information we collected previously. [Listing 8-22](#list8-22)
    shows this function in action.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 8-22: Retrieving event data with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tdh!TdhFormatProperty()</samp>'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: After the function completes, the name of the property (as in the *key* portion
    of the key-value pair) will be stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NameOffset</samp>
    member of the event map information structure (which we’ve stored in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pszPropertyName</samp> variable ❷, for
    brevity). Its value will be stored in the buffer passed into <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhFormatProperty()</samp>
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> parameter ❶
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">pszValue</samp>, in our example).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Consumer</samp>
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The snippet shown in [Listing 8-23](#list8-23) comes from our .NET event consumer.
    It shows the assembly-load event for the Seatbelt reconnaissance tool being loaded
    into memory via a command-and-control agent.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 8-23: Consumer of the Microsoft-Windows-DotNETRuntime provider detecting
    Seatbelt being loaded'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: From here, the agent can use the values as it pleases. If, for instance, the
    agent wanted to terminate any process that loads the Seatbelt assembly, it could
    use this event to trigger that preventive action. To instead act more passively,
    it could take the information collected from this event, supplement it with additional
    information about the originating process, and create its own event to feed into
    detection logic.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading ETW-Based Detections</samp>
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve demonstrated, ETW can be an incredibly useful method for collecting
    information from system components that would otherwise be impossible to get.
    The technology isn’t without its limitations, however. Because ETW was built for
    monitoring or debugging and not as a critical security component, its protections
    aren’t as robust as those of other sensor components.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2021, Claudiu Teodorescu, Igor Korkin, and Andrey Golchikov of Binarly gave
    a great presentation at Black Hat Europe in which they cataloged existing ETW
    evasion techniques and introduced new ones. Their talk identified 36 unique tactics
    for bypassing ETW providers and trace sessions. The presenters split these techniques
    into five groups: attacks from inside an attacker-controlled process; attacks
    on ETW environment variables, the registry, and files; attacks on user-mode ETW
    providers; attacks on kernel-mode ETW providers; and attacks on ETW sessions.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of these techniques overlap in other ways. Moreover, while some work across
    most providers, others target specific providers or trace sessions. Several of
    the techniques are also covered in Palantir’s blog post “Tampering with Windows
    Event Tracing: Background, Offense, and Defense.” To summarize both groups’ findings,
    this section breaks down the evasions into broader categories and discusses the
    pros and cons of each.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Patching</samp>
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arguably the most common technique for evading ETW in the offensive world is
    patching critical functions, structures, and other locations in memory that play
    some role in the emission of events. These patches aim to either completely prevent
    the provider from emitting events or selectively filter the events that it sends.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: You’ll most commonly see this patching take the form of function hooking, but
    attackers can tamper with numerous other components to alter event flow. For example,
    an attacker could null out the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>
    used by the provider or modify its <samp class="SANS_TheSansMonoCd_W5Regular_11">TraceLevel</samp>
    to prevent certain types of events from being emitted. In the kernel, an attacker
    could also modify structures such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp>,
    the kernel’s representation of an event registration object. We’ll discuss this
    technique in greater detail in “Bypassing a .NET Consumer” on [page 166](#sec20).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Configuration Modification</samp>
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another common technique involves modifying persistent attributes of the system,
    including registry keys, files, and environment variables. A vast number of procedures
    fall into this category, but all generally aim to prevent a trace session or provider
    from functioning as expected, typically by abusing something like a registry-based
    “off” switch.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Two examples of “off” switches are the <samp class="SANS_TheSansMonoCd_W5Regular_11">COMPlus_ETWEnabled</samp>
    environment variable and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETWEnabled</samp>
    value under the *HKCU:\Software\Microsoft\.NETFramework* registry key. By setting
    either of these values to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    an adversary can instruct *clr.dll*, the image for the Microsoft-Windows-DotNETRuntime
    provider, not to register any <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>,
    preventing the provider from emitting ETW events.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trace-Session Tampering</samp>
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next technique involves interfering with trace sessions already running
    on the system. While this typically requires system-level privileges, an attacker
    who has elevated their access can interact with a trace session of which they
    are not the explicit owner. For example, an adversary may remove a provider from
    a trace session using <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>
    or, more simply, using logman with the following syntax:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Even more directly, the attacker may opt to stop the trace entirely:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trace-Session Interference</samp>
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final technique complements the previous one: it focuses on preventing
    trace sessions, most commonly autologgers, from functioning as expected before
    they are started, resulting in persistent changes to the system.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: One example of this technique is the manual removal of a provider from an autologger
    session through a modification of the registry. By deleting the subkey tied to
    the provider, *HKLM:\SYSTEM\CurrentControlSet\Control\WMI\Autologger\<AUTOLOGGER_NAME>\<PROVIDER_GUID>*,
    or by setting its <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>
    value to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the attacker
    can remove the provider from the trace session after the next reboot.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Attackers could also take advantage of ETW’s mechanisms to prevent sessions
    from working as expected. For example, only one trace session per host can enable
    a legacy provider (as in MOF- or TMF-based WPP). If a new session enabled this
    provider, the original session would no longer receive the desired events. Similarly,
    an adversary could create a trace session with the same name as the target before
    the security product has a chance to start its session. When the agent attempts
    to start its session, it will be met with an <samp class="SANS_TheSansMonoCd_W5Regular_11">ERROR_ALREADY_EXISTS</samp>
    error code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bypassing a .NET Consumer</samp>
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s practice evading ETW-based telemetry sources by targeting a .NET runtime
    consumer similar to the one we wrote earlier in this chapter. In his blog post
    “Hiding Your .NET—ETW,” Adam Chester describes how to prevent the common language
    runtime from emitting ETW events, keeping a sensor from identifying the loading
    of SharpHound, a C# tool that collects the data to be fed into the path-mapping
    attacker tool BloodHound.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The bypass works by patching the function responsible for emitting the ETW
    event, <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>,
    and instructing it to return immediately upon entry. Chester discovered that this
    function was ultimately responsible for emitting the event by setting a breakpoint
    on this function in WinDbg and watching for calls from *clr.dll*. The syntax for
    setting this conditional breakpoint is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The conditional logic in this command tells WinDbg to parse the call stack (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">k</samp>) and inspect each line of the
    output. If any lines begin with <samp class="SANS_TheSansMonoCd_W5Regular_11">clr!</samp>,
    indicating that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    originated from the common language runtime, a break is triggered. If there are
    no instances of this substring in the call stack, the application simply continues.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: If we view the call stack when the substring is detected, shown in [Listing
    8-24](#list8-24), we can observe the common language runtime emitting events.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 8-24: An abbreviated call stack showing the emission of ETW events
    in the common language runtime'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Reading from bottom to top, we can see that the event originates in <samp class="SANS_TheSansMonoCd_W5Regular_11">System.AppDomain.Load()</samp>,
    the function responsible for loading an assembly into the current application
    domain ❸. A chain of internal calls leads into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW::Loaderlog</samp>
    class ❷, which ultimately calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    ❶.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: While Microsoft doesn’t intend for developers to call this function directly,
    the practice is documented. The function is expected to return a Win32 error code.
    Therefore, if we can manually set the value in the EAX register (which serves
    as the return value on Windows) to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">ERROR_SUCCESS</samp>, the function
    should immediately return, appearing to always complete successfully without emitting
    an event.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Patching this function is a relatively straightforward four-step process. Let’s
    dive into it in [Listing 8-25](#list8-25).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 8-25: Patching the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!EtwEventWrite()</samp>
    function'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We locate the entry point to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    in the currently loaded copy of *ntdll.dll* using <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!GetProcAddress()</samp>
    ❶. After locating the function, we change the memory protections of the first
    three bytes (the size of our patch) from read-execute (<samp class="SANS_TheSansMonoCd_W5Regular_11">rx</samp>)
    to read-write (<samp class="SANS_TheSansMonoCd_W5Regular_11">rw</samp>) ❷ to allow
    us to overwrite the entry point. Now all we have to do is copy in the patch using
    something like <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy()</samp> ❸
    and then revert the memory protections to their original state ❹. At this point,
    we can execute our assembly loader functionality without worrying about generating
    common language runtime loader events.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: We can use WinDbg to validate that <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>
    will no longer emit events, as shown in [Listing 8-26](#list8-26).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 8-26: The patched <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!EtwEventWrite()</samp>
    function'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: When this function is called, it will immediately clear the EAX register by
    setting it to 0 and return. This prevents the logic for producing ETW events from
    ever being reached and effectively stops the provider’s telemetry from flowing
    to the EDR agent.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Even so, this bypass has limitations. Because *clr.dll* and *ntdll.dll* are
    mapped into their own processes, they have the ability to tamper with the provider
    in a very direct manner. In most cases, however, the provider is running as a
    separate process outside the attacker’s immediate control. Patching the event-emission
    function in the mapped *ntdll.dll* won’t prevent the emission of events in another
    process.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: In his blog post “Universally Evading Sysmon and ETW,” Dylan Halls describes
    a different technique for preventing ETW events from being emitted that involves
    patching <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtTraceEvent()</samp>,
    the syscall that ultimately leads to the ETW event, in kernel mode. This means
    that any ETW event on the system routed through this syscall won’t be emitted
    while the patch is in place. This technique relies on the use of Kernel Driver
    Utility (KDU) to subvert Driver Signature Enforcement and InfinityHook to mitigate
    the risk of PatchGuard crashing the system if the patch were detected. While this
    technique expands the ability to evade ETW-based detections, it requires a driver
    to be loaded and protected kernel-mode code to be modified, making it subject
    to any mitigations to the techniques leveraged by KDU or InfinityHook.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ETW is one of the most important technologies for collecting host-based telemetry
    on Windows. It provides an EDR with visibility into components and processes,
    such as the Task Scheduler and local DNS client, that no other sensor can monitor.
    An agent can consume events from nearly any providers it finds and use that information
    to gain an immense amount of context about system activities. Evasion of ETW is
    well researched, with most strategies focusing on disabling, unregistering, or
    otherwise rendering a provider or consumer unable to handle events.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
