<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 2: The Anatomy of Web APIs</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4817cf93-40a6-403c-8355-e951c69da606" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_27" title="27"/>2</span><br/>
<span class="ChapterTitle">The Anatomy of Web APIs</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">Most of what the average user knows about a web application comes from what they can see and click in the graphical user interface (GUI) of their web browser. Under the hood, APIs perform much of the work. In particular, web APIs provide a way for applications to use the functionality and data of other applications over HTTP to feed a web application GUI with images, text, and videos.</p>
<p>This chapter covers common API terminology, types, data interchange formats, and authentication methods and then ties this information together with an example: observing the requests and responses exchanged during interactions with Twitter’s API.</p>
<h2 id="h1-502444c02-0001"><span epub:type="pagebreak" id="Page_28" title="28"/>How Web APIs Work</h2>
<p class="BodyFirst">Like web applications, web APIs rely on HTTP to facilitate a client/server relationship between the host of the API (the <em>provider</em>) and the system or person making an API request (the <em>consumer</em>).</p>
<p>An API consumer can request resources from an <em>API endpoint</em>, which is a URL for interacting with part of the API. Each of the following examples is a different API endpoint:</p>
<ol class="none">
<li><em>https://example.com/api/v3/users/</em></li>
<li><em>https://example.com/api/v3/customers/</em></li>
<li><em>https://example.com/api/updated_on/</em></li>
<li><em>https://example.com/api/state/1/</em></li>
</ol>
<p><em>Resources</em> are the data being requested. A <em>singleton </em>resource is a unique object, such as <em>/api/user/{user_id}</em>. A <em>collection</em> is a group of resources, such as <em>/api/profiles/users</em>. A <em>subcollection </em>refers to a collection within a particular resource. For example, <em>/api/user/{user_id}/settings</em> is the endpoint to access the <em>settings</em> subcollection of a specific (singleton) user.</p>
<p>When a consumer requests a resource from a provider, the request passes through an <em>API gateway</em>, which is an API management component that acts as an entry point to a web application. For example, as shown in <a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a>, end users can access an application’s services using a plethora of devices, which are all filtered through an API gateway. The API gateway then distributes the requests to whichever microservice is needed to fulfill each request.</p>
<p>The API gateway filters bad requests, monitors incoming traffic, and routes each request to the proper service or microservice. The API gateway can also handle security controls such as authentication, authorization, encryption in transit using SSL, rate limiting, and load balancing.</p>
<figure>
<img alt="Diagram showing an API gateway in the center, apps on the left-hand side, and microservices on the right-hand side. Arrows travel from the mobile app, web app, and IoT app to the API gateway, and from the API gateway to Microservice 1, Microservice 2, and Microservice 3." class="" src="image_fi/502444c02/F02001.png"/>
<figcaption><p><a id="figure2-1">Figure 2-1</a>: A sample microservices architecture and API gateway</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_29" title="29"/>A <em>microservice </em>is a modular piece of a web app that handles a specific function. Microservices use APIs to transfer data and trigger actions. For example, a web application with a payment gateway may have several different features on a single web page: a billing feature, a feature that logs customer account information, and one that emails receipts upon purchase. The application’s backend design could be monolithic, meaning all the services exist within a single application, or it could have a microservice architecture, where each service functions as its own standalone application.</p>
<p>The API consumer does not see the backend design, only the endpoints they can interact with and the resources they can access. These are spelled out in the API <em>contract</em>, which is human-readable documentation that describes how to use the API and how you can expect it to behave. API documentation differs from one organization to another but often includes a description of authentication requirements, user permission levels, API endpoints, and the required request parameters. It might also include usage examples. From an API hacker’s perspective, the documentation can reveal which endpoints to call for customer data, which API keys you need in order to become an administrator, and even business logic flaws.</p>
<p>In the following box, the GitHub API documentation for the <em>/applications/{client_id}/grants/{access_token}</em> endpoint, taken from <a class="LinkURL" href="https://docs.github.com/en/rest/reference/apps">https://docs.github.com/en/rest/reference/apps</a>, is an example of quality documentation.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Revoke a grant for an application</h2>
<p class="BoxBodyFirst">OAuth application owners can revoke a grant for their OAuth application and a specific user.</p>
<blockquote><p class="BoxExtractPara"><b>DELETE</b> <code>/applications/{</code><code>client_id</code><code>}/grants/{</code><code>access_token</code><code>}</code></p></blockquote>
<h3>Parameters</h3>
<table border="1" class="tabular" id="tabular-502444c02-">
<thead>
<tr>
<td><b>Name</b></td>
<td><b>Type</b></td>
<td><b>In</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>accept</code></td>
<td>string</td>
<td>header</td>
<td>Setting to <code>application/vnd.github.v3+json</code> is recommended.</td>
</tr>
<tr>
<td><code>client_id</code></td>
<td>string</td>
<td>path</td>
<td>The client ID of your GitHub app.</td>
</tr>
<tr>
<td><code>access_token</code></td>
<td>string</td>
<td>body</td>
<td>Required. The OAuth access token used to authenticate to the GitHub API.</td>
</tr>
</tbody>
</table>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" id="Page_30" title="30"/>The documentation for this endpoint includes the description of the purpose of the API request, the HTTP request method to use when interacting with the API endpoint, and the endpoint itself, <em>/applications</em>, followed by variables.</p>
<p>The acronym<em> CRUD</em>, which stands for <em>Create, Read, Update, Delete</em>, describes the primary actions and methods used to interact with APIs. <em>Create</em> is the process of making new records, accomplished through a POST request. <em>Read</em> is data retrieval, done through a GET request. <em>Update</em> is how currently existing records are modified without being overwritten and is accomplished with POST or PUT requests. <em>Delete</em> is the process of erasing records, which can be done with POST or DELETE, as shown in this example. Note that CRUD is a best practice only, and developers may implement their APIs in other ways. Therefore, when you learn to hack APIs later on, we’ll test beyond the CRUD methods.</p>
<p>By convention, curly brackets mean that a given variable is necessary within the path parameters. The <em>{client_id}</em> variable must be replaced with an actual client’s ID, and the <em>{access_token}</em> variable must be replaced with your own access token. Tokens are what API providers use to identify and authorize requests to approved API consumers. Other API documentation might use a colon or square brackets to signify a variable (for example, <em>/api/v2/:customers/</em> or <em>/api/:collection/:client_id</em>).</p>
<p>The “Parameters” section lays out the authentication and authorization requirements to perform the described actions, including the name of each parameter value, the type of data to provide, where to include the data, and a description of the parameter value.</p>
<h2 id="h1-502444c02-0002">Standard Web API Types</h2>
<p class="BodyFirst">APIs come in standard types, each of which varies in its rules, functions, and purpose. Typically, a given API will use only one type, but you may encounter endpoints that don’t match the format and structure of the others or don’t match a standard type at all. Being able to recognize typical and atypical APIs will help you know what to expect and test for as an API hacker. Remember, most public APIs are designed to be self-service, so a given API provider will often let you know the type of API you’ll be interacting with.</p>
<p>This section describes the two primary API types we’ll focus on throughout this book: RESTful APIs and GraphQL. Later parts of the book, as well as the book’s labs, cover attacks against RESTful APIs and GraphQL only.</p>
<h3 id="h2-502444c02-0001">RESTful APIs</h3>
<p class="BodyFirst"><em>Representational State Transfer (REST)</em> is a set of architectural constraints for applications that communicate using HTTP methods. APIs that use REST constraints are called <em>RESTful</em> (or just REST) APIs.</p>
<p><span epub:type="pagebreak" id="Page_31" title="31"/>REST was designed to improve upon many of the inefficiencies of other older APIs, such as Simple Object Access Protocol (SOAP). For example, it relies entirely on the use of HTTP, which makes it much more approachable to end users. REST APIs primarily use the HTTP methods GET, POST, PUT, and DELETE to accomplish CRUD (as described in the section <span class="xref" itemid="xref_target_“How Web APIs Work”">“How Web APIs Work”</span>).</p>
<p>RESTful design depends on six constraints. These constraints are “shoulds” instead of “musts,” reflecting the fact that REST is essentially a set of guidelines for an HTTP resource-based architecture:</p>
<ol class="decimal">
<li value="1"><b>Uniform interface:</b> REST APIs should have a uniform interface. In other words, the requesting client device should not matter; a mobile device, an IoT (internet of things) device, and a laptop must all be able to access a server in the same way.</li>
<li value="2"><b>Client/server:</b> REST APIs should have a client/server architecture. Clients are the consumers requesting information, and servers are the providers of that information.</li>
<li value="3"><b>Stateless:</b> REST APIs should not require stateful communications. REST APIs do not maintain state during communication; it is as though each request is the first one received by the server. The consumer will therefore need to supply everything the provider will need in order to act upon the request. This has the benefit of saving the provider from having to remember the consumer from one request to another. Consumers often provide tokens to create a state-like experience.</li>
<li value="4"><b>Cacheable:</b> The response from the REST API provider should indicate whether the response is cacheable. <em>Caching</em> is a method of increasing request throughput by storing commonly requested data on the client side or in a server cache. When a request is made, the client will first check its local storage for the requested information. If it doesn’t find the information, it passes the request to the server, which checks its local storage for the requested information. If the data is not there either, the request could be passed to other servers, such as database servers, where the data can be retrieved.
<p class="ListBody">As you might imagine, if the data is stored on the client, the client can immediately retrieve the requested data at little to no processing cost to the server. This also applies if the server has cached a request. The further down the chain a request has to go to retrieve data, the higher the resource cost and the longer it takes. Making REST APIs cacheable by default is a way to improve overall REST performance and scalability by decreasing response times and server processing power. APIs usually manage caching with the use of headers that explain when the requested information will expire from the cache.</p></li>
<li value="5"><b>Layered system:</b> The client should be able to request data from an endpoint without knowing about the underlying server architecture.</li>
<li value="6"><b>Code on demand (optional):</b> Allows for code to be sent to the client for execution.</li>
</ol>
<p><span epub:type="pagebreak" id="Page_32" title="32"/>REST is a style rather than a protocol, so each RESTful API may be different. It may have methods enabled beyond CRUD, its own sets of authentication requirements, subdomains instead of paths for endpoints, different rate-limit requirements, and so on. Furthermore, developers or an organization may call their API “RESTful” without adhering to the standard, which means you can’t expect every API you come across to meet all the REST constraints.</p>
<p><a href="#listing2-1" id="listinganchor2-1">Listing 2-1</a> shows a fairly typical REST API GET request used to find out how many pillows are in a store’s inventory. <a href="#listing2-2" id="listinganchor2-2">Listing 2-2</a> shows the provider’s response.</p>
<pre><code>GET /api/v3/inventory/item/pillow HTTP/1.1
HOST: rest-shop.com
User-Agent: Mozilla/5.0
Accept: application/json</code></pre>
<p class="CodeListingCaption"><a id="listing2-1">Listing 2-1</a>: A sample RESTful API request</p>
<pre><code>HTTP/1.1 200 OK
Server: RESTfulServer/0.1
Cache-Control: no-store
Content-Type: application/json

{
"item": {
    "id": "00101",
    "name": "pillow",
    "count": 25
    "price": {
"currency": "USD",
"value": "19.99"
}
  },
}</code></pre>
<p class="CodeListingCaption"><a id="listing2-2">Listing 2-2</a>: A sample RESTful API response</p>
<p>This REST API request is just an HTTP GET request to the specified URL. In this case, the request queries the store’s inventory for pillows. The provider responds with JSON indicating the item’s ID, name, and quantity of items in stock. If there was an error in the request, the provider would respond with an HTTP error code in the 400 range indicating what went wrong.</p>
<p>One thing to note: the <em>rest-shop.com</em> store provided all the information it had about the resource “pillow” in its response. If the consumer’s application only needed the name and value of the pillow, the consumer would need to filter out the additional information. The amount of information sent back to a consumer completely depends on how the API provider has programmed its API.</p>
<p><span epub:type="pagebreak" id="Page_33" title="33"/>REST APIs have some common headers you should become familiar with. These are identical to HTTP headers but are more commonly seen in REST API requests than in other API types, so they can help you identify REST APIs. (Headers, naming conventions, and the data interchange format used are normally the best indicators of an API’s type.) The following subsections detail some of the common REST API headers you will come across.</p>
<h4 id="h3-502444c02-0001">Authorization</h4>
<p class="BodyFirst"><code>Authorization</code> headers are used to pass a token or credentials to the API provider. The format of these headers is <code>Authorization: &lt;type&gt; &lt;token/credentials&gt;</code>. For example, take a look at the following authorization header:</p>
<pre><code>Authorization: Bearer Ab4dtok3n</code></pre>
<p>There are different authorization types<em>. </em><code>Basic</code> uses base64-encoded credentials.<em> </em><code>Bearer</code><em> </em>uses an API token. Finally,<em> </em><code>AWS-HMAC-SHA256</code> is an AWS authorization type that uses an access key and a secret key.</p>
<h4 id="h3-502444c02-0002">Content Type</h4>
<p class="BodyFirst"><code>Content-Type</code> headers are used to indicate the type of media being transferred. These headers differ from <code>Accept</code> headers, which state the media type you want to receive; <code>Content-Type</code> headers describe the media you’re sending.</p>
<p>Here are some common <code>Content-Type</code><b> </b>headers for REST APIs:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>application/json</code></span></span>  Used to specify JavaScript Object Notation (JSON) as a media type. JSON is the most common media type for REST APIs.</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>application/xml</code></span></span>  Used to specify XML as a media type.</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>application/x-www-form-</code></span><span class="LiteralBold"><code>urlencoded</code></span></span>  A format in which the values being sent are encoded and separated by an ampersand (<code>&amp;</code>), and an equal sign (<code>=</code>) is used between key/value pairs.</li>
</ol>
<h4 id="h3-502444c02-0003">Middleware (X) Headers</h4>
<p class="BodyFirst"><code>X-&lt;anything&gt;</code> headers are known as <em>middleware headers</em> and can serve all sorts of purposes. They are fairly common outside of API requests as well. <code>X-Response-Time</code> can be used as an API response to indicate how long a response took to process. <code>X-API-Key</code> can be used as an authorization header for API keys. <code>X-Powered-By</code> can be used to provide additional information about backend services. <code>X-Rate-Limit</code> can be used to tell the consumer how many requests they can make within a given time frame. <code>X-RateLimit-Remaining</code> can tell a consumer how many requests remain before they violate rate-limit enforcement. (There are many more, but you get the idea.) <code>X-&lt;anything&gt;</code> middleware headers can provide a lot of useful information to API consumers and hackers alike.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" id="Page_34" title="34"/>Encoding Data</h2>
<p class="BoxBodyFirst">As we touched upon in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, HTTP requests use encoding as a method to ensure that communications are handled properly. Various characters that can be problematic for the technologies used by the server are known as <em>bad characters</em>. One way of handling bad characters is to use an encoding scheme that formats the message in such a way as to remove them. Common encoding schemes include Unicode encoding, HTML encoding, URL encoding, and base64 encoding. XML typically uses one of two forms of Unicode encoding: UTF-8 or UTF-16.</p>
<p>When the string “hAPI hacker” is encoded in UTF-8, it becomes the following:</p>
<blockquote><p class="BoxExtractPara">\x68\x41\x50\x49\x20\x68\x61\x63\x6B\x65\x72</p></blockquote>
<p>Here is the UTF-16 version of the string:</p>
<blockquote><p class="BoxExtractPara">\u{68}\u{41}\u{50}\u{49}\u{20}\u{68}\u{61}\u{63}\u{6b}\u{65}\u{72}</p></blockquote>
<p>Finally, here is the base64-encoded version:</p>
<blockquote><p class="BoxExtractPara">aEFQSSBoYWNrZXI=</p></blockquote>
<p>Recognizing these encoding schemes will be useful as you begin examining requests and responses and encounter encoded data.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502444c02-0002">GraphQL</h3>
<p class="BodyFirst">Short for <em>Graph Query Language</em>, <em>GraphQL </em>is a specification for APIs that allow clients to define the structure of the data they want to request from the server. GraphQL is RESTful, as it follows the six constraints of REST APIs. However, GraphQL also takes the approach of being <em>query-centric</em>, because it is structured to function similarly to a database query language like Structured Query Language (SQL).</p>
<p>As you might gather from the specification’s name, GraphQL stores the resources in a graph data structure. To access a GraphQL API, you’ll typically access the URL where it is hosted and submit an authorized request that contains query parameters as the body of a POST request, similar to the following:</p>
<pre><code>query {
  users {
    username
    id
    email
  }
}</code></pre>
<p><span epub:type="pagebreak" id="Page_35" title="35"/>In the right context, this query would provide you with the usernames, IDs, and emails of the requested resources. A GraphQL response to this query would look like the following:</p>
<pre><code>{
  "data": {
    "users": {
      "username": "hapi_hacker",
      "id": 1111,
      "email": "hapihacker@email.com"
    }
  }
}</code></pre>
<p>GraphQL improves on typical REST APIs in several ways. Since REST APIs are resource based, there will likely be instances when a consumer needs to make several requests in order to get all the data they need. On the other hand, if a consumer only needs a specific value from the API provider, the consumer will need to filter out the excess data. With GraphQL, a consumer can use a single request to get the exact data they want. That’s because, unlike REST APIs, where clients receive whatever data the server is programmed to return from an endpoint, including the data they don’t need, GraphQL APIs let clients request specific fields from a resource.</p>
<p>GraphQL also uses HTTP, but it typically depends on a single entry point (URL) using the POST method. In a GraphQL request, the body of the POST request is what the provider processes. For example, take a look at the GraphQL request in <a href="#listing2-3" id="listinganchor2-3">Listing 2-3</a> and the response in <a href="#listing2-4" id="listinganchor2-4">Listing 2-4</a>, depicting a request to check a store’s inventory for graphics cards.</p>
<pre><code>POST /graphql HTTP/1.1
HOST: graphql-shop.com
Authorization: Bearer ab4dt0k3n

{query<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> {
  inventory<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> (item:"Graphics Card", id: 00101) {
name
fields<span aria-label="annotation3" class="CodeAnnotationCode">❸</span>{
price
quantity} } }
}</code></pre>
<p class="CodeListingCaption"><a id="listing2-3">Listing 2-3</a>: An example GraphQL request</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: application/json
Server: GraphqlServer

<span epub:type="pagebreak" id="Page_36" title="36"/>{
"data": { 
"inventory": { "name": "Graphics Card",
"fields":<span aria-label="annotation4" class="CodeAnnotationCode">❹</span>[
{
"price":"999.99"
"quantity": 25 } ] } }
}</code></pre>
<p class="CodeListingCaption"><a id="listing2-4">Listing 2-4</a>: An example GraphQL response</p>
<p>As you can see, a query payload in the body specifies the information needed. The GraphQL request body begins with the query operation <span aria-label="annotation1" class="CodeAnnotation">❶</span>, which is the equivalent of a GET request and used to obtain information from the API. The GraphQL node we are querying for, <code>"inventory"</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, is also known as the root query type. Nodes, similar to objects, are made up of fields <span aria-label="annotation3" class="CodeAnnotation">❸</span>, similar to key/value pairs in REST. The main difference here is that we can specify the exact fields we are looking for. In this example, we are looking for the “price” and “quantity” fields. Finally, you can see that the GraphQL response only provided the requested fields for the specified graphics card <span aria-label="annotation4" class="CodeAnnotation">❹</span>. Instead of getting the item ID, item name, and other superfluous information, the query resolved with only the fields that were needed.</p>
<p>If this had been a REST API, it might have been necessary to send requests to different endpoints to get the quantity and then the brand of the graphics card, but with GraphQL you can build out a query for the specific information you are looking for from a single endpoint.</p>
<p>GraphQL still functions using CRUD, which may sound confusing at first since it relies on POST requests. However, GraphQL uses three operations within the POST request to interact with GraphQL APIs: query, mutation, and subscription. <em>Query</em> is an operation to retrieve data (read). <em>Mutation</em> is an operation used to submit and write data (create, update, and delete). <em>Subscription</em> is an operation used to send data (read) when an event occurs. Subscription is a way for GraphQL clients to listen to live updates from the server.</p>
<p>GraphQL uses <em>schemas</em>, which are collections of the data that can be queried with the given service. Having access to the GraphQL schema is similar to having access to a REST API collection. A GraphQL schema will provide you with the information you’ll need in order to query the API.</p>
<p>You can interact with GraphQL using a browser if there is a GraphQL IDE, like GraphiQL, in place (see <a href="#figure2-2" id="figureanchor2-2">Figure 2-2</a>).</p>
<p>Otherwise, you’ll need a GraphQL client such as Postman, Apollo-Client, GraphQL-Request, GraphQL-CLI, or GraphQL-Compose. In later chapters, we’ll use Postman as our GraphQL client.</p>
<span epub:type="pagebreak" id="Page_37" title="37"/><figure>
<img alt="Screenshot of an interface with two windows: a left-hand window in which you can type GraphQL queries, and a right-hand window that populates with information about the GraphQL schema" class="keyline" src="image_fi/502444c02/F02002.png"/>
<figcaption><p><a id="figure2-2">Figure 2-2</a>: The GraphiQL interface for GitHub</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>SOAP: An Action-Oriented API Format</h2>
<p class="BoxBodyFirst"><em>Simple Object Access Protocol (SOAP)</em> is a type of action-oriented API that relies on XML. SOAP is one of the older web APIs, originally released as XML-RPC back in the late 1990s, so we won’t cover it in this book.</p>
<p>Although SOAP works over HTTP, SMTP, TCP, and UDP, it was primarily designed for use over HTTP. When SOAP is used over HTTP, the requests are all made using HTTP POST. For example, take a look at the following sample SOAP request:</p>
<pre><code>POST /Inventory HTTP/1.1
Host: www.soap-shop.com
Content-Type: application/soap+xml; charset=utf-8
Content-Length: nnn

&lt;?xml version="1.0"?&gt;

<span aria-label="annotation1" class="CodeAnnotationCode">❶</span>&lt;soap:Envelope
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span>xmlns:soap="http://www.w3.org/2003/05/soap-envelope/"
soap:encodingStyle="http://www.w3.org/2003/05/soap-encoding"&gt;

<span aria-label="annotation3" class="CodeAnnotationCode">❸</span>&lt;soap:Body xmlns:m="http://www.soap-shop.com/inventory"&gt;
  &lt;m:GetInventoryPrice&gt;
    &lt;m:InventoryName&gt;ThebestSOAP&lt;/m:InventoryName&gt;
  &lt;/m:GetInventoryPrice&gt;
&lt;/soap:Body&gt;

&lt;/soap:Envelope&gt;</code></pre>
<p>The corresponding SOAP response looks like this:</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: application/soap+xml; charset=utf-8
Content-Length: nnn

<span epub:type="pagebreak" id="Page_38" title="38"/>&lt;?xml version="1.0"?&gt;

&lt;soap:Envelope
xmlns:soap="http://www.w3.org/2003/05/soap-envelope/"
soap:encodingStyle="http://www.w3.org/2003/05/soap-encoding"&gt;

&lt;soap:Body xmlns:m="http://www.soap-shop.com/inventory"&gt;
<span aria-label="annotation4" class="CodeAnnotationCode">❹</span>&lt;soap:Fault&gt;
&lt;faultcode&gt;soap:VersionMismatch&lt;/faultcode&gt;
         &lt;faultstring, xml:lang='en"&gt;
            Name does not match Inventory record
         &lt;/faultstring&gt;
&lt;/soap:Fault&gt;
&lt;/soap:Body&gt;

&lt;/soap:Envelope&gt;</code></pre>
<p>SOAP API messages are made up of four parts: the envelope <span aria-label="annotation1" class="CodeAnnotation">❶</span> and header <span aria-label="annotation2" class="CodeAnnotation">❷</span>, which are necessary, and the body <span aria-label="annotation3" class="CodeAnnotation">❸</span> and fault <span aria-label="annotation4" class="CodeAnnotation">❹</span>, which are optional. The <em>envelope</em> is an XML tag at the beginning of a message that signifies that the message is a SOAP message. The <em>header</em> can be used to process a message; in this example, the <code>Content-Type</code> request header lets the SOAP provider know the type of content being sent in the POST request (<code>application/soap+xml</code>). Since APIs facilitate machine-to-machine communication, headers essentially form an agreement between the consumer and the provider concerning the expectations within the request. Headers are a way to ensure that the consumer and provider understand one another and are speaking the same language. The <em>body</em> is the primary payload of the XML message, meaning it contains the data sent to the application. The <em>fault</em> is an optional part of a SOAP response that can be used to provide error messaging.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502444c02-0003">REST API Specifications</h2>
<p class="BodyFirst">The variety of REST APIs has left room for other tools and standardizations to fill in some of the gaps.<em> API specifications</em>, or description languages, are frameworks that help organizations design their APIs, automatically create consistent human-readable documentation, and therefore help developers and users know what to expect regarding the API’s functionality and results. Without specifications, there would be little to no consistency between APIs. Consumers would have to learn how each API’s documentation was formatted and adjust their application to interact with each API.</p>
<p>Instead, a consumer can program their application to ingest different specifications and then easily interact with any API using that given specification. In other words, you can think of specifications as the home electric sockets of APIs. Instead of having a unique electric socket for every home appliance, the use of a single consistent format throughout a home allows you to buy a toaster and plug it into a socket on any wall without any hassle.</p>
<p><span epub:type="pagebreak" id="Page_39" title="39"/><em>OpenAPI Specification 3.0 (OAS)</em>, previously known as Swagger, is one of the leading specifications for RESTful APIs. OAS helps organize and manage APIs by allowing developers to describe endpoints, resources, operations, and authentication and authorization requirements. They can then create human- and machine-readable API documentation, formatted as JSON or YAML. Consistent API documentation is good for developers and users.</p>
<p>The <em>RESTful API Modeling Language (RAML)</em> is another way to consistently generate API documentation. RAML is an open specification that works exclusively with YAML for document formatting. Similar to OAS, RAML was designed to document, design, build, and test REST APIs. For more information about RAML, check out the raml-spec GitHub repo (<a class="LinkURL" href="https://github.com/raml-org/raml-spec">https://github.com/raml-org/raml-spec</a>).</p>
<p>In later chapters, we will use an API client called Postman to import specifications and get instant access to the capabilities of an organization’s APIs.</p>
<h2 id="h1-502444c02-0004">API Data Interchange Formats</h2>
<p class="BodyFirst">APIs use several formats to facilitate the exchange of data. Additionally, specifications use these formats to document APIs. Some APIs, like SOAP, require a specific format, whereas others allow the client to specify the format to use in the request and response body. This section introduces three common formats: JSON, XML, and YAML. Familiarity with data interchange formats will help you recognize API types, what the APIs are doing, and how they handle data.</p>
<h3 id="h2-502444c02-0003">JSON</h3>
<p class="BodyFirst"><em>JavaScript Object Notation (JSON)</em> is the primary data interchange format we’ll use throughout this book, as it is widely used for APIs. It organizes data in a way that is both human-readable and easily parsable by applications; many programming languages can turn JSON into data types they can use.</p>
<p>JSON represents objects as key/value pairs separated by commas, within a pair of curly brackets, as follows:</p>
<pre><code>{
  "firstName": "James",
  "lastName": "Lovell",
  "tripsToTheMoon": 2,
  "isAstronaut": true,
  "walkedOnMoon": false,
  "comment" : "This is a comment",
  "spacecrafts": ["Gemini 7", "Gemini 12", "Apollo 8", "Apollo 13"],
  "book": [
    {
      "title": "Lost Moon",
      "genre": "Non-fiction"
    }
  ]
}</code></pre>
<p><span epub:type="pagebreak" id="Page_40" title="40"/>Everything between the first curly bracket and the last is considered an object. Within the object are several key/value pairs, such as <code>"firstName": "James"</code>, <code>"lastName": "Lovell"</code>, and <code>"tripsToTheMoon": 2</code>. The first entry of the key/value pair (on the left) is the <em>key</em>, a string that describes the value pair, and the second is the <em>value</em> (on the right), which is some sort of data represented by one of the acceptable data types (strings, numbers, Boolean values, null, an array, or another object). For example, notice the Boolean value <code>false</code> for <code>"walkedOnMoon"</code> or the <code>"spacecrafts"</code> array surrounded by square brackets. Finally, the nested object <code>"book"</code> contains its own set of key/value pairs. <a href="#table2-1" id="tableanchor2-1">Table 2-1</a> describes JSON types in more detail.</p>
<p>JSON does not allow inline comments, so any sort of comment-like communications must take place as a key/value pair like <code>"comment" : "This is a comment"</code>. Alternatively, you can find comments in the API documentation or HTTP response.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-1">Table 2-1</a>: JSON Types</p></figcaption>
<table border="1" id="table-502444c02-0002">
<thead>
<tr>
<td><b>Type</b></td>
<td><b>Description</b></td>
<td><b>Example</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Strings</td>
<td>Any combination of characters within double quotes.</td>
<td><code>{</code><br/>
<code>"Motto":"Hack the planet",</code><br/>
<code>"Drink":"Jolt",</code><br/>
<code>"User”:"Razor"</code><br/>
<code>}</code></td>
</tr>
<tr>
<td>Numbers</td>
<td>Basic integers, fractions, negative numbers, and exponents. Notice that the multiple items are comma-separated.</td>
<td><code>{</code><br/>
<code>"number_1" : 101,</code><br/>
<code>"number_2" : -102,</code><br/>
<code>"number_3" : 1.03,</code><br/>
<code>"number_4" : 1.0E+4</code><br/>
<code>}</code></td>
</tr>
<tr>
<td>Boolean values</td>
<td>Either <code>true</code> or <code>false</code>.</td>
<td><code>{</code><br/>
<code>"admin" : false,</code><br/>
<code>"privesc" : true</code><br/>
<code>}</code></td>
</tr>
<tr>
<td>Null</td>
<td>No value.</td>
<td><code>{</code><br/>
<code>"value" : null</code><br/>
<code>}</code></td>
</tr>
<tr>
<td>Arrays</td>
<td>An ordered collection of values. Collections of values are surrounded by brackets (<code>[]</code>) and the values are comma-separated.</td>
<td><code>{</code><br/>
<code>"uid" : ["1","2","3"]</code><br/>
<code>}</code></td>
</tr>
<tr>
<td>Objects</td>
<td>An unordered set of value pairs inserted between curly brackets (<code>{}</code>). An object can contain multiple key/value pairs.</td>
<td><code>{</code><br/>
<code>"admin" : false,</code><br/>
<code>"key" : "value",</code><br/>
<code>"privesc" : true,</code><br/>
<code>"uid" : 101,</code><br/>
<code>"vulnerabilities" : "galore"</code><br/>
<code>}</code></td>
</tr>
</tbody>
</table>
</figure>
<p>To illustrate these types, take a look at the following key/value pairs in the JSON data found in a Twitter API response:</p>
<pre><code><span epub:type="pagebreak" id="Page_41" title="41"/>{
"id":1278533978970976256, <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
"id_str":"1278533978970976256", <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
"full_text":"1984: William Gibson published his debut novel, Neuromancer. It's a cyberpunk tale about Henry Case, a washed up computer hacker who's offered a chance at redemption by a mysterious dude named Armitage. Cyberspace. Hacking. Virtual reality. The matrix. Hacktivism. A must read. https:\/\/t.co\/R9hm2LOKQi",
"truncated":false <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
}</code></pre>
<p>In this example, you should be able to identify the number <code>1278533978970976256</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span>, strings like those for the keys <code>"id_str"</code> and <code>"full_text"</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, and the Boolean value <span aria-label="annotation3" class="CodeAnnotation">❸</span> for <code>"truncated"</code>.</p>
<h3 id="h2-502444c02-0004">XML</h3>
<p class="BodyFirst">The<em> Extensible Markup Language (XML)</em> format has been around for a while, and you’ll probably recognize it. XML is characterized by the descriptive tags it uses to wrap data. Although REST APIs can use XML, it is most commonly associated with SOAP APIs. SOAP APIs can only use XML as the data interchange.</p>
<p>The Twitter JSON you just saw would look like the following if converted to XML:</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt; <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
&lt;root&gt; <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
    &lt;id&gt;1278533978970976300&lt;/id&gt;
  &lt;id_str&gt;1278533978970976256&lt;/id_str&gt;
  &lt;full_text&gt;1984: William Gibson published his debut novel, Neuromancer. It&amp;#x27;s a cyberpunk tale about Henry Case, a washed up computer hacker who&amp;#x27;s offered a chance at redemption by a mysterious dude named Armitage. Cyberspace. Hacking. Virtual reality. The matrix. Hacktivism. A must read. https://t.co/R9hm2LOKQi &lt;/full_text&gt;
  &lt;truncated&gt;false&lt;/truncated&gt;
&lt;/root&gt;</code></pre>
<p>XML always begins with a <em>prolog</em>, which contains information about the XML version and encoding used <span aria-label="annotation1" class="CodeAnnotation">❶</span>.</p>
<p>Next, <em>elements </em>are the most basic parts of XML. An element is any XML tag or information surrounded by tags. In the previous example, <code>&lt;id&gt;1278533978970976300&lt;/id&gt;</code>, <code>&lt;id_str&gt;1278533978&lt;/id_str&gt;</code>, <code>&lt;full_text&gt;</code>, <code>&lt;/full_text&gt;</code>, and <code>&lt;truncated&gt;false&lt;/truncated&gt;</code> are all elements. XML must have a root element and can contain child elements. In the example, the root element is <code>&lt;root&gt;</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The child elements are XML attributes. An example of a child element is the <code>&lt;BookGenre&gt;</code> element within the following example:</p>
<pre><code><code>&lt;LibraryBooks&gt;</code>
 <code>&lt;BookGenre&gt;SciFi&lt;/BookGenre&gt;</code>
<code>&lt;/LibraryBooks&gt;</code></code></pre>
<p>Comments in XML are surrounded by two dashes, like this: <code>&lt;!--XML comment example--&gt;</code>.</p>
<p><span epub:type="pagebreak" id="Page_42" title="42"/>The key differences between XML and JSON are JSON’s descriptive tags, character encoding, and length: the XML takes much longer to convey the same information, a whopping 565 bytes.</p>
<h3 id="h2-502444c02-0005">YAML</h3>
<p class="BodyFirst">Another lightweight form of data exchange used in APIs, <em>YAML</em> is a recursive acronym that stands for <em>YAML Ain’t Markup Language</em>. It was created as a more human- and computer-readable format for data exchange.</p>
<p>Like JSON, YAML documents contain key/value pairs. The value may be any of the YAML data types, which include numbers, strings, Booleans, null values, and sequences. For example, take a look at the following YAML data:</p>
<pre><code>---
id: 1278533978970976300
id_str: 1278533978970976256
#Comment about Neuromancer
full_text: "1984: William Gibson published his debut novel, Neuromancer. It's a cyberpunk tale about Henry Case, a washed up computer hacker who's offered a chance at redemption by a mysterious dude named Armitage. Cyberspace. Hacking. Virtual reality. The matrix. Hacktivism. A must read. https://t.co/R9hm2LOKQi"
truncated: false
...</code></pre>
<p>You’ll notice that YAML is much more readable than JSON. YAML documents begin with</p>
<pre><code><code>---</code></code></pre>
<p class="BodyContinued">and end with</p>
<pre><code><code>...</code></code></pre>
<p class="BodyContinued">instead of with curly brackets. Also, quotes around strings are optional. Additionally, URLs don’t need to be encoded with backslashes. Finally, YAML uses indentation instead of curly brackets to represent nesting and allows for comments beginning with <code>#</code>.</p>
<p>API specifications will often be formatted as JSON or YAML, because these formats are easy for humans to digest. With only a few basic concepts in mind, we can look at either of these formats and understand what is going on; likewise, machines can easily parse the information.</p>
<p>If you’d like to see more YAML in action, visit <a class="LinkURL" href="https://yaml.org">https://yaml.org</a>. The entire website is presented in YAML format. YAML is recursive all the way down.</p>
<h2 id="h1-502444c02-0005">API Authentication</h2>
<p class="BodyFirst">APIs may allow public access to consumers without authentication, but when an API allows access to proprietary or sensitive data, it will use some form of authentication and authorization. An API’s authentication process should validate that users are who they claim to be, and the authorization <span epub:type="pagebreak" id="Page_43" title="43"/>process should grant them the ability to access the data they are allowed to access. This section covers a variety of API authentication and authorization methods. These methods vary in complexity and security, but they all operate on a common principle: the consumer must send some kind of information to the provider when making a request, and the provider must link that information to a user before granting or denying access to a resource.</p>
<p>Before jumping into API authentication, it is important to understand what authentication is. Authentication is the process of proving and verifying an identity. In a web application, authentication is the way you prove to the web server that you are a valid user of said web app. Typically, this is done through the use of credentials, which consist of a unique ID (such as a username or email) and password. After a client sends credentials, the web server compares what was sent to the credentials it has stored. If the credentials provided match the credentials stored, the web server will create a user session and issue a cookie to the client.</p>
<p>When the session ends between the web app and user, the web server will destroy the session and remove the associated client cookies.</p>
<p>As described earlier in this chapter, REST and GraphQL APIs are stateless, so when a consumer authenticates to these APIs, no session is created between the client and server. Instead, the API consumer must prove their identity within every request sent to the API provider’s web server.</p>
<h3 id="h2-502444c02-0006">Basic Authentication</h3>
<p class="BodyFirst">The simplest form of API authentication is <em>HTTP basic authentication</em>, in which the consumer includes their username and password in a header or the body of a request. The API could either pass the username and password to the provider in plaintext, like <code>username:password</code>, or it could encode the credentials using something like base64 to save space (for example, as <code>dXNlcm5hbWU6cGFzc3dvcmQK</code>).</p>
<p>Encoding is not encryption, and if base64-encoded data is captured, it can easily be decoded. For example, you can use the Linux command line to base64-encode <code>username:password</code> and then decode the encoded result:</p>
<pre><code>$ <b>echo "username:password"|base64</b>
dXNlcm5hbWU6cGFzc3dvcmQK
$ <b>echo "dXNlcm5hbWU6cGFzc3dvcmQK"|base64 -d</b>
username:password</code></pre>
<p>As you can see, basic authentication has no inherent security and completely depends on other security controls. An attacker can compromise basic authentication by capturing HTTP traffic, performing a man-in-the-middle attack, tricking the user into providing their credentials through social engineering tactics, or performing a brute-force attack in which they attempt various usernames and passwords until they find some that work.</p>
<p>Since APIs are often stateless, those using only basic authentication require the consumer to provide credentials in every request. It is common for an API provider to instead use basic authentication once, for the first request, and then issue an API key or some other token for all other requests.</p>
<h3 id="h2-502444c02-0007"><span epub:type="pagebreak" id="Page_44" title="44"/>API Keys</h3>
<p class="BodyFirst"><em>API keys</em> are unique strings that API providers generate and grant to authorize access for approved consumers. Once an API consumer has a key, they can include it in requests whenever specified by the provider. The provider will typically require that the consumer pass the key in query string parameters, request headers, body data, or as a cookie when they make a request.</p>
<p>API keys typically look like semi-random or random strings of numbers and letters. For example, take a look at the API key included in the query string of the following URL:</p>
<pre><code>/api/v1/users?apikey=<b>ju574n3x4mpl34p1k3y</b></code></pre>
<p>The following is an API key included as a header:</p>
<pre><code>"API-Secret": <b>"17813fg8-46a7-5006-e235-45be7e9f2345"</b></code></pre>
<p>Finally, here is an API key passed in as a cookie:</p>
<pre><code>Cookie: API-Key= <b>4n07h3r4p1k3y</b></code></pre>
<p>The process of acquiring an API key depends on the provider. The NASA API, for example, requires the consumer to register for the API with a name, email address, and optional application URL (if the user is programming an application to use the API), as shown in <a href="#figure2-3" id="figureanchor2-3">Figure 2-3</a>.</p>
<figure>
<img alt="Screenshot of an online form for Generating an API key. Includes fields for First Name, Last Name, Email, and Application URL." class="keyline" src="image_fi/502444c02/F02003.png"/>
<figcaption><p><a id="figure2-3">Figure 2-3</a>: NASA’s form to generate an API key</p></figcaption>
</figure>
<p>The resulting key will look something like this:</p>
<blockquote class="review">
<p class="Blockquote"><code>roS6SmRjLdxZzrNSAkxjCdb6WodSda2G9zc2Q7sK</code></p></blockquote>
<p>It must be passed as a URL parameter in each API request, as follows:</p>
<blockquote class="review">
<p class="Blockquote"><em>api.nasa.gov/planetary/apod?api_key=roS6SmRjLdxZzrNSAkxjCdb6WodSda2G9zc2Q7sK</em></p></blockquote>
<p>API keys can be more secure than basic authentication for several reasons. When keys are sufficiently long, complex, and randomly generated, they can be exceedingly difficult for an attacker to guess or brute-force. <span epub:type="pagebreak" id="Page_45" title="45"/>Additionally, providers can set expiration dates to limit the length of time for which the keys are valid.</p>
<p>However, API keys have several associated risks that we will take advantage of later in this book. Since each API provider may have their own system for generating API keys, you’ll find instances in which the API key is generated based on user data. In these cases, API hackers may guess or forge API keys by learning about the API consumers. API keys may also be exposed to the internet in online repositories, left in code comments, intercepted when transferred over unencrypted connections, or stolen through phishing.</p>
<h3 id="h2-502444c02-0008">JSON Web Tokens</h3>
<p class="BodyFirst">A <em>JSON Web Token (JWT)</em> is a type of token commonly used in API token-based authentication. It’s used like this: The API consumer authenticates to the API provider with a username and password. The provider generates a JWT and sends it back to the consumer. The consumer adds the provided JWT to the <code>Authorization</code> header in all API requests.</p>
<p>JWTs consist of three parts, all of which are base64-encoded and separated by periods: the header, the payload, and the signature. The <em>header</em> includes information about the algorithm used to sign the payload. The <em>payload</em> is the data included within the token, such as a username, timestamp, and issuer. The <em>signature</em> is the encoded and encrypted message used to validate the token.</p>
<p><a href="#table2-2" id="tableanchor2-2">Table 2-2</a> shows an example of these parts, unencoded for readability, as well as the final token.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The signature field is not a literal encoding of <code>HMACSHA512</code><code>...</code>; rather, the signature is created by calling the encryption function <code>HMACSHA512()</code>, specified by <code>"</code><code>alg</code><code>"</code><code>: </code><code>"</code><code>HS512</code><code>"</code>, on the encoded header and payload, and then encoding the result.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<figure>
<figcaption class="TableTitle"><p><a id="table2-2">Table 2-2</a>: JWT Components</p></figcaption>
<table border="1" id="table-502444c02-0003">
<thead>
<tr>
<td><b>Component</b></td>
<td><b>Content</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Header</td>
<td><code>{</code><br/>
<code>  "alg": "HS512",</code><br/>
<code>  "typ": "JWT"</code><br/>
<code>}</code></td>
</tr>
<tr>
<td>Payload</td>
<td><code>{</code><br/>
<code>  "sub": "1234567890",</code><br/>
<code>  "name": "hAPI Hacker",</code><br/>
<code>  "iat": 1516239022</code><br/>
<code>}</code></td>
</tr>
<tr>
<td>Signature</td>
<td><code>HMACSHA512(</code><br/>
<code>  base64UrlEncode(header) + "." +</code><br/>
<code>  base64UrlEncode(payload),</code><br/>
<code>SuperSecretPassword</code><br/>
<code>)</code></td>
</tr>
<tr>
<td>JWT</td>
<td><code style="overflow-wrap: break-word; word-break:break-all;">
eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImhBUEkgSGFja2VyIiwiaWF0IjoxNTE2MjM5MDIyfQ.zsUjGDbBjqI-bJbaUmvUdKaGSEvROKfNjy9K6TckK55sd97AMdPDLxUZwsneff4O1ZWQikhgPm7HHlXYn4jm0Q</code></td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" id="Page_46" title="46"/>JWTs are generally secure but can be implemented in ways that will compromise that security. API providers can implement JWTs that do not use encryption, which means you would be one base64 decode away from being able to see what is inside the token. An API hacker could decode such a token, tamper with the contents, and send it back to the provider to gain access, as you will see in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>. The JWT secret key may also be stolen or guessed by brute force.</p>
<h3 id="h2-502444c02-0009">HMAC</h3>
<p class="BodyFirst">A <em>hash-based message authentication code (HMAC)</em> is the primary API authentication method used by Amazon Web Services (AWS). When using HMAC, the provider creates a secret key and shares it with consumer. When a consumer interacts with the API, an HMAC hash function is applied to the consumer’s API request data and secret key. The resulting hash (also called a <em>message digest</em>) is added to the request and sent to the provider. The provider calculates the HMAC, just as the consumer did, by running the message and key through the hash function, and then compares the output hash value to the value provided by the client. If the provider’s hash value matches the consumer’s hash value, the consumer is authorized to make the request. If the values do not match, either the client’s secret key is incorrect or the message has been tampered with.</p>
<p>The security of the message digest depends on the cryptographic strength of the hash function and secret key. Stronger hash mechanisms typically produce longer hashes. <a href="#table2-3" id="tableanchor2-3">Table 2-3</a> shows the same message and key hashed by different HMAC algorithms.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-3">Table 2-3</a>: HMAC Algorithms</p></figcaption>
<table border="1" id="table-502444c02-0004">
<thead>
<tr>
<td><b>Algorithm</b></td>
<td><b>Hash output</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>HMAC-MD5</td>
<td>f37438341e3d22aa11b4b2e838120dcf</td>
</tr>
<tr>
<td>HMAC-SHA1</td>
<td>4c2de361ba8958558de3d049ed1fb5c115656e65</td>
</tr>
<tr>
<td>HMAC-SHA256</td>
<td><span style="white-space: pre-wrap;overflow-wrap: break-word; word-break:break-all;">be8e73ffbd9a953f2ec892f06f9a5e91e6551023d1942ec7994fa1a78a5ae6bc</span></td>
</tr>
<tr>
<td>HMAC-SHA512</td>
<td style="width:50%;"><span style="white-space: pre-wrap;overflow-wrap: break-word; word-break:break-all;">6434a354a730f888865bc5755d9f498126d8f67d73f32ccd2b775c47c91ce26b66dfa59c25aed7f4a6bcb4786d3a3c6130f63ae08367822af3f967d3a7469e1b</span></td>
</tr>
</tbody>
</table>
</figure>
<p>You may have some red flags regarding the use of SHA1 or MD5. As of the writing of this book, there are currently no known vulnerabilities affecting HMAC-SHA1 and HMAC-MD5, but these functions are cryptographically weaker than SHA-256 and SHA-512. However, the more secure functions are also slower. The choice of which hash function to use comes down to prioritizing either performance or security.</p>
<p>As with the previous authentication methods covered, the security of HMAC depends on the consumer and provider keeping the secret key private. If a secret key is compromised, an attacker could impersonate the victim and gain unauthorized access to the API.</p>
<h3 id="h2-502444c02-0010"><span epub:type="pagebreak" id="Page_47" title="47"/>OAuth 2.0</h3>
<p class="BodyFirst"><em>OAuth 2.0</em>, or just <em>OAuth</em>, is an authorization standard that allows different services to access each other’s data, often using APIs to facilitate the service-to-service communications.</p>
<p>Let’s say you want to automatically share your Twitter tweets on LinkedIn. In OAuth’s model, we would consider Twitter to be the service provider and LinkedIn to be the application or client. In order to post your tweets, LinkedIn will need authorization to access your Twitter information. Since both Twitter and LinkedIn have implemented OAuth, instead of providing your credentials to the service provider and consumer every time you want to share this information across platforms, you can simply go into your LinkedIn settings and authorize Twitter. Doing so will send you to <em>api.twitter.com</em> to authorize LinkedIn to access your Twitter account (see <a href="#figure2-4" id="figureanchor2-4">Figure 2-4</a>).</p>
<figure>
<img alt="Screenshot of a Twitter web page asking if you want to authorize LinkedIn to access your account. Includes Authorize app and Cancel buttons." class="keyline" src="image_fi/502444c02/F02004.png"/>
<figcaption><p><a id="figure2-4">Figure 2-4</a>: LinkedIn–Twitter OAuth authorization request</p></figcaption>
</figure>
<p>When you authorize LinkedIn to access your Twitter posts, Twitter generates a limited, time-based access token for LinkedIn. LinkedIn then provides that token to Twitter to post on your behalf, and you don’t have to give LinkedIn your Twitter credentials.</p>
<p><a href="#figure2-5" id="figureanchor2-5">Figure 2-5</a> shows the general OAuth process. The user (<em>resource owner</em>) grants an application (the <em>client</em>) access to a service (the <em>authorization server</em>), the service creates a token, and then the application uses the token to exchange data with the service (also the <em>resource server</em>).</p>
<p>In the LinkedIn–Twitter example, you are the resource owner, LinkedIn is the application/client, and Twitter is the authorization server and resource server.</p>
<span epub:type="pagebreak" id="Page_48" title="48"/><figure>
<img alt="Diagram showing the communications between LinkedIn and Twitter during the OAuth authorization process. Includes the following steps: 1) Authorization request (from LinkedIn to the user), 2) Authorization grant (from the user to LinkedIn), 3) Authorization grant (from LinkedIn to the user), 4) Access token (from the authorization server to LinkedIn), 5) Access token (from LinkedIn to the resource server), and 6) Protected resource (from the resource server to LinkedIn)." class="" src="image_fi/502444c02/F02005.png"/>
<figcaption><p><a id="figure2-5">Figure 2-5</a>: An illustration of the OAuth process</p></figcaption>
</figure>
<p>OAuth is one of the most trusted forms of API authorization. However, while it adds security to the authorization process, it also expands the potential attack surface—although flaws often have more to do with how the API provider implements OAuth than with OAuth itself. API providers that poorly implement OAuth can expose themselves to a variety of attacks such as token injection, authorization code reuse, cross-site request forgery, invalid redirection, and phishing.</p>
<h3 id="h2-502444c02-0011">No Authentication</h3>
<p class="BodyFirst">As in web applications generally, there are plenty of instances where it is valid for an API to have no authentication at all. If an API does not handle sensitive data and only provides public information, the provider could make the case that no authentication is necessary.</p>
<h2 id="h1-502444c02-0006">APIs in Action: Exploring Twitter’s API</h2>
<p class="BodyFirst">After reading this and the previous chapter, you should understand the various components running beneath the GUI of a web application. Let’s now make these concepts more concrete by taking a close look at Twitter’s API. If you open a web browser and visit the URL <a class="LinkURL" href="https://twitter.com">https://twitter.com</a>, the initial request triggers a series of communications between the client and the server. Your browser automatically orchestrates these data transfers, but by using a web proxy like Burp Suite, which we’ll set up in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, you can see all the requests and responses in action.</p>
<p>The communications begin with the typical kind of HTTP traffic described in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>:</p>
<ol class="decimal">
<li value="1">Once you’ve entered a URL into your browser, the browser automatically submits an HTTP GET request to the web server at <em>twitter.com</em>:
<pre><code><span epub:type="pagebreak" id="Page_49" title="49"/>GET / HTTP/1.1
Host: twitter.com
User-Agent: Mozilla/5.0
Accept: text/html
<var>--snip--</var>
Cookie: [...]</code></pre></li>
<li value="2">The Twitter web application server receives the request and responds to the GET request by issuing a successful 200 OK response:
<pre><code>HTTP/1.1 200 OK
cache-control: no-cache, no-store, must-revalidate
connection: close
content-security-policy: content-src 'self'
content-type: text/html; charset=utf-8
server: tsa_a
<var>--snip--</var>
x-powered-by: Express
x-response-time: 56

&lt;!DOCTYPE html&gt;
&lt;html dir="ltr" lang="en"&gt;
<var>--snip--</var></code></pre>
<p class="ListBody">This response header contains the status of the HTTP connection, client instructions, middleware information, and cookie-related information. <em>Client instructions</em> tell the browser how to handle the requested information, such as caching data, the content security policy, and instructions about the type of content that was sent. The actual payload begins just below <code>x-response-time</code>; it provides the browser with the HTML needed to render the web page.</p>
<p class="ListBody">Now imagine that the user looks up “hacking” using Twitter’s search bar. This kicks off a POST request to Twitter’s API, as shown next. Twitter is able to leverage APIs to distribute requests and seamlessly provide requested resources to many users.</p>
<pre><code>POST /1.1/jot/client_event.json?q=hacking HTTP/1.1
Host: api.twitter.com
User-Agent: Mozilla/5.0
<var>--snip--</var>
Authorization: Bearer AAAAAAAAAAAAAAAAA...
<var>--snip--</var></code></pre>
<p class="ListBody">This POST request is an example of the Twitter API querying the web service at <em>api.twitter.com</em> for the search term “hacking.” The Twitter API <span epub:type="pagebreak" id="Page_50" title="50"/>responds with JSON containing the search results, which includes tweets and information about each tweet such as user mentions, hashtags, and post times:</p>
<pre><code>"created_at": [...]
"id":1278533978970976256
"id_str": "1278533978970976256"
"full-text": "1984: William Gibson published his debut novel..."
"truncated":false,
<var>--snip--</var></code></pre>
<p class="ListBody">The fact that the Twitter API seems to adhere to CRUD, API naming conventions, tokens for authorization, <em>application/x-www-form-urlencoded</em>, and JSON as a data interchange makes it pretty clear that this API is a RESTful API.</p>
<p class="ListBody">Although the response body is formatted in a legible way, it’s meant to be processed by the browser to be displayed as a human-readable web page. The browser renders the search results using the string from the API request. The provider’s response then populates the page with search results, images, and social media–related information such as likes, retweets, comments (see <a href="#figure2-6" id="figureanchor2-6">Figure 2-6</a>).</p></li>
</ol>
<figure>
<img alt="Screenshot of a Twitter search for the word “hacking”" class="" src="image_fi/502444c02/F02006.png"/>
<figcaption><p><a id="figure2-6">Figure 2-6</a>: The rendered result from the Twitter API search request</p></figcaption>
</figure>
<p>From the end user’s perspective, the whole interaction appears seamless: you click the search bar, type in a query, and receive the results.</p>
<h2 id="h1-502444c02-0007"><span epub:type="pagebreak" id="Page_51" title="51"/>Summary</h2>
<p class="BodyFirst">In this chapter, we covered the terminology, parts, types, and supporting architecture of APIs. You learned that APIs are interfaces for interacting with web applications. Different types of APIs have different rules, functions, and purposes, but they all use some kind of format for exchanging data between applications. They often use authentication and authorization schemes to make sure consumers can access only the resources they’re supposed to.</p>
<p>Understanding these concepts will prepare you to confidently strike at the components that make up APIs. As you continue to read, refer to this chapter if you encounter API concepts that confuse you.</p>
</section>
</body>
</html>