- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FUNCTION-HOOKING
    DLLS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">函数钩取
    DLL</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Of all the components included in modern endpoint security products, the most
    widely deployed are DLLs responsible for function *hooking*, or interception.
    These DLLs provide defenders with a large amount of important information related
    to code execution, such as the parameters passed to a function of interest and
    the values it returns. Today, vendors largely use this data to supplement other,
    more robust sources of information. Still, function hooking is an important component
    of EDRs. In this chapter, we’ll discuss how EDRs most commonly intercept function
    calls and what we, as attackers, can do to interfere with them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代终端安全产品的所有组件中，最广泛部署的是负责函数 *钩取*（hooking）或拦截的 DLL。这些 DLL 为防御者提供了大量与代码执行相关的重要信息，如传递给感兴趣函数的参数以及函数返回的值。如今，供应商主要使用这些数据来补充其他更强大的信息来源。尽管如此，函数钩取仍然是
    EDR（端点检测与响应）系统的重要组成部分。在本章中，我们将讨论 EDR 系统最常见的函数调用拦截方式，以及作为攻击者的我们可以做些什么来干扰它们。
- en: This chapter focuses heavily on the hooking of functions in a Windows file called
    *ntdll.dll*, whose functionality we’ll cover shortly, but modern EDRs hook other
    Windows functions too. The process of implementing these other hooks closely resembles
    the workflow described in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论 Windows 文件 *ntdll.dll* 中函数的钩取，我们将在稍后介绍其功能，但现代 EDR 系统也钩取其他 Windows 函数。这些其他钩取的实现过程与本章描述的工作流程非常相似。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Function Hooking Works</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">函数钩取的工作原理</samp>
- en: To understand how endpoint security products use code hooking, you must understand
    how code running in user mode interacts with the kernel. This code typically leverages
    the Win32 API during execution to perform certain functions on the host, such
    as requesting a handle to another process. However, in many cases, the functionality
    provided via Win32 can’t be completed entirely in user mode. Some actions, such
    as memory and object management, are the responsibility of the kernel.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解终端安全产品如何使用代码钩取，你必须了解用户模式中的代码如何与内核交互。这些代码通常在执行期间利用 Win32 API 来执行主机上的某些功能，例如请求打开另一个进程的句柄。然而，在许多情况下，通过
    Win32 提供的功能无法完全在用户模式下完成。一些操作，如内存和对象管理，是由内核负责的。
- en: To transfer execution to the kernel, x64 systems use a syscall instruction.
    But rather than implementing syscall instructions in every function that needs
    to interact with the kernel, Windows provides them via functions in *ntdll.dll*.
    A function simply needs to pass the required parameters to this exported function;
    the function will, in turn, pass control into the kernel and then return the results
    of the operation. For example, [Figure 2-1](#fig2-1) demonstrates the execution
    flow that occurs when a user-mode application calls the Win32 API function <samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!OpenProcess()</samp>.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将执行控制转交给内核，x64 系统使用系统调用指令（syscall）。但 Windows 并不在每个需要与内核交互的函数中实现系统调用指令，而是通过
    *ntdll.dll* 中的函数提供它们。一个函数只需将所需的参数传递给这个导出的函数；该函数会将控制权传递给内核，然后返回操作结果。例如，[图 2-1](#fig2-1)
    展示了用户模式应用程序调用 Win32 API 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!OpenProcess()</samp>
    时的执行流程。
- en: '![](../images/Figure2-1.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The flow of execution
    from user mode to kernel mode</samp>'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-1：从用户模式到内核模式的执行流程</samp>
- en: To detect malicious activity, vendors often hook these Windows APIs. For example,
    one way that EDRs detect remote process injection is to hook the functions responsible
    for opening a handle to another process, allocating a region of memory, writing
    to the allocated memory, and creating the remote thread.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测恶意活动，供应商通常会钩取这些 Windows API。例如，EDR 系统检测远程进程注入的一种方式是钩取负责打开另一个进程句柄、分配内存区域、写入分配的内存以及创建远程线程的函数。
- en: In earlier versions of Windows, vendors (and malware authors) often placed their
    hooks on the System Service Dispatch Table (SSDT), a table in the kernel that
    holds the pointers to the kernel functions used upon invocation of a syscall.
    Security products would overwrite these function pointers with pointers to functions
    in their own kernel module used to log information about the function call and
    then execute the target function. They would then pass the return values back
    to the source application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本的 Windows 中，供应商（和恶意软件作者）经常将他们的钩子放置在系统服务调度表（SSDT）上，这是一个在内核中保存指向内核函数的指针的表格，当进行系统调用时会调用这些函数。安全产品会将这些函数指针覆盖为指向它们自己内核模块中用于记录函数调用信息的函数的指针，然后执行目标函数。然后，它们会将返回值传递回源应用程序。
- en: With the introduction of Windows XP in 2005, Microsoft made the decision to
    prevent the patching of SSDT, among a host of other critical structures, using
    a protection called Kernel Patch Protection (KPP), also known as PatchGuard, so
    this technique is not viable on modern 64-bit Windows versions. This means that
    traditional hooking must be done in user mode. Because the functions performing
    the syscalls in *ntdll.dll* are the last possible place to observe API calls in
    user mode, EDRs will often hook these functions in order to inspect their invocation
    and execution. Some commonly hooked functions are detailed in [Table 2-1](#tab2-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 2005 年 Windows XP 的推出，微软决定通过一种名为内核补丁保护（KPP），也称为 PatchGuard，来防止对 SSDT 等重要结构进行打补丁，因此这种技术在现代
    64 位 Windows 版本上不可行。这意味着传统的钩子函数必须在用户模式下执行。因为在 *ntdll.dll* 中执行系统调用的函数是观察用户模式下 API
    调用的最后一个可能位置，EDR（端点检测与响应）通常会钩住这些函数，以检查它们的调用和执行。某些常见的钩子函数在 [表 2-1](#tab2-1) 中有详细介绍。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">Commonly
    Hooked Functions in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ntdll.dll</samp>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-1：</samp> <samp class="SANS_Futura_Std_Book_11">ntdll.dll
    中常见的钩子函数</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ntdll.dll</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Function names</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Related
    attacker techniques</samp> |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">函数名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">相关的攻击者技术</samp>
    |'
- en: '| --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcessNtAllocateVirtualMemory</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>
    | <samp class="SANS_Futura_Std_Book_11">Remote process injection</samp> |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcessNtAllocateVirtualMemory</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>
    | <samp class="SANS_Futura_Std_Book_11">远程过程注入</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSuspendThreadNtResumeThread</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp> | <samp class="SANS_Futura_Std_Book_11">Shellcode
    injection via asynchronous procedure call (APC)</samp> |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSuspendThreadNtResumeThread</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp> | <samp class="SANS_Futura_Std_Book_11">通过异步过程调用（APC）进行
    Shellcode 注入</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSectionNtMapViewOfSection</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp> | <samp
    class="SANS_Futura_Std_Book_11">Shellcode injection via mapped memory sections</samp>
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSectionNtMapViewOfSection</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp> | <samp
    class="SANS_Futura_Std_Book_11">通过映射内存区段进行 Shellcode 注入</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp> | <samp
    class="SANS_Futura_Std_Book_11">Driver loading using a configuration stored in
    the registry</samp> |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp> | <samp
    class="SANS_Futura_Std_Book_11">使用存储在注册表中的配置加载驱动程序</samp> |'
- en: By intercepting calls to these APIs, an EDR can observe the parameters passed
    to the original function, as well as the value returned to the code that called
    the API. Agents can then examine this data to determine whether the activity was
    malicious. For example, to detect remote process injection, an agent could monitor
    whether the region of memory was allocated with read-write-execute permissions,
    whether data was written to the new allocation, and whether a thread was created
    using a pointer to the written data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拦截对这些 API 的调用，EDR 可以观察传递给原始函数的参数，以及返回给调用 API 的代码的值。然后，代理可以检查这些数据，以确定活动是否为恶意行为。例如，要检测远程进程注入，代理可以监视内存区域是否分配了读写执行权限，是否向新分配的内存写入了数据，以及是否使用指向已写入数据的指针创建了线程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing the
    Hooks with Microsoft Detours</samp>
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 Microsoft Detours
    实现钩子</samp>
- en: While a large number of libraries make it easy to implement function hooks,
    most leverage the same technique under the hood. This is because, at its core,
    all function hooking involves patching unconditional jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>)
    instructions to redirect the flow of execution from the function being hooked
    into the function specified by the developer of the EDR.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大量库使得实现函数钩子变得容易，但大多数库在底层都利用相同的技术。这是因为，从本质上讲，所有的函数钩住都涉及到对无条件跳转(<samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>)指令进行修补，将执行流从被钩住的函数重定向到开发者为
    EDR 指定的函数。
- en: Microsoft Detours is one of the most commonly used libraries for implementing
    function hooks. Behind the scenes, Detours replaces the first few instructions
    in the function to be hooked with an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>
    instruction that will redirect execution to a developer-defined function, also
    referred to as a *detour*. This detour function performs actions specified by
    the developer, such as logging the parameters passed to the target function. Then
    it passes execution to another function, often called a *trampoline*, which executes
    the target function and contains the instructions that were originally overwritten.
    When the target function completes its execution, control is returned to the detour.
    The detour may perform additional processing, such as logging the return value
    or output of the original function, before returning control to the original process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的 Detours 是实现函数钩子最常用的库之一。在后台，Detours 将要钩住的函数中的前几条指令替换为无条件的<samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>
    指令，该指令会将执行流重定向到开发者定义的函数，这个函数也称为*跳转函数*。这个跳转函数执行开发者指定的操作，例如记录传递给目标函数的参数。然后，它会将执行流传递给另一个函数，通常称为*弹簧板*，该函数执行目标函数并包含原本被覆盖的指令。当目标函数执行完毕后，控制会返回到跳转函数。跳转函数可能会执行额外的处理，比如记录原始函数的返回值或输出，然后将控制返回给原始进程。
- en: '[Figure 2-2](#fig2-2) illustrates a normal process’s execution compared to
    one with a detour. The solid arrow indicates expected execution flow, and the
    dashed arrow indicates hooked execution.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-2](#fig2-2) 展示了正常进程执行与带有跳转函数的执行的对比。实心箭头表示预期的执行流，虚线箭头表示钩住的执行流。'
- en: '![](../images/Figure2-2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: Normal and hooked
    execution paths</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-2：正常和钩住的执行路径</samp>
- en: In this example, the EDR has opted to hook <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateFile()</samp>,
    the syscall used to either create a new I/O device or open a handle to an existing
    one. Under normal operation, this syscall would transition immediately to the
    kernel, where its kernel-mode counterpart would continue operations. With the
    EDR’s hook in place, execution now makes a stop in the injected DLL. This <samp
    class="SANS_TheSansMonoCd_W5Regular_11">edr!HookedNtCreateFile()</samp> function
    will make the syscall on behalf of <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateFile()</samp>,
    allowing it to collect information about the parameters passed to the syscall,
    as well as the result of the operation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，EDR 选择了挂钩 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateFile()</samp>，这是一个系统调用，用于创建新的
    I/O 设备或打开现有设备的句柄。在正常操作下，这个系统调用会立即过渡到内核，内核模式的对应函数会继续执行。通过 EDR 的挂钩，执行现在会在注入的 DLL
    中停顿。这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">edr!HookedNtCreateFile()</samp>
    函数会代表 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateFile()</samp>
    执行系统调用，收集关于传递给系统调用的参数和操作结果的信息。
- en: Examining a hooked function in a debugger, such as WinDbg, clearly shows the
    differences between a function that has been hooked and one that hasn’t. [Listing
    2-1](#list2-1) shows what an unhooked <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp>
    function looks like in WinDbg.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器（如 WinDbg）中检查被挂钩的函数，清楚地显示了已经挂钩的函数与未挂钩函数之间的区别。[列表 2-1](#list2-1) 显示了未挂钩的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp> 函数在 WinDbg
    中的样子。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 2-1: The unhooked <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!SleepStub()</samp>
    function in WinDbg'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-1：WinDbg 中未挂钩的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!SleepStub()</samp>
    函数
- en: This disassembly of the function shows the execution flow that we expect. When
    the caller invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp>,
    the jump stub <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!SleepStub()</samp>
    is executed, long-jumping (<samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>)
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!_imp_Sleep()</samp>,
    which provides the real <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep()</samp>
    functionality the caller expects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的反汇编显示了我们预期的执行流程。当调用者调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp>
    时，跳转存根 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!SleepStub()</samp>
    被执行，长跳转（<samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>）到 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!_imp_Sleep()</samp>，它提供调用者所期望的实际
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep()</samp> 功能。
- en: The function looks substantially different after the injection of a DLL that
    leverages Detours to hook it, shown in [Listing 2-2](#list2-2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注入 DLL 后，利用 Detours 挂钩该函数，函数的样子发生了显著变化，见 [列表 2-2](#list2-2)。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 2-2: The hooked <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!Sleep()</samp>
    function in WinDbg'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-2：WinDbg 中被挂钩的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!Sleep()</samp>
    函数
- en: Instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!_imp_Sleep()</samp>, the disassembly
    contains a series of <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>
    instructions, the second of which lands execution in <samp class="SANS_TheSansMonoCd_W5Regular_11">trampoline64!TimedSleep()</samp>,
    shown in [Listing 2-3](#list2-3).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与其跳转到 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!_imp_Sleep()</samp>，反汇编中包含了一系列
    <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp> 指令，其中第二个将执行跳转到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">trampoline64!TimedSleep()</samp>，该函数在
    [列表 2-3](#list2-3) 中显示。
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 2-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!Sleep()</samp>
    intercept function'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-3：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!Sleep()</samp>
    拦截函数
- en: To collect metrics about the hooked function’s execution, this trampoline function
    evaluates the amount of time it sleeps, in CPU ticks, by calling the legitimate
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp> function
    via its internal <samp class="SANS_TheSansMonoCd_W5Regular_11">trampoline64!TrueSleep()</samp>
    wrapper function. It displays the tick count in a pop-up message.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集关于被挂钩函数执行的度量信息，这个跳板函数通过其内部的 <samp class="SANS_TheSansMonoCd_W5Regular_11">trampoline64!TrueSleep()</samp>
    包装函数，调用合法的 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp>
    函数来评估它的睡眠时间（以 CPU 时钟周期为单位）。它会在弹出消息中显示时钟计数。
- en: 'While this is a contrived example, it demonstrates the core of what every EDR’s
    function-hooking DLL does: proxying the execution of the target function and collecting
    information about how it was invoked. In this case, our EDR simply measures how
    long the hooked program sleeps. In a real EDR, functions important to adversary
    behavior, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtWriteVirtualMemory()</samp>
    for copying code into a remote process, would be proxied in the same way, but
    the hooking might pay more attention to the parameters being passed and the values
    returned.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个人为构造的例子，但它展示了每个 EDR 的函数钩子 DLL 的核心功能：代理目标函数的执行并收集有关如何调用它的信息。在这个例子中，我们的
    EDR 只是测量被钩程序的睡眠时间。在真实的 EDR 中，重要的函数，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtWriteVirtualMemory()</samp>（用于将代码复制到远程进程），也会以同样的方式被代理，但钩子可能会更关注传递的参数和返回的值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Injecting the DLL</samp>
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">注入 DLL</samp>
- en: A DLL that hooks functions isn’t particularly useful until it is loaded into
    the target process. Some libraries offer the ability to spawn a process and inject
    the DLL through an API, but this isn’t practical for EDRs, as they need the ability
    to inject their DLL into processes spawned by users at any time. Fortunately,
    Windows provides a few methods to do this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 DLL 被加载到目标进程中，它才会变得有用。某些库提供了通过 API 生成进程并注入 DLL 的能力，但这对于 EDR 来说并不实用，因为它们需要能够随时将
    DLL 注入用户生成的进程中。幸运的是，Windows 提供了几种方法来实现这一点。
- en: Until Windows 8, many vendors opted to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppInit_Dlls</samp>
    infrastructure to load their DLLs into every interactive process (those that import
    *user32.dll*). Unfortunately, malware authors routinely abused this technique
    for persistence and information collection, and it was notorious for causing system
    performance issues. Microsoft no longer recommends this method for DLL injection
    and, starting in Windows 8, prevents it entirely on systems with Secure Boot enabled.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 Windows 8 之前，许多厂商选择使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">AppInit_Dlls</samp>
    基础设施将他们的 DLL 加载到每个交互式进程中（那些导入 *user32.dll* 的进程）。不幸的是，恶意软件作者经常滥用这一技术来维持持久性和收集信息，这也使得该技术因导致系统性能问题而声名狼藉。微软不再推荐这种
    DLL 注入方法，并且从 Windows 8 开始，在启用安全启动的系统上完全禁止了这种方法。
- en: The most commonly used technique for injecting a function-hooking DLL into processes
    is to leverage a driver, which can use a kernel-level feature called *kernel asynchronous
    procedure call (KAPC) injection* to insert the DLL into the process. When the
    driver is notified of the creation of a new process, it will allocate some of
    the process’s memory for an APC routine and the name of the DLL to inject. It
    will then initialize a new APC object, which is responsible for loading the DLL
    into the process, and copy it into the process’s address space. Finally, it will
    change a flag in the thread’s APC state to force execution of the APC. When the
    process resumes its execution, the APC routine will run, loading the DLL. [Chapter
    5](chapter5.xhtml) explains this process in greater detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注入函数钩子 DLL 到进程中最常用的技术是利用驱动程序，它可以使用一个名为*内核异步过程调用（KAPC）注入*的内核级特性，将 DLL 插入进程中。当驱动程序被通知到新进程的创建时，它会为
    APC 程序和要注入的 DLL 名称分配一部分进程的内存。接下来，它会初始化一个新的 APC 对象，负责将 DLL 加载到进程中，并将其复制到进程的地址空间。最后，它会改变线程的
    APC 状态中的标志，以强制执行 APC。当进程恢复执行时，APC 程序将运行，加载 DLL。[第 5 章](chapter5.xhtml)对这个过程进行了更详细的解释。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting Function Hooks</samp>
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">检测函数钩子</samp>
- en: Offensive security practitioners often want to identify whether the functions
    they plan to use are hooked. Once they identify hooked functions, they can make
    a list of them and then limit, or entirely avoid, their use. This allows the adversary
    to bypass inspection by the EDR’s function-hooking DLL, as its inspection function
    will never be invoked. The process of detecting hooked functions is incredibly
    simple, especially for the native API functions exported by *ntdll.dll*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 进攻性安全从业人员通常希望识别他们计划使用的函数是否已被钩取。一旦他们识别出已钩取的函数，他们可以列出这些函数，然后限制或完全避免使用它们。这使得对手能够绕过
    EDR 的函数钩子 DLL 的检测，因为它的检测功能将永远不会被调用。检测钩取函数的过程非常简单，特别是对于 *ntdll.dll* 导出的本地 API 函数。
- en: Each function inside *ntdll.dll* consists of a syscall stub. The instructions
    that make up this stub are shown in [Listing 2-4](#list2-4).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*ntdll.dll*中的每个函数都包含一个系统调用存根。构成此存根的指令显示在[清单2-4](#list2-4)中。'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 2-4: Syscall stub assembly instructions'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-4：系统调用存根汇编指令
- en: You can see this stub by disassembling a function exported by *ntdll.dll* in
    WinDbg, as shown in [Listing 2-5](#list2-5).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在WinDbg中反汇编一个由*ntdll.dll*导出的函数来查看此存根，如[清单2-5](#list2-5)所示。
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 2-5: The unmodified syscall stub for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtAllocateVirtualMemory()</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-5：未经修改的<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtAllocateVirtualMemory()</samp>系统调用存根
- en: In the disassembly of <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>,
    we see the basic building blocks of the syscall stub. The stub preserves the volatile
    RCX register in the R10 register and then moves the syscall number that correlates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory()</samp>,
    or 0x18 in this version of Windows, into EAX. Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TEST</samp>
    and conditional jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">JNE</samp>)
    instructions following <samp class="SANS_TheSansMonoCd_W5Regular_11">MOV</samp>
    are a check found in all syscall stubs. Restricted User Mode uses it when Hypervisor
    Code Integrity is enabled for kernel-mode code but not user-mode code. You can
    safely ignore it in this context. Finally, the syscall instruction is executed,
    transitioning control to the kernel to handle the memory allocation. When the
    function completes and control is given back to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>,
    it simply returns.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在对<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>的反汇编中，我们看到系统调用存根的基本构建块。该存根将易失性的RCX寄存器保存在R10寄存器中，然后将与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory()</samp>相关的系统调用编号（在此版本的Windows中为0x18）移动到EAX寄存器。接下来，紧跟在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MOV</samp>指令后面的<samp class="SANS_TheSansMonoCd_W5Regular_11">TEST</samp>和条件跳转（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">JNE</samp>）指令是所有系统调用存根中的检查。当启用Hypervisor代码完整性时，受限用户模式会使用它来检查内核模式代码，但不适用于用户模式代码。在此上下文中，您可以安全地忽略它。最后，执行系统调用指令，将控制权转交给内核以处理内存分配。当函数完成并将控制权交还给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>时，它只是简单地返回。
- en: Because the syscall stub is the same for all native APIs, any modification of
    it indicates the presence of a function hook. For example, [Listing 2-6](#list2-6)
    shows the tampered syscall stub for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>
    function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有本地API的系统调用存根都是相同的，任何对它的修改都表明存在函数钩子。例如，[清单2-6](#list2-6)展示了被篡改的<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>函数的系统调用存根。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 2-6: The hooked <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtAllocateVirtualMemory()</samp>
    function'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-6：被钩住的<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtAllocateVirtualMemory()</samp>函数
- en: Notice here that, rather than the syscall stub existing at the entry point of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>,
    an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp> instruction
    is present. EDRs commonly use this type of modification to redirect execution
    flow to their hooking DLL.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这里，与其说<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>的入口点存在系统调用存根，不如说存在一个无条件的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>指令。EDR通常使用这种类型的修改将执行流程重定向到它们的钩子DLL。
- en: Thus, to detect hooks placed by an EDR, we can simply examine functions in the
    copy of *ntdll.dll* currently loaded into our process, comparing their entry-point
    instructions with the expected opcodes of an unmodified syscall stub. If we find
    a hook on a function we want to use, we can attempt to evade it using the techniques
    described in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了检测EDR所植入的钩子，我们可以简单地检查当前加载到我们进程中的*ntdll.dll*副本中的函数，将它们的入口点指令与未经修改的系统调用存根的预期操作码进行比较。如果我们发现某个我们想要使用的函数上有钩子，我们可以尝试使用下一节中描述的技术来规避它。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Function Hooks</samp>
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避函数钩子</samp>
- en: 'Of all the sensor components used in endpoint security software, function hooks
    are one of the most well researched when it comes to evasion. Attackers can use
    a myriad of methods to evade function interception, all of which generally boil
    down to one of the following techniques:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有用于终端安全软件的传感器组件中，函数钩子是研究最为深入的规避手段之一。攻击者可以通过多种方法规避函数拦截，这些方法通常归结为以下几种技术：
- en: Making direct syscalls to execute the instructions of an unmodified syscall
    stub
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接调用系统调用来执行未修改的系统调用存根指令
- en: Remapping *ntdll.dll* to get unhooked function pointers or overwriting the hooked
    *ntdll.dll* currently mapped in the process
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新映射 *ntdll.dll*，以获取未挂钩的函数指针，或覆盖当前映射在进程中的已挂钩的 *ntdll.dll*
- en: Blocking non-Microsoft DLLs from loading in the process to prevent the EDR’s
    function-hooking DLL from placing its detours
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止非微软的 DLL 在进程中加载，以防止 EDR 的函数钩子 DLL 设置其拦截
- en: 'This is by no means an exhaustive list. One example of a technique that doesn’t
    fit into any of these categories is vectored exception handling, as detailed in
    Peter Winter-Smith’s blog post “FireWalker: A New Approach to Generically Bypass
    User-Space EDR Hooking.” Winter-Smith’s technique uses a *vectored exception handler
    (VEH)*, an extension to structured exception handling that allows the developer
    to register their own function for which to watch and handle all exceptions in
    a given application. It sets the processor’s trap flag to put the program into
    single-step mode. On each new instruction, the evasion code generates a single-step
    exception on which the VEH has first right of refusal. The VEH will step over
    the hook placed by the EDR by updating the instruction pointer to the chunk containing
    the original, unmodified code.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是一个详尽无遗的列表。一个不属于上述任何类别的技术示例是向量化异常处理，详见 Peter Winter-Smith 的博客文章《FireWalker：一种通用规避用户空间
    EDR 钩子的全新方法》。Winter-Smith 的技术使用了 *向量化异常处理器 (VEH)*，它是结构化异常处理的扩展，允许开发者注册自己的函数来监视并处理给定应用程序中的所有异常。它通过设置处理器的陷阱标志将程序置于单步模式。在每个新的指令上，规避代码会生成单步异常，VEH
    首先有权拒绝。VEH 将通过更新指令指针，跳过 EDR 设置的钩子，指向包含原始未修改代码的代码块。
- en: While interesting, this technique currently only works for 32-bit applications
    and can adversely affect a program’s performance, due to the single stepping.
    For these reasons, this approach to evasion remains beyond the scope of this chapter.
    We’ll instead focus on more broadly applicable techniques.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个技术很有趣，但目前仅适用于 32 位应用程序，并且由于单步执行，它可能会对程序的性能产生不利影响。因此，这种规避方法超出了本章的讨论范围。我们将专注于更广泛适用的技术。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Direct Syscalls</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">直接调用系统调用</samp>
- en: By far, the most commonly abused technique for evading hooks placed on *ntdll.dll*
    functions is making direct syscalls. If we execute the instructions of a syscall
    stub ourselves, we can mimic an unmodified function. To do so, our code must include
    the desired function’s signature, a stub containing the correct syscall number,
    and an invocation of the target function. This invocation uses the signature and
    stub to pass in the required parameters and execute the target function in a way
    that the function hooks won’t detect. [Listing 2-7](#list2-7) contains the first
    file we need to create to execute this technique.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，最常被滥用的规避技术是直接调用系统调用，以规避在 *ntdll.dll* 函数上设置的钩子。如果我们自己执行系统调用存根的指令，就可以模拟未修改的函数。为了做到这一点，我们的代码必须包含所需函数的签名、包含正确系统调用编号的存根，以及对目标函数的调用。这个调用使用签名和存根传递必要的参数，并以钩子无法检测的方式执行目标函数。[清单
    2-7](#list2-7)包含了我们需要创建的第一个文件，以执行这一技术。
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 2-7: Assembly instructions for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtAllocateVirtualMemory()</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-7：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtAllocateVirtualMemory()</samp>的汇编指令
- en: The first file in our project contains what amounts to a reimplementation of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>.
    The instructions contained inside the sole function will fill the EAX register
    with the syscall number. Then, a syscall instruction is executed. This assembly
    code would reside in its own *.asm* file, and Visual Studio can be configured
    to compile it using the Microsoft Macro Assembler (MASM), with the rest of the
    project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目中的第一个文件包含了 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>
    的重新实现。该函数中的指令将填充 EAX 寄存器以存储系统调用编号。然后，执行系统调用指令。此汇编代码将保存在自己的 *.asm* 文件中，并且可以配置 Visual
    Studio 使用 Microsoft 宏汇编器（MASM）来编译它，和项目的其余部分一起。
- en: Even though we have our syscall stub built out, we still need a way to call
    it from our code. [Listing 2-8](#list2-8) shows how we would do that.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们已经构建了系统调用存根，我们仍然需要一种方式从代码中调用它。[列表 2-8](#list2-8) 展示了我们如何做到这一点。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 2-8: The definition of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtAllocateVirtualMemory()</samp>
    to be included in the project header file'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-8：将包含在项目头文件中的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtAllocateVirtualMemory()</samp>
    的定义
- en: This function definition contains all the required parameters and their types,
    along with the return type. It should live in our header file, *syscall.h*, and
    will be included in our C source file, shown in [Listing 2-9](#list2-9).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数定义包含了所有必需的参数及其类型，以及返回类型。它应该位于我们的头文件 *syscall.h* 中，并会包含在我们的 C 源文件中，如 [列表
    2-9](#list2-9) 所示。
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 2-9: Making a direct syscall in C'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-9：在 C 中进行直接系统调用
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain()</samp> function in
    this file calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory()</samp>
    ❶ to allocate a 0x1000-byte buffer in the current process with read-write permissions.
    This function is not defined in the header files that Microsoft makes available
    to developers, so we have to define it in our own header file. When this function
    is invoked, rather than calling into *ntdll.dll*, the assembly code we included
    in the project will be called, effectively simulating the behavior of an unhooked
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>
    without running the risk of hitting an EDR’s hook.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain()</samp> 函数调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory()</samp> ❶ 来为当前进程分配一个
    0x1000 字节的缓冲区，并且该缓冲区具有读写权限。这个函数没有在微软提供给开发者的头文件中定义，因此我们必须在自己的头文件中定义它。当调用这个函数时，汇编代码将会被执行，而不是调用
    *ntdll.dll*，有效地模拟了未被 hook 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>
    行为，而不会触发 EDR 的钩子。
- en: One of the primary challenges of this technique is that Microsoft frequently
    changes syscall numbers, so any tooling that hardcodes these numbers may only
    work on specific Windows builds. For example, the syscall number for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateThreadEx()</samp>
    on build 1909 of Windows 10 is 0xBD. On build 20H1, the following release, it
    is 0xC1\. This means that a tool targeting build 1909 won’t work on later versions
    of Windows.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的主要挑战之一是微软经常更改系统调用编号，因此任何硬编码这些编号的工具可能只能在特定的 Windows 版本上工作。例如，Windows 10
    1909 版本中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateThreadEx()</samp>
    系统调用编号是 0xBD。在 20H1 版本中，即接下来的发布版本，它的编号是 0xC1。这意味着，针对 1909 版本的工具在更高版本的 Windows
    上可能无法使用。
- en: To help address this limitation, many developers rely on external sources to
    track these changes. For example, Mateusz Jurczyk of Google’s Project Zero maintains
    a list of functions and their associated syscall numbers for each release of Windows.
    In December 2019, Jackson Thuraisamy published the tool SysWhispers, which gave
    attackers the ability to dynamically generate the function signatures and assembly
    code for the syscalls in their offensive tooling. [Listing 2-10](#list2-10) shows
    the assembly code generated by SysWhispers when targeting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateThreadEx()</samp>
    function on builds 1903 through 20H2 of Windows 10.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这一限制，许多开发者依赖外部资源来跟踪这些变化。例如，Google Project Zero 的 Mateusz Jurczyk 维护着每个
    Windows 版本的函数及其关联的系统调用编号列表。2019 年 12 月，Jackson Thuraisamy 发布了工具 SysWhispers，它使攻击者能够动态生成系统调用的函数签名和汇编代码，并将其应用于攻击工具中。[列表
    2-10](#list2-10) 展示了 SysWhispers 在针对 Windows 10 1903 到 20H2 版本的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateThreadEx()</samp>
    函数时生成的汇编代码。
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 2-10: The SysWhispers output for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtCreateThreadEx()</samp>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-10：SysWhispers对于<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtCreateThreadEx()</samp>的输出
- en: This assembly code extracts the build number from the process environment block
    ❶ and then uses that value to move the appropriate syscall number into the EAX
    register ❷ before making the syscall ❸. While this approach works, it requires
    substantial effort, as the attacker must update the syscall numbers in their dataset
    each time Microsoft releases a new Windows build.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这段汇编代码从进程环境块❶中提取构建号，然后使用该值将相应的系统调用号移动到EAX寄存器❷，在进行系统调用❸之前。虽然这种方法有效，但需要相当大的努力，因为攻击者必须在每次微软发布新版本的Windows时，更新数据集中系统调用号。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamically Resolving
    Syscall Numbers</samp>
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">动态解析系统调用号</samp>
- en: 'In December 2020, a researcher known by @modexpblog on Twitter published a
    blog post titled “Bypassing User-Mode Hooks and Direct Invocation of System Calls
    for Red Teams.” The post described another function-hook evasion technique: dynamically
    resolving syscall numbers at runtime, which kept attackers from having to hardcode
    the values for each Windows build. This technique uses the following workflow
    to create a dictionary of function names and syscall numbers:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 2020年12月，一位名为@modexpblog的研究人员在Twitter上发布了一篇名为《绕过用户模式钩子和直接调用系统调用用于红队》的博客文章。文章描述了另一种函数钩子规避技术：在运行时动态解析系统调用号，这使得攻击者无需为每个Windows版本硬编码调用号。该技术使用以下工作流来创建函数名称和系统调用号的字典：
- en: Get a handle to the current process’s mapped *ntdll.dll*.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前进程映射的*ntdll.dll*的句柄。
- en: Enumerate all exported functions that begin with *Zw* to identify system calls.
    Note that functions prefixed with *Nt* (which is more commonly seen) work identically
    when called from user mode. The decision to use the Zw version appears to be arbitrary
    in this case.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举所有以*Zw*开头的导出函数以识别系统调用。请注意，以*Nt*为前缀的函数（这是更常见的形式）在从用户模式调用时也能正常工作。此处选择使用Zw版本似乎是任意的。
- en: Store the exported function names and their associated relative virtual addresses.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储导出的函数名称及其相关的相对虚拟地址。
- en: Sort the dictionary by relative virtual addresses.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按相对虚拟地址对字典进行排序。
- en: Define the syscall number of the function as its index in the dictionary after
    sorting.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在字典中排序后，将函数的系统调用号定义为其索引。
- en: Using this technique, we can collect syscall numbers at runtime, insert them
    into the stub at the appropriate location, and then call the target functions
    as we otherwise would in the statically coded method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以在运行时收集系统调用号，将其插入到适当位置的存根中，然后像在静态编码方法中一样调用目标函数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Remapping ntdll.dll</samp>
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">重新映射ntdll.dll</samp>
- en: Another common technique used to evade user-mode function hooks is to load a
    new copy of *ntdll.dll* into the process, overwrite the existing hooked version
    with the contents of the newly loaded file, and then call the desired functions.
    This strategy works because the newly loaded *ntdll.dll* does not contain the
    hooks implemented in the copy loaded earlier, so when it overwrites the tainted
    version, it effectively cleans out all the hooks placed by the EDR. [Listing 2-11](#list2-11)
    shows a rudimentary example of this. Some lines have been omitted for brevity.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常用的规避用户模式函数钩子的技术是将新的*ntdll.dll*加载到进程中，用新加载的文件内容覆盖现有的钩取版本，然后调用所需的函数。这个策略有效，因为新加载的*ntdll.dll*不包含之前加载的版本中实现的钩子，因此当它覆盖被污染的版本时，实际上清除了所有由EDR放置的钩子。[列表
    2-11](#list2-11)展示了一个这一过程的简单示例。为简洁起见，部分行已被省略。
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 2-11: A technique for overwriting a hooked ntdll.dll'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-11：覆盖已钩取的ntdll.dll的技术
- en: Our code first gets the base address of the currently loaded (hooked) *ntdll.dll*
    ❶. Then we read in the contents of *ntdll.dll* from disk and map it into memory
    ❷. At this point, we can parse the PE headers of the hooked *ntdll.dll*, looking
    for the address of the *.text* section ❸, which holds the executable code in the
    image. Once we find it, we change the permissions of that region of memory so
    that we can write to it ❹, copy in the contents of the *.text* section from the
    “clean” file ❺, and revert the change to memory protection ❻. After this sequence
    of events completes, the hooks originally placed by the EDR should have been removed
    and the developer can call whichever function from *ntdll.dll* they need without
    the fear of execution being redirected to the EDR’s injected DLL.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码首先获取当前已加载（被钩住的）*ntdll.dll*的基地址❶。然后我们从磁盘读取*ntdll.dll*的内容并将其映射到内存中❷。此时，我们可以解析被钩住的*ntdll.dll*的PE头，寻找*.text*部分的地址❸，该部分包含映像中的可执行代码。一旦找到它，我们将修改该内存区域的权限，以便能够向其中写入❹，将“干净”文件中的*.text*部分内容复制进去❺，然后恢复内存保护的更改❻。当这一系列事件完成后，原本由EDR放置的钩子应该已经被移除，开发人员可以调用*ntdll.dll*中的任何函数，而不必担心执行会被重定向到EDR注入的DLL。
- en: While reading *ntdll.dll* from disk seems easy, it does come with a potential
    trade-off. This is because loading *ntdll.dll* into a single process multiple
    times is atypical behavior. Defenders can capture this activity with Sysmon, a
    free system-monitoring utility that provides many of the same telemetry-collection
    facilities as an EDR. Almost every non-malicious process has a one-to-one mapping
    of process GUIDs to loads of *ntdll.dll*. When I queried these properties in a
    large enterprise environment, only approximately 0.04 percent of 37 million processes
    loaded *ntdll.dll* more than once over the course of a month.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从磁盘读取*ntdll.dll*看似简单，但它确实带来了潜在的权衡。这是因为将*ntdll.dll*多次加载到单一进程中并非典型行为。防御者可以通过Sysmon捕获这一活动，Sysmon是一款免费的系统监控工具，提供与EDR相同的许多遥测收集功能。几乎每个非恶意进程都将进程GUID与*ntdll.dll*的加载一一对应。当我在大型企业环境中查询这些属性时，在一个月的时间内，约有37百万个进程中，只有大约0.04%的进程在此期间加载了*ntdll.dll*多于一次。
- en: To avoid detection based on this anomaly, you might opt to spawn a new process
    in a suspended state, get a handle to the unmodified *ntdll.dll* mapped in the
    new process, and copy it to the current process. From there, you could either
    get the function pointers as shown before, or replace the existing hooked *ntdll.dll*
    to effectively overwrite the hooks placed by the EDR. [Listing 2-12](#list2-12)
    demonstrates this technique.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免基于此异常的检测，您可以选择在挂起状态下生成一个新进程，获取新进程中未修改的*ntdll.dll*的句柄，并将其复制到当前进程中。从那里，您可以像之前展示的那样获取函数指针，或者替换现有的被钩住的*ntdll.dll*，有效地覆盖EDR放置的钩子。[示例
    2-12](#list2-12)演示了这种技术。
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 2-12: Remapping ntdll.dll in a suspended process'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-12：在挂起进程中重新映射ntdll.dll
- en: This minimal example first opens a handle to the copy of *ntdll.dll* ❶ currently
    mapped into our process, gets its base address, and parses its PE headers ❷. Next,
    it creates a suspended process ❸ and parses the PE headers of this process’s copy
    of *ntdll.dll* ❹, which hasn’t had the chance to be hooked by the EDR yet. The
    rest of the flow of this function is exactly the same as in the previous example,
    and when it completes, the hooked *ntdll.dll* should have been reverted to a clean
    state.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最小示例首先打开当前映射到我们进程中的*ntdll.dll*副本的句柄❶，获取其基地址并解析其PE头❷。接下来，它创建一个挂起的进程❸，并解析该进程中*ntdll.dll*副本的PE头❹，这个副本尚未被EDR钩住。该函数的其余流程与前一个示例完全相同，当它完成时，钩住的*ntdll.dll*应该已经恢复到干净状态。
- en: As with all things, there is a trade-off here as well, as our new suspended
    process creates another opportunity for detection, such as by a hooked <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>,
    the driver, or the ETW provider. In my experience, it is very rare to see a program
    create a temporary suspended process for legitimate reasons.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有事情一样，这里也存在一个权衡，因为我们新的挂起进程创建了另一个被检测的机会，比如通过钩住的<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>、驱动程序或ETW提供者。根据我的经验，很少见到程序出于合法原因创建一个临时挂起的进程。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: Function hooking is one of the original mechanisms by which an endpoint security
    product can monitor the execution flow of other processes. While it provides very
    useful information to an EDR, it is very susceptible to bypass due to inherent
    weaknesses in its common implementations. For that reason, most mature EDRs today
    consider it an auxiliary telemetry source and instead rely on more resilient sensors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 函数钩取是终端安全产品监控其他进程执行流的一种原始机制。尽管它为EDR提供了非常有用的信息，但由于其常见实现中的固有弱点，它非常容易被绕过。正因如此，现今大多数成熟的EDR将其视为辅助遥测源，而更依赖于更为稳健的传感器。
