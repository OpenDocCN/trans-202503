- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FUNCTION-HOOKING
    DLLS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Of all the components included in modern endpoint security products, the most
    widely deployed are DLLs responsible for function *hooking*, or interception.
    These DLLs provide defenders with a large amount of important information related
    to code execution, such as the parameters passed to a function of interest and
    the values it returns. Today, vendors largely use this data to supplement other,
    more robust sources of information. Still, function hooking is an important component
    of EDRs. In this chapter, we’ll discuss how EDRs most commonly intercept function
    calls and what we, as attackers, can do to interfere with them.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses heavily on the hooking of functions in a Windows file called
    *ntdll.dll*, whose functionality we’ll cover shortly, but modern EDRs hook other
    Windows functions too. The process of implementing these other hooks closely resembles
    the workflow described in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Function Hooking Works</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand how endpoint security products use code hooking, you must understand
    how code running in user mode interacts with the kernel. This code typically leverages
    the Win32 API during execution to perform certain functions on the host, such
    as requesting a handle to another process. However, in many cases, the functionality
    provided via Win32 can’t be completed entirely in user mode. Some actions, such
    as memory and object management, are the responsibility of the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: To transfer execution to the kernel, x64 systems use a syscall instruction.
    But rather than implementing syscall instructions in every function that needs
    to interact with the kernel, Windows provides them via functions in *ntdll.dll*.
    A function simply needs to pass the required parameters to this exported function;
    the function will, in turn, pass control into the kernel and then return the results
    of the operation. For example, [Figure 2-1](#fig2-1) demonstrates the execution
    flow that occurs when a user-mode application calls the Win32 API function <samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!OpenProcess()</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The flow of execution
    from user mode to kernel mode</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To detect malicious activity, vendors often hook these Windows APIs. For example,
    one way that EDRs detect remote process injection is to hook the functions responsible
    for opening a handle to another process, allocating a region of memory, writing
    to the allocated memory, and creating the remote thread.
  prefs: []
  type: TYPE_NORMAL
- en: In earlier versions of Windows, vendors (and malware authors) often placed their
    hooks on the System Service Dispatch Table (SSDT), a table in the kernel that
    holds the pointers to the kernel functions used upon invocation of a syscall.
    Security products would overwrite these function pointers with pointers to functions
    in their own kernel module used to log information about the function call and
    then execute the target function. They would then pass the return values back
    to the source application.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of Windows XP in 2005, Microsoft made the decision to
    prevent the patching of SSDT, among a host of other critical structures, using
    a protection called Kernel Patch Protection (KPP), also known as PatchGuard, so
    this technique is not viable on modern 64-bit Windows versions. This means that
    traditional hooking must be done in user mode. Because the functions performing
    the syscalls in *ntdll.dll* are the last possible place to observe API calls in
    user mode, EDRs will often hook these functions in order to inspect their invocation
    and execution. Some commonly hooked functions are detailed in [Table 2-1](#tab2-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">Commonly
    Hooked Functions in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ntdll.dll</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Function names</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Related
    attacker techniques</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcessNtAllocateVirtualMemory</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>
    | <samp class="SANS_Futura_Std_Book_11">Remote process injection</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSuspendThreadNtResumeThread</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp> | <samp class="SANS_Futura_Std_Book_11">Shellcode
    injection via asynchronous procedure call (APC)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSectionNtMapViewOfSection</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp> | <samp
    class="SANS_Futura_Std_Book_11">Shellcode injection via mapped memory sections</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp> | <samp
    class="SANS_Futura_Std_Book_11">Driver loading using a configuration stored in
    the registry</samp> |'
  prefs: []
  type: TYPE_TB
- en: By intercepting calls to these APIs, an EDR can observe the parameters passed
    to the original function, as well as the value returned to the code that called
    the API. Agents can then examine this data to determine whether the activity was
    malicious. For example, to detect remote process injection, an agent could monitor
    whether the region of memory was allocated with read-write-execute permissions,
    whether data was written to the new allocation, and whether a thread was created
    using a pointer to the written data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing the
    Hooks with Microsoft Detours</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While a large number of libraries make it easy to implement function hooks,
    most leverage the same technique under the hood. This is because, at its core,
    all function hooking involves patching unconditional jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>)
    instructions to redirect the flow of execution from the function being hooked
    into the function specified by the developer of the EDR.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Detours is one of the most commonly used libraries for implementing
    function hooks. Behind the scenes, Detours replaces the first few instructions
    in the function to be hooked with an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>
    instruction that will redirect execution to a developer-defined function, also
    referred to as a *detour*. This detour function performs actions specified by
    the developer, such as logging the parameters passed to the target function. Then
    it passes execution to another function, often called a *trampoline*, which executes
    the target function and contains the instructions that were originally overwritten.
    When the target function completes its execution, control is returned to the detour.
    The detour may perform additional processing, such as logging the return value
    or output of the original function, before returning control to the original process.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-2](#fig2-2) illustrates a normal process’s execution compared to
    one with a detour. The solid arrow indicates expected execution flow, and the
    dashed arrow indicates hooked execution.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: Normal and hooked
    execution paths</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the EDR has opted to hook <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateFile()</samp>,
    the syscall used to either create a new I/O device or open a handle to an existing
    one. Under normal operation, this syscall would transition immediately to the
    kernel, where its kernel-mode counterpart would continue operations. With the
    EDR’s hook in place, execution now makes a stop in the injected DLL. This <samp
    class="SANS_TheSansMonoCd_W5Regular_11">edr!HookedNtCreateFile()</samp> function
    will make the syscall on behalf of <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateFile()</samp>,
    allowing it to collect information about the parameters passed to the syscall,
    as well as the result of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Examining a hooked function in a debugger, such as WinDbg, clearly shows the
    differences between a function that has been hooked and one that hasn’t. [Listing
    2-1](#list2-1) shows what an unhooked <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp>
    function looks like in WinDbg.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: The unhooked <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!SleepStub()</samp>
    function in WinDbg'
  prefs: []
  type: TYPE_NORMAL
- en: This disassembly of the function shows the execution flow that we expect. When
    the caller invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp>,
    the jump stub <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!SleepStub()</samp>
    is executed, long-jumping (<samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>)
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!_imp_Sleep()</samp>,
    which provides the real <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep()</samp>
    functionality the caller expects.
  prefs: []
  type: TYPE_NORMAL
- en: The function looks substantially different after the injection of a DLL that
    leverages Detours to hook it, shown in [Listing 2-2](#list2-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: The hooked <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!Sleep()</samp>
    function in WinDbg'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!_imp_Sleep()</samp>, the disassembly
    contains a series of <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>
    instructions, the second of which lands execution in <samp class="SANS_TheSansMonoCd_W5Regular_11">trampoline64!TimedSleep()</samp>,
    shown in [Listing 2-3](#list2-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!Sleep()</samp>
    intercept function'
  prefs: []
  type: TYPE_NORMAL
- en: To collect metrics about the hooked function’s execution, this trampoline function
    evaluates the amount of time it sleeps, in CPU ticks, by calling the legitimate
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp> function
    via its internal <samp class="SANS_TheSansMonoCd_W5Regular_11">trampoline64!TrueSleep()</samp>
    wrapper function. It displays the tick count in a pop-up message.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is a contrived example, it demonstrates the core of what every EDR’s
    function-hooking DLL does: proxying the execution of the target function and collecting
    information about how it was invoked. In this case, our EDR simply measures how
    long the hooked program sleeps. In a real EDR, functions important to adversary
    behavior, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtWriteVirtualMemory()</samp>
    for copying code into a remote process, would be proxied in the same way, but
    the hooking might pay more attention to the parameters being passed and the values
    returned.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Injecting the DLL</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DLL that hooks functions isn’t particularly useful until it is loaded into
    the target process. Some libraries offer the ability to spawn a process and inject
    the DLL through an API, but this isn’t practical for EDRs, as they need the ability
    to inject their DLL into processes spawned by users at any time. Fortunately,
    Windows provides a few methods to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Until Windows 8, many vendors opted to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppInit_Dlls</samp>
    infrastructure to load their DLLs into every interactive process (those that import
    *user32.dll*). Unfortunately, malware authors routinely abused this technique
    for persistence and information collection, and it was notorious for causing system
    performance issues. Microsoft no longer recommends this method for DLL injection
    and, starting in Windows 8, prevents it entirely on systems with Secure Boot enabled.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used technique for injecting a function-hooking DLL into processes
    is to leverage a driver, which can use a kernel-level feature called *kernel asynchronous
    procedure call (KAPC) injection* to insert the DLL into the process. When the
    driver is notified of the creation of a new process, it will allocate some of
    the process’s memory for an APC routine and the name of the DLL to inject. It
    will then initialize a new APC object, which is responsible for loading the DLL
    into the process, and copy it into the process’s address space. Finally, it will
    change a flag in the thread’s APC state to force execution of the APC. When the
    process resumes its execution, the APC routine will run, loading the DLL. [Chapter
    5](chapter5.xhtml) explains this process in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting Function Hooks</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Offensive security practitioners often want to identify whether the functions
    they plan to use are hooked. Once they identify hooked functions, they can make
    a list of them and then limit, or entirely avoid, their use. This allows the adversary
    to bypass inspection by the EDR’s function-hooking DLL, as its inspection function
    will never be invoked. The process of detecting hooked functions is incredibly
    simple, especially for the native API functions exported by *ntdll.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: Each function inside *ntdll.dll* consists of a syscall stub. The instructions
    that make up this stub are shown in [Listing 2-4](#list2-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-4: Syscall stub assembly instructions'
  prefs: []
  type: TYPE_NORMAL
- en: You can see this stub by disassembling a function exported by *ntdll.dll* in
    WinDbg, as shown in [Listing 2-5](#list2-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-5: The unmodified syscall stub for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtAllocateVirtualMemory()</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the disassembly of <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>,
    we see the basic building blocks of the syscall stub. The stub preserves the volatile
    RCX register in the R10 register and then moves the syscall number that correlates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory()</samp>,
    or 0x18 in this version of Windows, into EAX. Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TEST</samp>
    and conditional jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">JNE</samp>)
    instructions following <samp class="SANS_TheSansMonoCd_W5Regular_11">MOV</samp>
    are a check found in all syscall stubs. Restricted User Mode uses it when Hypervisor
    Code Integrity is enabled for kernel-mode code but not user-mode code. You can
    safely ignore it in this context. Finally, the syscall instruction is executed,
    transitioning control to the kernel to handle the memory allocation. When the
    function completes and control is given back to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>,
    it simply returns.
  prefs: []
  type: TYPE_NORMAL
- en: Because the syscall stub is the same for all native APIs, any modification of
    it indicates the presence of a function hook. For example, [Listing 2-6](#list2-6)
    shows the tampered syscall stub for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-6: The hooked <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtAllocateVirtualMemory()</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: Notice here that, rather than the syscall stub existing at the entry point of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>,
    an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp> instruction
    is present. EDRs commonly use this type of modification to redirect execution
    flow to their hooking DLL.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, to detect hooks placed by an EDR, we can simply examine functions in the
    copy of *ntdll.dll* currently loaded into our process, comparing their entry-point
    instructions with the expected opcodes of an unmodified syscall stub. If we find
    a hook on a function we want to use, we can attempt to evade it using the techniques
    described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Function Hooks</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of all the sensor components used in endpoint security software, function hooks
    are one of the most well researched when it comes to evasion. Attackers can use
    a myriad of methods to evade function interception, all of which generally boil
    down to one of the following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Making direct syscalls to execute the instructions of an unmodified syscall
    stub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remapping *ntdll.dll* to get unhooked function pointers or overwriting the hooked
    *ntdll.dll* currently mapped in the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking non-Microsoft DLLs from loading in the process to prevent the EDR’s
    function-hooking DLL from placing its detours
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is by no means an exhaustive list. One example of a technique that doesn’t
    fit into any of these categories is vectored exception handling, as detailed in
    Peter Winter-Smith’s blog post “FireWalker: A New Approach to Generically Bypass
    User-Space EDR Hooking.” Winter-Smith’s technique uses a *vectored exception handler
    (VEH)*, an extension to structured exception handling that allows the developer
    to register their own function for which to watch and handle all exceptions in
    a given application. It sets the processor’s trap flag to put the program into
    single-step mode. On each new instruction, the evasion code generates a single-step
    exception on which the VEH has first right of refusal. The VEH will step over
    the hook placed by the EDR by updating the instruction pointer to the chunk containing
    the original, unmodified code.'
  prefs: []
  type: TYPE_NORMAL
- en: While interesting, this technique currently only works for 32-bit applications
    and can adversely affect a program’s performance, due to the single stepping.
    For these reasons, this approach to evasion remains beyond the scope of this chapter.
    We’ll instead focus on more broadly applicable techniques.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Direct Syscalls</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By far, the most commonly abused technique for evading hooks placed on *ntdll.dll*
    functions is making direct syscalls. If we execute the instructions of a syscall
    stub ourselves, we can mimic an unmodified function. To do so, our code must include
    the desired function’s signature, a stub containing the correct syscall number,
    and an invocation of the target function. This invocation uses the signature and
    stub to pass in the required parameters and execute the target function in a way
    that the function hooks won’t detect. [Listing 2-7](#list2-7) contains the first
    file we need to create to execute this technique.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-7: Assembly instructions for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtAllocateVirtualMemory()</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first file in our project contains what amounts to a reimplementation of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>.
    The instructions contained inside the sole function will fill the EAX register
    with the syscall number. Then, a syscall instruction is executed. This assembly
    code would reside in its own *.asm* file, and Visual Studio can be configured
    to compile it using the Microsoft Macro Assembler (MASM), with the rest of the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we have our syscall stub built out, we still need a way to call
    it from our code. [Listing 2-8](#list2-8) shows how we would do that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-8: The definition of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtAllocateVirtualMemory()</samp>
    to be included in the project header file'
  prefs: []
  type: TYPE_NORMAL
- en: This function definition contains all the required parameters and their types,
    along with the return type. It should live in our header file, *syscall.h*, and
    will be included in our C source file, shown in [Listing 2-9](#list2-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-9: Making a direct syscall in C'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain()</samp> function in
    this file calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory()</samp>
    ❶ to allocate a 0x1000-byte buffer in the current process with read-write permissions.
    This function is not defined in the header files that Microsoft makes available
    to developers, so we have to define it in our own header file. When this function
    is invoked, rather than calling into *ntdll.dll*, the assembly code we included
    in the project will be called, effectively simulating the behavior of an unhooked
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>
    without running the risk of hitting an EDR’s hook.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary challenges of this technique is that Microsoft frequently
    changes syscall numbers, so any tooling that hardcodes these numbers may only
    work on specific Windows builds. For example, the syscall number for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateThreadEx()</samp>
    on build 1909 of Windows 10 is 0xBD. On build 20H1, the following release, it
    is 0xC1\. This means that a tool targeting build 1909 won’t work on later versions
    of Windows.
  prefs: []
  type: TYPE_NORMAL
- en: To help address this limitation, many developers rely on external sources to
    track these changes. For example, Mateusz Jurczyk of Google’s Project Zero maintains
    a list of functions and their associated syscall numbers for each release of Windows.
    In December 2019, Jackson Thuraisamy published the tool SysWhispers, which gave
    attackers the ability to dynamically generate the function signatures and assembly
    code for the syscalls in their offensive tooling. [Listing 2-10](#list2-10) shows
    the assembly code generated by SysWhispers when targeting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateThreadEx()</samp>
    function on builds 1903 through 20H2 of Windows 10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-10: The SysWhispers output for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtCreateThreadEx()</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This assembly code extracts the build number from the process environment block
    ❶ and then uses that value to move the appropriate syscall number into the EAX
    register ❷ before making the syscall ❸. While this approach works, it requires
    substantial effort, as the attacker must update the syscall numbers in their dataset
    each time Microsoft releases a new Windows build.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamically Resolving
    Syscall Numbers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In December 2020, a researcher known by @modexpblog on Twitter published a
    blog post titled “Bypassing User-Mode Hooks and Direct Invocation of System Calls
    for Red Teams.” The post described another function-hook evasion technique: dynamically
    resolving syscall numbers at runtime, which kept attackers from having to hardcode
    the values for each Windows build. This technique uses the following workflow
    to create a dictionary of function names and syscall numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a handle to the current process’s mapped *ntdll.dll*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enumerate all exported functions that begin with *Zw* to identify system calls.
    Note that functions prefixed with *Nt* (which is more commonly seen) work identically
    when called from user mode. The decision to use the Zw version appears to be arbitrary
    in this case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the exported function names and their associated relative virtual addresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the dictionary by relative virtual addresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the syscall number of the function as its index in the dictionary after
    sorting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using this technique, we can collect syscall numbers at runtime, insert them
    into the stub at the appropriate location, and then call the target functions
    as we otherwise would in the statically coded method.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Remapping ntdll.dll</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another common technique used to evade user-mode function hooks is to load a
    new copy of *ntdll.dll* into the process, overwrite the existing hooked version
    with the contents of the newly loaded file, and then call the desired functions.
    This strategy works because the newly loaded *ntdll.dll* does not contain the
    hooks implemented in the copy loaded earlier, so when it overwrites the tainted
    version, it effectively cleans out all the hooks placed by the EDR. [Listing 2-11](#list2-11)
    shows a rudimentary example of this. Some lines have been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-11: A technique for overwriting a hooked ntdll.dll'
  prefs: []
  type: TYPE_NORMAL
- en: Our code first gets the base address of the currently loaded (hooked) *ntdll.dll*
    ❶. Then we read in the contents of *ntdll.dll* from disk and map it into memory
    ❷. At this point, we can parse the PE headers of the hooked *ntdll.dll*, looking
    for the address of the *.text* section ❸, which holds the executable code in the
    image. Once we find it, we change the permissions of that region of memory so
    that we can write to it ❹, copy in the contents of the *.text* section from the
    “clean” file ❺, and revert the change to memory protection ❻. After this sequence
    of events completes, the hooks originally placed by the EDR should have been removed
    and the developer can call whichever function from *ntdll.dll* they need without
    the fear of execution being redirected to the EDR’s injected DLL.
  prefs: []
  type: TYPE_NORMAL
- en: While reading *ntdll.dll* from disk seems easy, it does come with a potential
    trade-off. This is because loading *ntdll.dll* into a single process multiple
    times is atypical behavior. Defenders can capture this activity with Sysmon, a
    free system-monitoring utility that provides many of the same telemetry-collection
    facilities as an EDR. Almost every non-malicious process has a one-to-one mapping
    of process GUIDs to loads of *ntdll.dll*. When I queried these properties in a
    large enterprise environment, only approximately 0.04 percent of 37 million processes
    loaded *ntdll.dll* more than once over the course of a month.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid detection based on this anomaly, you might opt to spawn a new process
    in a suspended state, get a handle to the unmodified *ntdll.dll* mapped in the
    new process, and copy it to the current process. From there, you could either
    get the function pointers as shown before, or replace the existing hooked *ntdll.dll*
    to effectively overwrite the hooks placed by the EDR. [Listing 2-12](#list2-12)
    demonstrates this technique.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-12: Remapping ntdll.dll in a suspended process'
  prefs: []
  type: TYPE_NORMAL
- en: This minimal example first opens a handle to the copy of *ntdll.dll* ❶ currently
    mapped into our process, gets its base address, and parses its PE headers ❷. Next,
    it creates a suspended process ❸ and parses the PE headers of this process’s copy
    of *ntdll.dll* ❹, which hasn’t had the chance to be hooked by the EDR yet. The
    rest of the flow of this function is exactly the same as in the previous example,
    and when it completes, the hooked *ntdll.dll* should have been reverted to a clean
    state.
  prefs: []
  type: TYPE_NORMAL
- en: As with all things, there is a trade-off here as well, as our new suspended
    process creates another opportunity for detection, such as by a hooked <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>,
    the driver, or the ETW provider. In my experience, it is very rare to see a program
    create a temporary suspended process for legitimate reasons.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function hooking is one of the original mechanisms by which an endpoint security
    product can monitor the execution flow of other processes. While it provides very
    useful information to an EDR, it is very susceptible to bypass due to inherent
    weaknesses in its common implementations. For that reason, most mature EDRs today
    consider it an auxiliary telemetry source and instead rely on more resilient sensors.
  prefs: []
  type: TYPE_NORMAL
