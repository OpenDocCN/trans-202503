<html xmlns="http://www.w3.org/1999/xhtml" xmlns:dk="http://www.kirsanov.com" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:svg="http://www.w3.org/2000/svg" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
	<head>
		<meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
		<title>Chapter 18: Bitmaps</title>
		<link href="NSTemplate_v1_inkbook.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:53262340-c02e-40d5-9273-c34656cedc88" name="Adept.expected.resource"/>
	</head>
	<body>
		<section><a id="ch18"/>
		<header>
				<h1 class="chapterTitle"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_377" title="377"/>18</span><br/><span class="ChapterTitle">Bitmaps</span></h1>
			</header>
			<p class="ChapterIntro"><a id="377"/>Most vector images start or end (often both) their lives as bitmaps (<a href="c01.xhtml#section1.1">1.1</a>), and Inkscape's SVG documents are no exception. Many vector drawings,
artistic as well as technical, are developed from tracings of photos, scans, or other
bitmap drawings; at the other end of their lifetimes, almost all
vector pieces are exported into bitmap formats for viewing in software that
cannot deal directly with vectors. Bitmaps are an important object type in Inkscape, and
the techniques for dealing with them are sufficiently complex and interesting to devote
an entire chapter to them.</p>
			<a id="section18.1"/><h2>18.1 Bitmap as Object</h2>
			<p>
				If you have a bitmap image file, insert it into your Inkscape document with the <span class="ui">File<span class="MenuArrow"> ▶ </span>Import</span> command.
You can also <span class="ui">File<span class="MenuArrow"> ▶ </span>Open</span> any bitmap file as a document in its own right. In
this case, Inkscape automatically creates a new SVG document, its page size (<a href="c03.xhtml#section3.5.2">3.5.2</a>) matching the pixel size of the bitmap, and places the bitmap on
the canvas (into the document root—that is, not in any layer). You can now add
other objects to that document and save it as SVG (if you want to get a bitmap <a id="378"/><span epub:type="pagebreak" id="Page_378" title="378"/>with the
result, you need to export it, <a href="#section18.6">18.6</a>), or you can copy and paste the bitmap
object from that document into any other.</p>
			<p><span class="NoteHead">[1.1]</span></p>
			<p>
				Inkscape can read a large number
of bitmap formats, including all of the major ones (PNG, JPG, TIFF, GIF, BMP, but it can't (yet) read the relatively new WebP even though it can export it). Choose<span class="ui"><strong>All Bitmaps</strong></span> in the <span class="ui"><strong>Import</strong></span> dialog to see only the files in 
supported bitmap formats. Past versions of Inkscape failed when trying to open bitmaps larger than several thousands pixels in one of the dimensions; now you won't have problems with images measuring tens of thousands of pixels (if your computer has enough RAM).</p>
			<p>
				Whether opened or imported, what you end up with in your document is a <em>bitmap
object</em> (<a href="#fig18-1">Figure 18-1</a>). In most aspects, this is a regular object that you can transform, duplicate, clone,
apply filters to, and so on. In the status bar, it is described as<span class="ui">Image</span> with its pixel size, for example <span class="ui">640 × 480</span>.
The pixel size of a bitmap is simply how many pixels it has horizontally and vertically; this is not the same as
the size of the bitmap object on your canvas—you can scale it to any size in your SVG, but
the intrinsic pixel size of the bitmap never changes.</p>
			<a id="fig18-1"/><figure>
				<img alt="" src="20/bi-example.svg.png"/>
				<figcaption>
					<p>Figure 18-1: A bitmap object in a document</p>
				</figcaption>
			</figure>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>
						Just as you can open a bitmap file with <span class="ui">File<span class="MenuArrow"> ▶ </span>Open</span>, you can <span class="ui">File<span class="MenuArrow"> ▶ </span>Import</span> an SVG file into the current document
(as a shortcut for opening it, selecting all its objects, and copy-pasting them into your document). Even better, both <span class="ui">Open</span> and <span class="ui">Import</span>
can fetch files from the internet—just as well as they can open local files: simply paste a URL of the file (for example,<a href="https://upload.wikimedia.org/wikipedia/commons/0/0d/Inkscape_Logo.svg">https://upload.wikimedia.org/wikipedia/commons/0/0d/Inkscape_Logo.svg</a>) into the <span class="ui">File name</span> field of the file dialog.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<a id="section18.2"/>
			<h2>18.2 Bitmap Import Options</h2>
			<p><a href="#fig18-2">Figure 18-2</a> shows the dialog  you see when you open or import a bitmap into Inkscape.</p>
			<a id="fig18-2"/>
			<figure>
				<img alt="" src="20/bi-import-dialog.png"/>
				<figcaption>
					<p>Figure 18-2: Importing a bitmap from a file</p>
				</figcaption>
			</figure>
			<a id="section18.2.1"/>
			<h3>
				18.2.1 <a id="379"/><span epub:type="pagebreak" id="Page_379" title="379"/>Linking vs. Embedding</h3>
			<p>
				The first choice you face with a bitmap is whether to <em>embed</em> it or <em>link</em> to it. 
By default, any bitmap you import into Inkscape is linked to the
document—that means the actual content of the bitmap is always taken from the original
bitmap file. The SVG document contains just a reference to that file—its
filename and path relative to the location of the SVG file.
The status bar description of a linked
bitmap object reports its filename (inkscape.ico in <a href="#fig18-1">Figure 18-1</a>).</p>
			<p>
				This way, the SVG file size is kept to a minimum, and multiple
SVG documents can reuse the same bitmap file.
This also means that any changes made to that linked bitmap file outside 
Inkscape will be reflected in the Inkscape document immediately.
Moreover, you can run an external editor (such as GIMP or
Photoshop) on your linked image from inside Inkscape by right-clicking the bitmap object
and choosing <span class="ui">Edit externally</span>.</p>
			<p>
				On the <span class="ui">Imported Images</span> page of <span class="ui">Preferences</span> (<a href="c03.xhtml#section3.1.1">3.1.1</a>),
you can uncheck <span class="ui">Automatically reload images</span> to disable the updating of imported bitmaps. 
It is also where you can choose which <span class="ui">Bitmap editor</span> you want to use to edit them via <span class="ui">Edit externally</span> (browse to select an
executable file).</p>
			<p>
				The biggest disadvantage of linked bitmaps is in how easy it is to disrupt this link. If
the bitmap file is deleted or moved to a different location relative to the SVG
document, the result is not pretty, as <a href="#fig18-3">Figure 18-3</a> demonstrates.</p>
			<a id="fig18-3"/><figure>
				<img alt="" src="20/bi-broken.svg.png"/>
				<figcaption>
					<p>Figure 18-3: What Inkscape shows when it cannot find a linked bitmap file</p>
				</figcaption>
			</figure>
			<p>This is a common problem when you send your art to someone but
forget to include the linked images.</p>
			<p>
				What matters for Inkscape is the relative location of the bitmap,
because in the <code>xlink:href</code> attribute of the <code>svg:image</code> object, it
stores the relative path from the SVG document location to the image file. For
example, if the bitmap is in the images subfolder of the folder in which
your SVG document resides, you can move that folder along with its images
subfolder to a different location without a problem.</p>
			<p>
				Inkscape can also store the <em>absolute path</em> to the image in
the <code>sodipodi:absref</code> attribute; if that attribute is present, Inkscape will use it if the relative link in<code>xlink:href</code> fails. You can enable this behavior, disabled by default, with the <span class="ui">Store absolute path for linked images</span> checkbox
on the <span class="ui">Imported Images</span> page of <span class="ui">Preferences</span>.
Using <code>sodipodi:absref</code> will restore the images if you move the
SVG document to another location on the same computer but leave the linked images
behind; it won't help, however, if you move the images, or if you try to open the SVG on a different computer without its associated images.</p>
			<p>
				To prevent any linking problems once and for all, <em>embed</em>
your image into the SVG document by choosing the corresponding option during bitmap import (<a href="#fig18-2">Figure 18-2</a>).
The status bar description for such an image looks like <span class="ui">Image <a id="380"/><span epub:type="pagebreak" id="Page_380" title="380"/>64 × 64: embedded</span>.
An embedded image is stored right inside the SVG file,
so it will never be lost. On the downside, this increases the file size of the SVG file (by
about 1.4 times the file size of the bitmap file, which may be significant). Also,
embedded images cannot be edited in an external bitmap editor and cannot be shared by multiple SVGs.</p>
			<p>
				If you imported an image as linked but now want to embed it,
use <span class="ui"><strong>Extensions<span class="MenuArrow"> ▶ </span>Images<span class="MenuArrow"> ▶ </span>Embed Images</strong></span>.
You can apply this either to the selected bitmap object (leaving all others as they are) or to all bitmap objects in the document, as shown in <a href="#fig18-4">Figure 18-4</a>.</p>
			<a id="fig18-4"/><figure>
				<img alt="" src="20/bi-embed.png"/>
				<figcaption>
					<p>
						Figure 18-4: <span class="ui">Extensions<span class="MenuArrow"> ▶ </span>Images<span class="MenuArrow"> ▶ </span>Embed Images</span> embeds linked images into SVG.</p>
				</figcaption>
			</figure>
			<p>
				With<span class="ui">Extensions<span class="MenuArrow"> ▶ </span>Images<span class="MenuArrow"> ▶ </span>Extract Image</span>, you can reverse this—extract
the selected embedded image, or all embedded images in the document, into linked file(s). You will be
asked for the path to save the extracted file, as <a href="#fig18-5">Figure 18-5</a> demonstrates.</p>
			<a id="fig18-5"/><figure>
				<img alt="" src="20/bi-extract.png"/>
				<figcaption>
					<p>
						Figure 18-5: <span class="ui">Extensions<span class="MenuArrow"> ▶ </span>Images<span class="MenuArrow"> ▶ </span>Extract Image</span> converts embedded images to linked.</p>
				</figcaption>
			</figure>
			<a id="section18.2.2"/>
			<h3>18.2.2 Size on Import</h3>
			<p>What size does an image have when you open or import it?</p>
			<p>
				By its nature, a bitmap does not have a physical size measured in inches or centimeters. What it has is the <em>pixel size</em>—for example,
960 by 480 pixels. In addition to that, some bitmap formats specify the suggested <em>resolution</em>, also called the DPI (for <em>dots per inch</em>,
a historic term meaning the same as pixels per inch).
For example, if an image of 960 by 480 pixels has the resolution of 96 dpi, then it is supposed to be displayed in a space of 10 by 5 inches.
For Inkscape, which is a vector application, this is no more than a suggestion—it treats the pixels of a bitmap as vector shapes that
can be scaled to any size.</p>
			<p><span class="NoteHead">[1.1]</span></p>
			<p><a id="381"/><span epub:type="pagebreak" id="Page_381" title="381"/>Not all bitmap formats can specify DPI, and not all images have a meaningful DPI value. Still, by default Inkscape uses the image's DPI
when it's available to calculate the <em>initial</em> size of the bitmap object on canvas. Otherwise, it uses the <span class="ui">Default import resolution</span>
(on the <span class="ui">Imported Images</span> page of <span class="ui">Preferences</span>), which is 96 dpi. 
At this resolution, the size of each pixel square is exactly 1×1 px (<a href="b01.xhtml#sectionA.6">A.6</a>). 
You can force Inkscape to use the same resolution for all imported images, disregarding their own DPI,
by turning on the <span class="ui">Override file resolution</span> checkbox.</p>
			<a id="section18.2.3"/><h3>
				18.2.3 Rendering Options <span class="NoteHead">[1.1]</span></h3>
			<p>
				Bitmaps consist of pixels (<a href="c01.xhtml#section1.1">1.1</a>), which, to Inkscape, are little different from flat-color rectangles that get
scaled, rotated, or skewed when you transform the image. If you zoom in close enough, you can even make out those
individual pixels—but only barely, because by default Inkscape tries to smooth them out. If you dislike it, you
can turn this smoothing off, when you import an image, by setting the <span class="ui">Image Rendering Mode</span> (<a href="#fig18-2">Figure 18-2</a>)
to <span class="ui">Blocky (optimizeSpeed)</span>. The default <span class="ui">None (auto)</span> and <span class="ui">Smooth (optimizeQuality)</span> are currently
the same, and both smooth out pixels at high zoom levels, as shown in <a href="#fig18-6">Figure 18-6</a>.</p>
			<a id="fig18-6"/><figure>
				<img alt="" src="20/bi-rendering.svg.png"/>
				<figcaption>
					<p>Figure 18-6: Image rendering options</p>
				</figcaption>
			</figure>
			<p>
				It makes sense to use <span class="ui">Blocky</span>, for example, when you work with pixel art where the position of each individual pixel matters.
It is also preferable for large images that are not going to be zoomed into—for them, the jaggedness of individual
pixels will never be seen, but the <span class="ui">Blocky</span> option results in slightly faster rendering.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box">
					<h2>Image Scaling in Old Inkscape Documents</h2>
					<p>
						In older versions of Inkscape, imported images did not get the <code>preserveAspectRatio</code> attribute.
Unfortunately, by SVG rules, the lack of this attribute has the same effect as its default value, which forces an image to preserve
its aspect ratio despite any transformations. If you're trying to stretch an image in an old document but it remains unstretched and just
increases the margins, you need to fix such an image by adding <code>preserveAspectRatio="none"</code>. You can do this manually
in the XML Editor, or use the <span class="ui">Set Image Attributes</span> extension to do this for multiple images (make sure <span class="ui">Support non-uniform scaling</span> is set).</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				If you have one or more images imported with wrong settings that you need to change, use the<span class="ui"><strong>Extensions<span class="MenuArrow"> ▶ </span>Images<span class="MenuArrow"> ▶ </span>Set Image Attributes</strong></span> extension. Its <span class="ui">Render images blocky</span> option can
apply to all images in the document or only to selected images.</p>
			<a id="section18.3"/><h2>
				18.3 <a id="382"/><span epub:type="pagebreak" id="Page_382" title="382"/>Clipping and Masking</h2>
			<p>
				Usually, the first thing you'll want to do to an imported bitmap is<em>crop</em> it, removing the unnecessary margins and leaving only part
of the image. Inkscape provides several ways to achieve this.</p>
			<p>All techniques in this section are shown for bitmap objects—because that's what they are most often used for—but you
can apply them to any kind of object, including groups or layers (which, as you remember, are just a special kind of groups).</p>
			<a id="section18.3.1"/><h3>18.3.1 Clipping</h3>
			<p>
				Inkscape allows any object to be <em>clipped</em> by a path, so that only part of the
object inside that path will be visible. To determine which points are inside and which are outside,
the same rules are used as for filling (<a href="c12.xhtml#section12.1.2">12.1.2</a>).</p>
			<p>
				Starting from a bitmap object, draw a
clipping path or shape over it using any convenient tool, such as the Rectangle or Pen.
Then, select both the bitmap and the path/shape and choose <span class="ui">Object<span class="MenuArrow"> ▶ </span>Clip<span class="MenuArrow"> ▶ </span>Set</span>. The
clipping path disappears (it now resides in <code>defs</code>, <a href="b01.xhtml#sectionA.4">A.4</a>), but the bottom object is now
clipped by it. To edit the clipping path (via its nodes or shape handles) without unclipping, click the corresponding
toggle in the Node tool's controls bar, as shown in <a href="#fig18-7">Figure 18-7</a>.</p>
			<a id="fig18-7"/><figure>
				<img alt="" src="20/bi-clip.svg.png"/>
				<figcaption>
					<p>Figure 18-7: Applying clipping to a bitmap object</p>
				</figcaption>
			</figure>
			<p>
				At any time, you can do <span class="ui">Object<span class="MenuArrow"> ▶ </span>Clip<span class="MenuArrow"> ▶ </span>Release</span> to remove the clipping and get
the object and its clipping path as two separate objects again.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>The clipping path does not have to coincide with pixel boundaries—when zoomed in close enough,
you can literally clip half a pixel.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				The clipping path can be a group of paths or shapes, not a single path or shape. It makes more practical sense,
however, to have a group as the clip target, not as the clipping path. When you clip a group, you can always enter it
(<a href="c04.xhtml#section4.9.1">4.9.1</a>) and work inside, adding more objects, moving them around, or perhaps replacing the
original object you intended to clip with a different one—all without releasing the clip. That's why I recommend,
even if you have a single bitmap you want to crop, to group it first with itself and then clip that group, not the
bare bitmap.</p>
			<a id="section18.3.2"/><h3>18.3.2 Masking</h3>
			<p>
				Masking is similar to clipping. You select the object and the mask and choose<span class="ui">Object<span class="MenuArrow"> ▶ </span>Mask<span class="MenuArrow"> ▶ </span>Set</span> to mask it, or <span class="ui">Object<span class="MenuArrow"> ▶ </span>Mask<span class="MenuArrow"> ▶ </span>Release</span> to remove
the mask. However, with clipping, an object is limited to the interior of the clipping path; <a id="383"/><span epub:type="pagebreak" id="Page_383" title="383"/>any properties of the clip, such as
opacity, fill color, stroke, or blur, have no effect on clipping. Clipping is <em>binary</em>: at any point,
the clipped object is either visible or not. Masking, on the other hand, is <em>gradual</em>—it may
make an object <em>partially</em> transparent.</p>
			<p>
				Here's the rule to remember: in a mask, <em>black</em> makes the masked object<em>transparent</em> (invisible), and <em>white</em> makes it <em>opaque</em> (visible).
A 50 percent gray or 50-percent-opaque white makes the masked object semitransparent, but 50-percent-opaque
black works just the same as fully opaque black (makes the object invisible).
Any points not covered by the mask, or where the mask is 100 percent transparent, are not visible
in the masked object. In other words, to make the object visible, the mask must have<em>visible lightness</em>: an opaque white mask gives 100 percent visibility, while anything darker or
more transparent produces less than 100 percent visibility.</p>
			<p>
				Obviously, masking is most useful with gradients or blurring. For example, you
can blend a photo strip with the background using a linear gradient mask, or feather
the edges of a photo cutout using a blurred mask (<a href="#fig18-8">Figure 18-8</a>).</p>
			<a id="fig18-8"/><figure>
				<img alt="" src="20/bi-mask.svg.png"/>
				<figcaption>
					<p>Figure 18-8: Masking a bitmap object</p>
				</figcaption>
			</figure>
			<p>The Node tool has another button for editing the mask of the selected object.
However, this being the Node tool, that button only allows you to node-edit the single path or shape of the
mask—you can't change its color, gradient, or blur; for this, you need to release the mask
and set it again after changing.</p>
			<p>Just as with a clipping path, both a mask and a masked object can be groups. It makes 
sense to use masking on a group, even if it's a single-object group at first, because you can
enter that group and work inside it without removing the mask.</p>
			<a id="section18.3.3"/><h3>18.3.3 Bitmap as Pattern</h3>
			<p>
				If you want your imported bitmap to remain a rectangle and you only want to shave
off some margins, you can turn it into a <em>pattern</em>
(<a href="c10.xhtml#section10.8">10.8</a>) by pressing Alt-I. This does not change the
visible display but converts a rectangular bitmap (it must not be
rotated or skewed for this to work properly) into a rectangle object
(<a href="c11.xhtml#section11.2">11.2</a>) with a pattern fill displaying the bitmap.</p>
			<p>
				This method is convenient because you can edit the shape or path and its bitmap
fill at the same time (<a href="#fig18-9">Figure 18-9</a>). 
If you resize the rectangle via its two corner handles—for example, with the Node or
Rectangle tool (<a href="c11.xhtml#section11.2.1">11.2.1</a>)—it doesn’t affect the fill, which means you can crop it by
moving the rectangle handles inward.
At the same time, you can use the pattern's
three handles to <a id="384"/><span epub:type="pagebreak" id="Page_384" title="384"/>move, scale, and rotate the pattern, as described in<a href="c10.xhtml#section10.8.2">10.8.2</a>. (Initially, the pattern handles coincide with the rectangle handles; drag the
X-shaped handle in the top-left corner to separate them.)</p>
			<a id="fig18-9"/><figure>
				<img alt="" src="20/bi-pattern.svg.png"/>
				<figcaption>
					<p>Figure 18-9: A bitmap as a pattern in a rectangle</p>
				</figcaption>
			</figure>
			<p>
				After you convert your bitmap to a patterned rectangle, you can convert it to
path with Shift-Ctrl-C and node-edit the result, or intersect (<a href="c12.xhtml#section12.2">12.2</a>) the rectangle with another path.
Transforming, by default, affects both the
shape/path and its pattern fill; see <a href="c06.xhtml#section6.11">6.11</a> for how to change that.</p>
			<a id="section18.4"/><h2>18.4 Retouching and Patching</h2>
			<p>Simple bitmap editing tasks, such as hiding defects or suppressing unnecessary
details, are possible in Inkscape using its vector tools, without resorting to an
external bitmap editor. While this approach is limited, it is often surprisingly useful
and fast.</p>
			<p>Imagine you need to remove a small blemish in a photo. Start by zooming in closely and
drawing a calligraphic stroke over it. Then, switch to the Dropper tool and pick a
color from the photo nearby to assign it to the newly created path.</p>
			<p>
				In some cases, this may be all you really need—even
such a primitive patch may blend well enough to become invisible once you zoom out. More
likely, however, the edges of the patch will still be noticeable on at least one
side. The next step is, therefore, a gradient: switch to the Gradient tool (<a href="c10.xhtml#section10.1">10.1</a>),
draw a linear or elliptic gradient trying to match the dominant direction of color
change in the background, and use the Dropper tool again (<a href="c08.xhtml#section8.8">8.8</a>) to
pick colors for the gradient stops. If the gradient fails to make the patch completely
blend into the background, see if a little blurring can help, as shown in <a href="#fig18-10">Figure 18-10</a>.</p>
			<a id="fig18-10"/><figure>
				<img alt="" src="20/bi-retouch.svg.png"/>
				<figcaption>
					<p>Figure 18-10: Covering a small blemish on the cheek with a vector patch path, made "invisible" by gradient and blur</p>
				</figcaption>
			</figure>
			<p>
				When these simple methods aren't good enough, try the new Mesh Gradient tool (<a href="c10.xhtml#section10.7">10.7</a>)
with automatic color picking for the mesh nodes (<a href="c10.xhtml#section10.7.5">10.7.5</a>) to create a more
complex or extensive patch.</p>
			<p>When you're done retouching, don't forget to group the bitmap object with all its vector
patches so the group can be moved as a single object.</p>
			<a id="section18.5"/><h2>
				18.5 <a id="385"/><span epub:type="pagebreak" id="Page_385" title="385"/>Tracing</h2>
			<p>
				For a vector editor, two crucial bitmap-related capabilities are converting a bitmap to vector objects
(<em>tracing</em>) and vice versa (<em>bitmap export</em>). Inkscape offers rich and powerful tools for these conversions, which the rest
of this chapter explores in detail.</p>
			<a id="section18.5.1"/><h3>18.5.1 Manual Tracing</h3>
			<p>
				One way of tracing a bitmap does not
involve any tools other than those you already know. Just switch to the Pen tool (<a href="c14.xhtml#section14.1.1">14.1.1</a>),
zoom in on your bitmap, and do a series of clicks around or along an area that you
want to turn into a vector path (<a href="#fig18-11">Figure 18-11</a>). Use click-and-release in a sharp corner to create a cusp node; for smooth
curved edges, make a series of short click-and-drags along the curved line. Vary the density of your clicks depending on how precisely you want to trace
a specific area. Double-click, press Enter, or click the starting node to finish the path.</p>
			<a id="fig18-11"/><figure>
				<img alt="" src="20/bi-manual.svg.png"/>
				<figcaption>
					<p>Figure 18-11: Tracing a bitmap manually using the Pen (in the default Bézier mode)</p>
				</figcaption>
			</figure>
			<p>
				For extra smoothness, you can trace in Spiro or BSpline modes (<a href="c14.xhtml#section14.1.4">14.1.4</a>); in those modes, any click
creates a smooth node, and for a cusp node, do a Shift-click. Also, in the BSpline mode, 
remember to click not on the curve itself but a little outward on its curved side, so that the smooth path is inscribed
into the polygon you create with your clicks. If you're tracing art without any curves at all, use the
Straight lines mode so that an accidental drag does not create a smooth node you don't need.</p>
			<p>This technique may seem tedious and time-consuming at first, but once
you get the hang of it, you will be able to trace complex art surprisingly quickly. Like any manual technique, its main advantage is the complete
creative control—you decide what parts to trace and what to
ignore, how to simplify complex shapes, where to diverge from the bitmap, and where to place each node. Depending on your
skill, the result may look more satisfying than either an automatic trace or a completely manual drawing.</p>
			<a id="section18.5.2"/><h3>
				18.5.2 <a id="386"/><span epub:type="pagebreak" id="Page_386" title="386"/>The Trace Bitmap Dialog</h3>
			<p>
				Inkscape's tool for automatic bitmap tracing, based on the
stand-alone Potrace open source tracer (<a href="http://potrace.sourceforge.net/">http://potrace.sourceforge.net/</a>), is very powerful. With it,
you can trace anything from a simple black-and-white logo that needs just a few nodes to
a complex photo that produces dozens of colored paths with thousands of nodes.</p>
			<p>
				The <span class="ui">Trace Bitmap</span> dialog (Shift-Alt-B, <a href="#fig18-12">Figure 18-12</a>) has two main areas: the
options panel on the left and the preview panel on the right. What the
preview panel shows is not the traced vector path (that might be time-consuming to
create) but the bitmap as it will be fed to the tracer—with all the color reduction and
filtering preprocessing as specified in the options panel. To update the preview after the
options change, click <span class="ui"><strong>Update</strong></span>. Note that the dialog always shows, and the tracer always traces,
a complete bitmap even if it is clipped, masked, or otherwise obscured in the document.</p>
			<a id="fig18-12"/><figure>
				<img alt="" src="20/bi-tracedialog.svg.png"/>
				<figcaption>
					<p>
						Figure 18-12: The <span class="ui">Trace Bitmap</span> dialog</p>
				</figcaption>
			</figure>
			<p>
				To perform the actual trace of the selected bitmap object, click <span class="ui"><strong>OK</strong></span>. For a
large bitmap, this may be slow; watch the status bar for progress messages. You can
interrupt tracing by clicking the <span class="ui">Stop</span> button; <span class="ui">Revert</span>
resets the options to defaults.</p>
			<p>
				The tracing tool has several modes of operation. These modes are divided into <em>single-scan
modes</em> that create a single path from an image and <em>multiple-scan modes</em> that create multiple
paths (grouped together).</p>
			<a id="section18.5.2.1"/><h4>
				18.5.2.1 <a id="387"/><span epub:type="pagebreak" id="Page_387" title="387"/>Brightness Cutoff</h4>
			<p><span class="ui">Brightness cutoff</span> is the simplest approach to tracing a path. The
resulting path covers anything that is darker than the threshold you set. This trace
path, while a single object, can consist of multiple nonoverlapping subpaths
(<a href="c12.xhtml#section12.1.1">12.1.1</a>). This is the best tracing mode for simple monochromatic shapes such as logos,
text, vignettes, and so on.</p>
			<p>
				The <span class="ui">Threshold</span> is set as a fraction of the image's complete brightness range (<a href="#fig18-13">Figure 18-13</a>).
For example, at 0.6, the trace path covers the areas that are darker than 
60 percent of the image; the <span class="ui">Invert</span> checkbox inverts the threshold
so the path will cover the brightest 40 percent of the image.</p>
			<a id="fig18-13"/><figure>
				<img alt="" src="20/bi-tracecutoff.svg.png"/>
				<figcaption>
					<p>
						Figure 18-13: <span class="ui">Brightness cutoff</span> tracing with different threshold values</p>
				</figcaption>
			</figure>
			<p>
				The <span class="ui">Autotrace</span> mode is another brightness-cutoff mode powered by
a different tracing backend, Autotrace, instead of the Potrace backend other modes use. In this
mode, you can't set the threshold, but the default might just work for you, as <a href="#fig18-14">Figure 18-14</a> demonstrates.</p>
			<a id="fig18-14"/><figure>
				<img alt="" src="20/bi-tracecutoff-autotrace.svg.png"/>
				<figcaption>
					<p>
						Figure 18-14: <span class="ui">Brightness cutoff</span> tracing with different threshold values</p>
				</figcaption>
			</figure>
			<a id="section18.5.2.2"/>
			<h4>18.5.2.2 Tracing Quality</h4>
			<p>
				Even if the bitmap you're tracing is itself a rendition of a vector path, the trace will
never exactly reproduce that original path. Converting a vector shape into a bitmap
always incurs loss of information, and Inkscape's tracer cannot restore this lost
information other than by guessing.  Generally it's pretty good at it, but there
will be cases—especially when tracing low-resolution bitmaps or those containing text—where you will be disappointed by its failure to recognize features
(arcs, straight lines, corners) that you can easily see in the bitmap, as shown in <a href="#fig18-15">Figure 18-15</a>.</p>
			<a id="fig18-15"/><figure>
				<img alt="" src="20/bi-tracequality.svg.png"/>
				<figcaption>
					<p>Figure 18-15: Some common quality problems with bitmap tracing</p>
				</figcaption>
			</figure>
			<p><a id="388"/><span epub:type="pagebreak" id="Page_388" title="388"/>The best piece of advice in this situation is to get your bitmap at the highest
possible <em>resolution</em>. It's very hard to get a decent
trace from a bitmap whose crucial features are several pixels across; tracing a
higher-resolution version of an image often makes a huge difference. Also, you can try to adjust
the <span class="ui">Threshold</span> and experiment with the <span class="ui">Options</span> at the bottom of the dialog
(these options apply to all modes, both single-scan and multiple-scan):</p>
			<ul>
				<li>
					The <span class="ui">Speckles</span> option removes any color blobs that are smaller than
the specified number of pixels across. This suppresses small superfluous
subpaths when tracing dirty or dithered bitmaps.</li>
				<li>
					Increasing the <span class="ui">Smooth corners</span> parameter makes the trace algorithm less inclined
to recognize sharp corners in the image. This may be useful when tracing a naturally
smooth shape from a highly pixelated, low-resolution bitmap where you don't want
accidental pixel cusps to become sharp corners in the traced path. Conversely, lowering
this parameter is appropriate when you are tracing geometric shapes without any curved
lines. When <span class="ui">Smooth corners</span> is zero, the resulting path consists almost entirely 
of straight line segments with cusp nodes between them (but corners may still be chamfered).</li>
				<li>
					The <span class="ui">Optimize paths</span> parameter tries to reduce the number of nodes in the trace
path, much like the <span class="ui">Simplify</span> command does (<a href="c12.xhtml#section12.3">12.3</a>). Raising this value decreases the
number of nodes you get but also increases the chance of introducing visible
distortions or losing the details of your shapes.</li>
			</ul><a id="section18.5.2.3"/>
			<h4>18.5.2.3 Other Single-Scan Modes</h4>
			<p>
				The <span class="ui">Edge detection</span> mode applies the edge detection filter to the bitmap
before tracing it. As a result, the trace path will contain narrow strips that follow
the color boundaries in the source bitmap. The lower the <span class="ui">Threshold</span> is, the more
edges will be detected and traced.</p>
			<p>
				The <span class="ui">Color quantization</span> mode first quantizes (divides) the image into the
given number of areas (<span class="ui">Colors</span>), each with its own dominant color, much like
when reducing a full-color image to a fixed palette in a bitmap editor. It then
traces <em>every other</em> such area, which typically makes color
gradients appear striped, as <a href="#fig18-16">Figure 18-16</a> demonstrates.</p>
			<a id="fig18-16"/><figure>
				<img alt="" src="20/bi-traceedges.svg.png"/>
				<figcaption>
					<p>
						Figure 18-16: The <span class="ui">Edge detection</span> and <span class="ui">Color quantization</span>
modes</p>
				</figcaption>
			</figure>
			<p><a id="389"/><span epub:type="pagebreak" id="Page_389" title="389"/>Very visually interesting is the <span class="ui">Centerline tracing</span> option provided by Autotrace. It's a bit similar
to <span class="ui">Edge detection</span> but creates a stroked path, not stroke-like strips. In the areas where there are no well-defined
edges, this mode creates a charming geometric pattern with a predilection for diagonals, as shown in <a href="#fig18-17">Figure 18-17</a>.</p>
			<a id="fig18-17"/><figure>
				<img alt="" src="20/bi-tracecenterline.svg.png"/>
				<figcaption>
					<p>
						Figure 18-17: The <span class="ui">Centerline tracing (autotrace)</span> mode</p>
				</figcaption>
			</figure>
			<a id="section18.5.2.4"/>
			<h4>18.5.2.4 Multiple-Scan Modes</h4>
			<p>
				Like the single-scan <span class="ui">Color quantization</span> mode, each multiple-scan mode
starts by quantizing the image into the given number of areas (the<span class="ui">Scans</span> parameter). It then traces each area separately, assigns an appropriate color or gray
level to the trace path, and groups all the paths together. With enough scans, the result for a high-resolution bitmap may look pretty
decent—faithfully reproducing the color gradients, blur, natural textures, and so on.</p>
			<p>
				The<span class="ui">Brightness steps</span> mode is the best for grayscale images; it ignores any hue or
saturation differences and groups pixels into areas based solely on their
brightness (<a href="#fig18-18">Figure 18-18</a>). The <span class="ui">Colors</span> mode considers all aspects of the colors when performing
quantization, which results in the most faithful reproduction of full-color
images (see <a id="figref16"/><a href="c15b.xhtml#ill-fig16">Figure 16 in the color insert</a>). Finally, the <span class="ui">Grays</span> option works the same as <span class="ui">Colors</span>, except the
resulting paths are painted with approximating shades of gray instead of the original
colors.</p>
			<a id="fig18-18"/><figure>
				<img alt="" src="20/bi-tracemulti.svg.png"/>
				<figcaption>
					<p>Figure 18-18: Multiple scans: 10 brightness steps</p>
				</figcaption>
			</figure>
			<p><a id="390"/><span epub:type="pagebreak" id="Page_390" title="390"/>The <span class="ui">Smooth</span> option applies a certain amount of blur to the image before
quantizing it; this may produce better results in complex photographic images. The<span class="ui">Stack scans</span> option is best kept on: it makes sure that each area's path covers
not only that area but also all areas below it in z-order, which means there will be no
gaps between the scans, as shown in <a href="#fig18-19">Figure 18-19</a>.</p>
			<a id="fig18-19"/><figure>
				<img alt="" src="20/bi-tracestack.svg.png"/>
				<figcaption>
					<p>Figure 18-19: Stacking scans vs. abutting them</p>
				</figcaption>
			</figure>
			<p>
				The <span class="ui">Remove background</span> option simply removes the bottommost scan path from the
group. This is useful when you are tracing a photo of something on a flat-color
background and want to have the vector representation of the object only without the background.</p>
			<a id="section18.5.2.5"/><h4>18.5.2.5 Object Extraction with SIOX</h4>
			<p>
				SIOX stands for "Simple Interactive Object eXtraction"; this is an algorithm that assists you in separating a foreground object
from the background in an image. In Inkscape, it is a preprocessor applied to an image before it is traced (using any mode)
when you turn on the <span class="ui">SIOX</span> checkbox next to the <span class="ui">Update</span> button.</p>
			<p>
				The "Interactive" part of SIOX suggests, however, that it cannot do its magic fully automatically but needs some help. For SIOX to work,
you must have two objects selected: the bitmap and, on top of it, a mask path that identifies the foreground object  you're interested in.
That mask path can be pretty crude, but it must cover the entire foreground object and some minimal amount of background around it.
The result of a SIOX scan is rarely perfect (in <a href="#fig18-20">Figure 18-20</a>, bits of background still need to be cleared away
around the cat), but it's a good starting point that you can get to very easily.</p>
			<a id="fig18-20"/><figure>
				<img alt="" src="20/bi-tracesiox.svg.png"/>
				<figcaption>
					<p>
						Figure 18-20: Using the <span class="ui">SIOX</span> option to extract a foreground object during tracing</p>
				</figcaption>
			</figure>
			<a id="section18.5.2.6"/>
			<h4>
				18.5.2.6 <a id="391"/><span epub:type="pagebreak" id="Page_391" title="391"/>Pixel Art Tracing <span class="NoteHead">[1.1]</span></h4>
			<p>
				Inkscape has yet another tracing backend called <em>libdepixelize</em> designed for vectorizing low-resolution bitmaps
where meaningful features can be as small as single pixels and there's little to no anti-aliasing.
Such images, usually called <em>pixel art</em>, were the norm in computer
games of the low-resolution era but, surprisingly, remain a popular subgenre of digital art even today.</p>
			<p>
				Inkscape is not the best application for creating pixel art, but the <span class="ui">Pixel art</span> tab of its <span class="ui">Trace Bitmap</span> dialog makes it 
one of the best for reusing some old (or new) pixel art in your vector designs. This doesn't mean simple re-creating a bitmap's pixels as square paths;
if you need that,  just import your bitmap with the <span class="ui">Blocky</span> option (<a href="#section18.2.3">18.2.3</a>) and use it as is without tracing.
Instead, Inkscape's pixel art tracer attempts to infer and re-create the shapes the pixel art author had in mind—from their pixel
approximations. As improbable as that sounds, the results are often very satisfying. For example, where two same-color pixels are
diagonally adjacent, the pixel art tracer is smart enough to deduce they are a single feature and melt them together in the output, as demonstrated in <a href="#fig18-21">Figure 18-21</a>.</p>
			<a id="fig18-21"/><figure>
				<img alt="" src="20/bi-tracepixel.svg.png"/>
				<figcaption>
					<p>Figure 18-21: Using the pixel art tracer</p>
				</figcaption>
			</figure>
			<p>
				The default <span class="ui">Voronoi</span> option of the pixel art tracer is usually the best; the grouping of polygons it creates is known as
a <em>Voronoi tessellation</em> (named after a 19th-century Russian mathematician). The other output option, <span class="ui">B-splines</span>, tries to further
smooth out the shapes of the Voronoi polygons, but the result is usually not as neat. For comparison, <a href="#fig18-21">Figure 18-21</a>
also shows what the regular Potrace color tracer would do to the same pixel art image.</p>
			<p><a id="392"/><span epub:type="pagebreak" id="Page_392" title="392"/>The options in the <span class="ui">Heuristics</span> section are best left to their defaults. If you want to learn more about the algorithm used by the pixel art tracer
and about what these options can give you, start with the tutorial at <a href="https://inkscape.org/doc/tutorials/tracing-pixelart/tutorial-tracing-pixelart.html">https://inkscape.org/doc/tutorials/tracing-pixelart/tutorial-tracing-pixelart.html</a>
written by the authors of this feature.</p>
			<a id="section18.6"/><h2>18.6 Bitmap Export</h2>
			<p>Nowadays, Inkscape's SVG files are often used on the web directly, thanks to web browsers' support
for SVG. Still, ours remains a bitmap-dominated world, so the quality of rasterization and the bitmap export capabilities are
crucial for a vector editor.</p>
			<a id="section18.6.1"/><h3>18.6.1 The Export PNG Image Dialog</h3>
			<p>
				Use the <span class="ui">Export PNG Image</span> dialog (Shift-Ctrl-E) to export your drawing or
any part of it into a PNG file at any resolution. The dialog's areas, top to bottom, allow you to select:</p>
			<ul>
				<li>
					The canvas area you want to export (<a href="#section18.6.1.1">18.6.1.1</a>)</li>
				<li>
					The pixel size of the bitmap (<a href="#section18.6.1.2">18.6.1.2</a>)</li>
				<li>
					The filename of the export file and its format (<a href="#section18.6.1.3">18.6.1.3</a>)</li>
				<li>
					Additional export options (<a href="#section18.6.1.4">18.6.1.4</a>)</li>
				<li>
					Export format parameters (<a href="#section18.6.1.5">18.6.1.5</a>)</li>
			</ul><a id="section18.6.1.1"/>
			<h4>18.6.1.1 Export Area</h4>
			<p>
				For the area you want to export, you have four main options at the top of the dialog:<span class="ui">Page</span>, <span class="ui">Drawing</span>, <span class="ui">Selection</span>, and <span class="ui">Custom</span> (<a href="#fig18-22">Figure 18-22</a>).</p>
				<a id="fig18-22"/>
				<figure>
				<img alt="" src="20/bi-export.png"/>
				<figcaption>
					<p>
						Figure 18-22: The <span class="ui">Export PNG Image</span> dialog</p>
				</figcaption>
			</figure>
			<p>
				The <span class="ui">Page</span> button exports the page of your SVG
document, as visualized by the frame on the canvas (<a href="c02.xhtml#section2.3">2.3</a>), but any objects beyond the edges of the page are excluded.
The <span class="ui">Drawing</span> button exports 
the bounding box of the entire visible drawing (hidden layers or objects don't count), which can be smaller or larger than the page; the page
frame is not visible in the exported bitmap.
When the <span class="ui">Selection</span> button is pressed, 
the dialo`g exports the bounding box of the current selection (again, it can be inside or outside the page frame—this does not
matter).</p>
			<p>
				Alternatively, you can click <span class="ui">Custom</span> and type your own document coordinates for
the top-left corner (<span class="ui">x0</span>, <span class="ui">y0</span>) as well as either the bottom-right corner (<span class="ui">x1</span>, <span class="ui">y1</span>) or
the width and height of the export area. You can also choose the measurement unit for these values
(the default is <code>px</code>, <a href="b01.xhtml#sectionA.6">A.6</a>).</p>
			<p>
				The <span class="ui">Export PNG Image</span> dialog is not modal—that is, you can keep working on the canvas while it is open.
Unless you choose <span class="ui">Custom</span>, the dialog responds to
changing the selection by switching to the <span class="ui">Selection</span> mode and
updating the coordinates to match the bounding box of the new selection. If nothing is
selected and you are not in <span class="ui">Custom</span>, the dialog defaults to the <span class="ui">Drawing</span>
mode.</p>
			<a id="section18.6.1.2"/><h4>
				18.6.1.2 <a id="393"/><span epub:type="pagebreak" id="Page_393" title="393"/>Image Size</h4>
			<p>
				For the <span class="ui">Image size</span>, type the width and height in pixels (here, it is bitmap pixels, not px units), or adjust
the resolution value of <span class="ui">dpi</span>, which stands for <em>dots</em> (that is, pixels) <em>per inch</em>. The
default resolution of 96 dpi results in one SVG px unit translating to one
pixel of the rendered bitmap. The horizontal and vertical DPI values are always the same;
changing any one of the three editable values (<span class="ui">Width</span>, <span class="ui">Height</span>, <span class="ui">dpi</span>) changes the other two
to match.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>In versions of Inkscape older than 0.92, the default one-px-to-one-pixel resolution was 90 dpi, not 96.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>If your drawing contains some px-sized objects (such as strokes a
whole number of px wide) and you want them to export precisely into the
pixels of the bitmap, it may not be sufficient to choose the resolution of 96 dpi. For
example, a 1×1 px square in SVG might fall on a boundary between pixels in an
exported bitmap and thus would end up smeared into four adjacent pixels instead of
one.</p>
			<p>
				One way to fix this is by applying the <span class="ui">Pixelize</span> filter (<a href="c17.xhtml#section17.4">17.4</a>) to the exported objects. Another is to suppress anti-aliasing in PNG export options (<a href="#section18.6.1.5">18.6.1.5</a>). Both those methods work, but you may find that your single-pixel features disappear or get snapped to a wrong pixel position in export. To fix this properly, you need to put in some more work. Enable the grid (<a href="c07.xhtml#section7.2">7.2</a>) and snap your objects to the default 1
px-sized grid (or use the <span class="ui">Pixel Snap</span> extension, <a href="c13.xhtml#section13.4.2.6">13.4.2.6</a>). Make sure your export area is itself
aligned to the grid—that is, it has integer <span class="ui">x0</span>
and <span class="ui">y0</span> coordinates when measured in px. After that, exporting at 96 dpi will give you a
perfectly crisp image with no unwanted anti-aliasing.</p>
			<a id="section18.6.1.3"/><h4>
				18.6.1.3 <a id="394"/><span epub:type="pagebreak" id="Page_394" title="394"/>Export Filename and Format</h4>
			<p>
				For the <span class="ui">Filename</span>, you can type or paste a complete path to the file  or click the <span class="ui">Export As</span> button to access
your filesystem and choose a folder and a file. If you've already exported this object or the whole page,
Inkscape will try to fill in the filename automatically for you (<a href="#section18.6.1.4">18.6.1.4</a>).
If the file exists, you will be asked if you want to
overwrite it.</p>
			<p><span class="NoteHead">[1.1]</span></p>
			<p>
				For a long time, PNG was the only export format Inkscape supported.
By default, Inkscape still exports to PNG; the PNG format preserves the maximum rendering quality Inkscape is capable of, including alpha transparency,
anti-aliasing, and RGB color with 8 bits per channel. Since version 1.1, you can also export to some other formats:
JPG (lossy), WebP (lossy or lossless), and TIFF (lossless), as well as optimized PNG (lossy or lossless).
Choose one of these formats from the <span class="ui"><strong>Save as type</strong></span> list in the <span class="ui"><strong>Export As</strong></span> filename chooser, or
simply append the corresponding extension to the filename (.jpg, .webp, or .tiff; you cannot select optimized PNG by extension).</p>
			<a id="section18.6.1.4"/><h4>18.6.1.4 Export Hints</h4>
			<p>
				When you're exporting a single selected object, the export filename and resolution
are remembered and stored in that object's node in the SVG document (so you may need to save once you're done with the
export). These values are then restored into the <span class="ui">Export PNG Image</span> dialog whenever you select this object to export again.
Similarly, the filename and resolution are remembered when you're exporting the <span class="ui">Page</span> or <span class="ui">Drawing</span>.</p>
			<p>
				These<em>export hints</em> are great time savers when you need to export
multiple objects—for example, slices of a web page
graphic— to multiple bitmap files. If you've done this once (and saved your document
after that), just select your objects with the <span class="ui">Export PNG Image</span> dialog open and you
will see their saved export filenames in the <span class="ui">Filename</span> field.
For the same reason—to make it easier to export multiple objects one by one—the
dialog stays open even after you click <span class="ui">Export</span> (although there's also a <span class="ui">Close when complete</span>
checkbox under the <span class="ui">Filename</span> field).</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box">
					<h2>Export Hints in SVG</h2>
					<p>
						The export hints are stored in the <code>inkscape:export-filename</code>, <code>inkscape:export-xdpi</code>, and <code>inkscape:export-ydpi</code> extension attributes in the object's SVG element or (for <span class="ui">Page</span> or <span class="ui">Drawing</span> options) in the root <code>svg:svg</code> element.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				You can speed up the process even more by selecting all objects you want to
export and checking the <span class="ui">Batch export all selected objects</span>
checkbox. Now, when you click <span class="ui">Export</span>, Inkscape will create one bitmap file per selected
object. If an object has already been exported before—that is, has the filename and
resolution hints saved—those values will be used for it; otherwise, a name for the
bitmap file will be constructed from the object's ID (for example,
text2402.png, see <a href="b01.xhtml#sectionA.9">A.9</a>), and the file will be placed in the folder
where your SVG document was last saved.</p>
			<p>
				Normally, even if you are exporting a selection, you are actually exporting an
area—the bounding box of the selection—which may contain other
visible objects. Checking the <span class="ui">Hide all except selected</span>
checkbox ensures that the exported <a id="395"/><span epub:type="pagebreak" id="Page_395" title="395"/>bitmap will contain <em>only</em> the exported objects,
while all others, even if they overlap the export area, will not be rendered.</p>
			<a id="section18.6.1.5"/><h4>
				18.6.1.5 Export Format Parameters <span class="NoteHead">[1.1]</span></h4>
			<p>Inkscape allows you to adjust various parameters of export formats. There is no preview window,
but if you want to try different parameter values and see the result at once, use this trick.
Export your object and then import it back into Inkscape, placing it next to the object or area you're exporting.
Now, you can export it over and over to the same file with different options, and Inkscape will reload the newly exported file each time,
displaying the effect of your settings immediately.</p>
			<a id="section18.6.1.5.1"/><h5>18.6.1.5.1 PNG</h5>
			<p>
				In the dialog's <span class="ui">Advanced</span> section (collapsed by default), you can set some format options for the regular PNG export (not optimized PNG).</p>
			<ul>
				<li><span class="ui">Use interlacing</span> creates interlaced PNGs which, when used on a web page, will display a lower-resolution version of the image before it is fully transmitted from the web server.</li>
				<li><span class="ui">Bit depth</span> controls how color is represented in the output PNG. The default value is <code>RGBA_8</code>, which means RGB color, Alpha channel (transparency), 8 bits per channel; this is exactly how color is represented in Inkscape's renderer, so this option stores the program's rasterization output optimally. You can trim the output by dropping the alpha channel (<code>RGB_8</code>) or by switching to grayscale with (<code>GrayAlpha_8</code>) or without alpha (<code>Gray_8</code>) and with any number of bits per channel, down to 1 bit for a strictly black-and-white image (<code>Gray_1</code>). You can also use full-color representation with 16 bits per channel (<code>RGBA_16</code>), but since the renderer is still 8-bit, this will not actually increase the amount of information in the output (for example, if you're experiencing banding in gradients, this option will not reduce it).</li>
				<li><span class="ui">Compression</span> sets the level of compression of the PNG file; the optimal value depends on the content of the file, so if you want to get the smallest possible PNG file, I recommend using external utilities like <em>pngcrush</em> on Inkscape's PNGs.</li>
				<li><span class="ui">pHYs dpi</span> is the resolution value recorded in the PNG file; this value is rarely used, so there's no harm in leaving it at 0.</li>
				<li><span class="ui">Antialiasing</span> is actually a parameter of Inkscape's renderer (called Cairo), not of the PNG file. This is where you can either turn off all anti-aliasing (the <code>CAIRO_ANTIALIASING_NONE</code> option) or try to improve on the default <code>CAIRO_ANTIALIASING_GOOD</code> by choosing <code>CAIRO_ANTIALIASING_BEST</code>.</li>
			</ul><a id="section18.6.1.5.2"/>
			<h5>18.6.1.5.2 Other Formats</h5>
			<p>
				For formats other than regular PNG, an <span class="ui">Options</span> dialog pops up after the progress bar is finished—that is, after Inkscape is done rendering the bitmap.</p>
			<p>
				For JPG, you can set the <span class="ui">Quality</span> (1 to 100, default 90) and the <span class="ui">Progressive</span> option; when downloaded over a slow connection,
a Progressive JPG file will show a low-resolution preview before the complete full-resolution image (this <a id="396"/><span epub:type="pagebreak" id="Page_396" title="396"/>only makes sense for large images).
WebP has a <span class="ui">Lossless</span> option and adjustable parameters for <span class="ui">Quality</span> and <span class="ui">Speed</span>. TIFF has only<span class="ui">Quality</span> and <span class="ui">Speed</span> parameters.</p>
			<p>
				For the optimized PNG format, you can turn on <span class="ui">Interlaced</span> (similar to JPG's <span class="ui">Progressive</span> option) and choose how many trials will be performed
in an attempt to achieve the best compression for the image. On the <span class="ui">Lossy Options</span> tab of the <span class="ui">Options</span> dialog, you can enable various reductions
(bit depth, color type, palette) that can make the image even smaller but also lower quality.</p>
			<a id="section18.6.2"/><h3>18.6.2 Exporting via the Command Line</h3>
			<p>
				All of the capabilities of the <span class="ui">Export PNG Image</span> dialog are also available when you run
Inkscape from the command line. This way,
Inkscape can be used as a GUI-less utility from scripts or programs to automate various SVG
rendering jobs. For example, this is how you export an object with<code>id="text2402"</code> at 600 dpi:</p>
			<pre>$ inkscape document.svg --export-fileid=img/text.png --export-id=text2402 \ --export-dpi=600</pre>
			<p>
				Exporting to formats other than PNG via command line does not work as of Inkscape 1.1.
For a complete list of Inkscape's command line switches, refer to <a href="b03.xhtml#chC">Appendix C</a>.</p>
			<a id="section18.6.3"/><h3>18.6.3 Icon Preview</h3>
			<p>
				While there's no preview pane in the <span class="ui">Export PNG Image</span> dialog, if you use Inkscape
to create icons, one way to preview your work rendered to different icon sizes is via
the <span class="ui">Icon Preview</span> dialog, which you can call from the <span class="ui">View</span> menu (<a href="#fig18-23">Figure 18-23</a>).</p>
			<a id="fig18-23"/><figure>
				<img alt="" src="20/icon-preview.png"/>
				<figcaption>
					<p>
						Figure 18-23: The <span class="ui">Icon Preview</span> dialog</p>
				</figcaption>
			</figure>
			<p>
				This dialog contains previews of your document rasterized in a few typical icon
sizes, from 16×16 to 128×128 pixels; in the left side of the dialog, one of these
renderings is additionally displayed magnified so you can see how your vector objects
translate to actual pixels. Click the <span class="ui"><strong>Selection</strong></span> checkbox to
switch the preview from showing the entire document to the current selection.</p>
			<a id="section18.6.4"/><h3>
				18.6.4 <a id="397"/><span epub:type="pagebreak" id="Page_397" title="397"/>Make a Bitmap Copy</h3>
			<p>
				After you export something from your document, 
you can import (<a href="#section18.1">18.1</a>) the bitmap file back to check how rasterization worked. If, however, you need that bitmap in
your document and not as a separate file, you can use Inkscape's shortcut: the <span class="ui">Edit<span class="MenuArrow"> ▶ </span>Make a Bitmap Copy</span> command.</p>
			<p>
				This command exports the selected objects (without saving the file) and imports the result as an embedded bitmap back
to the document, overlaying it on top of the selection. You can set the export’s resolution on the <span class="ui">Imported Images</span>
page of the <span class="ui">Preferences</span>; the default is 96 dpi, and for that value, the
command will additionally snap the export area to the 1 px grid, making sure the pixels
of the created bitmap align exactly with the boundaries of px squares, as shown in <a href="#fig18-24">Figure 18-24</a>.</p>
			<a id="fig18-24"/><figure>
				<img alt="" src="20/bi-copy.svg.png"/>
				<figcaption>
					<p>Figure 18-24: A 96-dpi bitmap copy of a path, aligned to the
grid</p>
				</figcaption>
			</figure>
			<p>
				You can use this command for a quick preview of how your art will rasterize (after
which, the bitmap object can be deleted). It is also useful when you have some very
slow-rendering filters (<a href="c17.xhtml#section17.6">17.6</a>) but do not want to work in the No
Filters or Outline modes; in that case, just make a bitmap copy of the
filtered object and hide the slow-rendering original.</p>
			<a id="section18.7"/><h2>18.7 Bitmap Filters and Extensions</h2>
			<p>
				You can apply Inkscape's filters (<a href="c17.xhtml#ch17">Chapter 17</a>) to any kind of object, but they are perhaps most
useful when you have a bitmap that is not editable with the standard vector tools. I especially recommend
blend mode overlays (<a href="c17.xhtml#section17.2">17.2</a>) and the preset filters (<a href="c17.xhtml#section17.4">17.4</a>) in the<span class="ui">Blurs</span>, <span class="ui">Color</span>, and <span class="ui">Image Effects</span> submenus. You should use filters whenever possible because they are
nondestructive and do not change the original bitmap file you imported.</p>
			<p>
				Sometimes, however, you really do need to change the bitmap data itself. As mentioned above (<a href="#section18.2.1">18.2.1</a>), with a linked image,
you can just run your favorite bitmap editor on it, and you can even launch that editor from within Inkscape. This capability, however, is not available for
embedded images. In those cases, extensions (<a href="c19.xhtml#ch19">Chapter 19</a>) can help; a number of common bitmap processing algorithms have been implemented as extensions.
Here are those that are most useful—and not (or not quite) achievable via filters—from the <span class="ui">Extensions<span class="MenuArrow"> ▶ </span>Raster</span> submenu (<a href="#fig18-25">Figure 18-25</a>):</p>
			<ul>
				<li><a id="398"/><span epub:type="pagebreak" id="Page_398" title="398"/><span class="ui">Adaptive Threshold</span> shifts each pixel to extreme values in each of the RGB channels, depending on whether that pixel is above or below a threshold. That threshold is calculated from that pixel's local neighborhood (whose size is defined by the <span class="ui">Width</span> and <span class="ui">Height</span> parameters). This is a valuable transformation, because it is similar to the way humans perceive images—we judge a point "light" or "dark" relative to its local area, not relative to the average lightness of the entire image.</li>
				<li><span class="ui">Add Noise</span> gives you a choice of various types of noise to overlay on your
image; most types look more or less like scattered sand.</li>
				<li><span class="ui">Crop</span> is a way to reduce the size of an SVG with an embedded image—unlike clipping, it actually removes part of the bitmap data
from the edges (you can specify how much to crop on each side).</li>
				<li><span class="ui">Despeckle</span>, <span class="ui">Enhance</span>, and <span class="ui">Reduce Noise</span> implement various noise
reduction algorithms.</li>
				<li><span class="ui">Dither</span> randomly scatters pixels in a bitmap, with <span class="ui">Amount</span> specifying
the radius of scattering.</li>
				<li><span class="ui">Equalize</span> applies histogram equalization to the image.</li>
				<li><span class="ui">HSB Adjust</span> adjusts the hue (in the range of –360 to 360), saturation (–200
to 200), and brightness (–200 to 200).</li>
				<li><span class="ui">Implode</span>, <span class="ui">Swirl</span>, and <span class="ui">Wave</span> smoothly distort an image more or less as their names suggest. Wave uses
a horizontal sine wave with the given amplitude and wavelength.</li>
				<li><span class="ui">Level</span> blackens pixels that are darker than the <span class="ui">Black Point</span>, whitens
pixels brighter than the <span class="ui">White Point</span>, and scales those that fall within this
range to the full color range. When the <span class="ui">Black Point</span> is greater than 0 or the <span class="ui">White Point</span> is less than 100,
the extension increases the contrast of the image. <span class="ui">Gamma Correction</span> specifies additional brightness correction
(1 means no change).</li>
				<li><span class="ui">Level (with Channel)</span> is the same as <span class="ui">Level</span> but for a single channel only.</li>
				<li><span class="ui">Median</span> paints each pixel with the median color of its circular
neighborhood; the result is somewhat similar to blurring, but <span class="ui">Median</span> preserves sharp boundaries between colors that are too different.</li>
				<li><span class="ui">Normalize</span> increases contrast by expanding the color range of pixels to the
full range of color (for example, if the image has no reds, all colors will be tinted
toward red to compensate for that).</li>
				<li><span class="ui">Oil Painting</span> is similar to <span class="ui">Median</span> but additionally melts similar adjacent
colors in a way that's reminiscent of paint strokes.</li>
				<li><span class="ui">Resample</span> changes the pixel size of the bitmap without scaling it. Resampling<em>up</em> does not change the
appearance of an image, but it may be useful if you plan to apply some other effect and want
it to work with higher resolution. Resampling <em>down</em>
makes the image lose detail without changing its dimensions in the document; like <span class="ui">Crop</span>, this
reduces the file size of an SVG document with an embedded bitmap.</li>
				<li><span class="ui">Sharpen</span> and <span class="ui">Unsharp Mask</span> are the classic algorithms for sharpening
an image.</li>
			</ul><a id="fig18-25"/>
			<figure>
				<img alt="" src="20/bi-effects.svg.png"/>
				<figcaption>
					<p>
						Figure 18-25: Examples of extension effects from <span class="ui">Extensions<span class="MenuArrow"> ▶ </span>Raster</span></p>
				</figcaption>
			</figure>
			<p><a id="399"/><span epub:type="pagebreak" id="Page_399" title="399"/>Unlike filters, extensions make permanent changes to the bitmaps they process.
You can undo an extension but you cannot, for example, readjust its parameters after it is applied. Also, unlike filters, these extensions can work<em>only</em> on bitmap objects—you cannot, for example, apply a bitmap effect to a clone of a bitmap. If the bitmap is linked, these effects embed
it and work on the embedded copy, not on the external linked original.
Refer to <a href="c19.xhtml#section19.1">19.1</a> for general tips on working with extension effects.</p>
			<a id="section18.8"/><h2>18.8 Color Management</h2>
			<p>Color management aims to ensure that the colors in your artwork are
correctly translated between different output devices, typically from screen to
print. The ranges of colors that can be reproduced are different for different devices,
and some color distortions are unavoidable. Color management allows you to preview,
control, and thereby minimize such distortions.</p>
			<p>Inkscape has never claimed to be the best in class when it comes to color management.
You can use screen-proofing to preview output colors, but you can't, using
Inkscape alone, prepare a color-separated file for print with a color profile embedded.
However, in most cases, you can get the result you need by employing some additional software, as described in this section.</p>
			<p>On the other hand, in the years since the first edition of this book, the importance of
color management has certainly diminished. These days, a lot more graphics go from screen to screen
than from screen to paper. Also, consumer-grade computer screens and desktop color printers
are now much more uniform in quality—and most desktop printers will accept and print the
same RGB data as is displayed on your screen, performing their own color conversion without you needing to
do any extra work.</p>
			<p>It's only when you intend to print your design on high-end commercial printers, usually by sending it to a print service provider,
that you will need to look into Inkscape's color management facilities. 
Even then, some providers can perform color management on your documents for you if you ask
them to. If you have sufficient control over this process (for example, can review the
print proofs), this is usually the best option, because the print service staff knows what
works best with their equipment.</p>
			<a id="section18.8.1"/><h3>18.8.1 ICC Color Profiles</h3>
			<p><a id="400"/><span epub:type="pagebreak" id="Page_400" title="400"/>An ICC color profile is a file that describes the color capabilities of an output
device. If you want to prepare your document for outputting on a specific device, you
must first obtain the ICC profile that exactly corresponds to this device and the output
media (for example, the paper type used for printing). Sometimes, you can find an
appropriate profile file on the internet (for example, on the website of the printer
hardware's manufacturer), but typically, you would request it from the print service provider
you will be using.</p>
			<p>
				Once you get the destination profile, you need to install it into your operating system. 
On Windows 10, it's as easy as right-clicking an .icc file and selecting <span class="ui">Install Profile</span>.
On Linux, you need to have <em>gnome-color-manager</em> or <em>colord-kde</em> installed; then, double-click the .icc
file and click Import.</p>
			<a id="section18.8.2"/><h3>18.8.2 Screen Proofing</h3>
			<p>
				Since the color range of a typical printer is narrower than that of a computer display,
Inkscape can proof (preview) the print output on your screen by emulating the printer
colors. This is called <em>screen proofing</em> or <em>soft proofing</em>. 
For this, you need to have two ICC color profiles: one for the printer you're going
to use and another for your screen.</p>
			<p>
				Ideally, you should have your display <em>calibrated</em> using a special hardware device
called <em>colorimeter</em>; this calibration creates a custom ICC profile of your
display. Unless your quality
requirements are truly demanding, however, you can probably make do with a generic RGB profile,
such as the one that comes installed with Windows.</p>
			<p>
				In <span class="ui"><strong>Preferences</strong></span>, go to the <span class="ui"><strong>Input/Output<span class="MenuArrow"> ▶ </span>Color management</strong></span> page. Choose the display
profile (if you have more than one) in the <span class="ui"><strong>Display adjustment</strong></span> section. Then, in the <span class="ui"><strong>Proofing</strong></span>
section, check <span class="ui"><strong>Simulate output on screen</strong></span> and choose the <span class="ui"><strong>Device profile</strong></span>
of your target device (that is, the printer on which you're planning to print your artwork).
After that is set up, toggle the color-managed view via <span class="ui"><strong>View<span class="MenuArrow"> ▶ </span>Color-Managed View</strong></span> or 
the little toggle button in between the vertical and horizontal scroll bars in Inkscape's editing window.</p>
			<p>
				For both screen and target device profiles, you can also choose <span class="ui">Device rendering
intent</span>. The default <span class="ui">Perceptual</span> is the best choice in most cases; if you
want the output to look as color-rich as possible (for example, when printing simple
business graphics), try <span class="ui">Saturation</span>.</p>
			<p>
				If a screen color is "out of gamut"—that is, cannot be rendered on the output device
at all—you can make it immediately visible by designating an out-of-gamut marker color.
For example, if your design has no reds, check <span class="ui"><strong>Mark out of gamut colors</strong></span>
and choose red for <span class="ui"><strong>Out of gamut warning color</strong></span>. Then, wherever you see red in
your drawing, you'll know you need to change the actual color of that object (which is 
shown in the status bar or in the <span class="ui">Fill and Stroke</span> dialog—the red mark
is only in the drawing) if you want it to print without gross distortions.</p>
			<a id="section18.8.3"/><h3>
				18.8.3 <a id="401"/><span epub:type="pagebreak" id="Page_401" title="401"/>Separating and Embedding</h3>
			<p>
				Screen proofing is helpful, but it may not be enough—you may be required to
produce a file already converted to the target color system. Such files are often called<em>color-separated</em> because they contain the separate color channels (usually CMYK,<a href="c08.xhtml#section8.4.2">8.4.2</a>) corresponding to the inks of the output device. Such a file may also have the
target color profile embedded into it. The most commonly used formats are PDF (vector)
and TIFF (bitmap); both can contain color-separated data and embed ICC profiles.</p>
			<p>Although it can export PDF and PNG, Inkscape cannot do
color separation or profile embedding. You need some other software to do the job for
you, such as Adobe Photoshop (for TIFF) or Illustrator (for PDF); both can import
Inkscape's SVG format directly.</p>
			<p>
				You can also use open source software. The Scribus page
layout program (<a href="http://scribus.net/">http://scribus.net/</a>) will import SVG and create
color-separated PDFs; starting from Inkscape 1.0.1, you can set up PDF export via Scribus from 
Inkscape's <span class="ui">Save</span> dialog (see the Inkscape 1.0.1 Release Notes for details). The Cyan plug-in for GIMP
(<a href="https://github.com/rodlie/cyan/">https://github.com/rodlie/cyan/</a>) will take Inkscape-exported PNG bitmap
and convert it into a color-separated TIFF with screen proofing for complete control.</p>
		</section>
	</body>
</html>