- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Injection
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 注入
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Clients interact with APIs in a variety of ways, such as by creating, modifying,
    or deleting data. Challenges arise when applications must handle their arbitrary
    input. Should applications ever trust the input external clients send? What about
    internal clients?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端与 API 的交互方式多种多样，例如创建、修改或删除数据。当应用程序必须处理这些任意输入时，问题就会出现。应用程序是否应该信任外部客户端发送的输入？内部客户端呢？
- en: In this chapter, you’ll learn about injection vulnerabilities and discover why
    it is important to identify and secure the various entry points into applications
    backed by a GraphQL API, as well as the consequences of not doing so. We will
    identify opportunities to influence an application’s logic and manipulate it to
    take actions it wasn’t specifically designed to do. Successful injection can lead
    to outcomes ranging from web page manipulation to the execution of code on a database.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解注入漏洞，并发现为什么识别和保护由 GraphQL API 支持的应用程序的各个入口点至关重要，以及不这样做的后果。我们将识别影响应用程序逻辑并操控其执行未专门设计操作的机会。成功的注入可能导致从网页篡改到在数据库上执行代码的各种后果。
- en: GraphQL servers typically work with a datastore, such as relational databases
    like MySQL, document databases like Elasticsearch, key/value stores like Redis,
    or even graph databases like Neo4j. All of these can be vulnerable to injection-based
    vulnerabilities. In this chapter, we’ll discuss three types of injection vulnerabilities.
    Some, like SQL injection (SQLi) and operating system command injection, impact
    backend services such as servers and databases. The other, XSS, impacts clients.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 服务器通常与数据存储进行交互，如 MySQL 等关系型数据库、Elasticsearch 等文档数据库、Redis 等键值存储，甚至 Neo4j
    等图形数据库。所有这些都可能受到基于注入的漏洞的影响。在本章中，我们将讨论三种类型的注入漏洞。一些漏洞，如 SQL 注入（SQLi）和操作系统命令注入，会影响后端服务，如服务器和数据库。另一类漏洞，XSS，会影响客户端。
- en: Injection Vulnerabilities in GraphQL
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL 中的注入漏洞
- en: Injection vulnerabilities occur when an application accepts and processes untrustworthy
    input without any sanitization. *Sanitization* is a security measure that involves
    checking input and removing potentially dangerous characters from it. The absence
    of such a check could allow the input to be interpreted as a command or a query
    and execute on either the client side or server side. Injection is a broad class
    of attacks that can impact a network ecosystem, such as operating systems, clients’
    browsers, databases, third-party systems, and so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注入漏洞发生在应用程序接受并处理未经信任的输入时，且没有进行任何清理操作。*清理*是一个安全措施，涉及检查输入并去除其中可能危险的字符。缺乏此类检查可能会导致输入被解释为命令或查询，并在客户端或服务器端执行。注入是一个广泛的攻击类别，可能影响网络生态系统，如操作系统、客户端浏览器、数据库、第三方系统等。
- en: 'An application could accidentally introduce injection vulnerabilities in a
    variety of ways, including the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可能通过多种方式不小心引入注入漏洞，包括以下几种：
- en: The application does not implement security checks on the input it receives.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序没有对接收到的输入进行安全检查。
- en: The application uses insecure libraries (such as a parser) to process user input.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序使用不安全的库（如解析器）处理用户输入。
- en: The application passes the received user input to a third system, which doesn’t
    implement security checks on the input.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序将接收到的用户输入传递给第三方系统，而该系统没有对输入进行安全检查。
- en: The application accepts input and displays it to the client without transforming
    it in any way.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序接受输入并将其展示给客户端，而没有进行任何形式的转换。
- en: An application that implements a GraphQL API can become vulnerable to injection
    vulnerabilities after it starts allowing clients to manipulate data through interfaces
    such as the arguments of queries, mutations, or subscriptions. Even a GraphQL
    API that allows clients to only read data might have vulnerabilities in certain
    interfaces, such as query filters. While the risk can be decreased, it is almost
    never zero.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 GraphQL API 的应用程序，在允许客户端通过查询、变更或订阅等接口操作数据后，可能会变得容易受到注入漏洞的攻击。即使是仅允许客户端读取数据的
    GraphQL API，也可能在某些接口（如查询过滤器）中存在漏洞。虽然可以减少风险，但几乎不可能完全消除。
- en: Accepting user input is hard to avoid completely when building APIs. As the
    application becomes more complex, it will need some sort of input to be useful.
    For example, websites like Twitter or Facebook would be completely pointless if
    they didn’t allow user input. User actions, like tweeting, writing a Facebook
    post on someone’s wall, or uploading a dinner photo to Instagram, all require
    user input.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建API时，完全避免接受用户输入是很困难的。随着应用程序变得更加复杂，它将需要某种输入才能有用。例如，如果Twitter或Facebook不允许用户输入，那么它们将毫无意义。用户的操作，如发推文、在别人墙上写Facebook帖子，或上传晚餐照片到Instagram，都需要用户输入。
- en: The Blast Radius of Malicious Input
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恶意输入的影响范围
- en: Whether it comes from human clients, or machines such as other servers on the
    network, it is important to consider that input can be malicious. Even internal
    machines could become compromised and send malicious input to other servers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是来自人类客户端，还是来自网络上其他服务器等机器，都必须考虑输入可能是恶意的。即使是内部机器也可能被攻击并向其他服务器发送恶意输入。
- en: Applications are often developed under a relaxed trust model. Such a trust model
    assumes that input coming into the GraphQL API from other internal systems on
    the same network is safe, while input that originates from external sources is
    unsafe. This approach is very common, but designing systems in this way can backfire;
    if we are able to hack a system and send commands to another host on the network,
    we could easily move laterally to other servers. [Figure 8-1](#figure8-1) illustrates
    a similar scenario.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常在宽松的信任模型下开发。这样的信任模型假设来自同一网络的其他内部系统的输入是安全的，而来自外部来源的输入是不安全的。这种方法非常常见，但以这种方式设计系统可能会适得其反；如果我们能够攻击一个系统并向网络上的其他主机发送命令，就可以轻松横向移动到其他服务器。[图
    8-1](#figure8-1)说明了一个类似的场景。
- en: '![](image_fi/502840c08/f08001.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08001.png)'
- en: 'Figure 8-1: Network trust boundaries'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '图 8-1: 网络信任边界'
- en: This figure describes a penetration test in which we’ve identified an internet-facing
    GraphQL API server, the *public server*. This server happens to be dual-homed,
    meaning it has two network interfaces and is part of two separate networks. The
    server is vulnerable to injection attacks, as it does not adequately check the
    incoming queries it receives from clients.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该图描述了一个渗透测试，在测试过程中，我们发现了一个面向互联网的GraphQL API服务器，称为*公共服务器*。该服务器是双重接入的，意味着它有两个网络接口，并且属于两个独立的网络。该服务器容易受到注入攻击，因为它没有充分检查来自客户端的传入查询。
- en: Now, imagine that the *internal server* in the diagram is also a GraphQL server
    designed to trust any incoming queries from systems on the same network. It was
    configured in this way because it is not internet facing, and the security architects,
    in their threat model, assumed the local network was safe. Yet if the public server
    is hacked, an attacker could send malicious queries to the internal server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设图中的*内部服务器*也是一个GraphQL服务器，设计时假定信任来自同一网络系统的任何传入查询。之所以如此配置，是因为它不面向互联网，安全架构师在其威胁模型中假定本地网络是安全的。然而，如果公共服务器被黑客攻击，攻击者可能会向内部服务器发送恶意查询。
- en: This is why it is important to always perform security checks on any user input.
    It is also why it’s crucial for hackers to test for injection vulnerabilities
    wherever we identify that input is allowed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么始终对任何用户输入进行安全检查非常重要。也正是因为如此，黑客在发现允许输入的地方进行注入漏洞测试是至关重要的。
- en: The OWASP Top 10
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OWASP Top 10
- en: Every few years, OWASP releases new vulnerability class rankings for web applications
    under the *OWASP Top 10* project to help companies focus their security mitigation
    efforts on the most prevalent software flaw classes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每隔几年，OWASP会发布新的Web应用程序漏洞类别排名，作为*OWASP Top 10*项目的一部分，帮助公司将安全缓解工作集中在最常见的软件缺陷类别上。
- en: The injection vulnerability class has been on the OWASP Top 10 list for almost
    two decades. In the latest OWASP Top 10 release, injection vulnerability was ranked
    third, as shown in [Table 8-1](#table8-1).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注入漏洞类别已经连续近二十年出现在OWASP Top 10榜单中。在最新的OWASP Top 10发布中，注入漏洞排名第三，如[表格 8-1](#table8-1)所示。
- en: 'Table 8-1: OWASP Top 10'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '表格 8-1: OWASP Top 10'
- en: '| **Identifier** | **Vulnerability** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **标识符** | **漏洞** |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| A01 | Broken access control |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| A01 | 访问控制破坏 |'
- en: '| A02 | Cryptographic failures |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| A02 | 加密失败 |'
- en: '| A03 | Injection |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| A03 | 注入 |'
- en: '| A04 | Insecure design |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| A04 | 不安全的设计 |'
- en: '| A05 | Security misconfiguration |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| A05 | 安全配置错误 |'
- en: '| A06 | Vulnerable and outdated components |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| A06 | 脆弱和过时的组件 |'
- en: '| A07 | Identification and authentication failures |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| A07 | 身份识别和身份验证失败 |'
- en: '| A08 | Software and data integrity failures |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| A08 | 软件和数据完整性失败 |'
- en: '| A09 | Security logging and monitoring failures |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| A09 | 安全日志记录和监控失败 |'
- en: '| A10 | Server-side request forgery |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| A10 | 服务器端请求伪造 |'
- en: OWASP has also started tracking top vulnerabilities in APIs under a dedicated
    project, the *API Security Top 10*. This split helps distinguish between API-
    and non-API-based vulnerabilities. In the latest project release as of this writing,
    injection was ranked eighth, as shown in [Table 8-2](#table8-2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP 也开始在一个专门的项目中跟踪 API 中的顶级漏洞，*API 安全性前十*。这个划分有助于区分基于 API 和非 API 的漏洞。在截至本文撰写时的最新项目发布中，注入漏洞排在第八位，如
    [表 8-2](#table8-2) 所示。
- en: 'Table 8-2: API Security Top 10'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2：API 安全性前十
- en: '| **Identifier** | **Vulnerability** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **标识符** | **漏洞** |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| API1 | Broken object-level authorization |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| API1 | 对象级授权破坏 |'
- en: '| API2 | Broken user authentication |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| API2 | 用户身份验证破坏 |'
- en: '| API3 | Excessive data exposure |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| API3 | 过度数据暴露 |'
- en: '| API4 | Lack of resource and rate limiting |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| API4 | 缺乏资源和速率限制 |'
- en: '| API5 | Broken function-level authorization |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| API5 | 功能级授权破坏 |'
- en: '| API6 | Mass assignment |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| API6 | 批量赋值 |'
- en: '| API7 | Security misconfiguration |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| API7 | 安全配置错误 |'
- en: '| API8 | Injection |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| API8 | 注入 |'
- en: '| API9 | Improper asset management |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| API9 | 不当的资产管理 |'
- en: '| API10 | Insufficient logging and monitoring |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| API10 | 日志记录和监控不足 |'
- en: Injection vulnerabilities can have devastating consequences in APIs, and it
    is important to become comfortable with injection testing in both non-API-based
    web applications and APIs when performing penetration tests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注入漏洞在 API 中可能会带来灾难性的后果，因此，在进行渗透测试时，熟悉非 API 基于的 Web 应用程序和 API 中的注入测试非常重要。
- en: The Injection Surface
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入表面
- en: GraphQL APIs are typically designed to accept input from clients, perform backend
    actions such as database reading and writing, and return a response.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API 通常设计为接受来自客户端的输入，执行如数据库读写等后台操作，并返回响应。
- en: 'Technically, you can have read-only queries such as the following, which doesn’t
    change anything on the server side. Clients can’t use the query to pass arbitrary
    data, only the GraphQL fields `id` and `ipAddr`, which are defined in the GraphQL
    schema, as you might remember from Chapter 3:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你可以有只读查询，例如以下示例，这不会改变服务器端的任何内容。客户端不能通过查询传递任意数据，只能使用在 GraphQL 架构中定义的字段
    `id` 和 `ipAddr`，你可能还记得它们在第 3 章中有提到：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An application developer can get away with having only read-only operations
    if the application wasn’t designed to interact with clients in ways that allow
    them to modify data on the server, but in reality, this will almost never be the
    case. As applications become more complex and feature rich, they’ll need to accept
    client input through interfaces such as query arguments, field arguments, or both.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序没有设计为与客户端以允许修改服务器数据的方式进行交互，应用程序开发人员可以只进行只读操作，但实际上，这几乎从不会是这种情况。随着应用程序变得更加复杂和功能丰富，它们将需要通过查询参数、字段参数或两者来接受客户端输入。
- en: 'Let’s consider a few GraphQL components that allow clients to pass arbitrary
    inputs before diving into the various injection vulnerabilities. For each of these
    interfaces, you should ask yourself a few important questions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在深入探讨各种注入漏洞之前，考虑一些允许客户端传递任意输入的 GraphQL 组件。对于这些接口，你应该问自己一些重要的问题：
- en: Is the application verifying the incoming client input at all?
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否有验证传入的客户端输入？
- en: Does the application accept dangerous characters?
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否接受危险字符？
- en: Does the application throw exceptions when unexpected characters are sent as
    part of a query?
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否在查询中发送意外字符时抛出异常？
- en: Does GraphQL check the value type passed to the arguments?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 是否检查传递给参数的值类型？
- en: Can we infer from the GraphQL server response (or out-of-band response) whether
    an injection attempt was successful?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否从 GraphQL 服务器响应（或带外响应）中推断出注入尝试是否成功？
- en: Injection tests will require some trial and error, but once you experience a
    breakthrough, you’ll have a very satisfying feeling.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注入测试需要一些反复试验，但一旦你突破了瓶颈，你会有一种非常满足的感觉。
- en: Query Arguments
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询参数
- en: 'GraphQL operations such as queries, mutations, and subscriptions can be designed
    to accept arguments. Consider the following query, which passes a `limit` argument
    with an integer value of `100`. While this operation is still read-only, it provides
    an interface for manipulating the server’s response through the use of query filters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 操作，如查询、变更和订阅，可以设计为接受参数。考虑以下查询，它传递了一个值为 `100` 的 `limit` 参数。虽然这个操作仍然是只读的，但它提供了一个接口，可以通过使用查询过滤器来操控服务器的响应：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This argument doesn’t allow us to execute code, but we could use it to influence
    the server in a variety of ways. For example, providing a negative value (such
    as `-1`) to an `Int`-type argument such as `limit` could result in unexpected
    behaviors. Sometimes APIs interpret `-1` value as *return all*, in which case
    the server will return the entire list of objects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数不允许我们执行代码，但我们可以利用它以各种方式影响服务器。例如，向一个 `Int` 类型的参数（如 `limit`）提供一个负值（如 `-1`），可能会导致意外的行为。有时候，API
    会将 `-1` 的值解释为 *返回所有*，在这种情况下，服务器将返回整个对象列表。
- en: When you identify an argument of type `String`, you might want to spend some
    time experimenting with various injection payloads. Consider the GraphQL mutation
    in [Listing 8-1](#listing8-1), which uses the `createPaste` top-level field.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你识别出一个 `String` 类型的参数时，可能需要花一些时间尝试不同的注入载荷。考虑 [列表 8-1](#listing8-1) 中的 GraphQL
    变更，它使用了 `createPaste` 顶层字段。
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-1: Mutation input points'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-1：变更输入点
- en: 'The `createPaste` field is pretty self-explanatory; it takes information from
    the client and uses that data to create a brand-new paste in the database. In
    this example, the client controls the paste’s format via three arguments to `createPaste`:
    `content`, `title`, and `public`. These arguments are of different types. For
    example, `content` and `title` are of the scalar type `String`, while `public`
    is of the scalar type `Boolean`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`createPaste` 字段非常直观；它接收来自客户端的信息，并利用这些数据在数据库中创建一个全新的粘贴。在这个示例中，客户端通过三个参数控制粘贴的格式：`content`、`title`
    和 `public`。这些参数具有不同的类型。例如，`content` 和 `title` 是标量类型 `String`，而 `public` 是标量类型
    `Boolean`。'
- en: 'Imagine how a paste creation operation might look from a database operation
    perspective. Consider the following SQL example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，从数据库操作的角度看，粘贴创建操作可能是怎样的。考虑以下 SQL 示例：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When a client query is received by a GraphQL API, the server may need to look
    up information in or write information to a database in order to fulfill the query.
    If the GraphQL API is designed to process input from arguments such as `content`
    and `title` without proper security validations, data can be injected directly
    into the SQL command, which could allow for a SQLi vulnerability.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端查询被 GraphQL API 接收时，服务器可能需要查找或写入数据库中的信息，以便满足查询。如果 GraphQL API 设计为处理诸如 `content`
    和 `title` 等参数的输入，而没有适当的安全验证，数据可能会被直接注入到 SQL 命令中，这可能导致 SQL 注入漏洞。
- en: 'Consider the following SQLi example, in which a SQL command is inserted into
    the `content` argument:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 SQL 注入示例，其中 SQL 命令被插入到 `content` 参数中：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A query crafted this way could be converted to a SQL query on the backend,
    and it may look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构造的查询可以在后台转换为 SQL 查询，它可能如下所示：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is important to note that GraphQL APIs could (and should) have multiple layers
    of defensive checks in the query resolvers to mitigate against any forms of injection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，GraphQL API 应该在查询解析器中有多层防御性检查，以减少各种形式的注入攻击。
- en: Field Arguments
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段参数
- en: 'Just like top-level fields, GraphQL fields in selection sets can also take
    arguments. Consider the following query:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像顶层字段一样，GraphQL 查询中的选择集字段也可以接受参数。考虑以下查询：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using this query, we can return a list of users’ IDs and usernames. By default,
    the `username` field is lowercase in the response. Adding the `capitalize` argument
    and setting it to `true` results in the GraphQL resolver capitalizing the username.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个查询，我们可以返回用户的 ID 和用户名列表。默认情况下，响应中的 `username` 字段是小写的。添加 `capitalize` 参数并将其设置为
    `true`，则 GraphQL 解析器会将用户名首字母大写。
- en: Field arguments could be implemented to take different actions when specified
    in a field and, in a security context, aren’t that different from other arguments
    (such as arguments to directives). Values passed to field arguments can be inserted
    into a database or influence logic. The application might even use them as part
    of a different internal API call, so it’s important to test these when they exist.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 字段参数可以被实现为在指定的字段中执行不同的操作，在安全上下文中，它们与其他参数（例如指令的参数）没有太大区别。传递给字段参数的值可以被插入数据库或影响逻辑。应用程序甚至可能将其作为不同内部
    API 调用的一部分，因此在存在这些参数时进行测试非常重要。
- en: Query Directive Arguments
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询指令参数
- en: The query directives attached to certain GraphQL fields can also accept arguments,
    often of scalar types such as `String` and `Boolean`. The way these directives
    are used is completely implementation dependent, but it’s always worth checking
    which kinds of values they allow a client to send.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到某些 GraphQL 字段的查询指令也可以接受参数，通常是标量类型，如 `String` 和 `Boolean`。这些指令的使用方式完全依赖于实现，但检查它们允许客户端发送哪些类型的值始终是值得的。
- en: 'Consider the following query:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下查询：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we specify an argument named `style` to the directive `show_network`.
    The `style` argument is of type `String`, and it accepts arbitrary strings. In
    this example, we supply `cidr` as the value. In the backend, this will transform
    the `ipAddr` (IP address) field into an address using *Classless Inter-Domain
    Routing (CIDR)* notation. For example, the IPv4 address 192.168.0.1 will become
    192.168.0.1/32.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们为指令 `show_network` 指定了一个名为 `style` 的参数。`style` 参数的类型是 `String`，并且接受任意字符串。在此示例中，我们提供了
    `cidr` 作为值。在后台，这将把 `ipAddr`（IP 地址）字段转换为使用 *无类域间路由（CIDR）* 标记法的地址。例如，IPv4 地址 192.168.0.1
    将变为 192.168.0.1/32。
- en: Query directive arguments can be prone to injections too. Attackers can use
    them to influence the way the server returns the response to the specific field.
    For instance, a query directive might use the argument `where`, which then gets
    translated to a SQL-matching pattern (for example, the `LIKE` operator).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 查询指令参数也可能容易受到注入攻击。攻击者可以利用这些参数来影响服务器返回特定字段的响应方式。例如，查询指令可能使用参数 `where`，然后该参数被转换为
    SQL 匹配模式（例如，`LIKE` 操作符）。
- en: You can use the introspection query shown in [Listing 8-2](#listing8-2) to get
    only the available directives by using the `__schema` meta-field with the `directives`
    field.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 [清单 8-2](#listing8-2) 中显示的内省查询，通过使用 `__schema` 元字段和 `directives` 字段来仅获取可用的指令。
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-2: A GraphQL introspection query used to list directives'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-2：用于列出指令的 GraphQL 内省查询
- en: Operation Names
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作名称
- en: '*Operation names* are strings we can add to GraphQL operations such as queries,
    mutations, or subscriptions. They are often used to uniquely name each query when
    multiple queries are sent together. GraphQL graphical IDEs such as GraphiQL Explorer
    and GraphQL Playground use the operation name as a way to allow clients to choose
    which operation to run when more than one query exists in a document through a
    drop-down menu, as shown in [Figure 8-2](#figure8-2).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作名称* 是我们可以添加到 GraphQL 操作中的字符串，例如查询、变更或订阅。它们通常用于在发送多个查询时唯一标识每个查询。像 GraphiQL
    Explorer 和 GraphQL Playground 这样的 GraphQL 图形化 IDE 使用操作名称作为一种方式，允许客户端在文档中存在多个查询时通过下拉菜单选择要执行的操作，如
    [图 8-2](#figure8-2) 所示。'
- en: '![](image_fi/502840c08/f08002.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08002.png)'
- en: 'Figure 8-2: Executing a selected query based on its operation name in GraphiQL
    Explorer'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2：在 GraphiQL Explorer 中基于操作名称执行选定的查询
- en: Operation names are also used for other purposes, such as debugging and logging.
    In fact, they are interesting potential injection vectors because applications
    can use them in many ways. For instance, some applications use operation names
    for analytics, to determine which queries clients use the most. The operation
    name string could end up in different systems, such as logging systems, relational
    databases, cache databases, and so on. It is important to check whether the GraphQL
    API allows special characters as part of the operation name, as this could turn
    out to be an injectable interface.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 操作名称也用于其他目的，如调试和日志记录。事实上，它们是有趣的潜在注入向量，因为应用程序可以以多种方式使用它们。例如，一些应用程序使用操作名称进行分析，以确定客户端最常使用的查询。操作名称字符串可能最终出现在不同的系统中，如日志系统、关系数据库、缓存数据库等。因此，检查
    GraphQL API 是否允许将特殊字符作为操作名称的一部分是很重要的，因为这可能成为一个可注入的接口。
- en: Operation names are typically alphanumeric, but some GraphQL server implementations
    are more permissive than others when it comes to the type of characters they permit.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 操作名称通常是字母数字的，但有些 GraphQL 服务器实现对其允许的字符类型比其他服务器更宽松。
- en: Input Entry Points
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入入口点
- en: When attempting to perform injection testing against GraphQL APIs, we need to
    find a way to discover input entry points. If we are lucky and introspection is
    left enabled, we can often quickly access the various queries, mutations, and
    subscriptions that the API supports, along with information about its types, fields,
    arguments, and so on, using a GraphQL IDE tool like Altair, GraphiQL Explorer,
    or GraphQL Playground.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 GraphQL API 进行注入测试时，我们需要找到一种方法来发现输入入口点。如果运气好且 introspection（自省功能）仍然启用，我们通常可以快速访问
    API 支持的各种查询、变更和订阅，以及有关其类型、字段、参数等信息，使用像 Altair、GraphiQL Explorer 或 GraphQL Playground
    这样的 GraphQL IDE 工具。
- en: To view this information about DVGA in Altair, set the URL to ***http://localhost:5013/graphiql***
    and click the **Save** button (the diskette icon) located at the top right. Click
    the **Refresh** button located next to the Save button, and then click **Docs**.
    You should see a section for queries, mutations, and subscriptions. Click any
    of them to see the types of arguments that exist within each, as shown in the
    screenshot in [Figure 8-3](#figure8-3).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Altair 中查看有关 DVGA 的信息，请将 URL 设置为 ***http://localhost:5013/graphiql***，然后点击位于右上角的
    **保存** 按钮（磁盘图标）。点击保存按钮旁边的 **刷新** 按钮，然后点击 **文档**。你应该能看到查询、变更和订阅的部分。点击任意一项，查看每个部分中存在的参数类型，如
    [图 8-3](#figure8-3) 中的截图所示。
- en: '![](image_fi/502840c08/f08003.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08003.png)'
- en: 'Figure 8-3: Schema documentation in the Altair client'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3：Altair 客户端中的架构文档
- en: If luck isn’t on our side and introspection was disabled on the server, we can
    lean on tools such as Clairvoyance, which we touched on in Chapter 6, to reconstruct
    the schema and discover the various available inputs. Clairvoyance will fuzz the
    GraphQL document inputs to discover all of its various operations, fields, types,
    and arguments necessary to rebuild the complete schema view, which we can then
    use to identify all possible inputs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运气不好且服务器上禁用了 introspection，我们可以依赖像 Clairvoyance 这样的工具（我们在第六章中提到过），通过它重建架构并发现各种可用的输入。Clairvoyance
    会对 GraphQL 文档的输入进行模糊测试，以发现其所有操作、字段、类型和参数，从而重建完整的架构视图，然后我们可以利用这个视图来识别所有可能的输入。
- en: We will next explore how common types of injections could look in the GraphQL
    world by performing some injection testing against DVGA.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过对 DVGA 进行一些注入测试，探索在 GraphQL 世界中常见的注入类型。
- en: SQL Injection
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 注入
- en: '*SQL injection* is one of the oldest types of vulnerabilities out there. SQLi
    vulnerabilities happen when client input is directly inserted into a SQL command
    without proper character escaping. This condition allows a hacker to close out
    the intended SQL query and introduce their own SQL command, effectively interfering
    with the query the application makes to its database.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQL 注入* 是最古老的漏洞类型之一。SQLi 漏洞发生在客户端输入没有经过适当的字符转义而直接插入 SQL 命令时。这种情况允许黑客关闭原本的
    SQL 查询，并引入他们自己的 SQL 命令，从而有效地干扰应用程序与数据库之间的查询。'
- en: 'A SQLi vulnerability in GraphQL APIs could have devastating consequences. Full
    or even partial access to a database could result in any of the following consequences:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API 中的 SQLi 漏洞可能带来灾难性的后果。完全或部分访问数据库可能导致以下任一后果：
- en: '**Impact to data integrity.** A SQLi vulnerability could allow us to manipulate
    data, such as by altering data within a database table.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对数据完整性的影响。** 一个 SQLi 漏洞可能允许我们操控数据，例如修改数据库表中的数据。'
- en: '**Impact to data confidentiality.** SQLi could allow us to leak information
    from a database, either from the application’s specific SQL tables or from other
    tables in the same database. This information could include PII, password hashes,
    sensitive tokens, and so on.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对数据保密性的影响。** SQLi 可能允许我们泄露数据库中的信息，无论是来自应用程序特定的 SQL 表，还是来自同一数据库中的其他表。这些信息可能包括个人身份信息（PII）、密码哈希、敏感令牌等。'
- en: '**Impact to data availability.** SQLi could allow us to delete segments of
    the database or completely drop its tables, resulting in data loss and application
    instabilities.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对数据可用性的影响。** SQLi 可能允许我们删除数据库的部分内容或完全删除表，导致数据丢失和应用程序不稳定。'
- en: In recent years, modern web frameworks have gotten better at mitigating SQLi
    vulnerabilities by offering out-of-the-box defense mechanisms such as parameterized
    queries. Utilizing audited and vetted frameworks enables developers to write code
    more securely by using the framework’s built-in security features, such as through
    functions and libraries.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，现代Web框架在缓解SQL注入漏洞方面取得了更好的进展，通过提供现成的防御机制，如参数化查询。利用经过审计和验证的框架使开发人员能够通过使用框架内置的安全功能（如函数和库）编写更安全的代码。
- en: Understanding the Types of SQL Injection
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解SQL注入的类型
- en: There are two categories of SQLi vulnerabilities, each of which has a few subcategories.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入漏洞有两个类别，每个类别下都有一些子类别。
- en: Classic SQL Injection
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 经典SQL注入
- en: 'You know you’ve run into *classic SQLi* when the application returns SQL query
    errors during injection testing. These errors can be displayed directly in the
    web page or become apparent through network inspection. Two techniques are used
    to identify a classic SQLi vulnerability: error based and union based.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在注入测试期间返回SQL查询错误时，你就遇到了*经典SQL注入*。这些错误可以直接显示在网页上，或者通过网络检查显现出来。识别经典SQL注入漏洞使用两种技术：基于错误和基于联合。
- en: '*Error-based SQLi* is used to identify SQLi vulnerabilities through error observation.
    Applications that throw SQL errors to the client as a result of a failure in SQL
    query execution could allow us to find the right attack pattern to successfully
    exploit the SQLi vulnerability.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于错误的SQL注入*是通过观察错误来识别SQL注入漏洞。那些在SQL查询执行失败时向客户端抛出SQL错误的应用程序可能会让我们找到正确的攻击模式，从而成功利用SQL注入漏洞。'
- en: '*Union-based SQLi* is used to identify SQLi vulnerabilities by leveraging the
    `UNION` SQL operator. `UNION` concatenates results of multiple `SELECT` statements,
    which can then be returned to the client.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于联合的SQL注入*是通过利用`UNION` SQL操作符来识别SQL注入漏洞的。`UNION`用于连接多个`SELECT`语句的结果，然后将其返回给客户端。'
- en: Blind SQL Injection
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 盲SQL注入
- en: In *blind SQLi*, we are given no visible indications that a vulnerability exists.
    Applications could fail silently or redirect their errors to somewhere other than
    the client. Two discovery techniques apply to the blind SQLi category.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在*盲SQL注入*中，我们没有可见的迹象表明存在漏洞。应用程序可能会悄无声息地失败，或者将错误重定向到客户端以外的地方。有两种发现盲SQL注入漏洞的技术。
- en: '*Time-based SQLi* forces the application to wait for a certain amount of time
    before returning a response. By supplying a SQLi payload that instructs the database
    to wait for a certain number of seconds, we can infer that the application is
    vulnerable if a similar delay occurs in returning the final response.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于时间的SQL注入*迫使应用程序在返回响应之前等待一段时间。通过提供一个SQL注入负载，指示数据库等待一定的秒数，我们可以推断如果返回最终响应时出现类似的延迟，则应用程序可能存在漏洞。'
- en: '*Boolean-based SQLi* allows us to infer whether the application is vulnerable
    to SQLi by constructing a payload that will return a Boolean result such as `true`
    or `false`. By using this testing technique, we could influence the way the application
    presents data to the client, which helps us identify whether the vulnerability
    exists.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于布尔值的SQL注入*允许我们通过构造一个将返回布尔结果（如`true`或`false`）的负载来推断应用程序是否容易受到SQL注入攻击。通过使用这种测试技术，我们可以影响应用程序向客户端展示数据的方式，这帮助我们识别是否存在漏洞。'
- en: Testing for SQLi
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试SQL注入
- en: While SQLi vulnerabilities are on the decline, they can still be found occasionally.
    As hackers, we should assume that the application we’re testing may not have the
    appropriate controls in place to prevent SQLi and test for it wherever and whenever
    possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQL注入漏洞有所减少，但偶尔仍然可以发现。作为黑客，我们应假设我们正在测试的应用程序可能没有适当的控制措施来防止SQL注入，因此应在任何可能的地方和时间进行测试。
- en: 'Testing for SQLi can be done in a variety of ways, such as the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入的测试可以通过多种方式进行，例如以下几种：
- en: Submitting characters like single (`'`) or double (`"`) quotes and observing
    how the application handles unexpected inputs and errors.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交诸如单引号(`'`)或双引号(`"`)等字符，并观察应用程序如何处理意外的输入和错误。
- en: Fuzzing input fields and observing application errors that may indicate database
    query failures.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊测试输入字段并观察可能表明数据库查询失败的应用程序错误。
- en: Submitting SQL commands that introduce delays, such as by using `BENCHMARK`
    and `SLEEP` for MySQL databases, `WAITFOR` `DELAY` and `WAITFOR` `TIME` for Microsoft
    SQL Server, or `pg_sleep` for PostgreSQL databases, and then performing a response-timing
    analysis to identify whether the injection was successful. This is especially
    helpful when we are performing blind SQLi testing, whereby application errors
    are invisible to us.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交SQL命令引入延迟，例如使用MySQL数据库的`BENCHMARK`和`SLEEP`，Microsoft SQL Server的`WAITFOR`
    `DELAY`和`WAITFOR` `TIME`，或者PostgreSQL数据库的`pg_sleep`，然后进行响应时间分析，以判断注入是否成功。这在我们进行盲注测试时特别有用，因为应用程序错误对我们是不可见的。
- en: SQLi in GraphQL can be introduced through any interface that accepts client
    input. In this section, we will explore a SQLi example in GraphQL by using DVGA.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入（SQLi）可以通过任何接受客户端输入的接口在GraphQL中引入。在本节中，我们将通过使用DVGA来探索GraphQL中的SQLi示例。
- en: Testing DVGA for SQLi with Burp Suite
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Burp Suite对DVGA进行SQLi测试
- en: The first step to injection testing in GraphQL is to find places where we can
    make alterations to queries. We can start by looking at the schema documentation
    in Altair. [Figure 8-4](#figure8-4) shows the Query section. The documentation
    also has mutation and subscription sections, so have a look at those too.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL中进行注入测试的第一步是找到我们可以修改查询的地方。我们可以从Altair中的模式文档开始查看。[图8-4](#figure8-4)显示了查询部分。文档中还有变更和订阅部分，记得也要查看一下这些部分。
- en: '![](image_fi/502840c08/f08004.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08004.png)'
- en: 'Figure 8-4: Queries in DVGA'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4：DVGA中的查询
- en: 'As you can see, we have a few queries to choose from. Now we must prioritize
    which areas to focus on. Notice that a few fields, such as `systemUpdate`, `systemHealth`,
    `audits`, and `deleteAllPastes`, don’t take any kinds of arguments, so we are
    better off focusing on the ones that do. Let’s zoom in on the `pastes` field,
    which takes three optional arguments:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有一些查询可以选择。现在我们需要优先考虑哪些区域进行重点关注。注意到一些字段，比如`systemUpdate`、`systemHealth`、`audits`和`deleteAllPastes`，这些字段不接受任何参数，因此我们最好专注于那些接受参数的字段。让我们重点查看`pastes`字段，它接受三个可选参数：
- en: '`public`, of type `Boolean`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`，类型为`Boolean`'
- en: '`limit`, of type `Integer`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`，类型为`Integer`'
- en: '`filter`, of type `String`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`，类型为`String`'
- en: The `filter` argument could be a valuable candidate for SQLi testing, because
    it accepts string values and its name implies that it filters results. This filtering
    could involve backend query resolver logic that uses SQL operations, such as the
    SQL `WHERE` operator, in order to fulfill a query.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`参数可能是SQLi测试的一个有价值的候选项，因为它接受字符串值，且其名称暗示它用于过滤结果。这个过滤可能涉及后台查询解析器逻辑，使用SQL操作，如SQL的`WHERE`运算符，以完成查询。'
- en: Now that we have a target, let’s begin interacting with DVGA and proxying traffic.
    Open Burp Suite through Kali’s **Applications** menu, and then click **Open Browser**
    to open the built-in browser located under the **Proxy** tab and navigate to ***http://localhost:5013***.
    After the application loads, make sure Burp Suite is in **Intercept** mode. Navigate
    to the **Private Pastes** page in DVGA located in the left sidebar. You should
    see a GraphQL request similar to the one in [Figure 8-5](#figure8-5).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了目标，接下来开始与DVGA交互并代理流量。通过Kali的**应用程序**菜单打开Burp Suite，然后点击**打开浏览器**，在**代理**标签下打开内置浏览器并访问***http://localhost:5013***。应用加载后，确保Burp
    Suite处于**拦截**模式。接着，在DVGA的左侧边栏中导航到**Private Pastes**页面。你应该能看到一个类似于[图8-5](#figure8-5)的GraphQL请求。
- en: '![](image_fi/502840c08/f08005.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08005.png)'
- en: 'Figure 8-5: Intercepting a GraphQL query in Burp Suite'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-5：在Burp Suite中拦截GraphQL查询
- en: As you can see, DVGA sends an HTTP POST request using the GraphQL `pastes` query
    operation to get the list of private pastes from the GraphQL API server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，DVGA使用GraphQL的`pastes`查询操作发送HTTP POST请求，以从GraphQL API服务器获取私人粘贴列表。
- en: If you switch to the WebSockets History tab, you will notice that DVGA uses
    the subscription operation as well ([Figure 8-6](#figure8-6)). The subscription
    operation in this context allows the client to read new pastes from the API as
    soon as they are created by subscribing to the `pastes` event.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你切换到WebSockets历史记录标签，你会注意到DVGA也使用了订阅操作（[图8-6](#figure8-6)）。在此上下文中，订阅操作允许客户端通过订阅`pastes`事件，实时读取API中新创建的内容。
- en: To more easily manipulate requests, send the request to Burp Suite’s Repeater
    by right-clicking anywhere in the request window and clicking **Send to Repeater**.
    Then click the **Repeater** tab to see the captured request. This allows you to
    replay requests on demand.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要更轻松地操作请求，可以通过右键单击请求窗口中的任意位置并点击**发送到重发器**，将请求发送到 Burp Suite 的 Repeater。然后点击**Repeater**标签查看捕获的请求。这允许你按需重放请求。
- en: 'Let’s change the query so that it uses the `filter` argument. First, modify
    the query to look like the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改查询，使其使用 `filter` 参数。首先，将查询修改为如下所示：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](image_fi/502840c08/f08006.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08006.png)'
- en: 'Figure 8-6: The historical WebSocket traffic view in Burp Suite'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-6：Burp Suite 中的历史 WebSocket 流量视图
- en: Note that when a query contains double quotes, we must escape the quotes by
    using the backslash (`\`) character in Burp, as shown in [Figure 8-7](#figure8-7).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当查询包含双引号时，我们必须在 Burp 中使用反斜杠（`\`）字符来转义引号，如[图 8-7](#figure8-7)所示。
- en: '![](image_fi/502840c08/f08007.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08007.png)'
- en: 'Figure 8-7: Using Burp Repeater to send modified GraphQL queries'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7：使用 Burp Repeater 发送修改后的 GraphQL 查询
- en: 'Click **Send** to send the query to the GraphQL server. In response to this
    query, we should receive a paste that matches our filter search pattern. More
    specifically, it matches the `content` field:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**发送**将查询发送到 GraphQL 服务器。响应此查询时，我们应收到一个符合我们过滤搜索模式的 paste。更具体地说，它匹配 `content`
    字段：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This filter search pattern suggests that some sort of SQL query is happening
    behind the scenes and that this query behaves similarly to the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤搜索模式表明在后台某处正在执行某种 SQL 查询，并且该查询的行为类似于以下内容：
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This SQL query will return the `id`, `content`, and `title` columns from the
    `pastes` SQL table. Using the `WHERE` operator, the result will be filtered to
    return only results related to pastes that include the string `My` `First` `Paste`
    in their content, as defined by the `LIKE` operator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 SQL 查询将从 `pastes` SQL 表中返回 `id`、`content` 和 `title` 列。使用 `WHERE` 运算符，结果将被筛选，只返回内容中包含字符串
    `My` `First` `Paste` 的 pastes 相关记录，正如 `LIKE` 运算符所定义的那样。
- en: We want to throw some characters at the application that would potentially break
    this query and result in errors, which might indicate that the application is
    sending our input directly into the query. For instance, the SQL query would break
    if we added a single quote (`'`) after the search string, because this would result
    in an orphaned opening single quote without a closing single quote.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望向应用程序输入一些字符，可能会破坏此查询并导致错误，这可能表明应用程序将我们的输入直接发送到查询中。例如，如果我们在搜索字符串后添加单引号（`'`），SQL
    查询将中断，因为这会导致一个没有闭合单引号的孤立开头单引号。
- en: 'Let’s send the following query to DVGA to see the response we receive (notice
    the addition of the single quote):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向 DVGA 发送以下查询，以查看我们收到的响应（注意添加了单引号）：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In Burp, modify the request to look like the one shown in [Figure 8-8](#figure8-8).
    GraphQL should return a response containing an application error through the `errors`
    JSON key that reveals some interesting information.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Burp 中，修改请求，使其看起来像[图 8-8](#figure8-8)所示。GraphQL 应该返回一个通过 `errors` JSON 键包含应用程序错误的响应，揭示一些有趣的信息。
- en: '![](image_fi/502840c08/f08008.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08008.png)'
- en: 'Figure 8-8: Breaking a SQL query by using a single quote with Burp Suite'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8：通过使用单引号与 Burp Suite 打破 SQL 查询
- en: It appears that our string causes the SQL query to become invalid because it
    gets injected directly into the SQL `LIKE` search pattern. The application doesn’t
    escape the single quote we introduced, which allows us to break the SQL query
    altogether. Therefore, SQLite (the SQL engine that runs DVGA) throws errors, as
    you can see based on the string `sqlite3.OperationalError` in the error output.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的字符串导致 SQL 查询失效，因为它直接被注入到 SQL `LIKE` 搜索模式中。应用程序没有对我们引入的单引号进行转义，这使得我们能够完全破坏
    SQL 查询。因此，SQLite（运行 DVGA 的 SQL 引擎）抛出错误，正如你在错误输出中的 `sqlite3.OperationalError` 字符串所看到的。
- en: 'So, we think we’ve found a SQLi vulnerability. Now what? Well, we can check
    whether we are able to get additional information from the database by changing
    the SQL query to one that, say, returns all pastes:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们认为我们发现了一个 SQLi 漏洞。现在怎么办？我们可以通过修改 SQL 查询，例如将其更改为返回所有 pastes，来检查是否能够从数据库中获取更多信息：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now the SQL statement GraphQL uses when it queries the database after parsing
    the incoming GraphQL query might look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，GraphQL 在解析传入的 GraphQL 查询后查询数据库时使用的 SQL 语句可能如下所示：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By adding a single quote, we end the SQL `LIKE` operator immediately after the
    `My` `First` `Paste` filter pattern. Then we can introduce an `or` condition that
    makes the SQL query always true by adding the `1=1` comparison. We end the SQL
    query by using the comment double dash (`--`) syntax in SQL, which comments out
    the single quote at the end of the query, effectively ensuring that our syntax
    remains valid despite our alteration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个单引号，我们在 `My` `First` `Paste` 过滤模式后立即结束了 SQL `LIKE` 操作符。然后，我们可以通过添加 `1=1`
    比较，插入一个 `or` 条件，使 SQL 查询始终为真。我们使用 SQL 中的注释双破折号（`--`）语法来结束 SQL 查询，从而注释掉查询末尾的单引号，确保尽管修改了查询，我们的语法依然有效。
- en: '[Figure 8-9](#figure8-9) shows what this SQLi query looks like in Burp Suite
    and its result.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-9](#figure8-9) 显示了 Burp Suite 中这个 SQLi 查询的样子及其结果。'
- en: '![](image_fi/502840c08/f08009.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08009.png)'
- en: 'Figure 8-9: A successful SQL injection with Burp Suite'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-9：使用 Burp Suite 成功的 SQL 注入
- en: The server response contains all pastes in the DVGA database! This is an example
    of a Boolean-based SQLi.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应包含 DVGA 数据库中的所有粘贴！这是一个基于布尔值的 SQLi 示例。
- en: Automating SQL Injection
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化 SQL 注入
- en: Other tools attempt to automate the detection of a SQLi vulnerability. In particular,
    SQLmap can help fuzz the GraphQL API with payloads that are tailored to various
    database engines, such as MySQL, PostgreSQL, SQLite, and so on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工具尝试自动化 SQLi 漏洞的检测。特别是，SQLmap 可以通过针对各种数据库引擎（如 MySQL、PostgreSQL、SQLite 等）定制的负载，帮助模糊测试
    GraphQL API。
- en: 'When performing a SQLi test, you can take any potential GraphQL query and use
    an asterisk (`*`) to mark a specific position where SQLmap should inject payloads.
    For example, consider the following snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行 SQLi 测试时，你可以取任何潜在的 GraphQL 查询，并使用星号（`*`）标记一个特定位置，指示 SQLmap 应该注入负载。例如，考虑以下代码片段：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, SQLmap will replace the asterisk with entries from its database
    of SQLi payloads.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，SQLmap 会用它的 SQLi 负载数据库中的条目替换星号。
- en: SQLmap can read full HTTP requests from a file. We can take any HTTP request
    and feed it into SQLmap, which will then read the query and use it to execute
    SQL. [Figure 8-10](#figure8-10) shows how to save a request to a file in Burp
    Suite. Right-click anywhere in the request window and select **Copy to File**.
    Name the file *request.txt* and save it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: SQLmap 可以从文件读取完整的 HTTP 请求。我们可以将任何 HTTP 请求输入到 SQLmap 中，SQLmap 会读取查询并用它来执行 SQL。[图
    8-10](#figure8-10) 显示了如何在 Burp Suite 中将请求保存到文件。右键点击请求窗口中的任何位置，选择 **复制到文件**。将文件命名为
    *request.txt* 并保存。
- en: '![](image_fi/502840c08/f08010.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08010.png)'
- en: 'Figure 8-10: Saving an HTTP request from Burp Suite to a file'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-10：将 HTTP 请求从 Burp Suite 保存到文件
- en: Next, run SQLmap by using the `-r` (request) argument to specify the file. Set
    the target database engine argument (`--dbms`) to `sqlite`. By providing a database
    engine name, we narrow the number of tests executed to only the relevant subset
    and speed up the process of injection testing. [Listing 8-3](#listing8-3) shows
    how to run the command.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过使用 `-r`（请求）参数来运行 SQLmap，指定文件。将目标数据库引擎参数（`--dbms`）设置为 `sqlite`。通过提供数据库引擎名称，我们将执行的测试数量缩小到相关的子集，从而加快注入测试的过程。[清单
    8-3](#listing8-3) 显示了如何运行命令。
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 8-3: A SQLmap successful injection output'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-3：SQLmap 成功注入的输出
- en: SQLmap notifies us that it found our asterisk marker (`*`) and asks whether
    we want to process it. Enter `Y`. The tool then indicates that it found JSON data
    within our *request.txt* file and asks whether it should interpret it as JSON.
    Enter `N`, as GraphQL syntax could confuse SQLmap. Next, it suggests reducing
    the number of requests and using only a basic `UNION` test. Enter `Y`. The test
    found that our parameter was vulnerable, so enter `N` to instruct SQLmap not to
    execute any more tests. The tool also highlights the payload that led to a successful
    injection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: SQLmap 会通知我们它找到了星号标记（`*`），并询问是否要处理它。输入 `Y`。工具接着表示它在 *request.txt* 文件中找到了 JSON
    数据，并询问是否应将其解释为 JSON。输入 `N`，因为 GraphQL 语法可能会干扰 SQLmap。接下来，工具建议减少请求数量，仅使用基本的 `UNION`
    测试。输入 `Y`。测试发现我们的参数是脆弱的，因此输入 `N`，指示 SQLmap 不再执行其他测试。工具还高亮显示了导致成功注入的负载。
- en: Now we can gather information about the database by using the `--tables` argument,
    which will list the database tables in DVGA, as shown in [Listing 8-4](#listing8-4).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `--tables` 参数收集数据库信息，该参数将列出 DVGA 中的数据库表，如 [清单 8-4](#listing8-4) 所示。
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 8-4: Using SQLmap to list tables in the DVGA database'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-4：使用 SQLmap 列出 DVGA 数据库中的表
- en: As you can see, we’ve returned tables for the various components in DVGA. Great
    job! We were able to identify a SQL injection vulnerability both manually and
    automatically.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经返回了 DVGA 中各个组件的表格。做得好！我们能够手动和自动识别出 SQL 注入漏洞。
- en: Operating System Command Injection
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统命令注入
- en: '*Operating system (OS) command injection* vulnerabilities are injections that
    impact the application’s underlying operating system, and they happen when user
    input is inserted into a system shell command. This allows us to introduce additional
    parameters or break out of the designated command and run one that we control.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作系统（OS）命令注入*漏洞是影响应用程序底层操作系统的注入漏洞，它发生在用户输入被插入到系统命令行命令中时。这使得我们能够引入额外的参数，或者突破指定命令，执行我们控制的命令。'
- en: 'Much like SQLi, OS command injection could have severe consequences for an
    application, allowing attackers to do things such as the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 SQL 注入（SQLi）一样，操作系统命令注入可能对应用程序造成严重后果，允许攻击者执行以下操作：
- en: Enumerate local services, processes, users, and groups
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举本地服务、进程、用户和组
- en: Exfiltrate local filesystem files, such as sensitive configuration files, database
    files, and so on
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泄露本地文件系统文件，如敏感配置文件、数据库文件等
- en: Gain remote access by making the server call back to our remote shell
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过让服务器回调到我们的远程 shell 获得远程访问
- en: Turn the server into an attack launchpad using specialized malware
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专门的恶意软件将服务器转变为攻击发起平台
- en: Turn the server into a crypto-miner
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务器转变为加密矿工
- en: OS command injections could effectively allow us to perform system administration
    tasks on the server, often within the context of the web application user. Web
    servers are often running under Unix accounts such as *www-data*, *apache*, *nginx*,
    or, if we get very lucky, the *root* user.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统命令注入可以有效地让我们在服务器上执行系统管理任务，通常是在 Web 应用程序用户的上下文中。Web 服务器通常在像 *www-data*、*apache*、*nginx*
    等 Unix 账户下运行，或者，如果我们运气够好，可能会是 *root* 用户。
- en: Applications are often designed to use system shell libraries to perform backend
    tasks. For instance, an application might need to check whether a remote server
    is alive by using the `ping` command or download files by using the `wget` command.
    It might also compress files by using commands such as `zip`, `tar`, or `gunzip`
    or back up filesystems by using commands such as `cp` or `rsync`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常设计为使用系统 shell 库来执行后台任务。例如，一个应用程序可能需要通过使用 `ping` 命令来检查远程服务器是否存活，或者通过使用
    `wget` 命令来下载文件。它也可能使用 `zip`、`tar` 或 `gunzip` 等命令压缩文件，或者通过 `cp` 或 `rsync` 等命令来备份文件系统。
- en: 'The mere use of system utilities does not necessarily indicate the presence
    of OS command injection vulnerabilities, but if the system utility commands run
    by the application can be influenced by arbitrary user input, things can get dangerous.
    When performing source code review, look for the following imported libraries
    and functions, and see if their commands are constructed using custom user input:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 单单使用系统工具并不一定意味着存在操作系统命令注入漏洞，但如果应用程序运行的系统工具命令能够受到任意用户输入的影响，那就可能会变得危险。在执行源代码审查时，检查以下导入的库和函数，看看它们的命令是否是通过自定义用户输入构建的：
- en: Python libraries such as *subprocess* and *os* and functions like `exec` and
    `eval`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 库，如 *subprocess* 和 *os* 以及函数，如 `exec` 和 `eval`
- en: PHP functions such as `system`, `shell_exec`, `eval`, and `exec`
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 函数，如 `system`、`shell_exec`、`eval` 和 `exec`
- en: Java functions such as `Runtime.exec()`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 函数，如 `Runtime.exec()`
- en: Node.js modules such as `child_process` and functions like `exec` and `spawn`
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 模块，如 `child_process` 和函数，如 `exec` 和 `spawn`
- en: An Example
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'Imagine that an application lets a user supply a URL, then downloads a file
    from that URL into its own filesystem. Consider the following function in Flask,
    a web framework written in Python, as an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个应用程序允许用户提供一个 URL，然后从该 URL 下载文件到应用程序的本地文件系统。考虑下面的 Flask 函数示例，Flask 是一个用 Python
    编写的 Web 框架：
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code snippet is a Python web application route that exposes an endpoint
    called */download*. This endpoint supports requests coming in via the HTTP POST
    method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是一个 Python Web 应用程序路由，它暴露了一个名为 */download* 的端点。这个端点支持通过 HTTP POST 方法发送的请求。
- en: 'At ❶, the application takes user input submitted through an HTML form on the
    website and assigns it to the `url` variable. At ❷, the `url` variable is used
    in the context of a `wget` command, effectively allowing `wget` to download the
    file by using the `url` variable. The downloaded file is then stored under the
    */data/downloads* folder on the server’s filesystem. As a result, if a client
    provides a URL such as *http://example.com/file.zip*, the web application will
    execute the following shell command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，应用程序从网站上的HTML表单获取用户输入，并将其分配给`url`变量。在❷处，`url`变量被用于`wget`命令的上下文中，实际上使得`wget`能够通过使用`url`变量来下载文件。下载的文件随后存储在服务器文件系统的*/data/downloads*文件夹中。因此，如果客户端提供类似*http://example.com/file.zip*的URL，Web应用程序将执行以下shell命令：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Multiple problems exist here. First, the application allows any URL to be supplied.
    No checks are in place to verify that the input is even in a valid URL format.
    Second, a client could supply internal URLs or private IP addresses as a way to
    identify and reach internal restricted resources, which can also lead to *server-side
    request forgery (SSRF)* vulnerabilities (more on SSRF vulnerabilities in Chapter
    9). In addition, since the application inserts the client input directly into
    the `wget` command, we could introduce any shell command we desire. We could also
    use the semicolon (`;`) character to break or separate the `wget` command and
    start a new command, effectively performing an OS command injection. This could
    lead to complete server compromise.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在多个问题。首先，应用程序允许任何URL的输入，但没有任何检查机制来验证输入是否为有效的URL格式。其次，客户端可以提供内部URL或私人IP地址来识别并访问受限的内部资源，这也可能导致*服务器端请求伪造（SSRF）*漏洞（更多关于SSRF漏洞的内容见第9章）。此外，由于应用程序将客户端输入直接插入到`wget`命令中，我们可以引入任何我们想要的shell命令。我们还可以使用分号（`;`）字符来分隔或中断`wget`命令，开始一个新的命令，从而有效地执行操作系统命令注入。这可能导致服务器完全被攻陷。
- en: Manual Testing in DVGA
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DVGA中的手动测试
- en: In GraphQL, OS command injection can happen if a resolver function accepts arguments
    from a GraphQL field without implementing the necessary verifications on the input.
    Let’s explore what this looks like in DVGA.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL中，如果解析器函数接受来自GraphQL字段的参数而没有对输入进行必要的验证，就可能发生操作系统命令注入。让我们看看在DVGA中这会是什么样子。
- en: 'Returning to the schema documentation we reviewed earlier, we have four fields
    of interest, which all start with the word `system`: `systemUpdate`, `systemHealth`,
    `systemDiagnostics`, and `systemDebug`. While field names can differ from one
    application to another, the word `system` often hints at the use of system shell
    commands under the hood, so exploring those for OS command injections is worthwhile.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 返回我们之前查看的架构文档，我们有四个感兴趣的字段，它们都以`system`开头：`systemUpdate`、`systemHealth`、`systemDiagnostics`和`systemDebug`。虽然字段名称在不同应用程序之间可能有所不同，但`system`一词通常暗示着在背后使用了系统shell命令，因此探索这些字段是否存在操作系统命令注入是值得的。
- en: If you’ve ever performed a penetration test on your home router, you’ll know
    that its debug or diagnostics page is probably the most interesting place to look
    for impactful vulnerabilities. OS command injections often exist in these interfaces,
    as they use network utilities such as `ping` or `traceroute` under the hood. Home
    routers aren’t particularly famous for their security; they hardly ever check
    input for dangerous characters and are often vulnerable to OS command injection.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经对家庭路由器进行渗透测试，你会知道它的调试或诊断页面可能是寻找重大漏洞的最有趣的地方。操作系统命令注入通常存在于这些接口中，因为它们在背后使用网络工具，如`ping`或`traceroute`。家庭路由器在安全性方面并不出名，它们几乎从不检查输入是否包含危险字符，且通常容易受到操作系统命令注入的攻击。
- en: 'In this section, we’ll focus on `systemDebug`. Run the following in Altair
    to see the kind of response we get:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注`systemDebug`。在Altair中运行以下命令，查看我们得到的响应：
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you’ve done a bit of Linux system administration, you may recognize the
    following output excerpt; it comes from the `ps` command, which displays information
    about running system and user processes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做过一些Linux系统管理工作，你可能会认出以下输出片段；它来自于`ps`命令，用于显示正在运行的系统和用户进程的信息：
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open the **Docs** page in Altair. Under Queries, you’ll notice that `systemDebug`
    takes a single argument, named `arg`, of type `String`, which seems promising.
    Does the GraphQL query resolver send this argument directly to the `ps` command?
    Let’s find out:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Altair中的**Docs**页面。在查询部分，你会注意到`systemDebug`接受一个名为`arg`的单一参数，类型为`String`，这看起来很有前景。GraphQL查询解析器是否将该参数直接传递给`ps`命令？让我们来探究一下：
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now the output looks a little different. This is because `e` and `f` are two
    valid arguments that the `ps` command accepts and that change the output’s format.
    The `e` argument shows all processes on the system, while `f` changes the output
    format to a full-format listing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出看起来有点不同。这是因为 `e` 和 `f` 是 `ps` 命令接受的两个有效参数，它们改变了输出的格式。`e` 参数显示系统上的所有进程，而
    `f` 参数将输出格式更改为完整格式列表。
- en: 'It looks as though the `arg` argument takes our input and concatenates it with
    the `ps` command. We can attempt to introduce our own command by modifying `arg`
    to include the semicolon character (`;`), followed by another Linux command of
    our choice, such as `uptime`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 `arg` 参数接受我们的输入，并将其与 `ps` 命令连接起来。我们可以通过修改 `arg` 来引入自己的命令，例如添加分号字符（`;`），然后接着选择另一个
    Linux 命令，如 `uptime`：
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we get different output. It seems to include system information from the
    GraphQL server, confirming our hypothesis that OS command injection is possible:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了不同的输出。似乎包含了来自 GraphQL 服务器的系统信息，验证了我们关于操作系统命令注入可能性的假设：
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we will explore how to test for OS command injection a bit more effectively
    by utilizing specialized command-injection frameworks.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何通过利用专门的命令注入框架，更有效地测试操作系统命令注入。
- en: Automated Testing with Commix
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Commix 进行自动化测试
- en: So far, we’ve used a manual approach to identifying OS command injection vulnerabilities.
    Sometimes, however, these vulnerabilities won’t be as straightforward to find
    and exploit. For example, some applications may restrict the types of characters
    they accept, making it harder to inject commands into places such as query arguments.
    Alternatively, a firewall between us and the target GraphQL API could block dangerous
    characters from being accepted. These security controls make it difficult to identify
    holes by using a manual testing approach, which is time-consuming.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经采用手动方式来识别操作系统命令注入漏洞。然而，有时候这些漏洞并不会那么容易找到和利用。例如，一些应用程序可能会限制它们接受的字符类型，使得向查询参数等位置注入命令变得更加困难。或者，位于我们和目标
    GraphQL API 之间的防火墙可能会阻止危险字符的接受。这些安全控制措施使得通过手动测试方法识别漏洞变得困难且耗时。
- en: 'Automating command injection helps test many character variations until we
    find the right logic. For example, command injections can happen by introducing
    any of the following characters, among others:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化命令注入有助于测试许多字符变化，直到我们找到正确的逻辑。例如，命令注入可以通过引入以下任一字符等方式发生：
- en: A semicolon (`;`) to separate commands
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分号（`;`）用来分隔命令
- en: A single ampersand (`&`) to send the first command to the background and continue
    to a second command we introduced
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单独的与号（`&`）用来将第一个命令发送到后台并继续执行我们引入的第二个命令。
- en: A double ampersand (`&&`) to run a second command after the first command finishes
    successfully (returns `true`), acting as an AND condition
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双与号（`&&`）用来在第一个命令执行成功（返回 `true`）后运行第二个命令，作为 AND 条件
- en: A double pipe (`||`) to run a second command after the first command finishes
    unsuccessfully (returns `false`), acting as an OR condition
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双管道符号（`||`）用来在第一个命令执行失败（返回 `false`）后运行第二个命令，作为 OR 条件
- en: By using automated injection tools, we can test many of these characters with
    little to no effort.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用自动化注入工具，我们可以轻松地测试许多这些字符。
- en: '*Commix* is a cross-platform OS command injection framework capable of finding
    and exploiting these vulnerabilities in applications. Commix does its magic by
    fuzzing various application inputs and inspecting the server responses for patterns
    that indicate a successful injection. Commix can also identify successful injection
    attempts through inference, such as by adding delays to commands and timing the
    response through the use of `sleep`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*Commix* 是一个跨平台的操作系统命令注入框架，能够发现并利用应用程序中的这些漏洞。Commix 通过对各种应用程序输入进行模糊测试，并检查服务器响应中的模式来进行其“魔法”，这些模式表明命令注入成功。Commix
    还可以通过推测来识别成功的注入尝试，例如通过向命令中添加延迟并使用 `sleep` 来计时响应。'
- en: Let’s take another look at the GraphQL `systemDebug` field, which allowed us
    to inject OS commands through its `arg` argument. Imagine that, in a penetration
    test, we haven’t identified how to exploit the application in a timely manner
    yet think there might be something there to explore. We can use Commix to scale
    our attack by attempting dozens of payload variations and save valuable time.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看 GraphQL 的 `systemDebug` 字段，它使我们能够通过 `arg` 参数注入操作系统命令。假设在渗透测试中，我们尚未及时识别出如何利用应用程序，但觉得可能有一些东西值得探索。我们可以使用
    Commix 通过尝试数十种有效载荷变体来扩大攻击规模，从而节省宝贵的时间。
- en: 'The Commix command in [Listing 8-5](#listing8-5) shows how to run an injection
    test against our target application:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8-5](#listing8-5) 中的 Commix 命令展示了如何对我们的目标应用执行注入测试：
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 8-5: A successful GraphQL OS command injection with Commix'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-5：使用 Commix 成功执行的 GraphQL 操作系统命令注入
- en: We specify the GraphQL target URL *http://localhost:5013/graphql* by using the
    GraphQL query `systemDebug` along with the `arg` argument. We then use the `-p`
    flag to signal to Commix that it should inject the payloads at the specific `arg`
    placeholder.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 GraphQL 查询 `systemDebug` 并使用 `arg` 参数来指定 GraphQL 目标 URL *http://localhost:5013/graphql*。然后，我们使用
    `-p` 标志告诉 Commix 应在特定的 `arg` 占位符处注入有效载荷。
- en: Commix identifies that the server wants to set an HTTP cookie. We accept this
    by entering `Y` at the command line. Commix then needs to know the type of operating
    system the remote server is running so it can choose the relevant payloads from
    its database. For example, Linux servers require different injection payloads
    than Windows servers. We choose the Unix option by specifying the `U` character.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Commix 识别出服务器想要设置 HTTP cookie。我们通过在命令行输入 `Y` 来接受此请求。然后，Commix 需要了解远程服务器运行的操作系统类型，以便从其数据库中选择相关的有效载荷。例如，Linux
    服务器需要与 Windows 服务器不同的注入有效载荷。我们通过指定 `U` 字符选择 Unix 选项。
- en: Next, we indicate to Commix that it should process the JSON response coming
    from the GraphQL server. We specify that we want to inject payloads inside the
    command boundaries. Commix signals that it found the `arg` argument to be injectable.
    It identified this by inserting the `echo` command into it, along with a unique
    string. If the response contains this unique string, it means the code was successfully
    injected.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指示 Commix 处理来自 GraphQL 服务器的 JSON 响应。我们指定要在命令边界内注入有效载荷。Commix 表示它发现 `arg`
    参数是可注入的。它通过将 `echo` 命令与一个唯一字符串插入其中来识别这一点。如果响应中包含这个唯一字符串，说明代码已成功注入。
- en: We spawn a pseudo shell in which to send Unix commands to the server. Lastly,
    we send the `ls` command to test that we can interact with the server by using
    our shell and list its files. We can see that a few files were listed, meaning
    we’ve successfully performed an OS command injection.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动一个伪 shell 以便向服务器发送 Unix 命令。最后，我们发送 `ls` 命令测试是否能通过我们的 shell 与服务器交互，并列出其文件。我们看到列出了几个文件，意味着我们已经成功执行了操作系统命令注入。
- en: As you can see, Commix provides a very convenient way to run a series of injection
    tests against GraphQL APIs.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Commix 提供了一种非常便捷的方式来对 GraphQL API 进行一系列注入测试。
- en: Code Review of a Resolver Function
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析器函数的代码审查
- en: Let’s perform a code review of the resolver function for `systemDebug` to see
    how it is implemented in DVGA ([Listing 8-6](#listing8-6)). This should help us
    better understand the root cause of the OS command injection vulnerability we
    discovered.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `systemDebug` 的解析器函数进行代码审查，以查看它在 DVGA 中是如何实现的（见 [列表 8-6](#listing8-6)）。这将帮助我们更好地理解我们发现的操作系统命令注入漏洞的根本原因。
- en: '[PRE26]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 8-6: The resolver function in DVGA'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-6：DVGA 中的解析器函数
- en: The `resolve_system_debug()` Python function handles the GraphQL field `systemDebug`.
    It accepts a single, optional argument named `arg`. A default value of `None`
    is set if the client hasn’t set the argument in the query.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve_system_debug()` Python 函数处理 GraphQL 字段 `systemDebug`。它接受一个名为 `arg`
    的单一可选参数。如果客户端没有在查询中设置该参数，则默认为 `None`。'
- en: 'Within this function, the `helpers.run_cmd()` function runs the `ps` system
    shell command, which is concatenated with the `arg` value if it is not `None`.
    If the client provides the argument `ef`, the command effectively becomes the
    following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，`helpers.run_cmd()` 函数运行 `ps` 系统 shell 命令，如果 `arg` 值不为 `None`，则将其与命令连接。如果客户端提供了
    `ef` 参数，命令最终变成以下内容：
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the client hasn’t supplied any value to the `arg` argument, the function
    simply runs the command `ps` on its own, returning the list of running processes
    on the system.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端没有提供`arg`参数的任何值，函数将仅仅运行`ps`命令，返回系统上正在运行的进程列表。
- en: 'The vulnerability here is that there are no security checks on the supplied
    argument `arg`, so the resolver function will execute any Linux command it receives.
    This can be mitigated in multiple ways:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的漏洞在于没有对提供的`arg`参数进行安全检查，因此解析器函数会执行它接收到的任何Linux命令。这可以通过多种方式进行缓解：
- en: Accepting only alphabetic characters (`a` to `z`) and ensuring that these are
    valid `ps` arguments
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只接受字母字符（`a`到`z`），并确保这些字符是有效的`ps`参数
- en: Removing any dangerous characters that could allow an attacker to introduce
    additional commands
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除任何可能允许攻击者引入额外命令的危险字符
- en: Running the command as an unprivileged user to reduce the risk if an injection
    is possible
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以非特权用户身份运行命令，以降低注入可能性时的风险
- en: Using dedicated built-in libraries instead of shell commands directly, such
    as the *psutil* library in Python
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专门的内置库而不是直接使用shell命令，例如Python中的*psutil*库
- en: So far, we covered injection vulnerabilities that, when present, impact the
    server. Next, we will explore a few injection vulnerabilities that impact clients.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了会影响服务器的注入漏洞。接下来，我们将探讨几种影响客户端的注入漏洞。
- en: Cross-Site Scripting
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站脚本（XSS）
- en: Injection vulnerabilities can also impact clients. Imagine a Profile Update
    page on a social media website that allows users to change their full name and
    bio. If the application doesn’t perform any security validations on this input,
    we could try to use some GraphQL mutation to submit malicious JavaScript code
    to the page and have it render on other clients’ browsers whenever they visit
    our profile. The ability to execute JavaScript on a client’s browser is powerful,
    because it allows us to exfiltrate browser information such as cookies to a remote
    server and obtain access to sensitive session tokens that could hijack a client’s
    session.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注入漏洞也会影响客户端。假设某社交媒体网站的个人资料更新页面允许用户修改全名和简介。如果应用程序没有对这些输入进行任何安全验证，我们可以尝试使用一些GraphQL变更来提交恶意的JavaScript代码到页面，并且在其他客户端访问我们的个人资料时，使其在他们的浏览器中渲染。能够在客户端浏览器中执行JavaScript代码非常强大，因为它使我们能够将浏览器信息（如cookie）外泄到远程服务器，获取敏感的会话令牌，从而劫持客户端的会话。
- en: '*Cross-site scripting (XSS)* vulnerabilities happen when client-side code (such
    as JavaScript) gets interpreted and executed within the context of a web browser.
    This type of vulnerability has been reported since the 1990s, yet we still see
    it today, more than 30 years later.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*跨站脚本（XSS）*漏洞发生在客户端代码（如JavaScript）在网页浏览器的上下文中被解释和执行时。这种类型的漏洞自1990年代以来就被报告，但即使今天，30多年后，我们依然可以看到它的存在。'
- en: 'If you are already familiar with XSS vulnerabilities, you’ll find that they
    aren’t very different in GraphQL than in other API technologies such as REST.
    This section provides a brief explanation of the main types of XSS vulnerabilities:
    reflected, stored, and DOM based. Then we’ll explore XSS vulnerabilities in DVGA
    so you can gain experience identifying them in GraphQL APIs.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉XSS漏洞，你会发现它们在GraphQL中与其他API技术（如REST）没有太大不同。本节简要解释了主要的XSS漏洞类型：反射型、存储型和基于DOM的XSS。然后，我们将探讨DVGA中的XSS漏洞，让你在GraphQL
    API中积累识别它们的经验。
- en: Reflected XSS
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射型XSS
- en: Perhaps the simplest of all XSS vulnerabilities, *reflected XSS* occurs when
    input is submitted to the server and returned in an immediate response to the
    client, such as in HTML error messages or within an HTML page’s content.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是所有XSS漏洞中最简单的一种，*反射型XSS*发生在输入被提交到服务器并立即返回给客户端的响应中，如HTML错误信息或HTML页面内容中。
- en: From an attacker standpoint, exploiting a reflected XSS vulnerability requires
    social engineering the victim into clicking a link that triggers the XSS payload,
    causing the attacker’s JavaScript code to run in the victim’s browser.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从攻击者的角度来看，利用反射型XSS漏洞需要通过社会工程学让受害者点击一个触发XSS有效载荷的链接，导致攻击者的JavaScript代码在受害者的浏览器中执行。
- en: 'In the context of GraphQL, a query vulnerable to reflected XSS might look like
    the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL的上下文中，一个易受反射型XSS攻击的查询可能如下所示：
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This `hello` operation takes a `msg` parameter that accepts input from a client—in
    this case, the string `Black` `Hat` `GraphQL`. When a client submits this information,
    the server will render the page and perhaps print a message such as `Hello Black
    Hat GraphQL!`
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`hello`操作需要一个`msg`参数，该参数接受来自客户端的输入——在这种情况下，是字符串`Black` `Hat` `GraphQL`。当客户端提交这些信息时，服务器将渲染页面，并可能打印出类似`Hello
    Black Hat GraphQL!`的消息。
- en: 'Now, imagine that we change the `msg` parameter value to a JavaScript payload:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们将`msg`参数的值更改为一个JavaScript负载：
- en: '[PRE29]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When this gets rendered in the client’s browser, the `<script>` tag will instruct
    the browser to call the `document` JavaScript object and print the `cookie` string.
    Cookies will often include information related to the session, such as identifiers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当这在客户端的浏览器中渲染时，`<script>`标签将指示浏览器调用`document` JavaScript对象并打印`cookie`字符串。Cookie通常会包含与会话相关的信息，例如标识符。
- en: Because this information isn’t stored in any database on the server, but rather
    is reflected back to the client in the response upon submitting the query, the
    XSS is of a reflection type. We could improve the payload by having the victim’s
    browser send its cookie to a remote server under our control, allowing us to exfiltrate
    the user’s cookies.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些信息并没有存储在服务器的数据库中，而是通过提交查询后反射回客户端的响应中，所以这是反射型XSS。我们可以通过让受害者的浏览器将其cookie发送到我们控制的远程服务器来改进负载，从而使我们能够窃取用户的cookie。
- en: We mentioned earlier that this attack would require social engineering to be
    useful. For example, via a phishing email, we could send the victim a URL containing
    our malicious JavaScript payload and wait until they click it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们早些时候提到，这个攻击需要社会工程学才能发挥作用。例如，通过网络钓鱼邮件，我们可以将一个包含恶意JavaScript负载的URL发送给受害者，并等待他们点击。
- en: 'You might be asking yourself, how would this work when using POST requests?
    Well, earlier in the book we mentioned that GraphQL may support GET-based queries,
    so you could attempt to construct a link such as the following and test whether
    the target GraphQL server supports GET-based queries:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，使用POST请求时这如何工作呢？好吧，我们在书中早些时候提到，GraphQL可能支持基于GET的查询，因此你可以尝试构造如下链接，并测试目标GraphQL服务器是否支持基于GET的查询：
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This URL, when decoded, looks like the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 解码后，这个URL看起来如下所示：
- en: '[PRE31]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: GraphQL APIs that support GET-based queries will accept a `query` GET parameter,
    followed by the query syntax. The query operation can be a query or a mutation.
    A victim clicking this link would submit a GraphQL query using a GET request.
    In Chapter 9, you will learn about how GET-based queries can also be leveraged
    to carry cross-site request forgery (CSRF) attacks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 支持基于GET的查询的GraphQL API将接受一个`query` GET参数，后面跟着查询语法。查询操作可以是查询或突变。受害者点击此链接后，将通过GET请求提交一个GraphQL查询。在第9章中，您将了解如何利用GET请求进行跨站请求伪造（CSRF）攻击。
- en: Stored XSS
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储型 XSS
- en: In *stored*, or *persistent*, *XSS*, the injection payload is persisted to a
    datastore, such as a database, rather than reflected to the client as part of
    a response to a query. Thus, unlike reflected XSS, a stored XSS vulnerability
    will trigger the injected script every time the client’s browser loads a page
    containing the malicious payload.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在*存储型*或*持久型*的*XSS*中，注入的负载被持久化存储到数据存储中，例如数据库，而不是作为查询响应的一部分反射回客户端。因此，不同于反射型 XSS，存储型
    XSS漏洞会在每次客户端浏览器加载包含恶意负载的页面时触发注入的脚本。
- en: 'Often, stored XSS vulnerabilities are considered more dangerous than reflected
    XSS. The existence of the XSS payload in an application’s datastore could pose
    a risk to other systems, such as these:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，存储型 XSS漏洞被认为比反射型 XSS更危险。XSS负载存在于应用程序的数据存储中，可能对其他系统构成风险，例如：
- en: Other servers reading the malicious input from the same datastore as the GraphQL
    application. These are effectively impacted by the same exploit.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他服务器从与GraphQL应用程序相同的数据存储中读取恶意输入。这些服务器实际上受到了相同漏洞的影响。
- en: Other flows within the same GraphQL application reading from the same datastore.
    The exploit would impact other parts of the application and therefore affect other
    clients.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一GraphQL应用程序中的其他流程从相同的数据存储中读取。这个漏洞会影响应用程序的其他部分，因此会影响其他客户端。
- en: '[Figure 8-11](#figure8-11) shows how a stored XSS could impact other systems.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-11](#figure8-11)展示了存储型 XSS如何影响其他系统。'
- en: '![](image_fi/502840c08/F08011.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/F08011.png)'
- en: 'Figure 8-11: A stored XSS vulnerability impacting adjacent applications'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-11：存储型 XSS 漏洞影响相邻应用程序
- en: Our malicious input could traverse many devices and resources on a network;
    after first hitting the GraphQL API layer, it could be inserted into different
    datastores, such as a cache database, a relational database, or a local file.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的恶意输入可以穿越网络上的许多设备和资源；在首次经过 GraphQL API 层后，它可能会被插入到不同的数据存储中，例如缓存数据库、关系型数据库或本地文件。
- en: From there, we won’t always know whether the exploitation attempt worked. Often
    we need to wait until something (or someone) triggers our payload. Imagine that
    we use a GraphQL mutation to send a JavaScript payload and then don’t receive
    any indication that it was successfully rendered by the application as JavaScript
    code. Several explanations are possible. For example, we may have injected the
    payload into a database table that’s read only by someone with a different level
    of access to the application.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，我们并不总是能知道攻击是否成功。通常，我们需要等待直到某些事情（或某个人）触发我们的有效载荷。假设我们使用 GraphQL 突变发送一个 JavaScript
    有效载荷，然后没有收到任何指示说明它已成功作为 JavaScript 代码被应用渲染。几种解释都是可能的。例如，我们可能已经将有效载荷注入到一个数据库表中，该表仅能被具有不同访问权限的用户读取。
- en: Contact forms provide a good example. Say you submit a payload in a feedback
    form to a store from which you recently bought an item and get a `Thank you for
    your submission` message. Even though you received no indication that the exploitation
    attempt was successful, your attack was not necessarily a dead end. The payload
    might get triggered only after the store opens the feedback form. This could happen
    days or even weeks later. We call these hidden attacks *blind XSS*, a subcategory
    of stored XSS.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 联系表单提供了一个很好的例子。假设你在一个反馈表单中提交一个有效载荷给你最近购买物品的商店，并收到一个 `感谢您的提交` 的消息。即使你没有收到任何表明攻击尝试成功的提示，你的攻击也不一定是死路一条。有效载荷可能仅在商店打开反馈表单后被触发。这可能发生在几天甚至几周后。我们将这些隐藏攻击称为
    *盲 XSS*，它是存储型 XSS 的一个子类别。
- en: To take advantage of blind XSS vulnerabilities, you can use tools that generate
    unique payloads with which to test. When an XSS vulnerability is found and the
    payload is triggered, the payload will send probes to a centralized server for
    further inspection, allowing you to capture information about the client on which
    the payload was executed. One such tool is *XSS Hunter* ([https://xsshunter.com](https://xsshunter.com)).
    Tools that notify you whenever your XSS payload triggers are pretty convenient.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用盲 XSS 漏洞，你可以使用生成唯一有效载荷的工具进行测试。当发现 XSS 漏洞并且有效载荷被触发时，负载将向一个集中式服务器发送探测信息进行进一步检查，从而让你捕获到关于执行了有效载荷的客户端的信息。一个这样的工具是
    *XSS Hunter* ([https://xsshunter.com](https://xsshunter.com))。当你的 XSS 有效载荷被触发时通知你的工具非常方便。
- en: DOM-Based XSS
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于 DOM 的 XSS
- en: '*Document Object Model–based XSS*, or *DOM-based*, vulnerabilities occur when
    a JavaScript injection payload gets executed exclusively within the browser’s
    DOM. The DOM is a representation of a web document that allows applications to
    modify their structure, content, and style. All HTML objects can be manipulated
    using the DOM API.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*文档对象模型基础的 XSS*，或称 *基于 DOM 的 XSS*，漏洞发生在 JavaScript 注入有效载荷仅在浏览器的 DOM 中执行时。DOM
    是一种网页文档的表示形式，允许应用程序修改其结构、内容和样式。所有 HTML 对象都可以使用 DOM API 进行操作。'
- en: 'For example, the document object can be used to get the HTML `<title>` tag
    in a web page. In DVGA’s web interface, open your browser’s developer tools and
    enter the command `document.title` in the **Console** tab. You should see the
    following result:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，文档对象可以用来获取网页中的 HTML `<title>` 标签。在 DVGA 的网页界面中，打开浏览器的开发者工具，在 **控制台** 标签页中输入命令
    `document.title`。你应该会看到如下结果：
- en: '[PRE32]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While reflected XSS and stored XSS result from vulnerabilities that exist in
    server-side code, DOM XSS vulnerabilities usually stem from a vulnerability in
    the frontend application code facing the client. For example, it can happen when
    malicious input can be inserted (often as part of a URL) and passed to a component
    that supports dynamic code execution, like JavaScript’s `eval` function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然反射型 XSS 和存储型 XSS 是由于服务器端代码中的漏洞引起的，但 DOM XSS 漏洞通常源于前端应用程序代码中存在的漏洞，这些代码面向客户端。例如，当恶意输入（通常作为
    URL 的一部分）能够被插入并传递给支持动态代码执行的组件时，就可能发生这种情况，比如 JavaScript 的 `eval` 函数。
- en: Because DOM XSS vulnerabilities happen in client-side code, GraphQL APIs aren’t
    the root cause of such vulnerabilities. Despite this fact, we believe it’s important
    to be aware of them, as community-built GraphQL clients could be vulnerable to
    these types of vulnerabilities. For a comprehensive list of the available GraphQL
    client libraries, visit [https://graphql.org/code/#javascript-client](https://graphql.org/code/#javascript-client).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DOM XSS 漏洞发生在客户端代码中，GraphQL API 并不是这些漏洞的根本原因。尽管如此，我们认为有必要意识到这一点，因为社区构建的 GraphQL
    客户端可能会容易受到这些漏洞的影响。有关可用 GraphQL 客户端库的完整列表，请访问 [https://graphql.org/code/#javascript-client](https://graphql.org/code/#javascript-client)。
- en: Testing for XSS in DVGA
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 DVGA 中测试 XSS
- en: In this section, we will use DVGA’s user interface to perform XSS testing. Numerous
    XSS vulnerabilities are implemented into DVGA, so we can achieve XSS in more than
    one way. We’ll explore a few techniques to get you comfortable with using GraphQL
    queries for XSS testing.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 DVGA 的用户界面进行 XSS 测试。DVGA 中实现了多个 XSS 漏洞，因此我们可以通过多种方式实现 XSS。我们将探索一些技术，帮助你熟悉使用
    GraphQL 查询进行 XSS 测试。
- en: Open your web browser in the lab and navigate to DVGA’s main interface at ***http://localhost:5013***.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在实验室中打开你的网页浏览器，并导航到 DVGA 的主界面 ***http://localhost:5013***。
- en: Tampering with the Audit Page
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 篡改审计页面
- en: As a first step, click some of the pages on the left sidebar, such as Public
    Pastes. Your browser will start sending GraphQL queries to populate the web page
    with information. Next, click the user icon at the top right; then click **Audit**.
    You should be able to see audit events listed, as shown in [Figure 8-12](#figure8-12).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，点击左侧边栏中的一些页面，比如“Public Pastes”。你的浏览器会开始发送 GraphQL 查询以填充网页信息。接着，点击右上角的用户图标，然后点击
    **Audit**。你应该能够看到列出的审计事件，如 [图 8-12](#figure8-12) 所示。
- en: '![](image_fi/502840c08/f08012.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08012.png)'
- en: 'Figure 8-12: The audit trail in DVGA'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-12：DVGA 中的审计记录
- en: 'This Audit page suggests that the application is automatically tracking every
    query the browser sent while we were browsing the page, gathering information
    such as the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个审计页面表明，应用程序正在自动跟踪我们在浏览页面时浏览器发送的每个查询，收集的信息如下：
- en: The name of the actor or *user* (in this case, *DVGAUser*)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员或*用户*的名称（在本例中为 *DVGAUser*）
- en: The name of the *GraphQL operation* that was used (in this case, *getPastes*)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的 *GraphQL 操作* 名称（在本例中为 *getPastes*）
- en: The *executed query* (in this case, the `pastes` GraphQL field used with the
    `public` argument and a few selected fields, such as `id`, `title`, and `content`)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行的查询*（在本例中，是带有 `public` 参数和几个选定字段（如 `id`、`title` 和 `content`）的 `pastes` GraphQL
    字段）'
- en: 'This input is fully under our control. Let’s first explore how we can tamper
    with the GraphQL operation to impact the Audit page. Copy and paste the following
    query into Altair and run it:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输入完全在我们的控制之下。让我们首先探讨如何篡改 GraphQL 操作以影响审计页面。将以下查询复制并粘贴到 Altair 中，然后运行：
- en: '[PRE33]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The mutation creates a new paste with the title `Black Hat GraphQL` and content
    `I just spoofed the operation name`. At the same time, we return the newly created
    paste’s `content` and `title` fields, which should have identical values.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 该变异创建了一个新粘贴，标题为 `Black Hat GraphQL`，内容为 `I just spoofed the operation name`。同时，我们返回新创建粘贴的
    `content` 和 `title` 字段，它们的值应该是相同的。
- en: Refresh the Audit page. You should be able to see that it now shows our spoofed
    operation name `SpoofedOperationName` under the GraphQL Operation column, as shown
    in [Figure 8-13](#figure8-13). This is what a security analyst might see if attempting
    to monitor GraphQL queries using operation names.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新审计页面。你应该能够看到现在它在 GraphQL 操作列下显示了我们伪造的操作名称 `SpoofedOperationName`，如 [图 8-13](#figure8-13)
    所示。这就是安全分析师在尝试通过操作名称监控 GraphQL 查询时可能看到的内容。
- en: '![](image_fi/502840c08/f08013.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08013.png)'
- en: 'Figure 8-13: The Audit page showing the modified operation name in DVGA'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-13：显示 DVGA 中修改后的操作名称的审计页面
- en: As we mentioned earlier, different GraphQL server implementations may allow
    operation names to include special characters, which could be an injection vector,
    so always test these whenever possible.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，不同的 GraphQL 服务器实现可能允许操作名称包含特殊字符，这可能成为注入向量，因此在可能的情况下，始终测试这些特殊字符。
- en: Finding Stored XSS in the CreatePaste Mutation
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 CreatePaste 变异中发现存储型 XSS
- en: When we create a new paste in DVGA, the GraphQL fields used in our `createPaste`
    mutation, such as `title` and `content`, are shown on the Public Pastes page.
    The screenshot in [Figure 8-14](#figure8-14) shows what this looks like.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 DVGA 创建一个新的粘贴时，`createPaste` mutation 中使用的 GraphQL 字段，如 `title` 和 `content`，会显示在公共粘贴页面上。[图
    8-14](#figure8-14) 中的截图展示了这是什么样子的。
- en: '![](image_fi/502840c08/f08014.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08014.png)'
- en: 'Figure 8-14: Paste structure and contents in DVGA'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-14：DVGA 中的粘贴结构和内容
- en: As you can see, our paste shows up on the web page. This is a good opportunity
    to start testing the `createPaste` field with inputs such as JavaScript code to
    see whether the data is safely rendered in the web interface.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的粘贴出现在网页上。这是一个开始测试 `createPaste` 字段的好机会，可以输入例如 JavaScript 代码，看看数据是否在网页界面中安全地渲染。
- en: Go ahead and create a new paste using the mutation query shown in [Listing 8-7](#listing8-7).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用[列表 8-7](#listing8-7)中显示的 mutation 查询创建一个新的粘贴。
- en: '[PRE34]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 8-7: Injecting an XSS payload using the `createPaste` mutation'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-7：通过 `createPaste` mutation 注入 XSS payload
- en: This mutation creates a new paste that includes a JavaScript `<script>` tag
    in the `content` argument. If the application is vulnerable to XSS, this code
    will get rendered in the browser and an alert message box will pop up with the
    message `XSS`. After sending this mutation query, head over to the **Public Pastes**
    page. You should be greeted with a pop-up message, as shown in [Figure 8-15](#figure8-15).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 mutation 创建一个新的粘贴，`content` 参数中包含一个 JavaScript `<script>` 标签。如果应用程序存在 XSS
    漏洞，这段代码将在浏览器中被渲染，并弹出一个消息框，显示 `XSS`。发送这个 mutation 查询后，转到**公共粘贴**页面。你应该会看到一个弹出消息，如[图
    8-15](#figure8-15)所示。
- en: '![](image_fi/502840c08/f08015.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08015.png)'
- en: 'Figure 8-15: An XSS payload triggered via a malicious mutation'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-15：通过恶意 mutation 触发的 XSS payload
- en: Let’s walk through what happened here. We first created a new paste using `createPaste`,
    supplying a malicious JavaScript payload to the mutation’s `content` argument.
    The API then stored the new paste in the database. Because our client is using
    a GraphQL subscription operation over the WebSocket protocol, and since subscriptions
    are real time, we immediately see the new paste we created containing the malicious
    JavaScript code. This is an example of a stored XSS vulnerability.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这里发生了什么。我们首先使用 `createPaste` 创建了一个新的粘贴，并将恶意的 JavaScript payload 提供给 mutation
    的 `content` 参数。然后，API 将新的粘贴存储在数据库中。因为我们的客户端通过 WebSocket 协议使用了 GraphQL 订阅操作，且订阅是实时的，我们立即看到了我们创建的新粘贴，里面包含了恶意的
    JavaScript 代码。这是一个存储型 XSS 漏洞的例子。
- en: Finding Reflected XSS in the File Upload Functionality
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发现文件上传功能中的反射型 XSS
- en: 'Now we’ll explore the creation of a new paste using a file upload functionality.
    This should give you a sense of how file uploads look in GraphQL and whether they
    could be vulnerable to XSS. Download the following text file to your computer:
    [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch08/paste_from_file.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch08/paste_from_file.txt).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨如何通过文件上传功能创建一个新的粘贴。这应该能让你了解文件上传在 GraphQL 中的表现，以及它们是否可能存在 XSS 漏洞。下载以下文本文件到你的计算机：[https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch08/paste_from_file.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch08/paste_from_file.txt)。
- en: Open the **Upload Paste** page in DVGA to upload the text file. This file will
    eventually be stored in the database. Click **Choose File** and select the file
    you downloaded; then click **Upload**.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 DVGA 中的**上传粘贴**页面以上传文本文件。该文件最终将存储在数据库中。点击**选择文件**并选择你下载的文件，然后点击**上传**。
- en: You can use Burp Suite to intercept the request before clicking the Upload button
    to see what the GraphQL mutation looks like. Alternatively, use the browser’s
    Network tab in its developer tools. [Figure 8-16](#figure8-16) shows the mutation
    in Burp Suite.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Burp Suite 在点击上传按钮之前拦截请求，查看 GraphQL mutation 的样子。或者，可以使用浏览器开发者工具中的网络标签页。[图
    8-16](#figure8-16) 显示了 Burp Suite 中的 mutation。
- en: '![](image_fi/502840c08/f08016.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08016.png)'
- en: 'Figure 8-16: The `UploadPaste` mutation in Burp Suite'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-16：Burp Suite 中的 `UploadPaste` mutation
- en: As you can see, we’re using `UploadPaste` to create a new paste with a local
    file. You can also see that we’re passing two variables, `content` and `filename`,
    as part of the HTTP POST JSON payload. The `content` key includes the data present
    in the uploaded file, and the `filename` key is the filename that the server will
    set on disk.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用`UploadPaste`创建一个包含本地文件的新粘贴。你还可以看到，我们将两个变量`content`和`filename`作为HTTP
    POST JSON有效载荷的一部分传递。`content`键包含上传文件中的数据，`filename`键则是服务器在磁盘上设置的文件名。
- en: The payload defines an HTML heading (`<h3>`), a paragraph (`<p>`), and a JavaScript
    script tag (`<script>`) that calls the `alert` function with the string `Black`
    `Hat` `GraphQL`. This information will be rendered by the browser and, since `alert`
    is used, a pop-up window will appear, confirming our ability to run JavaScript
    through XSS injection.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷定义了一个HTML标题（`<h3>`）、一个段落（`<p>`）以及一个JavaScript脚本标签（`<script>`），该标签调用`alert`函数并传入字符串`Black`
    `Hat` `GraphQL`。这些信息将由浏览器渲染，且由于使用了`alert`，一个弹窗将会出现，确认我们可以通过XSS注入执行JavaScript。
- en: After this query is sent to the server (make sure you click **Forward** in Burp
    Suite to do this), we can view the newly uploaded file by navigating to the **Private
    Pastes** page. You should be able to see a JavaScript pop-up, as shown in [Figure
    8-17](#figure8-17).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询发送到服务器后（确保你在Burp Suite中点击**Forward**进行操作），我们可以通过导航到**Private Pastes**页面来查看新上传的文件。你应该能看到一个JavaScript弹窗，如[图8-17](#figure8-17)所示。
- en: '![](image_fi/502840c08/f08017.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08017.png)'
- en: 'Figure 8-17: The paste code is executed in the browser and triggers the alert
    window.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-17：粘贴的代码在浏览器中执行并触发了弹窗。
- en: We were able to trigger a Stored XSS vulnerability by using `UploadPaste` to
    upload a malicious text file containing JavaScript and HTML code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`UploadPaste`上传包含JavaScript和HTML代码的恶意文本文件，成功触发了一个存储型XSS漏洞。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a close look at injection vulnerabilities, ranging
    from those that impact databases and operating systems to those that affect client
    browsers, including classic and blind SQLi; reflected, stored, and DOM-based XSS;
    and OS command injection.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了注入漏洞，从影响数据库和操作系统的漏洞到影响客户端浏览器的漏洞，包括经典和盲注SQL注入；反射型、存储型和基于DOM的XSS；以及操作系统命令注入。
- en: Many issues can arise when GraphQL APIs fail to carefully validate input. We
    identified the various input entry points in GraphQL—from queries, fields, and
    directive arguments to operation names—all of which make up the injection surface.
    Injection vulnerabilities can have a devastating impact on application data, and
    while frameworks have gotten better at protecting against them by offering reusable
    security methods, they are still prevalent today.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当GraphQL API未能仔细验证输入时，可能会出现许多问题。我们识别了GraphQL中各种输入入口点——从查询、字段、指令参数到操作名称——这些都构成了注入面。注入漏洞可能对应用数据产生毁灭性影响，尽管框架在提供可复用的安全方法方面已经有所改进，但这些漏洞今天仍然普遍存在。
