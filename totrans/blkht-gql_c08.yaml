- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Injection
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 注入
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Clients interact with APIs in a variety of ways, such as by creating, modifying,
    or deleting data. Challenges arise when applications must handle their arbitrary
    input. Should applications ever trust the input external clients send? What about
    internal clients?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端与 API 的交互方式多种多样，例如创建、修改或删除数据。当应用程序必须处理这些任意输入时，问题就会出现。应用程序是否应该信任外部客户端发送的输入？内部客户端呢？
- en: In this chapter, you’ll learn about injection vulnerabilities and discover why
    it is important to identify and secure the various entry points into applications
    backed by a GraphQL API, as well as the consequences of not doing so. We will
    identify opportunities to influence an application’s logic and manipulate it to
    take actions it wasn’t specifically designed to do. Successful injection can lead
    to outcomes ranging from web page manipulation to the execution of code on a database.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解注入漏洞，并发现为什么识别和保护由 GraphQL API 支持的应用程序的各个入口点至关重要，以及不这样做的后果。我们将识别影响应用程序逻辑并操控其执行未专门设计操作的机会。成功的注入可能导致从网页篡改到在数据库上执行代码的各种后果。
- en: GraphQL servers typically work with a datastore, such as relational databases
    like MySQL, document databases like Elasticsearch, key/value stores like Redis,
    or even graph databases like Neo4j. All of these can be vulnerable to injection-based
    vulnerabilities. In this chapter, we’ll discuss three types of injection vulnerabilities.
    Some, like SQL injection (SQLi) and operating system command injection, impact
    backend services such as servers and databases. The other, XSS, impacts clients.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 服务器通常与数据存储进行交互，如 MySQL 等关系型数据库、Elasticsearch 等文档数据库、Redis 等键值存储，甚至 Neo4j
    等图形数据库。所有这些都可能受到基于注入的漏洞的影响。在本章中，我们将讨论三种类型的注入漏洞。一些漏洞，如 SQL 注入（SQLi）和操作系统命令注入，会影响后端服务，如服务器和数据库。另一类漏洞，XSS，会影响客户端。
- en: Injection Vulnerabilities in GraphQL
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL 中的注入漏洞
- en: Injection vulnerabilities occur when an application accepts and processes untrustworthy
    input without any sanitization. *Sanitization* is a security measure that involves
    checking input and removing potentially dangerous characters from it. The absence
    of such a check could allow the input to be interpreted as a command or a query
    and execute on either the client side or server side. Injection is a broad class
    of attacks that can impact a network ecosystem, such as operating systems, clients’
    browsers, databases, third-party systems, and so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注入漏洞发生在应用程序接受并处理未经信任的输入时，且没有进行任何清理操作。*清理*是一个安全措施，涉及检查输入并去除其中可能危险的字符。缺乏此类检查可能会导致输入被解释为命令或查询，并在客户端或服务器端执行。注入是一个广泛的攻击类别，可能影响网络生态系统，如操作系统、客户端浏览器、数据库、第三方系统等。
- en: 'An application could accidentally introduce injection vulnerabilities in a
    variety of ways, including the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可能通过多种方式不小心引入注入漏洞，包括以下几种：
- en: The application does not implement security checks on the input it receives.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序没有对接收到的输入进行安全检查。
- en: The application uses insecure libraries (such as a parser) to process user input.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序使用不安全的库（如解析器）处理用户输入。
- en: The application passes the received user input to a third system, which doesn’t
    implement security checks on the input.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序将接收到的用户输入传递给第三方系统，而该系统没有对输入进行安全检查。
- en: The application accepts input and displays it to the client without transforming
    it in any way.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序接受输入并将其展示给客户端，而没有进行任何形式的转换。
- en: An application that implements a GraphQL API can become vulnerable to injection
    vulnerabilities after it starts allowing clients to manipulate data through interfaces
    such as the arguments of queries, mutations, or subscriptions. Even a GraphQL
    API that allows clients to only read data might have vulnerabilities in certain
    interfaces, such as query filters. While the risk can be decreased, it is almost
    never zero.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 GraphQL API 的应用程序，在允许客户端通过查询、变更或订阅等接口操作数据后，可能会变得容易受到注入漏洞的攻击。即使是仅允许客户端读取数据的
    GraphQL API，也可能在某些接口（如查询过滤器）中存在漏洞。虽然可以减少风险，但几乎不可能完全消除。
- en: Accepting user input is hard to avoid completely when building APIs. As the
    application becomes more complex, it will need some sort of input to be useful.
    For example, websites like Twitter or Facebook would be completely pointless if
    they didn’t allow user input. User actions, like tweeting, writing a Facebook
    post on someone’s wall, or uploading a dinner photo to Instagram, all require
    user input.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建API时，完全避免接受用户输入是很困难的。随着应用程序变得更加复杂，它将需要某种输入才能有用。例如，如果Twitter或Facebook不允许用户输入，那么它们将毫无意义。用户的操作，如发推文、在别人墙上写Facebook帖子，或上传晚餐照片到Instagram，都需要用户输入。
- en: The Blast Radius of Malicious Input
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恶意输入的影响范围
- en: Whether it comes from human clients, or machines such as other servers on the
    network, it is important to consider that input can be malicious. Even internal
    machines could become compromised and send malicious input to other servers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是来自人类客户端，还是来自网络上其他服务器等机器，都必须考虑输入可能是恶意的。即使是内部机器也可能被攻击并向其他服务器发送恶意输入。
- en: Applications are often developed under a relaxed trust model. Such a trust model
    assumes that input coming into the GraphQL API from other internal systems on
    the same network is safe, while input that originates from external sources is
    unsafe. This approach is very common, but designing systems in this way can backfire;
    if we are able to hack a system and send commands to another host on the network,
    we could easily move laterally to other servers. [Figure 8-1](#figure8-1) illustrates
    a similar scenario.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常在宽松的信任模型下开发。这样的信任模型假设来自同一网络的其他内部系统的输入是安全的，而来自外部来源的输入是不安全的。这种方法非常常见，但以这种方式设计系统可能会适得其反；如果我们能够攻击一个系统并向网络上的其他主机发送命令，就可以轻松横向移动到其他服务器。[图
    8-1](#figure8-1)说明了一个类似的场景。
- en: '![](image_fi/502840c08/f08001.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08001.png)'
- en: 'Figure 8-1: Network trust boundaries'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '图 8-1: 网络信任边界'
- en: This figure describes a penetration test in which we’ve identified an internet-facing
    GraphQL API server, the *public server*. This server happens to be dual-homed,
    meaning it has two network interfaces and is part of two separate networks. The
    server is vulnerable to injection attacks, as it does not adequately check the
    incoming queries it receives from clients.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该图描述了一个渗透测试，在测试过程中，我们发现了一个面向互联网的GraphQL API服务器，称为*公共服务器*。该服务器是双重接入的，意味着它有两个网络接口，并且属于两个独立的网络。该服务器容易受到注入攻击，因为它没有充分检查来自客户端的传入查询。
- en: Now, imagine that the *internal server* in the diagram is also a GraphQL server
    designed to trust any incoming queries from systems on the same network. It was
    configured in this way because it is not internet facing, and the security architects,
    in their threat model, assumed the local network was safe. Yet if the public server
    is hacked, an attacker could send malicious queries to the internal server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设图中的*内部服务器*也是一个GraphQL服务器，设计时假定信任来自同一网络系统的任何传入查询。之所以如此配置，是因为它不面向互联网，安全架构师在其威胁模型中假定本地网络是安全的。然而，如果公共服务器被黑客攻击，攻击者可能会向内部服务器发送恶意查询。
- en: This is why it is important to always perform security checks on any user input.
    It is also why it’s crucial for hackers to test for injection vulnerabilities
    wherever we identify that input is allowed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么始终对任何用户输入进行安全检查非常重要。也正是因为如此，黑客在发现允许输入的地方进行注入漏洞测试是至关重要的。
- en: The OWASP Top 10
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OWASP Top 10
- en: Every few years, OWASP releases new vulnerability class rankings for web applications
    under the *OWASP Top 10* project to help companies focus their security mitigation
    efforts on the most prevalent software flaw classes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每隔几年，OWASP会发布新的Web应用程序漏洞类别排名，作为*OWASP Top 10*项目的一部分，帮助公司将安全缓解工作集中在最常见的软件缺陷类别上。
- en: The injection vulnerability class has been on the OWASP Top 10 list for almost
    two decades. In the latest OWASP Top 10 release, injection vulnerability was ranked
    third, as shown in [Table 8-1](#table8-1).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注入漏洞类别已经连续近二十年出现在OWASP Top 10榜单中。在最新的OWASP Top 10发布中，注入漏洞排名第三，如[表格 8-1](#table8-1)所示。
- en: 'Table 8-1: OWASP Top 10'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '表格 8-1: OWASP Top 10'
- en: '| **Identifier** | **Vulnerability** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **标识符** | **漏洞** |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| A01 | Broken access control |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| A01 | 访问控制破坏 |'
- en: '| A02 | Cryptographic failures |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| A02 | 加密失败 |'
- en: '| A03 | Injection |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| A03 | 注入 |'
- en: '| A04 | Insecure design |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| A04 | 不安全的设计 |'
- en: '| A05 | Security misconfiguration |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| A05 | 安全配置错误 |'
- en: '| A06 | Vulnerable and outdated components |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| A06 | 脆弱和过时的组件 |'
- en: '| A07 | Identification and authentication failures |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| A08 | Software and data integrity failures |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| A09 | Security logging and monitoring failures |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| A10 | Server-side request forgery |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: OWASP has also started tracking top vulnerabilities in APIs under a dedicated
    project, the *API Security Top 10*. This split helps distinguish between API-
    and non-API-based vulnerabilities. In the latest project release as of this writing,
    injection was ranked eighth, as shown in [Table 8-2](#table8-2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-2: API Security Top 10'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '| **Identifier** | **Vulnerability** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| API1 | Broken object-level authorization |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| API2 | Broken user authentication |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| API3 | Excessive data exposure |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| API4 | Lack of resource and rate limiting |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| API5 | Broken function-level authorization |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| API6 | Mass assignment |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| API7 | Security misconfiguration |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| API8 | Injection |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| API9 | Improper asset management |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| API10 | Insufficient logging and monitoring |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: Injection vulnerabilities can have devastating consequences in APIs, and it
    is important to become comfortable with injection testing in both non-API-based
    web applications and APIs when performing penetration tests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The Injection Surface
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraphQL APIs are typically designed to accept input from clients, perform backend
    actions such as database reading and writing, and return a response.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, you can have read-only queries such as the following, which doesn’t
    change anything on the server side. Clients can’t use the query to pass arbitrary
    data, only the GraphQL fields `id` and `ipAddr`, which are defined in the GraphQL
    schema, as you might remember from Chapter 3:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An application developer can get away with having only read-only operations
    if the application wasn’t designed to interact with clients in ways that allow
    them to modify data on the server, but in reality, this will almost never be the
    case. As applications become more complex and feature rich, they’ll need to accept
    client input through interfaces such as query arguments, field arguments, or both.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a few GraphQL components that allow clients to pass arbitrary
    inputs before diving into the various injection vulnerabilities. For each of these
    interfaces, you should ask yourself a few important questions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Is the application verifying the incoming client input at all?
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the application accept dangerous characters?
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the application throw exceptions when unexpected characters are sent as
    part of a query?
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does GraphQL check the value type passed to the arguments?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we infer from the GraphQL server response (or out-of-band response) whether
    an injection attempt was successful?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injection tests will require some trial and error, but once you experience a
    breakthrough, you’ll have a very satisfying feeling.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Query Arguments
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GraphQL operations such as queries, mutations, and subscriptions can be designed
    to accept arguments. Consider the following query, which passes a `limit` argument
    with an integer value of `100`. While this operation is still read-only, it provides
    an interface for manipulating the server’s response through the use of query filters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 操作，如查询、变更和订阅，可以设计为接受参数。考虑以下查询，它传递了一个值为 `100` 的 `limit` 参数。虽然这个操作仍然是只读的，但它提供了一个接口，可以通过使用查询过滤器来操控服务器的响应：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This argument doesn’t allow us to execute code, but we could use it to influence
    the server in a variety of ways. For example, providing a negative value (such
    as `-1`) to an `Int`-type argument such as `limit` could result in unexpected
    behaviors. Sometimes APIs interpret `-1` value as *return all*, in which case
    the server will return the entire list of objects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数不允许我们执行代码，但我们可以利用它以各种方式影响服务器。例如，向一个 `Int` 类型的参数（如 `limit`）提供一个负值（如 `-1`），可能会导致意外的行为。有时候，API
    会将 `-1` 的值解释为 *返回所有*，在这种情况下，服务器将返回整个对象列表。
- en: When you identify an argument of type `String`, you might want to spend some
    time experimenting with various injection payloads. Consider the GraphQL mutation
    in [Listing 8-1](#listing8-1), which uses the `createPaste` top-level field.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你识别出一个 `String` 类型的参数时，可能需要花一些时间尝试不同的注入载荷。考虑 [列表 8-1](#listing8-1) 中的 GraphQL
    变更，它使用了 `createPaste` 顶层字段。
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-1: Mutation input points'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-1：变更输入点
- en: 'The `createPaste` field is pretty self-explanatory; it takes information from
    the client and uses that data to create a brand-new paste in the database. In
    this example, the client controls the paste’s format via three arguments to `createPaste`:
    `content`, `title`, and `public`. These arguments are of different types. For
    example, `content` and `title` are of the scalar type `String`, while `public`
    is of the scalar type `Boolean`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`createPaste` 字段非常直观；它接收来自客户端的信息，并利用这些数据在数据库中创建一个全新的粘贴。在这个示例中，客户端通过三个参数控制粘贴的格式：`content`、`title`
    和 `public`。这些参数具有不同的类型。例如，`content` 和 `title` 是标量类型 `String`，而 `public` 是标量类型
    `Boolean`。'
- en: 'Imagine how a paste creation operation might look from a database operation
    perspective. Consider the following SQL example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，从数据库操作的角度看，粘贴创建操作可能是怎样的。考虑以下 SQL 示例：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When a client query is received by a GraphQL API, the server may need to look
    up information in or write information to a database in order to fulfill the query.
    If the GraphQL API is designed to process input from arguments such as `content`
    and `title` without proper security validations, data can be injected directly
    into the SQL command, which could allow for a SQLi vulnerability.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端查询被 GraphQL API 接收时，服务器可能需要查找或写入数据库中的信息，以便满足查询。如果 GraphQL API 设计为处理诸如 `content`
    和 `title` 等参数的输入，而没有适当的安全验证，数据可能会被直接注入到 SQL 命令中，这可能导致 SQL 注入漏洞。
- en: 'Consider the following SQLi example, in which a SQL command is inserted into
    the `content` argument:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 SQL 注入示例，其中 SQL 命令被插入到 `content` 参数中：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A query crafted this way could be converted to a SQL query on the backend,
    and it may look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构造的查询可以在后台转换为 SQL 查询，它可能如下所示：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is important to note that GraphQL APIs could (and should) have multiple layers
    of defensive checks in the query resolvers to mitigate against any forms of injection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，GraphQL API 应该在查询解析器中有多层防御性检查，以减少各种形式的注入攻击。
- en: Field Arguments
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段参数
- en: 'Just like top-level fields, GraphQL fields in selection sets can also take
    arguments. Consider the following query:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像顶层字段一样，GraphQL 查询中的选择集字段也可以接受参数。考虑以下查询：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using this query, we can return a list of users’ IDs and usernames. By default,
    the `username` field is lowercase in the response. Adding the `capitalize` argument
    and setting it to `true` results in the GraphQL resolver capitalizing the username.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个查询，我们可以返回用户的 ID 和用户名列表。默认情况下，响应中的 `username` 字段是小写的。添加 `capitalize` 参数并将其设置为
    `true`，则 GraphQL 解析器会将用户名首字母大写。
- en: Field arguments could be implemented to take different actions when specified
    in a field and, in a security context, aren’t that different from other arguments
    (such as arguments to directives). Values passed to field arguments can be inserted
    into a database or influence logic. The application might even use them as part
    of a different internal API call, so it’s important to test these when they exist.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 字段参数可以被实现为在指定的字段中执行不同的操作，在安全上下文中，它们与其他参数（例如指令的参数）没有太大区别。传递给字段参数的值可以被插入数据库或影响逻辑。应用程序甚至可能将其作为不同内部
    API 调用的一部分，因此在存在这些参数时进行测试非常重要。
- en: Query Directive Arguments
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询指令参数
- en: The query directives attached to certain GraphQL fields can also accept arguments,
    often of scalar types such as `String` and `Boolean`. The way these directives
    are used is completely implementation dependent, but it’s always worth checking
    which kinds of values they allow a client to send.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到某些 GraphQL 字段的查询指令也可以接受参数，通常是标量类型，如 `String` 和 `Boolean`。这些指令的使用方式完全依赖于实现，但检查它们允许客户端发送哪些类型的值始终是值得的。
- en: 'Consider the following query:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下查询：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we specify an argument named `style` to the directive `show_network`.
    The `style` argument is of type `String`, and it accepts arbitrary strings. In
    this example, we supply `cidr` as the value. In the backend, this will transform
    the `ipAddr` (IP address) field into an address using *Classless Inter-Domain
    Routing (CIDR)* notation. For example, the IPv4 address 192.168.0.1 will become
    192.168.0.1/32.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们为指令 `show_network` 指定了一个名为 `style` 的参数。`style` 参数的类型是 `String`，并且接受任意字符串。在此示例中，我们提供了
    `cidr` 作为值。在后台，这将把 `ipAddr`（IP 地址）字段转换为使用 *无类域间路由（CIDR）* 标记法的地址。例如，IPv4 地址 192.168.0.1
    将变为 192.168.0.1/32。
- en: Query directive arguments can be prone to injections too. Attackers can use
    them to influence the way the server returns the response to the specific field.
    For instance, a query directive might use the argument `where`, which then gets
    translated to a SQL-matching pattern (for example, the `LIKE` operator).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 查询指令参数也可能容易受到注入攻击。攻击者可以利用这些参数来影响服务器返回特定字段的响应方式。例如，查询指令可能使用参数 `where`，然后该参数被转换为
    SQL 匹配模式（例如，`LIKE` 操作符）。
- en: You can use the introspection query shown in [Listing 8-2](#listing8-2) to get
    only the available directives by using the `__schema` meta-field with the `directives`
    field.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 [清单 8-2](#listing8-2) 中显示的内省查询，通过使用 `__schema` 元字段和 `directives` 字段来仅获取可用的指令。
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-2: A GraphQL introspection query used to list directives'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-2：用于列出指令的 GraphQL 内省查询
- en: Operation Names
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作名称
- en: '*Operation names* are strings we can add to GraphQL operations such as queries,
    mutations, or subscriptions. They are often used to uniquely name each query when
    multiple queries are sent together. GraphQL graphical IDEs such as GraphiQL Explorer
    and GraphQL Playground use the operation name as a way to allow clients to choose
    which operation to run when more than one query exists in a document through a
    drop-down menu, as shown in [Figure 8-2](#figure8-2).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作名称* 是我们可以添加到 GraphQL 操作中的字符串，例如查询、变更或订阅。它们通常用于在发送多个查询时唯一标识每个查询。像 GraphiQL
    Explorer 和 GraphQL Playground 这样的 GraphQL 图形化 IDE 使用操作名称作为一种方式，允许客户端在文档中存在多个查询时通过下拉菜单选择要执行的操作，如
    [图 8-2](#figure8-2) 所示。'
- en: '![](image_fi/502840c08/f08002.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08002.png)'
- en: 'Figure 8-2: Executing a selected query based on its operation name in GraphiQL
    Explorer'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2：在 GraphiQL Explorer 中基于操作名称执行选定的查询
- en: Operation names are also used for other purposes, such as debugging and logging.
    In fact, they are interesting potential injection vectors because applications
    can use them in many ways. For instance, some applications use operation names
    for analytics, to determine which queries clients use the most. The operation
    name string could end up in different systems, such as logging systems, relational
    databases, cache databases, and so on. It is important to check whether the GraphQL
    API allows special characters as part of the operation name, as this could turn
    out to be an injectable interface.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 操作名称也用于其他目的，如调试和日志记录。事实上，它们是有趣的潜在注入向量，因为应用程序可以以多种方式使用它们。例如，一些应用程序使用操作名称进行分析，以确定客户端最常使用的查询。操作名称字符串可能最终出现在不同的系统中，如日志系统、关系数据库、缓存数据库等。因此，检查
    GraphQL API 是否允许将特殊字符作为操作名称的一部分是很重要的，因为这可能成为一个可注入的接口。
- en: Operation names are typically alphanumeric, but some GraphQL server implementations
    are more permissive than others when it comes to the type of characters they permit.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 操作名称通常是字母数字的，但有些 GraphQL 服务器实现对其允许的字符类型比其他服务器更宽松。
- en: Input Entry Points
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入入口点
- en: When attempting to perform injection testing against GraphQL APIs, we need to
    find a way to discover input entry points. If we are lucky and introspection is
    left enabled, we can often quickly access the various queries, mutations, and
    subscriptions that the API supports, along with information about its types, fields,
    arguments, and so on, using a GraphQL IDE tool like Altair, GraphiQL Explorer,
    or GraphQL Playground.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 GraphQL API 进行注入测试时，我们需要找到一种方法来发现输入入口点。如果运气好且 introspection（自省功能）仍然启用，我们通常可以快速访问
    API 支持的各种查询、变更和订阅，以及有关其类型、字段、参数等信息，使用像 Altair、GraphiQL Explorer 或 GraphQL Playground
    这样的 GraphQL IDE 工具。
- en: To view this information about DVGA in Altair, set the URL to ***http://localhost:5013/graphiql***
    and click the **Save** button (the diskette icon) located at the top right. Click
    the **Refresh** button located next to the Save button, and then click **Docs**.
    You should see a section for queries, mutations, and subscriptions. Click any
    of them to see the types of arguments that exist within each, as shown in the
    screenshot in [Figure 8-3](#figure8-3).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Altair 中查看有关 DVGA 的信息，请将 URL 设置为 ***http://localhost:5013/graphiql***，然后点击位于右上角的
    **保存** 按钮（磁盘图标）。点击保存按钮旁边的 **刷新** 按钮，然后点击 **文档**。你应该能看到查询、变更和订阅的部分。点击任意一项，查看每个部分中存在的参数类型，如
    [图 8-3](#figure8-3) 中的截图所示。
- en: '![](image_fi/502840c08/f08003.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c08/f08003.png)'
- en: 'Figure 8-3: Schema documentation in the Altair client'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3：Altair 客户端中的架构文档
- en: If luck isn’t on our side and introspection was disabled on the server, we can
    lean on tools such as Clairvoyance, which we touched on in Chapter 6, to reconstruct
    the schema and discover the various available inputs. Clairvoyance will fuzz the
    GraphQL document inputs to discover all of its various operations, fields, types,
    and arguments necessary to rebuild the complete schema view, which we can then
    use to identify all possible inputs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运气不好且服务器上禁用了 introspection，我们可以依赖像 Clairvoyance 这样的工具（我们在第六章中提到过），通过它重建架构并发现各种可用的输入。Clairvoyance
    会对 GraphQL 文档的输入进行模糊测试，以发现其所有操作、字段、类型和参数，从而重建完整的架构视图，然后我们可以利用这个视图来识别所有可能的输入。
- en: We will next explore how common types of injections could look in the GraphQL
    world by performing some injection testing against DVGA.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过对 DVGA 进行一些注入测试，探索在 GraphQL 世界中常见的注入类型。
- en: SQL Injection
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 注入
- en: '*SQL injection* is one of the oldest types of vulnerabilities out there. SQLi
    vulnerabilities happen when client input is directly inserted into a SQL command
    without proper character escaping. This condition allows a hacker to close out
    the intended SQL query and introduce their own SQL command, effectively interfering
    with the query the application makes to its database.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQL 注入* 是最古老的漏洞类型之一。SQLi 漏洞发生在客户端输入没有经过适当的字符转义而直接插入 SQL 命令时。这种情况允许黑客关闭原本的
    SQL 查询，并引入他们自己的 SQL 命令，从而有效地干扰应用程序与数据库之间的查询。'
- en: 'A SQLi vulnerability in GraphQL APIs could have devastating consequences. Full
    or even partial access to a database could result in any of the following consequences:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API 中的 SQLi 漏洞可能带来灾难性的后果。完全或部分访问数据库可能导致以下任一后果：
- en: '**Impact to data integrity.** A SQLi vulnerability could allow us to manipulate
    data, such as by altering data within a database table.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对数据完整性的影响。** 一个 SQLi 漏洞可能允许我们操控数据，例如修改数据库表中的数据。'
- en: '**Impact to data confidentiality.** SQLi could allow us to leak information
    from a database, either from the application’s specific SQL tables or from other
    tables in the same database. This information could include PII, password hashes,
    sensitive tokens, and so on.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对数据保密性的影响。** SQLi 可能允许我们泄露数据库中的信息，无论是来自应用程序特定的 SQL 表，还是来自同一数据库中的其他表。这些信息可能包括个人身份信息（PII）、密码哈希、敏感令牌等。'
- en: '**Impact to data availability.** SQLi could allow us to delete segments of
    the database or completely drop its tables, resulting in data loss and application
    instabilities.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对数据可用性的影响。** SQLi 可能允许我们删除数据库的部分内容或完全删除表，导致数据丢失和应用程序不稳定。'
- en: In recent years, modern web frameworks have gotten better at mitigating SQLi
    vulnerabilities by offering out-of-the-box defense mechanisms such as parameterized
    queries. Utilizing audited and vetted frameworks enables developers to write code
    more securely by using the framework’s built-in security features, such as through
    functions and libraries.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，现代Web框架在缓解SQL注入漏洞方面取得了更好的进展，通过提供现成的防御机制，如参数化查询。利用经过审计和验证的框架使开发人员能够通过使用框架内置的安全功能（如函数和库）编写更安全的代码。
- en: Understanding the Types of SQL Injection
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解SQL注入的类型
- en: There are two categories of SQLi vulnerabilities, each of which has a few subcategories.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入漏洞有两个类别，每个类别下都有一些子类别。
- en: Classic SQL Injection
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 经典SQL注入
- en: 'You know you’ve run into *classic SQLi* when the application returns SQL query
    errors during injection testing. These errors can be displayed directly in the
    web page or become apparent through network inspection. Two techniques are used
    to identify a classic SQLi vulnerability: error based and union based.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在注入测试期间返回SQL查询错误时，你就遇到了*经典SQL注入*。这些错误可以直接显示在网页上，或者通过网络检查显现出来。识别经典SQL注入漏洞使用两种技术：基于错误和基于联合。
- en: '*Error-based SQLi* is used to identify SQLi vulnerabilities through error observation.
    Applications that throw SQL errors to the client as a result of a failure in SQL
    query execution could allow us to find the right attack pattern to successfully
    exploit the SQLi vulnerability.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于错误的SQL注入*是通过观察错误来识别SQL注入漏洞。那些在SQL查询执行失败时向客户端抛出SQL错误的应用程序可能会让我们找到正确的攻击模式，从而成功利用SQL注入漏洞。'
- en: '*Union-based SQLi* is used to identify SQLi vulnerabilities by leveraging the
    `UNION` SQL operator. `UNION` concatenates results of multiple `SELECT` statements,
    which can then be returned to the client.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于联合的SQL注入*是通过利用`UNION` SQL操作符来识别SQL注入漏洞的。`UNION`用于连接多个`SELECT`语句的结果，然后将其返回给客户端。'
- en: Blind SQL Injection
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 盲SQL注入
- en: In *blind SQLi*, we are given no visible indications that a vulnerability exists.
    Applications could fail silently or redirect their errors to somewhere other than
    the client. Two discovery techniques apply to the blind SQLi category.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在*盲SQL注入*中，我们没有可见的迹象表明存在漏洞。应用程序可能会悄无声息地失败，或者将错误重定向到客户端以外的地方。有两种发现盲SQL注入漏洞的技术。
- en: '*Time-based SQLi* forces the application to wait for a certain amount of time
    before returning a response. By supplying a SQLi payload that instructs the database
    to wait for a certain number of seconds, we can infer that the application is
    vulnerable if a similar delay occurs in returning the final response.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于时间的SQL注入*迫使应用程序在返回响应之前等待一段时间。通过提供一个SQL注入负载，指示数据库等待一定的秒数，我们可以推断如果返回最终响应时出现类似的延迟，则应用程序可能存在漏洞。'
- en: '*Boolean-based SQLi* allows us to infer whether the application is vulnerable
    to SQLi by constructing a payload that will return a Boolean result such as `true`
    or `false`. By using this testing technique, we could influence the way the application
    presents data to the client, which helps us identify whether the vulnerability
    exists.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于布尔值的SQL注入*允许我们通过构造一个将返回布尔结果（如`true`或`false`）的负载来推断应用程序是否容易受到SQL注入攻击。通过使用这种测试技术，我们可以影响应用程序向客户端展示数据的方式，这帮助我们识别是否存在漏洞。'
- en: Testing for SQLi
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试SQL注入
- en: While SQLi vulnerabilities are on the decline, they can still be found occasionally.
    As hackers, we should assume that the application we’re testing may not have the
    appropriate controls in place to prevent SQLi and test for it wherever and whenever
    possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQL注入漏洞有所减少，但偶尔仍然可以发现。作为黑客，我们应假设我们正在测试的应用程序可能没有适当的控制措施来防止SQL注入，因此应在任何可能的地方和时间进行测试。
- en: 'Testing for SQLi can be done in a variety of ways, such as the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入的测试可以通过多种方式进行，例如以下几种：
- en: Submitting characters like single (`'`) or double (`"`) quotes and observing
    how the application handles unexpected inputs and errors.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交诸如单引号(`'`)或双引号(`"`)等字符，并观察应用程序如何处理意外的输入和错误。
- en: Fuzzing input fields and observing application errors that may indicate database
    query failures.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊测试输入字段并观察可能表明数据库查询失败的应用程序错误。
- en: Submitting SQL commands that introduce delays, such as by using `BENCHMARK`
    and `SLEEP` for MySQL databases, `WAITFOR` `DELAY` and `WAITFOR` `TIME` for Microsoft
    SQL Server, or `pg_sleep` for PostgreSQL databases, and then performing a response-timing
    analysis to identify whether the injection was successful. This is especially
    helpful when we are performing blind SQLi testing, whereby application errors
    are invisible to us.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLi in GraphQL can be introduced through any interface that accepts client
    input. In this section, we will explore a SQLi example in GraphQL by using DVGA.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Testing DVGA for SQLi with Burp Suite
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step to injection testing in GraphQL is to find places where we can
    make alterations to queries. We can start by looking at the schema documentation
    in Altair. [Figure 8-4](#figure8-4) shows the Query section. The documentation
    also has mutation and subscription sections, so have a look at those too.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08004.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: Queries in DVGA'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have a few queries to choose from. Now we must prioritize
    which areas to focus on. Notice that a few fields, such as `systemUpdate`, `systemHealth`,
    `audits`, and `deleteAllPastes`, don’t take any kinds of arguments, so we are
    better off focusing on the ones that do. Let’s zoom in on the `pastes` field,
    which takes three optional arguments:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '`public`, of type `Boolean`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit`, of type `Integer`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter`, of type `String`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `filter` argument could be a valuable candidate for SQLi testing, because
    it accepts string values and its name implies that it filters results. This filtering
    could involve backend query resolver logic that uses SQL operations, such as the
    SQL `WHERE` operator, in order to fulfill a query.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a target, let’s begin interacting with DVGA and proxying traffic.
    Open Burp Suite through Kali’s **Applications** menu, and then click **Open Browser**
    to open the built-in browser located under the **Proxy** tab and navigate to ***http://localhost:5013***.
    After the application loads, make sure Burp Suite is in **Intercept** mode. Navigate
    to the **Private Pastes** page in DVGA located in the left sidebar. You should
    see a GraphQL request similar to the one in [Figure 8-5](#figure8-5).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08005.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: Intercepting a GraphQL query in Burp Suite'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, DVGA sends an HTTP POST request using the GraphQL `pastes` query
    operation to get the list of private pastes from the GraphQL API server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: If you switch to the WebSockets History tab, you will notice that DVGA uses
    the subscription operation as well ([Figure 8-6](#figure8-6)). The subscription
    operation in this context allows the client to read new pastes from the API as
    soon as they are created by subscribing to the `pastes` event.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: To more easily manipulate requests, send the request to Burp Suite’s Repeater
    by right-clicking anywhere in the request window and clicking **Send to Repeater**.
    Then click the **Repeater** tab to see the captured request. This allows you to
    replay requests on demand.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the query so that it uses the `filter` argument. First, modify
    the query to look like the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](image_fi/502840c08/f08006.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: The historical WebSocket traffic view in Burp Suite'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Note that when a query contains double quotes, we must escape the quotes by
    using the backslash (`\`) character in Burp, as shown in [Figure 8-7](#figure8-7).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08007.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7: Using Burp Repeater to send modified GraphQL queries'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Send** to send the query to the GraphQL server. In response to this
    query, we should receive a paste that matches our filter search pattern. More
    specifically, it matches the `content` field:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This filter search pattern suggests that some sort of SQL query is happening
    behind the scenes and that this query behaves similarly to the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This SQL query will return the `id`, `content`, and `title` columns from the
    `pastes` SQL table. Using the `WHERE` operator, the result will be filtered to
    return only results related to pastes that include the string `My` `First` `Paste`
    in their content, as defined by the `LIKE` operator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We want to throw some characters at the application that would potentially break
    this query and result in errors, which might indicate that the application is
    sending our input directly into the query. For instance, the SQL query would break
    if we added a single quote (`'`) after the search string, because this would result
    in an orphaned opening single quote without a closing single quote.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s send the following query to DVGA to see the response we receive (notice
    the addition of the single quote):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In Burp, modify the request to look like the one shown in [Figure 8-8](#figure8-8).
    GraphQL should return a response containing an application error through the `errors`
    JSON key that reveals some interesting information.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08008.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-8: Breaking a SQL query by using a single quote with Burp Suite'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: It appears that our string causes the SQL query to become invalid because it
    gets injected directly into the SQL `LIKE` search pattern. The application doesn’t
    escape the single quote we introduced, which allows us to break the SQL query
    altogether. Therefore, SQLite (the SQL engine that runs DVGA) throws errors, as
    you can see based on the string `sqlite3.OperationalError` in the error output.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we think we’ve found a SQLi vulnerability. Now what? Well, we can check
    whether we are able to get additional information from the database by changing
    the SQL query to one that, say, returns all pastes:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now the SQL statement GraphQL uses when it queries the database after parsing
    the incoming GraphQL query might look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By adding a single quote, we end the SQL `LIKE` operator immediately after the
    `My` `First` `Paste` filter pattern. Then we can introduce an `or` condition that
    makes the SQL query always true by adding the `1=1` comparison. We end the SQL
    query by using the comment double dash (`--`) syntax in SQL, which comments out
    the single quote at the end of the query, effectively ensuring that our syntax
    remains valid despite our alteration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-9](#figure8-9) shows what this SQLi query looks like in Burp Suite
    and its result.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08009.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-9: A successful SQL injection with Burp Suite'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The server response contains all pastes in the DVGA database! This is an example
    of a Boolean-based SQLi.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Automating SQL Injection
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other tools attempt to automate the detection of a SQLi vulnerability. In particular,
    SQLmap can help fuzz the GraphQL API with payloads that are tailored to various
    database engines, such as MySQL, PostgreSQL, SQLite, and so on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'When performing a SQLi test, you can take any potential GraphQL query and use
    an asterisk (`*`) to mark a specific position where SQLmap should inject payloads.
    For example, consider the following snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, SQLmap will replace the asterisk with entries from its database
    of SQLi payloads.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: SQLmap can read full HTTP requests from a file. We can take any HTTP request
    and feed it into SQLmap, which will then read the query and use it to execute
    SQL. [Figure 8-10](#figure8-10) shows how to save a request to a file in Burp
    Suite. Right-click anywhere in the request window and select **Copy to File**.
    Name the file *request.txt* and save it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08010.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-10: Saving an HTTP request from Burp Suite to a file'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Next, run SQLmap by using the `-r` (request) argument to specify the file. Set
    the target database engine argument (`--dbms`) to `sqlite`. By providing a database
    engine name, we narrow the number of tests executed to only the relevant subset
    and speed up the process of injection testing. [Listing 8-3](#listing8-3) shows
    how to run the command.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 8-3: A SQLmap successful injection output'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: SQLmap notifies us that it found our asterisk marker (`*`) and asks whether
    we want to process it. Enter `Y`. The tool then indicates that it found JSON data
    within our *request.txt* file and asks whether it should interpret it as JSON.
    Enter `N`, as GraphQL syntax could confuse SQLmap. Next, it suggests reducing
    the number of requests and using only a basic `UNION` test. Enter `Y`. The test
    found that our parameter was vulnerable, so enter `N` to instruct SQLmap not to
    execute any more tests. The tool also highlights the payload that led to a successful
    injection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Now we can gather information about the database by using the `--tables` argument,
    which will list the database tables in DVGA, as shown in [Listing 8-4](#listing8-4).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 8-4: Using SQLmap to list tables in the DVGA database'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we’ve returned tables for the various components in DVGA. Great
    job! We were able to identify a SQL injection vulnerability both manually and
    automatically.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Operating System Command Injection
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Operating system (OS) command injection* vulnerabilities are injections that
    impact the application’s underlying operating system, and they happen when user
    input is inserted into a system shell command. This allows us to introduce additional
    parameters or break out of the designated command and run one that we control.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like SQLi, OS command injection could have severe consequences for an
    application, allowing attackers to do things such as the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Enumerate local services, processes, users, and groups
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exfiltrate local filesystem files, such as sensitive configuration files, database
    files, and so on
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gain remote access by making the server call back to our remote shell
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the server into an attack launchpad using specialized malware
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the server into a crypto-miner
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS command injections could effectively allow us to perform system administration
    tasks on the server, often within the context of the web application user. Web
    servers are often running under Unix accounts such as *www-data*, *apache*, *nginx*,
    or, if we get very lucky, the *root* user.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Applications are often designed to use system shell libraries to perform backend
    tasks. For instance, an application might need to check whether a remote server
    is alive by using the `ping` command or download files by using the `wget` command.
    It might also compress files by using commands such as `zip`, `tar`, or `gunzip`
    or back up filesystems by using commands such as `cp` or `rsync`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'The mere use of system utilities does not necessarily indicate the presence
    of OS command injection vulnerabilities, but if the system utility commands run
    by the application can be influenced by arbitrary user input, things can get dangerous.
    When performing source code review, look for the following imported libraries
    and functions, and see if their commands are constructed using custom user input:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Python libraries such as *subprocess* and *os* and functions like `exec` and
    `eval`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP functions such as `system`, `shell_exec`, `eval`, and `exec`
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java functions such as `Runtime.exec()`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js modules such as `child_process` and functions like `exec` and `spawn`
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Example
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine that an application lets a user supply a URL, then downloads a file
    from that URL into its own filesystem. Consider the following function in Flask,
    a web framework written in Python, as an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code snippet is a Python web application route that exposes an endpoint
    called */download*. This endpoint supports requests coming in via the HTTP POST
    method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'At ❶, the application takes user input submitted through an HTML form on the
    website and assigns it to the `url` variable. At ❷, the `url` variable is used
    in the context of a `wget` command, effectively allowing `wget` to download the
    file by using the `url` variable. The downloaded file is then stored under the
    */data/downloads* folder on the server’s filesystem. As a result, if a client
    provides a URL such as *http://example.com/file.zip*, the web application will
    execute the following shell command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Multiple problems exist here. First, the application allows any URL to be supplied.
    No checks are in place to verify that the input is even in a valid URL format.
    Second, a client could supply internal URLs or private IP addresses as a way to
    identify and reach internal restricted resources, which can also lead to *server-side
    request forgery (SSRF)* vulnerabilities (more on SSRF vulnerabilities in Chapter
    9). In addition, since the application inserts the client input directly into
    the `wget` command, we could introduce any shell command we desire. We could also
    use the semicolon (`;`) character to break or separate the `wget` command and
    start a new command, effectively performing an OS command injection. This could
    lead to complete server compromise.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Manual Testing in DVGA
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In GraphQL, OS command injection can happen if a resolver function accepts arguments
    from a GraphQL field without implementing the necessary verifications on the input.
    Let’s explore what this looks like in DVGA.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the schema documentation we reviewed earlier, we have four fields
    of interest, which all start with the word `system`: `systemUpdate`, `systemHealth`,
    `systemDiagnostics`, and `systemDebug`. While field names can differ from one
    application to another, the word `system` often hints at the use of system shell
    commands under the hood, so exploring those for OS command injections is worthwhile.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever performed a penetration test on your home router, you’ll know
    that its debug or diagnostics page is probably the most interesting place to look
    for impactful vulnerabilities. OS command injections often exist in these interfaces,
    as they use network utilities such as `ping` or `traceroute` under the hood. Home
    routers aren’t particularly famous for their security; they hardly ever check
    input for dangerous characters and are often vulnerable to OS command injection.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll focus on `systemDebug`. Run the following in Altair
    to see the kind of response we get:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you’ve done a bit of Linux system administration, you may recognize the
    following output excerpt; it comes from the `ps` command, which displays information
    about running system and user processes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open the **Docs** page in Altair. Under Queries, you’ll notice that `systemDebug`
    takes a single argument, named `arg`, of type `String`, which seems promising.
    Does the GraphQL query resolver send this argument directly to the `ps` command?
    Let’s find out:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now the output looks a little different. This is because `e` and `f` are two
    valid arguments that the `ps` command accepts and that change the output’s format.
    The `e` argument shows all processes on the system, while `f` changes the output
    format to a full-format listing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks as though the `arg` argument takes our input and concatenates it with
    the `ps` command. We can attempt to introduce our own command by modifying `arg`
    to include the semicolon character (`;`), followed by another Linux command of
    our choice, such as `uptime`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we get different output. It seems to include system information from the
    GraphQL server, confirming our hypothesis that OS command injection is possible:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we will explore how to test for OS command injection a bit more effectively
    by utilizing specialized command-injection frameworks.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Automated Testing with Commix
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve used a manual approach to identifying OS command injection vulnerabilities.
    Sometimes, however, these vulnerabilities won’t be as straightforward to find
    and exploit. For example, some applications may restrict the types of characters
    they accept, making it harder to inject commands into places such as query arguments.
    Alternatively, a firewall between us and the target GraphQL API could block dangerous
    characters from being accepted. These security controls make it difficult to identify
    holes by using a manual testing approach, which is time-consuming.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Automating command injection helps test many character variations until we
    find the right logic. For example, command injections can happen by introducing
    any of the following characters, among others:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: A semicolon (`;`) to separate commands
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single ampersand (`&`) to send the first command to the background and continue
    to a second command we introduced
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A double ampersand (`&&`) to run a second command after the first command finishes
    successfully (returns `true`), acting as an AND condition
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A double pipe (`||`) to run a second command after the first command finishes
    unsuccessfully (returns `false`), acting as an OR condition
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using automated injection tools, we can test many of these characters with
    little to no effort.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '*Commix* is a cross-platform OS command injection framework capable of finding
    and exploiting these vulnerabilities in applications. Commix does its magic by
    fuzzing various application inputs and inspecting the server responses for patterns
    that indicate a successful injection. Commix can also identify successful injection
    attempts through inference, such as by adding delays to commands and timing the
    response through the use of `sleep`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take another look at the GraphQL `systemDebug` field, which allowed us
    to inject OS commands through its `arg` argument. Imagine that, in a penetration
    test, we haven’t identified how to exploit the application in a timely manner
    yet think there might be something there to explore. We can use Commix to scale
    our attack by attempting dozens of payload variations and save valuable time.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The Commix command in [Listing 8-5](#listing8-5) shows how to run an injection
    test against our target application:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 8-5: A successful GraphQL OS command injection with Commix'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: We specify the GraphQL target URL *http://localhost:5013/graphql* by using the
    GraphQL query `systemDebug` along with the `arg` argument. We then use the `-p`
    flag to signal to Commix that it should inject the payloads at the specific `arg`
    placeholder.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Commix identifies that the server wants to set an HTTP cookie. We accept this
    by entering `Y` at the command line. Commix then needs to know the type of operating
    system the remote server is running so it can choose the relevant payloads from
    its database. For example, Linux servers require different injection payloads
    than Windows servers. We choose the Unix option by specifying the `U` character.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Next, we indicate to Commix that it should process the JSON response coming
    from the GraphQL server. We specify that we want to inject payloads inside the
    command boundaries. Commix signals that it found the `arg` argument to be injectable.
    It identified this by inserting the `echo` command into it, along with a unique
    string. If the response contains this unique string, it means the code was successfully
    injected.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: We spawn a pseudo shell in which to send Unix commands to the server. Lastly,
    we send the `ls` command to test that we can interact with the server by using
    our shell and list its files. We can see that a few files were listed, meaning
    we’ve successfully performed an OS command injection.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Commix provides a very convenient way to run a series of injection
    tests against GraphQL APIs.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Code Review of a Resolver Function
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s perform a code review of the resolver function for `systemDebug` to see
    how it is implemented in DVGA ([Listing 8-6](#listing8-6)). This should help us
    better understand the root cause of the OS command injection vulnerability we
    discovered.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 8-6: The resolver function in DVGA'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The `resolve_system_debug()` Python function handles the GraphQL field `systemDebug`.
    It accepts a single, optional argument named `arg`. A default value of `None`
    is set if the client hasn’t set the argument in the query.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this function, the `helpers.run_cmd()` function runs the `ps` system
    shell command, which is concatenated with the `arg` value if it is not `None`.
    If the client provides the argument `ef`, the command effectively becomes the
    following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the client hasn’t supplied any value to the `arg` argument, the function
    simply runs the command `ps` on its own, returning the list of running processes
    on the system.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'The vulnerability here is that there are no security checks on the supplied
    argument `arg`, so the resolver function will execute any Linux command it receives.
    This can be mitigated in multiple ways:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Accepting only alphabetic characters (`a` to `z`) and ensuring that these are
    valid `ps` arguments
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing any dangerous characters that could allow an attacker to introduce
    additional commands
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the command as an unprivileged user to reduce the risk if an injection
    is possible
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dedicated built-in libraries instead of shell commands directly, such
    as the *psutil* library in Python
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we covered injection vulnerabilities that, when present, impact the
    server. Next, we will explore a few injection vulnerabilities that impact clients.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Injection vulnerabilities can also impact clients. Imagine a Profile Update
    page on a social media website that allows users to change their full name and
    bio. If the application doesn’t perform any security validations on this input,
    we could try to use some GraphQL mutation to submit malicious JavaScript code
    to the page and have it render on other clients’ browsers whenever they visit
    our profile. The ability to execute JavaScript on a client’s browser is powerful,
    because it allows us to exfiltrate browser information such as cookies to a remote
    server and obtain access to sensitive session tokens that could hijack a client’s
    session.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '*Cross-site scripting (XSS)* vulnerabilities happen when client-side code (such
    as JavaScript) gets interpreted and executed within the context of a web browser.
    This type of vulnerability has been reported since the 1990s, yet we still see
    it today, more than 30 years later.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are already familiar with XSS vulnerabilities, you’ll find that they
    aren’t very different in GraphQL than in other API technologies such as REST.
    This section provides a brief explanation of the main types of XSS vulnerabilities:
    reflected, stored, and DOM based. Then we’ll explore XSS vulnerabilities in DVGA
    so you can gain experience identifying them in GraphQL APIs.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps the simplest of all XSS vulnerabilities, *reflected XSS* occurs when
    input is submitted to the server and returned in an immediate response to the
    client, such as in HTML error messages or within an HTML page’s content.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: From an attacker standpoint, exploiting a reflected XSS vulnerability requires
    social engineering the victim into clicking a link that triggers the XSS payload,
    causing the attacker’s JavaScript code to run in the victim’s browser.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of GraphQL, a query vulnerable to reflected XSS might look like
    the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This `hello` operation takes a `msg` parameter that accepts input from a client—in
    this case, the string `Black` `Hat` `GraphQL`. When a client submits this information,
    the server will render the page and perhaps print a message such as `Hello Black
    Hat GraphQL!`
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine that we change the `msg` parameter value to a JavaScript payload:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When this gets rendered in the client’s browser, the `<script>` tag will instruct
    the browser to call the `document` JavaScript object and print the `cookie` string.
    Cookies will often include information related to the session, such as identifiers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Because this information isn’t stored in any database on the server, but rather
    is reflected back to the client in the response upon submitting the query, the
    XSS is of a reflection type. We could improve the payload by having the victim’s
    browser send its cookie to a remote server under our control, allowing us to exfiltrate
    the user’s cookies.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier that this attack would require social engineering to be
    useful. For example, via a phishing email, we could send the victim a URL containing
    our malicious JavaScript payload and wait until they click it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be asking yourself, how would this work when using POST requests?
    Well, earlier in the book we mentioned that GraphQL may support GET-based queries,
    so you could attempt to construct a link such as the following and test whether
    the target GraphQL server supports GET-based queries:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This URL, when decoded, looks like the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: GraphQL APIs that support GET-based queries will accept a `query` GET parameter,
    followed by the query syntax. The query operation can be a query or a mutation.
    A victim clicking this link would submit a GraphQL query using a GET request.
    In Chapter 9, you will learn about how GET-based queries can also be leveraged
    to carry cross-site request forgery (CSRF) attacks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Stored XSS
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *stored*, or *persistent*, *XSS*, the injection payload is persisted to a
    datastore, such as a database, rather than reflected to the client as part of
    a response to a query. Thus, unlike reflected XSS, a stored XSS vulnerability
    will trigger the injected script every time the client’s browser loads a page
    containing the malicious payload.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, stored XSS vulnerabilities are considered more dangerous than reflected
    XSS. The existence of the XSS payload in an application’s datastore could pose
    a risk to other systems, such as these:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Other servers reading the malicious input from the same datastore as the GraphQL
    application. These are effectively impacted by the same exploit.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other flows within the same GraphQL application reading from the same datastore.
    The exploit would impact other parts of the application and therefore affect other
    clients.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 8-11](#figure8-11) shows how a stored XSS could impact other systems.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/F08011.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-11: A stored XSS vulnerability impacting adjacent applications'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Our malicious input could traverse many devices and resources on a network;
    after first hitting the GraphQL API layer, it could be inserted into different
    datastores, such as a cache database, a relational database, or a local file.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: From there, we won’t always know whether the exploitation attempt worked. Often
    we need to wait until something (or someone) triggers our payload. Imagine that
    we use a GraphQL mutation to send a JavaScript payload and then don’t receive
    any indication that it was successfully rendered by the application as JavaScript
    code. Several explanations are possible. For example, we may have injected the
    payload into a database table that’s read only by someone with a different level
    of access to the application.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Contact forms provide a good example. Say you submit a payload in a feedback
    form to a store from which you recently bought an item and get a `Thank you for
    your submission` message. Even though you received no indication that the exploitation
    attempt was successful, your attack was not necessarily a dead end. The payload
    might get triggered only after the store opens the feedback form. This could happen
    days or even weeks later. We call these hidden attacks *blind XSS*, a subcategory
    of stored XSS.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: To take advantage of blind XSS vulnerabilities, you can use tools that generate
    unique payloads with which to test. When an XSS vulnerability is found and the
    payload is triggered, the payload will send probes to a centralized server for
    further inspection, allowing you to capture information about the client on which
    the payload was executed. One such tool is *XSS Hunter* ([https://xsshunter.com](https://xsshunter.com)).
    Tools that notify you whenever your XSS payload triggers are pretty convenient.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: DOM-Based XSS
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Document Object Model–based XSS*, or *DOM-based*, vulnerabilities occur when
    a JavaScript injection payload gets executed exclusively within the browser’s
    DOM. The DOM is a representation of a web document that allows applications to
    modify their structure, content, and style. All HTML objects can be manipulated
    using the DOM API.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the document object can be used to get the HTML `<title>` tag
    in a web page. In DVGA’s web interface, open your browser’s developer tools and
    enter the command `document.title` in the **Console** tab. You should see the
    following result:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While reflected XSS and stored XSS result from vulnerabilities that exist in
    server-side code, DOM XSS vulnerabilities usually stem from a vulnerability in
    the frontend application code facing the client. For example, it can happen when
    malicious input can be inserted (often as part of a URL) and passed to a component
    that supports dynamic code execution, like JavaScript’s `eval` function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Because DOM XSS vulnerabilities happen in client-side code, GraphQL APIs aren’t
    the root cause of such vulnerabilities. Despite this fact, we believe it’s important
    to be aware of them, as community-built GraphQL clients could be vulnerable to
    these types of vulnerabilities. For a comprehensive list of the available GraphQL
    client libraries, visit [https://graphql.org/code/#javascript-client](https://graphql.org/code/#javascript-client).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Testing for XSS in DVGA
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will use DVGA’s user interface to perform XSS testing. Numerous
    XSS vulnerabilities are implemented into DVGA, so we can achieve XSS in more than
    one way. We’ll explore a few techniques to get you comfortable with using GraphQL
    queries for XSS testing.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Open your web browser in the lab and navigate to DVGA’s main interface at ***http://localhost:5013***.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Tampering with the Audit Page
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a first step, click some of the pages on the left sidebar, such as Public
    Pastes. Your browser will start sending GraphQL queries to populate the web page
    with information. Next, click the user icon at the top right; then click **Audit**.
    You should be able to see audit events listed, as shown in [Figure 8-12](#figure8-12).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08012.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-12: The audit trail in DVGA'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'This Audit page suggests that the application is automatically tracking every
    query the browser sent while we were browsing the page, gathering information
    such as the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The name of the actor or *user* (in this case, *DVGAUser*)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the *GraphQL operation* that was used (in this case, *getPastes*)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *executed query* (in this case, the `pastes` GraphQL field used with the
    `public` argument and a few selected fields, such as `id`, `title`, and `content`)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This input is fully under our control. Let’s first explore how we can tamper
    with the GraphQL operation to impact the Audit page. Copy and paste the following
    query into Altair and run it:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The mutation creates a new paste with the title `Black Hat GraphQL` and content
    `I just spoofed the operation name`. At the same time, we return the newly created
    paste’s `content` and `title` fields, which should have identical values.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the Audit page. You should be able to see that it now shows our spoofed
    operation name `SpoofedOperationName` under the GraphQL Operation column, as shown
    in [Figure 8-13](#figure8-13). This is what a security analyst might see if attempting
    to monitor GraphQL queries using operation names.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08013.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-13: The Audit page showing the modified operation name in DVGA'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, different GraphQL server implementations may allow
    operation names to include special characters, which could be an injection vector,
    so always test these whenever possible.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Finding Stored XSS in the CreatePaste Mutation
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we create a new paste in DVGA, the GraphQL fields used in our `createPaste`
    mutation, such as `title` and `content`, are shown on the Public Pastes page.
    The screenshot in [Figure 8-14](#figure8-14) shows what this looks like.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08014.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-14: Paste structure and contents in DVGA'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our paste shows up on the web page. This is a good opportunity
    to start testing the `createPaste` field with inputs such as JavaScript code to
    see whether the data is safely rendered in the web interface.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and create a new paste using the mutation query shown in [Listing 8-7](#listing8-7).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 8-7: Injecting an XSS payload using the `createPaste` mutation'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: This mutation creates a new paste that includes a JavaScript `<script>` tag
    in the `content` argument. If the application is vulnerable to XSS, this code
    will get rendered in the browser and an alert message box will pop up with the
    message `XSS`. After sending this mutation query, head over to the **Public Pastes**
    page. You should be greeted with a pop-up message, as shown in [Figure 8-15](#figure8-15).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08015.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-15: An XSS payload triggered via a malicious mutation'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through what happened here. We first created a new paste using `createPaste`,
    supplying a malicious JavaScript payload to the mutation’s `content` argument.
    The API then stored the new paste in the database. Because our client is using
    a GraphQL subscription operation over the WebSocket protocol, and since subscriptions
    are real time, we immediately see the new paste we created containing the malicious
    JavaScript code. This is an example of a stored XSS vulnerability.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Finding Reflected XSS in the File Upload Functionality
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’ll explore the creation of a new paste using a file upload functionality.
    This should give you a sense of how file uploads look in GraphQL and whether they
    could be vulnerable to XSS. Download the following text file to your computer:
    [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch08/paste_from_file.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch08/paste_from_file.txt).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Upload Paste** page in DVGA to upload the text file. This file will
    eventually be stored in the database. Click **Choose File** and select the file
    you downloaded; then click **Upload**.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: You can use Burp Suite to intercept the request before clicking the Upload button
    to see what the GraphQL mutation looks like. Alternatively, use the browser’s
    Network tab in its developer tools. [Figure 8-16](#figure8-16) shows the mutation
    in Burp Suite.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08016.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-16: The `UploadPaste` mutation in Burp Suite'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we’re using `UploadPaste` to create a new paste with a local
    file. You can also see that we’re passing two variables, `content` and `filename`,
    as part of the HTTP POST JSON payload. The `content` key includes the data present
    in the uploaded file, and the `filename` key is the filename that the server will
    set on disk.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The payload defines an HTML heading (`<h3>`), a paragraph (`<p>`), and a JavaScript
    script tag (`<script>`) that calls the `alert` function with the string `Black`
    `Hat` `GraphQL`. This information will be rendered by the browser and, since `alert`
    is used, a pop-up window will appear, confirming our ability to run JavaScript
    through XSS injection.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: After this query is sent to the server (make sure you click **Forward** in Burp
    Suite to do this), we can view the newly uploaded file by navigating to the **Private
    Pastes** page. You should be able to see a JavaScript pop-up, as shown in [Figure
    8-17](#figure8-17).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08017.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-17: The paste code is executed in the browser and triggers the alert
    window.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: We were able to trigger a Stored XSS vulnerability by using `UploadPaste` to
    upload a malicious text file containing JavaScript and HTML code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we took a close look at injection vulnerabilities, ranging
    from those that impact databases and operating systems to those that affect client
    browsers, including classic and blind SQLi; reflected, stored, and DOM-based XSS;
    and OS command injection.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Many issues can arise when GraphQL APIs fail to carefully validate input. We
    identified the various input entry points in GraphQL—from queries, fields, and
    directive arguments to operation names—all of which make up the injection surface.
    Injection vulnerabilities can have a devastating impact on application data, and
    while frameworks have gotten better at protecting against them by offering reusable
    security methods, they are still prevalent today.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
