- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Injection
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Clients interact with APIs in a variety of ways, such as by creating, modifying,
    or deleting data. Challenges arise when applications must handle their arbitrary
    input. Should applications ever trust the input external clients send? What about
    internal clients?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about injection vulnerabilities and discover why
    it is important to identify and secure the various entry points into applications
    backed by a GraphQL API, as well as the consequences of not doing so. We will
    identify opportunities to influence an application’s logic and manipulate it to
    take actions it wasn’t specifically designed to do. Successful injection can lead
    to outcomes ranging from web page manipulation to the execution of code on a database.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL servers typically work with a datastore, such as relational databases
    like MySQL, document databases like Elasticsearch, key/value stores like Redis,
    or even graph databases like Neo4j. All of these can be vulnerable to injection-based
    vulnerabilities. In this chapter, we’ll discuss three types of injection vulnerabilities.
    Some, like SQL injection (SQLi) and operating system command injection, impact
    backend services such as servers and databases. The other, XSS, impacts clients.
  prefs: []
  type: TYPE_NORMAL
- en: Injection Vulnerabilities in GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Injection vulnerabilities occur when an application accepts and processes untrustworthy
    input without any sanitization. *Sanitization* is a security measure that involves
    checking input and removing potentially dangerous characters from it. The absence
    of such a check could allow the input to be interpreted as a command or a query
    and execute on either the client side or server side. Injection is a broad class
    of attacks that can impact a network ecosystem, such as operating systems, clients’
    browsers, databases, third-party systems, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'An application could accidentally introduce injection vulnerabilities in a
    variety of ways, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The application does not implement security checks on the input it receives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application uses insecure libraries (such as a parser) to process user input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application passes the received user input to a third system, which doesn’t
    implement security checks on the input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application accepts input and displays it to the client without transforming
    it in any way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application that implements a GraphQL API can become vulnerable to injection
    vulnerabilities after it starts allowing clients to manipulate data through interfaces
    such as the arguments of queries, mutations, or subscriptions. Even a GraphQL
    API that allows clients to only read data might have vulnerabilities in certain
    interfaces, such as query filters. While the risk can be decreased, it is almost
    never zero.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting user input is hard to avoid completely when building APIs. As the
    application becomes more complex, it will need some sort of input to be useful.
    For example, websites like Twitter or Facebook would be completely pointless if
    they didn’t allow user input. User actions, like tweeting, writing a Facebook
    post on someone’s wall, or uploading a dinner photo to Instagram, all require
    user input.
  prefs: []
  type: TYPE_NORMAL
- en: The Blast Radius of Malicious Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether it comes from human clients, or machines such as other servers on the
    network, it is important to consider that input can be malicious. Even internal
    machines could become compromised and send malicious input to other servers.
  prefs: []
  type: TYPE_NORMAL
- en: Applications are often developed under a relaxed trust model. Such a trust model
    assumes that input coming into the GraphQL API from other internal systems on
    the same network is safe, while input that originates from external sources is
    unsafe. This approach is very common, but designing systems in this way can backfire;
    if we are able to hack a system and send commands to another host on the network,
    we could easily move laterally to other servers. [Figure 8-1](#figure8-1) illustrates
    a similar scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: Network trust boundaries'
  prefs: []
  type: TYPE_NORMAL
- en: This figure describes a penetration test in which we’ve identified an internet-facing
    GraphQL API server, the *public server*. This server happens to be dual-homed,
    meaning it has two network interfaces and is part of two separate networks. The
    server is vulnerable to injection attacks, as it does not adequately check the
    incoming queries it receives from clients.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that the *internal server* in the diagram is also a GraphQL server
    designed to trust any incoming queries from systems on the same network. It was
    configured in this way because it is not internet facing, and the security architects,
    in their threat model, assumed the local network was safe. Yet if the public server
    is hacked, an attacker could send malicious queries to the internal server.
  prefs: []
  type: TYPE_NORMAL
- en: This is why it is important to always perform security checks on any user input.
    It is also why it’s crucial for hackers to test for injection vulnerabilities
    wherever we identify that input is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The OWASP Top 10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every few years, OWASP releases new vulnerability class rankings for web applications
    under the *OWASP Top 10* project to help companies focus their security mitigation
    efforts on the most prevalent software flaw classes.
  prefs: []
  type: TYPE_NORMAL
- en: The injection vulnerability class has been on the OWASP Top 10 list for almost
    two decades. In the latest OWASP Top 10 release, injection vulnerability was ranked
    third, as shown in [Table 8-1](#table8-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-1: OWASP Top 10'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Identifier** | **Vulnerability** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A01 | Broken access control |'
  prefs: []
  type: TYPE_TB
- en: '| A02 | Cryptographic failures |'
  prefs: []
  type: TYPE_TB
- en: '| A03 | Injection |'
  prefs: []
  type: TYPE_TB
- en: '| A04 | Insecure design |'
  prefs: []
  type: TYPE_TB
- en: '| A05 | Security misconfiguration |'
  prefs: []
  type: TYPE_TB
- en: '| A06 | Vulnerable and outdated components |'
  prefs: []
  type: TYPE_TB
- en: '| A07 | Identification and authentication failures |'
  prefs: []
  type: TYPE_TB
- en: '| A08 | Software and data integrity failures |'
  prefs: []
  type: TYPE_TB
- en: '| A09 | Security logging and monitoring failures |'
  prefs: []
  type: TYPE_TB
- en: '| A10 | Server-side request forgery |'
  prefs: []
  type: TYPE_TB
- en: OWASP has also started tracking top vulnerabilities in APIs under a dedicated
    project, the *API Security Top 10*. This split helps distinguish between API-
    and non-API-based vulnerabilities. In the latest project release as of this writing,
    injection was ranked eighth, as shown in [Table 8-2](#table8-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-2: API Security Top 10'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Identifier** | **Vulnerability** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| API1 | Broken object-level authorization |'
  prefs: []
  type: TYPE_TB
- en: '| API2 | Broken user authentication |'
  prefs: []
  type: TYPE_TB
- en: '| API3 | Excessive data exposure |'
  prefs: []
  type: TYPE_TB
- en: '| API4 | Lack of resource and rate limiting |'
  prefs: []
  type: TYPE_TB
- en: '| API5 | Broken function-level authorization |'
  prefs: []
  type: TYPE_TB
- en: '| API6 | Mass assignment |'
  prefs: []
  type: TYPE_TB
- en: '| API7 | Security misconfiguration |'
  prefs: []
  type: TYPE_TB
- en: '| API8 | Injection |'
  prefs: []
  type: TYPE_TB
- en: '| API9 | Improper asset management |'
  prefs: []
  type: TYPE_TB
- en: '| API10 | Insufficient logging and monitoring |'
  prefs: []
  type: TYPE_TB
- en: Injection vulnerabilities can have devastating consequences in APIs, and it
    is important to become comfortable with injection testing in both non-API-based
    web applications and APIs when performing penetration tests.
  prefs: []
  type: TYPE_NORMAL
- en: The Injection Surface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraphQL APIs are typically designed to accept input from clients, perform backend
    actions such as database reading and writing, and return a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, you can have read-only queries such as the following, which doesn’t
    change anything on the server side. Clients can’t use the query to pass arbitrary
    data, only the GraphQL fields `id` and `ipAddr`, which are defined in the GraphQL
    schema, as you might remember from Chapter 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An application developer can get away with having only read-only operations
    if the application wasn’t designed to interact with clients in ways that allow
    them to modify data on the server, but in reality, this will almost never be the
    case. As applications become more complex and feature rich, they’ll need to accept
    client input through interfaces such as query arguments, field arguments, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a few GraphQL components that allow clients to pass arbitrary
    inputs before diving into the various injection vulnerabilities. For each of these
    interfaces, you should ask yourself a few important questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the application verifying the incoming client input at all?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the application accept dangerous characters?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the application throw exceptions when unexpected characters are sent as
    part of a query?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does GraphQL check the value type passed to the arguments?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we infer from the GraphQL server response (or out-of-band response) whether
    an injection attempt was successful?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injection tests will require some trial and error, but once you experience a
    breakthrough, you’ll have a very satisfying feeling.
  prefs: []
  type: TYPE_NORMAL
- en: Query Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GraphQL operations such as queries, mutations, and subscriptions can be designed
    to accept arguments. Consider the following query, which passes a `limit` argument
    with an integer value of `100`. While this operation is still read-only, it provides
    an interface for manipulating the server’s response through the use of query filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This argument doesn’t allow us to execute code, but we could use it to influence
    the server in a variety of ways. For example, providing a negative value (such
    as `-1`) to an `Int`-type argument such as `limit` could result in unexpected
    behaviors. Sometimes APIs interpret `-1` value as *return all*, in which case
    the server will return the entire list of objects.
  prefs: []
  type: TYPE_NORMAL
- en: When you identify an argument of type `String`, you might want to spend some
    time experimenting with various injection payloads. Consider the GraphQL mutation
    in [Listing 8-1](#listing8-1), which uses the `createPaste` top-level field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: Mutation input points'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createPaste` field is pretty self-explanatory; it takes information from
    the client and uses that data to create a brand-new paste in the database. In
    this example, the client controls the paste’s format via three arguments to `createPaste`:
    `content`, `title`, and `public`. These arguments are of different types. For
    example, `content` and `title` are of the scalar type `String`, while `public`
    is of the scalar type `Boolean`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine how a paste creation operation might look from a database operation
    perspective. Consider the following SQL example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When a client query is received by a GraphQL API, the server may need to look
    up information in or write information to a database in order to fulfill the query.
    If the GraphQL API is designed to process input from arguments such as `content`
    and `title` without proper security validations, data can be injected directly
    into the SQL command, which could allow for a SQLi vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following SQLi example, in which a SQL command is inserted into
    the `content` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A query crafted this way could be converted to a SQL query on the backend,
    and it may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that GraphQL APIs could (and should) have multiple layers
    of defensive checks in the query resolvers to mitigate against any forms of injection.
  prefs: []
  type: TYPE_NORMAL
- en: Field Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like top-level fields, GraphQL fields in selection sets can also take
    arguments. Consider the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using this query, we can return a list of users’ IDs and usernames. By default,
    the `username` field is lowercase in the response. Adding the `capitalize` argument
    and setting it to `true` results in the GraphQL resolver capitalizing the username.
  prefs: []
  type: TYPE_NORMAL
- en: Field arguments could be implemented to take different actions when specified
    in a field and, in a security context, aren’t that different from other arguments
    (such as arguments to directives). Values passed to field arguments can be inserted
    into a database or influence logic. The application might even use them as part
    of a different internal API call, so it’s important to test these when they exist.
  prefs: []
  type: TYPE_NORMAL
- en: Query Directive Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The query directives attached to certain GraphQL fields can also accept arguments,
    often of scalar types such as `String` and `Boolean`. The way these directives
    are used is completely implementation dependent, but it’s always worth checking
    which kinds of values they allow a client to send.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we specify an argument named `style` to the directive `show_network`.
    The `style` argument is of type `String`, and it accepts arbitrary strings. In
    this example, we supply `cidr` as the value. In the backend, this will transform
    the `ipAddr` (IP address) field into an address using *Classless Inter-Domain
    Routing (CIDR)* notation. For example, the IPv4 address 192.168.0.1 will become
    192.168.0.1/32.
  prefs: []
  type: TYPE_NORMAL
- en: Query directive arguments can be prone to injections too. Attackers can use
    them to influence the way the server returns the response to the specific field.
    For instance, a query directive might use the argument `where`, which then gets
    translated to a SQL-matching pattern (for example, the `LIKE` operator).
  prefs: []
  type: TYPE_NORMAL
- en: You can use the introspection query shown in [Listing 8-2](#listing8-2) to get
    only the available directives by using the `__schema` meta-field with the `directives`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: A GraphQL introspection query used to list directives'
  prefs: []
  type: TYPE_NORMAL
- en: Operation Names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Operation names* are strings we can add to GraphQL operations such as queries,
    mutations, or subscriptions. They are often used to uniquely name each query when
    multiple queries are sent together. GraphQL graphical IDEs such as GraphiQL Explorer
    and GraphQL Playground use the operation name as a way to allow clients to choose
    which operation to run when more than one query exists in a document through a
    drop-down menu, as shown in [Figure 8-2](#figure8-2).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: Executing a selected query based on its operation name in GraphiQL
    Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: Operation names are also used for other purposes, such as debugging and logging.
    In fact, they are interesting potential injection vectors because applications
    can use them in many ways. For instance, some applications use operation names
    for analytics, to determine which queries clients use the most. The operation
    name string could end up in different systems, such as logging systems, relational
    databases, cache databases, and so on. It is important to check whether the GraphQL
    API allows special characters as part of the operation name, as this could turn
    out to be an injectable interface.
  prefs: []
  type: TYPE_NORMAL
- en: Operation names are typically alphanumeric, but some GraphQL server implementations
    are more permissive than others when it comes to the type of characters they permit.
  prefs: []
  type: TYPE_NORMAL
- en: Input Entry Points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When attempting to perform injection testing against GraphQL APIs, we need to
    find a way to discover input entry points. If we are lucky and introspection is
    left enabled, we can often quickly access the various queries, mutations, and
    subscriptions that the API supports, along with information about its types, fields,
    arguments, and so on, using a GraphQL IDE tool like Altair, GraphiQL Explorer,
    or GraphQL Playground.
  prefs: []
  type: TYPE_NORMAL
- en: To view this information about DVGA in Altair, set the URL to ***http://localhost:5013/graphiql***
    and click the **Save** button (the diskette icon) located at the top right. Click
    the **Refresh** button located next to the Save button, and then click **Docs**.
    You should see a section for queries, mutations, and subscriptions. Click any
    of them to see the types of arguments that exist within each, as shown in the
    screenshot in [Figure 8-3](#figure8-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: Schema documentation in the Altair client'
  prefs: []
  type: TYPE_NORMAL
- en: If luck isn’t on our side and introspection was disabled on the server, we can
    lean on tools such as Clairvoyance, which we touched on in Chapter 6, to reconstruct
    the schema and discover the various available inputs. Clairvoyance will fuzz the
    GraphQL document inputs to discover all of its various operations, fields, types,
    and arguments necessary to rebuild the complete schema view, which we can then
    use to identify all possible inputs.
  prefs: []
  type: TYPE_NORMAL
- en: We will next explore how common types of injections could look in the GraphQL
    world by performing some injection testing against DVGA.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*SQL injection* is one of the oldest types of vulnerabilities out there. SQLi
    vulnerabilities happen when client input is directly inserted into a SQL command
    without proper character escaping. This condition allows a hacker to close out
    the intended SQL query and introduce their own SQL command, effectively interfering
    with the query the application makes to its database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A SQLi vulnerability in GraphQL APIs could have devastating consequences. Full
    or even partial access to a database could result in any of the following consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Impact to data integrity.** A SQLi vulnerability could allow us to manipulate
    data, such as by altering data within a database table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Impact to data confidentiality.** SQLi could allow us to leak information
    from a database, either from the application’s specific SQL tables or from other
    tables in the same database. This information could include PII, password hashes,
    sensitive tokens, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Impact to data availability.** SQLi could allow us to delete segments of
    the database or completely drop its tables, resulting in data loss and application
    instabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In recent years, modern web frameworks have gotten better at mitigating SQLi
    vulnerabilities by offering out-of-the-box defense mechanisms such as parameterized
    queries. Utilizing audited and vetted frameworks enables developers to write code
    more securely by using the framework’s built-in security features, such as through
    functions and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Types of SQL Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two categories of SQLi vulnerabilities, each of which has a few subcategories.
  prefs: []
  type: TYPE_NORMAL
- en: Classic SQL Injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You know you’ve run into *classic SQLi* when the application returns SQL query
    errors during injection testing. These errors can be displayed directly in the
    web page or become apparent through network inspection. Two techniques are used
    to identify a classic SQLi vulnerability: error based and union based.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Error-based SQLi* is used to identify SQLi vulnerabilities through error observation.
    Applications that throw SQL errors to the client as a result of a failure in SQL
    query execution could allow us to find the right attack pattern to successfully
    exploit the SQLi vulnerability.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Union-based SQLi* is used to identify SQLi vulnerabilities by leveraging the
    `UNION` SQL operator. `UNION` concatenates results of multiple `SELECT` statements,
    which can then be returned to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: Blind SQL Injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In *blind SQLi*, we are given no visible indications that a vulnerability exists.
    Applications could fail silently or redirect their errors to somewhere other than
    the client. Two discovery techniques apply to the blind SQLi category.
  prefs: []
  type: TYPE_NORMAL
- en: '*Time-based SQLi* forces the application to wait for a certain amount of time
    before returning a response. By supplying a SQLi payload that instructs the database
    to wait for a certain number of seconds, we can infer that the application is
    vulnerable if a similar delay occurs in returning the final response.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Boolean-based SQLi* allows us to infer whether the application is vulnerable
    to SQLi by constructing a payload that will return a Boolean result such as `true`
    or `false`. By using this testing technique, we could influence the way the application
    presents data to the client, which helps us identify whether the vulnerability
    exists.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing for SQLi
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While SQLi vulnerabilities are on the decline, they can still be found occasionally.
    As hackers, we should assume that the application we’re testing may not have the
    appropriate controls in place to prevent SQLi and test for it wherever and whenever
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing for SQLi can be done in a variety of ways, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Submitting characters like single (`'`) or double (`"`) quotes and observing
    how the application handles unexpected inputs and errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing input fields and observing application errors that may indicate database
    query failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting SQL commands that introduce delays, such as by using `BENCHMARK`
    and `SLEEP` for MySQL databases, `WAITFOR` `DELAY` and `WAITFOR` `TIME` for Microsoft
    SQL Server, or `pg_sleep` for PostgreSQL databases, and then performing a response-timing
    analysis to identify whether the injection was successful. This is especially
    helpful when we are performing blind SQLi testing, whereby application errors
    are invisible to us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLi in GraphQL can be introduced through any interface that accepts client
    input. In this section, we will explore a SQLi example in GraphQL by using DVGA.
  prefs: []
  type: TYPE_NORMAL
- en: Testing DVGA for SQLi with Burp Suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step to injection testing in GraphQL is to find places where we can
    make alterations to queries. We can start by looking at the schema documentation
    in Altair. [Figure 8-4](#figure8-4) shows the Query section. The documentation
    also has mutation and subscription sections, so have a look at those too.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: Queries in DVGA'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have a few queries to choose from. Now we must prioritize
    which areas to focus on. Notice that a few fields, such as `systemUpdate`, `systemHealth`,
    `audits`, and `deleteAllPastes`, don’t take any kinds of arguments, so we are
    better off focusing on the ones that do. Let’s zoom in on the `pastes` field,
    which takes three optional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`, of type `Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit`, of type `Integer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter`, of type `String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `filter` argument could be a valuable candidate for SQLi testing, because
    it accepts string values and its name implies that it filters results. This filtering
    could involve backend query resolver logic that uses SQL operations, such as the
    SQL `WHERE` operator, in order to fulfill a query.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a target, let’s begin interacting with DVGA and proxying traffic.
    Open Burp Suite through Kali’s **Applications** menu, and then click **Open Browser**
    to open the built-in browser located under the **Proxy** tab and navigate to ***http://localhost:5013***.
    After the application loads, make sure Burp Suite is in **Intercept** mode. Navigate
    to the **Private Pastes** page in DVGA located in the left sidebar. You should
    see a GraphQL request similar to the one in [Figure 8-5](#figure8-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: Intercepting a GraphQL query in Burp Suite'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, DVGA sends an HTTP POST request using the GraphQL `pastes` query
    operation to get the list of private pastes from the GraphQL API server.
  prefs: []
  type: TYPE_NORMAL
- en: If you switch to the WebSockets History tab, you will notice that DVGA uses
    the subscription operation as well ([Figure 8-6](#figure8-6)). The subscription
    operation in this context allows the client to read new pastes from the API as
    soon as they are created by subscribing to the `pastes` event.
  prefs: []
  type: TYPE_NORMAL
- en: To more easily manipulate requests, send the request to Burp Suite’s Repeater
    by right-clicking anywhere in the request window and clicking **Send to Repeater**.
    Then click the **Repeater** tab to see the captured request. This allows you to
    replay requests on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the query so that it uses the `filter` argument. First, modify
    the query to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](image_fi/502840c08/f08006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: The historical WebSocket traffic view in Burp Suite'
  prefs: []
  type: TYPE_NORMAL
- en: Note that when a query contains double quotes, we must escape the quotes by
    using the backslash (`\`) character in Burp, as shown in [Figure 8-7](#figure8-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7: Using Burp Repeater to send modified GraphQL queries'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Send** to send the query to the GraphQL server. In response to this
    query, we should receive a paste that matches our filter search pattern. More
    specifically, it matches the `content` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This filter search pattern suggests that some sort of SQL query is happening
    behind the scenes and that this query behaves similarly to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This SQL query will return the `id`, `content`, and `title` columns from the
    `pastes` SQL table. Using the `WHERE` operator, the result will be filtered to
    return only results related to pastes that include the string `My` `First` `Paste`
    in their content, as defined by the `LIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: We want to throw some characters at the application that would potentially break
    this query and result in errors, which might indicate that the application is
    sending our input directly into the query. For instance, the SQL query would break
    if we added a single quote (`'`) after the search string, because this would result
    in an orphaned opening single quote without a closing single quote.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s send the following query to DVGA to see the response we receive (notice
    the addition of the single quote):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In Burp, modify the request to look like the one shown in [Figure 8-8](#figure8-8).
    GraphQL should return a response containing an application error through the `errors`
    JSON key that reveals some interesting information.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-8: Breaking a SQL query by using a single quote with Burp Suite'
  prefs: []
  type: TYPE_NORMAL
- en: It appears that our string causes the SQL query to become invalid because it
    gets injected directly into the SQL `LIKE` search pattern. The application doesn’t
    escape the single quote we introduced, which allows us to break the SQL query
    altogether. Therefore, SQLite (the SQL engine that runs DVGA) throws errors, as
    you can see based on the string `sqlite3.OperationalError` in the error output.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we think we’ve found a SQLi vulnerability. Now what? Well, we can check
    whether we are able to get additional information from the database by changing
    the SQL query to one that, say, returns all pastes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the SQL statement GraphQL uses when it queries the database after parsing
    the incoming GraphQL query might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By adding a single quote, we end the SQL `LIKE` operator immediately after the
    `My` `First` `Paste` filter pattern. Then we can introduce an `or` condition that
    makes the SQL query always true by adding the `1=1` comparison. We end the SQL
    query by using the comment double dash (`--`) syntax in SQL, which comments out
    the single quote at the end of the query, effectively ensuring that our syntax
    remains valid despite our alteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-9](#figure8-9) shows what this SQLi query looks like in Burp Suite
    and its result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-9: A successful SQL injection with Burp Suite'
  prefs: []
  type: TYPE_NORMAL
- en: The server response contains all pastes in the DVGA database! This is an example
    of a Boolean-based SQLi.
  prefs: []
  type: TYPE_NORMAL
- en: Automating SQL Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other tools attempt to automate the detection of a SQLi vulnerability. In particular,
    SQLmap can help fuzz the GraphQL API with payloads that are tailored to various
    database engines, such as MySQL, PostgreSQL, SQLite, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When performing a SQLi test, you can take any potential GraphQL query and use
    an asterisk (`*`) to mark a specific position where SQLmap should inject payloads.
    For example, consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, SQLmap will replace the asterisk with entries from its database
    of SQLi payloads.
  prefs: []
  type: TYPE_NORMAL
- en: SQLmap can read full HTTP requests from a file. We can take any HTTP request
    and feed it into SQLmap, which will then read the query and use it to execute
    SQL. [Figure 8-10](#figure8-10) shows how to save a request to a file in Burp
    Suite. Right-click anywhere in the request window and select **Copy to File**.
    Name the file *request.txt* and save it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-10: Saving an HTTP request from Burp Suite to a file'
  prefs: []
  type: TYPE_NORMAL
- en: Next, run SQLmap by using the `-r` (request) argument to specify the file. Set
    the target database engine argument (`--dbms`) to `sqlite`. By providing a database
    engine name, we narrow the number of tests executed to only the relevant subset
    and speed up the process of injection testing. [Listing 8-3](#listing8-3) shows
    how to run the command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: A SQLmap successful injection output'
  prefs: []
  type: TYPE_NORMAL
- en: SQLmap notifies us that it found our asterisk marker (`*`) and asks whether
    we want to process it. Enter `Y`. The tool then indicates that it found JSON data
    within our *request.txt* file and asks whether it should interpret it as JSON.
    Enter `N`, as GraphQL syntax could confuse SQLmap. Next, it suggests reducing
    the number of requests and using only a basic `UNION` test. Enter `Y`. The test
    found that our parameter was vulnerable, so enter `N` to instruct SQLmap not to
    execute any more tests. The tool also highlights the payload that led to a successful
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can gather information about the database by using the `--tables` argument,
    which will list the database tables in DVGA, as shown in [Listing 8-4](#listing8-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-4: Using SQLmap to list tables in the DVGA database'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we’ve returned tables for the various components in DVGA. Great
    job! We were able to identify a SQL injection vulnerability both manually and
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Operating System Command Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Operating system (OS) command injection* vulnerabilities are injections that
    impact the application’s underlying operating system, and they happen when user
    input is inserted into a system shell command. This allows us to introduce additional
    parameters or break out of the designated command and run one that we control.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like SQLi, OS command injection could have severe consequences for an
    application, allowing attackers to do things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerate local services, processes, users, and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exfiltrate local filesystem files, such as sensitive configuration files, database
    files, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gain remote access by making the server call back to our remote shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the server into an attack launchpad using specialized malware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the server into a crypto-miner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS command injections could effectively allow us to perform system administration
    tasks on the server, often within the context of the web application user. Web
    servers are often running under Unix accounts such as *www-data*, *apache*, *nginx*,
    or, if we get very lucky, the *root* user.
  prefs: []
  type: TYPE_NORMAL
- en: Applications are often designed to use system shell libraries to perform backend
    tasks. For instance, an application might need to check whether a remote server
    is alive by using the `ping` command or download files by using the `wget` command.
    It might also compress files by using commands such as `zip`, `tar`, or `gunzip`
    or back up filesystems by using commands such as `cp` or `rsync`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mere use of system utilities does not necessarily indicate the presence
    of OS command injection vulnerabilities, but if the system utility commands run
    by the application can be influenced by arbitrary user input, things can get dangerous.
    When performing source code review, look for the following imported libraries
    and functions, and see if their commands are constructed using custom user input:'
  prefs: []
  type: TYPE_NORMAL
- en: Python libraries such as *subprocess* and *os* and functions like `exec` and
    `eval`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP functions such as `system`, `shell_exec`, `eval`, and `exec`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java functions such as `Runtime.exec()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js modules such as `child_process` and functions like `exec` and `spawn`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine that an application lets a user supply a URL, then downloads a file
    from that URL into its own filesystem. Consider the following function in Flask,
    a web framework written in Python, as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet is a Python web application route that exposes an endpoint
    called */download*. This endpoint supports requests coming in via the HTTP POST
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ❶, the application takes user input submitted through an HTML form on the
    website and assigns it to the `url` variable. At ❷, the `url` variable is used
    in the context of a `wget` command, effectively allowing `wget` to download the
    file by using the `url` variable. The downloaded file is then stored under the
    */data/downloads* folder on the server’s filesystem. As a result, if a client
    provides a URL such as *http://example.com/file.zip*, the web application will
    execute the following shell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Multiple problems exist here. First, the application allows any URL to be supplied.
    No checks are in place to verify that the input is even in a valid URL format.
    Second, a client could supply internal URLs or private IP addresses as a way to
    identify and reach internal restricted resources, which can also lead to *server-side
    request forgery (SSRF)* vulnerabilities (more on SSRF vulnerabilities in Chapter
    9). In addition, since the application inserts the client input directly into
    the `wget` command, we could introduce any shell command we desire. We could also
    use the semicolon (`;`) character to break or separate the `wget` command and
    start a new command, effectively performing an OS command injection. This could
    lead to complete server compromise.
  prefs: []
  type: TYPE_NORMAL
- en: Manual Testing in DVGA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In GraphQL, OS command injection can happen if a resolver function accepts arguments
    from a GraphQL field without implementing the necessary verifications on the input.
    Let’s explore what this looks like in DVGA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the schema documentation we reviewed earlier, we have four fields
    of interest, which all start with the word `system`: `systemUpdate`, `systemHealth`,
    `systemDiagnostics`, and `systemDebug`. While field names can differ from one
    application to another, the word `system` often hints at the use of system shell
    commands under the hood, so exploring those for OS command injections is worthwhile.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever performed a penetration test on your home router, you’ll know
    that its debug or diagnostics page is probably the most interesting place to look
    for impactful vulnerabilities. OS command injections often exist in these interfaces,
    as they use network utilities such as `ping` or `traceroute` under the hood. Home
    routers aren’t particularly famous for their security; they hardly ever check
    input for dangerous characters and are often vulnerable to OS command injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll focus on `systemDebug`. Run the following in Altair
    to see the kind of response we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’ve done a bit of Linux system administration, you may recognize the
    following output excerpt; it comes from the `ps` command, which displays information
    about running system and user processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the **Docs** page in Altair. Under Queries, you’ll notice that `systemDebug`
    takes a single argument, named `arg`, of type `String`, which seems promising.
    Does the GraphQL query resolver send this argument directly to the `ps` command?
    Let’s find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now the output looks a little different. This is because `e` and `f` are two
    valid arguments that the `ps` command accepts and that change the output’s format.
    The `e` argument shows all processes on the system, while `f` changes the output
    format to a full-format listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks as though the `arg` argument takes our input and concatenates it with
    the `ps` command. We can attempt to introduce our own command by modifying `arg`
    to include the semicolon character (`;`), followed by another Linux command of
    our choice, such as `uptime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we get different output. It seems to include system information from the
    GraphQL server, confirming our hypothesis that OS command injection is possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will explore how to test for OS command injection a bit more effectively
    by utilizing specialized command-injection frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Automated Testing with Commix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve used a manual approach to identifying OS command injection vulnerabilities.
    Sometimes, however, these vulnerabilities won’t be as straightforward to find
    and exploit. For example, some applications may restrict the types of characters
    they accept, making it harder to inject commands into places such as query arguments.
    Alternatively, a firewall between us and the target GraphQL API could block dangerous
    characters from being accepted. These security controls make it difficult to identify
    holes by using a manual testing approach, which is time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automating command injection helps test many character variations until we
    find the right logic. For example, command injections can happen by introducing
    any of the following characters, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: A semicolon (`;`) to separate commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single ampersand (`&`) to send the first command to the background and continue
    to a second command we introduced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A double ampersand (`&&`) to run a second command after the first command finishes
    successfully (returns `true`), acting as an AND condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A double pipe (`||`) to run a second command after the first command finishes
    unsuccessfully (returns `false`), acting as an OR condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using automated injection tools, we can test many of these characters with
    little to no effort.
  prefs: []
  type: TYPE_NORMAL
- en: '*Commix* is a cross-platform OS command injection framework capable of finding
    and exploiting these vulnerabilities in applications. Commix does its magic by
    fuzzing various application inputs and inspecting the server responses for patterns
    that indicate a successful injection. Commix can also identify successful injection
    attempts through inference, such as by adding delays to commands and timing the
    response through the use of `sleep`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take another look at the GraphQL `systemDebug` field, which allowed us
    to inject OS commands through its `arg` argument. Imagine that, in a penetration
    test, we haven’t identified how to exploit the application in a timely manner
    yet think there might be something there to explore. We can use Commix to scale
    our attack by attempting dozens of payload variations and save valuable time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Commix command in [Listing 8-5](#listing8-5) shows how to run an injection
    test against our target application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-5: A successful GraphQL OS command injection with Commix'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the GraphQL target URL *http://localhost:5013/graphql* by using the
    GraphQL query `systemDebug` along with the `arg` argument. We then use the `-p`
    flag to signal to Commix that it should inject the payloads at the specific `arg`
    placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: Commix identifies that the server wants to set an HTTP cookie. We accept this
    by entering `Y` at the command line. Commix then needs to know the type of operating
    system the remote server is running so it can choose the relevant payloads from
    its database. For example, Linux servers require different injection payloads
    than Windows servers. We choose the Unix option by specifying the `U` character.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we indicate to Commix that it should process the JSON response coming
    from the GraphQL server. We specify that we want to inject payloads inside the
    command boundaries. Commix signals that it found the `arg` argument to be injectable.
    It identified this by inserting the `echo` command into it, along with a unique
    string. If the response contains this unique string, it means the code was successfully
    injected.
  prefs: []
  type: TYPE_NORMAL
- en: We spawn a pseudo shell in which to send Unix commands to the server. Lastly,
    we send the `ls` command to test that we can interact with the server by using
    our shell and list its files. We can see that a few files were listed, meaning
    we’ve successfully performed an OS command injection.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Commix provides a very convenient way to run a series of injection
    tests against GraphQL APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Code Review of a Resolver Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s perform a code review of the resolver function for `systemDebug` to see
    how it is implemented in DVGA ([Listing 8-6](#listing8-6)). This should help us
    better understand the root cause of the OS command injection vulnerability we
    discovered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-6: The resolver function in DVGA'
  prefs: []
  type: TYPE_NORMAL
- en: The `resolve_system_debug()` Python function handles the GraphQL field `systemDebug`.
    It accepts a single, optional argument named `arg`. A default value of `None`
    is set if the client hasn’t set the argument in the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this function, the `helpers.run_cmd()` function runs the `ps` system
    shell command, which is concatenated with the `arg` value if it is not `None`.
    If the client provides the argument `ef`, the command effectively becomes the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If the client hasn’t supplied any value to the `arg` argument, the function
    simply runs the command `ps` on its own, returning the list of running processes
    on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vulnerability here is that there are no security checks on the supplied
    argument `arg`, so the resolver function will execute any Linux command it receives.
    This can be mitigated in multiple ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Accepting only alphabetic characters (`a` to `z`) and ensuring that these are
    valid `ps` arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing any dangerous characters that could allow an attacker to introduce
    additional commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the command as an unprivileged user to reduce the risk if an injection
    is possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dedicated built-in libraries instead of shell commands directly, such
    as the *psutil* library in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we covered injection vulnerabilities that, when present, impact the
    server. Next, we will explore a few injection vulnerabilities that impact clients.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Injection vulnerabilities can also impact clients. Imagine a Profile Update
    page on a social media website that allows users to change their full name and
    bio. If the application doesn’t perform any security validations on this input,
    we could try to use some GraphQL mutation to submit malicious JavaScript code
    to the page and have it render on other clients’ browsers whenever they visit
    our profile. The ability to execute JavaScript on a client’s browser is powerful,
    because it allows us to exfiltrate browser information such as cookies to a remote
    server and obtain access to sensitive session tokens that could hijack a client’s
    session.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cross-site scripting (XSS)* vulnerabilities happen when client-side code (such
    as JavaScript) gets interpreted and executed within the context of a web browser.
    This type of vulnerability has been reported since the 1990s, yet we still see
    it today, more than 30 years later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are already familiar with XSS vulnerabilities, you’ll find that they
    aren’t very different in GraphQL than in other API technologies such as REST.
    This section provides a brief explanation of the main types of XSS vulnerabilities:
    reflected, stored, and DOM based. Then we’ll explore XSS vulnerabilities in DVGA
    so you can gain experience identifying them in GraphQL APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps the simplest of all XSS vulnerabilities, *reflected XSS* occurs when
    input is submitted to the server and returned in an immediate response to the
    client, such as in HTML error messages or within an HTML page’s content.
  prefs: []
  type: TYPE_NORMAL
- en: From an attacker standpoint, exploiting a reflected XSS vulnerability requires
    social engineering the victim into clicking a link that triggers the XSS payload,
    causing the attacker’s JavaScript code to run in the victim’s browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of GraphQL, a query vulnerable to reflected XSS might look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This `hello` operation takes a `msg` parameter that accepts input from a client—in
    this case, the string `Black` `Hat` `GraphQL`. When a client submits this information,
    the server will render the page and perhaps print a message such as `Hello Black
    Hat GraphQL!`
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine that we change the `msg` parameter value to a JavaScript payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When this gets rendered in the client’s browser, the `<script>` tag will instruct
    the browser to call the `document` JavaScript object and print the `cookie` string.
    Cookies will often include information related to the session, such as identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Because this information isn’t stored in any database on the server, but rather
    is reflected back to the client in the response upon submitting the query, the
    XSS is of a reflection type. We could improve the payload by having the victim’s
    browser send its cookie to a remote server under our control, allowing us to exfiltrate
    the user’s cookies.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier that this attack would require social engineering to be
    useful. For example, via a phishing email, we could send the victim a URL containing
    our malicious JavaScript payload and wait until they click it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be asking yourself, how would this work when using POST requests?
    Well, earlier in the book we mentioned that GraphQL may support GET-based queries,
    so you could attempt to construct a link such as the following and test whether
    the target GraphQL server supports GET-based queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This URL, when decoded, looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: GraphQL APIs that support GET-based queries will accept a `query` GET parameter,
    followed by the query syntax. The query operation can be a query or a mutation.
    A victim clicking this link would submit a GraphQL query using a GET request.
    In Chapter 9, you will learn about how GET-based queries can also be leveraged
    to carry cross-site request forgery (CSRF) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Stored XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *stored*, or *persistent*, *XSS*, the injection payload is persisted to a
    datastore, such as a database, rather than reflected to the client as part of
    a response to a query. Thus, unlike reflected XSS, a stored XSS vulnerability
    will trigger the injected script every time the client’s browser loads a page
    containing the malicious payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, stored XSS vulnerabilities are considered more dangerous than reflected
    XSS. The existence of the XSS payload in an application’s datastore could pose
    a risk to other systems, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Other servers reading the malicious input from the same datastore as the GraphQL
    application. These are effectively impacted by the same exploit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other flows within the same GraphQL application reading from the same datastore.
    The exploit would impact other parts of the application and therefore affect other
    clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 8-11](#figure8-11) shows how a stored XSS could impact other systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/F08011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-11: A stored XSS vulnerability impacting adjacent applications'
  prefs: []
  type: TYPE_NORMAL
- en: Our malicious input could traverse many devices and resources on a network;
    after first hitting the GraphQL API layer, it could be inserted into different
    datastores, such as a cache database, a relational database, or a local file.
  prefs: []
  type: TYPE_NORMAL
- en: From there, we won’t always know whether the exploitation attempt worked. Often
    we need to wait until something (or someone) triggers our payload. Imagine that
    we use a GraphQL mutation to send a JavaScript payload and then don’t receive
    any indication that it was successfully rendered by the application as JavaScript
    code. Several explanations are possible. For example, we may have injected the
    payload into a database table that’s read only by someone with a different level
    of access to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Contact forms provide a good example. Say you submit a payload in a feedback
    form to a store from which you recently bought an item and get a `Thank you for
    your submission` message. Even though you received no indication that the exploitation
    attempt was successful, your attack was not necessarily a dead end. The payload
    might get triggered only after the store opens the feedback form. This could happen
    days or even weeks later. We call these hidden attacks *blind XSS*, a subcategory
    of stored XSS.
  prefs: []
  type: TYPE_NORMAL
- en: To take advantage of blind XSS vulnerabilities, you can use tools that generate
    unique payloads with which to test. When an XSS vulnerability is found and the
    payload is triggered, the payload will send probes to a centralized server for
    further inspection, allowing you to capture information about the client on which
    the payload was executed. One such tool is *XSS Hunter* ([https://xsshunter.com](https://xsshunter.com)).
    Tools that notify you whenever your XSS payload triggers are pretty convenient.
  prefs: []
  type: TYPE_NORMAL
- en: DOM-Based XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Document Object Model–based XSS*, or *DOM-based*, vulnerabilities occur when
    a JavaScript injection payload gets executed exclusively within the browser’s
    DOM. The DOM is a representation of a web document that allows applications to
    modify their structure, content, and style. All HTML objects can be manipulated
    using the DOM API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the document object can be used to get the HTML `<title>` tag
    in a web page. In DVGA’s web interface, open your browser’s developer tools and
    enter the command `document.title` in the **Console** tab. You should see the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: While reflected XSS and stored XSS result from vulnerabilities that exist in
    server-side code, DOM XSS vulnerabilities usually stem from a vulnerability in
    the frontend application code facing the client. For example, it can happen when
    malicious input can be inserted (often as part of a URL) and passed to a component
    that supports dynamic code execution, like JavaScript’s `eval` function.
  prefs: []
  type: TYPE_NORMAL
- en: Because DOM XSS vulnerabilities happen in client-side code, GraphQL APIs aren’t
    the root cause of such vulnerabilities. Despite this fact, we believe it’s important
    to be aware of them, as community-built GraphQL clients could be vulnerable to
    these types of vulnerabilities. For a comprehensive list of the available GraphQL
    client libraries, visit [https://graphql.org/code/#javascript-client](https://graphql.org/code/#javascript-client).
  prefs: []
  type: TYPE_NORMAL
- en: Testing for XSS in DVGA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will use DVGA’s user interface to perform XSS testing. Numerous
    XSS vulnerabilities are implemented into DVGA, so we can achieve XSS in more than
    one way. We’ll explore a few techniques to get you comfortable with using GraphQL
    queries for XSS testing.
  prefs: []
  type: TYPE_NORMAL
- en: Open your web browser in the lab and navigate to DVGA’s main interface at ***http://localhost:5013***.
  prefs: []
  type: TYPE_NORMAL
- en: Tampering with the Audit Page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a first step, click some of the pages on the left sidebar, such as Public
    Pastes. Your browser will start sending GraphQL queries to populate the web page
    with information. Next, click the user icon at the top right; then click **Audit**.
    You should be able to see audit events listed, as shown in [Figure 8-12](#figure8-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-12: The audit trail in DVGA'
  prefs: []
  type: TYPE_NORMAL
- en: 'This Audit page suggests that the application is automatically tracking every
    query the browser sent while we were browsing the page, gathering information
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the actor or *user* (in this case, *DVGAUser*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the *GraphQL operation* that was used (in this case, *getPastes*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *executed query* (in this case, the `pastes` GraphQL field used with the
    `public` argument and a few selected fields, such as `id`, `title`, and `content`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This input is fully under our control. Let’s first explore how we can tamper
    with the GraphQL operation to impact the Audit page. Copy and paste the following
    query into Altair and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The mutation creates a new paste with the title `Black Hat GraphQL` and content
    `I just spoofed the operation name`. At the same time, we return the newly created
    paste’s `content` and `title` fields, which should have identical values.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the Audit page. You should be able to see that it now shows our spoofed
    operation name `SpoofedOperationName` under the GraphQL Operation column, as shown
    in [Figure 8-13](#figure8-13). This is what a security analyst might see if attempting
    to monitor GraphQL queries using operation names.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-13: The Audit page showing the modified operation name in DVGA'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, different GraphQL server implementations may allow
    operation names to include special characters, which could be an injection vector,
    so always test these whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Stored XSS in the CreatePaste Mutation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we create a new paste in DVGA, the GraphQL fields used in our `createPaste`
    mutation, such as `title` and `content`, are shown on the Public Pastes page.
    The screenshot in [Figure 8-14](#figure8-14) shows what this looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-14: Paste structure and contents in DVGA'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our paste shows up on the web page. This is a good opportunity
    to start testing the `createPaste` field with inputs such as JavaScript code to
    see whether the data is safely rendered in the web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and create a new paste using the mutation query shown in [Listing 8-7](#listing8-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-7: Injecting an XSS payload using the `createPaste` mutation'
  prefs: []
  type: TYPE_NORMAL
- en: This mutation creates a new paste that includes a JavaScript `<script>` tag
    in the `content` argument. If the application is vulnerable to XSS, this code
    will get rendered in the browser and an alert message box will pop up with the
    message `XSS`. After sending this mutation query, head over to the **Public Pastes**
    page. You should be greeted with a pop-up message, as shown in [Figure 8-15](#figure8-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-15: An XSS payload triggered via a malicious mutation'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through what happened here. We first created a new paste using `createPaste`,
    supplying a malicious JavaScript payload to the mutation’s `content` argument.
    The API then stored the new paste in the database. Because our client is using
    a GraphQL subscription operation over the WebSocket protocol, and since subscriptions
    are real time, we immediately see the new paste we created containing the malicious
    JavaScript code. This is an example of a stored XSS vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Reflected XSS in the File Upload Functionality
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’ll explore the creation of a new paste using a file upload functionality.
    This should give you a sense of how file uploads look in GraphQL and whether they
    could be vulnerable to XSS. Download the following text file to your computer:
    [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch08/paste_from_file.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch08/paste_from_file.txt).'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Upload Paste** page in DVGA to upload the text file. This file will
    eventually be stored in the database. Click **Choose File** and select the file
    you downloaded; then click **Upload**.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Burp Suite to intercept the request before clicking the Upload button
    to see what the GraphQL mutation looks like. Alternatively, use the browser’s
    Network tab in its developer tools. [Figure 8-16](#figure8-16) shows the mutation
    in Burp Suite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-16: The `UploadPaste` mutation in Burp Suite'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we’re using `UploadPaste` to create a new paste with a local
    file. You can also see that we’re passing two variables, `content` and `filename`,
    as part of the HTTP POST JSON payload. The `content` key includes the data present
    in the uploaded file, and the `filename` key is the filename that the server will
    set on disk.
  prefs: []
  type: TYPE_NORMAL
- en: The payload defines an HTML heading (`<h3>`), a paragraph (`<p>`), and a JavaScript
    script tag (`<script>`) that calls the `alert` function with the string `Black`
    `Hat` `GraphQL`. This information will be rendered by the browser and, since `alert`
    is used, a pop-up window will appear, confirming our ability to run JavaScript
    through XSS injection.
  prefs: []
  type: TYPE_NORMAL
- en: After this query is sent to the server (make sure you click **Forward** in Burp
    Suite to do this), we can view the newly uploaded file by navigating to the **Private
    Pastes** page. You should be able to see a JavaScript pop-up, as shown in [Figure
    8-17](#figure8-17).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c08/f08017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-17: The paste code is executed in the browser and triggers the alert
    window.'
  prefs: []
  type: TYPE_NORMAL
- en: We were able to trigger a Stored XSS vulnerability by using `UploadPaste` to
    upload a malicious text file containing JavaScript and HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we took a close look at injection vulnerabilities, ranging
    from those that impact databases and operating systems to those that affect client
    browsers, including classic and blind SQLi; reflected, stored, and DOM-based XSS;
    and OS command injection.
  prefs: []
  type: TYPE_NORMAL
- en: Many issues can arise when GraphQL APIs fail to carefully validate input. We
    identified the various input entry points in GraphQL—from queries, fields, and
    directive arguments to operation names—all of which make up the injection surface.
    Injection vulnerabilities can have a devastating impact on application data, and
    while frameworks have gotten better at protecting against them by offering reusable
    security methods, they are still prevalent today.
  prefs: []
  type: TYPE_NORMAL
