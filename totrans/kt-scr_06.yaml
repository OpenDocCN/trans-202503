- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 4 SOLVING MATHEMATICAL PROBLEMS WITH CODE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/icon.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After our thorough overview of the fundamentals of the Kotlin programming language
    and the JavaFX graphics tools adapted for use in Kotlin, we’re now prepared to
    tackle a series of math problems in the form of mini projects. The projects will
    grow in complexity over the chapter, but they require only high school math skills.
    Our journey will take us from the ancient civilizations of Babylon, Greece, and
    Egypt to the modern-day world of cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of these projects is to enhance your Kotlin programming skills.
    We’ll discuss the context and mathematics behind each problem in detail, but the
    heart of each project will be developing an appropriate algorithm or problem-solving
    strategy and then implementing it in well-organized code. In doing so, you’ll
    gain a deeper understanding of both programming and math, preparing you to solve
    the more sophisticated problems introduced later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 9: Find the Square Root with the Babylonian Algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: We have several methods of finding the square root of a number. In this project,
    I’ll focus on the Babylonian square root algorithm, one of the most widely used
    methods today.
  prefs: []
  type: TYPE_NORMAL
- en: The Babylonian square root algorithm dates back to around 1800 BCE. It’s believed
    the Babylonians used it for practical purposes, such as land surveying. The algorithm
    was later refined by the Greeks, who used it to calculate square roots to a high
    degree of accuracy. The Greek mathematician Heron of Alexandria described the
    algorithm in his work *Metrica*, written in the first century CE.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its ancient origins, the Babylonian square root algorithm remains a
    valuable tool for understanding the history of mathematics and the development
    of numerical methods. The algorithm’s enduring usefulness is a testament to the
    ingenuity of ancient mathematicians and the power of mathematical techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the Babylonian algorithm to approximate the square root of a positive
    number in a few simple and iterative steps. The algorithm starts with an initial
    guess and then refines that guess until it’s close enough to the actual square
    root. Here’s how the algorithm works:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Start with an initial estimate, guess, for the square root of a positive
    number, N. This is customarily set to N / 2.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Check to see if the absolute value of (guess * guess - N) is less than the
    tolerance value. If yes, then terminate the loop and return the estimated square
    root.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Otherwise, update the guess using the formula guess = (guess + N / guess)
    / 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Repeat steps 2 and 3 until the stopping condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: '### The Code'
  prefs: []
  type: TYPE_NORMAL
- en: The Babylonian algorithm is simple enough that we can write a concise code segment
    to find a square root. However, it’s a good practice to create a separate function
    for a process like this and then call that function from main(). This makes the
    code more reusable and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example Kotlin function for calculating the square root of a positive
    number using the Babylonian algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This babylonianSquareRoot() function takes a positive double-precision number
    num as its single argument. It sets the tolerance value TOL to 0.000001, initializes
    a variable iter to 1 to track the number of iterations, and makes a starting guess
    of num / 2.0. The function then follows the Babylonian algorithm I described,
    using a while loop to refine the value of guess until the result is within the
    tolerance. To help visualize the convergence process, the intermediate values
    of iter and guess are printed at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this function, call it from the main() function and provide the value
    of the number you want to find the square root of, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the user is asked to enter the value of a positive number, which
    is read as a string and converted into a number of type Double before its square
    root is estimated. We’re assuming that the user will enter a valid number, which
    is greater than or equal to 1\. If the user enters characters that cannot be converted
    into a number of type Double, the program is terminated with an error message.
    Also, if the user enters a valid negative number, the algorithm will not converge
    to a real solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](chapter1.xhtml), you learned how to handle such errors or exceptions.
    Feel free to experiment with this code and to make it error-proof by using a try...catch
    block.  #### The Result'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, let’s try running the algorithm! If N is set to 25, the
    code should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the exact value of the square root of 25 is 5\. The Babylonian algorithm,
    like any other numerical algorithm, provides only an approximation. The accuracy
    of this approximation is determined by the value of tolerance (TOL), which can
    be adjusted to make the approximation more or less precise.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that a more accurate square root approximation will take longer
    to compute since the algorithm needs to go through more iterations. This sort
    of trade-off between accuracy and computational time is common.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 10: Create Pythagorean Triples with Euclid’s Formula'
  prefs: []
  type: TYPE_NORMAL
- en: Pythagoras was a Greek philosopher and mathematician who lived in the sixth
    century BCE. He believed in the idea of a harmonious universe and saw numbers,
    mathematics, and geometry as key elements in revealing the universe’s mysteries.
    He’s best known for the Pythagorean theorem, which states that in a right-angled
    triangle, the square of the length of the hypotenuse is equal to the sum of the
    squares of the other two sides (see [Figure 4-1](chapter4.xhtml#fig4-1)). Perhaps
    you’ve seen this theorem summarized as *a*² + *b*² = *c*².
  prefs: []
  type: TYPE_NORMAL
- en: '*Pythagorean triples* are sets of three positive integers (*a*, *b*, *c*) that
    satisfy the Pythagorean theorem. A familiar example is (3, 4, 5): 3² + 4² equals
    9 + 16, which equals 25, or 5². Pythagorean triples are used in many areas of
    mathematics, science, and engineering, including geometry, number theory, cryptography,
    physics, and computer graphics. Throughout history, mathematicians have come up
    with different ways of generating Pythagorean triples. In this project, we’ll
    check out one of the earliest methods, Euclid’s formula, and use it to create
    Pythagorean triples. Here are the steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Choose an arbitrary positive integer k.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Choose a pair of positive integers m and n, such that m > n > 0.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Calculate a = k(m² – n²), b = 2kmn, and c = k(m² + n²).
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The values a, b, and c form a Pythagorean triple (a, b, c).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: The Pythagorean theorem'
  prefs: []
  type: TYPE_NORMAL
- en: A Pythagorean triple is considered *primitive* if its members are all coprime,
    meaning they share no common factors other than 1\. For example, (3, 4, 5) and
    (6, 8, 10) are both Pythagorean triples, but only (3, 4, 5) is primitive, since
    6, 8, and 10 have a common factor of 2\. Euclid’s formula will generate a primitive
    Pythagorean triple if and only if the two integers *m* and *n* are coprime, and
    one of them is even. If both *m* and *n* are odd, then the values of *a*, *b*,
    and *c* will all be even, and the triple won’t be primitive. However, as long
    as *m* and *n* are coprime, dividing the values of *a*, *b*, and *c* by 2 will
    result in a primitive Pythagorean triple.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s a Kotlin function that generates a Pythagorean triple using Euclid’s
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function takes in two integers *m* and *n*, then uses them to calculate
    and return *a*, *b*, and *c*. By not explicitly including a value for *k* here,
    we’re implicitly assuming *k* = 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call this function repeatedly from the main() function, using a for
    loop to generate Pythagorean triples for an arbitrary number of pairs of successive
    integers, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the first triple is generated using an m of 2 and an n of 1. These
    are the smallest possible values of m and n. (Recall the stipulation in Euclid’s
    formula that *m* and *n* must be positive integers such that *m* > *n* > 0.) These
    values are passed on as arguments to the generatePythagoreanTriple() function,
    which returns the elements of the Pythagorean triple as a Triple object in Kotlin.
    Successive inputs are generated by incrementing both m and n inside the for loop
    that repeats numTriples times. Since m and n are consecutive, one of them will
    always be even, and they can’t possibly share any factors, so every triple will
    be primitive.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you don’t change any of the program parameters, the program will produce
    the following output that shows the first 10 Pythagorean triples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the starting values of m and n were hardcoded in the main()
    function. You might modify the code to allow the user to input values of m and
    n (ensuring *m* > *n* > 0). That would allow the user to generate a wider range
    of Pythagorean triples based on their requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 11: Identify Prime Numbers with the Sieve of Eratosthenes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Eratosthenes was an ancient Greek scholar who lived in the third century BCE.
    He was an accomplished mathematician, astronomer, geographer, and poet. In this
    project, we’ll explore one of Eratosthenes’s many mathematical discoveries: the
    *sieve of Eratosthenes*, an intuitive algorithm for identifying all the prime
    numbers up to a given limit. (We’ll explore another of his ingenious discoveries
    in the next project.) It’s remarkable to think that Eratosthenes conceived this
    strategy more than two millennia ago, during a time when few individuals could
    read or write, let alone think about algorithms and solve abstract mathematical
    problems.'
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To sieve for primes like Eratosthenes, start by creating a list of all integers
    from 2 up to some limit. Then, starting from 2, iteratively mark off all multiples
    of each prime number as composite. The unmarked numbers that remain at the end
    of the process are all prime numbers. Here are the steps to implement this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Create a list of consecutive integers from 2 through the given limit.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Starting with 2 (the first prime number), mark all its multiples as composite.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Find the next number in the list that isn’t marked as composite. This will
    be the next prime number.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Mark all multiples of the prime number found in step 3 as composite.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Repeat steps 3 and 4 until the square of the next prime number exceeds the
    given limit.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  The unmarked numbers in the list are all prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We can optimize the sieve algorithm by marking multiples of each prime number,
    starting from its square. For example, when marking multiples of 3, we can start
    at 3² = 9, since all multiples of 3 less than 9 will already have been marked
    as composite. In this case, 6 will have been marked while going through the multiples
    of 2\. Similarly, when we get to multiples of 5, we can skip 10, 15, and 20 as
    being multiples of either 2 or 3 and start marking off composites from 25.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As before, we’ll start by writing a function to implement the algorithm and
    then use the main() function to call this function and list the prime numbers.
    Here’s the Kotlin code for the sieveOfEratosthenes() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The sieveOfEratosthenes() function takes an integer n as input and returns a
    list of prime numbers up to n. For that, the function creates a Boolean array
    primes with a length of n + 1 and initializes each element’s value to true. Over
    the course of the function, we’ll change elements to false if their indices aren’t
    prime. The function also creates a mutable list primeNumbers of type Int to save
    the prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we set the first two values of the primes array to false because 0
    and 1 aren’t prime. We then iterate over the numbers from 2 to the square root
    of n (we do this by ensuring i*i <= n) ❶. For each number i in this range, if
    i is marked as prime (that is, true) in the primes array ❷, the function marks
    all multiples of i in the primes array as composite (false). To reach all the
    multiples of i, we use a for loop with a step size of i ❸.
  prefs: []
  type: TYPE_NORMAL
- en: To collect the prime numbers, we use a for loop ❹ to go over all primes elements
    and add the corresponding index to primeNumbers when the value of the element
    is true. Finally, we return the prime numbers to main() as a list of integers
    for postprocessing ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our sieving function is good to go, we can use the main() function
    to retrieve a list of prime numbers up to n and print it out. We’ll also create
    a printPrimes() helper function to manage the printing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The main() function is similar to the one we used for the Babylonian square
    root algorithm in [Project 9](chapter4.xhtml#pre-9). It takes a user input for
    the limit num, uses it to create a list of prime numbers with the sieveOfEratosthenes()
    function, and then calls printPrimes() to print the list. To make the output look
    nice, printPrimes() organizes the numbers into rows of six and uses string formatting
    to create neatly aligned columns.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s a look at the program output up to an arbitrary limit num of 251:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Other methods for generating prime numbers include the sieve of Sundaram, the
    sieve of Atkin, and trial division. I encourage you to do some online research
    and experiment with these methods to enhance your Kotlin coding skills and gain
    additional insight into prime number generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 12: Calculate Earth’s Circumference the Ancient Way'
  prefs: []
  type: TYPE_NORMAL
- en: One of Eratosthenes’s most famous achievements was calculating Earth’s circumference.
    He accomplished this by measuring the angle of the sun’s rays at noon on the summer
    solstice at two locations, Alexandria and Syene (modern-day Aswan), which were
    known to be on the same meridian, or longitude. [Figure 4-2](chapter4.xhtml#fig4-2)
    shows an abstraction of some of the geometry involved in this brilliant experiment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: Measuring Earth’s circumference'
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, we can think of points E and B as two locations on Earth’s
    surface (for example, Alexandria and Syene). We’ll assume for the sake of simplicity
    that Earth is a perfect sphere and that both of these locations are on the same
    meridian. Let’s also assume that *AB* and *DE* are two tall poles or towers that
    are sufficiently far apart that when extended to Earth’s center (C), they create
    a small but measurable angle *α*. Two parallel rays coming from the sun just miss
    the tops of the poles and will hit the ground at slightly different angles. Because
    Earth’s surface is curved, the angle *θ*[2] between ray 2 and *DE* will be slightly
    greater than the angle *θ*[1] between ray 1 and *AB*. As a result, the shadow
    of *DE* on the ground will be longer than that of *AB*, even if the poles themselves
    have the same height.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also assume that at both locations the poles are positioned vertically relative
    to the ground surface, which can be thought of as flat in the vicinity of the
    poles. This last assumption allows us to measure the angle of a ray of light relative
    to a pole. Assuming that the length of the shadow is *s* and the height of the
    pole is *h*, the angle *θ* between the ray and the pole can be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (4.1) ![](../images/eq4-1.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, consider triangle *ACF* in [Figure 4-2](chapter4.xhtml#fig4-2). According
    to the *exterior angle theorem*, the triangle’s exterior angle *AFE* must be equal
    to the sum of the two interior opposite angles, *ACF* and *CAF*. Meanwhile, *AFE*
    and *θ*[2] are equal because these are the *alternate interior angles* of the
    line *DF* that intersects the two parallel solar rays. Therefore, the following
    must be true:'
  prefs: []
  type: TYPE_NORMAL
- en: ∠*AFE* = ∠*ACF* + ∠*CAF*
  prefs: []
  type: TYPE_NORMAL
- en: '*  θ*[2] = *θ*[1] + *α*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rearranging the latter, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (4.2) ![](../images/eq4-2.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'This final equation is what we need to estimate Earth’s circumference. We’ll
    achieve that by using another geometric relationship that connects the length
    *d* of an arc of a circle to the angle *α* (in radians) that the arc creates at
    the center of the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ ![](../images/pg137-1.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving for the circumference gives us this equation:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (4.3) ![](../images/eq4-3.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: What Eratosthenes did was quite ingenious. He knew that at noon on the summer
    solstice, the sun would be directly overhead at Syene (point B in [Figure 4-2](chapter4.xhtml#fig4-2)),
    so a vertical pole there would cast no shadow, meaning *θ*[1] = 0, and therefore
    *α* = *θ*[2] per Equation 4.2\. In Alexandria (point E), however, the sun would
    be at an angle, so a pole would cast a shadow on the ground. By measuring the
    length of this shadow, Eratosthenes was able to calculate the angle between the
    sun’s ray (ray 2) and the pole (*DE*) using Equation 4.1\. He found this angle
    to be about 7.2 degrees, or 0.12566370614 radians.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eratosthenes was aware of the distance between Alexandria and Syene—he estimated
    it to be 5,000 stadia (about 800 kilometers). With this information and the angle
    of the shadow, he calculated Earth’s circumference (using Equation 4.3) and arrived
    at a value of approximately 40,000 kilometers. Once he determined the circumference,
    he could also calculate Earth’s radius. For any circle, the radius *r* can be
    calculated from the circumference as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ ![](../images/pg138-1.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Filling in the circumference formula from Equation 4.3, Earth’s radius *R*
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (4.4) ![](../images/eq4-4.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: This calculation gave Eratosthenes a value of 6,370 kilometers, which is remarkably
    close to the actual value of approximately 6,371 kilometers.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s write some code to imitate the method Eratosthenes used to calculate Earth’s
    circumference and radius. We’ll make our program more flexible by allowing the
    sun to not be directly overhead at the first location. To do this, we’ll use Equation
    4.1 to figure out the shadow angles, Equation 4.2 to get the arc angle, Equation
    4.3 to calculate the circumference, and finally, Equation 4.4 to calculate the
    radius.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The code segment starts by importing the required math function and defining
    a data class Earth with three properties: alpha, circumference, and radius. This
    data class allows us to conveniently package up the values estimated inside the
    calculateEarthMetrics() function and return them via a single Earth object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculateEarthMetrics() function has five named parameters that represent
    the shadow lengths (s1 and s2) and heights (h1 and h2) for the two locations,
    and the distance (d) between these two locations. Then the function follows the
    steps described on [page 137](#pg_137): calculating theta1 and theta2, using them
    to calculate alpha, and using alpha to estimate circumference and radius. Since
    these are large numbers (when expressed in kilometers), we convert both circumference
    and radius into integers (which is how they were defined in the Earth class).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main() function’s job is quite simple: call the calculateEarthMetrics()
    function; receive the values of alpha, circumference, and radius by deconstructing
    the returned object; and print them with appropriate annotations and format.'
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the given parameter values in this example—the same ones Eratosthenes used—the
    output of our program looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to use this tool to experiment with different parameter values. For
    example, you could try using shadow lengths and angles measured on an exoplanet
    and find out how large or small the planet is!
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 13: Code the Fibonacci Sequence'
  prefs: []
  type: TYPE_NORMAL
- en: Leonardo of Pisa, commonly known as Fibonacci, was an Italian mathematician
    born c. 1170\. From an early age, he showed a keen interest in mathematics, and
    his travels to North Africa and the Middle East exposed him to advanced mathematical
    concepts that weren’t yet known in Europe. Fibonacci’s most significant contribution
    to mathematics was the introduction of the Indo-Arabic numeral system to the Western
    world, which included the use of zero. This system replaced the previously used
    Roman numerals and revolutionized arithmetic calculations, making them significantly
    more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci is widely recognized for introducing the Fibonacci sequence, a series
    of numbers where each number is the sum of the two preceding numbers. To explain
    this concept in his book *Liber Abaci*, Fibonacci used a colorful analogy involving
    a pair of rabbits. Imagine placing a pair of rabbits in an enclosed area. The
    rabbits can mate when they’re one month old and can produce a new pair of rabbits
    when they’re two months old. Therefore, it takes one month for each new pair to
    mature and an additional month to give birth to a new pair. If the rabbits never
    die and the mating continues, how many pairs of rabbits will there be after each
    month?
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem forms the Fibonacci sequence. If we start with
    (1, 1) representing the starting pair over the first two months, the sequence
    will look like this: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, and so on. These numbers
    can be linked to Fibonacci’s rabbit example as explained in [Table 4-1](chapter4.xhtml#tab4-1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-1: Fibonacci’s Rabbits'
  prefs: []
  type: TYPE_NORMAL
- en: '| Month | Young pairs | Mature pairs | Total pairs | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | Start with a newborn pair, no mature pair, and no offspring.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 | The first pair becomes mature and will reproduce at the end
    of this period. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | 1 | 2 | The first pair of offspring is born. One mature pair will
    reproduce again at the end of this period. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 | 2 | 3 | The second pair of offspring is born. Two mature pairs will
    reproduce at the end of this period. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 2 | 3 | 5 | Two new pairs are born. Three mature pairs will reproduce
    at the end of this period. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 3 | 5 | 8 | Three new pairs are born. Five mature pairs will reproduce
    at the end of this period. |'
  prefs: []
  type: TYPE_TB
- en: 'Say we want to determine how many rabbit pairs will exist after a certain number
    of generations. Here are the steps we can take, using the Fibonacci sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Set the first two numbers in the sequence. By convention, these are usually
    0 and 1 rather than 1 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Add the first two numbers to get the third number in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Generate the next number by adding the two preceding numbers. This step
    can be mathematically expressed as Fn = Fn [– 1] + Fn [– 2], where n ≥ 2.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Repeat step 3 until the stopping condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fibonacci sequence has become a classic example of recursive sequences
    and is used to illustrate many mathematical concepts in various fields. Before
    getting into how to code this sequence, I’ll introduce you to two other related
    concepts: the golden ratio and the Fibonacci spiral. These concepts will be illustrated
    in our Fibonacci code.'
  prefs: []
  type: TYPE_NORMAL
- en: The Golden Ratio
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *golden ratio*, also known as the golden mean, is a mathematical ratio commonly
    found in nature, art, and architecture. The ratio is approximately 1.61803398875
    and is denoted by the Greek letter *φ*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The golden ratio is linked to the Fibonacci sequence: as the sequence continues,
    the ratio between each successive pair of numbers approaches the golden ratio.
    Starting with 1 (we can’t start with 0, as the ratio of 1 over 0 is infinity),
    if we calculate and plot this ratio for each successive pair, it will rapidly
    converge on *φ*, as shown in [Figure 4-3](chapter4.xhtml#fig4-3).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: Convergence to the golden ratio'
  prefs: []
  type: TYPE_NORMAL
- en: Well-known manifestations of the golden ratio in nature include nautilus shells,
    the arrangements of seeds in a sunflower and scales on a pine cone, and the proportions
    of the human body (for example, the ratio of the length of the forearm to the
    hand, and the ratio of the overall height to the height of the navel). The ratio
    has also been extensively exploited by artists, musicians, photographers, product
    designers, and architects in their work. In architecture, for example, it might
    determine the ratio of width to height for a building’s facade.
  prefs: []
  type: TYPE_NORMAL
- en: The Fibonacci Spiral
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Fibonacci spiral is a geometric pattern derived from the Fibonacci sequence.
    It’s created by drawing a series of quarter circles inside squares that are based
    on the numbers in the Fibonacci sequence. To draw the Fibonacci spiral, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Draw a small square with a side length of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Draw another square of side length 1 adjacent to the first square, sharing
    a side.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Draw a third square of side length 2 adjacent to the second square, sharing
    a side.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Draw a fourth square of side length 3 adjacent to the third square, sharing
    a side.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Continue this process, drawing squares with side lengths equal to the sum
    of the two preceding squares, adjacent to the last drawn square, sharing a side.
  prefs: []
  type: TYPE_NORMAL
- en: '6.  Draw a quarter circle inside each of the squares, connecting the opposite
    corners of each square. The quarter circles will form a smooth curve: the Fibonacci
    spiral.'
  prefs: []
  type: TYPE_NORMAL
- en: If you follow these steps and draw the spiral for the first eight numbers (starting
    from 1), the result will look like [Figure 4-4](chapter4.xhtml#fig4-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: A Fibonacci spiral for the first eight numbers'
  prefs: []
  type: TYPE_NORMAL
- en: The Fibonacci spiral, often associated with the golden ratio, is a recurring
    pattern in nature, appearing in various forms such as seashells, leaf arrangements,
    and even the spirals of distant galaxies! While the golden ratio is not an absolute
    prerequisite for beauty or efficiency in design, it undeniably holds an enduring
    charm as a mathematical concept that continues to capture our imagination.
  prefs: []
  type: TYPE_NORMAL
- en: '#### The Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating and printing the Fibonacci sequence up to a certain limit can be
    accomplished with just a few lines of code. Let’s take this project a step further:
    along with generating the sequence itself, we’ll also draw the Fibonacci spiral.
    This way, we’ll be able to practice some of the data visualization techniques
    covered in the previous chapter and anticipate future projects where we’ll gain
    deeper insight into a problem by visualizing the program output.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To begin, we’ll write the global components of the code, including the import
    block needed for the visualization, the FibonacciSpiral application class, and
    the main() function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code segment starts with an import block that provides access to a number
    of JavaFX graphics features that we’ll use to draw the Fibonacci spiral on a canvas
    object. See [Chapter 3](chapter3.xhtml) for a review of these features. Coding
    in IntelliJ IDEA means you don’t need to memorize which library features you need
    to import; as you use the default template and add code that may require additional
    graphics elements, the IDE will import those features automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Following the import block, we set up some global parameters. First, we create
    a variable called N to set how far into the Fibonacci sequence we’ll go (starting
    from 0). Then, we create a mutable list of type Int named fibs, which will store
    the Fibonacci sequence as we calculate it. We also set several parameters to create
    a canvas where we’ll draw the Fibonacci spiral. To define the size of the canvas,
    we use the values canvasW and canvasH, and to set the starting location of the
    origin of the coordinate system, we use xOffset and yOffset. For this particular
    project, I’ve set the canvas size to 1,000 pixels wide and 750 pixels high, which
    should be suitable for most screen sizes and resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the length of a line or the side of a rectangle
    on the canvas is measured in pixels. To plot the Fibonacci spiral, we’ll start
    with a square of size 1\. However, drawing a square of 1 pixel would result in
    a tiny dot on the screen, which we don’t want. To avoid this, we’ll use an amplification
    factor called amplify and set it to 25. Therefore, the first square will be 25
    pixels in size, and all subsequent squares will be amplified by the same factor.
    This ensures that the end result is a Fibonacci spiral that fills the canvas nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the FibonacciSpiral application class, we first create a layout container
    called root of type Pane(), which is the most basic layout container in JavaFX
    to hold and position nodes (user interface components) in a scene. We use root
    to hold the canvas on which the spiral will be drawn. Notice how we use the translate
    property of the graphics context gc to shift the initial position of the origin
    from the top-left corner (the default) to a position offset a bit from the middle
    of the canvas, where we’ll draw the first Fibonacci square (see [Figure 4-4](chapter4.xhtml#fig4-4)
    to get a sense of where that is). The rest of the class is routine JavaFX: we
    assign canvas to root, which is assigned to scene1, which connects to stage, the
    primary display window for this application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we move to the problem-specific segment of the application class, which
    consists of calls to three separate functions: generateFibonacciNumbers(), drawFibonacciSpiral(),
    and printFibonacciSequenceAndRatios(). These functions do exactly what their names
    suggest, and we’ll discuss them in detail shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the main() function contains a single line of code that launches a
    JavaFX application by calling the launch() method of the Application class, passing
    it the FibonacciSpiral class as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the Fibonacci Sequence
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The generateFibonacciNumbers() function generates the Fibonacci sequence as
    discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: First, *F*(0) and *F*(1) are set to 0 and 1, respectively, and then the rest
    of the sequence is generated using *F*n = *F*n [– 1] + *F*n [– 2], where *n* ≥
    2\. We add all generated numbers to the mutable list fibs using its fibs.add()
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the Fibonacci Spiral
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The drawFibonacciSpiral() function drives the process of drawing the Fibonacci
    spiral using the generated sequence of Fibonacci numbers, with support from two
    other helper functions that label each square with its corresponding Fibonacci
    number and draw the quarter circles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The drawFibonacciSpiral() function uses a for loop that starts with 1 (we cannot
    draw a square of size 0) to iterate over the sequence of numbers. In the loop,
    we retrieve the current number and multiply it by amplify to properly scale the
    squares on the screen ❶. Then we implement the rest of the process inside a with(gc)
    block ❷ where we draw a square, annotate it, and draw an arc. At the end of each
    cycle, we move the canvas’s origin to the next location and rotate the coordinate
    system counterclockwise by 90 degrees. This way, the squares will spiral outward,
    as shown in [Figure 4-4](chapter4.xhtml#fig4-4), but we’ll still be able to draw
    each one with the same strokeRect(0.0, 0.0, side, side) call.
  prefs: []
  type: TYPE_NORMAL
- en: In the drawText() function, we use the argument i, which represents the index
    of the current Fibonacci number, to set the font size of the text used for annotation
    ❸. This ensures that the first two numbers fit inside a square of size 25 pixels.
    We then use the fillText() method of the graphics context gc to draw the number
    in the middle of its corresponding square.
  prefs: []
  type: TYPE_NORMAL
- en: The drawArc() function sets up the parameter values needed by the strokeArc()
    method of the graphics context. These parameters include the top-left corner of
    the rectangle, its width and height, the starting angle with respect to the x-axis
    in degrees, and the length of the arc in degrees. We also specify the arc type
    as OPEN, which means the two endpoints won’t be connected with a line.
  prefs: []
  type: TYPE_NORMAL
- en: For drawing the arc, think of the imaginary box inside which the arc will be
    drawn as a stand-alone object that has its own coordinate system whose origin
    is at the center of the box. Inside this box, the positive x-axis points east
    and the positive y-axis points north. (Note that this isn’t the same as the default
    convention used by the JavaFX canvas.) Taking this into account, drawing an arc
    counterclockwise is considered the positive direction, and this is how the starting
    angle and arc length are specified. For example, we’ve specified the start angle
    as –90 degress and the arc length as –90 degrees (both in the clockwise direction
    relative to the positive x-axis). Alternatively, we could have specified the start
    angle as +180 degress and the arc angle as +90 degrees (both counterclockwise)
    to produce the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the Sequence
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We have one more function that prints the Fibonacci sequence, as well as the
    ratios between successive terms in the sequence, to illustrate how these values
    converge on the golden ratio.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The function first prints a header message and the length of the generated Fibonacci
    sequence. Next, it prints the generated sequence itself using println() ❶. Finally,
    a for loop calculates and prints the ratios of adjacent numbers in the sequence,
    using format() to show the values with appropriate spacing and precision.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you run the code, the text portion of the output should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the ratios initially zigzag around the value of 1.61803398875 but
    quickly approach the golden ratio once we reach the 10th pair in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the app also displays a beautiful Fibonacci spiral drawn on the canvas
    using JavaFX. It should look exactly like [Figure 4-4](chapter4.xhtml#fig4-4)—that
    figure was generated with this very code!
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 14: Find the Shortest Distance Between Two Locations on Earth'
  prefs: []
  type: TYPE_NORMAL
- en: We use the Pythagorean theorem to calculate distances between points on the
    same plane. However, for points on Earth’s surface, this method isn’t accurate
    over long distances, because it doesn’t consider Earth’s curved shape. That’s
    where the *haversine formula* comes in. It calculates the shortest distance between
    two points on the surface of a sphere using the latitude and longitude coordinates
    of the points. In the case of Earth, the formula isn’t totally accurate, since
    Earth isn’t perfectly spherical, but it still offers a reasonable distance approximation
    for many practical applications, including in navigation, astronomy, and geography.
  prefs: []
  type: TYPE_NORMAL
- en: The haversine formula revolves around the concept of a *great circle*, the largest
    circle that can be drawn on a sphere. It’s formed by the intersection of the sphere’s
    surface with a plane that passes through the sphere’s center. The great circle
    divides the sphere into two equal halves, and its circumference matches the circumference
    of the sphere itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-5](chapter4.xhtml#fig4-5) showcases two prominent great circles:
    the equator and the prime meridian. The equator acts as a dividing line between
    the northern and southern hemispheres, while the prime meridian (which passes
    through Greenwich, England) separates the Eastern and Western Hemispheres on Earth’s
    surface. These two great circles serve as references for latitude and longitude,
    which together define the locations of points on Earth’s surface.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: The latitude and longitude of a point P'
  prefs: []
  type: TYPE_NORMAL
- en: '*Latitude* measures the distance north or south of the equator. It’s expressed
    in degrees, with the equator being 0 degrees latitude, the North Pole 90 degrees
    north (90°N), and the South Pole 90 degrees south (90°S). In [Figure 4-5](chapter4.xhtml#fig4-5),
    the latitude of point P would be denoted as *φ*°N, as it lies *φ* degrees north
    of the equator along a great circle that intersects with P and the North Pole.
    *Longitude* measures the distance east or west of the prime meridian. The prime
    meridian itself has a longitude of 0 degrees, and longitude values range from
    –180 degrees west of the prime meridian to 180 degrees east of the prime meridian.
    In the case of point P, its longitude would be *λ*°E, indicating its great circle
    is *λ* degrees east of the prime meridian.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You may be used to seeing all latitude and longitude values expressed as positive
    numbers, but for the haversine formula to work, southern latitudes and western
    longitudes must be negative. Our program will automatically convert coordinates
    that don’t follow this convention.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given any two points on the surface of a sphere, you can draw a great circle
    that intersects with both points, and that great circle will define the shortest
    path between the two points. If you know the angle *θ* (in radians) between the
    points—that is, the angle formed at the sphere’s center by the arc connecting
    the points—and if you know the radius *r* of the sphere, you can calculate the
    distance along the sphere’s surface between the two points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (4.5) ![](../images/eq4-5.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Earth, we know the radius *R* to be about 6,371.009 kilometers,
    but how do we know the angle between two points on Earth’s surface? This is where
    the haversine formula comes in. It uses the points’ latitude and longitude coordinates,
    and a bit of trigonometry, to determine that angle, which in turn lets us calculate
    the distance between the points. The formula involves a little-known trigonometric
    function called the haversine function. The haversine of an angle *θ* is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (4.6) ![](../images/eq4-6.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'The haversine formula calculates *a*, the haversine of the angle between two
    points on Earth’s surface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*  a* = hav(*φ*[2] – *φ*[1]) + cos(*φ*[1]) cos(*φ*[2]) hav(*λ*[2] – *λ*[1])'
  prefs: []
  type: TYPE_NORMAL
- en: Here (*φ*[1], *λ*[1]) and (*φ*[2], *λ*[2]) are the latitude and longitude coordinates
    of the two points, expressed in radians. To convert from degrees to radians, simply
    multiply by π and divide by 180.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the haversine of the angle between the two points, but not the
    angle itself. For that, we can use the *a* we just calculated and the definition
    of haversine (Equation 4.6) to solve for the arc angle *c*:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ ![](../images/pg150-1.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the angle *c*, we have everything we need to calculate the
    distance between the points using Equation 4.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '*  d* = *Rc*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one catch, however: *d* works out to a real number only when 0 ≤ *a*
    ≤ 1, but sometimes *a* can be pushed outside this range due to a floating-point
    error. To avoid this, we should instead express *c* as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ ![](../images/pg150-2.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: This constrains the value of *a* to a range from 0 to 1, preventing any unrealistic
    results.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We now have everything we need to write a Kotlin program that calculates the
    shortest distance between two locations on Earth. For this example, I’ve hardcoded
    the locations of two well-known landmarks, Big Ben in London and the Statue of
    Liberty in New York, but you can use any locations you want. The code consists
    of four main segments: an import block and global declarations, the main() function,
    the printLatLong() function, and the haversineDistance() function. I’ll discuss
    them in the same order.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the haversine formula needs to use quite a few math functions, we begin
    by importing those from the kotlin.math package. Next, we declare a data class
    Location with five properties: name (the name of the location), lat (the latitude),
    latDir (the direction of the latitude), lon (the longitude), and lonDir (the direction
    of the longitude). We then create two Location objects, L1 and L2, representing
    Big Ben and the Statue of Liberty. We store them together in a list called locations
    so we can efficiently iterate over the locations.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I’ve provided the latitude and longitude values as positive numbers
    in degrees, regardless of which direction they’re in. I’m relying on the latDir
    and lonDir properties to communicate that extra information. The convention is
    N for north, S for south, E for east, and W for west. In cases where the latitude
    or longitude of a location is exactly 0, the corresponding direction can be set
    to EQ (equator) or PM (prime meridian), although this won’t impact the final result.
    Later, in the haversineDistance() function, we ensure that when the lat or lon
    direction is S or W, respectively, the corresponding values are always negative
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The main() function prints the provided latitude and longitude values before
    and after adjustments (if any) using the printLatLong() function, makes a single
    call to the haversineDistance() function, and prints the result.
  prefs: []
  type: TYPE_NORMAL
- en: The printLatLong() function takes one argument, category, which is of type String.
    The category parameter is passed to a when block to determine which of two messages
    to print, indicating whether the coordinates have been adjusted for their direction
    properties. The locations themselves are then printed one at a time using the
    forEach() method of the locationsToPrint list. We could have used a regular for
    loop here, but some Kotlin enthusiasts consider forEach() to be more idiomatic.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the haversineDistance() function calculates the shortest distance between
    the two locations on a spherical surface. It first iterates over the locations
    and negates the latitudes and longitudes if needed ❶, then converts all the latitude
    and longitude values from degrees to radians. Next, it steps through the equations
    we discussed on [page 150](#pg_150), using the coordinates to calculate *a* ❷,
    using *a* (constrained to between 0 and 1) to calculate the angle *c* ❸, and using
    *c* to calculate and return the haversine distance *d* between the points ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you run the program for the set location and parameter values, the output
    should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned on [page 148](#pg_148), the haversine calculation assumes that
    Earth is a perfect sphere, which is not true. In fact, Earth is an oblate spheroid,
    slightly flattened at the poles and bulging at the equator. To get around this
    wrinkle, you could use Vincenty’s formula, which takes into account the oblate
    spheroidal shape of Earth by considering Earth’s equatorial and polar diameters.
    Which formula to use really depends on the nature of the problem, as both methods
    have their strengths and their weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 15: Do Encryption with the Hill Cipher'
  prefs: []
  type: TYPE_NORMAL
- en: In today’s interconnected world, we constantly share sensitive data like personal
    information, financial details, and confidential messages. What’s to stop unauthorized
    parties from accessing that information? The answer is *encryption*, a set of
    techniques for scrambling our data into gibberish that can be deciphered only
    with the right key. Encryption protects our privacy, safeguards against hackers
    and cybercriminals, and secures our online transactions.
  prefs: []
  type: TYPE_NORMAL
- en: There are a variety of encryption algorithms in use today. In this project,
    we’ll focus on a particular algorithm called the Hill cipher, developed by American
    mathematician Lester S. Hill in 1929\. According to this method, the *plaintext*
    (text in plain English or any other language) is divided into blocks of fixed
    size and represented as vectors. These vectors are then multiplied by a square
    matrix called the *encryption key*, modulo a specified number, to obtain the *ciphertext*
    (encrypted text). For decryption, the ciphertext vectors are multiplied by the
    inverse of the encryption key matrix, modulo the same specified number.
  prefs: []
  type: TYPE_NORMAL
- en: Hill’s encryption method can be vulnerable to attacks if we don’t choose the
    encryption key matrix carefully. While it’s no longer employed as the sole encryption
    mechanism, it can still be incorporated into more sophisticated methods and remains
    a valuable concept to grasp. Plus, exploring Hill’s method provides an excellent
    opportunity to apply and enhance our coding skills in the crucial field of cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Hill cipher revolves around concepts from linear algebra and modulo operations.
    I don’t expect you to have an in-depth knowledge of these areas of mathematics,
    but you may wish to review these topics to gain a better insight into how the
    Hill cipher actually works, as well as its strengths and weaknesses. Here are
    brief definitions of the key terms that we’ll use in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector**'
  prefs: []
  type: TYPE_NORMAL
- en: A one-dimensional sequence of values. For example, [1, 3, 5] is a row vector
    with three elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Matrix**'
  prefs: []
  type: TYPE_NORMAL
- en: A two-dimensional collection of values, arranged in rows and columns. For example,
    a 3×3 matrix has three rows and three columns, and a total of nine elements (numbers)
    that can be real or complex.
  prefs: []
  type: TYPE_NORMAL
- en: '**Determinant**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A single value calculated using the elements of a matrix. The matrix must be
    square, meaning it has the same number of rows and columns. Say we have the following
    square matrix A:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ ![](../images/pg155-1.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Its determinant, denoted by det(A), det A, or |A|, can be calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: det(*A*) = *aei* + *bfg* + *cdh* – *ceg* – *bdi* – *afh*
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity matrix**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A square matrix, often denoted as I, where all the elements along a diagonal
    from the top left to the bottom right have a value of 1 and all other elements
    have a value of 0\. A 3×3 identity matrix looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ ![](../images/pg155-2.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: '**Inverse matrix**'
  prefs: []
  type: TYPE_NORMAL
- en: For a given matrix A, its inverse A^(–1) is another matrix such that multiplying
    the two matrices results in the identity matrix (that is, AA^(–1) = I). A matrix
    must be square to have an inverse, although not all square matrices have one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modulo**'
  prefs: []
  type: TYPE_NORMAL
- en: An operation represented by the symbol % that finds the remainder when one number
    is divided by another. For example, 5 % 2 is 1\. Modulo (mod for short) is a multipurpose
    operator used in various applications, such as determining divisibility, cycling
    through a range of values, and handling periodic patterns. Hill’s algorithm relies
    on the modulo operation to keep the encrypted and decrypted texts within the same
    alphabet as the plaintext. Thus, the size of the alphabet serves as the base or
    modulus (the number after the % operator) for these operations, guaranteeing valid
    ciphertext and plaintext representations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modular multiplicative inverse (MMI)**'
  prefs: []
  type: TYPE_NORMAL
- en: For a given integer a and a modulus m, the MMI is positive integer x such that
    ax % m = 1\. The value of x must be less than the modulus. For example, the MMI
    for 5 modulo 11 is 9, because (5 * 9) % 11 = 1, and 9 is less than 11.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these definitions, let’s now dive into the core encryption and decryption
    steps employed by the Hill cipher and highlight some of our Kotlin implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For Encryption
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 1.  Define the alphabet. Choose which letters are to be used for writing plain
    and encrypted messages. For messages written in English, the alphabet size should
    be at least 26 to include all lowercase letters. We’ll also include a period,
    a space, and a question mark, giving us an alphabet of 29 characters total. The
    size of the alphabet serves as the modulus.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Choose a block size. During encryption and decryption, the message is divided
    into small blocks of characters, each of the same length. In this exercise, we’ll
    have three characters per block.
  prefs: []
  type: TYPE_NORMAL
- en: '3.  Generate the encryption key matrix. For the purposes of this project, I’ve
    generated the encryption key matrix for you, but if you’re curious, it must adhere
    to these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  The matrix must be square and have the same dimension as the block size
    chosen in step 2\. In this case, with a block size of 3, we need a 3×3 matrix.
  prefs: []
  type: TYPE_NORMAL
- en: b.  The determinant of the matrix can’t be 0.
  prefs: []
  type: TYPE_NORMAL
- en: c.  The determinant must not share a factor, other than 1, with the modulus
    from step 1.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Prepare the plaintext. Divide the plaintext message into blocks based on
    the chosen block size. If the last block is smaller than the fixed size, pad it
    with filler characters. We’ll use spaces for padding to ensure that the message
    remains the same after decryption, with no extra visible characters.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Create vectors from the plaintext. Each block of the plaintext must be converted
    into a numerical vector with the same length as the block size. To assign numerical
    values to characters, we’ll save the alphabet in a single String object. We can
    then map each character in the plaintext to that character’s corresponding index
    in the string. For example, a will be mapped to 0, b to 1, and so on. This way,
    the block cab will become (2, 0, 1), a vector of size 3.
  prefs: []
  type: TYPE_NORMAL
- en: '6.  Encrypt the message. For each block, carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Multiply the block’s plaintext vector by the key matrix, modulo 29, to generate
    a ciphertext vector.
  prefs: []
  type: TYPE_NORMAL
- en: b.  Convert the numerical values in the ciphertext vector back to text characters
    using the reverse mapping scheme.
  prefs: []
  type: TYPE_NORMAL
- en: c.  Add the ciphered characters to a mutable list of characters, which will
    become the encrypted message (ciphertext) once all the blocks have been processed.
  prefs: []
  type: TYPE_NORMAL
- en: For Decryption
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 1.  Generate the decryption key matrix. To decipher the encrypted text, we must
    first create the inverse of the encryption key matrix modulo the specified number.
    This process involves multiple linear algebraic steps and modulo operations; for
    simplicity, I’ve provided the inverse matrix. If you want to work with a different
    set of key and inverse matrices, you can look up the online tools that will generate
    those for you.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Prepare the ciphertext. Divide the ciphertext into blocks of the specified
    size used during encryption (3 for this project). This time, no padding is needed,
    since the padding was already done during encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Create vectors from the ciphertext. Use the same character-numbering scheme
    to convert the ciphertext blocks into ciphertext vectors of size 3.
  prefs: []
  type: TYPE_NORMAL
- en: '4.  Decrypt the message. For each block, carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Multiply the ciphertext vector by the decryption key matrix, modulo 29,
    to generate a deciphered vector.
  prefs: []
  type: TYPE_NORMAL
- en: b.  Convert the numerical values in the deciphered vector back to text characters
    using the reverse mapping scheme.
  prefs: []
  type: TYPE_NORMAL
- en: c.  Add the deciphered characters to a mutable list of characters, which will
    become the decrypted message (plaintext) once all the blocks have been processed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, keep in mind that it’s customary to pick an encryption key matrix made
    up of only integers, preferably falling between 0 and the modulus.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re ready to implement the Kotlin code for Hill’s encryption and decryption
    method. The code is organized in a top-down manner, starting with global declarations,
    continuing with the main() function, and ending with a series of short helper
    functions. We’ll review everything in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and Data Structures
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We begin by declaring the variables and data structures needed to implement
    Hill’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we create the matrices for encryption and decryption (key and keyInv).
    For this project, we’ll accept these as given, but you can use online tools to
    create a different encryption key matrix that meets the required conditions and
    calculate the corresponding inverse matrix. The size of these square matrices
    is captured in the parameter dim, which is later used as the block size for processing
    messages. We also define a string called alphabet that stores all the valid letters
    that can be used in the plaintext and ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduce a data class called Block, which we’ll use to store the text
    blocks generated while processing the message. These blocks will be stored as
    a mutable list named blocks. We also create a few other collections to temporarily
    hold and manipulate the vectors created during encryption and decryption operations,
    along with a mutable list named processedText to store the final list of characters.
    Since the encryption and decryption processes are very similar, we’ll be able
    to use these variables and collections during both processes to store the intermediate
    and final values.
  prefs: []
  type: TYPE_NORMAL
- en: The main() Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The main() function calls a series of helper functions to coordinate the overall
    encryption or decryption process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In main(), we first call the runValidation() function, which uses matrix multiplication
    (mod 29) to ensure that the encryption and decryption matrices are valid. We then
    prompt the user to choose which operation to carry out: encryption (enter 1) or
    decryption (enter 2). Based on the choice, we use a when block ❶ to implement
    the steps to encrypt or decrypt a message.'
  prefs: []
  type: TYPE_NORMAL
- en: For both choices, we start with the getText() function, which takes in the message
    to be encrypted or decrypted from the user as a text string and divides it into
    blocks. We then call encrypt() or decrypt(), depending on the choice made earlier.
    Finally, we display the result with help from the printProcessedText() function.
  prefs: []
  type: TYPE_NORMAL
- en: The Helper Functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are several helper functions called from within the main() function. We’ll
    turn to those next, starting with the functions that help validate the matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The runValidation() function displays the size of the key matrices. It then
    calls multiplyMatricesMod29() to do the validation check and shows the results
    with displayProduct(). The matrices are considered valid if one is the inverse
    of the other, modulo 29\. If this is the case, the product of the two matrices,
    modulo 29, should be an identity matrix where all elements are zeros, except for
    ones along the diagonal from the top left to the bottom right.
  prefs: []
  type: TYPE_NORMAL
- en: In multiplyMatricesMod29(), we test this out, using three nested for loops to
    multiply the encryption and decryption key matrices, taking modulo 29 of each
    resulting value before putting it in the product matrix ❶. See the “Multiplying
    Two Matrices” box for details about the math behind this process.
  prefs: []
  type: TYPE_NORMAL
- en: The displayProduct() function neatly formats and prints the contents of the
    product matrix. As you’ll later see in the example output, the result should indeed
    be an identity matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the getText() function, which we call from main() at the start of the
    encryption or decryption process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The function uses readln() to take in the plaintext or ciphertext from the user.
    We convert all the characters to lowercase since we have only lowercase letters
    in our alphabet. We then check if the input string is divisible by 3 ❶ and pad
    it with spaces if not. Finally, we use a for loop with a step size of 3 to break
    the text into three-character blocks. Each one is stored in a Block object and
    added to the blocks mutable list.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the helper functions do the work of actually encrypting and
    decrypting the text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The encrypt() and decrypt() functions both iterate through the Block objects
    in the blocks list and call a series of helpers to process them. The first helper
    called is the getIndexBlock() function, which looks up each character’s index
    in the alphabet string, thereby converting each character to an integer. The values
    are stored in the indexVector array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call encryptIndexBlock() or decryptIndexBlock(), which converts the
    plaintext vector into a cipher (encrypted) vector or vice versa by multiplying
    the vector by the appropriate matrix (key or keyInv), modulo 29\. Multiplying
    a vector by a matrix is much like multiplying two matrices, but in this case,
    we need only two levels of for loops. The result goes in the processedVector array.
  prefs: []
  type: TYPE_NORMAL
- en: Our last encryption and decryption helper is the addToProcessedText() function,
    which takes each number from the processedVector array, looks up the corresponding
    character from the alphabet string, and adds that character to processedText,
    a mutable list. In the end, once all the vectors are processed, this list contains
    the final encrypted or decrypted text. Back in main(), we call the printProcessedText()
    function, which concatenates all the characters stored in the processedText list
    into a single string for easy printing.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s a sample run of the program in encryption mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'First, notice the validation check: the product of the two matrices is indeed
    an identity matrix, with ones running along the diagonal and zeros everywhere
    else. Then notice the final output, where the program has turned the readable
    plaintext into unreadable gibberish. The process also works in reverse: if you
    choose the decryption option (enter 2) and input the encrypted text, the program
    will instantly convert the ciphertext back to the original plaintext.'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the final result is displayed in all lowercase letters. I invite
    you to improve the printProcessedText() function so that the final result is capitalized
    as needed before printing. If you’re thorough, you’ll soon realize that implementing
    a complete set of capitalization rules isn’t as simple as it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 16: Simulate a One-Dimensional Random Walk'
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, the projects have all been *deterministic*, meaning
    there’s a unique solution for a given set of input parameters. If we were to run
    the code multiple times with the same input, the output would remain unchanged.
    In this project, we’ll explore a different kind of problem, one that’s *stochastic*
    in nature. In a stochastic problem, the output for a given set of inputs isn’t
    predetermined. We may be aware of various possible outcomes, or a range within
    which the output will fall, but the specific value generated by an individual
    instance of the experiment is determined purely by chance. To illustrate this
    concept, we’ll probe the idea of a random walk.
  prefs: []
  type: TYPE_NORMAL
- en: A *random walk* is a process made up of a series of *random steps*, actions
    with multiple possible outcomes. We know the probability of each potential outcome,
    but the actual outcome is determined randomly. For example, rolling a die is a
    type of random step. Assuming the die is fair, each of its six sides will have
    the same likelihood of landing face up (one-sixth, or approximately 16.67 percent).
    Therefore, when we actually roll the die, we can’t know for sure what number we’ll
    get. Our guesses will be correct only 16.67 percent of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Random walks can be described using a *mathematical space* with a certain number
    of dimensions, depending on the nature of the random step. Let’s say we’re considering
    the movement of a heavily inebriated person who has just come out of a pub. The
    street in front of the pub runs east–west. This person is totally disoriented
    and is taking random steps along the street in both directions. We can mathematically
    describe the distance the person travels over time as the sum of individual steps
    along the x-direction (the x-axis being the east–west line). We could record each
    step toward the east as +1 and a step in the opposite direction as −1 (assuming
    all steps cover the same distance). This is an example of a one-dimensional random
    walk—we need only the x-axis to describe it mathematically.
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose the person has been drinking in the middle of an open field and
    has started to wander randomly in different directions. The person’s steps can
    now have both an x-component (east or west) and a y-component (north or south).
    In this case, to measure the distance traveled from the center of the field, we’ll
    have to track the person’s movements in a two-dimensional space, which will make
    this a two-dimensional random walk problem.
  prefs: []
  type: TYPE_NORMAL
- en: A well-known example of a random walk is *Brownian motion*, named for Robert
    Brown, a 19th-century Scottish botanist. Using a microscope, Brown was observing
    grains of pollen immersed in water when he noticed that the grains were constantly
    moving in random directions. In fact, we can find similar movements whenever very
    small particles are injected in a fluid medium, such as dust or smoke particles
    in the air or the movement of particles in a colloidal suspension such as milk
    or paint. Brown’s observation was an important scientific discovery that remained
    unexplained for more than half a century until 1905, when Albert Einstein explained
    that Brownian motion was caused by the continuous bombardment of the pollen grains
    by the surrounding water molecules.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we’ll build and simulate a 1D random walk model in Kotlin.
    This will allow us to gain a deeper insight into how particles or objects move
    in one dimension through random steps. In particular, by repeating the simulation
    many times and plotting the results, we’ll be able to identify patterns and explore
    the statistical properties that underlie this dynamic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: A One-Dimensional Model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine a single particle moving randomly along a line in small steps. For simplicity’s
    sake, we’ll assume that the particle’s step size remains constant and that steps
    are made at steady time intervals (we do not need to use time as an explicit variable
    in our model). Physicists often call this scenario a *free diffusion* problem
    in one dimension. The process is schematically shown in [Figure 4-6](chapter4.xhtml#fig4-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: A random walk in one dimension, starting at x = 0'
  prefs: []
  type: TYPE_NORMAL
- en: The particle starts at location *x* = 0 and moves in discrete steps of length
    Δ*x* = ±1\. The direction of the particle’s movement is random, so its next position
    after 0 can be either 1 (with a displacement of +1) or 2 (with a displacement
    of −1). The probability *p* of choosing either direction is equal, so *p* = 0.5\.
    Notice that at any given location, the particle can change its direction, so it’s
    possible for the particle to take several random steps and end up back where it
    started.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question we’re interested in exploring is this: After making an arbitrary
    number of steps, *n*, how far on average will the particle have moved from its
    starting position? To answer this question, we’ll need to simulate many random
    walks—say, 500 walks of 1,000 steps each—and analyze the results. We can’t simply
    take the average of the cumulative distances traveled in the different simulations,
    however; the particle can drift in both the positive and negative x-directions,
    so the net-positive and net-negative distances would likely cancel each other
    out, giving us an average distance of roughly 0\. Instead, we’ll use the *root-mean-square
    (RMS) distance*, which is calculated in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Square all the distances from all the simulations after a given number of
    steps n. This converts any negative numbers to positive numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Add all the results from step 1 and divide by the number of simulations
    to find the mean (average) of the squared distances.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Take the square root of step 2’s result to arrive at the RMS distance.
  prefs: []
  type: TYPE_NORMAL
- en: Based on past research conducted on one-dimensional random walks, we know that
    the RMS distance exhibits a nonlinear relationship with the number of steps taken;
    in theory, the RMS distance after the *n*th step should equal the square root
    of *n*. To validate this notion, we’ll compute the RMS distance (the *simulated*
    RMS) and the square root of *n* (the *theoretical* RMS) and plot them both against
    the number of steps, *n*. Hopefully, the two plots will be similar. We’ll also
    plot the mean distance traveled at each time step, which should remain close to
    0.
  prefs: []
  type: TYPE_NORMAL
- en: In a separate graph, we’ll visualize the trajectories of the 500 random walks
    themselves. This should help illustrate the random nature of the outcomes and
    give further support to our theories about the cumulative and RMS distances traveled.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ll present the code segments for this project in a top-down sequence, starting
    with some general setup code. Since we want to visualize the random walks from
    different simulations and examine the relationship between the cumulative, mean,
    and RMS distances with the number of steps, we’ll use the JavaFX template that
    we developed and used in [Chapter 3](chapter3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code segment starts with the import block. Since this project will use the
    XY charting features of JavaFX instead of the canvas feature, the import block
    is somewhat different from what we needed for [Project 13](chapter4.xhtml#pre-13),
    and it includes a few extra lines of code to import the Background, BackgroundFill,
    CornerRadii, and Insets features, which we’ll use to set the chart background
    to white.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare a simple data class State ❶ for holding individual data points
    during the simulation. Its step property represents the number of steps taken
    since the beginning of the random walk, and dist is the cumulative distance traveled
    after that many steps. We then declare two global parameters: numStep, to specify
    the maximum number of steps per simulation, and numSim, to set the maximum number
    of simulations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll accumulate data in a number of lists ❷, each of size numStep and type
    State, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: xList Stores the cumulative distance traveled after each step for a particular
    simulation
  prefs: []
  type: TYPE_NORMAL
- en: avgList Stores the arithmetic average (mean) of the cumulative distances traveled
    across all simulations after each step
  prefs: []
  type: TYPE_NORMAL
- en: rmsList Stores the RMS distance calculated across all simulations after each
    step
  prefs: []
  type: TYPE_NORMAL
- en: expList Stores the theoretical (exponential) RMS distance after each step
  prefs: []
  type: TYPE_NORMAL
- en: All these lists are initialized to (0.0, 0.0), meaning all simulations start
    at step number 0 and position 0\. In addition to these lists, we also create two
    mutable lists, states1 and states2, which we’ll use for charting purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the RandomWalk1D application class, we use a VBox container ❸ to hold
    the chart objects, as we’ll generate two sets of charts that will be placed vertically
    inside the VBox. Notice the additional lines of code for setting the background
    of the container to white programmatically ❹, without using the cascading style
    sheets needed for more extensive customizations. We’ve also introduced the ScrollPane
    feature ❺, which will allow us to scroll the chart window to view the top or the
    bottom chart, as needed. We can also enlarge the window to make both charts visible
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting up the graphics window, we call three custom functions that will
    run the simulation and help visualize the results. The first call is to the randomWalk1d()
    function, which simulates numSim one-dimensional random walks over numStep steps.
    Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The function body starts by creating three local arrays of type DoubleArray.
    The first, s, is a two-dimensional array that stores the cumulative distance traveled
    at each step of each simulation ❶. The others are one-dimensional arrays, sumX
    and sumX2, to save the running sums of the cumulative distances at each step and
    the sums of squared distances at each step, respectively. We’ll use these values
    to get the mean and RMS distances.
  prefs: []
  type: TYPE_NORMAL
- en: The random walks are implemented inside a nested for loop. The outer loop controls
    the number of simulations, and the inner loop makes the particle take numStep
    steps in succession. During each step, a local variable draw is randomly set to
    either 0 or 1 with equal likelihood ❷. Based on the outcome, step (referred to
    as Δ*x* in [Figure 4-6](chapter4.xhtml#fig4-6)) is set to -1 or 1, which is then
    added to the cumulative distance traveled up to the previous step of the simulation
    ❸. These cumulative distances are used to create the elements of xList, which
    is then copied and passed on to states1 once per simulation ❹. Notice how we’re
    reusing the memory allocated for xList during each simulation by overwriting the
    values of its elements. In the end, states1 has all the data we need to visualize
    the random walks themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’re done with the random walks, we use the resulting lists, sumX and
    sumX2, to create the avgList and rmsList inside another for loop by dividing the
    elements of sumX and sumX2 by numSim. Here sumX[j] is the sum of all the elements
    in column j of the s[i][j] matrix, where i represents the simulation number and
    j represents the number of steps taken so far. (Likewise, sumX2[j] is the same,
    squared.) Finally, avgList and rmsList are passed on as elements of states2 ❺,
    which we defined earlier as a list of lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function call inside the application class is calcRMS1d(). It generates
    the theoretical RMS distance at each step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We know from the theoretical analysis of the one-dimensional random walk problem
    that the RMS distance is a nonlinear function of the number of steps *n*, which
    can be expressed as *x*n = √*n*, where *x*n is the RMS distance for the *n*th
    step (*n* is equivalent to looping variable j in the code). We use this relationship
    in the calcRMS1d() function to calculate the theoretical RMS distances and update
    expList ❶. We’ll use this list to create a side-by-side plot of the theoretical
    and simulated RMS distances to see how closely they follow each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last two lines of the application class, we make two successive calls
    to the createRWChart1() and createRWChart2() functions, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Other than the chart labels, the only difference between these two functions
    is that the first one uses states1 and the second one uses states2 to generate
    the respective charts. Both of these functions call the singleXYChart() function
    (which we discussed and used in [Chapter 3](chapter3.xhtml)) to draw the line
    charts and stack them inside a scroll pane.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you run the full code on your device, you should see a single scrollable
    window pop up with two separate charts. Let’s first consider the visualization
    of the random walks themselves, shown in [Figure 4-7](chapter4.xhtml#fig4-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-7: The random walk paths from 500 simulations of 1,000 steps'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chart shows all 500 random paths generated by the randomWalk1d() function
    (one per simulation, based on our global numSim parameter). These paths show a
    number of key features of one-dimensional random walks:'
  prefs: []
  type: TYPE_NORMAL
- en: Each random path is unique, evident from the tangled web of lines moving across
    the chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most random walks tend to stay close to their starting position, even after
    many steps. We can see this in the darker band along the x-axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The paths are equally dispersed on both sides of x = 0, as expected. You could
    confirm this by creating histograms of the cumulative distances traveled at different
    numbers of steps. (I’ll leave this for you to try out as an exercise.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any given number of steps, if we add the cumulative distances from all simulations,
    the sum will be close to zero because positive and negative distances will cancel
    each other. For the same reason, the arithmetic mean will also be close to zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RMS distance increases with the number of steps, as confirmed by the gradual
    widening of the band that envelops all random paths. The RMS distance is therefore
    a better measure for the average distance traveled than the arithmetic mean, as
    we don’t care about the direction of the movement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these points collectively provide the answer we were seeking at the start
    of this project. A particle moving randomly in one dimension will likely trace
    a path that will initially stay close to its starting position. However, if we
    follow the particle for a long time, it may gradually move farther away. Again,
    we can’t predict exactly how far a particular particle will move, but if we measure
    the RMS distance from many different particles, we’ll see that the RMS distance
    increases with the number of steps. Our other chart, shown in [Figure 4-8](chapter4.xhtml#fig4-8),
    helps us explore this last point further.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-8: The mean and RMS distances traveled for a given number of steps'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-8](chapter4.xhtml#fig4-8) charts three lines. First, we have the
    line labeled “Simulated mean,” generated from the data in avgList. This line stays
    very close to zero, confirming one of the key points made based on [Figure 4-7](chapter4.xhtml#fig4-7):
    that the arithmetic average or mean for any number of steps will be zero if we
    have a sufficiently large number of observations. Second, we have the “Simulated
    RMS” line, generated from the data in rmsList, which clearly shows the RMS distance
    increasing (although at a decreasing rate) with the number of steps. Third, the
    smooth “Theoretical RMS” line represents the theoretical RMS distances from expList,
    calculated by simply taking the square root of the number of steps. Again, we
    can visually confirm that the simulated RMS values are very close to the theoretically
    expected RMS values.'
  prefs: []
  type: TYPE_NORMAL
- en: The minor discrepancies we see between the simulated and theoretical RMS values
    are to be expected. The simulated RMS values will approach the theoretical values
    as the number of simulations approaches infinity. I invite you to run the code
    again, this time setting numSim to 5000. Make sure that you comment out the call
    to the createRWChart1() function before doing that. The default implementation
    of JavaFX is memory and computation intensive, and trying to plot 5,000 lines,
    each with 1,000 data points, can take a while depending on your processor and
    memory configuration. However, if you do this experiment as suggested, you’ll
    see that with the added random walks, the simulated and theoretical RMS lines
    become virtually the same. If you go further by setting numSim to 50000, you’ll
    see only one line.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we used Kotlin code and custom algorithms to solve math-related
    problems. The problems weren’t just theoretical; they also had practical applications
    in fields like mathematics, geodesy, navigation, and cryptography. Throughout
    our journey, we employed various mathematical concepts, operations, and tools,
    including basic arithmetic, math and trigonometric functions, the Pythagorean
    theorem, the Fibonacci sequence, the haversine formula, modulo operations, and
    linear algebra. We also probed the realm of stochastic processes, exploring the
    generation and utilization of random numbers to simulate random phenomena.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, we used many core features of Kotlin, such as variables and collections,
    data classes, and conditional and iterative structures like if, when, for, and
    while. We also discovered the convenience of functions and lambdas, along with
    the rich set of mathematical and graphics library functions at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: '### Resources'
  prefs: []
  type: TYPE_NORMAL
- en: Ayars, Eric. “Stochastic Methods.” In *Computational Physics with Python*, 131–139\.
    August 18, 2013\. Accessed June 15, 2024\. *[https://belglas.files.wordpress.com/2018/03/cpwp.pdf](https://belglas.files.wordpress.com/2018/03/cpwp.pdf)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dutka, Jacques. “Eratosthenes’ Measurement of the Earth Reconsidered.” *Archive
    for History of Exact Sciences* 46, no. 1 (1993): 55–66\. Accessed June 15, 2024\.
    *[http://<wbr>www<wbr>.jstor<wbr>.org<wbr>/stable<wbr>/41134135](http://www.jstor.org/stable/41134135)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Eisenberg, Murray. “Hill Ciphers and Modular Linear Algebra.” November 3, 1999\.
    Accessed June 15, 2024\. *[https://apprendre-en-ligne.net/crypto/hill/Hillciph.pdf](https://apprendre-en-ligne.net/crypto/hill/Hillciph.pdf)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Harder, Douglas. “Project H.1: Sieve of Eratosthenes.” University of Waterloo.
    Accessed June 15, 2024\. *[https://ece.uwaterloo.ca/~ece150/Programming_challenges/H/1/](https://ece.uwaterloo.ca/~ece150/Programming_challenges/H/1/).*'
  prefs: []
  type: TYPE_NORMAL
- en: Kereki, Federico. “A Modern Look at Square Roots in the Babylonian Way.” *Cantor’s
    Paradise*. December 7, 2020\. Accessed June 15, 2024\. *[https://medium.com/cantors-paradise/a-modern-look-at-square-roots-in-the-babylonian-way-ccd48a5e8716](https://medium.com/cantors-paradise/a-modern-look-at-square-roots-in-the-babylonian-way-ccd48a5e8716)*.
  prefs: []
  type: TYPE_NORMAL
- en: “Pythagorean Triples.” Prime Glossary. Accessed June 15, 2024\. *[https://t5k.org/glossary/page.php?sort=PrmPythagTriples](https://t5k.org/glossary/page.php?sort=PrmPythagTriples)*.
  prefs: []
  type: TYPE_NORMAL
- en: Reich, Dan. “The Fibonacci Sequence, Spirals and the Golden Mean.” Department
    of Mathematics, Temple University. Accessed June 15, 2024\. *[https://math.temple.edu/~reich/Fib/fibo.xhtml](https://math.temple.edu/~reich/Fib/fibo.xhtml)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Van Brummelen, Glen. *Heavenly Mathematics: The Forgotten Art of Spherical
    Trigonometry*. Princeton, NJ: Princeton University Press, 2013.'
  prefs: []
  type: TYPE_NORMAL
