- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 4 SOLVING MATHEMATICAL PROBLEMS WITH CODE
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 用代码解决数学问题
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/icon.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/icon.jpg)'
- en: After our thorough overview of the fundamentals of the Kotlin programming language
    and the JavaFX graphics tools adapted for use in Kotlin, we’re now prepared to
    tackle a series of math problems in the form of mini projects. The projects will
    grow in complexity over the chapter, but they require only high school math skills.
    Our journey will take us from the ancient civilizations of Babylon, Greece, and
    Egypt to the modern-day world of cryptography.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们全面了解了Kotlin编程语言的基础知识以及为Kotlin适配的JavaFX图形工具后，我们现在准备好解决一系列数学问题，以迷你项目的形式展开。这些项目将在本章中逐渐增加复杂性，但只需要高中数学知识。我们的旅程将带我们穿越巴比伦、希腊和埃及的古代文明，直至现代的密码学世界。
- en: The main goal of these projects is to enhance your Kotlin programming skills.
    We’ll discuss the context and mathematics behind each problem in detail, but the
    heart of each project will be developing an appropriate algorithm or problem-solving
    strategy and then implementing it in well-organized code. In doing so, you’ll
    gain a deeper understanding of both programming and math, preparing you to solve
    the more sophisticated problems introduced later in this book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目的主要目标是提升你的Kotlin编程技能。我们将详细讨论每个问题的背景和数学原理，但每个项目的核心将是开发合适的算法或问题解决策略，并将其实现为结构清晰的代码。通过这样做，你将对编程和数学有更深的理解，为后面更复杂的问题解决打下基础。
- en: 'Project 9: Find the Square Root with the Babylonian Algorithm'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 9：使用巴比伦算法求平方根
- en: We have several methods of finding the square root of a number. In this project,
    I’ll focus on the Babylonian square root algorithm, one of the most widely used
    methods today.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以求一个数的平方根。在这个项目中，我将专注于巴比伦平方根算法，它是今天最广泛使用的方法之一。
- en: The Babylonian square root algorithm dates back to around 1800 BCE. It’s believed
    the Babylonians used it for practical purposes, such as land surveying. The algorithm
    was later refined by the Greeks, who used it to calculate square roots to a high
    degree of accuracy. The Greek mathematician Heron of Alexandria described the
    algorithm in his work *Metrica*, written in the first century CE.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 巴比伦平方根算法可以追溯到公元前1800年左右。据信，巴比伦人出于实际目的，如土地测量，使用了该算法。这个算法后来被希腊人改进，希腊人使用它来精确地计算平方根。公元一世纪，希腊数学家亚历山大赫伦在他的著作《度量法》中描述了这个算法。
- en: Despite its ancient origins, the Babylonian square root algorithm remains a
    valuable tool for understanding the history of mathematics and the development
    of numerical methods. The algorithm’s enduring usefulness is a testament to the
    ingenuity of ancient mathematicians and the power of mathematical techniques.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管源自古代，巴比伦的平方根算法仍然是理解数学历史和数值方法发展的宝贵工具。该算法持久的实用性证明了古代数学家的聪明才智以及数学技术的强大力量。
- en: 'We can use the Babylonian algorithm to approximate the square root of a positive
    number in a few simple and iterative steps. The algorithm starts with an initial
    guess and then refines that guess until it’s close enough to the actual square
    root. Here’s how the algorithm works:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用巴比伦算法通过几个简单且迭代的步骤来逼近正数的平方根。该算法从初始猜测开始，然后不断精化猜测，直到它足够接近实际的平方根。以下是该算法的工作原理：
- en: 1.  Start with an initial estimate, guess, for the square root of a positive
    number, N. This is customarily set to N / 2.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  从一个初步估算值 guess 开始，作为正数 N 的平方根。通常情况下，guess 设为 N / 2。
- en: 2.  Check to see if the absolute value of (guess * guess - N) is less than the
    tolerance value. If yes, then terminate the loop and return the estimated square
    root.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  检查(guess * guess - N)的绝对值是否小于容差值。如果是，则终止循环并返回估算的平方根。
- en: 3.  Otherwise, update the guess using the formula guess = (guess + N / guess)
    / 2.0.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  否则，使用公式 guess = (guess + N / guess) / 2.0 更新猜测值。
- en: 4.  Repeat steps 2 and 3 until the stopping condition is met.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  重复步骤 2 和 3，直到满足停止条件。
- en: '### The Code'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '### 代码'
- en: The Babylonian algorithm is simple enough that we can write a concise code segment
    to find a square root. However, it’s a good practice to create a separate function
    for a process like this and then call that function from main(). This makes the
    code more reusable and easier to read.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 巴比伦算法足够简单，我们可以编写一个简洁的代码段来求平方根。然而，将这样的过程封装成一个单独的函数，并在`main()`中调用它是一个很好的实践。这使得代码更加可重用，且更易于阅读。
- en: 'Here’s an example Kotlin function for calculating the square root of a positive
    number using the Babylonian algorithm:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例Kotlin函数，用于使用巴比伦算法计算正数的平方根：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This babylonianSquareRoot() function takes a positive double-precision number
    num as its single argument. It sets the tolerance value TOL to 0.000001, initializes
    a variable iter to 1 to track the number of iterations, and makes a starting guess
    of num / 2.0. The function then follows the Babylonian algorithm I described,
    using a while loop to refine the value of guess until the result is within the
    tolerance. To help visualize the convergence process, the intermediate values
    of iter and guess are printed at each iteration.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个babylonianSquareRoot()函数接受一个正的双精度浮点数num作为唯一参数。它将容差值TOL设置为0.000001，初始化变量iter为1，以跟踪迭代次数，并设定初始猜测为num
    / 2.0。接着，函数按照我描述的巴比伦算法，通过while循环来优化猜测值，直到结果在容差范围内。为了帮助可视化收敛过程，每次迭代时都会打印出iter和guess的中间值。
- en: 'To use this function, call it from the main() function and provide the value
    of the number you want to find the square root of, like so:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个函数，从main()函数中调用它，并提供你想要计算平方根的数字值，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, the user is asked to enter the value of a positive number, which
    is read as a string and converted into a number of type Double before its square
    root is estimated. We’re assuming that the user will enter a valid number, which
    is greater than or equal to 1\. If the user enters characters that cannot be converted
    into a number of type Double, the program is terminated with an error message.
    Also, if the user enters a valid negative number, the algorithm will not converge
    to a real solution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用户被要求输入一个正数的值，输入的值会作为字符串读取，并转换成Double类型的数字，然后进行平方根的估算。我们假设用户会输入一个有效数字，且大于或等于1。如果用户输入不能转换成Double类型的字符，程序将终止并显示错误信息。另外，如果用户输入一个有效的负数，算法将无法收敛到一个实数解。
- en: 'In [Chapter 1](chapter1.xhtml), you learned how to handle such errors or exceptions.
    Feel free to experiment with this code and to make it error-proof by using a try...catch
    block.  #### The Result'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](chapter1.xhtml)中，你学习了如何处理此类错误或异常。可以随意尝试此代码，并通过使用try...catch块使其更加健壮。####
    结果
- en: 'Without further ado, let’s try running the algorithm! If N is set to 25, the
    code should output the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们试试运行这个算法！如果N设置为25，代码应该输出以下内容：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Of course, the exact value of the square root of 25 is 5\. The Babylonian algorithm,
    like any other numerical algorithm, provides only an approximation. The accuracy
    of this approximation is determined by the value of tolerance (TOL), which can
    be adjusted to make the approximation more or less precise.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，25的平方根的确切值是5。像其他任何数值算法一样，巴比伦算法仅提供一个近似值。这个近似值的准确性由容差值（TOL）决定，可以调整容差值使近似值更加精确或不那么精确。
- en: Keep in mind that a more accurate square root approximation will take longer
    to compute since the algorithm needs to go through more iterations. This sort
    of trade-off between accuracy and computational time is common.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，更精确的平方根近似值将需要更长的计算时间，因为算法需要更多的迭代。这种准确性与计算时间之间的权衡是常见的。
- en: 'Project 10: Create Pythagorean Triples with Euclid’s Formula'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 10：使用欧几里得公式创建毕达哥拉斯三元组
- en: Pythagoras was a Greek philosopher and mathematician who lived in the sixth
    century BCE. He believed in the idea of a harmonious universe and saw numbers,
    mathematics, and geometry as key elements in revealing the universe’s mysteries.
    He’s best known for the Pythagorean theorem, which states that in a right-angled
    triangle, the square of the length of the hypotenuse is equal to the sum of the
    squares of the other two sides (see [Figure 4-1](chapter4.xhtml#fig4-1)). Perhaps
    you’ve seen this theorem summarized as *a*² + *b*² = *c*².
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 毕达哥拉斯是公元前六世纪的希腊哲学家和数学家。他相信宇宙和谐的理念，并认为数字、数学和几何学是揭示宇宙奥秘的关键元素。他最为人知的是毕达哥拉斯定理，该定理指出，在直角三角形中，斜边的平方等于另外两边平方的和（见[图4-1](chapter4.xhtml#fig4-1)）。或许你曾见过将这个定理总结为
    *a*² + *b*² = *c*²。
- en: '*Pythagorean triples* are sets of three positive integers (*a*, *b*, *c*) that
    satisfy the Pythagorean theorem. A familiar example is (3, 4, 5): 3² + 4² equals
    9 + 16, which equals 25, or 5². Pythagorean triples are used in many areas of
    mathematics, science, and engineering, including geometry, number theory, cryptography,
    physics, and computer graphics. Throughout history, mathematicians have come up
    with different ways of generating Pythagorean triples. In this project, we’ll
    check out one of the earliest methods, Euclid’s formula, and use it to create
    Pythagorean triples. Here are the steps involved:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*毕达哥拉斯三元组*是满足毕达哥拉斯定理的三组正整数（*a*，*b*，*c*）。一个常见的例子是（3，4，5）：3² + 4² 等于 9 + 16，结果为25，或5²。毕达哥拉斯三元组广泛应用于数学、科学和工程的多个领域，包括几何学、数论、密码学、物理学和计算机图形学。在历史上，数学家们提出了不同的生成毕达哥拉斯三元组的方法。在这个项目中，我们将探讨最早的生成方法之一——欧几里得公式，并使用它来创建毕达哥拉斯三元组。以下是相关步骤：'
- en: 1.  Choose an arbitrary positive integer k.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  选择一个任意的正整数k。
- en: 2.  Choose a pair of positive integers m and n, such that m > n > 0.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  选择一对正整数m和n，满足m > n > 0。
- en: 3.  Calculate a = k(m² – n²), b = 2kmn, and c = k(m² + n²).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  计算a = k(m² – n²)，b = 2kmn，和c = k(m² + n²)。
- en: 4.  The values a, b, and c form a Pythagorean triple (a, b, c).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  值a、b和c构成一个毕达哥拉斯三元组(a, b, c)。
- en: '![](../images/Figure4-1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-1.jpg)'
- en: 'Figure 4-1: The Pythagorean theorem'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1：毕达哥拉斯定理
- en: A Pythagorean triple is considered *primitive* if its members are all coprime,
    meaning they share no common factors other than 1\. For example, (3, 4, 5) and
    (6, 8, 10) are both Pythagorean triples, but only (3, 4, 5) is primitive, since
    6, 8, and 10 have a common factor of 2\. Euclid’s formula will generate a primitive
    Pythagorean triple if and only if the two integers *m* and *n* are coprime, and
    one of them is even. If both *m* and *n* are odd, then the values of *a*, *b*,
    and *c* will all be even, and the triple won’t be primitive. However, as long
    as *m* and *n* are coprime, dividing the values of *a*, *b*, and *c* by 2 will
    result in a primitive Pythagorean triple.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个毕达哥拉斯三元组的成员彼此互质，即除了1之外没有共同的因子，则认为它是*原始的*。例如，（3，4，5）和（6，8，10）都是毕达哥拉斯三元组，但只有（3，4，5）是原始的，因为6、8和10有一个公共因子2。欧几里得公式将生成一个原始的毕达哥拉斯三元组，只有当*m*和*n*是互质且其中一个是偶数时。如果*m*和*n*都是奇数，则*a*、*b*和*c*的值都会是偶数，三元组就不是原始的。然而，只要*m*和*n*互质，除以2后的*a*、*b*和*c*仍然会形成一个原始的毕达哥拉斯三元组。
- en: The Code
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'Here’s a Kotlin function that generates a Pythagorean triple using Euclid’s
    formula:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用欧几里得公式生成毕达哥拉斯三元组的Kotlin函数：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function takes in two integers *m* and *n*, then uses them to calculate
    and return *a*, *b*, and *c*. By not explicitly including a value for *k* here,
    we’re implicitly assuming *k* = 1.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接收两个整数*m*和*n*，然后使用它们计算并返回*a*、*b*和*c*。由于这里没有明确给出*k*的值，我们隐式假设*k* = 1。
- en: 'We can call this function repeatedly from the main() function, using a for
    loop to generate Pythagorean triples for an arbitrary number of pairs of successive
    integers, as shown in the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从main()函数中反复调用此函数，通过for循环为任意数量的连续整数对生成毕达哥拉斯三元组，如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the first triple is generated using an m of 2 and an n of 1. These
    are the smallest possible values of m and n. (Recall the stipulation in Euclid’s
    formula that *m* and *n* must be positive integers such that *m* > *n* > 0.) These
    values are passed on as arguments to the generatePythagoreanTriple() function,
    which returns the elements of the Pythagorean triple as a Triple object in Kotlin.
    Successive inputs are generated by incrementing both m and n inside the for loop
    that repeats numTriples times. Since m and n are consecutive, one of them will
    always be even, and they can’t possibly share any factors, so every triple will
    be primitive.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个三元组是使用m为2和n为1生成的。这是m和n的最小可能值。（回想欧几里得公式中的要求，*m*和*n*必须是正整数且满足*m* > *n*
    > 0。）这些值作为参数传递给generatePythagoreanTriple()函数，该函数返回一个包含毕达哥拉斯三元组元素的Triple对象（Kotlin语言）。接下来的输入是通过在for循环内同时递增m和n生成的，该循环重复numTriples次。由于m和n是连续的，其中一个值总是偶数，而且它们不可能有任何公共因子，因此每个三元组都是原始的。
- en: The Result
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'If you don’t change any of the program parameters, the program will produce
    the following output that shows the first 10 Pythagorean triples:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不改变任何程序参数，程序将输出显示前10个毕达哥拉斯三元组的结果：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the starting values of m and n were hardcoded in the main()
    function. You might modify the code to allow the user to input values of m and
    n (ensuring *m* > *n* > 0). That would allow the user to generate a wider range
    of Pythagorean triples based on their requirements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，m 和 n 的初始值在 main() 函数中是硬编码的。你可以修改代码，让用户输入 m 和 n 的值（确保 *m* > *n* > 0）。这样用户就可以根据需求生成更广泛的毕达哥拉斯三元组。
- en: 'Project 11: Identify Prime Numbers with the Sieve of Eratosthenes'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 11：使用埃拉托斯特尼筛法识别质数
- en: 'Eratosthenes was an ancient Greek scholar who lived in the third century BCE.
    He was an accomplished mathematician, astronomer, geographer, and poet. In this
    project, we’ll explore one of Eratosthenes’s many mathematical discoveries: the
    *sieve of Eratosthenes*, an intuitive algorithm for identifying all the prime
    numbers up to a given limit. (We’ll explore another of his ingenious discoveries
    in the next project.) It’s remarkable to think that Eratosthenes conceived this
    strategy more than two millennia ago, during a time when few individuals could
    read or write, let alone think about algorithms and solve abstract mathematical
    problems.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 埃拉托斯特尼是公元前 3 世纪的古希腊学者。他是一位杰出的数学家、天文学家、地理学家和诗人。在这个项目中，我们将探讨埃拉托斯特尼的众多数学发现之一：*埃拉托斯特尼筛法*，一种识别所有质数的直观算法，直到给定的限制。（在下一个项目中，我们将探讨他其他的巧妙发现。）值得一提的是，埃拉托斯特尼在两千多年前就构思了这个策略，那时几乎没有人能够阅读或书写，更别提思考算法和解决抽象的数学问题了。
- en: The Strategy
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: 'To sieve for primes like Eratosthenes, start by creating a list of all integers
    from 2 up to some limit. Then, starting from 2, iteratively mark off all multiples
    of each prime number as composite. The unmarked numbers that remain at the end
    of the process are all prime numbers. Here are the steps to implement this algorithm:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要像埃拉托斯特尼一样筛选质数，首先创建一个从 2 到某个限制的所有整数的列表。然后，从 2 开始，迭代地标记每个质数的倍数为合数。过程结束时，未被标记的数字都是质数。以下是实现这个算法的步骤：
- en: 1.  Create a list of consecutive integers from 2 through the given limit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  创建一个从 2 到给定限制的连续整数列表。
- en: 2.  Starting with 2 (the first prime number), mark all its multiples as composite.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  从 2（第一个质数）开始，将它的所有倍数标记为合数。
- en: 3.  Find the next number in the list that isn’t marked as composite. This will
    be the next prime number.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  在列表中找到下一个未被标记为合数的数字。这将是下一个质数。
- en: 4.  Mark all multiples of the prime number found in step 3 as composite.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  将步骤 3 中找到的质数的所有倍数标记为合数。
- en: 5.  Repeat steps 3 and 4 until the square of the next prime number exceeds the
    given limit.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  重复步骤 3 和 4，直到下一个质数的平方超过给定限制。
- en: 6.  The unmarked numbers in the list are all prime numbers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  列表中未标记的数字都是质数。
- en: We can optimize the sieve algorithm by marking multiples of each prime number,
    starting from its square. For example, when marking multiples of 3, we can start
    at 3² = 9, since all multiples of 3 less than 9 will already have been marked
    as composite. In this case, 6 will have been marked while going through the multiples
    of 2\. Similarly, when we get to multiples of 5, we can skip 10, 15, and 20 as
    being multiples of either 2 or 3 and start marking off composites from 25.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过标记每个质数的倍数来优化筛法算法，从它的平方开始。例如，在标记 3 的倍数时，我们可以从 3² = 9 开始，因为所有小于 9 的 3 的倍数已经会被标记为合数。在这种情况下，6
    在标记 2 的倍数时就已经被标记了。同样，当我们标记 5 的倍数时，可以跳过 10、15 和 20，因为它们是 2 或 3 的倍数，而从 25 开始标记合数。
- en: The Code
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'As before, we’ll start by writing a function to implement the algorithm and
    then use the main() function to call this function and list the prime numbers.
    Here’s the Kotlin code for the sieveOfEratosthenes() function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们将首先编写一个函数来实现算法，然后使用 main() 函数调用这个函数并列出质数。以下是 sieveOfEratosthenes() 函数的
    Kotlin 代码：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The sieveOfEratosthenes() function takes an integer n as input and returns a
    list of prime numbers up to n. For that, the function creates a Boolean array
    primes with a length of n + 1 and initializes each element’s value to true. Over
    the course of the function, we’ll change elements to false if their indices aren’t
    prime. The function also creates a mutable list primeNumbers of type Int to save
    the prime numbers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: sieveOfEratosthenes() 函数接受一个整数 n 作为输入，并返回一个质数列表，直到 n。为此，函数创建一个长度为 n + 1 的布尔数组
    primes，并将每个元素的值初始化为 true。在函数执行过程中，如果某个元素的索引不是质数，则将其值更改为 false。该函数还创建了一个可变列表 primeNumbers，类型为
    Int，用于保存质数。
- en: To begin, we set the first two values of the primes array to false because 0
    and 1 aren’t prime. We then iterate over the numbers from 2 to the square root
    of n (we do this by ensuring i*i <= n) ❶. For each number i in this range, if
    i is marked as prime (that is, true) in the primes array ❷, the function marks
    all multiples of i in the primes array as composite (false). To reach all the
    multiples of i, we use a for loop with a step size of i ❸.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 primes 数组的前两个值设置为 false，因为 0 和 1 不是素数。然后，我们遍历从 2 到 n 的平方根的数字（我们通过确保 i*i
    <= n 来实现这一点）❶。对于这个范围内的每个数字 i，如果 i 在 primes 数组中被标记为素数（即 true）❷，该函数将 primes 数组中所有
    i 的倍数标记为合数（false）。为了遍历所有 i 的倍数，我们使用一个步长为 i 的 for 循环 ❸。
- en: To collect the prime numbers, we use a for loop ❹ to go over all primes elements
    and add the corresponding index to primeNumbers when the value of the element
    is true. Finally, we return the prime numbers to main() as a list of integers
    for postprocessing ❺.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集素数，我们使用一个 for 循环 ❹ 遍历所有 primes 元素，当元素的值为 true 时，将相应的索引添加到 primeNumbers 列表中。最后，我们将素数作为整数列表返回给
    main() 进行后处理 ❺。
- en: Now that our sieving function is good to go, we can use the main() function
    to retrieve a list of prime numbers up to n and print it out. We’ll also create
    a printPrimes() helper function to manage the printing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的筛选函数已经准备好，我们可以使用 main() 函数来获取一个直到 n 的素数列表并将其打印出来。我们还将创建一个 printPrimes()
    辅助函数来管理打印工作。
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The main() function is similar to the one we used for the Babylonian square
    root algorithm in [Project 9](chapter4.xhtml#pre-9). It takes a user input for
    the limit num, uses it to create a list of prime numbers with the sieveOfEratosthenes()
    function, and then calls printPrimes() to print the list. To make the output look
    nice, printPrimes() organizes the numbers into rows of six and uses string formatting
    to create neatly aligned columns.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: main() 函数类似于我们在[项目 9](chapter4.xhtml#pre-9)中使用的巴比伦平方根算法。它接受用户输入的限制 num，利用这个限制通过sieveOfEratosthenes()函数生成素数列表，然后调用printPrimes()函数打印该列表。为了让输出看起来更加整齐，printPrimes()将数字组织成每行六个，并使用字符串格式化来创建整齐对齐的列。
- en: The Result
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'Here’s a look at the program output up to an arbitrary limit num of 251:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是程序输出的一个示例，限制 num 为 251 时的结果：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Other methods for generating prime numbers include the sieve of Sundaram, the
    sieve of Atkin, and trial division. I encourage you to do some online research
    and experiment with these methods to enhance your Kotlin coding skills and gain
    additional insight into prime number generation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 生成素数的其他方法包括 Sundaram 筛法、Atkin 筛法和试除法。我鼓励你进行一些在线研究，并尝试这些方法，提升你的 Kotlin 编程技能，并深入了解素数的生成。
- en: 'Project 12: Calculate Earth’s Circumference the Ancient Way'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 12：用古老的方式计算地球的周长
- en: One of Eratosthenes’s most famous achievements was calculating Earth’s circumference.
    He accomplished this by measuring the angle of the sun’s rays at noon on the summer
    solstice at two locations, Alexandria and Syene (modern-day Aswan), which were
    known to be on the same meridian, or longitude. [Figure 4-2](chapter4.xhtml#fig4-2)
    shows an abstraction of some of the geometry involved in this brilliant experiment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 埃拉托斯特尼的最著名成就之一是计算地球的周长。他通过在夏至当天正午，在两个已知位于同一经线（或经度）上的地点——亚历山大和赛内（现代的阿斯旺）测量太阳光线的角度来完成这一任务。[图
    4-2](chapter4.xhtml#fig4-2)展示了这一精彩实验中涉及的一些几何抽象。
- en: '![](../images/Figure4-2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-2.jpg)'
- en: 'Figure 4-2: Measuring Earth’s circumference'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2：测量地球的周长
- en: In this diagram, we can think of points E and B as two locations on Earth’s
    surface (for example, Alexandria and Syene). We’ll assume for the sake of simplicity
    that Earth is a perfect sphere and that both of these locations are on the same
    meridian. Let’s also assume that *AB* and *DE* are two tall poles or towers that
    are sufficiently far apart that when extended to Earth’s center (C), they create
    a small but measurable angle *α*. Two parallel rays coming from the sun just miss
    the tops of the poles and will hit the ground at slightly different angles. Because
    Earth’s surface is curved, the angle *θ*[2] between ray 2 and *DE* will be slightly
    greater than the angle *θ*[1] between ray 1 and *AB*. As a result, the shadow
    of *DE* on the ground will be longer than that of *AB*, even if the poles themselves
    have the same height.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图示中，我们可以将点E和B看作是地球表面的两个位置（例如，亚历山大和赛涅）。为了简化起见，我们假设地球是一个完美的球体，且这两个位置位于同一经线上。我们还假设*AB*和*DE*是两根高塔或塔柱，它们的距离足够远，以至于当它们延伸到地球的中心（C）时，形成一个小而可测量的角度*α*。从太阳射来的两条平行光线恰好未触及塔顶，它们会以略微不同的角度打到地面。由于地球表面是弯曲的，光线2与*DE*之间的角度*θ*[2]将略大于光线1与*AB*之间的角度*θ*[1]。因此，*DE*在地面上的阴影将比*AB*的阴影长，即使这些塔柱的高度相同。
- en: 'We also assume that at both locations the poles are positioned vertically relative
    to the ground surface, which can be thought of as flat in the vicinity of the
    poles. This last assumption allows us to measure the angle of a ray of light relative
    to a pole. Assuming that the length of the shadow is *s* and the height of the
    pole is *h*, the angle *θ* between the ray and the pole can be expressed as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设在两个位置，竿子相对于地面是垂直的，而地面在竿子附近可以看作是平坦的。这个假设使我们能够测量光线相对于竿子的角度。假设阴影的长度为*s*，竿子的高度为*h*，那么光线与竿子之间的角度*θ*可以表示为：
- en: $Equation$ (4.1) ![](../images/eq4-1.jpg)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ (4.1) ![](../images/eq4-1.jpg)
- en: 'Finally, consider triangle *ACF* in [Figure 4-2](chapter4.xhtml#fig4-2). According
    to the *exterior angle theorem*, the triangle’s exterior angle *AFE* must be equal
    to the sum of the two interior opposite angles, *ACF* and *CAF*. Meanwhile, *AFE*
    and *θ*[2] are equal because these are the *alternate interior angles* of the
    line *DF* that intersects the two parallel solar rays. Therefore, the following
    must be true:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑[图4-2](chapter4.xhtml#fig4-2)中的三角形*ACF*。根据*外角定理*，该三角形的外角*AFE*必须等于两内对角*ACF*和*CAF*之和。与此同时，*AFE*和*θ*[2]相等，因为它们是交叉两条平行太阳光线的直线*DF*的*交替内角*。因此，以下等式必须成立：
- en: ∠*AFE* = ∠*ACF* + ∠*CAF*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ∠*AFE* = ∠*ACF* + ∠*CAF*
- en: '*  θ*[2] = *θ*[1] + *α*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*  θ*[2] = *θ*[1] + *α*'
- en: 'Rearranging the latter, we get:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重新排列后，我们得到：
- en: $Equation$ (4.2) ![](../images/eq4-2.jpg)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ (4.2) ![](../images/eq4-2.jpg)
- en: 'This final equation is what we need to estimate Earth’s circumference. We’ll
    achieve that by using another geometric relationship that connects the length
    *d* of an arc of a circle to the angle *α* (in radians) that the arc creates at
    the center of the circle:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终方程式就是我们用来估算地球周长的公式。我们将通过使用另一个几何关系来实现这一目标，该关系将圆弧的长度*d*与该圆弧在圆心处所形成的角度*α*（以弧度表示）联系起来：
- en: $Equation$ ![](../images/pg137-1.jpg)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ ![](../images/pg137-1.jpg)
- en: 'Solving for the circumference gives us this equation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解出周长得到以下方程式：
- en: $Equation$ (4.3) ![](../images/eq4-3.jpg)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ (4.3) ![](../images/eq4-3.jpg)
- en: What Eratosthenes did was quite ingenious. He knew that at noon on the summer
    solstice, the sun would be directly overhead at Syene (point B in [Figure 4-2](chapter4.xhtml#fig4-2)),
    so a vertical pole there would cast no shadow, meaning *θ*[1] = 0, and therefore
    *α* = *θ*[2] per Equation 4.2\. In Alexandria (point E), however, the sun would
    be at an angle, so a pole would cast a shadow on the ground. By measuring the
    length of this shadow, Eratosthenes was able to calculate the angle between the
    sun’s ray (ray 2) and the pole (*DE*) using Equation 4.1\. He found this angle
    to be about 7.2 degrees, or 0.12566370614 radians.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 埃拉托斯特尼的做法非常巧妙。他知道，在夏至的中午，太阳会正好位于赛涅的正上方（即[图4-2](chapter4.xhtml#fig4-2)中的点B），所以在那里竖立的竿子不会投下阴影，这意味着*θ*[1]
    = 0，因此根据方程式4.2，*α* = *θ*[2]。然而，在亚历山大（点E），太阳的位置会呈一定角度，所以竿子会在地面上投下阴影。通过测量这个阴影的长度，埃拉托斯特尼能够利用方程式4.1计算太阳光线（光线2）与竿子（*DE*）之间的角度。他发现这个角度大约是7.2度，或者0.12566370614弧度。
- en: 'Eratosthenes was aware of the distance between Alexandria and Syene—he estimated
    it to be 5,000 stadia (about 800 kilometers). With this information and the angle
    of the shadow, he calculated Earth’s circumference (using Equation 4.3) and arrived
    at a value of approximately 40,000 kilometers. Once he determined the circumference,
    he could also calculate Earth’s radius. For any circle, the radius *r* can be
    calculated from the circumference as:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 厄拉托斯特尼知道亚历山大和赛内之间的距离——他估算为5,000斯塔迪（约800公里）。通过这些信息和阴影角度，他计算了地球的周长（使用方程4.3），得到了大约40,000公里的值。确定周长后，他也可以计算地球的半径。对于任何圆形，半径*r*可以通过周长计算得出：
- en: $Equation$ ![](../images/pg138-1.jpg)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ ![](../images/pg138-1.jpg)
- en: 'Filling in the circumference formula from Equation 4.3, Earth’s radius *R*
    is:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将方程4.3中的周长公式代入，地球的半径*R*为：
- en: $Equation$ (4.4) ![](../images/eq4-4.jpg)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (4.4) ![](../images/eq4-4.jpg)
- en: This calculation gave Eratosthenes a value of 6,370 kilometers, which is remarkably
    close to the actual value of approximately 6,371 kilometers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算给厄拉托斯特尼提供了6,370公里的值，与实际值大约6,371公里非常接近。
- en: The Code
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: Let’s write some code to imitate the method Eratosthenes used to calculate Earth’s
    circumference and radius. We’ll make our program more flexible by allowing the
    sun to not be directly overhead at the first location. To do this, we’ll use Equation
    4.1 to figure out the shadow angles, Equation 4.2 to get the arc angle, Equation
    4.3 to calculate the circumference, and finally, Equation 4.4 to calculate the
    radius.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来模拟厄拉托斯特尼计算地球周长和半径的方法。我们将通过允许太阳在第一个地点不直接位于头顶来使程序更加灵活。为此，我们将使用方程4.1来计算阴影角度，方程4.2来获取弧度角，方程4.3来计算周长，最后使用方程4.4来计算半径。
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code segment starts by importing the required math function and defining
    a data class Earth with three properties: alpha, circumference, and radius. This
    data class allows us to conveniently package up the values estimated inside the
    calculateEarthMetrics() function and return them via a single Earth object.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码段首先导入所需的数学函数，并定义了一个数据类Earth，具有三个属性：alpha、周长和半径。这个数据类让我们能够方便地将calculateEarthMetrics()函数中估算的值打包，并通过一个Earth对象返回它们。
- en: 'The calculateEarthMetrics() function has five named parameters that represent
    the shadow lengths (s1 and s2) and heights (h1 and h2) for the two locations,
    and the distance (d) between these two locations. Then the function follows the
    steps described on [page 137](#pg_137): calculating theta1 and theta2, using them
    to calculate alpha, and using alpha to estimate circumference and radius. Since
    these are large numbers (when expressed in kilometers), we convert both circumference
    and radius into integers (which is how they were defined in the Earth class).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: calculateEarthMetrics()函数有五个命名参数，分别代表两个地点的阴影长度（s1和s2）、高度（h1和h2）以及这两个地点之间的距离（d）。然后，函数按照[第137页](#pg_137)中描述的步骤进行：计算theta1和theta2，使用它们计算alpha，再利用alpha估算周长和半径。由于这些是大数字（以公里为单位表示时），我们将周长和半径都转换为整数（这就是它们在Earth类中定义的方式）。
- en: 'The main() function’s job is quite simple: call the calculateEarthMetrics()
    function; receive the values of alpha, circumference, and radius by deconstructing
    the returned object; and print them with appropriate annotations and format.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: main()函数的任务很简单：调用calculateEarthMetrics()函数；通过解构返回的对象获取alpha、周长和半径的值；并以适当的注释和格式打印它们。
- en: The Result
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'For the given parameter values in this example—the same ones Eratosthenes used—the
    output of our program looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本例中给定的参数值——与厄拉托斯特尼使用的相同——我们程序的输出如下：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Feel free to use this tool to experiment with different parameter values. For
    example, you could try using shadow lengths and angles measured on an exoplanet
    and find out how large or small the planet is!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用此工具来尝试不同的参数值。例如，你可以尝试使用在系外行星上测量的阴影长度和角度，看看该行星的大小！
- en: 'Project 13: Code the Fibonacci Sequence'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 项目13：编写斐波那契数列的代码
- en: Leonardo of Pisa, commonly known as Fibonacci, was an Italian mathematician
    born c. 1170\. From an early age, he showed a keen interest in mathematics, and
    his travels to North Africa and the Middle East exposed him to advanced mathematical
    concepts that weren’t yet known in Europe. Fibonacci’s most significant contribution
    to mathematics was the introduction of the Indo-Arabic numeral system to the Western
    world, which included the use of zero. This system replaced the previously used
    Roman numerals and revolutionized arithmetic calculations, making them significantly
    more efficient.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 比萨的莱昂纳多，通常被称为斐波那契，是一位大约在1170年出生的意大利数学家。从小，他便对数学表现出浓厚的兴趣，他前往北非和中东的旅行让他接触到了欧洲尚未掌握的先进数学概念。斐波那契对数学最重要的贡献是将印度-阿拉伯数字系统引入西方世界，这一系统包括了“零”的使用。这个系统取代了之前使用的罗马数字，并彻底改变了算术计算，使其变得更加高效。
- en: Fibonacci is widely recognized for introducing the Fibonacci sequence, a series
    of numbers where each number is the sum of the two preceding numbers. To explain
    this concept in his book *Liber Abaci*, Fibonacci used a colorful analogy involving
    a pair of rabbits. Imagine placing a pair of rabbits in an enclosed area. The
    rabbits can mate when they’re one month old and can produce a new pair of rabbits
    when they’re two months old. Therefore, it takes one month for each new pair to
    mature and an additional month to give birth to a new pair. If the rabbits never
    die and the mating continues, how many pairs of rabbits will there be after each
    month?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契因引入斐波那契数列而广为人知，这是一系列数字，其中每个数字是前两个数字的和。为了在他的书《算盘之书》（*Liber Abaci*）中解释这一概念，斐波那契使用了一个生动的类比，涉及一对兔子。假设将一对兔子放入一个封闭区域。这些兔子在一月龄时可以交配，并且在二月龄时可以繁殖一对新兔。因此，每对兔子需要一个月时间成熟，并且需要额外一个月才能生育一对新兔。如果兔子永不死亡并且交配持续进行，那么每个月将有多少对兔子呢？
- en: 'The solution to this problem forms the Fibonacci sequence. If we start with
    (1, 1) representing the starting pair over the first two months, the sequence
    will look like this: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, and so on. These numbers
    can be linked to Fibonacci’s rabbit example as explained in [Table 4-1](chapter4.xhtml#tab4-1).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解答形成了斐波那契数列。如果我们从（1, 1）开始，表示前两个月的起始兔对数，数列将呈现如下：1, 1, 2, 3, 5, 8, 13, 21,
    34, 55，依此类推。这些数字可以通过[表 4-1](chapter4.xhtml#tab4-1)中所解释的斐波那契兔子例子来理解。
- en: 'Table 4-1: Fibonacci’s Rabbits'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1：斐波那契的兔子
- en: '| Month | Young pairs | Mature pairs | Total pairs | Explanation |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 月份 | 幼兔对数 | 成熟兔对数 | 总兔对数 | 说明 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | 1 | 0 | 1 | Start with a newborn pair, no mature pair, and no offspring.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 从一对新生兔子开始，没有成熟兔对，也没有幼兔。 |'
- en: '| 1 | 0 | 1 | 1 | The first pair becomes mature and will reproduce at the end
    of this period. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 | 第一对兔子变成熟，并将在这个周期结束时繁殖。 |'
- en: '| 2 | 1 | 1 | 2 | The first pair of offspring is born. One mature pair will
    reproduce again at the end of this period. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 1 | 2 | 第一对幼兔出生。此时，一对成熟的兔子将在这个周期结束时再次繁殖。 |'
- en: '| 3 | 1 | 2 | 3 | The second pair of offspring is born. Two mature pairs will
    reproduce at the end of this period. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 | 2 | 3 | 第二对幼兔出生。两对成熟的兔子将在这个周期结束时繁殖。 |'
- en: '| 4 | 2 | 3 | 5 | Two new pairs are born. Three mature pairs will reproduce
    at the end of this period. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2 | 3 | 5 | 两对新兔出生。三对成熟的兔子将在这个周期结束时繁殖。 |'
- en: '| 5 | 3 | 5 | 8 | Three new pairs are born. Five mature pairs will reproduce
    at the end of this period. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 3 | 5 | 8 | 三对新兔出生。五对成熟的兔子将在这个周期结束时繁殖。 |'
- en: 'Say we want to determine how many rabbit pairs will exist after a certain number
    of generations. Here are the steps we can take, using the Fibonacci sequence:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要确定在一定代数后会有多少对兔子。我们可以按照以下步骤，使用斐波那契数列来计算：
- en: 1.  Set the first two numbers in the sequence. By convention, these are usually
    0 and 1 rather than 1 and 1.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 设置数列的前两个数字。按照惯例，这两个数字通常是0和1，而不是1和1。
- en: 2.  Add the first two numbers to get the third number in the sequence.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 将前两个数字相加得到数列中的第三个数字。
- en: 3.  Generate the next number by adding the two preceding numbers. This step
    can be mathematically expressed as Fn = Fn [– 1] + Fn [– 2], where n ≥ 2.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 通过将前两个数字相加来生成下一个数字。这个步骤可以用数学公式表示为 Fn = Fn[– 1] + Fn[– 2]，其中 n ≥ 2。
- en: 4.  Repeat step 3 until the stopping condition is met.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 重复步骤 3，直到满足停止条件。
- en: 'The Fibonacci sequence has become a classic example of recursive sequences
    and is used to illustrate many mathematical concepts in various fields. Before
    getting into how to code this sequence, I’ll introduce you to two other related
    concepts: the golden ratio and the Fibonacci spiral. These concepts will be illustrated
    in our Fibonacci code.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列已经成为递归数列的经典例子，并被用来说明各个领域中的许多数学概念。在介绍如何编写这个数列的代码之前，我将向您介绍另外两个相关的概念：黄金比例和斐波那契螺旋。这些概念将在我们的斐波那契代码中得到体现。
- en: The Golden Ratio
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 黄金比例
- en: The *golden ratio*, also known as the golden mean, is a mathematical ratio commonly
    found in nature, art, and architecture. The ratio is approximately 1.61803398875
    and is denoted by the Greek letter *φ*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*黄金比例*，也称为黄金分割，是一种在自然界、艺术和建筑中常见的数学比例。这个比例大约是1.61803398875，表示为希腊字母*φ*。'
- en: 'The golden ratio is linked to the Fibonacci sequence: as the sequence continues,
    the ratio between each successive pair of numbers approaches the golden ratio.
    Starting with 1 (we can’t start with 0, as the ratio of 1 over 0 is infinity),
    if we calculate and plot this ratio for each successive pair, it will rapidly
    converge on *φ*, as shown in [Figure 4-3](chapter4.xhtml#fig4-3).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金比例与斐波那契数列有关：随着数列的延续，每对连续数字之间的比例逐渐接近黄金比例。从1开始（我们不能从0开始，因为1除以0是无穷大），如果我们计算并绘制每对连续数字的比例，它将迅速收敛到*φ*，如[图4-3](chapter4.xhtml#fig4-3)所示。
- en: '![](../images/Figure4-3.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-3.jpg)'
- en: 'Figure 4-3: Convergence to the golden ratio'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3：趋近黄金比例
- en: Well-known manifestations of the golden ratio in nature include nautilus shells,
    the arrangements of seeds in a sunflower and scales on a pine cone, and the proportions
    of the human body (for example, the ratio of the length of the forearm to the
    hand, and the ratio of the overall height to the height of the navel). The ratio
    has also been extensively exploited by artists, musicians, photographers, product
    designers, and architects in their work. In architecture, for example, it might
    determine the ratio of width to height for a building’s facade.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金比例在自然界中的著名体现包括鹦鹉螺壳、向日葵种子的排列、松果上的鳞片，以及人体的比例（例如，前臂和手的长度比，以及整体身高和肚脐高度的比值）。这一比例还被艺术家、音乐家、摄影师、产品设计师和建筑师广泛运用在他们的作品中。例如，在建筑学中，它可能决定建筑物立面宽高比。
- en: The Fibonacci Spiral
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 斐波那契螺旋
- en: 'The Fibonacci spiral is a geometric pattern derived from the Fibonacci sequence.
    It’s created by drawing a series of quarter circles inside squares that are based
    on the numbers in the Fibonacci sequence. To draw the Fibonacci spiral, follow
    these steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契螺旋是一个源自斐波那契数列的几何图案。它是通过在基于斐波那契数列中的数字的正方形内绘制一系列四分之一圆来创建的。绘制斐波那契螺旋的步骤如下：
- en: 1.  Draw a small square with a side length of 1.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  绘制一个边长为1的小正方形。
- en: 2.  Draw another square of side length 1 adjacent to the first square, sharing
    a side.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  绘制另一个边长为1的正方形，紧邻第一个正方形，共享一条边。
- en: 3.  Draw a third square of side length 2 adjacent to the second square, sharing
    a side.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  绘制一个边长为2的第三个正方形，紧邻第二个正方形，共享一条边。
- en: 4.  Draw a fourth square of side length 3 adjacent to the third square, sharing
    a side.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  绘制一个边长为3的第四个正方形，紧邻第三个正方形，共享一条边。
- en: 5.  Continue this process, drawing squares with side lengths equal to the sum
    of the two preceding squares, adjacent to the last drawn square, sharing a side.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  继续这个过程，绘制边长等于前两个正方形之和的正方形，紧邻最后绘制的正方形，共享一条边。
- en: '6.  Draw a quarter circle inside each of the squares, connecting the opposite
    corners of each square. The quarter circles will form a smooth curve: the Fibonacci
    spiral.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  在每个正方形内绘制一个四分之一圆，连接每个正方形的对角线。四分之一圆将形成一个平滑的曲线：斐波那契螺旋。
- en: If you follow these steps and draw the spiral for the first eight numbers (starting
    from 1), the result will look like [Figure 4-4](chapter4.xhtml#fig4-4).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按照这些步骤操作，并绘制前八个数字的螺旋（从1开始），结果将如下图所示[图4-4](chapter4.xhtml#fig4-4)。
- en: '![](../images/Figure4-4.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-4.jpg)'
- en: 'Figure 4-4: A Fibonacci spiral for the first eight numbers'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4：前八个数字的斐波那契螺旋
- en: The Fibonacci spiral, often associated with the golden ratio, is a recurring
    pattern in nature, appearing in various forms such as seashells, leaf arrangements,
    and even the spirals of distant galaxies! While the golden ratio is not an absolute
    prerequisite for beauty or efficiency in design, it undeniably holds an enduring
    charm as a mathematical concept that continues to capture our imagination.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契螺旋，通常与黄金比例相关，是自然界中一个常见的模式，出现在各种形式中，比如海贝、叶子排列，甚至遥远星系的螺旋！虽然黄金比例并不是设计中美学或效率的绝对前提，但它无疑作为一个数学概念，因其持久的魅力而持续吸引着我们的想象力。
- en: '#### The Code'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 代码'
- en: 'Generating and printing the Fibonacci sequence up to a certain limit can be
    accomplished with just a few lines of code. Let’s take this project a step further:
    along with generating the sequence itself, we’ll also draw the Fibonacci spiral.
    This way, we’ll be able to practice some of the data visualization techniques
    covered in the previous chapter and anticipate future projects where we’ll gain
    deeper insight into a problem by visualizing the program output.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 生成并打印出直到某个限制的斐波那契数列，可以通过几行代码轻松实现。让我们将这个项目更进一步：除了生成数列本身，我们还将绘制斐波那契螺旋。这样，我们就能够练习上一章中介绍的一些数据可视化技巧，并预见到未来的项目，在这些项目中我们将通过可视化程序输出，更深入地理解问题。
- en: Setting Up
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置
- en: To begin, we’ll write the global components of the code, including the import
    block needed for the visualization, the FibonacciSpiral application class, and
    the main() function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写代码的全局组件，包括用于可视化的导入模块、FibonacciSpiral 应用程序类，以及 main() 函数。
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code segment starts with an import block that provides access to a number
    of JavaFX graphics features that we’ll use to draw the Fibonacci spiral on a canvas
    object. See [Chapter 3](chapter3.xhtml) for a review of these features. Coding
    in IntelliJ IDEA means you don’t need to memorize which library features you need
    to import; as you use the default template and add code that may require additional
    graphics elements, the IDE will import those features automatically.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码段从一个导入模块开始，提供了对多个 JavaFX 图形特性的访问，这些特性将帮助我们在画布对象上绘制斐波那契螺旋。有关这些特性的复习，请参考[第 3
    章](chapter3.xhtml)。在 IntelliJ IDEA 中编写代码意味着你不需要记住需要导入哪些库特性；当你使用默认模板并添加可能需要额外图形元素的代码时，IDE
    会自动导入这些特性。
- en: Following the import block, we set up some global parameters. First, we create
    a variable called N to set how far into the Fibonacci sequence we’ll go (starting
    from 0). Then, we create a mutable list of type Int named fibs, which will store
    the Fibonacci sequence as we calculate it. We also set several parameters to create
    a canvas where we’ll draw the Fibonacci spiral. To define the size of the canvas,
    we use the values canvasW and canvasH, and to set the starting location of the
    origin of the coordinate system, we use xOffset and yOffset. For this particular
    project, I’ve set the canvas size to 1,000 pixels wide and 750 pixels high, which
    should be suitable for most screen sizes and resolutions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入模块之后，我们设置了一些全局参数。首先，我们创建了一个名为 N 的变量，用来设置斐波那契数列的计算范围（从 0 开始）。接着，我们创建了一个名为
    fibs 的可变列表，它的类型是 Int，用来存储我们计算出的斐波那契数列。我们还设置了多个参数来创建一个画布，在上面绘制斐波那契螺旋。为了定义画布的大小，我们使用
    canvasW 和 canvasH 这两个值，而为了设置坐标系原点的位置，我们使用 xOffset 和 yOffset。对于这个特定的项目，我将画布的大小设置为
    1000 像素宽，750 像素高，这对于大多数屏幕尺寸和分辨率来说应该是合适的。
- en: It’s important to note that the length of a line or the side of a rectangle
    on the canvas is measured in pixels. To plot the Fibonacci spiral, we’ll start
    with a square of size 1\. However, drawing a square of 1 pixel would result in
    a tiny dot on the screen, which we don’t want. To avoid this, we’ll use an amplification
    factor called amplify and set it to 25. Therefore, the first square will be 25
    pixels in size, and all subsequent squares will be amplified by the same factor.
    This ensures that the end result is a Fibonacci spiral that fills the canvas nicely.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，画布上直线或矩形边长的单位是像素。为了绘制斐波那契螺旋，我们将从一个边长为 1 的正方形开始。然而，绘制一个 1 像素的正方形会导致屏幕上出现一个非常小的点，这显然不是我们想要的。为了避免这种情况，我们将使用一个叫做放大系数（amplify）的因子，并将其设置为
    25。因此，第一个正方形的大小将是 25 像素，之后的所有正方形都会按同样的放大系数进行放大。这样可以确保最终结果是一个填充整个画布的斐波那契螺旋。
- en: 'In the FibonacciSpiral application class, we first create a layout container
    called root of type Pane(), which is the most basic layout container in JavaFX
    to hold and position nodes (user interface components) in a scene. We use root
    to hold the canvas on which the spiral will be drawn. Notice how we use the translate
    property of the graphics context gc to shift the initial position of the origin
    from the top-left corner (the default) to a position offset a bit from the middle
    of the canvas, where we’ll draw the first Fibonacci square (see [Figure 4-4](chapter4.xhtml#fig4-4)
    to get a sense of where that is). The rest of the class is routine JavaFX: we
    assign canvas to root, which is assigned to scene1, which connects to stage, the
    primary display window for this application.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FibonacciSpiral 应用程序类中，我们首先创建一个名为 root 的布局容器，其类型为 Pane()，它是 JavaFX 中最基础的布局容器，用于在场景中承载和定位节点（用户界面组件）。我们使用
    root 来承载将在其上绘制螺旋的画布。请注意，我们如何使用图形上下文 gc 的 translate 属性将原点的初始位置从左上角（默认位置）移动到画布中稍偏离中心的位置，在那里我们将绘制第一个
    Fibonacci 方块（请参见 [图 4-4](chapter4.xhtml#fig4-4) 以了解位置）。类的其余部分是常规的 JavaFX 操作：我们将画布赋给
    root，root 被赋给 scene1，scene1 连接到 stage，这是此应用程序的主要显示窗口。
- en: 'Next, we move to the problem-specific segment of the application class, which
    consists of calls to three separate functions: generateFibonacciNumbers(), drawFibonacciSpiral(),
    and printFibonacciSequenceAndRatios(). These functions do exactly what their names
    suggest, and we’ll discuss them in detail shortly.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入应用程序类的特定问题部分，该部分包括对三个独立函数的调用：generateFibonacciNumbers()、drawFibonacciSpiral()
    和 printFibonacciSequenceAndRatios()。这些函数的功能正如其名称所示，我们将在稍后详细讨论它们。
- en: Finally, the main() function contains a single line of code that launches a
    JavaFX application by calling the launch() method of the Application class, passing
    it the FibonacciSpiral class as an argument.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，main() 函数包含一行代码，通过调用 Application 类的 launch() 方法并将 FibonacciSpiral 类作为参数传入，启动
    JavaFX 应用程序。
- en: Generating the Fibonacci Sequence
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成 Fibonacci 数列
- en: The generateFibonacciNumbers() function generates the Fibonacci sequence as
    discussed earlier.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: generateFibonacciNumbers() 函数生成之前讨论过的 Fibonacci 数列。
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, *F*(0) and *F*(1) are set to 0 and 1, respectively, and then the rest
    of the sequence is generated using *F*n = *F*n [– 1] + *F*n [– 2], where *n* ≥
    2\. We add all generated numbers to the mutable list fibs using its fibs.add()
    method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*F*(0) 和 *F*(1) 分别设置为 0 和 1，然后使用 *F*n = *F*n [– 1] + *F*n [– 2] 的公式生成其余的数列，其中
    *n* ≥ 2。我们将所有生成的数字添加到可变列表 fibs 中，使用其 fibs.add() 方法。
- en: Drawing the Fibonacci Spiral
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 绘制 Fibonacci 螺旋
- en: The drawFibonacciSpiral() function drives the process of drawing the Fibonacci
    spiral using the generated sequence of Fibonacci numbers, with support from two
    other helper functions that label each square with its corresponding Fibonacci
    number and draw the quarter circles.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: drawFibonacciSpiral() 函数通过使用生成的 Fibonacci 数列，结合两个辅助函数，驱动绘制 Fibonacci 螺旋的过程，这两个函数分别标注每个方块的
    Fibonacci 数字并绘制四分之一圆。
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The drawFibonacciSpiral() function uses a for loop that starts with 1 (we cannot
    draw a square of size 0) to iterate over the sequence of numbers. In the loop,
    we retrieve the current number and multiply it by amplify to properly scale the
    squares on the screen ❶. Then we implement the rest of the process inside a with(gc)
    block ❷ where we draw a square, annotate it, and draw an arc. At the end of each
    cycle, we move the canvas’s origin to the next location and rotate the coordinate
    system counterclockwise by 90 degrees. This way, the squares will spiral outward,
    as shown in [Figure 4-4](chapter4.xhtml#fig4-4), but we’ll still be able to draw
    each one with the same strokeRect(0.0, 0.0, side, side) call.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: drawFibonacciSpiral() 函数使用一个从 1 开始的 for 循环（因为我们不能绘制大小为 0 的方块），遍历数字序列。在循环中，我们获取当前数字并将其乘以放大系数
    amplify，以正确地在屏幕上缩放方块❶。然后，我们在 with(gc) 块 ❷ 内实现其余过程，其中我们绘制一个方块、标注它并绘制一个弧形。在每次循环结束时，我们将画布的原点移动到下一个位置，并将坐标系逆时针旋转
    90 度。这样，方块就会向外螺旋展开，如 [图 4-4](chapter4.xhtml#fig4-4) 所示，但我们仍然可以通过相同的 strokeRect(0.0,
    0.0, side, side) 调用绘制每个方块。
- en: In the drawText() function, we use the argument i, which represents the index
    of the current Fibonacci number, to set the font size of the text used for annotation
    ❸. This ensures that the first two numbers fit inside a square of size 25 pixels.
    We then use the fillText() method of the graphics context gc to draw the number
    in the middle of its corresponding square.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在drawText()函数中，我们使用参数i，它表示当前斐波那契数的索引，来设置注释文本的字体大小❸。这确保了前两个数字能适应25像素的正方形。然后，我们使用图形上下文gc的fillText()方法将数字绘制在其对应正方形的中央。
- en: The drawArc() function sets up the parameter values needed by the strokeArc()
    method of the graphics context. These parameters include the top-left corner of
    the rectangle, its width and height, the starting angle with respect to the x-axis
    in degrees, and the length of the arc in degrees. We also specify the arc type
    as OPEN, which means the two endpoints won’t be connected with a line.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: drawArc()函数设置了图形上下文中strokeArc()方法所需的参数值。这些参数包括矩形的左上角坐标、矩形的宽度和高度、相对于x轴的起始角度（单位为度），以及弧长（单位为度）。我们还指定弧的类型为OPEN，这意味着两个端点之间不会用线连接。
- en: For drawing the arc, think of the imaginary box inside which the arc will be
    drawn as a stand-alone object that has its own coordinate system whose origin
    is at the center of the box. Inside this box, the positive x-axis points east
    and the positive y-axis points north. (Note that this isn’t the same as the default
    convention used by the JavaFX canvas.) Taking this into account, drawing an arc
    counterclockwise is considered the positive direction, and this is how the starting
    angle and arc length are specified. For example, we’ve specified the start angle
    as –90 degress and the arc length as –90 degrees (both in the clockwise direction
    relative to the positive x-axis). Alternatively, we could have specified the start
    angle as +180 degress and the arc angle as +90 degrees (both counterclockwise)
    to produce the same result.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绘制弧线，可以将弧线将要绘制的虚拟框视为一个独立的对象，它有自己的坐标系，原点位于框的中心。在这个框内，正x轴指向东，正y轴指向北。（请注意，这与JavaFX画布使用的默认约定不同。）考虑到这一点，逆时针绘制弧线被视为正方向，这也是指定起始角度和弧长的方式。例如，我们已将起始角度指定为–90度，弧长指定为–90度（相对于正x轴的顺时针方向）。或者，我们也可以将起始角度指定为+180度，弧长指定为+90度（逆时针方向），以产生相同的结果。
- en: Printing the Sequence
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 打印数列
- en: We have one more function that prints the Fibonacci sequence, as well as the
    ratios between successive terms in the sequence, to illustrate how these values
    converge on the golden ratio.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个函数，它打印斐波那契数列以及数列中相邻项之间的比值，以展示这些值如何收敛到黄金比例。
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The function first prints a header message and the length of the generated Fibonacci
    sequence. Next, it prints the generated sequence itself using println() ❶. Finally,
    a for loop calculates and prints the ratios of adjacent numbers in the sequence,
    using format() to show the values with appropriate spacing and precision.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先打印一个头部消息以及生成的斐波那契数列的长度。接下来，它使用println()打印生成的数列❶。最后，一个for循环计算并打印相邻数字之间的比值，使用format()函数以适当的间距和精度显示这些值。
- en: The Result
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'When you run the code, the text portion of the output should appear as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，输出的文本部分应如下所示：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice how the ratios initially zigzag around the value of 1.61803398875 but
    quickly approach the golden ratio once we reach the 10th pair in the sequence.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，比率最初在1.61803398875值附近呈锯齿形波动，但一旦我们到达数列中的第10对数，它们便迅速接近黄金比例。
- en: Of course, the app also displays a beautiful Fibonacci spiral drawn on the canvas
    using JavaFX. It should look exactly like [Figure 4-4](chapter4.xhtml#fig4-4)—that
    figure was generated with this very code!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，应用程序还会显示一个使用JavaFX绘制的美丽斐波那契螺旋图案。它应与[图4-4](chapter4.xhtml#fig4-4)完全相同——该图是用这段代码生成的！
- en: 'Project 14: Find the Shortest Distance Between Two Locations on Earth'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 项目14：计算地球上两地点之间的最短距离
- en: We use the Pythagorean theorem to calculate distances between points on the
    same plane. However, for points on Earth’s surface, this method isn’t accurate
    over long distances, because it doesn’t consider Earth’s curved shape. That’s
    where the *haversine formula* comes in. It calculates the shortest distance between
    two points on the surface of a sphere using the latitude and longitude coordinates
    of the points. In the case of Earth, the formula isn’t totally accurate, since
    Earth isn’t perfectly spherical, but it still offers a reasonable distance approximation
    for many practical applications, including in navigation, astronomy, and geography.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用毕达哥拉斯定理来计算同一平面上点与点之间的距离。然而，对于地球表面的点，这种方法在长距离上不够准确，因为它没有考虑地球的曲面形状。这就是*哈弗森公式*的作用所在。它利用点的纬度和经度坐标计算球面上两点之间的最短距离。就地球而言，公式并不是完全准确的，因为地球并非完美的球形，但它仍为许多实际应用提供了合理的距离近似，包括导航、天文学和地理学。
- en: The haversine formula revolves around the concept of a *great circle*, the largest
    circle that can be drawn on a sphere. It’s formed by the intersection of the sphere’s
    surface with a plane that passes through the sphere’s center. The great circle
    divides the sphere into two equal halves, and its circumference matches the circumference
    of the sphere itself.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 哈弗森公式围绕着*大圆*的概念展开，大圆是可以在球面上绘制的最大圆。它是球面与通过球心的平面相交所形成的。大圆将球面分成两半，其周长与球体的周长相同。
- en: '[Figure 4-5](chapter4.xhtml#fig4-5) showcases two prominent great circles:
    the equator and the prime meridian. The equator acts as a dividing line between
    the northern and southern hemispheres, while the prime meridian (which passes
    through Greenwich, England) separates the Eastern and Western Hemispheres on Earth’s
    surface. These two great circles serve as references for latitude and longitude,
    which together define the locations of points on Earth’s surface.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-5](chapter4.xhtml#fig4-5)展示了两个显著的大圆：赤道和本初子午线。赤道作为南北半球的分界线，而本初子午线（经过英国格林威治）将地球表面分为东西半球。这两个大圆作为纬度和经度的参考，它们共同定义了地球表面点的位置。'
- en: '![](../images/Figure4-5.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-5.jpg)'
- en: 'Figure 4-5: The latitude and longitude of a point P'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5：点P的纬度和经度
- en: '*Latitude* measures the distance north or south of the equator. It’s expressed
    in degrees, with the equator being 0 degrees latitude, the North Pole 90 degrees
    north (90°N), and the South Pole 90 degrees south (90°S). In [Figure 4-5](chapter4.xhtml#fig4-5),
    the latitude of point P would be denoted as *φ*°N, as it lies *φ* degrees north
    of the equator along a great circle that intersects with P and the North Pole.
    *Longitude* measures the distance east or west of the prime meridian. The prime
    meridian itself has a longitude of 0 degrees, and longitude values range from
    –180 degrees west of the prime meridian to 180 degrees east of the prime meridian.
    In the case of point P, its longitude would be *λ*°E, indicating its great circle
    is *λ* degrees east of the prime meridian.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*纬度*衡量的是距离赤道的南北位置。它以度数表示，赤道的纬度为0度，北极为90度北（90°N），南极为90度南（90°S）。在[图 4-5](chapter4.xhtml#fig4-5)中，点P的纬度表示为*φ*°N，因为它位于赤道以北*φ*度，沿着与P和北极相交的最大圆圈。*经度*衡量的是距离本初子午线的东西位置。本初子午线本身的经度为0度，经度值的范围从本初子午线以西180度到本初子午线以东180度。对于点P，其经度表示为*λ*°E，表示其最大圆圈位于本初子午线以东*λ*度。'
- en: NOTE
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You may be used to seeing all latitude and longitude values expressed as positive
    numbers, but for the haversine formula to work, southern latitudes and western
    longitudes must be negative. Our program will automatically convert coordinates
    that don’t follow this convention.*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能习惯于看到所有的纬度和经度值都表示为正数，但为了使哈弗森公式有效，南纬和西经必须为负值。我们的程序会自动转换不符合此惯例的坐标。*'
- en: 'Given any two points on the surface of a sphere, you can draw a great circle
    that intersects with both points, and that great circle will define the shortest
    path between the two points. If you know the angle *θ* (in radians) between the
    points—that is, the angle formed at the sphere’s center by the arc connecting
    the points—and if you know the radius *r* of the sphere, you can calculate the
    distance along the sphere’s surface between the two points as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 给定球面上任意两点，你可以绘制一条大圆，这条大圆与两点相交，并且这条大圆会定义两点之间的最短路径。如果你知道两点之间的角度 *θ*（单位为弧度），即连接两点的弧线所形成的角度，并且知道球面的半径
    *r*，那么你就可以按照以下公式计算球面上两点之间的距离：
- en: $Equation$ (4.5) ![](../images/eq4-5.jpg)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ (4.5) ![](../images/eq4-5.jpg)
- en: 'In the case of Earth, we know the radius *R* to be about 6,371.009 kilometers,
    but how do we know the angle between two points on Earth’s surface? This is where
    the haversine formula comes in. It uses the points’ latitude and longitude coordinates,
    and a bit of trigonometry, to determine that angle, which in turn lets us calculate
    the distance between the points. The formula involves a little-known trigonometric
    function called the haversine function. The haversine of an angle *θ* is defined
    as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在地球的情况下，我们知道半径 * R * 大约为 6,371.009 公里，但我们如何知道地球表面两点之间的角度呢？这就是哈弗斯公式的作用。它使用两点的纬度和经度坐标，并通过一些三角学原理来确定这个角度，从而帮助我们计算两点之间的距离。该公式涉及一个鲜为人知的三角函数，叫做哈弗正弦函数。一个角度
    *θ* 的哈弗正弦定义如下：
- en: $Equation$ (4.6) ![](../images/eq4-6.jpg)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ (4.6) ![](../images/eq4-6.jpg)
- en: 'The haversine formula calculates *a*, the haversine of the angle between two
    points on Earth’s surface, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈弗斯公式**计算了* a *，即地球表面两点之间角度的哈弗正弦，公式如下：'
- en: '*  a* = hav(*φ*[2] – *φ*[1]) + cos(*φ*[1]) cos(*φ*[2]) hav(*λ*[2] – *λ*[1])'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*  a* = hav(*φ*[2] – *φ*[1]) + cos(*φ*[1]) cos(*φ*[2]) hav(*λ*[2] – *λ*[1])'
- en: Here (*φ*[1], *λ*[1]) and (*φ*[2], *λ*[2]) are the latitude and longitude coordinates
    of the two points, expressed in radians. To convert from degrees to radians, simply
    multiply by π and divide by 180.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 (*φ*[1], *λ*[1]) 和 (*φ*[2], *λ*[2]) 是两点的纬度和经度坐标，单位是弧度。要将角度转换为弧度，只需将角度乘以π，再除以180。
- en: 'We now have the haversine of the angle between the two points, but not the
    angle itself. For that, we can use the *a* we just calculated and the definition
    of haversine (Equation 4.6) to solve for the arc angle *c*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在得到了两点之间角度的哈弗正弦，但还没有得到实际的角度。为此，我们可以使用刚刚计算出的 *a* 和哈弗正弦的定义（方程式 4.6）来求解弧度角度
    *c*：
- en: $Equation$ ![](../images/pg150-1.jpg)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ ![](../images/pg150-1.jpg)
- en: 'Now that we have the angle *c*, we have everything we need to calculate the
    distance between the points using Equation 4.5:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了角度 *c*，我们拥有了使用方程式 4.5 计算两点之间距离所需的所有信息：
- en: '*  d* = *Rc*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*  d* = *Rc*'
- en: 'There’s one catch, however: *d* works out to a real number only when 0 ≤ *a*
    ≤ 1, but sometimes *a* can be pushed outside this range due to a floating-point
    error. To avoid this, we should instead express *c* as:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题：* d * 只有在 0 ≤ * a * ≤ 1 时才会是一个实数，但有时由于浮点错误，* a * 可能会超出这个范围。为避免这种情况，我们应该将
    * c * 表达为：
- en: $Equation$ ![](../images/pg150-2.jpg)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ ![](../images/pg150-2.jpg)
- en: This constrains the value of *a* to a range from 0 to 1, preventing any unrealistic
    results.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 *a* 的值限制在 0 到 1 的范围内，从而避免不现实的结果。
- en: The Code
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'We now have everything we need to write a Kotlin program that calculates the
    shortest distance between two locations on Earth. For this example, I’ve hardcoded
    the locations of two well-known landmarks, Big Ben in London and the Statue of
    Liberty in New York, but you can use any locations you want. The code consists
    of four main segments: an import block and global declarations, the main() function,
    the printLatLong() function, and the haversineDistance() function. I’ll discuss
    them in the same order.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了编写 Kotlin 程序的所有信息，以计算地球上两地之间的最短距离。为了举例，我硬编码了伦敦的“大本钟”和纽约的“自由女神像”的位置，但你可以使用任何你想要的位置。代码由四个主要部分组成：导入块和全局声明、main()
    函数、printLatLong() 函数和 haversineDistance() 函数。我会按这个顺序讨论它们。
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since the haversine formula needs to use quite a few math functions, we begin
    by importing those from the kotlin.math package. Next, we declare a data class
    Location with five properties: name (the name of the location), lat (the latitude),
    latDir (the direction of the latitude), lon (the longitude), and lonDir (the direction
    of the longitude). We then create two Location objects, L1 and L2, representing
    Big Ben and the Statue of Liberty. We store them together in a list called locations
    so we can efficiently iterate over the locations.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 haversine 公式需要使用许多数学函数，我们首先从 kotlin.math 包导入这些函数。接着，我们声明一个数据类 Location，包含五个属性：name（位置名称）、lat（纬度）、latDir（纬度方向）、lon（经度）和
    lonDir（经度方向）。然后，我们创建了两个 Location 对象，L1 和 L2，分别代表大本钟和自由女神像。我们将它们存储在一个名为 locations
    的列表中，以便可以高效地遍历这些位置。
- en: Notice that I’ve provided the latitude and longitude values as positive numbers
    in degrees, regardless of which direction they’re in. I’m relying on the latDir
    and lonDir properties to communicate that extra information. The convention is
    N for north, S for south, E for east, and W for west. In cases where the latitude
    or longitude of a location is exactly 0, the corresponding direction can be set
    to EQ (equator) or PM (prime meridian), although this won’t impact the final result.
    Later, in the haversineDistance() function, we ensure that when the lat or lon
    direction is S or W, respectively, the corresponding values are always negative
    ❶.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我提供的纬度和经度值是正数，不管它们所在的方向。我依赖 latDir 和 lonDir 属性来传达这些额外信息。约定是，N 代表北，S 代表南，E
    代表东，W 代表西。对于纬度或经度值为 0 的情况，相应的方向可以设置为 EQ（赤道）或 PM（本初子午线），虽然这不会影响最终结果。在后面的 haversineDistance()
    函数中，我们确保当纬度或经度的方向分别为 S 或 W 时，对应的值始终为负 ❶。
- en: The main() function prints the provided latitude and longitude values before
    and after adjustments (if any) using the printLatLong() function, makes a single
    call to the haversineDistance() function, and prints the result.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: main() 函数在调用 printLatLong() 函数后，打印出调整前后的纬度和经度值（如果有调整），然后调用一次 haversineDistance()
    函数，并打印结果。
- en: The printLatLong() function takes one argument, category, which is of type String.
    The category parameter is passed to a when block to determine which of two messages
    to print, indicating whether the coordinates have been adjusted for their direction
    properties. The locations themselves are then printed one at a time using the
    forEach() method of the locationsToPrint list. We could have used a regular for
    loop here, but some Kotlin enthusiasts consider forEach() to be more idiomatic.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: printLatLong() 函数接受一个参数，category，它是 String 类型。category 参数传递给一个 when 语句块，用于确定打印哪条消息，表示坐标是否已根据其方向属性进行了调整。然后，使用
    locationsToPrint 列表的 forEach() 方法逐一打印位置。我们本可以在这里使用常规的 for 循环，但一些 Kotlin 爱好者认为
    forEach() 更符合惯用法。
- en: Finally, the haversineDistance() function calculates the shortest distance between
    the two locations on a spherical surface. It first iterates over the locations
    and negates the latitudes and longitudes if needed ❶, then converts all the latitude
    and longitude values from degrees to radians. Next, it steps through the equations
    we discussed on [page 150](#pg_150), using the coordinates to calculate *a* ❷,
    using *a* (constrained to between 0 and 1) to calculate the angle *c* ❸, and using
    *c* to calculate and return the haversine distance *d* between the points ❹.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，haversineDistance() 函数计算了两点在球面上的最短距离。它首先遍历位置，如果需要的话，将纬度和经度取反 ❶，然后将所有的纬度和经度值从度数转换为弧度。接下来，它按照我们在[第150页](#pg_150)讨论的公式，使用坐标计算
    *a* ❷，用 *a*（限制在0到1之间）计算角度 *c* ❸，最后使用 *c* 计算并返回两点之间的 haversine 距离 *d* ❹。
- en: The Result
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'When you run the program for the set location and parameter values, the output
    should appear as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序，使用设定的地点和参数值时，输出应如下所示：
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As mentioned on [page 148](#pg_148), the haversine calculation assumes that
    Earth is a perfect sphere, which is not true. In fact, Earth is an oblate spheroid,
    slightly flattened at the poles and bulging at the equator. To get around this
    wrinkle, you could use Vincenty’s formula, which takes into account the oblate
    spheroidal shape of Earth by considering Earth’s equatorial and polar diameters.
    Which formula to use really depends on the nature of the problem, as both methods
    have their strengths and their weaknesses.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第148页](#pg_148)中提到的，哈弗辛计算假设地球是一个完美的球体，但事实并非如此。实际上，地球是一个扁球体，极地稍微扁平，赤道稍微膨胀。为了绕过这个问题，你可以使用文森提公式，它通过考虑地球的赤道和极地直径来考虑地球的扁球形状。使用哪个公式实际上取决于问题的性质，因为这两种方法各有优缺点。
- en: 'Project 15: Do Encryption with the Hill Cipher'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 项目15：使用Hill密码进行加密
- en: In today’s interconnected world, we constantly share sensitive data like personal
    information, financial details, and confidential messages. What’s to stop unauthorized
    parties from accessing that information? The answer is *encryption*, a set of
    techniques for scrambling our data into gibberish that can be deciphered only
    with the right key. Encryption protects our privacy, safeguards against hackers
    and cybercriminals, and secures our online transactions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天这个互联互通的世界中，我们不断地分享敏感数据，如个人信息、财务细节和机密消息。有什么能阻止未经授权的人员访问这些信息呢？答案是*加密*，一套将我们的数据混淆成乱码的技术，只有使用正确的密钥才能解密。加密保护我们的隐私，防止黑客和网络犯罪分子，保障我们的在线交易安全。
- en: There are a variety of encryption algorithms in use today. In this project,
    we’ll focus on a particular algorithm called the Hill cipher, developed by American
    mathematician Lester S. Hill in 1929\. According to this method, the *plaintext*
    (text in plain English or any other language) is divided into blocks of fixed
    size and represented as vectors. These vectors are then multiplied by a square
    matrix called the *encryption key*, modulo a specified number, to obtain the *ciphertext*
    (encrypted text). For decryption, the ciphertext vectors are multiplied by the
    inverse of the encryption key matrix, modulo the same specified number.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有各种各样的加密算法在使用中。在本项目中，我们将重点关注一种名为Hill密码的算法，该算法由美国数学家Lester S. Hill于1929年开发。根据这种方法，*明文*（英文或任何其他语言的文本）被分割成固定大小的块，并表示为向量。然后，这些向量与一个称为*加密密钥*的方阵相乘，并模以指定的数字，从而获得*密文*（加密后的文本）。对于解密，密文向量与加密密钥矩阵的逆矩阵相乘，并模以相同的指定数字。
- en: Hill’s encryption method can be vulnerable to attacks if we don’t choose the
    encryption key matrix carefully. While it’s no longer employed as the sole encryption
    mechanism, it can still be incorporated into more sophisticated methods and remains
    a valuable concept to grasp. Plus, exploring Hill’s method provides an excellent
    opportunity to apply and enhance our coding skills in the crucial field of cryptography.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有小心选择加密密钥矩阵，Hill加密方法可能会受到攻击。虽然它不再作为唯一的加密机制使用，但仍然可以被融入到更复杂的方法中，并且仍然是一个值得掌握的有价值的概念。而且，探索Hill方法为我们提供了一个应用和提高加密领域编程技能的绝佳机会。
- en: How It Works
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The Hill cipher revolves around concepts from linear algebra and modulo operations.
    I don’t expect you to have an in-depth knowledge of these areas of mathematics,
    but you may wish to review these topics to gain a better insight into how the
    Hill cipher actually works, as well as its strengths and weaknesses. Here are
    brief definitions of the key terms that we’ll use in this project:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Hill密码围绕线性代数和模运算的概念展开。我不指望你对这些数学领域有深入的了解，但你可能希望复习这些主题，以更好地理解Hill密码的实际工作原理，以及它的优缺点。以下是我们将在本项目中使用的关键术语的简要定义：
- en: '**Vector**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量**'
- en: A one-dimensional sequence of values. For example, [1, 3, 5] is a row vector
    with three elements.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一维的数值序列。例如，[1, 3, 5]是一个具有三个元素的行向量。
- en: '**Matrix**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**矩阵**'
- en: A two-dimensional collection of values, arranged in rows and columns. For example,
    a 3×3 matrix has three rows and three columns, and a total of nine elements (numbers)
    that can be real or complex.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一个二维的数值集合，按行和列排列。例如，一个3×3的矩阵有三行三列，总共有九个元素（数字），这些元素可以是实数或复数。
- en: '**Determinant**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**行列式**'
- en: 'A single value calculated using the elements of a matrix. The matrix must be
    square, meaning it has the same number of rows and columns. Say we have the following
    square matrix A:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵元素计算的单一值。矩阵必须是方阵，即行数和列数相同。假设我们有以下方阵A：
- en: $Equation$ ![](../images/pg155-1.jpg)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ ![](../images/pg155-1.jpg)
- en: 'Its determinant, denoted by det(A), det A, or |A|, can be calculated as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它的行列式，表示为det(A)、det A或|A|，可以按以下方式计算：
- en: det(*A*) = *aei* + *bfg* + *cdh* – *ceg* – *bdi* – *afh*
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: det(*A*) = *aei* + *bfg* + *cdh* – *ceg* – *bdi* – *afh*
- en: '**Identity matrix**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**单位矩阵**'
- en: 'A square matrix, often denoted as I, where all the elements along a diagonal
    from the top left to the bottom right have a value of 1 and all other elements
    have a value of 0\. A 3×3 identity matrix looks like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方阵，通常表示为I，所有从左上到右下的对角线元素值为1，其他所有元素值为0。一个3×3的单位矩阵看起来像这样：
- en: $Equation$ ![](../images/pg155-2.jpg)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ ![](../images/pg155-2.jpg)
- en: '**Inverse matrix**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**逆矩阵**'
- en: For a given matrix A, its inverse A^(–1) is another matrix such that multiplying
    the two matrices results in the identity matrix (that is, AA^(–1) = I). A matrix
    must be square to have an inverse, although not all square matrices have one.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的矩阵A，它的逆矩阵A^(–1)是另一个矩阵，满足将这两个矩阵相乘的结果是单位矩阵（即，AA^(–1) = I）。矩阵必须是方阵才能有逆矩阵，尽管并不是所有方阵都有逆矩阵。
- en: '**Modulo**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**模**'
- en: An operation represented by the symbol % that finds the remainder when one number
    is divided by another. For example, 5 % 2 is 1\. Modulo (mod for short) is a multipurpose
    operator used in various applications, such as determining divisibility, cycling
    through a range of values, and handling periodic patterns. Hill’s algorithm relies
    on the modulo operation to keep the encrypted and decrypted texts within the same
    alphabet as the plaintext. Thus, the size of the alphabet serves as the base or
    modulus (the number after the % operator) for these operations, guaranteeing valid
    ciphertext and plaintext representations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由符号%表示的运算，表示在一个数字被另一个数字除时所得到的余数。例如，5 % 2是1。模（简称mod）是一个多用途的运算符，用于各种应用，如确定可除性、循环通过一系列值以及处理周期性模式。Hill算法依赖于模运算来保持加密和解密文本与明文处于相同的字母表中。因此，字母表的大小作为这些操作的基数或模数（%运算符后的数字），保证了有效的密文和明文表示。
- en: '**Modular multiplicative inverse (MMI)**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**模逆（MMI）**'
- en: For a given integer a and a modulus m, the MMI is positive integer x such that
    ax % m = 1\. The value of x must be less than the modulus. For example, the MMI
    for 5 modulo 11 is 9, because (5 * 9) % 11 = 1, and 9 is less than 11.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的整数a和模数m，MMI是正整数x，使得ax % m = 1。x的值必须小于模数。例如，5模11的MMI是9，因为(5 * 9) % 11 =
    1，并且9小于11。
- en: Armed with these definitions, let’s now dive into the core encryption and decryption
    steps employed by the Hill cipher and highlight some of our Kotlin implementation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借这些定义，让我们现在深入探讨Hill密码所采用的核心加密和解密步骤，并突出我们Kotlin实现中的一些内容。
- en: For Encryption
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 用于加密
- en: 1.  Define the alphabet. Choose which letters are to be used for writing plain
    and encrypted messages. For messages written in English, the alphabet size should
    be at least 26 to include all lowercase letters. We’ll also include a period,
    a space, and a question mark, giving us an alphabet of 29 characters total. The
    size of the alphabet serves as the modulus.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  定义字母表。选择用于书写明文和加密消息的字母。对于用英语写的消息，字母表大小应该至少为26，以包括所有小写字母。我们还将包括句号、空格和问号，得到一个包含29个字符的字母表。字母表的大小作为模数。
- en: 2.  Choose a block size. During encryption and decryption, the message is divided
    into small blocks of characters, each of the same length. In this exercise, we’ll
    have three characters per block.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  选择一个块大小。在加密和解密过程中，消息被分割成小块，每块字符长度相同。在本练习中，我们每块有三个字符。
- en: '3.  Generate the encryption key matrix. For the purposes of this project, I’ve
    generated the encryption key matrix for you, but if you’re curious, it must adhere
    to these rules:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  生成加密密钥矩阵。对于本项目，我已经为你生成了加密密钥矩阵，但如果你有兴趣，它必须遵循以下规则：
- en: a.  The matrix must be square and have the same dimension as the block size
    chosen in step 2\. In this case, with a block size of 3, we need a 3×3 matrix.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: a.  矩阵必须是方阵，并且具有与第2步中选择的块大小相同的维度。在本例中，块大小为3，因此我们需要一个3×3的矩阵。
- en: b.  The determinant of the matrix can’t be 0.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: b.  矩阵的行列式不能为0。
- en: c.  The determinant must not share a factor, other than 1, with the modulus
    from step 1.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: c.  行列式必须与步骤1中的模数没有其他公因子，除了1以外。
- en: 4.  Prepare the plaintext. Divide the plaintext message into blocks based on
    the chosen block size. If the last block is smaller than the fixed size, pad it
    with filler characters. We’ll use spaces for padding to ensure that the message
    remains the same after decryption, with no extra visible characters.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  准备明文。根据所选的块大小将明文消息划分为块。如果最后一个块小于固定大小，则用填充字符填充它。我们将使用空格进行填充，以确保解密后消息保持不变，不会有额外的可见字符。
- en: 5.  Create vectors from the plaintext. Each block of the plaintext must be converted
    into a numerical vector with the same length as the block size. To assign numerical
    values to characters, we’ll save the alphabet in a single String object. We can
    then map each character in the plaintext to that character’s corresponding index
    in the string. For example, a will be mapped to 0, b to 1, and so on. This way,
    the block cab will become (2, 0, 1), a vector of size 3.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  从明文创建向量。每个明文块必须转换为一个与块大小相同长度的数值向量。为了给字符分配数值，我们将字母表保存在一个单一的字符串对象中。然后，我们可以将明文中的每个字符映射到该字符在字符串中的对应索引。例如，a将映射到0，b映射到1，依此类推。这样，块cab将变成（2,
    0, 1），一个大小为3的向量。
- en: '6.  Encrypt the message. For each block, carry out the following steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  加密消息。对于每个块，执行以下步骤：
- en: a.  Multiply the block’s plaintext vector by the key matrix, modulo 29, to generate
    a ciphertext vector.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: a.  将块的明文向量与密钥矩阵相乘，模29，生成一个密文向量。
- en: b.  Convert the numerical values in the ciphertext vector back to text characters
    using the reverse mapping scheme.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: b.  使用反向映射方案将密文向量中的数值转换回文本字符。
- en: c.  Add the ciphered characters to a mutable list of characters, which will
    become the encrypted message (ciphertext) once all the blocks have been processed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: c.  将加密后的字符添加到可变字符列表中，一旦所有块处理完毕，这些字符将成为加密消息（密文）。
- en: For Decryption
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对于解密
- en: 1.  Generate the decryption key matrix. To decipher the encrypted text, we must
    first create the inverse of the encryption key matrix modulo the specified number.
    This process involves multiple linear algebraic steps and modulo operations; for
    simplicity, I’ve provided the inverse matrix. If you want to work with a different
    set of key and inverse matrices, you can look up the online tools that will generate
    those for you.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  生成解密密钥矩阵。为了解密加密文本，我们必须首先创建加密密钥矩阵的逆矩阵，模指定的数值。此过程涉及多个线性代数步骤和模运算；为了简化，我提供了逆矩阵。如果你想使用不同的密钥和逆矩阵，可以查找在线工具来为你生成。
- en: 2.  Prepare the ciphertext. Divide the ciphertext into blocks of the specified
    size used during encryption (3 for this project). This time, no padding is needed,
    since the padding was already done during encryption.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  准备密文。将密文划分为加密时使用的指定大小的块（此项目为3）。这次不需要填充，因为填充已在加密时完成。
- en: 3.  Create vectors from the ciphertext. Use the same character-numbering scheme
    to convert the ciphertext blocks into ciphertext vectors of size 3.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  从密文创建向量。使用相同的字符编号方案将密文块转换为大小为3的密文向量。
- en: '4.  Decrypt the message. For each block, carry out the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  解密消息。对于每个块，执行以下步骤：
- en: a.  Multiply the ciphertext vector by the decryption key matrix, modulo 29,
    to generate a deciphered vector.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: a.  将密文向量与解密密钥矩阵相乘，模29，生成一个解密向量。
- en: b.  Convert the numerical values in the deciphered vector back to text characters
    using the reverse mapping scheme.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: b.  使用反向映射方案将解密向量中的数值转换回文本字符。
- en: c.  Add the deciphered characters to a mutable list of characters, which will
    become the decrypted message (plaintext) once all the blocks have been processed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: c.  将解密后的字符添加到可变字符列表中，一旦所有块处理完毕，这些字符将成为解密消息（明文）。
- en: Finally, keep in mind that it’s customary to pick an encryption key matrix made
    up of only integers, preferably falling between 0 and the modulus.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，通常会选择仅由整数构成的加密密钥矩阵，最好是在0和模数之间。
- en: The Code
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: We’re ready to implement the Kotlin code for Hill’s encryption and decryption
    method. The code is organized in a top-down manner, starting with global declarations,
    continuing with the main() function, and ending with a series of short helper
    functions. We’ll review everything in sequence.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备实现 Hill 加密和解密方法的 Kotlin 代码。代码按照自上而下的顺序组织，从全局声明开始，接着是 main() 函数，最后是一些简短的辅助函数。我们将按顺序回顾一切。
- en: Variables and Data Structures
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 变量和数据结构
- en: We begin by declaring the variables and data structures needed to implement
    Hill’s method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明实现 Hill 方法所需的变量和数据结构。
- en: '[PRE18]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we create the matrices for encryption and decryption (key and keyInv).
    For this project, we’ll accept these as given, but you can use online tools to
    create a different encryption key matrix that meets the required conditions and
    calculate the corresponding inverse matrix. The size of these square matrices
    is captured in the parameter dim, which is later used as the block size for processing
    messages. We also define a string called alphabet that stores all the valid letters
    that can be used in the plaintext and ciphertext.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建加密和解密的矩阵（key 和 keyInv）。对于这个项目，我们将这些矩阵视为给定的，但你可以使用在线工具创建一个符合要求条件的加密密钥矩阵，并计算出相应的逆矩阵。这些方阵的大小由参数
    dim 表示，后续会作为处理消息的块大小。我们还定义了一个字符串 alphabet，用来存储所有可以在明文和密文中使用的有效字母。
- en: Next, we introduce a data class called Block, which we’ll use to store the text
    blocks generated while processing the message. These blocks will be stored as
    a mutable list named blocks. We also create a few other collections to temporarily
    hold and manipulate the vectors created during encryption and decryption operations,
    along with a mutable list named processedText to store the final list of characters.
    Since the encryption and decryption processes are very similar, we’ll be able
    to use these variables and collections during both processes to store the intermediate
    and final values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们引入一个名为 Block 的数据类，用于存储在处理消息时生成的文本块。这些块将作为一个可变列表 blocks 存储。我们还创建了一些其他集合，用于暂时保存和操作加密和解密过程中创建的向量，同时创建了一个名为
    processedText 的可变列表，用于存储最终的字符列表。由于加密和解密过程非常相似，我们可以在这两个过程中使用这些变量和集合来存储中间值和最终值。
- en: The main() Function
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: main() 函数
- en: The main() function calls a series of helper functions to coordinate the overall
    encryption or decryption process.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: main() 函数调用一系列辅助函数来协调整体的加密或解密过程。
- en: '[PRE19]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In main(), we first call the runValidation() function, which uses matrix multiplication
    (mod 29) to ensure that the encryption and decryption matrices are valid. We then
    prompt the user to choose which operation to carry out: encryption (enter 1) or
    decryption (enter 2). Based on the choice, we use a when block ❶ to implement
    the steps to encrypt or decrypt a message.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main() 中，我们首先调用 runValidation() 函数，它通过矩阵乘法（模 29）确保加密和解密矩阵是有效的。然后，我们提示用户选择要执行的操作：加密（输入
    1）或解密（输入 2）。根据选择，我们使用 when 块 ❶ 实现加密或解密消息的步骤。
- en: For both choices, we start with the getText() function, which takes in the message
    to be encrypted or decrypted from the user as a text string and divides it into
    blocks. We then call encrypt() or decrypt(), depending on the choice made earlier.
    Finally, we display the result with help from the printProcessedText() function.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两种选择，我们从 getText() 函数开始，该函数接收用户输入的要加密或解密的消息字符串，并将其分成块。然后，根据之前的选择，我们调用 encrypt()
    或 decrypt() 函数。最后，我们借助 printProcessedText() 函数显示结果。
- en: The Helper Functions
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 辅助函数
- en: There are several helper functions called from within the main() function. We’ll
    turn to those next, starting with the functions that help validate the matrices.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main() 函数中有几个辅助函数被调用。我们接下来会介绍这些函数，从帮助验证矩阵的函数开始。
- en: '[PRE20]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The runValidation() function displays the size of the key matrices. It then
    calls multiplyMatricesMod29() to do the validation check and shows the results
    with displayProduct(). The matrices are considered valid if one is the inverse
    of the other, modulo 29\. If this is the case, the product of the two matrices,
    modulo 29, should be an identity matrix where all elements are zeros, except for
    ones along the diagonal from the top left to the bottom right.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: runValidation()函数显示密钥矩阵的大小。然后，它调用multiplyMatricesMod29()进行验证检查，并使用displayProduct()显示结果。如果两个矩阵是互为逆矩阵（模29），则它们的乘积模29应为单位矩阵，除了从左上到右下对角线上的1，其余元素应为0。
- en: In multiplyMatricesMod29(), we test this out, using three nested for loops to
    multiply the encryption and decryption key matrices, taking modulo 29 of each
    resulting value before putting it in the product matrix ❶. See the “Multiplying
    Two Matrices” box for details about the math behind this process.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在multiplyMatricesMod29()中，我们使用三层嵌套的for循环测试这一点，分别对加密和解密密钥矩阵进行乘法操作，并在将结果放入产品矩阵之前，对每个计算结果取模29❶。有关该过程背后数学原理的详细信息，请参见“矩阵乘法”框。
- en: The displayProduct() function neatly formats and prints the contents of the
    product matrix. As you’ll later see in the example output, the result should indeed
    be an identity matrix.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: displayProduct()函数整齐地格式化并打印产品矩阵的内容。正如你稍后在示例输出中看到的，结果确实应该是一个单位矩阵。
- en: 'Here’s the getText() function, which we call from main() at the start of the
    encryption or decryption process:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是getText()函数，我们在加密或解密过程开始时从main()中调用：
- en: '[PRE21]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The function uses readln() to take in the plaintext or ciphertext from the user.
    We convert all the characters to lowercase since we have only lowercase letters
    in our alphabet. We then check if the input string is divisible by 3 ❶ and pad
    it with spaces if not. Finally, we use a for loop with a step size of 3 to break
    the text into three-character blocks. Each one is stored in a Block object and
    added to the blocks mutable list.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用readln()从用户那里获取明文或密文。我们将所有字符转换为小写，因为我们的字母表中只有小写字母。然后，我们检查输入字符串是否可以被3整除❶，如果不能，则用空格填充它。最后，我们使用步长为3的for循环将文本拆分成三个字符的块。每个块存储在一个Block对象中，并添加到blocks可变列表中。
- en: The remainder of the helper functions do the work of actually encrypting and
    decrypting the text.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的助手函数实际执行加密和解密文本的工作。
- en: '[PRE22]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The encrypt() and decrypt() functions both iterate through the Block objects
    in the blocks list and call a series of helpers to process them. The first helper
    called is the getIndexBlock() function, which looks up each character’s index
    in the alphabet string, thereby converting each character to an integer. The values
    are stored in the indexVector array.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: encrypt()和decrypt()函数都会遍历blocks列表中的Block对象，并调用一系列助手函数对它们进行处理。第一个调用的助手是getIndexBlock()函数，它查找每个字符在字母表字符串中的索引，从而将每个字符转换为整数。该值存储在indexVector数组中。
- en: Next, we call encryptIndexBlock() or decryptIndexBlock(), which converts the
    plaintext vector into a cipher (encrypted) vector or vice versa by multiplying
    the vector by the appropriate matrix (key or keyInv), modulo 29\. Multiplying
    a vector by a matrix is much like multiplying two matrices, but in this case,
    we need only two levels of for loops. The result goes in the processedVector array.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用encryptIndexBlock()或decryptIndexBlock()，通过将向量乘以相应的矩阵（key或keyInv），对明文向量进行加密，或将密文向量解密，结果取模29。将向量乘以矩阵就像是矩阵乘法，但在这种情况下，我们只需要两层for循环。结果存储在processedVector数组中。
- en: Our last encryption and decryption helper is the addToProcessedText() function,
    which takes each number from the processedVector array, looks up the corresponding
    character from the alphabet string, and adds that character to processedText,
    a mutable list. In the end, once all the vectors are processed, this list contains
    the final encrypted or decrypted text. Back in main(), we call the printProcessedText()
    function, which concatenates all the characters stored in the processedText list
    into a single string for easy printing.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的加密和解密助手是addToProcessedText()函数，它从processedVector数组中取出每个数字，查找字母表字符串中对应的字符，并将该字符添加到processedText可变列表中。最后，当所有向量都处理完毕时，该列表包含最终的加密或解密文本。在main()中，我们调用printProcessedText()函数，将存储在processedText列表中的所有字符连接成一个字符串，方便打印。
- en: The Result
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'Here’s a sample run of the program in encryption mode:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序在加密模式下的一个示例运行：
- en: '[PRE23]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'First, notice the validation check: the product of the two matrices is indeed
    an identity matrix, with ones running along the diagonal and zeros everywhere
    else. Then notice the final output, where the program has turned the readable
    plaintext into unreadable gibberish. The process also works in reverse: if you
    choose the decryption option (enter 2) and input the encrypted text, the program
    will instantly convert the ciphertext back to the original plaintext.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意验证检查：两个矩阵的乘积确实是一个单位矩阵，主对角线上的元素为 1，其他地方全是 0。接着注意最终输出，程序已将可读的明文转换成不可读的乱码。这个过程也可以反向操作：如果选择解密选项（输入
    2）并输入加密文本，程序会立即将密文转换回原始明文。
- en: Currently, the final result is displayed in all lowercase letters. I invite
    you to improve the printProcessedText() function so that the final result is capitalized
    as needed before printing. If you’re thorough, you’ll soon realize that implementing
    a complete set of capitalization rules isn’t as simple as it sounds.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，最终结果以全小写字母显示。我邀请你改进 printProcessedText() 函数，以便在打印之前根据需要将最终结果大写。如果你细心的话，很快就会意识到实现一套完整的大写规则并不像听起来那么简单。
- en: 'Project 16: Simulate a One-Dimensional Random Walk'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 16：模拟一维随机漫步
- en: So far in this chapter, the projects have all been *deterministic*, meaning
    there’s a unique solution for a given set of input parameters. If we were to run
    the code multiple times with the same input, the output would remain unchanged.
    In this project, we’ll explore a different kind of problem, one that’s *stochastic*
    in nature. In a stochastic problem, the output for a given set of inputs isn’t
    predetermined. We may be aware of various possible outcomes, or a range within
    which the output will fall, but the specific value generated by an individual
    instance of the experiment is determined purely by chance. To illustrate this
    concept, we’ll probe the idea of a random walk.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中的所有项目都是*确定性的*，意味着对于一组给定的输入参数，有唯一的解决方案。如果我们多次使用相同的输入运行代码，输出将保持不变。在这个项目中，我们将探索另一种类型的问题，即*随机*性质的问题。在随机问题中，给定一组输入的输出是无法预先确定的。我们可能知道各种可能的结果，或者输出将落在某个范围内，但由实验实例生成的具体值完全由随机因素决定。为了说明这个概念，我们将探讨随机漫步的思想。
- en: A *random walk* is a process made up of a series of *random steps*, actions
    with multiple possible outcomes. We know the probability of each potential outcome,
    but the actual outcome is determined randomly. For example, rolling a die is a
    type of random step. Assuming the die is fair, each of its six sides will have
    the same likelihood of landing face up (one-sixth, or approximately 16.67 percent).
    Therefore, when we actually roll the die, we can’t know for sure what number we’ll
    get. Our guesses will be correct only 16.67 percent of the time.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机漫步*是一种由一系列*随机步伐*组成的过程，步骤有多种可能的结果。我们知道每个潜在结果的概率，但实际结果是随机决定的。例如，掷骰子就是一种随机步伐。假设骰子是公平的，那么它的六个面有相同的概率朝上（每面为六分之一，即约
    16.67%）。因此，当我们实际掷骰子时，我们不能确定会得到什么数字。我们的猜测只有 16.67% 的机会是正确的。'
- en: Random walks can be described using a *mathematical space* with a certain number
    of dimensions, depending on the nature of the random step. Let’s say we’re considering
    the movement of a heavily inebriated person who has just come out of a pub. The
    street in front of the pub runs east–west. This person is totally disoriented
    and is taking random steps along the street in both directions. We can mathematically
    describe the distance the person travels over time as the sum of individual steps
    along the x-direction (the x-axis being the east–west line). We could record each
    step toward the east as +1 and a step in the opposite direction as −1 (assuming
    all steps cover the same distance). This is an example of a one-dimensional random
    walk—we need only the x-axis to describe it mathematically.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 随机漫步可以使用一个*数学空间*来描述，空间的维度数取决于随机步伐的性质。假设我们在考虑一个刚刚从酒吧出来的醉酒者的运动。酒吧前的街道是东西走向的。这个人完全迷失方向，沿着街道朝两个方向随机走动。我们可以用数学方式描述这个人随时间走过的距离，即沿着
    x 方向的各个步伐之和（x 轴是东西走向的线）。我们可以记录每一个朝东的步伐为 +1，朝相反方向的步伐为 −1（假设每步的距离相同）。这是一个一维随机漫步的例子——我们只需要
    x 轴就可以在数学上描述它。
- en: Now suppose the person has been drinking in the middle of an open field and
    has started to wander randomly in different directions. The person’s steps can
    now have both an x-component (east or west) and a y-component (north or south).
    In this case, to measure the distance traveled from the center of the field, we’ll
    have to track the person’s movements in a two-dimensional space, which will make
    this a two-dimensional random walk problem.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设一个人正在一片开阔地中央喝酒，并开始随机地朝不同方向游走。这个人的步伐现在可以同时具有x分量（东或西）和y分量（南或北）。在这种情况下，为了测量从开阔地中心开始的移动距离，我们需要在二维空间中跟踪这个人的运动，这将使这个问题成为一个二维随机游走问题。
- en: A well-known example of a random walk is *Brownian motion*, named for Robert
    Brown, a 19th-century Scottish botanist. Using a microscope, Brown was observing
    grains of pollen immersed in water when he noticed that the grains were constantly
    moving in random directions. In fact, we can find similar movements whenever very
    small particles are injected in a fluid medium, such as dust or smoke particles
    in the air or the movement of particles in a colloidal suspension such as milk
    or paint. Brown’s observation was an important scientific discovery that remained
    unexplained for more than half a century until 1905, when Albert Einstein explained
    that Brownian motion was caused by the continuous bombardment of the pollen grains
    by the surrounding water molecules.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 随机游走的一个著名例子是*布朗运动*，以19世纪苏格兰植物学家罗伯特·布朗命名。布朗通过显微镜观察浸入水中的花粉颗粒时，发现这些颗粒不断地朝随机方向移动。事实上，每当极小的粒子被注入流体介质中时，我们都能观察到类似的运动，例如空气中的灰尘或烟雾粒子，或乳液或涂料等胶体悬浮液中的粒子运动。布朗的观察是一次重要的科学发现，直到1905年，爱因斯坦才解释了布朗运动是由于水分子不断撞击花粉颗粒所导致的。
- en: In this exercise, we’ll build and simulate a 1D random walk model in Kotlin.
    This will allow us to gain a deeper insight into how particles or objects move
    in one dimension through random steps. In particular, by repeating the simulation
    many times and plotting the results, we’ll be able to identify patterns and explore
    the statistical properties that underlie this dynamic behavior.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Kotlin构建并模拟一个一维随机游走模型。这将帮助我们更深入地理解粒子或物体如何通过随机步伐在一维空间中移动。特别地，通过多次重复模拟并绘制结果，我们能够识别出模式，并探索支撑这种动态行为的统计性质。
- en: A One-Dimensional Model
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一维模型
- en: Imagine a single particle moving randomly along a line in small steps. For simplicity’s
    sake, we’ll assume that the particle’s step size remains constant and that steps
    are made at steady time intervals (we do not need to use time as an explicit variable
    in our model). Physicists often call this scenario a *free diffusion* problem
    in one dimension. The process is schematically shown in [Figure 4-6](chapter4.xhtml#fig4-6).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个粒子在一条线上随机移动，步伐较小。为了简化问题，我们假设粒子的步长保持恒定，且步伐是在稳定的时间间隔内进行的（在我们的模型中不需要明确使用时间作为变量）。物理学家通常将这种情况称为*自由扩散*问题，在一维空间中。该过程的示意图见[图4-6](chapter4.xhtml#fig4-6)。
- en: '![](../images/Figure4-6.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-6.jpg)'
- en: 'Figure 4-6: A random walk in one dimension, starting at x = 0'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-6：从x = 0开始的一维随机游走
- en: The particle starts at location *x* = 0 and moves in discrete steps of length
    Δ*x* = ±1\. The direction of the particle’s movement is random, so its next position
    after 0 can be either 1 (with a displacement of +1) or 2 (with a displacement
    of −1). The probability *p* of choosing either direction is equal, so *p* = 0.5\.
    Notice that at any given location, the particle can change its direction, so it’s
    possible for the particle to take several random steps and end up back where it
    started.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子从位置*x* = 0开始，以离散的步长Δ*x* = ±1进行移动。粒子移动的方向是随机的，因此它在位置0后的下一位置可能是1（位移为+1）或2（位移为−1）。选择任一方向的概率*p*是相等的，因此*p*
    = 0.5。注意，在任何给定的位置，粒子都可以改变其方向，因此粒子可能会走几步随机的步伐，并最终回到起点。
- en: 'The question we’re interested in exploring is this: After making an arbitrary
    number of steps, *n*, how far on average will the particle have moved from its
    starting position? To answer this question, we’ll need to simulate many random
    walks—say, 500 walks of 1,000 steps each—and analyze the results. We can’t simply
    take the average of the cumulative distances traveled in the different simulations,
    however; the particle can drift in both the positive and negative x-directions,
    so the net-positive and net-negative distances would likely cancel each other
    out, giving us an average distance of roughly 0\. Instead, we’ll use the *root-mean-square
    (RMS) distance*, which is calculated in three steps:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的问题是：在进行任意步数*n*后，粒子从起始位置平均移动了多远？为了回答这个问题，我们需要模拟许多随机行走——例如，500次每次1000步的行走——并分析结果。然而，我们不能仅仅取不同模拟中累积行走距离的平均值；因为粒子可以在正负x方向上漂移，所以净正距离和净负距离很可能会相互抵消，导致我们得到一个大约为0的平均距离。相反，我们将使用*均方根（RMS）距离*，它通过以下三个步骤来计算：
- en: 1.  Square all the distances from all the simulations after a given number of
    steps n. This converts any negative numbers to positive numbers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  将所有模拟中在给定步数*n*后的距离平方。这将把任何负数转换为正数。
- en: 2.  Add all the results from step 1 and divide by the number of simulations
    to find the mean (average) of the squared distances.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将第一步的所有结果相加，然后除以模拟次数，求得平方距离的均值（平均值）。
- en: 3.  Take the square root of step 2’s result to arrive at the RMS distance.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  对第2步的结果取平方根，得到RMS距离。
- en: Based on past research conducted on one-dimensional random walks, we know that
    the RMS distance exhibits a nonlinear relationship with the number of steps taken;
    in theory, the RMS distance after the *n*th step should equal the square root
    of *n*. To validate this notion, we’ll compute the RMS distance (the *simulated*
    RMS) and the square root of *n* (the *theoretical* RMS) and plot them both against
    the number of steps, *n*. Hopefully, the two plots will be similar. We’ll also
    plot the mean distance traveled at each time step, which should remain close to
    0.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 根据过去在一维随机行走中的研究，我们知道RMS距离与步数之间存在非线性关系；理论上，第*n*步后的RMS距离应该等于*n*的平方根。为了验证这一观点，我们将计算RMS距离（*模拟*
    RMS）和*n*的平方根（*理论* RMS），并将它们与步数*n*绘制在同一图表上。希望这两条曲线能非常相似。我们还将绘制每个时间步的平均距离，这应该保持接近0。
- en: In a separate graph, we’ll visualize the trajectories of the 500 random walks
    themselves. This should help illustrate the random nature of the outcomes and
    give further support to our theories about the cumulative and RMS distances traveled.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个单独的图表中，我们将可视化500个随机行走的轨迹。这将有助于说明结果的随机性，并进一步支持我们关于累积和RMS行走距离的理论。
- en: The Code
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: I’ll present the code segments for this project in a top-down sequence, starting
    with some general setup code. Since we want to visualize the random walks from
    different simulations and examine the relationship between the cumulative, mean,
    and RMS distances with the number of steps, we’ll use the JavaFX template that
    we developed and used in [Chapter 3](chapter3.xhtml).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我将按照自上而下的顺序呈现该项目的代码段，从一些常规的设置代码开始。由于我们希望可视化不同模拟的随机行走，并且研究累积、均值和RMS距离与步数之间的关系，我们将使用在[第3章](chapter3.xhtml)中开发并使用的JavaFX模板。
- en: '[PRE24]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code segment starts with the import block. Since this project will use the
    XY charting features of JavaFX instead of the canvas feature, the import block
    is somewhat different from what we needed for [Project 13](chapter4.xhtml#pre-13),
    and it includes a few extra lines of code to import the Background, BackgroundFill,
    CornerRadii, and Insets features, which we’ll use to set the chart background
    to white.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 代码段从导入块开始。由于这个项目将使用JavaFX的XY图表功能，而不是画布功能，因此导入块与[第13章](chapter4.xhtml#pre-13)所需的有所不同，并且它包含了一些额外的代码行来导入Background、BackgroundFill、CornerRadii和Insets功能，这些将用于将图表背景设置为白色。
- en: 'Next, we declare a simple data class State ❶ for holding individual data points
    during the simulation. Its step property represents the number of steps taken
    since the beginning of the random walk, and dist is the cumulative distance traveled
    after that many steps. We then declare two global parameters: numStep, to specify
    the maximum number of steps per simulation, and numSim, to set the maximum number
    of simulations.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明了一个简单的数据类 State ❶，用于在模拟过程中保存单个数据点。它的 step 属性表示从随机行走开始以来所经过的步数，而 dist
    则是经过这么多步之后的累计行驶距离。然后，我们声明了两个全局参数：numStep，用于指定每个模拟的最大步数，和 numSim，用于设置模拟的最大数量。
- en: 'We’ll accumulate data in a number of lists ❷, each of size numStep and type
    State, as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把数据累积到多个列表 ❷ 中，每个列表的大小为 numStep，类型为 State，具体如下：
- en: xList Stores the cumulative distance traveled after each step for a particular
    simulation
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: xList 存储特定模拟中每一步的累计行进距离
- en: avgList Stores the arithmetic average (mean) of the cumulative distances traveled
    across all simulations after each step
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: avgList 存储所有模拟中每一步的累计距离的算术平均值（均值）
- en: rmsList Stores the RMS distance calculated across all simulations after each
    step
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: rmsList 存储所有模拟中每一步的 RMS 距离
- en: expList Stores the theoretical (exponential) RMS distance after each step
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: expList 存储每一步之后的理论（指数）RMS 距离
- en: All these lists are initialized to (0.0, 0.0), meaning all simulations start
    at step number 0 and position 0\. In addition to these lists, we also create two
    mutable lists, states1 and states2, which we’ll use for charting purposes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些列表都初始化为 (0.0, 0.0)，这意味着所有模拟从步骤 0 和位置 0 开始。除了这些列表之外，我们还创建了两个可变列表 states1
    和 states2，供绘图使用。
- en: Inside the RandomWalk1D application class, we use a VBox container ❸ to hold
    the chart objects, as we’ll generate two sets of charts that will be placed vertically
    inside the VBox. Notice the additional lines of code for setting the background
    of the container to white programmatically ❹, without using the cascading style
    sheets needed for more extensive customizations. We’ve also introduced the ScrollPane
    feature ❺, which will allow us to scroll the chart window to view the top or the
    bottom chart, as needed. We can also enlarge the window to make both charts visible
    at the same time.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RandomWalk1D 应用类内部，我们使用一个 VBox 容器 ❸ 来保存图表对象，因为我们将生成两组图表，它们将垂直放置在 VBox 中。注意额外的代码行，用于编程设置容器的背景为白色
    ❹，而不是使用需要更复杂自定义样式的层叠样式表（CSS）。我们还引入了 ScrollPane 功能 ❺，它允许我们滚动图表窗口，以查看顶部或底部的图表，按需查看。我们还可以放大窗口，以便同时查看两个图表。
- en: 'After setting up the graphics window, we call three custom functions that will
    run the simulation and help visualize the results. The first call is to the randomWalk1d()
    function, which simulates numSim one-dimensional random walks over numStep steps.
    Here’s how it works:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好图形窗口后，我们调用三个自定义函数来运行模拟并帮助可视化结果。第一次调用是 randomWalk1d() 函数，它模拟了 numSim 次一维随机行走，共进行
    numStep 步。它的工作方式如下：
- en: '[PRE25]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The function body starts by creating three local arrays of type DoubleArray.
    The first, s, is a two-dimensional array that stores the cumulative distance traveled
    at each step of each simulation ❶. The others are one-dimensional arrays, sumX
    and sumX2, to save the running sums of the cumulative distances at each step and
    the sums of squared distances at each step, respectively. We’ll use these values
    to get the mean and RMS distances.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体首先创建了三个类型为 DoubleArray 的局部数组。第一个，s，是一个二维数组，用于存储每个模拟中每一步的累计距离 ❶。其他两个是单维数组，sumX
    和 sumX2，分别用于保存每一步的累计距离的运行总和和每一步的平方距离的总和。我们将使用这些值来计算均值和 RMS 距离。
- en: The random walks are implemented inside a nested for loop. The outer loop controls
    the number of simulations, and the inner loop makes the particle take numStep
    steps in succession. During each step, a local variable draw is randomly set to
    either 0 or 1 with equal likelihood ❷. Based on the outcome, step (referred to
    as Δ*x* in [Figure 4-6](chapter4.xhtml#fig4-6)) is set to -1 or 1, which is then
    added to the cumulative distance traveled up to the previous step of the simulation
    ❸. These cumulative distances are used to create the elements of xList, which
    is then copied and passed on to states1 once per simulation ❹. Notice how we’re
    reusing the memory allocated for xList during each simulation by overwriting the
    values of its elements. In the end, states1 has all the data we need to visualize
    the random walks themselves.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Once we’re done with the random walks, we use the resulting lists, sumX and
    sumX2, to create the avgList and rmsList inside another for loop by dividing the
    elements of sumX and sumX2 by numSim. Here sumX[j] is the sum of all the elements
    in column j of the s[i][j] matrix, where i represents the simulation number and
    j represents the number of steps taken so far. (Likewise, sumX2[j] is the same,
    squared.) Finally, avgList and rmsList are passed on as elements of states2 ❺,
    which we defined earlier as a list of lists.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function call inside the application class is calcRMS1d(). It generates
    the theoretical RMS distance at each step:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We know from the theoretical analysis of the one-dimensional random walk problem
    that the RMS distance is a nonlinear function of the number of steps *n*, which
    can be expressed as *x*n = √*n*, where *x*n is the RMS distance for the *n*th
    step (*n* is equivalent to looping variable j in the code). We use this relationship
    in the calcRMS1d() function to calculate the theoretical RMS distances and update
    expList ❶. We’ll use this list to create a side-by-side plot of the theoretical
    and simulated RMS distances to see how closely they follow each other.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last two lines of the application class, we make two successive calls
    to the createRWChart1() and createRWChart2() functions, shown here:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Other than the chart labels, the only difference between these two functions
    is that the first one uses states1 and the second one uses states2 to generate
    the respective charts. Both of these functions call the singleXYChart() function
    (which we discussed and used in [Chapter 3](chapter3.xhtml)) to draw the line
    charts and stack them inside a scroll pane.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you run the full code on your device, you should see a single scrollable
    window pop up with two separate charts. Let’s first consider the visualization
    of the random walks themselves, shown in [Figure 4-7](chapter4.xhtml#fig4-7).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-7.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-7: The random walk paths from 500 simulations of 1,000 steps'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'This chart shows all 500 random paths generated by the randomWalk1d() function
    (one per simulation, based on our global numSim parameter). These paths show a
    number of key features of one-dimensional random walks:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Each random path is unique, evident from the tangled web of lines moving across
    the chart.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most random walks tend to stay close to their starting position, even after
    many steps. We can see this in the darker band along the x-axis.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The paths are equally dispersed on both sides of x = 0, as expected. You could
    confirm this by creating histograms of the cumulative distances traveled at different
    numbers of steps. (I’ll leave this for you to try out as an exercise.)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any given number of steps, if we add the cumulative distances from all simulations,
    the sum will be close to zero because positive and negative distances will cancel
    each other. For the same reason, the arithmetic mean will also be close to zero.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RMS distance increases with the number of steps, as confirmed by the gradual
    widening of the band that envelops all random paths. The RMS distance is therefore
    a better measure for the average distance traveled than the arithmetic mean, as
    we don’t care about the direction of the movement.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these points collectively provide the answer we were seeking at the start
    of this project. A particle moving randomly in one dimension will likely trace
    a path that will initially stay close to its starting position. However, if we
    follow the particle for a long time, it may gradually move farther away. Again,
    we can’t predict exactly how far a particular particle will move, but if we measure
    the RMS distance from many different particles, we’ll see that the RMS distance
    increases with the number of steps. Our other chart, shown in [Figure 4-8](chapter4.xhtml#fig4-8),
    helps us explore this last point further.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-8.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-8: The mean and RMS distances traveled for a given number of steps'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-8](chapter4.xhtml#fig4-8) charts three lines. First, we have the
    line labeled “Simulated mean,” generated from the data in avgList. This line stays
    very close to zero, confirming one of the key points made based on [Figure 4-7](chapter4.xhtml#fig4-7):
    that the arithmetic average or mean for any number of steps will be zero if we
    have a sufficiently large number of observations. Second, we have the “Simulated
    RMS” line, generated from the data in rmsList, which clearly shows the RMS distance
    increasing (although at a decreasing rate) with the number of steps. Third, the
    smooth “Theoretical RMS” line represents the theoretical RMS distances from expList,
    calculated by simply taking the square root of the number of steps. Again, we
    can visually confirm that the simulated RMS values are very close to the theoretically
    expected RMS values.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: The minor discrepancies we see between the simulated and theoretical RMS values
    are to be expected. The simulated RMS values will approach the theoretical values
    as the number of simulations approaches infinity. I invite you to run the code
    again, this time setting numSim to 5000. Make sure that you comment out the call
    to the createRWChart1() function before doing that. The default implementation
    of JavaFX is memory and computation intensive, and trying to plot 5,000 lines,
    each with 1,000 data points, can take a while depending on your processor and
    memory configuration. However, if you do this experiment as suggested, you’ll
    see that with the added random walks, the simulated and theoretical RMS lines
    become virtually the same. If you go further by setting numSim to 50000, you’ll
    see only one line.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的模拟和理论 RMS 值之间的细微差异是可以预期的。当模拟次数接近无穷大时，模拟的 RMS 值将接近理论值。我邀请你重新运行代码，这次将 numSim
    设置为 5000。在此之前，请确保注释掉对 createRWChart1() 函数的调用。JavaFX 的默认实现占用大量内存和计算资源，尝试绘制 5000
    条线，每条线有 1000 个数据点，可能会根据你的处理器和内存配置需要一些时间。然而，如果你按照建议进行此实验，你会看到，随着增加的随机游走，模拟和理论 RMS
    曲线几乎完全相同。如果你进一步将 numSim 设置为 50000，你将看到只有一条线。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used Kotlin code and custom algorithms to solve math-related
    problems. The problems weren’t just theoretical; they also had practical applications
    in fields like mathematics, geodesy, navigation, and cryptography. Throughout
    our journey, we employed various mathematical concepts, operations, and tools,
    including basic arithmetic, math and trigonometric functions, the Pythagorean
    theorem, the Fibonacci sequence, the haversine formula, modulo operations, and
    linear algebra. We also probed the realm of stochastic processes, exploring the
    generation and utilization of random numbers to simulate random phenomena.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了 Kotlin 代码和自定义算法来解决与数学相关的问题。这些问题不仅是理论性的；它们在数学、测量学、导航和密码学等领域也有实际应用。在整个过程中，我们运用了多种数学概念、运算和工具，包括基本的算术运算、数学和三角函数、毕达哥拉斯定理、斐波那契数列、哈弗辛公式、模运算和线性代数。我们还探讨了随机过程的领域，研究了如何生成和利用随机数来模拟随机现象。
- en: Along the way, we used many core features of Kotlin, such as variables and collections,
    data classes, and conditional and iterative structures like if, when, for, and
    while. We also discovered the convenience of functions and lambdas, along with
    the rich set of mathematical and graphics library functions at our disposal.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们使用了 Kotlin 的许多核心特性，如变量和集合、数据类，以及条件和迭代结构，如 if、when、for 和 while。我们还发现了函数和
    Lambda 的便利性，并充分利用了我们手头的丰富数学和图形库函数。
- en: '### Resources'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '### 资源'
- en: Ayars, Eric. “Stochastic Methods.” In *Computational Physics with Python*, 131–139\.
    August 18, 2013\. Accessed June 15, 2024\. *[https://belglas.files.wordpress.com/2018/03/cpwp.pdf](https://belglas.files.wordpress.com/2018/03/cpwp.pdf)*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Ayars, Eric. “Stochastic Methods.” In *Computational Physics with Python*, 131–139\.
    August 18, 2013\. Accessed June 15, 2024\. *[https://belglas.files.wordpress.com/2018/03/cpwp.pdf](https://belglas.files.wordpress.com/2018/03/cpwp.pdf)*.
- en: 'Dutka, Jacques. “Eratosthenes’ Measurement of the Earth Reconsidered.” *Archive
    for History of Exact Sciences* 46, no. 1 (1993): 55–66\. Accessed June 15, 2024\.
    *[http://<wbr>www<wbr>.jstor<wbr>.org<wbr>/stable<wbr>/41134135](http://www.jstor.org/stable/41134135)*.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'Dutka, Jacques. “Eratosthenes’ Measurement of the Earth Reconsidered.” *Archive
    for History of Exact Sciences* 46, no. 1 (1993): 55–66\. Accessed June 15, 2024\.
    *[http://<wbr>www<wbr>.jstor<wbr>.org<wbr>/stable<wbr>/41134135](http://www.jstor.org/stable/41134135)*.'
- en: Eisenberg, Murray. “Hill Ciphers and Modular Linear Algebra.” November 3, 1999\.
    Accessed June 15, 2024\. *[https://apprendre-en-ligne.net/crypto/hill/Hillciph.pdf](https://apprendre-en-ligne.net/crypto/hill/Hillciph.pdf)*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Eisenberg, Murray. “Hill Ciphers and Modular Linear Algebra.” November 3, 1999\.
    Accessed June 15, 2024\. *[https://apprendre-en-ligne.net/crypto/hill/Hillciph.pdf](https://apprendre-en-ligne.net/crypto/hill/Hillciph.pdf)*.
- en: 'Harder, Douglas. “Project H.1: Sieve of Eratosthenes.” University of Waterloo.
    Accessed June 15, 2024\. *[https://ece.uwaterloo.ca/~ece150/Programming_challenges/H/1/](https://ece.uwaterloo.ca/~ece150/Programming_challenges/H/1/).*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 'Harder, Douglas. “Project H.1: Sieve of Eratosthenes.” University of Waterloo.
    Accessed June 15, 2024\. *[https://ece.uwaterloo.ca/~ece150/Programming_challenges/H/1/](https://ece.uwaterloo.ca/~ece150/Programming_challenges/H/1/).*'
- en: Kereki, Federico. “A Modern Look at Square Roots in the Babylonian Way.” *Cantor’s
    Paradise*. December 7, 2020\. Accessed June 15, 2024\. *[https://medium.com/cantors-paradise/a-modern-look-at-square-roots-in-the-babylonian-way-ccd48a5e8716](https://medium.com/cantors-paradise/a-modern-look-at-square-roots-in-the-babylonian-way-ccd48a5e8716)*.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Kereki, Federico. “从巴比伦方式看平方根的现代视角。” *Cantor的乐园*。2020年12月7日。访问日期：2024年6月15日。
    *[https://medium.com/cantors-paradise/a-modern-look-at-square-roots-in-the-babylonian-way-ccd48a5e8716](https://medium.com/cantors-paradise/a-modern-look-at-square-roots-in-the-babylonian-way-ccd48a5e8716)*。
- en: “Pythagorean Triples.” Prime Glossary. Accessed June 15, 2024\. *[https://t5k.org/glossary/page.php?sort=PrmPythagTriples](https://t5k.org/glossary/page.php?sort=PrmPythagTriples)*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: “毕达哥拉斯三元组。” Prime词汇表。访问日期：2024年6月15日。 *[https://t5k.org/glossary/page.php?sort=PrmPythagTriples](https://t5k.org/glossary/page.php?sort=PrmPythagTriples)*。
- en: Reich, Dan. “The Fibonacci Sequence, Spirals and the Golden Mean.” Department
    of Mathematics, Temple University. Accessed June 15, 2024\. *[https://math.temple.edu/~reich/Fib/fibo.xhtml](https://math.temple.edu/~reich/Fib/fibo.xhtml)*.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Reich, Dan. “斐波那契数列、螺旋和黄金比例。” 数学系，天普大学。访问日期：2024年6月15日。 *[https://math.temple.edu/~reich/Fib/fibo.xhtml](https://math.temple.edu/~reich/Fib/fibo.xhtml)*。
- en: 'Van Brummelen, Glen. *Heavenly Mathematics: The Forgotten Art of Spherical
    Trigonometry*. Princeton, NJ: Princeton University Press, 2013.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Van Brummelen, Glen. *天文数学：被遗忘的球面三角学艺术*。普林斯顿，新泽西州：普林斯顿大学出版社，2013年。
