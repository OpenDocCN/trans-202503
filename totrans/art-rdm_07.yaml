- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: ART**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ART**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In this chapter, we’ll explore generative art—images created by algorithms that
    use randomness. We’ll begin with “random art,” a catchall phrase for three different
    approaches to producing artistic images. Alternative methods exist, but these
    will give you a taste of what’s possible. We’ll also learn about fractals, which
    were extremely popular a few decades ago when personal computers were finally
    powerful enough to do interesting things with graphics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索生成艺术——通过使用随机性算法创建的图像。我们将从“随机艺术”开始，这是一个总括性的词汇，涵盖了三种不同的艺术图像生成方法。虽然也存在其他方法，但这些将让你体验一下可能的艺术形式。我们还将学习分形艺术，分形曾在几十年前非常流行，当时个人计算机终于足够强大，能够做一些有趣的图形处理。
- en: We’ll generate many color images in this chapter, though this book is in black
    and white. I suggest running the code to see them properly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将生成许多彩色图像，尽管本书是黑白的。我建议你运行代码以查看它们的实际效果。
- en: '**Creating Random Art**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建随机艺术**'
- en: We’ll begin with three examples. The first mimics a program that amazed early
    Apple II personal computer enthusiasts. It also introduces us to Python’s turtle
    graphics package.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从三个例子开始。第一个例子模仿了一款令早期Apple II个人计算机爱好者惊叹的程序。它还将我们引入Python的turtle图形包。
- en: The second implements a random walk, effectively a simulation of Brownian motion,
    the wanderings of particles in a fluid when viewed through a microscope. It’s
    a simple process that, with appropriate color tables, leads to pleasant images
    suitable for T-shirts and coffee mugs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子实现了一个随机漫步，实际上是布朗运动的模拟，即通过显微镜观察流体中粒子的随机运动。这是一个简单的过程，配合合适的颜色表，能够生成适合印在T恤和咖啡杯上的美丽图像。
- en: The last example warps a two-dimensional grid of points using randomly selected
    functions, rotations, and color tables to generate unique images, likewise suitable
    for print.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的例子通过使用随机选择的函数、旋转和颜色表来扭曲二维点阵，生成独特的图像，同样适合打印。
- en: '***Moiré Patterns***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***莫尔条纹***'
- en: '*Moiré patterns* occur in digital images when the discrete world of the computer
    screen meets what should be a continuous representation, that is, when drawing
    a line that can’t be accurately represented by the grid imposed by the display.
    [Figure 7-1](ch07.xhtml#ch07fig01) shows an example.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*莫尔条纹*出现在数字图像中，当计算机屏幕的离散世界与应该是连续表示的图像相遇时，也就是说，当画一条线时，该线无法通过显示器强加的网格准确表示时。 [图
    7-1](ch07.xhtml#ch07fig01)展示了一个例子。'
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig01.jpg)'
- en: '*Figure 7-1: “Brian’s Theme” as rendered by an Apple II computer*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：“Brian’s Theme”由Apple II计算机呈现*'
- en: '[Figure 7-1](ch07.xhtml#ch07fig01) is 1979’s “Brian’s Theme,” a simple BASIC
    program created by Brian Howard; it could be found on the Apple II DOS 3.3 system
    master diskette from 1983\. The program selected a random point, from which it
    drew line after line to the edge of the screen, stepping each time by a randomly
    selected value. The crude resolution of the 280×160-pixel Apple II display, along
    with the funky way points were colored when plotting, produced a moiré pattern.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-1](ch07.xhtml#ch07fig01)是1979年由Brian Howard创建的简单BASIC程序《Brian’s Theme》；它可以在1983年的Apple
    II DOS 3.3系统主盘中找到。该程序从一个随机点开始，接着从该点画出一条条线到达屏幕边缘，每次都按随机选定的值进行步进。Apple II显示器的280×160像素的粗糙分辨率，以及绘制时点的颜色处理方式，产生了莫尔条纹。'
- en: Let’s create our own moiré patterns. The code we want is in *moire.py*. It introduces
    us to Python’s turtle graphics module (`turtle`), part of the standard Python
    distribution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来创造自己的莫尔条纹。我们需要的代码在*moire.py*文件中。它向我们介绍了Python的turtle图形模块（`turtle`），这是Python标准库的一部分。
- en: '**NOTE**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The phrase* turtle graphics *comes from the Logo programming language, which
    used a graphical “turtle” to drag a pen across the screen to teach programming
    concepts to children.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*“turtle graphics”一词来自于Logo编程语言，它使用图形化的“海龟”在屏幕上拖动笔触，帮助儿童学习编程概念。*'
- en: Simple commands like `FD 10` (forward 10), `RT 90` (right turn 90 degrees),
    and `PD` (pen down) made it possible to create complex drawings with relatively
    little programming knowledge; imagine an old-school spirograph game, but on the
    computer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的命令，如`FD 10`（前进10），`RT 90`（右转90度）和`PD`（笔触）使得使用相对较少的编程知识就能创建复杂的图形；可以想象一个老式的螺旋画游戏，只不过是在计算机上实现。
- en: We want the turtle to draw straight lines from a randomly selected point near
    the center to the edges, stepping by some distance along the edge each time. The
    result is something like [Figure 7-2](ch07.xhtml#ch07fig02).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望海龟从一个随机选取的靠近中心的点出发，画出直线到达边缘，每次沿边缘走一定的距离。结果类似于 [图 7-2](ch07.xhtml#ch07fig02)。
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig02.jpg)'
- en: '*Figure 7-2: “Brian’s Theme” redux*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2: “Brian’s Theme” 复刻版*'
- en: '[Figure 7-2](ch07.xhtml#ch07fig02) is nothing more than straight line after
    straight line; the pattern emerges from the moiré effect.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](ch07.xhtml#ch07fig02)不过是直线一条接一条；这个图案源自莫尔条纹效应。'
- en: 'First, we import the necessary modules and ask the turtle to configure the
    display:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入必要的模块，并要求海龟配置显示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We configure the turtle, here `tu`, to go as fast as it can and then hide itself
    (`ht` for “hide turtle”). This way, we see only what it draws.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置海龟，这里是 `tu`，让它尽可能快地行进，然后隐藏它自己（`ht` 为“隐藏海龟”）。这样，我们只看到它绘制的内容。
- en: The drawing window is adjusted to 500×500 pixels with a black background. The
    *x* and *y* dimensions follow using NumPy’s `linspace` to generate 400 point vectors
    spanning –200 to 200\. The turtle’s screen places the origin in the center of
    the display window.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图窗口调整为 500×500 像素，背景为黑色。*x* 和 *y* 维度使用 NumPy 的 `linspace` 来生成从 -200 到 200 的
    400 个点的向量。海龟的屏幕将原点放置在显示窗口的中央。
- en: 'We’ll draw a moiré pattern, wait a bit, then clear the screen and draw another—interactive
    visual art at its finest. We need a loop:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个莫尔条纹图案，稍等片刻，然后清空屏幕并绘制另一个——这是最好的交互式视觉艺术。我们需要一个循环：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To start a drawing, we clear the screen and select the origin point (`X`, `Y`)
    and the `step` size. We specify color as red, green, and blue using HTML notation;
    for example, `#FF0000` is bright red, `#E0B0FF` is mauve, `#A0522D` is sienna,
    and so on, mixing red, green, and blue in proportion.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始绘图，我们清空屏幕并选择原点（`X`，`Y`）和 `step` 大小。我们使用 HTML 表示法指定颜色为红、绿、蓝；例如，`#FF0000` 是鲜红色，`#E0B0FF`
    是淡紫色，`#A0522D` 是铁锈色，等等，按比例混合红、绿、蓝。
- en: 'A simple loop then uses `Line` to draw the pattern from the center point to
    each of the four screen edges:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的循环随后使用 `Line` 从中心点绘制到四个屏幕边缘的图案：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Line` method first draws the requested line in white, then backs over it
    using the randomly selected color to produce a flashing effect.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Line` 方法首先用白色绘制请求的直线，然后用随机选择的颜色重新描绘它，产生闪烁效果。'
- en: Given the speed of modern computers, you might expect the moiré pattern to flash
    on the screen. However, Python’s turtle is similar to its namesake in that it
    draws the pattern at its leisure, essentially matching the speed of the Apple
    II code we’re mimicking.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到现代计算机的速度，你可能会期望莫尔条纹图案会在屏幕上闪现。然而，Python 的海龟图形与其名字一样，以悠闲的速度绘制图案，本质上匹配了我们模仿的
    Apple II 代码的速度。
- en: We’ll return to turtle graphics later in the chapter. For now, it’s time to
    take a walk.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后再次使用海龟图形。现在，是时候去散步了。
- en: '***Random Walks***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***随机游走***'
- en: 'A *random walk* algorithm follows the “two steps forward, one step backward”
    model in two dimensions: beginning at the origin, repeatedly take steps in random
    directions. To turn this trivial algorithm into art, we track the sequence of
    steps to create an image where each step is assigned a color from one of Matplotlib’s
    color tables.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *随机游走* 算法遵循“两步前进，一步后退”的模型，二维空间内：从原点开始，反复朝随机方向迈步。为了将这个简单的算法转化为艺术，我们跟踪步伐的顺序，创造出一个图像，每一步都会从
    Matplotlib 的颜色表中选取一个颜色。
- en: A color table—also called a color map or lookup table—is a list of colors in
    red, green, and blue format. Most color tables, Matplotlib’s included, have 256
    entries. For example, if some value of interest is 129, or assignable to 129,
    then the associated color is stored at index 129 of the color table currently
    in use.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色表——也称为色彩映射表或查找表——是一个由红、绿、蓝格式的颜色列表构成的表。大多数颜色表，包括 Matplotlib 中的颜色表，都有 256 个条目。例如，如果某个感兴趣的值是
    129，或者可以赋值为 129，那么与之关联的颜色将存储在当前使用的颜色表的索引 129 处。
- en: 'If the desired index is 129 and the color table is `viridis`, then the resulting
    RGB color value is:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果期望的索引是 129 且颜色表是 `viridis`，那么得到的 RGB 颜色值是：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code snippet demonstrates how to access Matplotlib’s color tables, but
    the output might not be as expected. Why are there four values, and why are they
    not in the range [0, 255] like turtle graphics’ hexadecimal color values? RGB
    color values are often mapped to [0, 1], or as fractions of the maximum possible
    value of 1.0\. To find the corresponding byte value, multiply by 255 and keep
    the integer part. The color in the previous code is `#20918C` in hexadecimal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码示例演示了如何访问 Matplotlib 的颜色表，但输出可能不像预期的那样。为什么有四个值？它们为什么不像海龟图形的十六进制颜色值那样在[0,
    255]的范围内？RGB 颜色值通常映射到[0, 1]，或者作为最大值 1.0 的分数。为了找到对应的字节值，需要乘以 255，并保留整数部分。前述代码中的颜色是十六进制的`#20918C`。
- en: This explains the first three values, but the fourth component is the alpha
    value, representing the color’s transparency. An alpha value of 1.0 is opaque,
    0.0 is transparent, and 0.5 blends the color and the color of the pixel behind
    it (similar to stacked graphics planes). For our purposes, we’ll allow for transparent
    backgrounds (what this means will become apparent when examining the code).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了前三个值，但第四个分量是透明度值，表示颜色的透明度。透明度值为 1.0 时是完全不透明的，0.0 时是完全透明的，而 0.5 时颜色与后面的像素颜色混合（类似堆叠图形平面）。对于我们的目的，我们允许透明背景（当查看代码时，您会发现这意味着什么）。
- en: Matplotlib comes with 84 predefined color tables, called *maps*; see *color_map_names.txt*
    for a list. Our random walk code supports all of them in any combination.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 提供了 84 种预定义的颜色表，称为*色图*；请参见*color_map_names.txt*获取完整列表。我们的随机漫步代码支持它们的任何组合。
- en: While random walks “repeatedly take steps in random directions,” I didn’t specify
    the allowed set of directions. From a point, (*x*, *y*), there are either four
    or eight possible directions one might go, as shown in [Figure 7-3](ch07.xhtml#ch07fig03).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 随着随机漫步“反复在随机方向上迈步”，我并没有指定允许的方向集合。从一个点（*x*，*y*）出发，可能的方向有四个或八个，如[图 7-3](ch07.xhtml#ch07fig03)所示。
- en: '![Image](../images/07fig03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig03.jpg)'
- en: '*Figure 7-3: The four (left) or eight (right) directions a random walker can
    move*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：随机漫步者可以移动的四个（左）或八个（右）方向*'
- en: 'Random walkers on the left (called *4-connected*) are restricted to the cardinal
    directions: north, south, east, or west. Those on the right (*8-connected*) have
    the option to walk diagonally. The code in *walker.py* supports both options.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的随机漫步者（称为*4连接*）仅限于朝着四个方向行走：北、南、东或西。而右侧的漫步者（*8连接*）则可以选择对角线行走。*walker.py* 中的代码支持这两种选择。
- en: Notice how the offsets from (*x*, *y*) are marked. If you’re used to plotting
    with Cartesian coordinates, as in math class, you might be a bit thrown by the
    signs. Ordinarily, we expect to plot in the first quadrant with *x* and *y* both
    positive and increasing to the right and up, respectively; this is not how most
    computers handle things. Instead, they put the origin at the upper-left corner
    of the screen so *y* increases as you move down and *x* increases as you move
    to the right. Mathematically, we’re plotting in the fourth quadrant and ignoring
    the sign of the *y*-axis.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如何标记从（*x*，*y*）的偏移量。如果你习惯于使用笛卡尔坐标系作图，就像数学课上那样，可能会对符号感到困惑。通常，我们期望在第一象限作图，其中
    *x* 和 *y* 都是正值，并分别向右和向上增大；但大多数计算机并不是这样处理的。相反，它们将原点放在屏幕的左上角，因此 *y* 随着向下移动而增大，*x*
    随着向右移动而增大。从数学角度来看，我们正在第四象限作图，并忽略了 *y* 轴的符号。
- en: 'Let’s run *walker.py* and see what it gives us:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行*walker.py*，看看它给我们带来什么：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The command produces an output image according to the given extension, here
    a PNG file; see [Figure 7-4](ch07.xhtml#ch07fig04).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令根据给定的扩展生成输出图像，这里是 PNG 文件；见[图 7-4](ch07.xhtml#ch07fig04)。
- en: '![Image](../images/07fig04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig04.jpg)'
- en: '*Figure 7-4: Sample random walker output*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：示例随机漫步输出*'
- en: The first argument tells the code to take a 4-connected walk. The second is
    the number of steps to take *per specified color table*. The color tables come
    next, separated by commas and no spaces. Here, I’ve repeatedly used Matplotlib’s
    `Reds` and `Oranges`. With 1,000,000 steps per color table and four color tables,
    the image in [Figure 7-4](ch07.xhtml#ch07fig04) represents a stroll of 4 million
    random steps, each generating a single pixel.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数告诉代码执行 4 连接的漫步。第二个参数是每个指定颜色表应迈的步数。接下来的就是颜色表，按逗号分隔且不留空格。在这里，我反复使用了 Matplotlib
    的 `Reds` 和 `Oranges`。每个颜色表 1,000,000 步，总共有四个颜色表，[图 7-4](ch07.xhtml#ch07fig04)中的图像表示了
    400 万步随机漫步，每一步生成一个像素。
- en: After the color tables, we add the background color or the word `none` for a
    transparent background. We can specify colors using HTML hexadecimal format without
    the leading `#` so that `000000` is a black background and `FFFFFF` is white.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在颜色表之后，我们添加背景色或单词`none`表示透明背景。我们可以使用HTML十六进制格式指定颜色，格式中不需要`#`，因此`000000`是黑色背景，`FFFFFF`是白色。
- en: The following argument is the orientation for the output image. The walk will
    naturally be more extensive in one direction or the other. This argument orients
    the output as either `portrait` so the longest dimension of the output image is
    in the *y* direction, or `landscape` to use the *x* dimension.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参数是输出图像的方向。行走会在某个方向上自然地更为广泛。此参数将输出图像定向为`portrait`（使输出图像的最长维度位于 *y* 方向）或`landscape`（使输出图像使用
    *x* 维度）。
- en: The final two arguments are the randomness source and seed value for the source.
    Both are optional.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两个参数是随机源和源的种子值。两者都是可选的。
- en: '**NOTE**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I called the output file* tshirt.png *because I used this example to make
    an actual T-shirt. There are multiple online services where you can upload an
    image and order a shirt. If you want to make your own, I recommend many millions
    of steps, a transparent background, and even encapsulated PostScript output format
    (use a* .eps *file extension on the command line).*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*我将输出文件命名为* tshirt.png *，因为我使用这个例子制作了一件真正的T恤。有许多在线服务允许你上传图片并订购T恤。如果你想自己制作，我推荐使用数百万步、透明背景，甚至封装的PostScript输出格式（在命令行使用*.eps*文件扩展名）。*'
- en: 'Let’s take a walk through *walker.py*. I’ll skip the part that imports the
    usual modules and parses the command line. Here’s the code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过*walker.py*来走一遍。我将跳过导入常见模块和解析命令行的部分。代码如下：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We begin by configuring the randomness source. In this case, we choose random
    integers in the range [0, 3] if 4-connected and [0, 7] if 8-connected. We’ll use
    the values as indices into a list of *x* and *y* offsets and add the offsets to
    the current point to take a step. The three cases in the code handle specifying
    a randomness source, a source with a seed value, or defaults.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先配置随机源。在这种情况下，如果是4连通，我们选择[0, 3]范围内的随机整数；如果是8连通，则选择[0, 7]范围内的随机整数。我们将使用这些值作为
    *x* 和 *y* 偏移量列表的索引，并将这些偏移量添加到当前位置以迈出一步。代码中的三个案例处理指定随机源、带有种子值的源或默认值。
- en: 'Next comes the walk. The main loop tracks points in the lists `X` and `Y`,
    with colors in `C`. At this level, the loop is over the specified color tables:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是行走。主循环跟踪`X`和`Y`列表中的点，以及`C`中的颜色。在这一层，循环遍历指定的颜色表：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Walk` function simulates a complete walk of `steps` steps for the current
    color table (`cname`) and `mode`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Walk`函数模拟当前颜色表（`cname`）和`mode`的完整`steps`步行走：'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we get the color table (`cmap`), and then we define `offset`, a list
    of *x* and *y* offset values for 4-connected and 8-connected walks. The walk itself
    begins at (0, 0) using the color at index 0 (`C`).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取颜色表（`cmap`），然后定义`offset`，它是4连通和8连通行走的 *x* 和 *y* 偏移值列表。行走本身从(0, 0)开始，使用索引为0的颜色（`C`）。
- en: The loop over `steps` simulates the walk. We add a randomly selected offset
    to the last position for both *x* and *y*. Consider the code to select the color
    ➊. The loop index, `i`, ranges over [0, steps). Dividing by `steps` produces a
    fraction, [0, 1). Multiplying by 256 selects an index of the color table. Therefore,
    a full random walk steps through the entire color table once. There are other
    options to experiment with; see “Exercises” on [page 238](ch07.xhtml#ch00lev1_49).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对`steps`的循环模拟了步态。我们为 *x* 和 *y* 的最后位置分别添加一个随机选择的偏移量。考虑选择颜色的代码 ➊。循环索引`i`的范围是[0,
    steps)。除以`steps`会产生一个分数，[0, 1)。乘以256则选择颜色表的一个索引。因此，一次完整的随机行走会遍历整个颜色表一次。还有其他实验选项；请参见[第238页](ch07.xhtml#ch00lev1_49)的“练习”。
- en: 'For now, there is no output image, only a collection of points (*x*, *y*) and
    associated colors in `C`. To make an image, we need `CreateOutputImage`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，没有输出图像，只有一组点（*x*，*y*）及其关联的颜色在`C`中。为了生成图像，我们需要`CreateOutputImage`：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The function is in three parts. The first makes NumPy vectors of the *x* and
    *y* points and determines the extent in each direction (`dx`, `dy`) to specify
    the output image, `img`. The output image uses 4 as the number of channels, not
    3 as we’ve used previously; because we want to support a transparent background,
    we need to explicitly specify the alpha channel.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数分为三部分。第一部分生成 *x* 和 *y* 点的 NumPy 向量，并确定每个方向的扩展量（`dx`, `dy`），以指定输出图像 `img`。输出图像使用
    4 个通道，而不是我们之前使用的 3 个通道；因为我们要支持透明背景，需要明确指定 alpha 通道。
- en: Next, we set the entire image to the transparent background color. Use 0 for
    the alpha channel for a transparent background and 255 for one that is completely
    opaque.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将整个图像设置为透明背景色。使用 0 作为 alpha 通道的值表示透明背景，使用 255 表示完全不透明的背景。
- en: We loop over the points, mapping each point to a pixel of the image with explicit
    red, green, and blue color values. Review the assignments to `xx` and `yy` to
    follow how they map raw points to valid image coordinates.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历这些点，将每个点映射到图像的一个像素，并明确指定红色、绿色和蓝色的颜色值。查看 `xx` 和 `yy` 的赋值，了解它们如何将原始点映射到有效的图像坐标。
- en: Notice how `img` is indexed. The code assigns the point (*x*, *y*) to the image,
    but the image is indexed as `(yy,xx)`. Images are indexed by row and then by column,
    meaning the *y*-coordinate—using the origin at the upper-left corner convention—represents
    the row, and the *x* the column.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `img` 的索引方式。代码将点 (*x*, *y*) 分配给图像，但图像的索引方式是 `(yy,xx)`。图像是先按行索引，再按列索引，这意味着
    *y* 坐标（使用左上角为原点的约定）表示行，*x* 表示列。
- en: 'We’re almost done. The `CreateOutputImage` function returns the image as specified
    by the actual points of the walk. To produce the final output, we reorient the
    image to respect the portrait or landscape orientation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成了。`CreateOutputImage` 函数根据行走的实际点返回图像。为了生成最终输出，我们将图像重新调整方向，以适应竖屏或横屏方向：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `transpose` method rearranges the columns of a NumPy array as specified.
    We swap rows and columns as needed, but ensure the number of channels remains
    in place. Read through *walker.py* to follow the overall flow of the code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`transpose` 方法按指定的方式重新排列 NumPy 数组的列。我们根据需要交换行和列，但确保通道数保持不变。阅读 *walker.py* 以跟踪代码的整体流程。'
- en: I’ve included several example outputs in the chapter files to inspire you to
    create your own. I especially like *example1.png*; it reminds me of the sci-fi
    sets used in *Doctor Who* episodes from the 1970s. The *example5.png* file uses
    *hotbits.bin* when that file was 1,130,496 bytes. The cyclic pattern is due to
    the number of requested points, which exceeds the number of random samples extracted
    from the file, thereby repeating. The *example5.txt* file contains the text of
    the command. If you create any compelling examples, please share them. I’ll make
    a small gallery on the book’s GitHub page.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我在章节文件中包含了几个示例输出，以激发你创建自己的作品。我特别喜欢 *example1.png*；它让我想起了 1970 年代《神秘博士》剧集中的科幻场景。*example5.png*
    文件使用了当时为 1,130,496 字节的 *hotbits.bin* 文件。循环模式是由于请求的点数超过了从文件中提取的随机样本数，从而导致了重复。*example5.txt*
    文件包含命令的文本。如果你创建了任何有趣的示例，请分享它们。我会在本书的 GitHub 页面上创建一个小画廊。
- en: Let’s change gears and use randomness in combination with determinism to produce
    images constructed from warpings of the *xy*-plane.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转换思路，结合随机性和确定性，生成通过 *xy* 平面扭曲构建的图像。
- en: '***A Grid***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个网格***'
- en: What happens if you take an evenly spaced grid of points in two dimensions,
    apply a function that maps each point to a new point, then plot the points? In
    other words, what happens when you warp a grid of points? In this section, we’ll
    discover the answer and use it to build random works of abstract digital art.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你取一个二维的均匀分布的点网格，应用一个将每个点映射到新点的函数，然后绘制这些点，会发生什么？换句话说，当你扭曲一个点网格时，会发生什么？在本节中，我们将揭示答案，并利用这一过程创造随机的抽象数字艺术作品。
- en: '[Figure 7-5](ch07.xhtml#ch07fig05) illustrates the basic process.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-5](ch07.xhtml#ch07fig05) 说明了这一基本过程。'
- en: '![Image](../images/07fig05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig05.jpg)'
- en: '*Figure 7-5: A grid of points (left) and the same grid warped (right)*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：左侧是点的网格，右侧是经过扭曲后的相同网格*'
- en: On the left of [Figure 7-5](ch07.xhtml#ch07fig05), we have a grid of 30×30 points.
    We apply a function to each point, (*x*, *y*), to generate a new point, (*x′*,
    *y′*), plotted on the right of [Figure 7-5](ch07.xhtml#ch07fig05).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 7-5](ch07.xhtml#ch07fig05) 的左侧，我们有一个 30×30 点的网格。我们对每个点 (*x*, *y*) 应用一个函数，生成一个新点
    (*x′*, *y′*)，该点绘制在 [图 7-5](ch07.xhtml#ch07fig05) 的右侧。
- en: 'The function is:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数是：
- en: (*x′*, *y′*) *←* (*y*³ + *x*, *x*² + *y*)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: (*x′*, *y′*) *←* (*y*³ + *x*, *x*² + *y*)
- en: For input point (*x*, *y*), the output *x*-coordinate is *y*³ + *x* and the
    *y*-coordinate is *x*² + *y*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入点 (*x*, *y*)，输出的 *x* 坐标是 *y*³ + *x*，而 *y* 坐标是 *x*² + *y*。
- en: Likewise, the function (*x*, *y*) *→* (*yx*², *xy*²) changes the uniform grid
    of points into [Figure 7-6](ch07.xhtml#ch07fig06).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，函数 (*x*, *y*) *→* (*yx*², *xy*²) 将均匀的点网格转换为 [图 7-6](ch07.xhtml#ch07fig06)。
- en: '![Image](../images/07fig06.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig06.jpg)'
- en: '*Figure 7-6: A uniform grid warped by (*x,y*) → (*yx^(*2,*) xy^(*2*)*)*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：由 (*x,y*) → (*yx², xy²*) 变形的均匀网格*'
- en: We’ll generate a set of warping functions, select one randomly, and apply it
    to the uniform grid of points. Then, we repeat this process for a specified number
    of cycles, keeping all output points as we go.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成一组变形函数，随机选择一个，并将其应用于均匀的点网格。然后，我们重复这个过程指定次数，并在此过程中保留所有输出点。
- en: To add color, we make each warping function return a color table index along
    with the new point location. Therefore, each warping function maps an input point
    to a new output point and color table index. Each cycle selects a new color table
    at random.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加颜色，我们使每个变形函数返回一个颜色表索引和新的点位置。因此，每个变形函数将输入点映射到一个新的输出点和颜色表索引。每个周期会随机选择一个新的颜色表。
- en: To add more randomness, we’ll shift the collection of points by adding randomly
    selected *x* and *y* offsets. Because we’re adventurous types, we’ll also rotate
    the points by a random angle about the origin.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加更多的随机性，我们将通过添加随机选择的 *x* 和 *y* 偏移量来平移点集合。因为我们是冒险型人物，所以我们还将以一个随机角度围绕原点旋转这些点。
- en: 'I’ve defined a collection of five warping functions, two of which we’ve already
    seen:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个包含五个变形函数的集合，其中有两个我们已经见过：
- en: '![Image](../images/f0221-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0221-01.jpg)'
- en: The input grid is always in [–1, 1]. Each function returns the new point and
    color table index found by keeping the integer part after multiplying the third
    return value by 255\. The cumulative effect of the random function applications,
    rotations, offsets, and color tables produces the desired output image.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输入网格始终在[–1, 1]范围内。每个函数返回新的点和颜色表索引，这些索引是通过将第三个返回值乘以 255 后取整数部分得到的。随机函数应用、旋转、偏移和颜色表的累积效应产生了期望的输出图像。
- en: The code is in *warp.py*. Run it like so
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在 *warp.py* 中。运行方式如下：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: to produce [Figure 7-7](ch07.xhtml#ch07fig07).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以产生 [图 7-7](ch07.xhtml#ch07fig07)。
- en: '![Image](../images/07fig07.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig07.jpg)'
- en: '*Figure 7-7: Warping in action*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：变形效果*'
- en: The first argument to *warp.py* is the number of points along each grid dimension.
    The second is the number of cycles, or the number of times we apply a randomly
    selected function to the grid. Finally, the last three arguments are the output
    image name, randomness source, and seed, if desired.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*warp.py* 的第一个参数是每个网格维度上的点数。第二个是周期数，或者说我们将随机选择的函数应用到网格上的次数。最后三个参数是输出图像的名称、随机性源和种子（如果需要）。'
- en: 'First are the warp functions. For example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是变形函数。例如：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This implements the first warping function in the collection. The remaining
    four functions are similar. We store the warp functions in a list so they can
    be selected at random:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这实现了集合中的第一个变形函数。其余四个函数类似。我们将变形函数存储在列表中，以便可以随机选择：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The main body of *warp.py* parses the command line and loads the color table
    names from *color_map_names.txt*. It then defines empty lists to hold all the
    (*x*, *y*) points and associated RGB colors, `X`, `Y`, and `C`, respectively.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*warp.py* 的主体解析命令行并从 *color_map_names.txt* 加载颜色表名称。然后，它定义了空列表来存储所有的 (*x*, *y*)
    点和关联的 RGB 颜色，分别是 `X`、`Y` 和 `C`。'
- en: 'The grid is specified as an `npoints` long vector from –1 to +1:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 网格被指定为一个从 –1 到 +1 的 `npoints` 长向量：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All the action is in the loops over cycles and grid points:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的操作都在对周期和网格点的循环中：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The outermost loop over `k` handles the cycles. Each cycle randomly selects
    a color map (`cmap`) and a warp function (`fn`). It also selects random *x* and
    *y* offsets (`xoff`, `yoff`) and a rotation angle (`theta`).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 外层循环处理 `k` 变量，负责循环操作。每个周期会随机选择一个颜色映射（`cmap`）和一个变形函数（`fn`）。它还会选择随机的 *x* 和 *y*
    偏移量（`xoff`，`yoff`）以及旋转角度（`theta`）。
- en: The two inner loops, over `i` and `j`, walk through `v` in both the *x* and
    *y* directions; they visit every point in the 2D grid. The selected function is
    applied to each point, `n,m,c = fn(v[i],v[j])`, to return a new point (*n*, *m*)
    and color table index (`c`). To rotate a point about the origin, we multiply it
    by a rotation matrix
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 两个内部循环，遍历`i`和`j`，在*x*和*y*方向上走遍`v`，访问2D网格中的每一个点。选定的函数应用于每个点，`n,m,c = fn(v[i],v[j])`，返回一个新点(*n*,
    *m*)和颜色表索引(`c`)。要围绕原点旋转一个点，我们将其乘以旋转矩阵。
- en: '![Image](../images/f0223-01.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0223-01.jpg)'
- en: 'which, following the rules for matrix multiplication, becomes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 根据矩阵乘法的规则，变为：
- en: '![Image](../images/f0223-02.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0223-02.jpg)'
- en: This matches the previous code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的代码相匹配。
- en: Rotation complete, the final step is to add the *x* and *y* offsets. These shift
    the points in the *x* and *y* directions to keep them from overlapping.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转完成后，最后一步是添加*x*和*y*的偏移量。这些偏移量将点在*x*和*y*方向上移动，以避免它们重叠。
- en: Every warped, rotated, and offset point is appended to the list of points and
    colors. Notice that the warping function returns a color table index, but `C`
    holds the tuple returned by `cmap` for the current color table.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个扭曲、旋转和偏移后的点都会添加到点和颜色的列表中。请注意，扭曲函数返回的是颜色表索引，但`C`保存的是当前颜色表由`cmap`返回的元组。
- en: 'With all cycles complete, we produce the plot and dump it to disk. Matplotlib
    obliges:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有周期完成后，我们生成图表并将其保存到磁盘。Matplotlib 依照要求执行：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here `oname` is the output image name; it’s taken from the command line argument.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`oname`是输出图像的名称；它来自命令行参数。
- en: Unlike Matplotlib’s `plot` command, `scatter` accepts a list of per-point colors,
    which is why we constructed `C` for each point. The `tight_layout` command removes
    extraneous space, which is handy after turning the axes off.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与Matplotlib的`plot`命令不同，`scatter`接受每个点的颜色列表，这就是为什么我们为每个点构造了`C`。`tight_layout`命令去除多余的空间，这在关闭坐标轴后非常实用。
- en: Run *warp.py* a few times to experiment with the code. If you make the grid
    too fine, with the first argument above 300 or thereabouts, you may run out of
    memory. While it isn’t necessary to specify a pseudorandom generator and seed
    value, doing so lets you re-create the output. The file *warp_factor_9.py* uses
    a single pseudorandom generator with a user-supplied global seed to create a specified
    number of warp images. I ran the command
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*warp.py*几次来实验代码。如果你将网格设置得过于细致，设置第一个参数超过300左右，可能会耗尽内存。虽然并不需要指定伪随机生成器和种子值，但这样做可以让你重新生成输出。文件*warp_factor_9.py*使用一个用户提供的全局种子创建指定数量的扭曲图像。
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: to create 100 images in the *warpings* directory. It took about 15 minutes to
    run and produced some attractive output. Matplotlib’s cyclic color tables, like
    `flag`, make stunning displays.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在*warpings*目录中创建100张图像。运行大约花费了15分钟，并生成了一些吸引人的输出。Matplotlib的循环色彩表，如`flag`，展现了惊艳的效果。
- en: While *warp.py* makes pretty pictures, the randomness isn’t particularly profound;
    it selects from among a set of options, relying on combinations of possible options
    to produce novelty.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*warp.py*能生成漂亮的图像，但它的随机性并不特别深刻；它从一组选项中选择，依靠可能的选项组合来产生新颖性。
- en: 'The following section introduces us to fractals: a world of math, emergent
    behavior, and randomness.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将带领我们了解分形：一个充满数学、涌现行为和随机性的世界。
- en: '**Fun with Fractals**'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分形的乐趣**'
- en: '*Fractals* are mathematical objects constructed from smaller copies of themselves;
    they are *self-similar*. Mathematical fractals are our focus, but approximate
    fractals are a common sight in nature—for example, the branching of a tree, the
    airways in your lungs, and the fronds of a fern.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*分形*是由自身的较小副本构成的数学对象；它们是*自相似的*。我们的关注点是数学分形，但近似分形在自然界中很常见——例如，树的分枝、肺部的气道和蕨类植物的叶片。'
- en: In this section, we’ll explore randomness as a means of generating fractal images.
    There is a rich literature on fractals for art and computer graphics. We’ll accomplish
    the barest of introductions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨随机性作为生成分形图像的一种手段。关于艺术和计算机图形学的分形有着丰富的文献。我们将做一个最简单的介绍。
- en: First, we’ll play the chaos game to build simple fractal images with Python’s
    turtle. Then, we’ll learn about a more sophisticated approach to generating fractal
    images, iterated function systems (IFS). Finally, we’ll put everything together
    to build *ifs.py*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将玩混沌游戏，用Python的海龟画图构建简单的分形图像。然后，我们将了解生成分形图像的更复杂方法——迭代函数系统（IFS）。最后，我们将把所有内容结合起来，构建*ifs.py*。
- en: '***The Chaos Game***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***混沌游戏***'
- en: 'Let’s play the *chaos game*, so named by mathematician and fractal explorer
    Michael Barnsley. It works like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来玩一下*混沌游戏*，这个名字由数学家和分形探索者迈克尔·巴恩斯利命名。它的运作方式如下：
- en: Pick three points, (*x*[0], *y*[0]), (*x*[1], *y*[1]), and (*x*[2], *y*[2]),
    to form the vertices of a triangle.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选取三个点，(*x*[0], *y*[0])、(*x*[1], *y*[1])和(*x*[2], *y*[2])，作为三角形的顶点。
- en: Set *x* = *x*[0] and *y* = *y*[0].
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置*x* = *x*[0]和*y* = *y*[0]。
- en: Pick a vertex of the triangle at random, (*x[n]*, *y[n]*) for *n* in [0, 2].
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选取三角形的一个顶点，(*x[n]*, *y[n]*)，其中*n*在[0, 2]之间。
- en: Update using *x ←* 0.5(*x* + *x[n]*) and *y ←* 0.5(*y* + *y[n]*).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*x ←* 0.5(*x* + *x[n]*)和*y ←* 0.5(*y* + *y[n]*)进行更新。
- en: Plot (*x*, *y*).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制(*x*, *y*)。
- en: Repeat from step 3.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第3步开始重复。
- en: 'This algorithm plots points in the *xy*-plane. Let’s find out whether the set
    of points eventually covers the plane, or there’s a pattern of some kind. Run
    *sierpinski.py*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法在*xy*平面上绘制点。让我们看看这些点的集合是否最终覆盖了平面，或者是否存在某种模式。运行*sierpinski.py*：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A small window should appear. The Python turtle is also there, jumping around
    the window seemingly at random. Each time it moves, it leaves a small dot behind.
    The dot color corresponds to which triangle vertex was selected in step 3.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会弹出一个小窗口。Python海龟也在其中，似乎随意地跳跃在窗口中。每次它移动时，都会留下一个小点。点的颜色对应于第3步中选定的三角形顶点。
- en: Let the program run for some length of time to draw whatever it is it wants
    to draw. When you have waited as long as you can for the turtle to do its thing,
    press a key and examine the resulting image. It should look similar to [Figure
    7-8](ch07.xhtml#ch07fig08).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序运行一段时间，绘制它想要绘制的内容。当你等待海龟完成任务的时间足够长后，按下一个键并检查结果图像。它应该看起来与[图 7-8](ch07.xhtml#ch07fig08)相似。
- en: '![Image](../images/07fig08.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig08.jpg)'
- en: '*Figure 7-8: The chaos game in action*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：混沌游戏的实际操作*'
- en: The image is a fractal known as the Sierpiński triangle after Wacław Sierpiński,
    a Polish mathematician who explored such shapes in 1915.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这幅图是一个分形，被称为谢尔宾斯基三角形，得名于波兰数学家瓦茨瓦夫·谢尔宾斯基，他在1915年研究了这种形状。
- en: Fractals are constructed from copies of themselves. For example, the main triangle
    is built from three smaller triangles, each constructed from three still smaller
    triangles, and so on forever. Therefore, the game didn’t fill the *xy*-plane but
    only a subset of points on it. Such things are called “fractal” because their
    dimension is a noninteger.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 分形是由自身的副本构建而成的。例如，主三角形是由三个较小的三角形构建的，每个较小的三角形又是由三个更小的三角形构建的，依此类推，永无止境。因此，游戏并没有填满*xy*平面，而只是填充了平面上的一个子集。这样的事物被称为“分形”，因为它们的维度是非整数的。
- en: The fractal is more than a line, dimension 1, and less than a plane, dimension
    2\. There are multiple ways to define a fractal dimension, but perhaps the most
    common is the Hausdorff dimension. For the Sierpiński triangle, the Hausdorff
    dimension is log 3 / log 2 = 1.5849625 . . . , greater than a line but less than
    a plane.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分形大于一条线（维度1），但小于一个平面（维度2）。定义分形维度的方式有多种，但最常见的可能是豪斯多夫维度。对于谢尔宾斯基三角形，豪斯多夫维度为log
    3 / log 2 = 1.5849625……，大于一条线但小于一个平面。
- en: Let’s look at *sierpinski.py*, shown in [Listing 7-1](ch07.xhtml#ch07list01).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下*sierpinski.py*，如[清单 7-1](ch07.xhtml#ch07list01)所示。
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 7-1: Uncovering the Sierpiński triangle*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：揭示谢尔宾斯基三角形*'
- en: The first code paragraph configures the turtle, some colors, and the pseudorandom
    generator (`rng`). It also defines two lists holding the triangle’s vertices,
    `X` and `Y`. The other important bit is assigning `x` and `y` to the first vertex.
    Any random initial value will do, but a few iterations of the game might be necessary
    to land on points within the fractal.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段代码配置了海龟、一些颜色和伪随机生成器（`rng`）。它还定义了两个列表来保存三角形的顶点，`X`和`Y`。另一个重要部分是将`x`和`y`赋值为第一个顶点。任何随机的初始值都可以，但可能需要几次游戏迭代才能落到分形内的点上。
- en: The second paragraph is merely for convenience. It defines a global, `done`,
    and an event handler for turtle graphics to call when we press a key. The handler’s
    sole task is to set global `done` to `True` so the `while` loop exits. The turtle’s
    `onkeypress` and `listen` methods tell the turtle that it should listen for keypresses
    in the drawing window and perform some action when it hears one.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第二段仅为方便之用。它定义了一个全局变量`done`，以及一个事件处理程序，当我们按下键时，海龟图形会调用该处理程序。该处理程序的唯一任务是将全局变量`done`设置为`True`，以便`while`循环退出。海龟的`onkeypress`和`listen`方法告诉海龟应该监听绘图窗口中的按键，并在收到按键时执行某些操作。
- en: All the cool stuff is in the third paragraph—the `while` loop that runs until
    a keypress. It selects a vertex at random, `n`, and updates `x` and `y` before
    placing a properly colored dot at that point. The process repeats, placing point
    after point.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有有趣的东西都在第三段——`while`循环，它会一直运行直到按下一个键。它随机选择一个顶点`n`，并在更新`x`和`y`后，在该点上放置一个正确颜色的点。这个过程会重复，点一个接一个地放置。
- en: The chaos game uses the vertices of the triangle and randomness to uncover the
    *attractor* of the fractal, or the set of points that make up the fractal.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 混沌游戏使用三角形的顶点和随机性来揭示分形的*吸引子*，或者说是构成分形的点集。
- en: The chaos game works for *n*-sided polygons (*n* > 2) as well, as the code in
    *polygon.py* demonstrates. I won’t walk through it here; it’s a glorified version
    of *sierpinski.py* accepting *n* on the command line, followed, optionally, by
    a randomness source and a seed value. [Figure 7-9](ch07.xhtml#ch07fig09) shows
    the results for *n* = 5 and *n* = 9.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 混沌游戏同样适用于*n*边形（*n* > 2），正如*polygon.py*中的代码所示。我在这里不会详细讲解；它是一个改进版的*sierpinski.py*，可以接受命令行中的*n*，然后可选地接受一个随机源和一个种子值。[图
    7-9](ch07.xhtml#ch07fig09)展示了*n* = 5 和 *n* = 9的结果。
- en: '![Image](../images/07fig09.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig09.jpg)'
- en: '*Figure 7-9: The chaos game with five-sided (left) and nine-sided polygons
    (right)*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：带有五边形（左）和九边形（右）的混沌游戏*'
- en: Read through *polygon.py* to understand what it’s doing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读*polygon.py*以理解它的功能。
- en: '***Iterated Function Systems***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***迭代函数系统***'
- en: This section introduces us to *iterated function systems (IFS)*, systems of
    equation that map points in the plane to other locations. In the following section,
    we combine IFS and the chaos game to generate fractals, the attractors of the
    IFS. Let this serve as a warning that there’s math with vectors and matrices ahead.
    If these are unfamiliar beasts, have no worries. We can use IFS to make fantastic
    images without grasping all of the details behind the process. Still, it’s best
    to understand at a deeper level if we have the option.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了*迭代函数系统（IFS）*，即将平面中的点映射到其他位置的方程系统。在接下来的章节中，我们将IFS与混沌游戏结合，生成分形图像，IFS的吸引子。请注意，接下来会涉及到与向量和矩阵相关的数学。如果这些概念对你来说比较陌生，不用担心。我们可以在不完全掌握过程细节的情况下，利用IFS制作出令人惊叹的图像。不过，如果有可能的话，深入理解会更好。
- en: To build an IFS, we need to understand a few concepts. First, that matrices
    map vectors in the *xy*-plane to new vectors in the *xy*-plane. Second, that a
    vector in the *xy*-plane is another way to refer to a point, (*x*, *y*). Third,
    what a contraction mapping is. And finally, that a set of contraction mappings—with
    offset vectors and associated probabilities—forms an IFS, enabling us to use the
    chaos game to create fractal images. Let’s begin.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个IFS，我们需要理解几个概念。首先，矩阵将*xy*平面中的向量映射到*xy*平面中的新向量。其次，*xy*平面中的向量是指一个点（*x*，*y*）的另一种方式。第三，什么是收缩映射。最后，一组带有偏移向量和相关概率的收缩映射构成了一个IFS，使我们能够使用混沌游戏创建分形图像。让我们开始吧。
- en: 'Earlier, we used a matrix to rotate a set of points by some angle, *θ*, about
    the origin:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用矩阵将一组点按某个角度*θ*围绕原点旋转：
- en: '![Image](../images/f0227-01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0227-01.jpg)'
- en: We write this as ***x**′* = ***Mx***, where the bold lowercase letters are vectors
    and the bold uppercase letter is a matrix.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其写作***x**′* = ***Mx***，其中粗体小写字母是向量，粗体大写字母是矩阵。
- en: To be more specific, multiplying a two-dimensional vector
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，乘以一个二维向量
- en: '![Image](../images/f0228-01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0228-01.jpg)'
- en: by a matrix
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过矩阵
- en: '![Image](../images/f0228-02.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0228-02.jpg)'
- en: 'maps the vector to a new two-dimensional vector, ***x**′*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将向量映射到一个新的二维向量，***x**′*：
- en: '![Image](../images/f0228-03.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0228-03.jpg)'
- en: 'This also shows us how to multiply a two-dimensional vector by a matrix: multiply
    each element of the rows of the matrix by the corresponding element of the vector
    and sum. We say the matrix ***M*** is a *mapping* from ***x*** to ***x**′*.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这也展示了如何通过矩阵乘以二维向量：将矩阵行的每个元素与向量的相应元素相乘并求和。我们说矩阵***M***是从***x***到***x**′*的*映射*。
- en: 'In [Chapter 3](ch03.xhtml), we learned about the Euclidean distance between
    two points. Consider two vectors, ***x***[0] and ***x***[1], and their mappings
    under matrix ***M***: ![Image](../images/f0228-03a.jpg) and ![Image](../images/f0228-03b.jpg).
    If *d*(***x***[0], ***x***[1]) is the Euclidean distance between ***x***[0] and
    ***x***[1], and we have'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.xhtml)中，我们学习了两点之间的欧几里得距离。考虑两个向量，***x***[0]和***x***[1]，以及它们在矩阵***M***下的映射：![Image](../images/f0228-03a.jpg)
    和 ![Image](../images/f0228-03b.jpg)。如果*d*(***x***[0]，***x***[1])是***x***[0]和***x***[1]之间的欧几里得距离，我们有
- en: '![Image](../images/f0228-04.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0228-04.jpg)'
- en: for 0 < *α* < 1, then ***M*** is a *contraction mapping* that moves points together.
    We’ll use contraction mappings for our IFS, with each mapping represented by a
    matrix.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于0 < *α* < 1，***M***是一个*压缩映射*，将点聚集在一起。我们将使用压缩映射来表示我们的IFS，每个映射由一个矩阵表示。
- en: A mapping may also include a constant offset vector added to the vector found
    by applying the matrix. We write this as
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个映射还可以包括一个常数偏移向量，它加到应用矩阵后得到的向量上。我们可以将其写成
- en: '![Image](../images/f0228-05.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0228-05.jpg)'
- en: 'where adding vectors is element-wise, like NumPy. However, it’s more convenient
    to replace the 2×2 matrix with a 3×3 matrix incorporating the offset vector:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，向量相加是逐元素进行的，像NumPy那样。然而，更方便的做法是将2×2矩阵替换为一个3×3矩阵，并加入偏移向量：
- en: '![Image](../images/f0228-06.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0228-06.jpg)'
- en: A set of contraction mapping matrices, {***M***[0], ***M***[1], ***M***[2],
    . . . }, forms an IFS where each ***M*** is a 3×3 matrix combining a mapping with
    an offset vector. IFS have *attractors*, sets of points that subsequent mappings
    with the IFS send back to other points in the attractor. In this way, mapping
    a point on the attractor using one of the matrices in the IFS results in another
    point on the attractor. The points forming the attractor are the fractal we want
    to image, and the chaos game is the tool we use to find them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一组压缩映射矩阵，{***M***[0]，***M***[1]，***M***[2]，...}，形成一个IFS，其中每个***M***是一个3×3矩阵，将映射与偏移向量结合。IFS有*吸引子*，即一组点，后续的映射将这些点映射到吸引子中的其他点。通过这种方式，使用IFS中的一个矩阵对吸引子上的点进行映射会得到吸引子上的另一个点。形成吸引子的点就是我们想要成像的分形，混沌游戏是我们用来找到它们的工具。
- en: '***Fractals Plotted with Points***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过点绘制的分形***'
- en: We’re almost where we need to be. We have an IFS, a collection of matrices,
    ***M***. We also know that the chaos game helps us find the points on the attractor
    of the IFS. To adapt the chaos game to a set of matrices, we assign a probability
    to each map. Then, when playing the chaos game, we select the next map to apply
    based on that probability. The assigned probabilities alter the weighting of the
    attractor points.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎已经到了需要的地方。我们有了一个IFS，即一组矩阵，***M***。我们还知道，混沌游戏帮助我们找到IFS的吸引子上的点。为了将混沌游戏应用于一组矩阵，我们给每个映射分配一个概率。然后，在玩混沌游戏时，我们根据该概率选择下一个要应用的映射。分配的概率改变了吸引子点的加权。
- en: 'Let’s get practical. The code we’ll work with is in *ifs.py*. Read through
    the file to give yourself an overview. The majority of the file is the `IFS` class.
    Running *ifs.py* without arguments teaches us how to configure the command line:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实践。我们将使用的代码在*ifs.py*文件中。通读这个文件以了解整体内容。文件的大部分内容是`IFS`类。运行*ifs.py*并不带任何参数会教会我们如何配置命令行：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The words at the bottom of the output are assigned to different IFS, meaning
    different sets of mappings and probabilities. We specify the IFS we want on the
    command line by name. The maps are hardcoded in a dictionary embedded in the `IFS`
    class. For example, here’s the definition of the `sierpinski` IFS:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出底部的文字被分配给不同的IFS，意味着不同的映射和概率集合。我们通过命令行中的名称指定我们想要的IFS。映射在`IFS`类中嵌入的字典中是硬编码的。例如，下面是`sierpinski`
    IFS的定义：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The IFS consists of three maps, or three 3×3 matrices:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该IFS由三个映射组成，或者说由三个3×3矩阵组成：
- en: '![Image](../images/f0229-01.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0229-01.jpg)'
- en: Each is selected with probability 1/3 and is equally likely to be chosen when
    playing the chaos game.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个映射的选择概率为1/3，且在玩混沌游戏时，每个映射被选中的概率相等。
- en: The other IFS are defined similarly, though with more or fewer maps, as necessary.
    The `maple` IFS, and those following, are by Paul Bourke (*[https://paulbourke.net/fractals/ifs](https://paulbourke.net/fractals/ifs)*),
    used with permission. Bourke’s site is a treasure trove of fascinating computer
    graphics and geometry pages, including many on fractals and IFS. I highly recommend
    taking a look.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其他IFS定义方式类似，尽管根据需要可以有更多或更少的映射。`maple` IFS及其后续的IFS由Paul Bourke提供（* [https://paulbourke.net/fractals/ifs](https://paulbourke.net/fractals/ifs)*），并已获得许可。Bourke的网站是一个宝库，里面有许多有趣的计算机图形和几何学页面，包括许多关于分形和IFS的内容。我强烈推荐去看看。
- en: 'The remaining command line arguments are as described, with two options worth
    special mention. The first is using `maps` for the color. Specifying `maps` has
    the same effect as *sierpinski.py*; points are plotted in a color associated with
    the selected IFS map. This option reveals the maps in the output image. The second
    is using `random` for the IFS, which generates an IFS at random and then iterates
    to find the fractal it represents. We’ll experiment with this option shortly.
    For now, let’s use the `fern` IFS to see what sort of output we get. Give this
    command line a go:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的命令行参数如上所述，有两个选项值得特别提及。第一个是使用`maps`来指定颜色。指定`maps`的效果与*sierpinski.py*相同；点被绘制成与选定的IFS映射相关的颜色。这个选项可以在输出图像中显示映射。第二个是使用`random`来生成IFS，它会随机生成一个IFS，然后迭代找到它所代表的分形。我们稍后会试验这个选项。现在，让我们使用`fern`
    IFS来看看得到什么样的输出。尝试这个命令行：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It plots 1 million points of the attractor for the fern IFS using a different
    color for each of the four maps. The result is [Figure 7-10](ch07.xhtml#ch07fig10).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用四种不同颜色绘制蕨类IFS的100万个吸引子点。结果如[图7-10](ch07.xhtml#ch07fig10)所示。
- en: '![Image](../images/07fig10.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig10.jpg)'
- en: '*Figure 7-10: One million points of the fern attractor*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-10：蕨类吸引子的100万个点*'
- en: The fourth map is the narrow stem of the fern. Explore the other fractals supported
    by *ifs.py* or browse the *misc* directory, which contains images of each using
    1 million points.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个映射是蕨类植物的狭窄茎部。探索*ifs.py*支持的其他分形，或者浏览*misc*目录，其中包含每种分形使用100万个点的图像。
- en: The *ifs.py* code uses Matplotlib to produce the output plot. Matplotlib’s graphics
    are interactive. Try generating 10 million points of the `shell` IFS and then
    click the magnifying glass icon and draw a box around the center to zoom in. With
    10 million points, you should be able to zoom in two or three times. The spiral
    continues forever.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*ifs.py*代码使用Matplotlib来生成输出图。Matplotlib的图形是互动式的。试着生成`shell` IFS的1000万个点，然后点击放大镜图标，在中心周围画一个框来进行放大。用1000万个点，你应该能够放大两到三次。螺旋会永远继续下去。'
- en: That IFS fractals resemble objects in nature can’t be a mere coincidence; there
    must be a biological basis for self-similar patterns, even if they’re not rigorous
    but only approximate mathematical fractals.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: IFS分形与自然界中的物体相似，这不可能仅仅是巧合；自相似的模式必定有生物学基础，即使它们不是严格的，而只是近似的数学分形。
- en: While it’s fun to look at the pretty fractal images *ifs.py* creates, it’s even
    more fun to understand the “how” behind them. Let’s examine the code and then
    experiment with purely random IFS fractals.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然查看*ifs.py*生成的漂亮分形图像很有趣，但理解它们背后的“原理”更加有趣。让我们分析一下代码，然后尝试纯粹随机的IFS分形。
- en: '**The IFS Class**'
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**IFS 类**'
- en: 'The dictionary of predefined maps constitutes the bulk of the `IFS` class.
    In terms of actual code, there are a handful of methods to contemplate: `ChooseMap`,
    `GeneratePoints`, `StoreFractal`, and `RandomMaps`. I’ll save `RandomMaps` for
    the next section; `StoreFractal` is a straightforward application of Matplotlib
    to plot the generated points using the associated colors. That leaves `GeneratePoints`
    and `ChooseMap`. Let’s begin with `GeneratePoints`, as shown in [Listing 7-2](ch07.xhtml#ch07list02).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义映射的字典构成了`IFS`类的主体。就实际代码而言，有一些方法值得思考：`ChooseMap`、`GeneratePoints`、`StoreFractal`和`RandomMaps`。我会把`RandomMaps`留到下一节讨论；`StoreFractal`是Matplotlib的一个直接应用，用来使用相关的颜色绘制生成的点。这就剩下了`GeneratePoints`和`ChooseMap`。我们从`GeneratePoints`开始，如[清单7-2](ch07.xhtml#ch07list02)所示。
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 7-2: Finding the points on the fractal attractor*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-2：寻找分形吸引子上的点*'
- en: 'The `GeneratePoints` method fills in a NumPy array of `npoints` rows and three
    columns: *x*, *y*, and the index of the selected map. The code iterates a randomly
    initialized vector, `xy`. The third element, a constant 1, allows us to use 3×3
    matrices for the maps.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`GeneratePoints` 方法填充一个包含 `npoints` 行和三列的 NumPy 数组：*x*、*y* 和选定地图的索引。代码迭代一个随机初始化的向量
    `xy`。第三个元素，一个常量 1，允许我们使用 3×3 矩阵作为地图。'
- en: A randomly selected point isn’t likely to be on the attractor; therefore, before
    we store points in `self.xy`, we iterate 100 times to ensure that new points are
    on the attractor. Each iteration involves selecting a map according to the assigned
    probabilities followed by a matrix multiplication with that map, ***x** → **Mx***,
    which becomes `xy = m @ xy` in code. NumPy uses `@` for matrix multiplication.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择的点不太可能位于吸引子上；因此，在我们将点存储到 `self.xy` 之前，我们迭代 100 次，确保新点位于吸引子上。每次迭代都涉及根据分配的概率选择一个地图，然后进行与该地图的矩阵乘法，***x**
    → **Mx***，在代码中变为 `xy = m @ xy`。NumPy 使用 `@` 进行矩阵乘法。
- en: While the `GeneratePoints` method does the lion’s share of the work, it relies
    on `ChooseMap` ([Listing 7-3](ch07.xhtml#ch07list03)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `GeneratePoints` 方法承担了大部分工作，但它依赖于 `ChooseMap` ([列表 7-3](ch07.xhtml#ch07list03))。
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 7-3: Choosing a map*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-3：选择一个地图*'
- en: The `IFS` constructor creates member variables `nmaps`, `probs`, and `maps`
    according to the selected IFS. The `ChooseMap` method returns an index into the
    list of maps by picking a random number in [0, 1) (`r`) and then adding per-map
    probabilities until the accumulated sum (`a`) exceeds the selected value, at which
    point it returns the current index, `k`. The effect selects maps in proportion
    to their assigned probabilities.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFS` 构造函数根据选择的 IFS 创建成员变量 `nmaps`、`probs` 和 `maps`。`ChooseMap` 方法通过在 [0, 1)
    范围内选择一个随机数 (`r`)，然后逐步累加每个地图的概率，直到累积和 (`a`) 超过所选值，最终返回当前的索引 `k`。这种方法按比例选择地图，与它们分配的概率成正比。'
- en: 'Using the `IFS` class is straightforward:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `IFS` 类非常简单：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The constructor accepts the number of points, fractal name, color, an initialized
    `RE` object, and a flag to show or hide the fractal when we call `StoreFractal`.
    The `GeneratePoints` and `StoreFractal` methods complete the process. Encapsulating
    `IFS` in a single class with a small main driver lets us use *ifs.py* as a program
    or module; we’ll use it as the latter in the next section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受点数、分形名称、颜色、初始化的 `RE` 对象和一个标志，用于在调用 `StoreFractal` 时显示或隐藏分形。`GeneratePoints`
    和 `StoreFractal` 方法完成整个过程。将 `IFS` 封装到一个类中，并使用一个简洁的主驱动程序，让我们能够将 *ifs.py* 作为程序或模块使用；在下一节中，我们将作为模块使用它。
- en: '**Random IFS**'
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**随机 IFS**'
- en: Running *ifs.py* with `random` as the fractal name generates a set of random
    maps with random probabilities. Each map is a 3×3 matrix
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `random` 作为分形名称运行 *ifs.py* 会生成一组具有随机概率的随机地图。每个地图是一个 3×3 矩阵
- en: '![Image](../images/f0232-01.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0232-01.jpg)'
- en: 'with an associated probability, *p*. The six elements of the map must satisfy
    a set of constraints to be a contraction mapping. Specifically, the following
    must be true:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相关概率 *p*。地图的六个元素必须满足一组约束条件，才能成为收缩映射。具体来说，以下条件必须成立：
- en: '![Image](../images/f0232-02.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0232-02.jpg)'
- en: The `RandomMaps` method creates a collection of maps and probabilities, as in
    [Listing 7-4](ch07.xhtml#ch07list04).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`RandomMaps` 方法创建一个包含地图和概率的集合，如 [列表 7-4](ch07.xhtml#ch07list04) 所示。'
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 7-4: Creating a random IFS*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-4：创建一个随机 IFS*'
- en: The code first chooses a random number of maps, [2, 5], and probabilities (`probs`).
    It then loops `nmaps` times, calling the embedded function, `mapping`, which returns
    a valid map matrix. The `mapping` method repeatedly selects random elements in
    [–1, 1) until all constraints are satisfied.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先选择一个随机数目的地图，[2, 5]，和概率 (`probs`)。然后，它循环 `nmaps` 次，调用嵌套函数 `mapping`，该函数返回一个有效的地图矩阵。`mapping`
    方法会不断选择 [–1, 1) 范围内的随机元素，直到所有约束条件得到满足。
- en: 'Let’s create 100 random fractals to get a feel for what the attractor of a
    randomly generated IFS looks like. The file *ifs_maps.py* contains the code we
    need. It uses a master seed value passed on the command line to generate a collection
    of random fractals. Here’s the command line I used:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 100 个随机分形，感受一下随机生成的 IFS 吸引子的样子。文件 *ifs_maps.py* 包含我们需要的代码。它使用命令行传入的主种子值来生成一组随机分形。以下是我使用的命令行：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you use the same command line, you’ll get the same collection of fractals
    in the *fractals* directory. The file *ifs_maps_271828.txt* contains the randomly
    generated maps and the seed value. The code in *ifs_maps.py* is only a few dozen
    lines, but it demonstrates how to use the `IFS` class inside another program.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-11](ch07.xhtml#ch07fig11) presents some fractals that were produced
    by the previous command line. (These are better in color.)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig11.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Randomly generated IFS fractals*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Even without color, we get a taste of what random IFS can do. The numbers identify
    the fractal. The maps used are in *ifs_maps_271828.txt*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '***IFS Maps***'
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we understand the process of iterating a function system represented
    as a collection of matrices and probabilities, we’ll generate our own IFS maps.
    This section is optional, as some linear algebra is involved.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Figure 7-12](ch07.xhtml#ch07fig12).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig12.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: The three contraction maps of the Sierpiński triangle*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: This shows the effect of the three maps that make up the Sierpiński triangle.
    The maps take the unit square (outermost square) and map it to one of the three
    smaller squares. The diagonal line shows the orientation to clarify flips or rotations.
    Here the mappings shrink the unit square and offset it from the origin, but they
    don’t flip or rotate. The recursive self-similar appearance of the attractor comes
    from repeating this mapping in each of the smaller squares, repeating in each
    of those, and so on forever.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Let’s turn the illustration in [Figure 7-12](ch07.xhtml#ch07fig12) into three
    3×3 matrices, or maps. We’ll track where the three points of the unit square,
    (0, 0), (1, 0), and (0, 1), end up in each map.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin with the top map that maps the unit square into the range [0.25,
    0.75] in *x* and [0.5, 1] in *y*. The map takes any point in the unit square to
    the proper place in this smaller square. The point at (1, 0) must map to (0.75,
    0.5); similarly, (0, 0) *→* (0.25, 0.5) and (1, 0) *→* (0.25, 1). How do we find
    the matrix ***M*** that does this?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, we need ***M*** to act like so
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-01.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: for properly selected *a*, *b*, *c*, *d*, *e*, and *f*. The same matrix must
    also map (0, 0) and (0, 1) to (0.25, 0.5) and (0.25, 1), respectively.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing matrix multiplication gives us two equations to map (1, 0) to (0.75,
    0.5):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-02.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: The third equation contains only constants, so we’ll ignore it going forward.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two other points to consider that use the same matrix, so we have four
    more equations:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-03.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 'Let’s find *a*, *b*, and *e*. The process repeats to find *c*, *d*, and *f*.
    If we group equations involving *a*, *b*, and *e*, we get:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-04.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: 'This gives us three equations and three unknowns, so we can find a unique solution.
    First, let’s rewrite the equations in matrix form:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-05.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: This is a matrix equation of the form ***b*** = ***Ax***, and we want to find
    ***x***. One approach is to use *Cramer’s rule*, which solves the equation, element
    by element, as the ratio of determinants. In particular, we find each element
    of ***x*** as
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-06.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: 'for |***A***| the determinant of the matrix and |***A**[i]*| the determinant
    of a matrix formed by replacing the *i*th column of ***A*** with ***b***. Therefore,
    we get *a*, *b*, and *e* like so:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0237-01.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: Working through the determinants, perhaps by using NumPy’s `np.linalg.det` function,
    tells us that *a* = 0.5, *b* = 0.0, and *e* = 0.25\. The corresponding equations
    for *c*, *d*, and *f* give 0.0, 0.5, and 0.5, respectively.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the mapping matrix we need:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0237-02.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: This is indeed one of the `sierpinski` matrices in *ifs.py*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: We can generalize this process to write immediate solutions for a desired map.
    Assume three points on the unit square, (*a*[0], *a*[1]), (*b*[0], *b*[1]), and
    (*c*[0], *c*[1]). If their desired positions after mapping are (*A*[0], *A*[1]),
    (*B*[0], *B*[1]), and (*C*[0], *C*[1]), then we can find the map by calculating
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0237-03.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: 'and:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0237-04.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: This process gives the maps, but says nothing about the associated probability
    for selecting the map when playing the chaos game. Intuition and experimentation
    help with assigning probabilities.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: There are a plethora of IFS-related programs out there, many of which let you
    design IFS mappings interactively, so you need not work through the map calculations
    by hand. For example, Larry Riddle’s IFS Construction Kit is a Windows program
    for creating and animating IFS fractals that includes a graphical designer (*[https://larryriddle.agnesscott.org/ifskit](https://larryriddle.agnesscott.org/ifskit)*).
    I was able to run the program under Linux using `wine` after downloading the missing
    *.ocx* and *.dll* files Riddle refers to on the installation page.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s no end to creating generative art. Here are some exercises related
    to this chapter’s experiments:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The code in *moire.py* draws from a single point to the edges. Try drawing from
    a corner; then, try multiple points with different step sizes.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify *walker.py* to select a random color table index or use the step number
    modulo 256 to cycle through the color table.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why limit *walker.py* to a single walker?
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of available functions in *warp.py* is rather Spartan. Add new ones
    that assume inputs in [–1, 1] for both *x* and *y* and return new *x* and *y*
    values plus a color table index [0, 255].
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you change the probabilities for each map in *ifs.py*?
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new IFS maps for *ifs.py* using the manual process described in the text.
    Do they produce the expected result?
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new IFS maps using IFS Construction Kit or a similar program and add
    them to the library in *ifs.py*.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced us to randomness in generative art, though we only scratched
    the surface. We explored images generated by the moiré effect, random walkers,
    and the application of randomly selected warping functions and color tables.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了生成艺术中的随机性，虽然我们只触及了表面。我们探讨了通过莫尔条纹效应、随机漫步者以及随机选择的形变函数和颜色表生成的图像。
- en: Fractals came next. We learned that IFS have attractors, or self-similar fractals.
    The chaos game, using a random sequence of mappings, falls onto the attractor,
    thereby giving us a means for generating an infinite number of fractal images.
    Randomly selected sets of maps produce fascinating and mesmerizing collections
    of fractal images. There seems to be a deep connection between the formation of
    structures in nature and the attractors of IFS.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是分形的内容。我们了解到IFS有吸引子，或者说是自相似的分形。通过使用随机映射序列，混沌游戏会落在吸引子上，从而为我们提供了一种生成无限多分形图像的方法。随机选择的映射集合会生成迷人且令人着迷的分形图像集合。自然界结构的形成似乎与IFS的吸引子之间有着深刻的联系。
- en: This chapter focused on what is pleasant to look at. In the next chapter, we’ll
    delve into what is pleasant to listen to.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本章聚焦于视觉上令人愉悦的内容。在下一章，我们将深入探讨听觉上令人愉悦的内容。
