- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ART**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll explore generative art—images created by algorithms that
    use randomness. We’ll begin with “random art,” a catchall phrase for three different
    approaches to producing artistic images. Alternative methods exist, but these
    will give you a taste of what’s possible. We’ll also learn about fractals, which
    were extremely popular a few decades ago when personal computers were finally
    powerful enough to do interesting things with graphics.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll generate many color images in this chapter, though this book is in black
    and white. I suggest running the code to see them properly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Random Art**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll begin with three examples. The first mimics a program that amazed early
    Apple II personal computer enthusiasts. It also introduces us to Python’s turtle
    graphics package.
  prefs: []
  type: TYPE_NORMAL
- en: The second implements a random walk, effectively a simulation of Brownian motion,
    the wanderings of particles in a fluid when viewed through a microscope. It’s
    a simple process that, with appropriate color tables, leads to pleasant images
    suitable for T-shirts and coffee mugs.
  prefs: []
  type: TYPE_NORMAL
- en: The last example warps a two-dimensional grid of points using randomly selected
    functions, rotations, and color tables to generate unique images, likewise suitable
    for print.
  prefs: []
  type: TYPE_NORMAL
- en: '***Moiré Patterns***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Moiré patterns* occur in digital images when the discrete world of the computer
    screen meets what should be a continuous representation, that is, when drawing
    a line that can’t be accurately represented by the grid imposed by the display.
    [Figure 7-1](ch07.xhtml#ch07fig01) shows an example.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: “Brian’s Theme” as rendered by an Apple II computer*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](ch07.xhtml#ch07fig01) is 1979’s “Brian’s Theme,” a simple BASIC
    program created by Brian Howard; it could be found on the Apple II DOS 3.3 system
    master diskette from 1983\. The program selected a random point, from which it
    drew line after line to the edge of the screen, stepping each time by a randomly
    selected value. The crude resolution of the 280×160-pixel Apple II display, along
    with the funky way points were colored when plotting, produced a moiré pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create our own moiré patterns. The code we want is in *moire.py*. It introduces
    us to Python’s turtle graphics module (`turtle`), part of the standard Python
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The phrase* turtle graphics *comes from the Logo programming language, which
    used a graphical “turtle” to drag a pen across the screen to teach programming
    concepts to children.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simple commands like `FD 10` (forward 10), `RT 90` (right turn 90 degrees),
    and `PD` (pen down) made it possible to create complex drawings with relatively
    little programming knowledge; imagine an old-school spirograph game, but on the
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: We want the turtle to draw straight lines from a randomly selected point near
    the center to the edges, stepping by some distance along the edge each time. The
    result is something like [Figure 7-2](ch07.xhtml#ch07fig02).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: “Brian’s Theme” redux*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](ch07.xhtml#ch07fig02) is nothing more than straight line after
    straight line; the pattern emerges from the moiré effect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the necessary modules and ask the turtle to configure the
    display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We configure the turtle, here `tu`, to go as fast as it can and then hide itself
    (`ht` for “hide turtle”). This way, we see only what it draws.
  prefs: []
  type: TYPE_NORMAL
- en: The drawing window is adjusted to 500×500 pixels with a black background. The
    *x* and *y* dimensions follow using NumPy’s `linspace` to generate 400 point vectors
    spanning –200 to 200\. The turtle’s screen places the origin in the center of
    the display window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll draw a moiré pattern, wait a bit, then clear the screen and draw another—interactive
    visual art at its finest. We need a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To start a drawing, we clear the screen and select the origin point (`X`, `Y`)
    and the `step` size. We specify color as red, green, and blue using HTML notation;
    for example, `#FF0000` is bright red, `#E0B0FF` is mauve, `#A0522D` is sienna,
    and so on, mixing red, green, and blue in proportion.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple loop then uses `Line` to draw the pattern from the center point to
    each of the four screen edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Line` method first draws the requested line in white, then backs over it
    using the randomly selected color to produce a flashing effect.
  prefs: []
  type: TYPE_NORMAL
- en: Given the speed of modern computers, you might expect the moiré pattern to flash
    on the screen. However, Python’s turtle is similar to its namesake in that it
    draws the pattern at its leisure, essentially matching the speed of the Apple
    II code we’re mimicking.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll return to turtle graphics later in the chapter. For now, it’s time to
    take a walk.
  prefs: []
  type: TYPE_NORMAL
- en: '***Random Walks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *random walk* algorithm follows the “two steps forward, one step backward”
    model in two dimensions: beginning at the origin, repeatedly take steps in random
    directions. To turn this trivial algorithm into art, we track the sequence of
    steps to create an image where each step is assigned a color from one of Matplotlib’s
    color tables.'
  prefs: []
  type: TYPE_NORMAL
- en: A color table—also called a color map or lookup table—is a list of colors in
    red, green, and blue format. Most color tables, Matplotlib’s included, have 256
    entries. For example, if some value of interest is 129, or assignable to 129,
    then the associated color is stored at index 129 of the color table currently
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the desired index is 129 and the color table is `viridis`, then the resulting
    RGB color value is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet demonstrates how to access Matplotlib’s color tables, but
    the output might not be as expected. Why are there four values, and why are they
    not in the range [0, 255] like turtle graphics’ hexadecimal color values? RGB
    color values are often mapped to [0, 1], or as fractions of the maximum possible
    value of 1.0\. To find the corresponding byte value, multiply by 255 and keep
    the integer part. The color in the previous code is `#20918C` in hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: This explains the first three values, but the fourth component is the alpha
    value, representing the color’s transparency. An alpha value of 1.0 is opaque,
    0.0 is transparent, and 0.5 blends the color and the color of the pixel behind
    it (similar to stacked graphics planes). For our purposes, we’ll allow for transparent
    backgrounds (what this means will become apparent when examining the code).
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib comes with 84 predefined color tables, called *maps*; see *color_map_names.txt*
    for a list. Our random walk code supports all of them in any combination.
  prefs: []
  type: TYPE_NORMAL
- en: While random walks “repeatedly take steps in random directions,” I didn’t specify
    the allowed set of directions. From a point, (*x*, *y*), there are either four
    or eight possible directions one might go, as shown in [Figure 7-3](ch07.xhtml#ch07fig03).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: The four (left) or eight (right) directions a random walker can
    move*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Random walkers on the left (called *4-connected*) are restricted to the cardinal
    directions: north, south, east, or west. Those on the right (*8-connected*) have
    the option to walk diagonally. The code in *walker.py* supports both options.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the offsets from (*x*, *y*) are marked. If you’re used to plotting
    with Cartesian coordinates, as in math class, you might be a bit thrown by the
    signs. Ordinarily, we expect to plot in the first quadrant with *x* and *y* both
    positive and increasing to the right and up, respectively; this is not how most
    computers handle things. Instead, they put the origin at the upper-left corner
    of the screen so *y* increases as you move down and *x* increases as you move
    to the right. Mathematically, we’re plotting in the fourth quadrant and ignoring
    the sign of the *y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run *walker.py* and see what it gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The command produces an output image according to the given extension, here
    a PNG file; see [Figure 7-4](ch07.xhtml#ch07fig04).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: Sample random walker output*'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument tells the code to take a 4-connected walk. The second is
    the number of steps to take *per specified color table*. The color tables come
    next, separated by commas and no spaces. Here, I’ve repeatedly used Matplotlib’s
    `Reds` and `Oranges`. With 1,000,000 steps per color table and four color tables,
    the image in [Figure 7-4](ch07.xhtml#ch07fig04) represents a stroll of 4 million
    random steps, each generating a single pixel.
  prefs: []
  type: TYPE_NORMAL
- en: After the color tables, we add the background color or the word `none` for a
    transparent background. We can specify colors using HTML hexadecimal format without
    the leading `#` so that `000000` is a black background and `FFFFFF` is white.
  prefs: []
  type: TYPE_NORMAL
- en: The following argument is the orientation for the output image. The walk will
    naturally be more extensive in one direction or the other. This argument orients
    the output as either `portrait` so the longest dimension of the output image is
    in the *y* direction, or `landscape` to use the *x* dimension.
  prefs: []
  type: TYPE_NORMAL
- en: The final two arguments are the randomness source and seed value for the source.
    Both are optional.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I called the output file* tshirt.png *because I used this example to make
    an actual T-shirt. There are multiple online services where you can upload an
    image and order a shirt. If you want to make your own, I recommend many millions
    of steps, a transparent background, and even encapsulated PostScript output format
    (use a* .eps *file extension on the command line).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a walk through *walker.py*. I’ll skip the part that imports the
    usual modules and parses the command line. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We begin by configuring the randomness source. In this case, we choose random
    integers in the range [0, 3] if 4-connected and [0, 7] if 8-connected. We’ll use
    the values as indices into a list of *x* and *y* offsets and add the offsets to
    the current point to take a step. The three cases in the code handle specifying
    a randomness source, a source with a seed value, or defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the walk. The main loop tracks points in the lists `X` and `Y`,
    with colors in `C`. At this level, the loop is over the specified color tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Walk` function simulates a complete walk of `steps` steps for the current
    color table (`cname`) and `mode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the color table (`cmap`), and then we define `offset`, a list
    of *x* and *y* offset values for 4-connected and 8-connected walks. The walk itself
    begins at (0, 0) using the color at index 0 (`C`).
  prefs: []
  type: TYPE_NORMAL
- en: The loop over `steps` simulates the walk. We add a randomly selected offset
    to the last position for both *x* and *y*. Consider the code to select the color
    ➊. The loop index, `i`, ranges over [0, steps). Dividing by `steps` produces a
    fraction, [0, 1). Multiplying by 256 selects an index of the color table. Therefore,
    a full random walk steps through the entire color table once. There are other
    options to experiment with; see “Exercises” on [page 238](ch07.xhtml#ch00lev1_49).
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, there is no output image, only a collection of points (*x*, *y*) and
    associated colors in `C`. To make an image, we need `CreateOutputImage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The function is in three parts. The first makes NumPy vectors of the *x* and
    *y* points and determines the extent in each direction (`dx`, `dy`) to specify
    the output image, `img`. The output image uses 4 as the number of channels, not
    3 as we’ve used previously; because we want to support a transparent background,
    we need to explicitly specify the alpha channel.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the entire image to the transparent background color. Use 0 for
    the alpha channel for a transparent background and 255 for one that is completely
    opaque.
  prefs: []
  type: TYPE_NORMAL
- en: We loop over the points, mapping each point to a pixel of the image with explicit
    red, green, and blue color values. Review the assignments to `xx` and `yy` to
    follow how they map raw points to valid image coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how `img` is indexed. The code assigns the point (*x*, *y*) to the image,
    but the image is indexed as `(yy,xx)`. Images are indexed by row and then by column,
    meaning the *y*-coordinate—using the origin at the upper-left corner convention—represents
    the row, and the *x* the column.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re almost done. The `CreateOutputImage` function returns the image as specified
    by the actual points of the walk. To produce the final output, we reorient the
    image to respect the portrait or landscape orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `transpose` method rearranges the columns of a NumPy array as specified.
    We swap rows and columns as needed, but ensure the number of channels remains
    in place. Read through *walker.py* to follow the overall flow of the code.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included several example outputs in the chapter files to inspire you to
    create your own. I especially like *example1.png*; it reminds me of the sci-fi
    sets used in *Doctor Who* episodes from the 1970s. The *example5.png* file uses
    *hotbits.bin* when that file was 1,130,496 bytes. The cyclic pattern is due to
    the number of requested points, which exceeds the number of random samples extracted
    from the file, thereby repeating. The *example5.txt* file contains the text of
    the command. If you create any compelling examples, please share them. I’ll make
    a small gallery on the book’s GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s change gears and use randomness in combination with determinism to produce
    images constructed from warpings of the *xy*-plane.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Grid***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What happens if you take an evenly spaced grid of points in two dimensions,
    apply a function that maps each point to a new point, then plot the points? In
    other words, what happens when you warp a grid of points? In this section, we’ll
    discover the answer and use it to build random works of abstract digital art.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-5](ch07.xhtml#ch07fig05) illustrates the basic process.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: A grid of points (left) and the same grid warped (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: On the left of [Figure 7-5](ch07.xhtml#ch07fig05), we have a grid of 30×30 points.
    We apply a function to each point, (*x*, *y*), to generate a new point, (*x′*,
    *y′*), plotted on the right of [Figure 7-5](ch07.xhtml#ch07fig05).
  prefs: []
  type: TYPE_NORMAL
- en: 'The function is:'
  prefs: []
  type: TYPE_NORMAL
- en: (*x′*, *y′*) *←* (*y*³ + *x*, *x*² + *y*)
  prefs: []
  type: TYPE_NORMAL
- en: For input point (*x*, *y*), the output *x*-coordinate is *y*³ + *x* and the
    *y*-coordinate is *x*² + *y*.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the function (*x*, *y*) *→* (*yx*², *xy*²) changes the uniform grid
    of points into [Figure 7-6](ch07.xhtml#ch07fig06).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: A uniform grid warped by (*x,y*) → (*yx^(*2,*) xy^(*2*)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll generate a set of warping functions, select one randomly, and apply it
    to the uniform grid of points. Then, we repeat this process for a specified number
    of cycles, keeping all output points as we go.
  prefs: []
  type: TYPE_NORMAL
- en: To add color, we make each warping function return a color table index along
    with the new point location. Therefore, each warping function maps an input point
    to a new output point and color table index. Each cycle selects a new color table
    at random.
  prefs: []
  type: TYPE_NORMAL
- en: To add more randomness, we’ll shift the collection of points by adding randomly
    selected *x* and *y* offsets. Because we’re adventurous types, we’ll also rotate
    the points by a random angle about the origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve defined a collection of five warping functions, two of which we’ve already
    seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0221-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The input grid is always in [–1, 1]. Each function returns the new point and
    color table index found by keeping the integer part after multiplying the third
    return value by 255\. The cumulative effect of the random function applications,
    rotations, offsets, and color tables produces the desired output image.
  prefs: []
  type: TYPE_NORMAL
- en: The code is in *warp.py*. Run it like so
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: to produce [Figure 7-7](ch07.xhtml#ch07fig07).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Warping in action*'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to *warp.py* is the number of points along each grid dimension.
    The second is the number of cycles, or the number of times we apply a randomly
    selected function to the grid. Finally, the last three arguments are the output
    image name, randomness source, and seed, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'First are the warp functions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This implements the first warping function in the collection. The remaining
    four functions are similar. We store the warp functions in a list so they can
    be selected at random:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The main body of *warp.py* parses the command line and loads the color table
    names from *color_map_names.txt*. It then defines empty lists to hold all the
    (*x*, *y*) points and associated RGB colors, `X`, `Y`, and `C`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The grid is specified as an `npoints` long vector from –1 to +1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'All the action is in the loops over cycles and grid points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The outermost loop over `k` handles the cycles. Each cycle randomly selects
    a color map (`cmap`) and a warp function (`fn`). It also selects random *x* and
    *y* offsets (`xoff`, `yoff`) and a rotation angle (`theta`).
  prefs: []
  type: TYPE_NORMAL
- en: The two inner loops, over `i` and `j`, walk through `v` in both the *x* and
    *y* directions; they visit every point in the 2D grid. The selected function is
    applied to each point, `n,m,c = fn(v[i],v[j])`, to return a new point (*n*, *m*)
    and color table index (`c`). To rotate a point about the origin, we multiply it
    by a rotation matrix
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0223-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'which, following the rules for matrix multiplication, becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0223-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This matches the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation complete, the final step is to add the *x* and *y* offsets. These shift
    the points in the *x* and *y* directions to keep them from overlapping.
  prefs: []
  type: TYPE_NORMAL
- en: Every warped, rotated, and offset point is appended to the list of points and
    colors. Notice that the warping function returns a color table index, but `C`
    holds the tuple returned by `cmap` for the current color table.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all cycles complete, we produce the plot and dump it to disk. Matplotlib
    obliges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here `oname` is the output image name; it’s taken from the command line argument.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Matplotlib’s `plot` command, `scatter` accepts a list of per-point colors,
    which is why we constructed `C` for each point. The `tight_layout` command removes
    extraneous space, which is handy after turning the axes off.
  prefs: []
  type: TYPE_NORMAL
- en: Run *warp.py* a few times to experiment with the code. If you make the grid
    too fine, with the first argument above 300 or thereabouts, you may run out of
    memory. While it isn’t necessary to specify a pseudorandom generator and seed
    value, doing so lets you re-create the output. The file *warp_factor_9.py* uses
    a single pseudorandom generator with a user-supplied global seed to create a specified
    number of warp images. I ran the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: to create 100 images in the *warpings* directory. It took about 15 minutes to
    run and produced some attractive output. Matplotlib’s cyclic color tables, like
    `flag`, make stunning displays.
  prefs: []
  type: TYPE_NORMAL
- en: While *warp.py* makes pretty pictures, the randomness isn’t particularly profound;
    it selects from among a set of options, relying on combinations of possible options
    to produce novelty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following section introduces us to fractals: a world of math, emergent
    behavior, and randomness.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fun with Fractals**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Fractals* are mathematical objects constructed from smaller copies of themselves;
    they are *self-similar*. Mathematical fractals are our focus, but approximate
    fractals are a common sight in nature—for example, the branching of a tree, the
    airways in your lungs, and the fronds of a fern.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore randomness as a means of generating fractal images.
    There is a rich literature on fractals for art and computer graphics. We’ll accomplish
    the barest of introductions.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll play the chaos game to build simple fractal images with Python’s
    turtle. Then, we’ll learn about a more sophisticated approach to generating fractal
    images, iterated function systems (IFS). Finally, we’ll put everything together
    to build *ifs.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Chaos Game***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s play the *chaos game*, so named by mathematician and fractal explorer
    Michael Barnsley. It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Pick three points, (*x*[0], *y*[0]), (*x*[1], *y*[1]), and (*x*[2], *y*[2]),
    to form the vertices of a triangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set *x* = *x*[0] and *y* = *y*[0].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick a vertex of the triangle at random, (*x[n]*, *y[n]*) for *n* in [0, 2].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update using *x ←* 0.5(*x* + *x[n]*) and *y ←* 0.5(*y* + *y[n]*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plot (*x*, *y*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from step 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This algorithm plots points in the *xy*-plane. Let’s find out whether the set
    of points eventually covers the plane, or there’s a pattern of some kind. Run
    *sierpinski.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A small window should appear. The Python turtle is also there, jumping around
    the window seemingly at random. Each time it moves, it leaves a small dot behind.
    The dot color corresponds to which triangle vertex was selected in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: Let the program run for some length of time to draw whatever it is it wants
    to draw. When you have waited as long as you can for the turtle to do its thing,
    press a key and examine the resulting image. It should look similar to [Figure
    7-8](ch07.xhtml#ch07fig08).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: The chaos game in action*'
  prefs: []
  type: TYPE_NORMAL
- en: The image is a fractal known as the Sierpiński triangle after Wacław Sierpiński,
    a Polish mathematician who explored such shapes in 1915.
  prefs: []
  type: TYPE_NORMAL
- en: Fractals are constructed from copies of themselves. For example, the main triangle
    is built from three smaller triangles, each constructed from three still smaller
    triangles, and so on forever. Therefore, the game didn’t fill the *xy*-plane but
    only a subset of points on it. Such things are called “fractal” because their
    dimension is a noninteger.
  prefs: []
  type: TYPE_NORMAL
- en: The fractal is more than a line, dimension 1, and less than a plane, dimension
    2\. There are multiple ways to define a fractal dimension, but perhaps the most
    common is the Hausdorff dimension. For the Sierpiński triangle, the Hausdorff
    dimension is log 3 / log 2 = 1.5849625 . . . , greater than a line but less than
    a plane.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at *sierpinski.py*, shown in [Listing 7-1](ch07.xhtml#ch07list01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1: Uncovering the Sierpiński triangle*'
  prefs: []
  type: TYPE_NORMAL
- en: The first code paragraph configures the turtle, some colors, and the pseudorandom
    generator (`rng`). It also defines two lists holding the triangle’s vertices,
    `X` and `Y`. The other important bit is assigning `x` and `y` to the first vertex.
    Any random initial value will do, but a few iterations of the game might be necessary
    to land on points within the fractal.
  prefs: []
  type: TYPE_NORMAL
- en: The second paragraph is merely for convenience. It defines a global, `done`,
    and an event handler for turtle graphics to call when we press a key. The handler’s
    sole task is to set global `done` to `True` so the `while` loop exits. The turtle’s
    `onkeypress` and `listen` methods tell the turtle that it should listen for keypresses
    in the drawing window and perform some action when it hears one.
  prefs: []
  type: TYPE_NORMAL
- en: All the cool stuff is in the third paragraph—the `while` loop that runs until
    a keypress. It selects a vertex at random, `n`, and updates `x` and `y` before
    placing a properly colored dot at that point. The process repeats, placing point
    after point.
  prefs: []
  type: TYPE_NORMAL
- en: The chaos game uses the vertices of the triangle and randomness to uncover the
    *attractor* of the fractal, or the set of points that make up the fractal.
  prefs: []
  type: TYPE_NORMAL
- en: The chaos game works for *n*-sided polygons (*n* > 2) as well, as the code in
    *polygon.py* demonstrates. I won’t walk through it here; it’s a glorified version
    of *sierpinski.py* accepting *n* on the command line, followed, optionally, by
    a randomness source and a seed value. [Figure 7-9](ch07.xhtml#ch07fig09) shows
    the results for *n* = 5 and *n* = 9.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: The chaos game with five-sided (left) and nine-sided polygons
    (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: Read through *polygon.py* to understand what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: '***Iterated Function Systems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section introduces us to *iterated function systems (IFS)*, systems of
    equation that map points in the plane to other locations. In the following section,
    we combine IFS and the chaos game to generate fractals, the attractors of the
    IFS. Let this serve as a warning that there’s math with vectors and matrices ahead.
    If these are unfamiliar beasts, have no worries. We can use IFS to make fantastic
    images without grasping all of the details behind the process. Still, it’s best
    to understand at a deeper level if we have the option.
  prefs: []
  type: TYPE_NORMAL
- en: To build an IFS, we need to understand a few concepts. First, that matrices
    map vectors in the *xy*-plane to new vectors in the *xy*-plane. Second, that a
    vector in the *xy*-plane is another way to refer to a point, (*x*, *y*). Third,
    what a contraction mapping is. And finally, that a set of contraction mappings—with
    offset vectors and associated probabilities—forms an IFS, enabling us to use the
    chaos game to create fractal images. Let’s begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we used a matrix to rotate a set of points by some angle, *θ*, about
    the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0227-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We write this as ***x**′* = ***Mx***, where the bold lowercase letters are vectors
    and the bold uppercase letter is a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: To be more specific, multiplying a two-dimensional vector
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0228-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: by a matrix
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0228-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'maps the vector to a new two-dimensional vector, ***x**′*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0228-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This also shows us how to multiply a two-dimensional vector by a matrix: multiply
    each element of the rows of the matrix by the corresponding element of the vector
    and sum. We say the matrix ***M*** is a *mapping* from ***x*** to ***x**′*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.xhtml), we learned about the Euclidean distance between
    two points. Consider two vectors, ***x***[0] and ***x***[1], and their mappings
    under matrix ***M***: ![Image](../images/f0228-03a.jpg) and ![Image](../images/f0228-03b.jpg).
    If *d*(***x***[0], ***x***[1]) is the Euclidean distance between ***x***[0] and
    ***x***[1], and we have'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0228-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for 0 < *α* < 1, then ***M*** is a *contraction mapping* that moves points together.
    We’ll use contraction mappings for our IFS, with each mapping represented by a
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: A mapping may also include a constant offset vector added to the vector found
    by applying the matrix. We write this as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0228-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where adding vectors is element-wise, like NumPy. However, it’s more convenient
    to replace the 2×2 matrix with a 3×3 matrix incorporating the offset vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0228-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A set of contraction mapping matrices, {***M***[0], ***M***[1], ***M***[2],
    . . . }, forms an IFS where each ***M*** is a 3×3 matrix combining a mapping with
    an offset vector. IFS have *attractors*, sets of points that subsequent mappings
    with the IFS send back to other points in the attractor. In this way, mapping
    a point on the attractor using one of the matrices in the IFS results in another
    point on the attractor. The points forming the attractor are the fractal we want
    to image, and the chaos game is the tool we use to find them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Fractals Plotted with Points***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re almost where we need to be. We have an IFS, a collection of matrices,
    ***M***. We also know that the chaos game helps us find the points on the attractor
    of the IFS. To adapt the chaos game to a set of matrices, we assign a probability
    to each map. Then, when playing the chaos game, we select the next map to apply
    based on that probability. The assigned probabilities alter the weighting of the
    attractor points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get practical. The code we’ll work with is in *ifs.py*. Read through
    the file to give yourself an overview. The majority of the file is the `IFS` class.
    Running *ifs.py* without arguments teaches us how to configure the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The words at the bottom of the output are assigned to different IFS, meaning
    different sets of mappings and probabilities. We specify the IFS we want on the
    command line by name. The maps are hardcoded in a dictionary embedded in the `IFS`
    class. For example, here’s the definition of the `sierpinski` IFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The IFS consists of three maps, or three 3×3 matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0229-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each is selected with probability 1/3 and is equally likely to be chosen when
    playing the chaos game.
  prefs: []
  type: TYPE_NORMAL
- en: The other IFS are defined similarly, though with more or fewer maps, as necessary.
    The `maple` IFS, and those following, are by Paul Bourke (*[https://paulbourke.net/fractals/ifs](https://paulbourke.net/fractals/ifs)*),
    used with permission. Bourke’s site is a treasure trove of fascinating computer
    graphics and geometry pages, including many on fractals and IFS. I highly recommend
    taking a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining command line arguments are as described, with two options worth
    special mention. The first is using `maps` for the color. Specifying `maps` has
    the same effect as *sierpinski.py*; points are plotted in a color associated with
    the selected IFS map. This option reveals the maps in the output image. The second
    is using `random` for the IFS, which generates an IFS at random and then iterates
    to find the fractal it represents. We’ll experiment with this option shortly.
    For now, let’s use the `fern` IFS to see what sort of output we get. Give this
    command line a go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It plots 1 million points of the attractor for the fern IFS using a different
    color for each of the four maps. The result is [Figure 7-10](ch07.xhtml#ch07fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: One million points of the fern attractor*'
  prefs: []
  type: TYPE_NORMAL
- en: The fourth map is the narrow stem of the fern. Explore the other fractals supported
    by *ifs.py* or browse the *misc* directory, which contains images of each using
    1 million points.
  prefs: []
  type: TYPE_NORMAL
- en: The *ifs.py* code uses Matplotlib to produce the output plot. Matplotlib’s graphics
    are interactive. Try generating 10 million points of the `shell` IFS and then
    click the magnifying glass icon and draw a box around the center to zoom in. With
    10 million points, you should be able to zoom in two or three times. The spiral
    continues forever.
  prefs: []
  type: TYPE_NORMAL
- en: That IFS fractals resemble objects in nature can’t be a mere coincidence; there
    must be a biological basis for self-similar patterns, even if they’re not rigorous
    but only approximate mathematical fractals.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s fun to look at the pretty fractal images *ifs.py* creates, it’s even
    more fun to understand the “how” behind them. Let’s examine the code and then
    experiment with purely random IFS fractals.
  prefs: []
  type: TYPE_NORMAL
- en: '**The IFS Class**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The dictionary of predefined maps constitutes the bulk of the `IFS` class.
    In terms of actual code, there are a handful of methods to contemplate: `ChooseMap`,
    `GeneratePoints`, `StoreFractal`, and `RandomMaps`. I’ll save `RandomMaps` for
    the next section; `StoreFractal` is a straightforward application of Matplotlib
    to plot the generated points using the associated colors. That leaves `GeneratePoints`
    and `ChooseMap`. Let’s begin with `GeneratePoints`, as shown in [Listing 7-2](ch07.xhtml#ch07list02).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2: Finding the points on the fractal attractor*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GeneratePoints` method fills in a NumPy array of `npoints` rows and three
    columns: *x*, *y*, and the index of the selected map. The code iterates a randomly
    initialized vector, `xy`. The third element, a constant 1, allows us to use 3×3
    matrices for the maps.'
  prefs: []
  type: TYPE_NORMAL
- en: A randomly selected point isn’t likely to be on the attractor; therefore, before
    we store points in `self.xy`, we iterate 100 times to ensure that new points are
    on the attractor. Each iteration involves selecting a map according to the assigned
    probabilities followed by a matrix multiplication with that map, ***x** → **Mx***,
    which becomes `xy = m @ xy` in code. NumPy uses `@` for matrix multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: While the `GeneratePoints` method does the lion’s share of the work, it relies
    on `ChooseMap` ([Listing 7-3](ch07.xhtml#ch07list03)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-3: Choosing a map*'
  prefs: []
  type: TYPE_NORMAL
- en: The `IFS` constructor creates member variables `nmaps`, `probs`, and `maps`
    according to the selected IFS. The `ChooseMap` method returns an index into the
    list of maps by picking a random number in [0, 1) (`r`) and then adding per-map
    probabilities until the accumulated sum (`a`) exceeds the selected value, at which
    point it returns the current index, `k`. The effect selects maps in proportion
    to their assigned probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `IFS` class is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The constructor accepts the number of points, fractal name, color, an initialized
    `RE` object, and a flag to show or hide the fractal when we call `StoreFractal`.
    The `GeneratePoints` and `StoreFractal` methods complete the process. Encapsulating
    `IFS` in a single class with a small main driver lets us use *ifs.py* as a program
    or module; we’ll use it as the latter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Random IFS**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Running *ifs.py* with `random` as the fractal name generates a set of random
    maps with random probabilities. Each map is a 3×3 matrix
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0232-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'with an associated probability, *p*. The six elements of the map must satisfy
    a set of constraints to be a contraction mapping. Specifically, the following
    must be true:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0232-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `RandomMaps` method creates a collection of maps and probabilities, as in
    [Listing 7-4](ch07.xhtml#ch07list04).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-4: Creating a random IFS*'
  prefs: []
  type: TYPE_NORMAL
- en: The code first chooses a random number of maps, [2, 5], and probabilities (`probs`).
    It then loops `nmaps` times, calling the embedded function, `mapping`, which returns
    a valid map matrix. The `mapping` method repeatedly selects random elements in
    [–1, 1) until all constraints are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create 100 random fractals to get a feel for what the attractor of a
    randomly generated IFS looks like. The file *ifs_maps.py* contains the code we
    need. It uses a master seed value passed on the command line to generate a collection
    of random fractals. Here’s the command line I used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you use the same command line, you’ll get the same collection of fractals
    in the *fractals* directory. The file *ifs_maps_271828.txt* contains the randomly
    generated maps and the seed value. The code in *ifs_maps.py* is only a few dozen
    lines, but it demonstrates how to use the `IFS` class inside another program.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-11](ch07.xhtml#ch07fig11) presents some fractals that were produced
    by the previous command line. (These are better in color.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Randomly generated IFS fractals*'
  prefs: []
  type: TYPE_NORMAL
- en: Even without color, we get a taste of what random IFS can do. The numbers identify
    the fractal. The maps used are in *ifs_maps_271828.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '***IFS Maps***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we understand the process of iterating a function system represented
    as a collection of matrices and probabilities, we’ll generate our own IFS maps.
    This section is optional, as some linear algebra is involved.
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Figure 7-12](ch07.xhtml#ch07fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: The three contraction maps of the Sierpiński triangle*'
  prefs: []
  type: TYPE_NORMAL
- en: This shows the effect of the three maps that make up the Sierpiński triangle.
    The maps take the unit square (outermost square) and map it to one of the three
    smaller squares. The diagonal line shows the orientation to clarify flips or rotations.
    Here the mappings shrink the unit square and offset it from the origin, but they
    don’t flip or rotate. The recursive self-similar appearance of the attractor comes
    from repeating this mapping in each of the smaller squares, repeating in each
    of those, and so on forever.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s turn the illustration in [Figure 7-12](ch07.xhtml#ch07fig12) into three
    3×3 matrices, or maps. We’ll track where the three points of the unit square,
    (0, 0), (1, 0), and (0, 1), end up in each map.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin with the top map that maps the unit square into the range [0.25,
    0.75] in *x* and [0.5, 1] in *y*. The map takes any point in the unit square to
    the proper place in this smaller square. The point at (1, 0) must map to (0.75,
    0.5); similarly, (0, 0) *→* (0.25, 0.5) and (1, 0) *→* (0.25, 1). How do we find
    the matrix ***M*** that does this?
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, we need ***M*** to act like so
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for properly selected *a*, *b*, *c*, *d*, *e*, and *f*. The same matrix must
    also map (0, 0) and (0, 1) to (0.25, 0.5) and (0.25, 1), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing matrix multiplication gives us two equations to map (1, 0) to (0.75,
    0.5):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The third equation contains only constants, so we’ll ignore it going forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two other points to consider that use the same matrix, so we have four
    more equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s find *a*, *b*, and *e*. The process repeats to find *c*, *d*, and *f*.
    If we group equations involving *a*, *b*, and *e*, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This gives us three equations and three unknowns, so we can find a unique solution.
    First, let’s rewrite the equations in matrix form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a matrix equation of the form ***b*** = ***Ax***, and we want to find
    ***x***. One approach is to use *Cramer’s rule*, which solves the equation, element
    by element, as the ratio of determinants. In particular, we find each element
    of ***x*** as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0236-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'for |***A***| the determinant of the matrix and |***A**[i]*| the determinant
    of a matrix formed by replacing the *i*th column of ***A*** with ***b***. Therefore,
    we get *a*, *b*, and *e* like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0237-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working through the determinants, perhaps by using NumPy’s `np.linalg.det` function,
    tells us that *a* = 0.5, *b* = 0.0, and *e* = 0.25\. The corresponding equations
    for *c*, *d*, and *f* give 0.0, 0.5, and 0.5, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the mapping matrix we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0237-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is indeed one of the `sierpinski` matrices in *ifs.py*.
  prefs: []
  type: TYPE_NORMAL
- en: We can generalize this process to write immediate solutions for a desired map.
    Assume three points on the unit square, (*a*[0], *a*[1]), (*b*[0], *b*[1]), and
    (*c*[0], *c*[1]). If their desired positions after mapping are (*A*[0], *A*[1]),
    (*B*[0], *B*[1]), and (*C*[0], *C*[1]), then we can find the map by calculating
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0237-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'and:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0237-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This process gives the maps, but says nothing about the associated probability
    for selecting the map when playing the chaos game. Intuition and experimentation
    help with assigning probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: There are a plethora of IFS-related programs out there, many of which let you
    design IFS mappings interactively, so you need not work through the map calculations
    by hand. For example, Larry Riddle’s IFS Construction Kit is a Windows program
    for creating and animating IFS fractals that includes a graphical designer (*[https://larryriddle.agnesscott.org/ifskit](https://larryriddle.agnesscott.org/ifskit)*).
    I was able to run the program under Linux using `wine` after downloading the missing
    *.ocx* and *.dll* files Riddle refers to on the installation page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s no end to creating generative art. Here are some exercises related
    to this chapter’s experiments:'
  prefs: []
  type: TYPE_NORMAL
- en: The code in *moire.py* draws from a single point to the edges. Try drawing from
    a corner; then, try multiple points with different step sizes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify *walker.py* to select a random color table index or use the step number
    modulo 256 to cycle through the color table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why limit *walker.py* to a single walker?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of available functions in *warp.py* is rather Spartan. Add new ones
    that assume inputs in [–1, 1] for both *x* and *y* and return new *x* and *y*
    values plus a color table index [0, 255].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you change the probabilities for each map in *ifs.py*?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new IFS maps for *ifs.py* using the manual process described in the text.
    Do they produce the expected result?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new IFS maps using IFS Construction Kit or a similar program and add
    them to the library in *ifs.py*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced us to randomness in generative art, though we only scratched
    the surface. We explored images generated by the moiré effect, random walkers,
    and the application of randomly selected warping functions and color tables.
  prefs: []
  type: TYPE_NORMAL
- en: Fractals came next. We learned that IFS have attractors, or self-similar fractals.
    The chaos game, using a random sequence of mappings, falls onto the attractor,
    thereby giving us a means for generating an infinite number of fractal images.
    Randomly selected sets of maps produce fascinating and mesmerizing collections
    of fractal images. There seems to be a deep connection between the formation of
    structures in nature and the attractors of IFS.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focused on what is pleasant to look at. In the next chapter, we’ll
    delve into what is pleasant to listen to.
  prefs: []
  type: TYPE_NORMAL
