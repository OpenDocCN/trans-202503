- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UML INTERACTION DIAGRAMS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Interaction diagrams model the operations that occur between different objects
    (participants) in a system. There are three main types of interaction diagrams
    in UML: sequence, collaboration (communication), and timing. The majority of this
    chapter will focus on sequence diagrams, followed by a very brief discussion of
    collaboration diagrams.'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.1 Sequence Diagrams**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sequence diagrams show the interaction between participants (actors, objects)
    in the order in which it takes place. Whereas activity diagrams describe the particulars
    of one operation on an object, sequence diagrams tie activity diagrams together
    to show the order in which multiple operations occur. From a design perspective,
    sequence diagrams are more informative than activity diagrams as they illustrate
    the overall architecture of the system; at the (lower) level of an activity diagram,
    however, a system architect can usually safely assume that the software engineer
    implementing the system can figure out the activities required by the design.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.1 Lifelines***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the top of a sequence diagram you draw the set of participants, using rectangles
    or stick figures (see [Figure 7-1](ch07.xhtml#ch7fig1)), and then draw a dashed
    line from each participant to the bottom of the diagram to indicate that object’s
    lifeline. *Lifelines* show the flow of time from the earliest (topmost) point
    of execution to the latest (bottommost) point. However, lifelines by themselves
    do not indicate the *amount* of time that passes, only the passage of time from
    the top to the bottom of the diagram, and equal line lengths need not correspond
    to the same amount of time—a 1 cm section at one point could be days, while a
    1 cm section elsewhere could be microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: A basic sequence diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.2 Message Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Communication between participants takes the form of *messages* (which I will
    sometimes call *operations*), which consist of an arrow drawn between lifelines,
    or even from one lifeline to itself.
  prefs: []
  type: TYPE_NORMAL
- en: There are four types of message arrows you can use, as shown in [Figure 7-2](ch07.xhtml#ch7fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Message types in sequence diagrams*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Synchronous* messages are the typical call/return operation that most programs
    use (to execute object methods, functions, and procedures). The sender suspends
    execution until the receiver returns control.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Return* messages indicate that control returns from a synchronous message
    back to the message sender, but they are purely optional in a sequence diagram.
    An object cannot continue execution until a synchronous message completes, so
    the presence of some other message (received or sent) on the same timeline inherently
    implies a return operation. Because a large number of return arrows can obfuscate
    a sequence diagram, it’s best to leave them off if the diagram starts to get cluttered.
    If the sequence diagram is relatively clean, however, a return arrow can help
    show exactly what is happening.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Asynchronous* messages trigger an invocation of some code in the receiver,
    but the message sender does not have to wait for a return message before continuing
    execution. For this reason, there’s no need to draw an explicit return arrow for
    an asynchronous call in your sequence diagrams.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Flat* messages can be either synchronous or asynchronous. Use a flat message
    when the type doesn’t matter for the design and you want to leave the choice up
    to the engineer implementing the code. As a general rule, you do not draw return
    arrows for flat messages because that would imply that the implementer must use
    a synchronous call.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Flat messages are UML 1.*x *entities only. In UML 2.0, asynchronous messages
    use the full open arrowhead instead.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.3 Message Labels***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you draw a message, you must attach a label to the message’s arrow. This
    label could simply be a description of the message, as in [Figure 7-3](ch07.xhtml#ch7fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Message labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The sequence of messages is indicated by their vertical placement. In [Figure
    7-3](ch07.xhtml#ch7fig3), the “Select immediate pool clean” label is the first
    message line in the diagram, meaning it is the first operation to execute. Moving
    downward, “Turn on pump” is the second message line, so it executes next. The
    return from “Turn on pump” is the third operation and the return from “Select
    immediate pool clean” is the fourth.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.4 Message Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As your sequence diagrams become more complex, it may be difficult to determine
    the execution order from the message position alone, so it can be helpful to attach
    additional indicators like numbers to each message label. [Figure 7-4](ch07.xhtml#ch7fig4)
    uses sequential integers, though UML doesn’t require this. You could use numbers
    like 3.2.4 or even non-numeric indicators (for example, A, B, C). However, the
    goal is to make it easy to determine the message sequence, so if you get too carried
    away here you might defeat that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: Message numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: Although the message labels you’ve seen thus far are relatively straightforward
    descriptions, it’s not uncommon to use the actual operation names, parameters,
    and return values as labels on message arrows, as in [Figure 7-5](ch07.xhtml#ch7fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Message arguments and return values*'
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.5 Guard Conditions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Your message labels can also include guard conditions: Boolean expressions
    enclosed in brackets (see [Figure 7-6](ch07.xhtml#ch7fig6)). If the guard expression
    evaluates to `true`, the system sends the message; if it evaluates to `false`,
    the system does not send the message.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: Message guard conditions*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 7-6](ch07.xhtml#ch7fig6), the `pMon` object sends a `pump(100)` message
    to `pump` only if `pumpPower` is `on` (`true`). If `pumpPower` is `off` (`false`)
    and the `pump(100)` message does not execute, the corresponding return operation
    (sequence item 3) will not execute either, and control will move to the next outgoing
    arrow item in the `pMon` lifeline (sequence item 4, returning control to the user
    object).
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.6 Iterations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also specify the number of times a message executes by providing an
    iteration count in a sequence diagram. To specify an iteration, you use an asterisk
    symbol (`*`) followed by a guard condition or `for` loop iteration count (see
    [Figure 7-7](ch07.xhtml#ch7fig7)). The system will repeatedly send the message
    as long as the guard condition is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Partial sequence diagram with iteration*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 7-7](ch07.xhtml#ch7fig7), the message executes 100 times, with the
    variable `i` taking on the value `1` through `100`, incrementing on each iteration.
    If the `pumpPwrAndDelay` function applies the percent power specified as the argument
    and delays for 1 second, then in about 1 minute, 40 seconds, the pump will be
    running at full speed (increasing by 1 percent of the total speed each second).
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.7 Long Delays and Time Constraints***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sequence diagrams typically describe only the order of messages, not the amount
    of time each message takes to execute. Sometimes, however, a designer might want
    to indicate that a particular operation might take a long time relative to others.
    This is particularly common when one object sends a message to another object
    located outside the bounds of the current system (for example, when a software
    component sends a message to some object on a remote server across the internet),
    which we’ll discuss shortly. You indicate that an operation will take longer by
    pointing the message arrow slightly downward. In [Figure 7-8](ch07.xhtml#ch7fig8),
    for example, you would expect the `scheduledClean()` operation to take more time
    than a typical operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: Timed messages with timing constraints*'
  prefs: []
  type: TYPE_NORMAL
- en: You must also specify the expected amount of time for each message by adding
    some sort of constraint to the diagram. [Figure 7-8](ch07.xhtml#ch7fig8) demonstrates
    this with a dashed vertical arrow from the start of the `scheduledClean()` operation
    to the point on the lifeline where the system returns control to the Timer Module
    actor (probably the physical timer on the pool monitor system). The required time
    constraint appears inside braces next to the dashed arrow.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.8 External Objects***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Occasionally a component of a sequence diagram must communicate with some object
    *external* to the system. For example, some code in the pool monitor might check
    the salinity level and send an SMS message to the owner’s cell phone if it drops
    too low. The code to actually transmit the SMS message is probably handled by
    an Internet of Things (IoT) device and thus outside the scope of the pool monitor
    software; hence, the SMS code is an external object.
  prefs: []
  type: TYPE_NORMAL
- en: You draw a heavy border around external objects and use a solid line for their
    lifelines rather than a dashed line (see [Figure 7-9](ch07.xhtml#ch7fig9)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: External objects in a sequence diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 7-9](ch07.xhtml#ch7fig9), the Timer Module makes an asynchronous
    call to the `salinity` object, and there is no return from the `salinityCheck()`
    operation. After that call, the Timer Module can perform other tasks (not shown
    in this simple diagram). Ten minutes later, as noted by the time constraint, the
    `salinity` object makes an asynchronous call to the Timer Module actor and has
    it update the salinity value on the display.
  prefs: []
  type: TYPE_NORMAL
- en: Because there isn’t an explicit time constraint on the `sendMsg()` operation,
    it could occur any time after the `salinityCheck()` operation and before the `updateSalinityDisp()`
    operation; this is indicated by the `sendMsg()` message arrow’s position between
    the other two messages.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.9 Activation Bars***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Activation bars indicate that an object is instantiated and active, and appear
    as open rectangles across a lifeline (see [Figure 7-10](ch07.xhtml#ch7fig10)).
    They are optional, as you can generally infer the lifetime of an object simply
    by looking at the messages traveling to and from it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: Activation bars*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For the most part, activation bars clutter up sequence diagrams, so this book
    will not use them. They’re described here just in case you encounter them in sequence
    diagrams from other sources.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.10 Branching***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As noted in “Guard Conditions” on [page 131](ch07.xhtml#page_131), you can apply
    guard conditions to a message that say, effectively, “if `true`, then execute
    message; else, continue along this lifeline.” Another handy tool is branching—the
    equivalent of the C-style `switch`/`case` statement where you can select one of
    several messages to execute based on a set of guard conditions, one guard for
    each message. In order to execute different messages based on whether a pool uses
    chlorine or bromine as a sanitizer, you might be tempted to draw branching logic
    as shown in [Figure 7-11](ch07.xhtml#ch7fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Bad implementation of branching logic*'
  prefs: []
  type: TYPE_NORMAL
- en: In one aspect, this diagram makes perfect sense. If the sanitizer for this particular
    pool is bromine rather than chlorine, the first message does not execute and control
    flows down to the second message, which does execute. The problem with this diagram
    is that the two messages appear at different points on the lifeline and, therefore,
    could execute at completely different times. Particularly as your sequence diagrams
    get more complex, some other message invocation could wind up between these two—and
    thus would execute prior to the `getBromine()` message. Instead, if the sanitizer
    is not `chlorine` you’d want to immediately check to see if it is `bromine`, with
    no possibility of intervening messages. [Figure 7-12](ch07.xhtml#ch7fig12) shows
    the proper way to draw this logic.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Good implementation of branching logic*'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing branching logic with the arrow tails that start from the same vertical
    position and the arrowheads that end at the same vertical position avoids any
    ambiguity with the sequence of execution (assuming that the guard conditions are
    mutually exclusive—that is, it is not possible for both conditions to be simultaneously
    `true`).
  prefs: []
  type: TYPE_NORMAL
- en: Branching uses slanted message arrows similar to long delays, but a long delay
    item will have an associated time constraint.^([1](ch19_footnote.xhtml#ch07fn1))
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.11 Alternative Flows***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s another potential issue with branching: what happens when you need
    to send one of two different messages to the same destination object? Because
    the arrow tails and heads must start and end, respectively, at the same vertical
    positions for both arrows, the two arrows would overlay each other and there would
    be no indication that branching takes place at all. The solution to this problem
    is to use an *alternative flow*.'
  prefs: []
  type: TYPE_NORMAL
- en: In an alternative flow, a single lifeline splits into two separate lifelines
    at some point (see [Figure 7-13](ch07.xhtml#ch7fig13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: Alternative flows*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the Timer Module has to choose between retrieving the current
    level of salinity (NaCl) or sodium hydroxide (NaOH). The `getSalinity()` and `getNaOH()`
    operations are methods within the same class; therefore, their message arrows
    will both point at the same spot in the `ClGen` lifeline. To avoid overlapping
    the message arrows, [Figure 7-13](ch07.xhtml#ch7fig13) splits the `ClGen` lifeline
    into two lifelines: the original and an alternative flow.'
  prefs: []
  type: TYPE_NORMAL
- en: After the message invocation, you can merge the two flows back together if desired.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.12 Object Creation and Destruction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far in the examples, the objects have existed throughout the lifetime of
    the sequence diagram; that is, all objects existed prior to the execution of the
    first message (operation) and persist after the execution of the last message.
    In real-world designs, you’ll need to create and destroy objects that don’t exist
    for the full duration of the program’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: Object creation and destruction are messages just like any other. The common
    convention in UML is to use the special messages «create» and «destroy» (see [Figure
    7-14](ch07.xhtml#ch7fig14)) to show object lifetimes within the sequence diagram;
    however, you can use any message name you like. The X at the end of the `cleanProcess`
    lifeline, immediately below the «destroy» operation, denotes the end of the lifeline,
    because the object no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: Object creation and destruction*'
  prefs: []
  type: TYPE_NORMAL
- en: This example uses a *dropped title box* to indicate the beginning of the lifeline
    for a newly created object. As Russ Miles and Kim Hamilton point out in *Learning
    UML 2.0* (O’Reilly, 2003), many standardized UML tools don’t support using dropped
    title boxes, allowing you to place the object title boxes only at the top of the
    diagram. There are a couple of solutions to this problem that should work with
    most standard UML tools.
  prefs: []
  type: TYPE_NORMAL
- en: You can put the object at the top of the diagram and add a comment to explicitly
    indicate object creation and destruction at the points where they occur (see [Figure
    7-15](ch07.xhtml#ch7fig15)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-15: Using notes to indicate object lifetime*'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use an alternative flow to indicate the lifetime of the object
    (see [Figure 7-16](ch07.xhtml#ch7fig16)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-16: Using alternative flows to indicate object lifetime*'
  prefs: []
  type: TYPE_NORMAL
- en: Activation bars provide a third alternative that might be clearer here.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1.13 Sequence Fragments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: UML 2.0 added *sequence fragments* to show loops, branches, and other alternatives,
    enabling you to better manage sequence diagrams. UML defines several standard
    sequence fragment types you can use, defined briefly in [Table 7-1](ch07.xhtml#ch7tab1)
    (full descriptions appear later in this section).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Brief Descriptions of Sequence Fragment Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| `alt` | Executes only the alternative fragment that is `true` (think of an
    `if`/`else` or `switch` statement). |'
  prefs: []
  type: TYPE_TB
- en: '| `assert` | Notes that operations within the fragment are valid if a guard
    condition is `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `break` | Exits a loop fragment (based on some guard condition). |'
  prefs: []
  type: TYPE_TB
- en: '| `consider` | Provides a list of valid messages in a sequence fragment. |'
  prefs: []
  type: TYPE_TB
- en: '| `ignore` | Provides a list of invalid messages in a sequence fragment. |'
  prefs: []
  type: TYPE_TB
- en: '| `loop` | Runs multiple times and the guard condition determines whether the
    fragment repeats. |'
  prefs: []
  type: TYPE_TB
- en: '| `neg` | Never executes. |'
  prefs: []
  type: TYPE_TB
- en: '| `opt` | Executes only if the associated condition is `true`. Comparable to
    `alt` with only one alternative fragment. |'
  prefs: []
  type: TYPE_TB
- en: '| `par` | Runs multiple fragments in parallel. |'
  prefs: []
  type: TYPE_TB
- en: '| `ref` | Indicates a call to another sequence diagram. |'
  prefs: []
  type: TYPE_TB
- en: '| `region` | (Also known as `critical`.) Defines a critical region in which
    only one thread of execution is possible. |'
  prefs: []
  type: TYPE_TB
- en: '| `seq` | Indicates that operations (in a multitasking environment) must occur
    in a specific sequence. |'
  prefs: []
  type: TYPE_TB
- en: '| `strict` | A stricter version of `seq`. |'
  prefs: []
  type: TYPE_TB
- en: In general, you draw sequence fragments as a rectangle surrounding the messages,
    with a special penta-rectangle symbol (a rectangle with the lower-right corner
    cropped) in its upper-left corner that contains the UML fragment name/type (see
    [Figure 7-17](ch07.xhtml#ch7fig17); substitute any actual fragment type for typ
    in this diagram).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-17: Generic sequence fragment form*'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you wanted to repeat a sequence of messages several times, you
    would enclose those messages in a `loop` sequence fragment. This tells the engineer
    implementing the program to repeat those messages the number of times specified
    by the `loop` fragment.
  prefs: []
  type: TYPE_NORMAL
- en: You can also include an optional *additional info* item, which is typically
    a guard condition or iteration count. The following subsections describe the sequence
    fragment types from [Table 7-1](ch07.xhtml#ch7tab1) in detail, as well as any
    additional information they may require.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.1.13.1 ref**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are two components to a `ref` sequence fragment: the UML interaction
    occurrence and the reference itself. An *interaction occurrence* is a stand-alone
    sequence diagram corresponding to a subroutine (procedure or function) in code.
    It is surrounded by a sequence fragment box. The penta-rectangle in the upper-left
    corner of the box contains `sd` (for *sequence diagram*) followed by the name
    of the `ref` fragment and any arguments you want to assign to it (see [Figure
    7-18](ch07.xhtml#ch7fig18)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-18: An interaction occurrence example*'
  prefs: []
  type: TYPE_NORMAL
- en: The leftmost incoming arrow corresponds to the *subroutine entry point*. If
    this isn’t present, you can assume that control flows to the leftmost participant
    at the top of its lifeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we come to the second component of the `ref` sequence fragment: referencing
    the interaction occurrence within a different sequence diagram (see [Figure 7-19](ch07.xhtml#ch7fig19)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-19: A ref sequence fragment example*'
  prefs: []
  type: TYPE_NORMAL
- en: This corresponds to a call to a subroutine (procedure or function) in code.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.1.13.2 consider and ignore**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `consider` sequence fragment lists all messages that are valid within a
    section of the sequence diagram; all other messages/operators are illegal. The
    `ignore` operator lists names of messages that are invalid within a section of
    the sequence diagram; all other operators/messages are legal.
  prefs: []
  type: TYPE_NORMAL
- en: '`consider` and `ignore` work either as operators in conjunction with an existing
    sequence fragment or as sequence fragments by themselves. A `consider` or `ignore`
    operator takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `consider` and `ignore` operators may appear after the `sd` *name* title
    in an interaction occurrence (see [Figure 7-20](ch07.xhtml#ch7fig20)), in which
    case they apply to the entire diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-20: A consider operator example*'
  prefs: []
  type: TYPE_NORMAL
- en: You may also create a sequence fragment within another sequence diagram and
    label that fragment with a `consider` or `ignore` operation. In that case, `consider`
    or `ignore` applies only to the messages within the specific sequence fragment
    (see [Figure 7-21](ch07.xhtml#ch7fig21)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-21: An ignore sequence fragment example*'
  prefs: []
  type: TYPE_NORMAL
- en: If these fragment types seem strange, consider creating a very generic `ref`
    fragment that handles only certain messages, but then referencing that `ref` from
    several different places that might pass along unhandled messages along with the
    handled ones. By adding a `consider` or `ignore` operator to the `ref`, you can
    have the fragment simply ignore the messages it doesn’t explicitly handle, which
    allows you to use that `ref` without having to add any extra design to the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.1.13.3 assert**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `assert` sequence fragment tells the system implementer that the messages
    within it are valid only if some guard condition evaluates to `true`. At the end
    of the `assert` fragment, you typically provide some sort of Boolean condition
    (the guard condition) that must be `true` once the sequence is complete (see [Figure
    7-22](ch07.xhtml#ch7fig22)). If the condition isn’t `true` after the `assert`
    fragment has finished executing, the design can’t guarantee correct results. The
    `assert` reminds the engineer to verify that this condition is indeed `true` by,
    for example, using a C++ `assert` macro invocation (or something similar in other
    languages, or even just an `if` statement).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-22: An assert sequence fragment example*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In C/C++ you’d probably implement the sequence in [Figure 7-22](ch07.xhtml#ch7fig22)
    using code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**7.1.13.4 loop**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `loop` sequence fragment indicates iteration. You place the `loop` operator
    in the penta-rectangle associated with the sequence fragment, and may also include
    a guard condition enclosed in brackets at the top of the sequence fragment. The
    combination of the `loop` operator and guard condition controls the number of
    iterations.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest form of this sequence fragment is the *infinite* loop, consisting
    of the `loop` operator without any arguments and without a guard condition (see
    [Figure 7-23](ch07.xhtml#ch7fig23)). Most “infinite” loops actually aren’t infinite,
    but terminate with a `break` sequence fragment when some condition is true (we’ll
    discuss the `break` sequence in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-23: An infinite loop*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop in [Figure 7-23](ch07.xhtml#ch7fig23) is roughly equivalent to the
    following C/C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, alternatively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Personally, I prefer the following:*'
  prefs: []
  type: TYPE_NORMAL
- en: '#define ever ;;'
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: for(ever)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Object4->msg2();
  prefs: []
  type: TYPE_NORMAL
- en: '} // endfor'
  prefs: []
  type: TYPE_NORMAL
- en: '*I feel this is the most readable solution. Of course, if you’re “anti-macro
    at all costs,” you would probably disagree with my choice for an infinite loop!*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Definite* loops execute a fixed number of times and can appear in two forms.
    The first is `loop(`*integer*`)`, which is shorthand for `loop(0,` *integer*`)`;
    that is, it will execute a minimum of zero times and a maximum of *integer* times.
    The second is `loop(`*minInt*`,` *maxInt*`)`, which indicates that the loop will
    execute a minimum of *minInt* times and a maximum of *maxInt* times. Without a
    guard condition, the minimum count is irrelevant; the loop will always execute
    *maxInt* times. Therefore, most definite loops use the form `loop(`*integer*`)`
    where *integer* is the number of iterations to perform (see [Figure 7-24](ch07.xhtml#ch7fig24)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-24: A definite loop*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop in [Figure 7-24](ch07.xhtml#ch7fig24) is roughly equivalent to the
    following C/C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the multiplicity symbol `*` to denote infinity. Therefore,
    `loop(*)` is equivalent to `loop(0, *)` which is equivalent to `loop` (in other
    words, you get an infinite loop).
  prefs: []
  type: TYPE_NORMAL
- en: An *indefinite* loop executes an indeterminate^([2](ch19_footnote.xhtml#ch07fn2))
    number of times (corresponding to `while`, `do/while`, `repeat/until`, and other
    loop forms in programming languages). Indefinite loops include a guard condition
    as part of the `loop` sequence fragment,^([3](ch19_footnote.xhtml#ch07fn3)) meaning
    the `loop` sequence fragment will always execute the loop *minInt* times (zero
    times if *minInt* is not present). After *minInt* iterations, the loop sequence
    fragment will begin testing the guard condition and continue iterating only while
    the guard condition is `true`. The loop sequence fragment will execute at most
    *maxInt* iterations (total, not in addition to the *minInt* iterations). [Figure
    7-25](ch07.xhtml#ch7fig25) shows a traditional `while`-type loop that executes
    a minimum of zero times and a maximum of infinity times, as long as the guard
    condition (`[cond == true]`) evaluates to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-25: An indefinite while loop*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop in [Figure 7-25](ch07.xhtml#ch7fig25) is roughly equivalent to the
    following C/C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can create a `do..while` loop by setting the *minInt* value to `1` and the
    *maxInt* value to `*`, and then specifying the Boolean expression to continue
    loop execution (see [Figure 7-26](ch07.xhtml#ch7fig26)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-26: An indefinite do..while loop*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop in [Figure 7-26](ch07.xhtml#ch7fig26) is roughly equivalent to the
    following C/C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It’s possible to create many other complex loop types, but I’ll leave that as
    an exercise for interested readers.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.1.13.5 break**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `break` sequence fragment consists of the word `break` in a penta-rectangle
    along with a guard condition. If the guard condition evaluates to `true`, then
    the system executes the sequence inside the `break` sequence fragment, after which
    control immediately exits the enclosing sequence fragment. If the enclosing sequence
    fragment is a `loop`, control immediately executes to the first message past the
    `loop` (like a `break` statement in languages like Swift, C/C++, and Java). [Figure
    7-27](ch07.xhtml#ch7fig27) provides an example of such a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-27: An example of the break sequence fragment*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop in [Figure 7-27](ch07.xhtml#ch7fig27) is roughly equivalent to the
    following C++ code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the most recent `break`-compatible enclosing sequence is a subroutine, not
    a loop, the `break` sequence fragment behaves like a return from a subroutine
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.1.13.6 opt and alt**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `opt` and `alt` sequence fragments allow you to control the execution of
    a set of messages with a single guard condition—particularly if the values of
    the components making up the guard condition could change over the execution of
    the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The `opt` sequence fragment is like a simple `if` statement without an `else`
    clause. You attach a guard condition and the system will execute the sequence
    contained within the `opt` fragment only if the guard condition evaluates to `true`
    (see [Figure 7-28](ch07.xhtml#ch7fig28)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-28: An example of the `opt` sequence fragment*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example in [Figure 7-28](ch07.xhtml#ch7fig28) is roughly equivalent to
    the following C/C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For more complex logic, use the `alt` sequence fragment, which acts like an
    `if`/`else` or `switch`/`case`. To create an `alt` sequence fragment, you combine
    several rectangles, each with its own guard condition and an optional `else`,
    to form a multiway decision (see [Figure 7-29](ch07.xhtml#ch7fig29)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-29: An alt sequence fragment*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interaction occurrence in [Figure 7-29](ch07.xhtml#ch7fig29) is roughly
    equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**7.1.13.7 neg**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You use a `neg` sequence fragment to enclose a sequence that will not be part
    of the final design. Effectively, using `neg` comments out the enclosed sequence.
    Why even include a sequence if it’s not going to be part of the design? There
    are at least two good reasons: code generation and future features.'
  prefs: []
  type: TYPE_NORMAL
- en: Although, for the most part, UML is a diagramming language intended to help
    with system design prior to implementation in a programming language like Java
    or Swift, there are certain UML tools that will convert UML diagrams directly
    into code. During development, you might want to include some diagrams that illustrate
    something but are not yet complete (certainly not to the point of producing executable
    code). In this scenario, you could use the `neg` sequence fragment to turn off
    the code generation for those sequences that aren’t quite yet ready for prime
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you don’t intend to generate code directly from a UML diagram, you might
    want to use the `neg` for future features. When you hand your UML diagrams off
    to an engineer to implement the design, they represent a contract that says, “This
    is how the code is to be written.” Sometimes, though, you’ll want your diagrams
    to show features that you plan to include in a future version of the software,
    but not in the first (or current) version. The `neg` sequence fragment is a clean
    way to tell the engineer to ignore that part of the design. [Figure 7-30](ch07.xhtml#ch7fig30)
    shows a simple example of the `neg` sequence fragment.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-30: An example of the neg sequence fragment*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example in [Figure 7-30](ch07.xhtml#ch7fig30) is roughly equivalent to
    the following C/C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**7.1.13.8 par**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `par` sequence fragment, an example of which is shown in [Figure 7-31](ch07.xhtml#ch7fig31),
    states that the enclosed sequences^([4](ch19_footnote.xhtml#ch07fn4)) (operations)
    can be executed in parallel with each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-31: An example of the par sequence fragment*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-31](ch07.xhtml#ch7fig31) shows three operands: the sequence with
    {`msg2a`, `msg2b`, `msg2c`}, the sequence with {`msg3a`, `msg3b`, `msg3c`}, and
    the sequence with {`msg4a`, `msg4b`, `msg4c`}. The `par` sequence fragment requires
    that the operations within a given sequence must execute in the order in which
    they appear (for example, `msg2a`, then `msg2b`, then `msg2c`). However, the system
    is free to interleave operations from different operands as long as it maintains
    the internal order of those operands. So, in [Figure 7-31](ch07.xhtml#ch7fig31),
    the order {`msg2a`, `msg3a`, `msg3b`, `msg4a`, `msg2b`, `msg2c`, `msg4b`, `msg4c`,
    `msg3c`} is legitimate, as is {`msg4a`, `msg4b`, `msg4c`, `msg3a`, `msg3b`, `msg3c`,
    `msg2a`, `msg2b`, `msg2c`}, because the ordering of the enclosed sequences matches.
    However, {`msg2a`, `msg2c`, `msg4a`, `msg4b`, `msg4c`, `msg3a`, `msg3b`, `msg3c`,
    `msg2b`} is not legitimate because `msg2c` occurs before `msg2b` (which is contrary
    to the ordering specified in [Figure 7-31](ch07.xhtml#ch7fig31)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.1.13.9 seq**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `par` sequence fragment enforces the following restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: The system maintains the ordering of the operations within an operand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system allows operations on different lifelines from different operands
    to execute in any order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the `seq` sequence adds another:'
  prefs: []
  type: TYPE_NORMAL
- en: Operations on the same lifeline in different operands must execute in the order
    in which they appear in the diagram (from top to bottom).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Figure 7-32](ch07.xhtml#ch7fig32), for example, `Operand1` and `Operand3`
    have messages that are sent to the same object (lifeline). Therefore, in a `seq`
    sequence fragment, `msg2a`, `msg2b`, and `msg2c` must all execute before `msg4a`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-32: An example of the seq sequence fragment*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-32](ch07.xhtml#ch7fig32) shows a stand-alone `seq` sequence fragment.
    In typical usage, however, a `seq` sequence fragment will appear inside a `par`
    to control the execution sequence of a portion of the `par`’s operands.'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.1.13.10 strict**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `strict` sequence fragment forces the operations to occur in the sequence
    they appear in each operand; interleaving of operations between operands is not
    allowed. The format for a `strict` sequence fragment is similar to that of `par`
    and `seq` (see [Figure 7-33](ch07.xhtml#ch7fig33)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-33: An example of the strict sequence fragment*'
  prefs: []
  type: TYPE_NORMAL
- en: The `strict` parallel operation allows the operands to execute in any order,
    but once a given operand begins execution, all the operations within it must complete
    in the sequence specified before any other operand can begin executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 7-33](ch07.xhtml#ch7fig33), there are six different operation sequences
    possible: {`Operand1`, `Operand2`, `Operand3`}; {`Operand1`, `Operand3`, `Operand2`};
    {`Operand2`, `Operand1`, `Operand3`}; {`Operand2`, `Operand3`, `Operand1`}; {`Operand3`,
    `Operand1`, `Operand2`}; and {`Operand3`, `Operand2`, `Operand1`}.'
  prefs: []
  type: TYPE_NORMAL
- en: However, operations internal to the operands cannot interleave, and must execute
    from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.1.13.11 region**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the section “[Extending UML Activity Diagrams](ch05.xhtml#lev-5.2)” on [page
    99](ch05.xhtml#page_99), I used the example of a home-brew critical section in
    an activity diagram to demonstrate how to extend UML for your own purposes. I
    pointed out why this is a bad idea (reread that section for the details), and
    mentioned there is another way to achieve what you want to do using standard UML:
    the `region` sequence fragment. UML activity diagrams don’t support critical sections,
    but sequence diagrams do.'
  prefs: []
  type: TYPE_NORMAL
- en: The `region` sequence fragment specifies that once execution enters the region,
    no other operations in the same parallel execution context can be interleaved
    until it completes execution. The `region` sequence fragment must always appear
    within some other parallel sequence fragment (generally `par` or `seq`; technically
    it could appear inside `strict`, though ultimately this would serve no purpose).
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider [Figure 7-34](ch07.xhtml#ch7fig34)—the system is free
    to interleave the execution of any operand’s messages, subject to the rules given
    for the `par` sequence fragment, but once the system enters the critical region
    (with the execution of the `msg4a` operation), no other threads in the `par` sequence
    fragment can execute.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-34: The region sequence fragment*'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.2 Collaboration Diagrams**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Collaboration (or communication) diagrams provide the same information as sequence
    diagrams but in a slightly more compact form. Rather than drawing arrows between
    lifelines, in collaboration diagrams we draw message arrows directly between objects,
    and attach numbers to each message to indicate the sequence (see [Figure 7-35](ch07.xhtml#ch7fig35)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-35: A collaboration diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram in [Figure 7-35](ch07.xhtml#ch7fig35) is roughly equivalent to the
    sequence diagram in [Figure 7-9](ch07.xhtml#ch7fig9) (without the time constraint
    of 10 minutes). In [Figure 7-35](ch07.xhtml#ch7fig35) the `salinityCheck` message
    executes first, `sendMsg` executes second, and `updateSalinityDisplay` executes
    last.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-36](ch07.xhtml#ch7fig36) shows a more complex collaboration diagram
    that better demonstrates the compactness of this option. The six messages sent
    in this example would require six lines in a sequence diagram but here require
    only three communication links.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-36: A more complex collaboration diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Having both collaboration and sequence diagrams is probably an artifact of
    merging different systems together when UML was created. Which one you use is
    really just a matter of personal preference. Keep in mind, however, that as the
    diagrams become more complex, collaboration diagrams become harder to follow.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.3 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bremer, Michael. *The User Manual Manual: How to Research, Write, Test, Edit,
    and Produce a Software Manual*. Grass Valley, CA: UnTechnical Press, 1999\. A
    sample chapter is available at *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Larman, Craig. *Applying UML and Patterns: An Introduction to Object-Oriented
    Analysis and Design and Iterative Development*. 3rd ed. Upper Saddle River, NJ:
    Prentice Hall, 2004.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Miles, Russ, and Kim Hamilton. *Learning UML 2.0: A Pragmatic Introduction
    to UML*. Sebastopol, CA: O’Reilly Media, 2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pender, Tom. *UML Bible*. Indianapolis: Wiley, 2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pilone, Dan, and Neil Pitman. *UML 2.0 in a Nutshell: A Desktop Quick Reference*.
    2nd ed. Sebastopol, CA: O’Reilly Media, 2005.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Roff, Jason T. *UML: A Beginner’s Guide*. Berkeley, CA: McGraw-Hill Education,
    2003.'
  prefs: []
  type: TYPE_NORMAL
- en: Tutorials Point. “UML Tutorial.” [*https://www.tutorialspoint.com/uml/*](https://www.tutorialspoint.com/uml/).
  prefs: []
  type: TYPE_NORMAL
