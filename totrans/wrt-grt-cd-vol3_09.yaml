- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: UML INTERACTION DIAGRAMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: UML 交互图**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: 'Interaction diagrams model the operations that occur between different objects
    (participants) in a system. There are three main types of interaction diagrams
    in UML: sequence, collaboration (communication), and timing. The majority of this
    chapter will focus on sequence diagrams, followed by a very brief discussion of
    collaboration diagrams.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 交互图模拟系统中不同对象（参与者）之间发生的操作。UML中有三种主要类型的交互图：时序图、协作图（通信图）和时序图。本文大部分内容将聚焦于时序图，接下来简要讨论协作图。
- en: '**7.1 Sequence Diagrams**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.1 时序图**'
- en: Sequence diagrams show the interaction between participants (actors, objects)
    in the order in which it takes place. Whereas activity diagrams describe the particulars
    of one operation on an object, sequence diagrams tie activity diagrams together
    to show the order in which multiple operations occur. From a design perspective,
    sequence diagrams are more informative than activity diagrams as they illustrate
    the overall architecture of the system; at the (lower) level of an activity diagram,
    however, a system architect can usually safely assume that the software engineer
    implementing the system can figure out the activities required by the design.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 时序图显示参与者（演员、对象）之间的交互，按照发生的顺序。与活动图描述单一操作的细节不同，时序图将多个操作的顺序关联起来。从设计的角度来看，时序图比活动图更具信息性，因为它们展示了系统的整体架构；然而，在活动图（较低级别）中，系统架构师通常可以放心地假设实现系统的软件工程师能够理解设计所需的活动。
- en: '***7.1.1 Lifelines***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.1 生命周期***'
- en: At the top of a sequence diagram you draw the set of participants, using rectangles
    or stick figures (see [Figure 7-1](ch07.xhtml#ch7fig1)), and then draw a dashed
    line from each participant to the bottom of the diagram to indicate that object’s
    lifeline. *Lifelines* show the flow of time from the earliest (topmost) point
    of execution to the latest (bottommost) point. However, lifelines by themselves
    do not indicate the *amount* of time that passes, only the passage of time from
    the top to the bottom of the diagram, and equal line lengths need not correspond
    to the same amount of time—a 1 cm section at one point could be days, while a
    1 cm section elsewhere could be microseconds.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在时序图的顶部，你需要绘制参与者集，使用矩形或简笔画（参见[图 7-1](ch07.xhtml#ch7fig1)），然后从每个参与者绘制一条虚线到底部，表示该对象的生命周期。*生命周期*显示从执行的最早（最上面）到最新（最下面）时间点的流动。然而，仅凭生命周期并不能指示经过的*时间量*，它仅表示时间的流逝从图表的顶部到底部，等长的线段不必对应相同的时间量——某个地方的1厘米段可能是几天，而另一个地方的1厘米段可能是微秒。
- en: '![image](Images/fig7-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-1.jpg)'
- en: '*Figure 7-1: A basic sequence diagram*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1: 基本时序图*'
- en: '***7.1.2 Message Types***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.2 消息类型***'
- en: Communication between participants takes the form of *messages* (which I will
    sometimes call *operations*), which consist of an arrow drawn between lifelines,
    or even from one lifeline to itself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者之间的通信以*消息*（有时我称之为*操作*）的形式存在，它们由绘制在生命周期之间的箭头组成，甚至可能从一个生命周期指向其自身。
- en: There are four types of message arrows you can use, as shown in [Figure 7-2](ch07.xhtml#ch7fig2).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的消息箭头可以使用，如[图 7-2](ch07.xhtml#ch7fig2)所示。
- en: '![image](Images/fig7-2.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-2.jpg)'
- en: '*Figure 7-2: Message types in sequence diagrams*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2: 时序图中的消息类型*'
- en: '*Synchronous* messages are the typical call/return operation that most programs
    use (to execute object methods, functions, and procedures). The sender suspends
    execution until the receiver returns control.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*同步*消息是大多数程序使用的典型调用/返回操作（用于执行对象方法、函数和过程）。发送者会暂停执行，直到接收者返回控制。'
- en: '*Return* messages indicate that control returns from a synchronous message
    back to the message sender, but they are purely optional in a sequence diagram.
    An object cannot continue execution until a synchronous message completes, so
    the presence of some other message (received or sent) on the same timeline inherently
    implies a return operation. Because a large number of return arrows can obfuscate
    a sequence diagram, it’s best to leave them off if the diagram starts to get cluttered.
    If the sequence diagram is relatively clean, however, a return arrow can help
    show exactly what is happening.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*返回*消息表示控制从同步消息返回到消息发送方，但在顺序图中返回消息是完全可选的。在同步消息完成之前，对象无法继续执行，因此在同一时间线上出现的其他消息（无论是接收还是发送）本身就暗示了一个返回操作。由于大量返回箭头可能会混淆顺序图，因此如果图表开始变得混乱，最好省略它们。然而，如果顺序图相对简洁，返回箭头有助于准确显示发生的事情。'
- en: '*Asynchronous* messages trigger an invocation of some code in the receiver,
    but the message sender does not have to wait for a return message before continuing
    execution. For this reason, there’s no need to draw an explicit return arrow for
    an asynchronous call in your sequence diagrams.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步*消息会触发接收方代码的调用，但消息发送方在继续执行之前不需要等待返回消息。因此，在顺序图中，异步调用不需要画出明确的返回箭头。'
- en: '*Flat* messages can be either synchronous or asynchronous. Use a flat message
    when the type doesn’t matter for the design and you want to leave the choice up
    to the engineer implementing the code. As a general rule, you do not draw return
    arrows for flat messages because that would imply that the implementer must use
    a synchronous call.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*平面*消息可以是同步的，也可以是异步的。当类型对设计无关紧要，并且你希望将选择留给实现代码的工程师时，可以使用平面消息。作为一般规则，平面消息不绘制返回箭头，因为那样会暗示实现者必须使用同步调用。'
- en: '**NOTE**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Flat messages are UML 1.*x *entities only. In UML 2.0, asynchronous messages
    use the full open arrowhead instead.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*平面消息仅为UML 1.*x *实体。在UML 2.0中，异步消息使用完整的开放箭头。*'
- en: '***7.1.3 Message Labels***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.3 消息标签***'
- en: When you draw a message, you must attach a label to the message’s arrow. This
    label could simply be a description of the message, as in [Figure 7-3](ch07.xhtml#ch7fig3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制消息时，必须为消息的箭头附加标签。这个标签可以只是消息的描述，如[图7-3](ch07.xhtml#ch7fig3)所示。
- en: '![image](Images/fig7-3.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-3.jpg)'
- en: '*Figure 7-3: Message labels*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：消息标签*'
- en: The sequence of messages is indicated by their vertical placement. In [Figure
    7-3](ch07.xhtml#ch7fig3), the “Select immediate pool clean” label is the first
    message line in the diagram, meaning it is the first operation to execute. Moving
    downward, “Turn on pump” is the second message line, so it executes next. The
    return from “Turn on pump” is the third operation and the return from “Select
    immediate pool clean” is the fourth.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的顺序通过其垂直位置来表示。在[图7-3](ch07.xhtml#ch7fig3)中，“选择即时池清理”标签是图中的第一条消息线，意味着它是第一个执行的操作。向下移动，“开启泵”是第二条消息线，所以它接着执行。“开启泵”的返回是第三个操作，“选择即时池清理”的返回是第四个操作。
- en: '***7.1.4 Message Numbers***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.4 消息编号***'
- en: As your sequence diagrams become more complex, it may be difficult to determine
    the execution order from the message position alone, so it can be helpful to attach
    additional indicators like numbers to each message label. [Figure 7-4](ch07.xhtml#ch7fig4)
    uses sequential integers, though UML doesn’t require this. You could use numbers
    like 3.2.4 or even non-numeric indicators (for example, A, B, C). However, the
    goal is to make it easy to determine the message sequence, so if you get too carried
    away here you might defeat that purpose.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 随着顺序图变得更复杂，仅凭消息位置可能很难确定执行顺序，因此在每个消息标签上附加额外的指示符（如编号）可能会有所帮助。[图7-4](ch07.xhtml#ch7fig4)使用了顺序整数，尽管UML并不要求如此。你也可以使用像3.2.4这样的编号，甚至是非数字指示符（例如A、B、C）。然而，目标是使得消息顺序易于确定，所以如果在此处过于复杂，可能会适得其反。
- en: '![image](Images/fig7-4.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-4.jpg)'
- en: '*Figure 7-4: Message numbers*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：消息编号*'
- en: Although the message labels you’ve seen thus far are relatively straightforward
    descriptions, it’s not uncommon to use the actual operation names, parameters,
    and return values as labels on message arrows, as in [Figure 7-5](ch07.xhtml#ch7fig5).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止你看到的消息标签是相对简单的描述，但也不罕见将实际操作名称、参数和返回值用作消息箭头的标签，如[图7-5](ch07.xhtml#ch7fig5)所示。
- en: '![image](Images/fig7-5.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-5.jpg)'
- en: '*Figure 7-5: Message arguments and return values*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：消息参数和返回值*'
- en: '***7.1.5 Guard Conditions***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.5 保护条件***'
- en: 'Your message labels can also include guard conditions: Boolean expressions
    enclosed in brackets (see [Figure 7-6](ch07.xhtml#ch7fig6)). If the guard expression
    evaluates to `true`, the system sends the message; if it evaluates to `false`,
    the system does not send the message.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你的消息标签也可以包含保护条件：用括号括起来的布尔表达式（参见[图 7-6](ch07.xhtml#ch7fig6)）。如果保护条件的结果为`true`，系统就会发送消息；如果结果为`false`，系统则不会发送消息。
- en: '![image](Images/fig7-6.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-6.jpg)'
- en: '*Figure 7-6: Message guard conditions*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：消息保护条件*'
- en: In [Figure 7-6](ch07.xhtml#ch7fig6), the `pMon` object sends a `pump(100)` message
    to `pump` only if `pumpPower` is `on` (`true`). If `pumpPower` is `off` (`false`)
    and the `pump(100)` message does not execute, the corresponding return operation
    (sequence item 3) will not execute either, and control will move to the next outgoing
    arrow item in the `pMon` lifeline (sequence item 4, returning control to the user
    object).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 7-6](ch07.xhtml#ch7fig6)中，只有当`pumpPower`为`on`（`true`）时，`pMon`对象才会向`pump`发送`pump(100)`消息。如果`pumpPower`为`off`（`false`）并且`pump(100)`消息没有执行，那么相应的返回操作（序列项
    3）也不会执行，控制将转移到`pMon`生命线中的下一个外发箭头项（序列项 4，返回控制到用户对象）。
- en: '***7.1.6 Iterations***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.6 迭代***'
- en: You can also specify the number of times a message executes by providing an
    iteration count in a sequence diagram. To specify an iteration, you use an asterisk
    symbol (`*`) followed by a guard condition or `for` loop iteration count (see
    [Figure 7-7](ch07.xhtml#ch7fig7)). The system will repeatedly send the message
    as long as the guard condition is `true`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在序列图中提供迭代次数来指定消息执行的次数。要指定迭代，可以使用星号符号（`*`），后跟保护条件或`for`循环迭代次数（参见[图 7-7](ch07.xhtml#ch7fig7)）。只要保护条件为`true`，系统就会重复发送消息。
- en: '![image](Images/fig7-7.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-7.jpg)'
- en: '*Figure 7-7: Partial sequence diagram with iteration*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：带有迭代的部分序列图*'
- en: In [Figure 7-7](ch07.xhtml#ch7fig7), the message executes 100 times, with the
    variable `i` taking on the value `1` through `100`, incrementing on each iteration.
    If the `pumpPwrAndDelay` function applies the percent power specified as the argument
    and delays for 1 second, then in about 1 minute, 40 seconds, the pump will be
    running at full speed (increasing by 1 percent of the total speed each second).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 7-7](ch07.xhtml#ch7fig7)中，消息执行 100 次，变量`i`的值从`1`变到`100`，并在每次迭代时递增。如果`pumpPwrAndDelay`函数应用了作为参数指定的百分比功率，并且延迟
    1 秒，那么大约 1 分 40 秒后，水泵将以全速运行（每秒增加总速度的 1%）。
- en: '***7.1.7 Long Delays and Time Constraints***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.7 长时间延迟和时间约束***'
- en: Sequence diagrams typically describe only the order of messages, not the amount
    of time each message takes to execute. Sometimes, however, a designer might want
    to indicate that a particular operation might take a long time relative to others.
    This is particularly common when one object sends a message to another object
    located outside the bounds of the current system (for example, when a software
    component sends a message to some object on a remote server across the internet),
    which we’ll discuss shortly. You indicate that an operation will take longer by
    pointing the message arrow slightly downward. In [Figure 7-8](ch07.xhtml#ch7fig8),
    for example, you would expect the `scheduledClean()` operation to take more time
    than a typical operation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 序列图通常只描述消息的顺序，而不描述每条消息执行所需的时间。然而，有时设计者可能希望指出某个特定操作相对于其他操作可能需要更长时间。这在一个对象向另一个位于当前系统之外的对象发送消息时尤为常见（例如，当一个软件组件向远程服务器上的某个对象发送消息时），我们稍后会讨论。通过将消息箭头稍微指向下方来表示一个操作需要更长时间。例如，在[图
    7-8](ch07.xhtml#ch7fig8)中，你会预期`scheduledClean()`操作的执行时间会比典型操作更长。
- en: '![image](Images/fig7-8.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-8.jpg)'
- en: '*Figure 7-8: Timed messages with timing constraints*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：带有时间约束的定时消息*'
- en: You must also specify the expected amount of time for each message by adding
    some sort of constraint to the diagram. [Figure 7-8](ch07.xhtml#ch7fig8) demonstrates
    this with a dashed vertical arrow from the start of the `scheduledClean()` operation
    to the point on the lifeline where the system returns control to the Timer Module
    actor (probably the physical timer on the pool monitor system). The required time
    constraint appears inside braces next to the dashed arrow.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须通过在图表中添加某种约束来指定每个消息的预期时间量。[图 7-8](ch07.xhtml#ch7fig8)通过一条从`scheduledClean()`操作开始到系统将控制权交还给计时器模块演员（很可能是泳池监控系统上的物理计时器）的位置的虚线垂直箭头来演示这一点。所需的时间约束显示在虚线箭头旁边的花括号内。
- en: '***7.1.8 External Objects***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.8 外部对象***'
- en: Occasionally a component of a sequence diagram must communicate with some object
    *external* to the system. For example, some code in the pool monitor might check
    the salinity level and send an SMS message to the owner’s cell phone if it drops
    too low. The code to actually transmit the SMS message is probably handled by
    an Internet of Things (IoT) device and thus outside the scope of the pool monitor
    software; hence, the SMS code is an external object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，序列图中的某个组件必须与系统外部的某个对象进行通信。例如，泳池监控中的一些代码可能会检查盐度水平，如果过低，则向所有者的手机发送短信。实际发送短信的代码可能由物联网（IoT）设备处理，因此超出了泳池监控软件的范围；因此，短信代码是一个外部对象。
- en: You draw a heavy border around external objects and use a solid line for their
    lifelines rather than a dashed line (see [Figure 7-9](ch07.xhtml#ch7fig9)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为外部对象绘制一个粗边框，并使用实线表示它们的生命线，而不是使用虚线（参见[图 7-9](ch07.xhtml#ch7fig9)）。
- en: '![image](Images/fig7-9.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-9.jpg)'
- en: '*Figure 7-9: External objects in a sequence diagram*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：序列图中的外部对象*'
- en: In [Figure 7-9](ch07.xhtml#ch7fig9), the Timer Module makes an asynchronous
    call to the `salinity` object, and there is no return from the `salinityCheck()`
    operation. After that call, the Timer Module can perform other tasks (not shown
    in this simple diagram). Ten minutes later, as noted by the time constraint, the
    `salinity` object makes an asynchronous call to the Timer Module actor and has
    it update the salinity value on the display.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 7-9](ch07.xhtml#ch7fig9)中，计时器模块对`salinity`对象进行异步调用，并且`salinityCheck()`操作没有返回值。之后，计时器模块可以执行其他任务（在这个简单的示意图中未显示）。十分钟后，如时间约束所示，`salinity`对象对计时器模块进行异步调用，并要求其更新显示上的盐度值。
- en: Because there isn’t an explicit time constraint on the `sendMsg()` operation,
    it could occur any time after the `salinityCheck()` operation and before the `updateSalinityDisp()`
    operation; this is indicated by the `sendMsg()` message arrow’s position between
    the other two messages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`sendMsg()`操作没有明确的时间约束，因此它可能在`salinityCheck()`操作之后、`updateSalinityDisp()`操作之前的任何时刻发生；这可以通过`sendMsg()`消息箭头在另外两个消息之间的位置来表示。
- en: '***7.1.9 Activation Bars***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.9 激活条***'
- en: Activation bars indicate that an object is instantiated and active, and appear
    as open rectangles across a lifeline (see [Figure 7-10](ch07.xhtml#ch7fig10)).
    They are optional, as you can generally infer the lifetime of an object simply
    by looking at the messages traveling to and from it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 激活条表示一个对象已实例化并处于活动状态，它们呈现为横跨生命线的开放矩形（参见[图 7-10](ch07.xhtml#ch7fig10)）。它们是可选的，因为通常你可以仅通过观察发送到和接收到对象的消息来推测对象的生命周期。
- en: '![image](Images/fig7-10.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-10.jpg)'
- en: '*Figure 7-10: Activation bars*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：激活条*'
- en: '**NOTE**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For the most part, activation bars clutter up sequence diagrams, so this book
    will not use them. They’re described here just in case you encounter them in sequence
    diagrams from other sources.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数情况下，激活条会让序列图显得杂乱，因此本书不会使用它们。它们在这里的描述仅仅是为了防止你在其他来源的序列图中遇到它们。*'
- en: '***7.1.10 Branching***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.10 分支***'
- en: As noted in “Guard Conditions” on [page 131](ch07.xhtml#page_131), you can apply
    guard conditions to a message that say, effectively, “if `true`, then execute
    message; else, continue along this lifeline.” Another handy tool is branching—the
    equivalent of the C-style `switch`/`case` statement where you can select one of
    several messages to execute based on a set of guard conditions, one guard for
    each message. In order to execute different messages based on whether a pool uses
    chlorine or bromine as a sanitizer, you might be tempted to draw branching logic
    as shown in [Figure 7-11](ch07.xhtml#ch7fig11).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如“守卫条件”部分所述，见[第 131 页](ch07.xhtml#page_131)，你可以将守卫条件应用于一条消息，这相当于说，“如果`true`，则执行消息；否则，继续沿这个生命周期。”另一个有用的工具是分支——等同于
    C 风格的 `switch`/`case` 语句，你可以根据一组守卫条件选择执行的消息，每条消息都有一个守卫条件。为了根据泳池使用氯或溴作为消毒剂来执行不同的消息，你可能会倾向于按[图
    7-11](ch07.xhtml#ch7fig11)所示的方式绘制分支逻辑。
- en: '![image](Images/fig7-11.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-11.jpg)'
- en: '*Figure 7-11: Bad implementation of branching logic*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-11：不良的分支逻辑实现*'
- en: In one aspect, this diagram makes perfect sense. If the sanitizer for this particular
    pool is bromine rather than chlorine, the first message does not execute and control
    flows down to the second message, which does execute. The problem with this diagram
    is that the two messages appear at different points on the lifeline and, therefore,
    could execute at completely different times. Particularly as your sequence diagrams
    get more complex, some other message invocation could wind up between these two—and
    thus would execute prior to the `getBromine()` message. Instead, if the sanitizer
    is not `chlorine` you’d want to immediately check to see if it is `bromine`, with
    no possibility of intervening messages. [Figure 7-12](ch07.xhtml#ch7fig12) shows
    the proper way to draw this logic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个角度来看，这个图表是完全合理的。如果这个特定泳池的消毒剂是溴而不是氯，则第一个消息不会执行，控制流程会转到第二个消息，第二个消息会执行。这个图表的问题在于两个消息出现在生命周期的不同点，因此它们可能会在完全不同的时间执行。尤其是当你的序列图变得更复杂时，可能会有其他消息调用插入到这两者之间，从而在`getBromine()`消息之前执行。相反，如果消毒剂不是`氯`，你应该立即检查是否是`溴`，并且不允许有任何干扰消息。[图
    7-12](ch07.xhtml#ch7fig12)展示了正确绘制这种逻辑的方法。
- en: '![image](Images/fig7-12.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-12.jpg)'
- en: '*Figure 7-12: Good implementation of branching logic*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：良好的分支逻辑实现*'
- en: Drawing branching logic with the arrow tails that start from the same vertical
    position and the arrowheads that end at the same vertical position avoids any
    ambiguity with the sequence of execution (assuming that the guard conditions are
    mutually exclusive—that is, it is not possible for both conditions to be simultaneously
    `true`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从相同垂直位置开始的箭头尾部和在相同垂直位置结束的箭头头部来绘制分支逻辑，可以避免执行顺序的任何歧义（前提是守卫条件是互斥的——也就是说，不可能同时使两个条件为`true`）。
- en: Branching uses slanted message arrows similar to long delays, but a long delay
    item will have an associated time constraint.^([1](ch19_footnote.xhtml#ch07fn1))
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 分支使用斜向的消息箭头，类似于长时间延迟，但是长延迟项会有相关的时间约束。^([1](ch19_footnote.xhtml#ch07fn1))
- en: '***7.1.11 Alternative Flows***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.11 替代流程***'
- en: 'There’s another potential issue with branching: what happens when you need
    to send one of two different messages to the same destination object? Because
    the arrow tails and heads must start and end, respectively, at the same vertical
    positions for both arrows, the two arrows would overlay each other and there would
    be no indication that branching takes place at all. The solution to this problem
    is to use an *alternative flow*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 分支还有另一个潜在问题：当你需要向同一个目标对象发送两种不同消息中的一种时该怎么办？由于箭头的尾部和头部必须分别在相同的垂直位置开始和结束，这两条箭头会相互重叠，并且无法表明分支的发生。解决这个问题的方法是使用*替代流程*。
- en: In an alternative flow, a single lifeline splits into two separate lifelines
    at some point (see [Figure 7-13](ch07.xhtml#ch7fig13)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在替代流程中，一个单独的生命周期会在某个点分裂成两个独立的生命周期（见[图 7-13](ch07.xhtml#ch7fig13)）。
- en: '![image](Images/fig7-13.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-13.jpg)'
- en: '*Figure 7-13: Alternative flows*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：替代流程*'
- en: 'In this example, the Timer Module has to choose between retrieving the current
    level of salinity (NaCl) or sodium hydroxide (NaOH). The `getSalinity()` and `getNaOH()`
    operations are methods within the same class; therefore, their message arrows
    will both point at the same spot in the `ClGen` lifeline. To avoid overlapping
    the message arrows, [Figure 7-13](ch07.xhtml#ch7fig13) splits the `ClGen` lifeline
    into two lifelines: the original and an alternative flow.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，定时器模块必须在获取当前盐度（NaCl）或氢氧化钠（NaOH）之间做出选择。`getSalinity()`和`getNaOH()`操作是同一类中的方法，因此它们的消息箭头都会指向`ClGen`生命线的同一个位置。为了避免消息箭头重叠，[图7-13](ch07.xhtml#ch7fig13)将`ClGen`生命线分成了两个生命线：原始生命线和一个备用流程。
- en: After the message invocation, you can merge the two flows back together if desired.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息调用之后，如果需要，您可以将两个流程重新合并在一起。
- en: '***7.1.12 Object Creation and Destruction***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.12 对象创建与销毁***'
- en: So far in the examples, the objects have existed throughout the lifetime of
    the sequence diagram; that is, all objects existed prior to the execution of the
    first message (operation) and persist after the execution of the last message.
    In real-world designs, you’ll need to create and destroy objects that don’t exist
    for the full duration of the program’s execution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的示例中，所有对象都在序列图的生命周期内存在；也就是说，所有对象在执行第一条消息（操作）之前就已存在，并且在执行最后一条消息之后仍然存在。在实际设计中，您需要创建和销毁一些在程序执行的整个过程中并不一直存在的对象。
- en: Object creation and destruction are messages just like any other. The common
    convention in UML is to use the special messages «create» and «destroy» (see [Figure
    7-14](ch07.xhtml#ch7fig14)) to show object lifetimes within the sequence diagram;
    however, you can use any message name you like. The X at the end of the `cleanProcess`
    lifeline, immediately below the «destroy» operation, denotes the end of the lifeline,
    because the object no longer exists.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的创建与销毁和其他消息一样。UML中的常用约定是使用特殊消息«create»和«destroy»（参见[图7-14](ch07.xhtml#ch7fig14)）来显示序列图中的对象生命周期；然而，您也可以使用任何您喜欢的消息名称。在`cleanProcess`生命线末尾，紧接着«destroy»操作的X，表示该生命线的结束，因为对象不再存在。
- en: '![image](Images/fig7-14.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-14.jpg)'
- en: '*Figure 7-14: Object creation and destruction*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-14：对象创建与销毁*'
- en: This example uses a *dropped title box* to indicate the beginning of the lifeline
    for a newly created object. As Russ Miles and Kim Hamilton point out in *Learning
    UML 2.0* (O’Reilly, 2003), many standardized UML tools don’t support using dropped
    title boxes, allowing you to place the object title boxes only at the top of the
    diagram. There are a couple of solutions to this problem that should work with
    most standard UML tools.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例使用了一个*掉落标题框*来表示新创建对象的生命周期开始。如Russ Miles和Kim Hamilton在《学习UML 2.0》（O'Reilly,
    2003）中指出，许多标准化的UML工具不支持使用掉落标题框，导致您只能将对象标题框放置在图表的顶部。对于这个问题，存在一些解决方案，应该适用于大多数标准UML工具。
- en: You can put the object at the top of the diagram and add a comment to explicitly
    indicate object creation and destruction at the points where they occur (see [Figure
    7-15](ch07.xhtml#ch7fig15)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将对象放置在图表的顶部，并添加注释，明确指出对象创建和销毁发生的点（参见[图7-15](ch07.xhtml#ch7fig15)）。
- en: '![image](Images/fig7-15.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-15.jpg)'
- en: '*Figure 7-15: Using notes to indicate object lifetime*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-15：使用注释表示对象生命周期*'
- en: You can also use an alternative flow to indicate the lifetime of the object
    (see [Figure 7-16](ch07.xhtml#ch7fig16)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用替代流程来表示对象的生命周期（参见[图7-16](ch07.xhtml#ch7fig16)）。
- en: '![image](Images/fig7-16.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-16.jpg)'
- en: '*Figure 7-16: Using alternative flows to indicate object lifetime*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-16：使用替代流程表示对象生命周期*'
- en: Activation bars provide a third alternative that might be clearer here.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 激活条提供了一个第三种选择，这里可能会更加清晰。
- en: '***7.1.13 Sequence Fragments***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***7.1.13 序列片段***'
- en: UML 2.0 added *sequence fragments* to show loops, branches, and other alternatives,
    enabling you to better manage sequence diagrams. UML defines several standard
    sequence fragment types you can use, defined briefly in [Table 7-1](ch07.xhtml#ch7tab1)
    (full descriptions appear later in this section).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: UML 2.0增加了*序列片段*来表示循环、分支和其他替代流程，使您能够更好地管理序列图。UML定义了几种标准序列片段类型，您可以使用，这些类型简要定义在[表7-1](ch07.xhtml#ch7tab1)中（完整描述稍后会在本节中出现）。
- en: '**Table 7-1:** Brief Descriptions of Sequence Fragment Types'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-1：** 序列片段类型的简要描述'
- en: '| `alt` | Executes only the alternative fragment that is `true` (think of an
    `if`/`else` or `switch` statement). |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `alt` | 仅执行`true`的替代片段（可以类比于`if`/`else`或`switch`语句）。 |'
- en: '| `assert` | Notes that operations within the fragment are valid if a guard
    condition is `true`. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `assert` | 表示如果守卫条件为 `true`，片段中的操作是有效的。 |'
- en: '| `break` | Exits a loop fragment (based on some guard condition). |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `break` | 退出循环片段（基于某些守卫条件）。 |'
- en: '| `consider` | Provides a list of valid messages in a sequence fragment. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `consider` | 提供序列片段中有效消息的列表。 |'
- en: '| `ignore` | Provides a list of invalid messages in a sequence fragment. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `ignore` | 提供序列片段中无效消息的列表。 |'
- en: '| `loop` | Runs multiple times and the guard condition determines whether the
    fragment repeats. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `loop` | 执行多次，守卫条件决定片段是否重复。 |'
- en: '| `neg` | Never executes. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `neg` | 永不执行。 |'
- en: '| `opt` | Executes only if the associated condition is `true`. Comparable to
    `alt` with only one alternative fragment. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `opt` | 仅在关联条件为 `true` 时执行。与 `alt` 类似，但只有一个替代片段。 |'
- en: '| `par` | Runs multiple fragments in parallel. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `par` | 并行执行多个片段。 |'
- en: '| `ref` | Indicates a call to another sequence diagram. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `ref` | 表示调用另一个序列图。 |'
- en: '| `region` | (Also known as `critical`.) Defines a critical region in which
    only one thread of execution is possible. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `region` | （也称为 `critical`）定义一个临界区，在该区域中只能有一个执行线程。 |'
- en: '| `seq` | Indicates that operations (in a multitasking environment) must occur
    in a specific sequence. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `seq` | 表示在多任务环境中操作必须按特定顺序执行。 |'
- en: '| `strict` | A stricter version of `seq`. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `strict` | `seq` 的严格版本。 |'
- en: In general, you draw sequence fragments as a rectangle surrounding the messages,
    with a special penta-rectangle symbol (a rectangle with the lower-right corner
    cropped) in its upper-left corner that contains the UML fragment name/type (see
    [Figure 7-17](ch07.xhtml#ch7fig17); substitute any actual fragment type for typ
    in this diagram).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会画出一个包围消息的矩形序列片段，矩形的左上角有一个特殊的五边形符号（一个右下角被裁剪的矩形），其中包含 UML 片段的名称/类型（参见 [图
    7-17](ch07.xhtml#ch7fig17)；在此图中，用实际的片段类型替代 typ）。
- en: '![image](Images/fig7-17.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-17.jpg)'
- en: '*Figure 7-17: Generic sequence fragment form*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-17：通用序列片段形式*'
- en: For example, if you wanted to repeat a sequence of messages several times, you
    would enclose those messages in a `loop` sequence fragment. This tells the engineer
    implementing the program to repeat those messages the number of times specified
    by the `loop` fragment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想多次重复一系列消息，可以将这些消息放入一个 `loop` 序列片段中。这告诉实现程序的工程师根据 `loop` 片段指定的次数重复这些消息。
- en: You can also include an optional *additional info* item, which is typically
    a guard condition or iteration count. The following subsections describe the sequence
    fragment types from [Table 7-1](ch07.xhtml#ch7tab1) in detail, as well as any
    additional information they may require.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以包括一个可选的 *附加信息* 项，通常是守卫条件或迭代次数。以下小节将详细描述 [表 7-1](ch07.xhtml#ch7tab1) 中的序列片段类型以及它们可能需要的任何附加信息。
- en: '**7.1.13.1 ref**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.13.1 ref**'
- en: 'There are two components to a `ref` sequence fragment: the UML interaction
    occurrence and the reference itself. An *interaction occurrence* is a stand-alone
    sequence diagram corresponding to a subroutine (procedure or function) in code.
    It is surrounded by a sequence fragment box. The penta-rectangle in the upper-left
    corner of the box contains `sd` (for *sequence diagram*) followed by the name
    of the `ref` fragment and any arguments you want to assign to it (see [Figure
    7-18](ch07.xhtml#ch7fig18)).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref` 序列片段有两个组成部分：UML 交互发生和引用本身。一个 *交互发生* 是与代码中的子例程（过程或函数）对应的独立序列图。它被一个序列片段框包围。框的左上角的五边形矩形包含
    `sd`（表示 *序列图*），后面是 `ref` 片段的名称以及你希望分配给它的任何参数（参见 [图 7-18](ch07.xhtml#ch7fig18)）。'
- en: '![image](Images/fig7-18.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-18.jpg)'
- en: '*Figure 7-18: An interaction occurrence example*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-18：交互发生示例*'
- en: The leftmost incoming arrow corresponds to the *subroutine entry point*. If
    this isn’t present, you can assume that control flows to the leftmost participant
    at the top of its lifeline.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最左侧的输入箭头对应于 *子例程入口点*。如果没有这个，你可以假设控制流将进入其生命线顶部的最左侧参与者。
- en: 'Now we come to the second component of the `ref` sequence fragment: referencing
    the interaction occurrence within a different sequence diagram (see [Figure 7-19](ch07.xhtml#ch7fig19)).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们讲解 `ref` 序列片段的第二个组成部分：在不同的序列图中引用交互发生（参见 [图 7-19](ch07.xhtml#ch7fig19)）。
- en: '![image](Images/fig7-19.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-19.jpg)'
- en: '*Figure 7-19: A ref sequence fragment example*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-19：`ref` 序列片段示例*'
- en: This corresponds to a call to a subroutine (procedure or function) in code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于代码中的子程序调用（过程或函数）。
- en: '**7.1.13.2 consider and ignore**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.13.2 consider 和 ignore**'
- en: The `consider` sequence fragment lists all messages that are valid within a
    section of the sequence diagram; all other messages/operators are illegal. The
    `ignore` operator lists names of messages that are invalid within a section of
    the sequence diagram; all other operators/messages are legal.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`consider`序列片段列出了在序列图的某一部分中有效的所有消息；所有其他消息/操作符都是非法的。`ignore`操作符列出了在序列图的某一部分中无效的消息名称；所有其他操作符/消息是合法的。'
- en: '`consider` and `ignore` work either as operators in conjunction with an existing
    sequence fragment or as sequence fragments by themselves. A `consider` or `ignore`
    operator takes the following form:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`consider`和`ignore`可以作为操作符与现有的序列片段一起使用，或者作为独立的序列片段使用。`consider`或`ignore`操作符的格式如下：'
- en: '[PRE0]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `consider` and `ignore` operators may appear after the `sd` *name* title
    in an interaction occurrence (see [Figure 7-20](ch07.xhtml#ch7fig20)), in which
    case they apply to the entire diagram.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`consider`和`ignore`操作符可以出现在交互发生时`sd` *名称* 标题之后（参见[图 7-20](ch07.xhtml#ch7fig20)），在这种情况下，它们适用于整个图表。'
- en: '![image](Images/fig7-20.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-20.jpg)'
- en: '*Figure 7-20: A consider operator example*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-20：一个consider操作符示例*'
- en: You may also create a sequence fragment within another sequence diagram and
    label that fragment with a `consider` or `ignore` operation. In that case, `consider`
    or `ignore` applies only to the messages within the specific sequence fragment
    (see [Figure 7-21](ch07.xhtml#ch7fig21)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在另一个序列图中创建一个序列片段，并用`consider`或`ignore`操作对该片段进行标注。在这种情况下，`consider`或`ignore`仅适用于该特定序列片段中的消息（参见[图
    7-21](ch07.xhtml#ch7fig21)）。
- en: '![image](Images/fig7-21.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-21.jpg)'
- en: '*Figure 7-21: An ignore sequence fragment example*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-21：一个忽略序列片段示例*'
- en: If these fragment types seem strange, consider creating a very generic `ref`
    fragment that handles only certain messages, but then referencing that `ref` from
    several different places that might pass along unhandled messages along with the
    handled ones. By adding a `consider` or `ignore` operator to the `ref`, you can
    have the fragment simply ignore the messages it doesn’t explicitly handle, which
    allows you to use that `ref` without having to add any extra design to the system.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些片段类型看起来很奇怪，可以考虑创建一个非常通用的`ref`片段，仅处理某些消息，然后从多个不同的地方引用该`ref`，这些地方可能会传递未处理的消息以及已处理的消息。通过向`ref`添加`consider`或`ignore`操作符，你可以让该片段简单地忽略它未明确处理的消息，这样你就可以在不必为系统添加任何额外设计的情况下使用该`ref`。
- en: '**7.1.13.3 assert**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.13.3 assert**'
- en: The `assert` sequence fragment tells the system implementer that the messages
    within it are valid only if some guard condition evaluates to `true`. At the end
    of the `assert` fragment, you typically provide some sort of Boolean condition
    (the guard condition) that must be `true` once the sequence is complete (see [Figure
    7-22](ch07.xhtml#ch7fig22)). If the condition isn’t `true` after the `assert`
    fragment has finished executing, the design can’t guarantee correct results. The
    `assert` reminds the engineer to verify that this condition is indeed `true` by,
    for example, using a C++ `assert` macro invocation (or something similar in other
    languages, or even just an `if` statement).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`序列片段告诉系统实现者，只有在某个保护条件计算结果为`true`时，里面的消息才是有效的。在`assert`片段的末尾，通常会提供某种布尔条件（即保护条件），这个条件在序列完成后必须为`true`（参见[图
    7-22](ch07.xhtml#ch7fig22)）。如果`assert`片段执行完毕后该条件不是`true`，则设计无法保证结果正确。`assert`提醒工程师通过例如使用C++的`assert`宏调用（或者其他语言中的类似方法，甚至是`if`语句）来验证该条件确实为`true`。'
- en: '![image](Images/fig7-22.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-22.jpg)'
- en: '*Figure 7-22: An assert sequence fragment example*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-22：一个assert序列片段示例*'
- en: 'In C/C++ you’d probably implement the sequence in [Figure 7-22](ch07.xhtml#ch7fig22)
    using code like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在C/C++中，你可能会使用如下代码来实现[图 7-22](ch07.xhtml#ch7fig22)中的序列：
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**7.1.13.4 loop**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.13.4 循环**'
- en: The `loop` sequence fragment indicates iteration. You place the `loop` operator
    in the penta-rectangle associated with the sequence fragment, and may also include
    a guard condition enclosed in brackets at the top of the sequence fragment. The
    combination of the `loop` operator and guard condition controls the number of
    iterations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop`序列片段表示迭代。你将在与序列片段相关的五边形矩形中放置`loop`操作符，并且还可以在序列片段的顶部包含一个括起来的保护条件。`loop`操作符和保护条件的组合控制迭代次数。'
- en: The simplest form of this sequence fragment is the *infinite* loop, consisting
    of the `loop` operator without any arguments and without a guard condition (see
    [Figure 7-23](ch07.xhtml#ch7fig23)). Most “infinite” loops actually aren’t infinite,
    but terminate with a `break` sequence fragment when some condition is true (we’ll
    discuss the `break` sequence in the next section).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种序列片段的最简单形式是*无限*循环，由没有任何参数且没有保护条件的`loop`运算符组成（见[图7-23](ch07.xhtml#ch7fig23)）。大多数“无限”循环实际上并非真无限，而是在某个条件为真时通过`break`序列片段终止（我们将在下一节讨论`break`序列）。
- en: '![image](Images/fig7-23.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-23.jpg)'
- en: '*Figure 7-23: An infinite loop*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-23：一个无限循环*'
- en: 'The loop in [Figure 7-23](ch07.xhtml#ch7fig23) is roughly equivalent to the
    following C/C++ code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-23](ch07.xhtml#ch7fig23)中的循环大致等同于以下的C/C++代码：'
- en: '[PRE2]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or, alternatively:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，替代的方式是：
- en: '[PRE3]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**NOTE**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Personally, I prefer the following:*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*个人来说，我更喜欢以下这种方式：*'
- en: '#define ever ;;'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '#define ever ;;'
- en: .
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: .
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: .
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: for(ever)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: for(ever)
- en: '{'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Object4->msg2();
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Object4->msg2();
- en: '} // endfor'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '} // endfor'
- en: '*I feel this is the most readable solution. Of course, if you’re “anti-macro
    at all costs,” you would probably disagree with my choice for an infinite loop!*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*我觉得这是最易读的解决方案。当然，如果你是“无论如何都反对宏”的人，你可能会不同意我选择使用无限循环！*'
- en: '*Definite* loops execute a fixed number of times and can appear in two forms.
    The first is `loop(`*integer*`)`, which is shorthand for `loop(0,` *integer*`)`;
    that is, it will execute a minimum of zero times and a maximum of *integer* times.
    The second is `loop(`*minInt*`,` *maxInt*`)`, which indicates that the loop will
    execute a minimum of *minInt* times and a maximum of *maxInt* times. Without a
    guard condition, the minimum count is irrelevant; the loop will always execute
    *maxInt* times. Therefore, most definite loops use the form `loop(`*integer*`)`
    where *integer* is the number of iterations to perform (see [Figure 7-24](ch07.xhtml#ch7fig24)).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*确定*循环执行固定次数，可以有两种形式。第一种是`loop(`*integer*`)`，它是`loop(0,` *integer*`)`的简写；也就是说，它将至少执行零次，最多执行*integer*次。第二种是`loop(`*minInt*`,`
    *maxInt*`)`，表示循环将至少执行*minInt*次，最多执行*maxInt*次。如果没有保护条件，最小次数无关紧要；循环将始终执行*maxInt*次。因此，大多数确定循环使用`loop(`*integer*`)`的形式，其中*integer*是要执行的迭代次数（参见[图7-24](ch07.xhtml#ch7fig24)）。'
- en: '![image](Images/fig7-24.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-24.jpg)'
- en: '*Figure 7-24: A definite loop*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-24：一个确定循环*'
- en: 'The loop in [Figure 7-24](ch07.xhtml#ch7fig24) is roughly equivalent to the
    following C/C++ code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-24](ch07.xhtml#ch7fig24)中的循环大致等同于以下的C/C++代码：'
- en: '[PRE4]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can also use the multiplicity symbol `*` to denote infinity. Therefore,
    `loop(*)` is equivalent to `loop(0, *)` which is equivalent to `loop` (in other
    words, you get an infinite loop).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用乘法符号`*`来表示无限。因此，`loop(*)`等同于`loop(0, *)`，也等同于`loop`（换句话说，你得到的是一个无限循环）。
- en: An *indefinite* loop executes an indeterminate^([2](ch19_footnote.xhtml#ch07fn2))
    number of times (corresponding to `while`, `do/while`, `repeat/until`, and other
    loop forms in programming languages). Indefinite loops include a guard condition
    as part of the `loop` sequence fragment,^([3](ch19_footnote.xhtml#ch07fn3)) meaning
    the `loop` sequence fragment will always execute the loop *minInt* times (zero
    times if *minInt* is not present). After *minInt* iterations, the loop sequence
    fragment will begin testing the guard condition and continue iterating only while
    the guard condition is `true`. The loop sequence fragment will execute at most
    *maxInt* iterations (total, not in addition to the *minInt* iterations). [Figure
    7-25](ch07.xhtml#ch7fig25) shows a traditional `while`-type loop that executes
    a minimum of zero times and a maximum of infinity times, as long as the guard
    condition (`[cond == true]`) evaluates to `true`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*不确定*循环会执行不确定次数（对应于编程语言中的`while`、`do/while`、`repeat/until`等循环形式）。不确定循环包括一个保护条件作为`loop`序列片段的一部分，^([2](ch19_footnote.xhtml#ch07fn2))这意味着`loop`序列片段会始终执行*minInt*次循环（如果*minInt*不存在，则执行零次）。在执行了*minInt*次之后，循环序列片段将开始测试保护条件，只有当保护条件为`true`时，才会继续执行循环。循环序列片段最多会执行*maxInt*次（总共，不包括*minInt*次）。[图7-25](ch07.xhtml#ch7fig25)展示了一个传统的`while`类型循环，最低执行零次，最高执行无限次，只要保护条件（`[cond
    == true]`）的值为`true`。'
- en: '![image](Images/fig7-25.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-25.jpg)'
- en: '*Figure 7-25: An indefinite while loop*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-25：一个不确定的while循环*'
- en: 'The loop in [Figure 7-25](ch07.xhtml#ch7fig25) is roughly equivalent to the
    following C/C++ code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-25](ch07.xhtml#ch7fig25)中的循环大致等同于以下的C/C++代码：'
- en: '[PRE5]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can create a `do..while` loop by setting the *minInt* value to `1` and the
    *maxInt* value to `*`, and then specifying the Boolean expression to continue
    loop execution (see [Figure 7-26](ch07.xhtml#ch7fig26)).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将*minInt*值设置为`1`，将*maxInt*值设置为`*`，然后指定布尔表达式来继续循环执行（参见[图 7-26](ch07.xhtml#ch7fig26)）。
- en: '![image](Images/fig7-26.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-26.jpg)'
- en: '*Figure 7-26: An indefinite do..while loop*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-26：一个不确定的 do..while 循环*'
- en: 'The loop in [Figure 7-26](ch07.xhtml#ch7fig26) is roughly equivalent to the
    following C/C++ code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-26](ch07.xhtml#ch7fig26)中的循环大致等同于以下C/C++代码：'
- en: '[PRE6]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s possible to create many other complex loop types, but I’ll leave that as
    an exercise for interested readers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以创建许多其他复杂的循环类型，但我会把这个留给感兴趣的读者作为练习。
- en: '**7.1.13.5 break**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.13.5 break**'
- en: The `break` sequence fragment consists of the word `break` in a penta-rectangle
    along with a guard condition. If the guard condition evaluates to `true`, then
    the system executes the sequence inside the `break` sequence fragment, after which
    control immediately exits the enclosing sequence fragment. If the enclosing sequence
    fragment is a `loop`, control immediately executes to the first message past the
    `loop` (like a `break` statement in languages like Swift, C/C++, and Java). [Figure
    7-27](ch07.xhtml#ch7fig27) provides an example of such a loop.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`序列片段由一个带有保护条件的五边形矩形框中的单词`break`组成。如果保护条件评估为`true`，则系统执行`break`序列片段中的序列，然后控制立即退出封闭的序列片段。如果封闭的序列片段是`loop`，控制会立即执行到`loop`之后的第一条消息（就像Swift、C/C++和Java等语言中的`break`语句）。[图
    7-27](ch07.xhtml#ch7fig27)提供了这样一个循环的示例。'
- en: '![image](Images/fig7-27.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-27.jpg)'
- en: '*Figure 7-27: An example of the break sequence fragment*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-27：一个 break 序列片段的示例*'
- en: 'The loop in [Figure 7-27](ch07.xhtml#ch7fig27) is roughly equivalent to the
    following C++ code fragment:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-27](ch07.xhtml#ch7fig27)中的循环大致等同于以下C++代码片段：'
- en: '[PRE7]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the most recent `break`-compatible enclosing sequence is a subroutine, not
    a loop, the `break` sequence fragment behaves like a return from a subroutine
    operation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最近的`break`兼容的外层序列是子例程，而不是循环，则`break`序列片段的行为类似于从子例程操作中返回。
- en: '**7.1.13.6 opt and alt**'
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.13.6 opt 和 alt**'
- en: The `opt` and `alt` sequence fragments allow you to control the execution of
    a set of messages with a single guard condition—particularly if the values of
    the components making up the guard condition could change over the execution of
    the sequence.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`opt`和`alt`序列片段允许你通过一个单一的保护条件来控制一组消息的执行——特别是当组成保护条件的组件的值可能在序列执行过程中发生变化时。'
- en: The `opt` sequence fragment is like a simple `if` statement without an `else`
    clause. You attach a guard condition and the system will execute the sequence
    contained within the `opt` fragment only if the guard condition evaluates to `true`
    (see [Figure 7-28](ch07.xhtml#ch7fig28)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`opt`序列片段就像一个简单的`if`语句，没有`else`子句。你附加一个保护条件，系统只有在保护条件评估为`true`时，才会执行`opt`片段中包含的序列（参见[图
    7-28](ch07.xhtml#ch7fig28)）。'
- en: '![image](Images/fig7-28.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-28.jpg)'
- en: '*Figure 7-28: An example of the `opt` sequence fragment*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-28：`opt`序列片段的示例*'
- en: 'The example in [Figure 7-28](ch07.xhtml#ch7fig28) is roughly equivalent to
    the following C/C++ code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-28](ch07.xhtml#ch7fig28)中的示例大致等同于以下C/C++代码：'
- en: '[PRE8]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For more complex logic, use the `alt` sequence fragment, which acts like an
    `if`/`else` or `switch`/`case`. To create an `alt` sequence fragment, you combine
    several rectangles, each with its own guard condition and an optional `else`,
    to form a multiway decision (see [Figure 7-29](ch07.xhtml#ch7fig29)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的逻辑，使用`alt`序列片段，它类似于`if`/`else`或`switch`/`case`。要创建`alt`序列片段，你可以将多个矩形组合在一起，每个矩形都有自己的保护条件和一个可选的`else`，从而形成多路决策（参见[图
    7-29](ch07.xhtml#ch7fig29)）。
- en: '![image](Images/fig7-29.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-29.jpg)'
- en: '*Figure 7-29: An alt sequence fragment*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-29：一个 alt 序列片段*'
- en: 'The interaction occurrence in [Figure 7-29](ch07.xhtml#ch7fig29) is roughly
    equivalent to the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-29](ch07.xhtml#ch7fig29)中的交互发生大致等同于以下代码：'
- en: '[PRE9]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**7.1.13.7 neg**'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.13.7 neg**'
- en: 'You use a `neg` sequence fragment to enclose a sequence that will not be part
    of the final design. Effectively, using `neg` comments out the enclosed sequence.
    Why even include a sequence if it’s not going to be part of the design? There
    are at least two good reasons: code generation and future features.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`neg`序列片段来封装一段不包含在最终设计中的序列。实际上，使用`neg`就是注释掉封闭的序列。如果一段序列最终不包含在设计中，为什么还要包括它呢？至少有两个很好的理由：代码生成和未来功能。
- en: Although, for the most part, UML is a diagramming language intended to help
    with system design prior to implementation in a programming language like Java
    or Swift, there are certain UML tools that will convert UML diagrams directly
    into code. During development, you might want to include some diagrams that illustrate
    something but are not yet complete (certainly not to the point of producing executable
    code). In this scenario, you could use the `neg` sequence fragment to turn off
    the code generation for those sequences that aren’t quite yet ready for prime
    time.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数情况下，UML是一种图示语言，旨在帮助在像Java或Swift这样的编程语言实现之前进行系统设计，但也有一些UML工具可以直接将UML图转换为代码。在开发过程中，你可能想要包含一些图示来说明某些内容，但这些图示尚未完成（当然还没到生成可执行代码的程度）。在这种情况下，你可以使用`neg`序列片段来关闭那些尚未准备好投入使用的序列的代码生成。
- en: Even if you don’t intend to generate code directly from a UML diagram, you might
    want to use the `neg` for future features. When you hand your UML diagrams off
    to an engineer to implement the design, they represent a contract that says, “This
    is how the code is to be written.” Sometimes, though, you’ll want your diagrams
    to show features that you plan to include in a future version of the software,
    but not in the first (or current) version. The `neg` sequence fragment is a clean
    way to tell the engineer to ignore that part of the design. [Figure 7-30](ch07.xhtml#ch7fig30)
    shows a simple example of the `neg` sequence fragment.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不打算直接从UML图生成代码，你可能也想为未来的功能使用`neg`。当你将UML图交给工程师实现设计时，它们代表着一个合同，表明：“这就是代码应该如何编写。”然而，有时候，你希望图示中显示的是你计划在未来版本中加入的功能，而不是在当前（或第一）版本中。`neg`序列片段是告诉工程师忽略该部分设计的一种清晰方式。[图
    7-30](ch07.xhtml#ch7fig30)展示了`neg`序列片段的一个简单示例。
- en: '![image](Images/fig7-30.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-30.jpg)'
- en: '*Figure 7-30: An example of the neg sequence fragment*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-30：neg序列片段的示例*'
- en: 'The example in [Figure 7-30](ch07.xhtml#ch7fig30) is roughly equivalent to
    the following C/C++ code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-30](ch07.xhtml#ch7fig30)中的示例大致等同于以下C/C++代码：'
- en: '[PRE10]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**7.1.13.8 par**'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.13.8 par**'
- en: The `par` sequence fragment, an example of which is shown in [Figure 7-31](ch07.xhtml#ch7fig31),
    states that the enclosed sequences^([4](ch19_footnote.xhtml#ch07fn4)) (operations)
    can be executed in parallel with each other.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`par`序列片段，示例见[图 7-31](ch07.xhtml#ch7fig31)，指出被包含的序列^([4](ch19_footnote.xhtml#ch07fn4))（操作）可以并行执行。'
- en: '![image](Images/fig7-31.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-31.jpg)'
- en: '*Figure 7-31: An example of the par sequence fragment*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-31：par序列片段的示例*'
- en: '[Figure 7-31](ch07.xhtml#ch7fig31) shows three operands: the sequence with
    {`msg2a`, `msg2b`, `msg2c`}, the sequence with {`msg3a`, `msg3b`, `msg3c`}, and
    the sequence with {`msg4a`, `msg4b`, `msg4c`}. The `par` sequence fragment requires
    that the operations within a given sequence must execute in the order in which
    they appear (for example, `msg2a`, then `msg2b`, then `msg2c`). However, the system
    is free to interleave operations from different operands as long as it maintains
    the internal order of those operands. So, in [Figure 7-31](ch07.xhtml#ch7fig31),
    the order {`msg2a`, `msg3a`, `msg3b`, `msg4a`, `msg2b`, `msg2c`, `msg4b`, `msg4c`,
    `msg3c`} is legitimate, as is {`msg4a`, `msg4b`, `msg4c`, `msg3a`, `msg3b`, `msg3c`,
    `msg2a`, `msg2b`, `msg2c`}, because the ordering of the enclosed sequences matches.
    However, {`msg2a`, `msg2c`, `msg4a`, `msg4b`, `msg4c`, `msg3a`, `msg3b`, `msg3c`,
    `msg2b`} is not legitimate because `msg2c` occurs before `msg2b` (which is contrary
    to the ordering specified in [Figure 7-31](ch07.xhtml#ch7fig31)).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-31](ch07.xhtml#ch7fig31)展示了三个操作数：包含{`msg2a`，`msg2b`，`msg2c`}的序列，包含{`msg3a`，`msg3b`，`msg3c`}的序列，以及包含{`msg4a`，`msg4b`，`msg4c`}的序列。`par`序列片段要求给定序列中的操作必须按出现的顺序执行（例如，`msg2a`，然后是`msg2b`，然后是`msg2c`）。然而，系统可以自由交错不同操作数中的操作，只要它保持这些操作数的内部顺序。所以，在[图
    7-31](ch07.xhtml#ch7fig31)中，顺序{`msg2a`，`msg3a`，`msg3b`，`msg4a`，`msg2b`，`msg2c`，`msg4b`，`msg4c`，`msg3c`}是合法的，{`msg4a`，`msg4b`，`msg4c`，`msg3a`，`msg3b`，`msg3c`，`msg2a`，`msg2b`，`msg2c`}也是合法的，因为包含的序列的顺序匹配。然而，{`msg2a`，`msg2c`，`msg4a`，`msg4b`，`msg4c`，`msg3a`，`msg3b`，`msg3c`，`msg2b`}是不合法的，因为`msg2c`出现在`msg2b`之前（这与[图
    7-31](ch07.xhtml#ch7fig31)中指定的顺序相反）。'
- en: '**7.1.13.9 seq**'
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.13.9 seq**'
- en: 'The `par` sequence fragment enforces the following restrictions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`par`序列片段强制执行以下限制：'
- en: The system maintains the ordering of the operations within an operand.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统保持操作数内操作的顺序。
- en: The system allows operations on different lifelines from different operands
    to execute in any order.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统允许来自不同操作数的不同生命线上的操作按任何顺序执行。
- en: 'And the `seq` sequence adds another:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 而`seq`序列片段又添加了另一层：
- en: Operations on the same lifeline in different operands must execute in the order
    in which they appear in the diagram (from top to bottom).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同操作数中相同生命线上的操作必须按它们在图中出现的顺序执行（从上到下）。
- en: In [Figure 7-32](ch07.xhtml#ch7fig32), for example, `Operand1` and `Operand3`
    have messages that are sent to the same object (lifeline). Therefore, in a `seq`
    sequence fragment, `msg2a`, `msg2b`, and `msg2c` must all execute before `msg4a`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[图 7-32](ch07.xhtml#ch7fig32)中，`Operand1`和`Operand3`有发送到同一对象（生命线）的消息。因此，在`seq`序列片段中，`msg2a`、`msg2b`和`msg2c`必须在`msg4a`之前执行。
- en: '![image](Images/fig7-32.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-32.jpg)'
- en: '*Figure 7-32: An example of the seq sequence fragment*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-32：一个`seq`序列片段的示例*'
- en: '[Figure 7-32](ch07.xhtml#ch7fig32) shows a stand-alone `seq` sequence fragment.
    In typical usage, however, a `seq` sequence fragment will appear inside a `par`
    to control the execution sequence of a portion of the `par`’s operands.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-32](ch07.xhtml#ch7fig32)展示了一个独立的`seq`序列片段。然而，在典型使用中，`seq`序列片段会出现在`par`内，以控制`par`的部分操作数的执行顺序。'
- en: '**7.1.13.10 strict**'
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.13.10 strict**'
- en: The `strict` sequence fragment forces the operations to occur in the sequence
    they appear in each operand; interleaving of operations between operands is not
    allowed. The format for a `strict` sequence fragment is similar to that of `par`
    and `seq` (see [Figure 7-33](ch07.xhtml#ch7fig33)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`strict`序列片段强制操作按它们在每个操作数中出现的顺序进行；不允许操作数之间的操作交叉执行。`strict`序列片段的格式类似于`par`和`seq`（参见[图
    7-33](ch07.xhtml#ch7fig33)）。'
- en: '![image](Images/fig7-33.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-33.jpg)'
- en: '*Figure 7-33: An example of the strict sequence fragment*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-33：一个`strict`序列片段的示例*'
- en: The `strict` parallel operation allows the operands to execute in any order,
    but once a given operand begins execution, all the operations within it must complete
    in the sequence specified before any other operand can begin executing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`strict`并行操作允许操作数按任何顺序执行，但一旦某个操作数开始执行，所有操作必须按指定的顺序完成，才能开始执行其他操作数。'
- en: 'In [Figure 7-33](ch07.xhtml#ch7fig33), there are six different operation sequences
    possible: {`Operand1`, `Operand2`, `Operand3`}; {`Operand1`, `Operand3`, `Operand2`};
    {`Operand2`, `Operand1`, `Operand3`}; {`Operand2`, `Operand3`, `Operand1`}; {`Operand3`,
    `Operand1`, `Operand2`}; and {`Operand3`, `Operand2`, `Operand1`}.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 7-33](ch07.xhtml#ch7fig33)中，有六种不同的操作序列可能性：{`Operand1`，`Operand2`，`Operand3`}；{`Operand1`，`Operand3`，`Operand2`}；{`Operand2`，`Operand1`，`Operand3`}；{`Operand2`，`Operand3`，`Operand1`}；{`Operand3`，`Operand1`，`Operand2`}；和{`Operand3`，`Operand2`，`Operand1`}。
- en: However, operations internal to the operands cannot interleave, and must execute
    from top to bottom.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，操作数内部的操作不能交叉执行，必须从上到下执行。
- en: '**7.1.13.11 region**'
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.1.13.11 region**'
- en: 'In the section “[Extending UML Activity Diagrams](ch05.xhtml#lev-5.2)” on [page
    99](ch05.xhtml#page_99), I used the example of a home-brew critical section in
    an activity diagram to demonstrate how to extend UML for your own purposes. I
    pointed out why this is a bad idea (reread that section for the details), and
    mentioned there is another way to achieve what you want to do using standard UML:
    the `region` sequence fragment. UML activity diagrams don’t support critical sections,
    but sequence diagrams do.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第99页](ch05.xhtml#page_99)的“[扩展UML活动图](ch05.xhtml#lev-5.2)”部分中，我用活动图中的一个自制临界区示例来演示如何扩展UML以满足自己的需求。我指出了为什么这是一个不好的主意（可以重新阅读该部分获取详细信息），并提到有另一种方法可以使用标准UML实现你想做的事情：`region`序列片段。UML活动图不支持临界区，但序列图支持。
- en: The `region` sequence fragment specifies that once execution enters the region,
    no other operations in the same parallel execution context can be interleaved
    until it completes execution. The `region` sequence fragment must always appear
    within some other parallel sequence fragment (generally `par` or `seq`; technically
    it could appear inside `strict`, though ultimately this would serve no purpose).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`region`序列片段指定一旦执行进入该区域，同一并行执行上下文中的其他操作不能交叉执行，直到执行完成。`region`序列片段必须始终出现在其他并行序列片段中（通常是`par`或`seq`；技术上它可以出现在`strict`内部，尽管最终这没有实际意义）。'
- en: As an example, consider [Figure 7-34](ch07.xhtml#ch7fig34)—the system is free
    to interleave the execution of any operand’s messages, subject to the rules given
    for the `par` sequence fragment, but once the system enters the critical region
    (with the execution of the `msg4a` operation), no other threads in the `par` sequence
    fragment can execute.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例，考虑[图 7-34](ch07.xhtml#ch7fig34)—系统可以自由地交织任何操作数消息的执行，遵循`par`序列片段给出的规则，但一旦系统进入临界区域（执行`msg4a`操作），`par`序列片段中的其他线程将无法执行。
- en: '![image](Images/fig7-34.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-34.jpg)'
- en: '*Figure 7-34: The region sequence fragment*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-34: 区域序列片段*'
- en: '**7.2 Collaboration Diagrams**'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.2 协作图**'
- en: Collaboration (or communication) diagrams provide the same information as sequence
    diagrams but in a slightly more compact form. Rather than drawing arrows between
    lifelines, in collaboration diagrams we draw message arrows directly between objects,
    and attach numbers to each message to indicate the sequence (see [Figure 7-35](ch07.xhtml#ch7fig35)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 协作图（或通信图）提供与序列图相同的信息，但形式更紧凑一些。与其在生命线之间绘制箭头，在协作图中，我们直接在对象之间绘制消息箭头，并为每条消息附上编号以表示顺序（见[图
    7-35](ch07.xhtml#ch7fig35)）。
- en: '![image](Images/fig7-35.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-35.jpg)'
- en: '*Figure 7-35: A collaboration diagram*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-35: 一个协作图*'
- en: The diagram in [Figure 7-35](ch07.xhtml#ch7fig35) is roughly equivalent to the
    sequence diagram in [Figure 7-9](ch07.xhtml#ch7fig9) (without the time constraint
    of 10 minutes). In [Figure 7-35](ch07.xhtml#ch7fig35) the `salinityCheck` message
    executes first, `sendMsg` executes second, and `updateSalinityDisplay` executes
    last.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-35](ch07.xhtml#ch7fig35)中的图表大致等同于[图 7-9](ch07.xhtml#ch7fig9)中的序列图（不考虑10分钟的时间限制）。在[图
    7-35](ch07.xhtml#ch7fig35)中，`salinityCheck`消息首先执行，`sendMsg`第二执行，`updateSalinityDisplay`最后执行。'
- en: '[Figure 7-36](ch07.xhtml#ch7fig36) shows a more complex collaboration diagram
    that better demonstrates the compactness of this option. The six messages sent
    in this example would require six lines in a sequence diagram but here require
    only three communication links.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-36](ch07.xhtml#ch7fig36) 显示了一个更复杂的协作图，它更好地展示了这一选项的紧凑性。这个示例中的六条消息在序列图中需要六条线，而在这里只需要三条通信链接。'
- en: '![image](Images/fig7-36.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-36.jpg)'
- en: '*Figure 7-36: A more complex collaboration diagram*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-36: 更复杂的协作图*'
- en: '**NOTE**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Having both collaboration and sequence diagrams is probably an artifact of
    merging different systems together when UML was created. Which one you use is
    really just a matter of personal preference. Keep in mind, however, that as the
    diagrams become more complex, collaboration diagrams become harder to follow.*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*同时拥有协作图和序列图可能是UML创建过程中合并不同系统的产物。你使用哪一个实际上只是个人偏好的问题。然而，请记住，随着图表的复杂性增加，协作图会变得更加难以理解。*'
- en: '**7.3 For More Information**'
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.3 更多信息**'
- en: 'Bremer, Michael. *The User Manual Manual: How to Research, Write, Test, Edit,
    and Produce a Software Manual*. Grass Valley, CA: UnTechnical Press, 1999\. A
    sample chapter is available at *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'Bremer, Michael. *用户手册手册：如何研究、编写、测试、编辑和制作软件手册*. Grass Valley, CA: UnTechnical
    Press, 1999\. 你可以在 *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*
    下载示例章节。'
- en: 'Larman, Craig. *Applying UML and Patterns: An Introduction to Object-Oriented
    Analysis and Design and Iterative Development*. 3rd ed. Upper Saddle River, NJ:
    Prentice Hall, 2004.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 'Larman, Craig. *应用UML与模式：面向对象分析与设计及迭代开发导论*. 第三版. Upper Saddle River, NJ: Prentice
    Hall, 2004.'
- en: 'Miles, Russ, and Kim Hamilton. *Learning UML 2.0: A Pragmatic Introduction
    to UML*. Sebastopol, CA: O’Reilly Media, 2003.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'Miles, Russ, 和 Kim Hamilton. *学习UML 2.0：UML的实用入门*. Sebastopol, CA: O’Reilly
    Media, 2003.'
- en: 'Pender, Tom. *UML Bible*. Indianapolis: Wiley, 2003.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pender, Tom. *UML圣经*. 印第安纳波利斯: Wiley, 2003.'
- en: 'Pilone, Dan, and Neil Pitman. *UML 2.0 in a Nutshell: A Desktop Quick Reference*.
    2nd ed. Sebastopol, CA: O’Reilly Media, 2005.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pilone, Dan, 和 Neil Pitman. *UML 2.0概述：桌面快速参考*. 第二版. Sebastopol, CA: O’Reilly
    Media, 2005.'
- en: 'Roff, Jason T. *UML: A Beginner’s Guide*. Berkeley, CA: McGraw-Hill Education,
    2003.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'Roff, Jason T. *UML：初学者指南*. 伯克利, CA: McGraw-Hill Education, 2003.'
- en: Tutorials Point. “UML Tutorial.” [*https://www.tutorialspoint.com/uml/*](https://www.tutorialspoint.com/uml/).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Tutorials Point. “UML教程。” [*https://www.tutorialspoint.com/uml/*](https://www.tutorialspoint.com/uml/)。
