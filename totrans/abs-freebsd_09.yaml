- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: SECURING YOUR SYSTEM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**保护您的系统**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Securing your system means ensuring that your computer’s resources are used
    only by authorized people for authorized purposes. Even if you have no important
    data on your system, you still have valuable CPU time, memory, and bandwidth.
    Many folks who thought that their systems were too unimportant for anyone to bother
    breaking into found themselves an unwitting relay for an attack that disabled
    a major corporation. You don’t want to wake up one morning to the delightful sound
    of law enforcement agents kicking in your door because your insecure computer
    broke into a bank.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 保护您的系统意味着确保计算机的资源仅供授权人员用于授权的目的。即使您的系统上没有重要数据，您仍然拥有宝贵的CPU时间、内存和带宽。许多曾认为自己的系统不重要，不会有人去破解的人，最终发现自己成了一个无意中的中继站，成为了攻击的工具，导致某个大型公司瘫痪。你不希望有一天早上醒来，听到执法人员破门而入的声音，因为您的不安全计算机被用来破解了某个银行。
- en: Sure, there are things worse than having some punk kid take over your servers—say,
    having the neighborhood loan shark break both your legs. Discovering that your
    organization’s web page now says, “Ha ha, you’ve been r00ted!” is a decent competitor
    for second place. Even more comprehensible intrusions cause huge headaches. Most
    of the actual intrusions I’ve been involved with (not as an attacker, but as a
    consultant to the victim) have originated from countries with government censorship,
    and traffic analysis showed that the intruders were actually just looking for
    unrestricted access to news sites. While I fully sympathize with these people,
    when I’m depending upon the stable operation of my servers to run my business,
    their intrusion is unacceptable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有比某个小屁孩接管您的服务器更糟糕的事情——比如邻里的高利贷者把你的两条腿打断。发现您组织的网页上现在写着“哈哈，你被r00t了！”是个相当强劲的竞争者，可能排得上第二。即便是更容易理解的入侵也会带来巨大的麻烦。我曾参与过的多数实际入侵事件（我不是攻击者，而是作为受害者的顾问）都来自那些有政府审查制度的国家，流量分析显示攻击者其实只是想获取不受限制的新闻网站访问权限。虽然我完全同情这些人，但当我依赖服务器的稳定运行来经营我的业务时，他们的入侵是不可接受的。
- en: Over the last few years, taking over remote computers has become much easier.
    Point-and-click programs for subverting computers can be found through search
    engines. When one bright attacker writes an exploit, several thousand bored teenagers
    with nothing better to do can download it and make life difficult for the rest
    of us. Even if the data on your system is worthless, you must secure the system’s
    resources.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，接管远程计算机变得容易多了。可以通过搜索引擎找到一些点选即用的程序，用来颠覆计算机。当一个聪明的攻击者编写了一个漏洞时，数千个无聊的青少年可以下载它，并让我们其他人生活得更困难。即使系统上的数据毫无价值，您仍然必须保护系统的资源。
- en: Generally speaking, operating systems are not broken into; the programs running
    on operating systems are. Even the most paranoiac, secure-by-default operating
    system in the world can’t protect badly written programs from themselves. Occasionally,
    one of those programs can interact with the operating system in such a way as
    to actually compromise the operating system. The most well-known of these are
    *buffer overflows*, where an intruder’s program is dumped straight into the CPU’s
    execution space and the operating system runs it. FreeBSD has undergone extensive
    auditing to eliminate buffer overflows as well as myriad other well-understood
    security issues, but that’s no guarantee that they’ve been eradicated. New functions
    and programs appear continuously, and they can interact with older functions and
    each other in unexpected ways.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，操作系统本身并不会被攻破；而是运行在操作系统上的程序会被攻破。即便是世界上最为偏执、默认安全的操作系统，也无法保护写得不好的程序免受其自身问题的影响。偶尔，某个程序可能与操作系统以某种方式交互，从而实际上危及操作系统的安全。其中最著名的就是*缓冲区溢出*，在这种情况下，攻击者的程序会直接被转储到CPU的执行空间，操作系统随后执行它。FreeBSD进行了广泛的审计，消除了缓冲区溢出以及其他众多众所周知的安全问题，但这并不意味着它们已经被彻底根除。新功能和程序不断出现，它们可能以意想不到的方式与旧功能或彼此之间发生交互。
- en: FreeBSD provides many tools to help you secure your system against attackers,
    both internal and external. While no one of these tools is sufficient, all are
    desirable. Treat everything you learn about system security as a tool in a kit,
    not as the answer to all your problems. For example, while simply raising a system’s
    securelevel will not make your system secure, it can help when combined with reasonable
    permissions, file flags, regular patching, password control, and all the other
    things that make up a good security policy. We’ll cover more advanced security
    tools in [Chapter 19](ch19.xhtml#ch19), but without the basic protections discussed
    here, those tools won’t help secure your system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 提供了许多工具来帮助你保护系统免受内外部攻击者的侵害。虽然这些工具中的任何一个单独使用都不足够，但它们都是可取的。将你关于系统安全的所有知识视为工具箱中的工具，而不是解决所有问题的答案。例如，虽然仅仅提高系统的安全级别不会让你的系统变得安全，但结合合理的权限、文件标志、定期修补、密码控制以及所有构成良好安全策略的其他措施时，它会起到作用。我们将在[第19章](ch19.xhtml#ch19)中介绍更多的高级安全工具，但如果没有在这里讨论的基本保护措施，这些工具无法帮助你保护系统。
- en: '**Who Is the Enemy?**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**敌人是谁？**'
- en: 'We’ll arbitrarily lump potential attackers into four groups: script kiddies,
    disaffected users, botnets, and skilled attackers. You’ll find a more detailed
    classification in books dedicated to security, but that’s not what you’re here
    for. These categories are easily explained, easily understood, and include 99
    percent of all the attackers you’re likely to encounter.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将潜在的攻击者随便分为四组：脚本小子、不满的用户、僵尸网络和有技术的攻击者。你会在专门讨论安全的书籍中找到更详细的分类，但这不是你要关注的内容。这些类别容易解释，容易理解，并涵盖了你可能遇到的99%的攻击者。
- en: '***Script Kiddies***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***脚本小子***'
- en: 'The most numerous human attackers, *script kiddies*, are not sysadmins. They’re
    not skilled. They download attack programs that work on a point-and-click basis
    and go looking for vulnerable systems. They’re the equivalent of purse snatchers,
    preying upon old ladies holding their bags just a little bit too loosely. Fortunately,
    script kiddies are easy to defend against: just keep your software up-to-date
    and follow good computing practices. Like locusts, script kiddies are easy to
    squash, but there are just so darned *many* of them!'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最多的人类攻击者，*脚本小子*，并不是系统管理员。他们没有技能。他们下载基于点击操作的攻击程序，寻找易受攻击的系统。他们相当于抢包的小偷，专门欺负那些手提包稍微松懈的老太太。幸运的是，脚本小子很容易防范：只需保持软件更新，并遵循良好的计算机操作规范。像蝗虫一样，脚本小子容易被打败，但他们实在是*太多*了！
- en: '***Disaffected Users***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不满的用户***'
- en: The second group, your own users, causes the majority of security problems.
    Your organization’s employees are the people most likely to know where the security
    gaps are, to feel that the rules don’t apply to them, and to have the time to
    spend breaking your security. If you tell an employee that company policy forbids
    him access to a computer resource, and if the employee feels that he should have
    access to it, he’s likely to search for a way around the restriction. Anyone who
    feels that he’s so fabulously special that the rules don’t apply to him is a security
    risk. Worse, when an employee who knows all the dirty laundry gets angry, bad
    things can happen. You might have all your servers patched and a downright misanthropic
    firewall installed, but if anyone who knows the password is *Current93* can dial
    the back room modem, you’re in trouble.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二类群体，你的用户，是导致大多数安全问题的根源。你组织的员工最有可能知道安全漏洞的位置，认为规则不适用于他们，并且有时间去破坏你的安全。如果你告诉某个员工公司政策禁止他访问某个计算机资源，而该员工认为他应该有权访问，那么他很可能会寻找绕过限制的方法。任何认为自己特别到规则不适用的人都是安全风险。更糟糕的是，当一个知道所有丑事的员工生气时，坏事可能会发生。你可能已经修补了所有服务器，并安装了极为反人类的防火墙，但如果任何知道密码的人是*Current93*，能够拨打后端调制解调器，你就麻烦了。
- en: The best way to stop people like these is simply not to be sloppy. Don’t leave
    projects insecurely half-finished or half-documented. When someone leaves the
    company, disable his account, change all administrative passwords, inform all
    employees of that person’s departure, and remind them not to share confidential
    knowledge with that person. Have a computer security policy with real violation
    penalties and have HR enforce it. And get rid of the unsecured modem, the undocumented
    telnet server running on an odd port, or whatever hurried hack you put into place
    thinking that nobody would ever find it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止这些人的最佳方式就是简单地不要疏忽大意。不要把项目半途而废或文档不全地留着。当有人离开公司时，禁用他的账户，修改所有的管理员密码，通知所有员工该人的离职，并提醒他们不要与该人分享机密信息。制定一套具有实际违规惩罚的计算机安全政策，并由人力资源部门执行。并且，清除那些不安全的调制解调器、运行在奇怪端口上的未记录的
    telnet 服务器，或者你当初匆忙设置的、以为没人会发现的黑客后门。
- en: '***Botnets***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***僵尸网络***'
- en: Botnets are more numerous than either of the above, but they’re not human. They’re
    machines compromised by malware and controlled from a central point. Botnets can
    include millions of machines. The malware authors control the botnets and use
    them for anything from searching for more vulnerable hosts to sending spam or
    breaking into secure sites. Most botnets are composed of Windows and Linux machines,
    but there’s no reason why FreeBSD operating systems can’t be assimilated into
    botnets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 僵尸网络的数量超过了上述任何一类，但它们不是人类。它们是被恶意软件感染并从一个中心点控制的机器。僵尸网络可以包括数百万台机器。恶意软件的作者控制着这些僵尸网络，并利用它们做任何事情，从寻找更多易受攻击的主机到发送垃圾邮件或突破安全网站。大多数僵尸网络由
    Windows 和 Linux 机器组成，但并不排除 FreeBSD 操作系统也可能被纳入僵尸网络中。
- en: Fortunately, botnet defense is much like script kiddie defense; keeping your
    software patched and following good computing practices goes a long way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，僵尸网络防御和脚本小子防御非常相似；保持软件更新并遵循良好的计算实践会带来很大帮助。
- en: '***Motivated Skilled Attackers***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***有动机的熟练攻击者***'
- en: The most dangerous group—skilled attackers—are competent system administrators,
    security researchers, penetration specialists, and criminals who want access to
    your specific resources. Computer penetration is a lucrative criminal field these
    days, especially if the victim has resources that can be used for distributed
    denial-of-service (DDos) attacks or mass spam transmission. Compromising a web
    farm and turning it to evil is profitable. If you have valuable company secrets,
    you might be targeted by one of these intruders. If one of these people *really*
    wants to break into your network, he’ll probably get there.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最危险的群体——熟练攻击者——是那些有能力的系统管理员、安全研究员、渗透专家和犯罪分子，他们想要访问你的特定资源。如今，计算机渗透是一个有利可图的犯罪领域，尤其是当受害者拥有可以用于分布式拒绝服务（DDoS）攻击或大规模垃圾邮件传输的资源时。妥协一个网站农场并将其转化为恶意用途是有利可图的。如果你有有价值的公司机密，可能会成为这些入侵者的目标。如果这些人*真的*想要突破你的网络，他很可能会成功。
- en: Still, security measures that stop the first three groups of people change the
    tactics of the skilled attacker. Instead of breaking into your computers over
    the network, he’ll have to show up at your door dressed as a telco repairman lugging
    a packet sniffer, or dumpster-dive searching for old sticky notes with scribbled
    passwords. This dramatically increases his risk, possibly making an intrusion
    more trouble than it’s worth. If you can make the intruder’s break-in plan resemble
    a Hollywood script *no matter how much he knows about your network*, your security
    is probably pretty good.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，能够阻止前三类人群的安全措施会改变熟练攻击者的战术。他将不再通过网络突破你的计算机，而是得以伪装成一名电信维修工，背着一个数据包嗅探器出现在你家门口，或是翻垃圾桶找寻写满密码的旧便签。这大大增加了他的风险，可能会使得入侵变得不值得冒险。如果你能让入侵者的突破计划看起来像一部好莱坞剧本，*不管他对你的网络了解多少*，那么你的安全措施可能已经相当不错了。
- en: '**Hackers, Intruders, and Related Scum**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑客、入侵者及相关渣滓**'
- en: You’ll frequently hear the word *hacker* used to describe people who break into
    computers. This word has different meanings depending on the speaker. In the technical
    world, a hacker is someone who’s interested in the inner workings of technology.
    Some hackers are interested in everything; others have a narrow area of specialization.
    In the open source community, *hacker* is a title of respect. The main FreeBSD
    technical list is *[FreeBSD-hackers@FreeBSD.org](mailto:FreeBSD-hackers@FreeBSD.org)*.
    In the popular media, however, a hacker is someone who breaks into computer systems,
    end of story.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常听到“*黑客*”这个词用来描述那些闯入计算机的人。这个词根据说话者的不同有不同的含义。在技术领域，黑客是指那些对技术内部运作感兴趣的人。有些黑客对所有内容都有兴趣，而其他人则专注于某一特定领域。在开源社区中，*黑客*是一个尊重的称呼。FreeBSD的主要技术邮件列表是*
    [FreeBSD-hackers@FreeBSD.org](mailto:FreeBSD-hackers@FreeBSD.org)*。然而，在大众媒体中，黑客通常是指那些闯入计算机系统的人，故事就到此为止。
- en: To reduce confusion, I recommend completely avoiding the word *hacker*. In this
    book, I call people who break into computers *intruders*.[*](ch09.xhtml#ch09fn1aa)
    Technical wizards can be called by a variety of names, but they rarely object
    to “Oh Great and Powerful One.”
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少混淆，我建议完全避免使用“*黑客*”这个词。在本书中，我称那些闯入计算机的人为*入侵者*。[*](ch09.xhtml#ch09fn1aa) 技术高手可以被称为各种名字，但他们通常不会反对“哦，伟大而强大的存在”。
- en: '[*](ch09.xhtml#ch09fn1b) Two editions later, and my editor *still* won’t let
    me print what I call them in person.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[*](ch09.xhtml#ch09fn1b) 两个版本之后，我的编辑*仍然*不允许我当面说出我对他们的看法。'
- en: '**FreeBSD Security Announcements**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**FreeBSD安全公告**'
- en: The best defense against any attackers is to keep your system up to date. This
    means you must know when to patch your system, what to patch, and how. An outdated
    system is a script kiddie’s best friend.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 防范任何攻击者的最佳方法是保持系统的最新状态。这意味着你必须知道何时为系统打补丁，打什么补丁，以及如何打。一个过时的系统是脚本小子的最佳伙伴。
- en: The FreeBSD Project includes volunteers who specialize in auditing source code
    and watching for security issues with both the base operating system and add-on
    software. These developers maintain a very low-volume mailing list, *[FreeBSD-security-notifications@FreeBSD.org](mailto:FreeBSD-security-notifications@FreeBSD.org)*,
    and subscribing is a good idea. While you can monitor other mailing lists for
    general announcements, the security notifications list is a single source for
    FreeBSD-specific information. To subscribe to the security notifications mailing
    list, see the instructions on *[http://lists.freebsd.org/](http://lists.freebsd.org/)*.
    The FreeBSD security team releases advisories on that mailing list as soon as
    they’re available.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD项目包含一些志愿者，他们专门负责审计源代码，并监控基础操作系统及附加软件的安全问题。这些开发人员维护着一个非常低流量的邮件列表，* [FreeBSD-security-notifications@FreeBSD.org](mailto:FreeBSD-security-notifications@FreeBSD.org)
    *，订阅该列表是一个好主意。虽然你可以通过其他邮件列表来获取一般公告，但安全通知列表是获取FreeBSD特定信息的唯一来源。要订阅安全通知邮件列表，请参见*
    [http://lists.freebsd.org/](http://lists.freebsd.org/)*。FreeBSD安全团队会在该邮件列表中一有新的安全公告就发布。
- en: Read advisories carefully and quickly act on those that affect you, as you can
    be certain that script kiddies are searching for vulnerable machines. FreeBSD
    makes applying security patches pretty easy, as [Chapter 18](ch18.xhtml#ch18)
    discusses.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读安全公告，并迅速采取措施应对影响到你的那些问题，因为你可以确定脚本小子正在寻找易受攻击的机器。正如[第18章](ch18.xhtml#ch18)所讨论的，FreeBSD使得应用安全补丁变得非常简单。
- en: '**User Security**'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户安全**'
- en: Remember when I said that your own users are your greatest security risk? Here’s
    where you learn to keep the little buggers in line. FreeBSD has a variety of ways
    to allow users to do their work without giving them free rein on the system. We’ll
    look at the most important tools here, starting with adding users in the first
    place.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我说过，你自己的用户是你最大的安全隐患吗？现在你将学习如何管好这些“小家伙”。FreeBSD提供了多种方式，让用户能够完成工作，而不需要让他们在系统上为所欲为。我们将在这里讨论一些最重要的工具，从添加用户开始。
- en: '***Creating User Accounts***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建用户账户***'
- en: FreeBSD uses the standard Unix user management programs such as passwd(1), pw(8),
    and vipw(8). FreeBSD also includes a friendly interactive user-adding program,
    adduser(8). Only *root* may add users, of course. Just type `adduser` on the command
    line to enter an interactive shell.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD使用标准的Unix用户管理程序，如passwd(1)、pw(8)和vipw(8)。FreeBSD还包含了一个友好的交互式用户添加程序adduser(8)。当然，只有*root*用户可以添加其他用户。只需在命令行中输入`adduser`即可进入交互式命令行。
- en: The first time you run adduser(8), it prompts you to set appropriate defaults
    for all new user settings. Use the following example session to help you determine
    appropriate defaults for your system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行 adduser(8) 时，它会提示你为所有新用户设置适当的默认值。使用以下示例会话来帮助你为系统确定合适的默认值。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The username ➊ is the name of the account. Users on my systems get a username
    of their first initial, middle initial, and last name. You can assign usernames
    by whatever scheme you dream up. Here, I let the user pick their own username,
    an indulgence I always later regret. The full name ➋ is the user’s real name.
    FreeBSD then lets you choose a numerical user ID (UID) ➌. FreeBSD starts numbering
    UIDs at 1,000; while you can change this, all UIDs below 1,000 are reserved for
    system use. I recommend just pressing ENTER to take the next available UID.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名 ➊ 是账户的名称。我系统上的用户会获得一个由他们的名字首字母、中间名首字母和姓氏组成的用户名。你可以根据自己想出的方案来分配用户名。在这里，我让用户自己选择用户名，这种宽容通常会让我后悔。全名
    ➋ 是用户的真实姓名。FreeBSD 接着让你选择一个数字化的用户 ID (UID) ➌。FreeBSD 从 1000 开始编号 UID；虽然你可以更改此设置，但所有低于
    1000 的 UID 都保留给系统使用。我建议直接按 ENTER 键选择下一个可用的 UID。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The user’s default group ➊ is important—remember, Unix permissions are set by
    owner and group. The FreeBSD default of having each user in their own group is
    usually the most sensible way for most setups. Any of the big thick books on system
    administration offers several grouping schemes—feel free to use whatever matches
    your needs. You can add this user to other groups ➋ in addition to the primary
    group at this time, if appropriate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的默认组 ➊ 非常重要——记住，Unix 权限是根据所有者和组设置的。FreeBSD 默认将每个用户分配到自己的组，通常是大多数设置中最合理的方式。关于系统管理的大部头书籍提供了几种分组方案——随时使用任何符合你需求的方案。如果适当，你现在可以将该用户添加到其他组
    ➋，除了主组之外。
- en: A login class ➌ specifies what level of resources the user has access to. We’ll
    talk about login classes later in this section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 登录类 ➌ 指定了用户可以访问的资源级别。我们稍后会在本节中讨论登录类。
- en: The shell ➍ is the command line environment. While the system default is */bin/sh*,
    I prefer tcsh.^([1](footnote.xhtml#ch09fn1)) If you’re deeply attached to another
    shell, feel free to use it instead. Knowledgeable users can change their own shells.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Shell ➍ 是命令行环境。虽然系统默认是 */bin/sh*，我更喜欢 tcsh。^([1](footnote.xhtml#ch09fn1)) 如果你对其他
    shell 深有依赖，随时可以使用它。精通的用户可以更改自己的 shell。
- en: The home directory ➎ is where the user’s files reside on disk. The user and
    that user’s primary group own this directory. You can set custom permissions ➏
    on the directory if you want, probably so that other users can’t view this user’s
    directory.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 家目录 ➎ 是用户文件在磁盘上的存放位置。该用户及其主组拥有此目录。如果需要，你可以在目录上设置自定义权限 ➏，通常是为了防止其他用户查看该用户的目录。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The password options give you a certain degree of flexibility. If all of your
    users are comfortable with key-based SSH authentication, perhaps you can get away
    without using passwords. In the meantime, the rest of us are stuck with passwords
    ➊.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 密码选项提供了一定程度的灵活性。如果所有用户都熟悉基于密钥的 SSH 身份验证，也许你可以不用密码。与此同时，其余的人都得依赖密码 ➊。
- en: Use an empty password ➋ if you want the user to set his or her own password
    via the console. Whoever connects to that account first gets to set the password.
    This makes an empty password a good idea right up there with smoking inside a
    hydrogen dirigible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望用户通过控制台设置自己的密码，可以使用空密码 ➋。第一次连接到该账户的人将设定密码。将空密码作为一种设置，与在氢气飞艇内吸烟一样不太明智。
- en: A random password ➌, on the other hand, is a good idea for a new account. The
    random password generator FreeBSD provides is good enough for day-to-day use.
    Random passwords are usually hard to remember, which encourages the user to change
    his password as soon as possible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，随机密码 ➌ 对于新账户来说是一个好主意。FreeBSD 提供的随机密码生成器足够日常使用。随机密码通常很难记住，这会促使用户尽快更改密码。
- en: When an account is locked ➍, nobody can use it to log in. This is generally
    counterproductive.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当账户被锁定 ➍ 时，没人可以用它登录。这通常是适得其反的。
- en: After entering all this information, adduser spits everything back at you for
    review and confirmation or rejection. Once you confirm, adduser verifies the account
    setup and provides you with the randomly generated password. It then creates the
    user’s home directory, copies the shell configuration files from */etc/skel*,
    and asks whether you want to set up another user.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输入所有信息后，adduser会将所有内容反馈给您进行审查和确认或拒绝。一旦您确认，adduser会验证账户设置并为您提供随机生成的密码。然后，它会创建用户的主目录，从*/etc/skel*复制shell配置文件，并询问您是否要设置另一个用户。
- en: '***Configuring Adduser: /etc/adduser.conf***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置Adduser: /etc/adduser.conf***'
- en: Creating new users on some Unix systems requires you to manually edit */etc/passwd*,
    rebuild the password database, edit */etc/group*, create a home directory, set
    permissions on that home directory, install dotfiles, and so on. This makes handling
    your local customizations routine—if you set everything by hand, you can manage
    your local account setup easily. The adduser(8) program provides a set of sensible
    defaults. For sites with different requirements, */etc/adduser.conf* lets you
    set those requirements as defaults while retaining the high degree of automation.
    To create *adduser.conf file*, run `adduser -C` and answer the questions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Unix系统上创建新用户需要手动编辑*/etc/passwd*，重建密码数据库，编辑*/etc/group*，创建主目录，设置该主目录的权限，安装dotfiles，等等。这使得处理本地自定义变得例行化——如果您手动设置所有内容，就可以轻松管理本地账户设置。adduser(8)程序提供了一组合理的默认值。对于有不同需求的网站，*/etc/adduser.conf*允许您将这些需求设置为默认值，同时保持高度的自动化。要创建*adduser.conf文件*，请运行`adduser
    -C`并回答相关问题。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You might want to start numbering UIDs somewhere other than 1,000\. If you want
    higher initial UIDs, enter it in the `Uid` space ➊. Don’t start below 1,000.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望从1,000以外的地方开始编号UID。如果您想要更高的初始UID，请在`Uid`字段中输入 ➊。不要从1,000以下开始。
- en: The login group ➋ is the default user group. An empty login group means the
    user account defaults to having its own unique user group (the FreeBSD default).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 登录组 ➋ 是默认的用户组。空的登录组意味着用户账户默认会有一个独立的唯一用户组（FreeBSD默认设置）。
- en: You can specify any additional user groups ➌ that new accounts belong to by
    default, as well as the login class ➍. I set both of these to `staff` so that
    all new users get added to that group and assigned that class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定新账户默认属于的任何其他用户组 ➌，以及登录类 ➍。我将这两个设置为`staff`，这样所有新用户都会被添加到该组并分配该类。
- en: Choose a default shell ➎ for your users.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的用户选择一个默认的shell ➎。
- en: Your home directory location ➏ might vary from the standalone FreeBSD standard.
    In this example, I’ve specified a typical style of NFS-mounted home directories
    used when many users have accounts on many machines.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您的主目录位置 ➏ 可能与独立的FreeBSD标准有所不同。在这个例子中，我指定了当多个用户在多台机器上有账户时，常用的NFS挂载的主目录样式。
- en: Choose the default password behavior for new users. You can specify whether
    users should use passwords at all ➐ and whether the initial password should be
    empty ➑ or random ➒.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 选择新用户的默认密码行为。您可以指定用户是否应该使用密码 ➐，以及初始密码是应该为空 ➑ 还是随机生成 ➒。
- en: Finally, dictate whether new accounts should default to being locked or not
    ➓.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，决定新账户是否默认锁定 ➓。
- en: You’ll find more configuration settings in adduser.conf(5). While you can set
    account characteristics here, the format of this file is considered internal to
    adduser(8). The setting names can change with any FreeBSD release. To change *adduser.conf*,
    re-run `adduser -C`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在adduser.conf(5)中找到更多配置设置。虽然您可以在这里设置账户特征，但该文件的格式被认为是adduser(8)的内部格式。设置名称可能会随着任何FreeBSD版本的发布而变化。要更改*adduser.conf*，请重新运行`adduser
    -C`。
- en: '***Editing Users***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编辑用户***'
- en: Managing users isn’t just about creating and deleting accounts. You’ll need
    to change those accounts from time to time. While FreeBSD includes several tools
    for editing accounts, the simplest are passwd(1), chpass(1), vipw(8), and pw(8).
    These work on the tightly interrelated files */etc/master.passwd*, */etc/passwd*,
    */etc/spwd.db*, and */etc/pwd.db*. We’ll start with the files and then review
    the common tools for editing those files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 管理用户不仅仅是创建和删除账户。您需要不时地更改这些账户。虽然FreeBSD提供了多个工具用于编辑账户，但最简单的工具是passwd(1)、chpass(1)、vipw(8)和pw(8)。这些工具作用于紧密关联的文件*/etc/master.passwd*、*/etc/passwd*、*/etc/spwd.db*和*/etc/pwd.db*。我们将从这些文件开始，然后回顾编辑这些文件的常用工具。
- en: The files */etc/master.passwd*, */etc/passwd*, */etc/spwd.db*, and */etc/pwd.db*
    hold user account information. Each file has a slightly different format and purpose.
    The file */etc/master.passwd* is the authoritative source of user account information
    and includes user passwords in encrypted form. Normal users don’t have permission
    to view the contents of */etc/master.passwd*. Regular users need access to basic
    account information, however; how else can unprivileged system programs identify
    users? The file */etc/passwd* lists user accounts with all privileged information
    (such as the encrypted password) removed. Anyone can view the contents of */etc/passwd*
    to get basic account information.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 */etc/master.passwd*、*/etc/passwd*、*/etc/spwd.db* 和 */etc/pwd.db* 都包含用户账户信息。每个文件的格式和用途略有不同。文件
    */etc/master.passwd* 是权威的用户账户信息来源，并包含加密形式的用户密码。普通用户没有权限查看 */etc/master.passwd*
    的内容。然而，普通用户需要访问基本的账户信息；否则，未经授权的系统程序怎么识别用户呢？文件 */etc/passwd* 列出了用户账户，移除了所有特权信息（如加密密码）。任何人都可以查看
    */etc/passwd* 的内容以获取基本的账户信息。
- en: Many programs need account information, and parsing a text file is notoriously
    slow. In this day of laptop supercomputers, the word *slow* isn’t very meaningful,
    but this was a very real problem back when disco freely roamed the earth. For
    that reason, BSD-derived systems build a database file out of */etc/master.passwd*
    and */etc/passwd*. (Other Unix-like systems have similar functionality in different
    files.) The file */etc/spwd.db* is taken directly from */etc/master.passwd* and
    contains sensitive user information, but it can be read only by root. The file
    */etc/pwd.db* can be read by anyone, but it contains the limited subset of information
    contained in */etc/passwd*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序需要账户信息，而解析文本文件非常缓慢。在如今笔记本超级计算机的时代，*缓慢* 这个词不再那么有意义，但在迪斯科风靡一时的年代，这确实是一个非常实际的问题。正因如此，BSD
    衍生的系统将 */etc/master.passwd* 和 */etc/passwd* 构建为一个数据库文件。（其他类 Unix 系统在不同的文件中有类似的功能。）文件
    */etc/spwd.db* 直接来自 */etc/master.passwd*，并包含敏感的用户信息，但只有 root 可以读取。文件 */etc/pwd.db*
    则可以被任何人读取，但它只包含 */etc/passwd* 中的有限信息。
- en: Any time any standard user management program changes the account information
    in */etc/master.passwd*, FreeBSD runs pwd_mkdb(8) to update the other three files.
    For example, the three programs passwd(1), chpass(1), and vipw(8) all allow you
    to make changes to the master password file, and all three programs trigger pwd_mkdb
    to update the related files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每当任何标准的用户管理程序更改 */etc/master.passwd* 中的账户信息时，FreeBSD 会运行 pwd_mkdb(8) 来更新其他三个文件。例如，三个程序
    passwd(1)、chpass(1) 和 vipw(8) 都允许你修改主密码文件，并且这三个程序都会触发 pwd_mkdb 来更新相关文件。
- en: '**Changing a Password**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更改密码**'
- en: Use passwd(1) to change passwords. A user can change his own password, and root
    can change anyone’s password. To change your own password, just enter `passwd`
    at the command prompt.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 passwd(1) 来更改密码。用户可以更改自己的密码，而 root 用户可以更改任何人的密码。要更改自己的密码，只需在命令提示符下输入 `passwd`。
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When changing your own password, passwd(1) first asks for your current password.
    This is to ensure that nobody else can change your password without your knowledge.
    It’s always good to log out when you walk away from your terminal, but when you
    don’t, this simple check in passwd(1) prevents practical jokers from really annoying
    you. Then enter your new password twice, and it’s done. When you’re the superuser
    and want to change another user’s password, just give the username as an argument
    to passwd.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改自己的密码时，passwd(1) 会首先要求输入当前密码。这是为了确保没有其他人可以在你不知情的情况下更改你的密码。虽然走开时注销总是个好习惯，但当你没有注销时，passwd(1)
    中的这个简单检查可以防止恶作剧者真正让你烦恼。然后输入两次新密码，操作就完成了。当你是超级用户并且想更改其他用户的密码时，只需在 passwd 后给出用户名作为参数。
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that root doesn’t need to know the user’s old password; the root user can
    change any user account on the system in any manner desired.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，root 用户不需要知道用户的旧密码；root 用户可以以任何方式更改系统中的任何用户账户。
- en: '**USER MANAGEMENT AND $EDITOR**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户管理与 $EDITOR**'
- en: User management tools such as chpass and vipw (as well as many other system
    management tools) bring up a text editor window where you make your changes. These
    tools generally check the environment variable `$EDITOR` to see which text editor
    you prefer. `$EDITOR` lets you default to vi, Emacs, or any other editor installed.
    I recommend Vigor, a vi(1) clone with an animated-paperclip help system that might
    make users of older Microsoft Office versions feel more comfortable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 像chpass和vipw这样的用户管理工具（以及许多其他系统管理工具）会弹出一个文本编辑器窗口，让你进行修改。这些工具通常会检查环境变量`$EDITOR`，以查看你偏好的文本编辑器。`$EDITOR`允许你默认使用vi、Emacs或其他已安装的编辑器。我推荐Vigor，它是vi(1)的一个克隆，具有动画回形针帮助系统，这可能会让习惯使用老版Microsoft
    Office的用户感到更舒适。
- en: '**Changing Accounts with chpass(1)**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用chpass(1)更改账户**'
- en: 'The account has more information associated with it than just the password.
    The chpass(1) utility lets users edit everything they can reach in their account.
    For example, if I run chpass(1) as a regular user, I get an editor with the following
    text:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 账户除了密码外，还有更多关联的信息。chpass(1)工具允许用户编辑他们能接触到的账户信息。例如，如果我以普通用户身份运行chpass(1)，我会看到一个编辑器，里面包含以下内容：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I’m allowed to edit six informational fields in my account. The first, my shell,
    can be set to any shell listed in */etc/shells* (see “[Shells and */etc/shells*](ch09.xhtml#lev282)”
    on [page 178](ch09.xhtml#page_178)). I can change my full name; perhaps I want
    my full middle name listed, or maybe I wish to be known to other system users
    as *Mr. Scabies*. I can update my office location and office phone so my coworkers
    can find me easily. This is another feature that was very useful on the university
    campuses where BSD grew up and where system users rarely had an idea of anyone’s
    physical location. Now that we have extensive online directories and many more
    computers, it’s less useful. I generally set my home phone number to 911 (999
    in the UK), and I put a little bit of personal information in the `Other` space.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以编辑账户中的六个信息字段。第一个是我的shell，可以设置为*/etc/shells*中列出的任何shell（参见 “[Shells 和 */etc/shells*](ch09.xhtml#lev282)”
    [第178页](ch09.xhtml#page_178)）。我可以更改我的全名；也许我想列出我的全名中的中间名，或者可能我希望其他系统用户称我为*斯卡比斯先生*。我还可以更新我的办公位置和办公电话，以便同事们能轻松找到我。这是BSD在大学校园中发展时非常有用的功能，那时系统用户很少知道彼此的物理位置。现在我们有了广泛的在线目录和更多的计算机，这个功能就不那么有用了。我通常将我的家庭电话号码设置为911（在英国为999），并在`其他`字段中填写一些个人信息。
- en: Also note what I *can’t* change as a regular user. The sysadmin sets my home
    directory, and I may not change it even if the system has a new hard drive with
    lots of empty space for my MP3 collection. My UID and GID numbers, similarly,
    are assigned by the system or the sysadmin.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，作为普通用户，我*无法*更改的内容。系统管理员设置了我的主目录，即使系统有一块新硬盘，空间足够存放我的MP3收藏，我也不能更改它。我的UID和GID号也类似，是由系统或系统管理员分配的。
- en: On the other hand, if I run `chpass xistence`, its heightened privileges give
    me a very different view.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我运行`chpass xistence`，其提升的权限给了我一个完全不同的视角。
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As root, you can do anything you like to the poor user. Changing his login to
    *megaloser* is only the start of the havoc you can wreak. You even get access
    to the user’s hashed password ➊. Don’t alter this field, unless you’re comfortable
    computing password hashes. Use passwd(1) to more safely and reliably change the
    user’s password. You can also change the user’s home directory, although chpass(1)
    doesn’t move the user’s files; you must copy them by hand.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为root，你可以对那个可怜的用户做任何你想做的事情。将他的登录名改为*megaloser*只是你能制造的混乱的开始。你甚至可以访问该用户的哈希密码
    ➊。除非你擅长计算密码哈希，否则不要修改这个字段。使用passwd(1)来更安全、更可靠地更改用户的密码。你也可以更改用户的主目录，尽管chpass(1)不会移动用户的文件；你必须手动复制它们。
- en: You can also set a date for password changes and account expiration. Password
    expiration is useful if you’ve just changed a user’s password and you want him
    to change it upon his first login. Account expiration is useful when someone asks
    for an account but insists it’s needed only for a limited time. You can forget
    to go back to delete that account, but FreeBSD never forgets. Both of these fields
    take a date in the form *month day year*, but you need only the first three letters
    of the month. For example, to make a user’s password expire on June 8, 2028, I
    would enter `Jun 8 2028` in the `Change` space. Once the user changes his password,
    the password expiration field is blanked out again, but only the system administrator
    can extend an account expiration date.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '**The Big Hammer: vipw(8)**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While chpass(1) is fine for editing individual accounts, what happens when you
    must edit many accounts? Suppose your system has hundreds of users and a brand
    new hard disk for the home partition. Do you really want to run chpass(1) hundreds
    of times? That’s where vipw(8) comes in.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Directly edit */etc/master.passwd* with vipw(8). When you finish your edits,
    vipw(8) checks the password file’s syntax to be sure you haven’t ruined anything.
    Then, it saves the new password file and runs pwd_mkdb(8). Although vipw(8) can
    protect your password file from many basic mistakes, if you’re clever, you can
    still muck things up. You must understand the format of the password file to use
    vipw(8) properly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: If the information in */etc/master.passwd* conflicts with information in other
    files, */etc/master.passwd* wins. For example, the primary group that appears
    in */etc/master.passwd* is correct, even if */etc/group* doesn’t show the user
    as a member. This “*master.passwd* is always correct” logic is deeply ingrained
    throughout user management.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line in */etc/master.passwd* is a single account record, containing 10
    colon-separated fields. These fields are the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '**Username**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: This field is either an account name created by the sysadmin or a username created
    at install time to provide some system service. FreeBSD includes users for system
    administration, such as root, daemon, games, and so on. Each of these users owns
    a part of the base system. FreeBSD also provides accounts for common services,
    such as the *www* user reserved for use by web servers. Add-on software might
    add its own system accounts as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**Encrypted Password**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The second field is the encrypted password. System users don’t have a password,
    so you can’t log in as one of them. User accounts have a string of random-looking
    characters here.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**User ID**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The third field is the *user ID number*, or *UID*. Every user has a unique UID.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**Group ID**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the fourth field is the *group ID number*, or *GID*. This is the
    user’s primary group. Usually this is identical to the UID, and the group has
    the same name as the username.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**User’s Class**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The next field is the user’s class as defined in */etc/login.conf* (see “[Restricting
    System Usage](ch09.xhtml#lev300)” on [page 188](ch09.xhtml#page_188)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Password Expiration**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: This field is the same as the password expiration date set via chpass(1), but
    here the time gets stored as seconds from the epoch. Use `date -j` and the `+%s`
    output format to generate epochal seconds from a real date. To convert midnight,
    June 1, 2018, to epochal seconds, run `date -j 201806010000 '+%s'`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**Account Expiration**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: This field enables you to make the account shut itself off on a certain day.
    Just set the account expiration date as you would for password expiration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**Personal Data**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: This field is also known as the *gecos* field for obscure historical reasons.
    It contains the user’s real name, office number, work phone number, and home phone
    number, all separated by commas. Do not use colons in this field; */etc/master.passwd*
    reserves colons as a field delimiter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**User’s Home Directory**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The ninth field is the user’s home directory. While this defaults to */home/<username>*,
    you can move this anywhere appropriate. You’ll also need to move the actual home
    directory and its files when you change this field. Users with a nonexistent home
    directory can’t log in by default, although the `requirehome` setting in *login.conf*
    can change this.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '**User’s Shell**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The final field is the user’s shell. If this field is empty, the system assigns
    the user the boring old */bin/sh*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: While chpass(1) lets you muck up individual user accounts, vipw(8) unleashes
    you on the entire userbase. Be careful with it!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing a User**'
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The rmuser(8) program deletes user accounts. You’ll be prompted for the username
    you want to delete and asked whether you want to remove that user’s home directory.
    That’s really all you have to do; destruction is much easier than creation, after
    all.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Scripting with pw(8)**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The pw(8) command provides a powerful command line interface to user accounts.
    While useradd(8) walks you through setting up an account in a friendly manner,
    pw(8) lets you specify everything on a single command line. I find pw(8) cumbersome
    for day-to-day use, but if you manage many user accounts, it’s invaluable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: One thing I do use pw(8) for is locking accounts. While a locked account is
    active, nobody can log in to it. I’ve used this to great effect when a client
    was behind on a bill; users call quite quickly when they can’t log in, and yet
    their websites continue to come up and their email continues to accumulate.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When Bert apologizes, I’ll unlock his account.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you need scripts to manage your users, definitely read the pw(8) man page.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '**Shells and /etc/shells**'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *shell* is the program that provides the user’s command prompt. Different
    shells behave differently and offer different shortcuts and features. Many people
    are very attached to particular shells and complain bitterly if their shell isn’t
    available on a system. The packages collection contains many shells.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The file */etc/shells* contains a list of all legitimate user shells. When you
    install a shell from a port or a package, it adds an appropriate entry in */etc/shells*.
    If you compile your own shell from source, without using a FreeBSD port, you must
    list the shell by its complete path in */etc/shells*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The FTP daemon won’t allow a user to log in via FTP if his shell isn’t listed
    in */etc/shells*. If you use */sbin/nologin* as an FTP-only user shell, you must
    add it to this file, although a better way to handle such users is with login
    classes, as discussed later in this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**root, Groups, and Management**'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unix security has been considered somewhat coarse because one superuser, *root*,
    can do anything. Other users are lowly peons who endure the shackles root places
    upon them. The problem is, root doesn’t have a wide variety of shackles on hand
    and can’t individualize them very well. While there’s some truth to this, a decent
    administrator can combine groups and permissions to handle almost any problem
    securely.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '***The root Password***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Certain actions require absolute control of the system, including manipulating
    core system files such as the kernel, device drivers, and authentication systems.
    Such activities are designed to be performed by root.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the root password, you can either log in as root at a console login
    prompt or, if you’re a member of the group wheel, log in as yourself and use the
    switch user command su(1). (We’ll discuss groups later in this section.) I recommend
    su; it logs who uses it and can be used on a remote system. The command is very
    simple to use:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, check your current user ID with the id(1) command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You now own the system—and I do mean *own* it. Consider every keystroke; carelessness
    can return your hard drive to the primordial state of unformatted empty wasteland.
    And share the root password sparingly, if at all, because anyone who has the root
    password can inflict unlimited damage on the system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Remember, only the users in the group *wheel* can use the root password to become
    root through su(1). Anyone can use the root password at the system console, which
    is why physical protection of your system is vital. If you give the root password
    to a regular user who doesn’t have physical access to the console, they can type
    `su` and enter the root password as many times as they want, and it still won’t
    work.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: This naturally leads to the question, “Who needs root access?” Much of the configuration
    discussed in this book requires use of the root password. Once you have the system
    running properly, you can greatly decrease or discontinue use of the root password.
    For those remaining tasks that absolutely require root privileges, I recommend
    the sudo package, and probably my book *Sudo Mastery* (Tilted Windmill Press,
    2013). One of the simplest ways to reduce the need for root access is through
    the proper use of groups.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '***Groups of Users***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unix-like operating systems classify users into *groups*, each group consisting
    of people who perform similar administrative functions. A sysadmin can define
    a group called *webmasters*, add the accounts of the people editing web pages
    to that group, and set the privileges on the web-related files so that the members
    of that group can edit those files. She can also create a group called *email*,
    add the email administrators to that group, and set the permissions of mail-related
    files accordingly. Using groups in this manner is a powerful and oft-neglected
    tool for system management.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Any user can identify the groups she belongs to with id(1). The preceding example
    showed that the user root is in the groups wheel and operator. Root is a special
    user, however, and can do anything she pleases. Here’s my account, which is a
    little more realistic for an average user:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'My UID is 1001, and my username is *mwlucas*. My GID, primary group ID, is
    1001, and my primary group is named *mwlucas* as well. This is all pretty standard
    for the first user on a system, and even in later users, the only thing that changes
    is the numbers assigned to the account and primary group. More interesting is
    what other groups I’m assigned to: in addition to my primary group, I’m in the
    groups wheel, dialer, and webmaster. Wheel members may use the root password to
    become root, dialer members may use tip(1) without becoming root, and webmaster
    members can edit the web files on the local system. Each of these groups has special
    privileges on my system, and as a member of those groups, I inherit those privileges.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Group information is defined in */etc/group*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**/etc/group**'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The file */etc/group* contains all group information except for the user’s
    primary group (which is defined with the user account in */etc/master.passwd*).
    Each line in */etc/group* contains four colon-delimited fields: the group name,
    the group password, the group ID number, and a list of members.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample entry:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The group name is a human-friendly name for the group. This group is named *wheel*.
    Group names are arbitrary; you can call a group of users *lackeys* if you wish.
    Choose group names that give you an idea of what the groups are for; while you
    might remember that your lackeys may edit the company web page, will your coworkers
    understand that?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The second field, the group password, was a great idea that turned out to be
    a security nightmare. Modern Unix-like systems don’t do anything with the group
    password, but the field remains because old programs expect to find something
    in this space. The asterisk is a placeholder to placate such software.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The third field gives the group’s unique numeric group ID (GID). Many programs
    use the GID rather than name to identify a group. The wheel group has a GID of
    0, and the maximum GID is 65535.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Last is a comma-delimited list of all users in the group. The users *root*,
    *mwlucas*, and *xistence* are members of the group wheel.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing Group Memberships**'
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you want to add a user to a group, add his username to the end of the line
    for that group. For example, the wheel group is the list of users that may use
    the root password. Here, I add *rwatson* to the wheel group:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Mind you, the odds of me convincing rwatson (leading security researcher and
    ex–FreeBSD Foundation President) to assume sysadmin duties on any of my systems
    range from negligible to nonexistent, but it’s worth a try.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Groups**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To create a new group, you need only a name for the group and a group ID number.
    Technically, you don’t even need a member for the group; some programs run as
    members of a group, and FreeBSD uses the group permissions to control those programs
    just as the users are controlled.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, GIDs are assigned the next number up the list. GID is an arbitrary
    number between 0 and 65535\. Generally speaking, GIDs below 1000 are reserved
    for operating system usage. Programs that need a dedicated group ID usually use
    one in this range. User accounts start numbering their GIDs at 1001 and go up.
    Some special groups might start numbering at 65535 and go down.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Groups to Avoid Root***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to being a security concern, the root password distribution policy
    can cause dissension in any organization. Many sysadmins refuse to share the root
    password with people who’re responsible for maintaining part of the system but
    don’t offer an alternative and thereby prevent people from doing their job. Other
    sysadmins hand out root to dang near anyone who wants it and then complain when
    the system becomes unstable. Both attitudes are untenable in the long run. Personally,
    I don’t want root on your system. While having root privileges can be convenient,
    a lack of responsibility when the system breaks is more convenient.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: One common situation is where a junior sysadmin is responsible for a particular
    portion of the system. I’ve had many DNS administrators work under me;^([2](footnote.xhtml#ch09fn2))
    these people don’t ever install software, recompile the kernel, or perform other
    sysadmin tasks. They only answer emails, update zone files, and reload the named
    daemon. New sysadmins often believe they need root access to do this sort of work.
    Nope. You can use groups.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Establishing your own groups, consisting of people who perform similar administrative
    functions, lets you avoid distributing the root password and still allow people
    to do their work. In this section, we’ll implement group-level access control
    over nameserver files. The same principles apply to any files you choose to protect.
    Mail and web configuration files are other popular choices for group-based management.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**System Accounts**'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: FreeBSD reserves some user account names for integrated programs. We discuss
    these unprivileged accounts in [Chapter 19](ch19.xhtml#ch19). For example, the
    nameserver runs under the user account bind and the group bind. If an intruder
    compromises the nameserver, she can access the system only with the privileges
    of the user bind.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Don’t have users log in as these users. They’re not set up as interactive accounts
    by design. What’s more, do not allow the group of the system account user to own
    the files created for that function. Create a separate user and group to own program
    files. That way, our hypothetical intruder can’t even edit the files used by the
    DNS server, further minimizing potential damage. If the program regularly updates
    the files (e.g., a database’s backend storage), you must give the program access
    rights, but chances are that a human being doesn’t ever need to edit that file.
    Similarly, there’s no reason a database should be able to edit its own configuration
    file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**Administrative Group Creation**'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The simplest way to create a group that owns files is to employ adduser(8) to
    make a user that owns them and then to utilize that user’s primary group as the
    group for the files. Because we already have a user called *bind*, we’ll create
    an administrative user *dns*. The username isn’t important, but you should choose
    a name that everyone will recognize.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Give your administrative user a shell of *nologin*, which sets a shell of */sbin/nologin*.
    This prevents anyone from actually logging in as the administrative user.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you could specify a particular UID and GID for these sorts of users.
    I’ve been known to choose UID and GID numbers that resemble those used by their
    related service accounts. For example, the user bind has a UID and GID of 53\.
    I could give the user dns a UID of 10053 to make it easily recognizable. At other
    times, I start numbering my administrative groups at 65535 and work my way down.
    It doesn’t matter as long as I’m completely consistent within an organization.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Do not add this administrative user to any other groups. Under no circumstances
    add this user to a privileged group, such as wheel!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Every user needs a home directory. For an administrative user, a home directory
    of */nonexistent* works well. This user’s files are elsewhere in the system, after
    all.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let adduser(8) disable the account. While the shell prevents logins,
    an extra layer of defense won’t hurt.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an administrative user and a group, you can assign ownership
    of files to that user. A user and a group own every file. You can see existing
    file ownership and permissions with `ls -l`. (If you’ve forgotten how Unix permissions
    work, read ls(1) and chmod(1).) Many sysadmins pay close attention to file owners,
    somewhat less attention to worldwide permissions, and only glance at the group
    permissions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, I’ve created two files. The first file, *rndc.key*, can be read and written
    by the user *mwlucas*. It can be read by anyone in the group *mwlucas*, but no
    one else can do anything with it. The file *mwl.io.db* can be read or written
    by the user *mwlucas* or anyone in the group *mwlucas*, but others can only read
    the file. If you’re in the group *mwlucas*, you can edit the file *mwl.io.db*
    without becoming root.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Change a file’s owner and group with chown(1). You must know the name of the
    user and group whose ownership you want to change. In this case, we want to change
    both files to be owned by the user dns and the group dns.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These files are now owned by the user dns and the group dns. Anyone who is in
    the group dns can edit *mwl.io.db* without using the root password. Finally, this
    file can be read by the user bind, who runs the nameserver. Add your DNS administrators
    to the dns group in */etc/group*, and abruptly they can do their jobs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The DNS administrators might think they need the root password for restarting
    the nameserver program itself. However, this is easily managed with rndc(8). Other
    tasks can be managed with cron jobs or with the add-on program sudo(8).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want an administrative user but only a group, use vigr(8) to edit
    */etc/group*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**Interesting Default Groups**'
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: FreeBSD ships with several default groups. Most are used by the system and aren’t
    of huge concern to a sysadmin—you should know that they’re there, but that’s different
    than working with them on a day-to-day basis. In [Table 9-1](ch09.xhtml#ch09tab1),
    I present for your amusement and edification the most useful, interesting, and
    curious of the default groups. Adding your own groups simplifies system administration,
    but the groups listed here are available on every FreeBSD system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** FreeBSD System Groups'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '| **Group name** | **Purpose** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| audit | Users who can access audit(8) information |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| authpf | Users who can authenticate to the PF packet filter |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| bin | Group owner of general system programs |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| bind | Group for the BIND DNS server software |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| daemon | Used by various system services, such as the printing system |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| _dhcp | DHCP client operations |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| dialer | Users who can access serial ports; useful for modems and tip(1)
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| games | Owner of game files |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| guest | System guests (almost never used) |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| hast | Files used by hastd(8) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| kmem | Programs that can access kernel memory, such as fstat(1), netstat(1),
    and so on |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| mail | Owner of the mail system |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| mailnull | Default group for sendmail(8) or other mail server |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| man | Owner of uncompressed man pages |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| network | Owner of network programs like ppp(8) |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| news | Owner of the Usenet News software (probably not installed) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| nobody | Primary group for unprivileged user nobody, intended for use by
    NFS |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| nogroup | Group with no privileges, intended for use by NFS |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| operator | Users that can access drives, generally for backup purposes |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| _pflogd | Group for PF logging |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| proxy | Group for FTP proxy in PF packet filter |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| smmsp | Group for Sendmail submissions |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| sshd | Owner of the SSH server (see [Chapter 20](ch20.xhtml#ch20)) |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| staff | System administrators (from BSD’s college roots, when users were
    staff, faculty, or students) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| sys | Another system group |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| tty | Programs that can write to terminals, like wall(1) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| unbound | Files and programs related to the unbound(8) DNS server |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| uucp | Group for programs related to the Unix-to-Unix Copy Protocol |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| video | Group that can access DRM and DRI video devices |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| wheel | Users who may use the root password |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| www | Web server programs (not files) |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| _ypldap | Files needed by the LDAP-backed YP server ypldap(8) |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: I know very few people using either internet news or UUCP, and you might think
    you could reuse those groups for other purposes. You’re really better off creating
    a new group than risking confusion later, however. Group ID numbers are not in
    short supply.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**Tweaking User Security**'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You prevent any single user from utilizing too much memory, processor time,
    or other system resources by setting limits on the account. Now that even small
    computers have very fast processors and lots of memory, these limits aren’t as
    important, but it’s still very useful in systems with dozens or hundreds of users.
    You can also control where users may log in from.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '***Restricting Login Ability***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FreeBSD checks */etc/login.access* every time a user tries to log in. If *login.access*
    contains rules that forbid logins from that user, the login attempt fails immediately.
    This file has no rules by default, meaning that anyone who provides a valid username
    and password has no restrictions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The */etc/login.access* file has three colon-delimited fields. The first either
    grants (`+`) or denies (`-`) the right to log in; the second is a list of users
    or groups; and the third is a list of connection sources. You can use an `ALL`
    or `ALL EXCEPT` syntax, which allows you to make simple but expressive rules.
    Rules are checked on a first-fit basis. When login(1) finds a rule where the user
    and the connection source match, the connection is immediately accepted or rejected,
    making rule order vital. The default is to allow logins.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to allow only members of the wheel group to log in from the system
    console, you might try this rule:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The problem with this rule, however, is that it doesn’t actually deny users
    login privileges. Since the default is to accept logins, and since all this rule
    does is explicitly grant login privileges to the users in the wheel group, nothing
    changes. Bert certainly isn’t in the wheel group, but if he tries to log in, no
    rule denies him access.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'You could try two rules like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This set of rules would achieve the desired effect but is longer than you need.
    Use `ALL EXCEPT` instead.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This rule rejects unwanted logins most quickly and runs less risk of administrator
    error. As a rule, it’s best to build *login.access* lists by rejecting logins,
    rather than permitting them. FreeBSD immediately rejects nonwheel users at the
    console upon hitting this rule.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Change the default from “allow access” to “deny access” by adding a final rule.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Any login request that doesn’t match an earlier permit rule gets denied.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The last field in *login.access*, the connection source, can use hostnames,
    host addresses, network numbers, domain names, or the special values `LOCAL` and
    `ALL`. Let’s see how they work.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**Hostnames**'
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Hostnames rely upon DNS or the hosts file. If you suspect that your nameserver
    might suffer an intrusion or attack, avoid hostnames; intruders can give a hostname
    any IP address that they like and fool your system into accepting the connection,
    and a nameserver failure could lock you out completely. Still, it’s possible to
    use a rule like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Users in the wheel group can log in from the fileserver, but nobody else can.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '**Host Addresses and Networks**'
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Host addresses work like hostnames, but they’re immune to DNS failures or spoofing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A network number is a truncated IP address, like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This network number allows anyone in the wheel group to log in from a machine
    whose IP address begins with 203.0.113 and denies everyone else access from those
    IP addresses.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '**LOCAL**'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The most complicated location is `LOCAL`, which matches any hostname without
    a dot in it (generally, only hosts in the local domain). For example, *[www.mwl.io](http://www.mwl.io)*
    thinks that any machine in the domain *mwl.io* matches `LOCAL`. DNS spoofing can
    easily evade this filter. Although my desktop claims that it has a hostname of
    *storm.mwl.io*, its IP address has reverse DNS that claims it’s somewhere in my
    cable modem provider’s network. The host *[www.mwl.io](http://www.mwl.io)* thinks
    that my desktop isn’t in the same domain and hence isn’t local. As such, I can’t
    use the `LOCAL` verification method.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, anyone who owns a block of IP addresses can give their addresses
    any desired reverse DNS. The `LOCAL` restriction is best avoided.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**ALL and ALL EXCEPT**'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`ALL` matches everything, and `ALL EXCEPT` matches everything but what you
    specify. These are the most useful connection sources, in my opinion. For example,
    if you had a highly secure machine only accessible from a couple of management
    workstations, you could have a rule like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Tie It All Together**'
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The point of these rules is to build a login policy that matches your real-world
    policies. If you provide generic services but only allow your system administrators
    to log on remotely, a one-line *login.access* prevents any other users from logging
    in:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is great if you can live with a restriction this tight. On the other hand,
    I’ve worked at several internet service providers that used FreeBSD to provide
    client services. Lowly customers weren’t allowed to log onto the servers unless
    they had a shell account. System administrators could log in remotely, as could
    the DNS and web teams (members of the dns and webmasters groups). Only sysadmins
    could log onto the console, however.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Set this up in *login.access* once, and let group membership control all of
    your remote logins forever after.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '***Restricting System Usage***'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can provide more specific controls with login classes. Login classes, managed
    through */etc/login.conf*, define the resources and information provided for users.
    Each user is assigned a class, and each class has limits on the system resources
    available. When you change the limits on a class, all users get the new limits
    when they next log in. Set a user’s class when creating the user account, or change
    it later with chpass(1).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**Class Definitions**'
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The default *login.conf* starts with the default class, the class used by accounts
    without any other class. This class gives the user basically unlimited access
    to system resources and is suitable for application servers with a limited number
    of users. If this meets your needs, don’t adjust the file at all.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Each class definition consists of a series of variable assignments that define
    the user’s resource limits, accounting, and environment. Each variable assignment
    in the class definition begins and ends with a colon. The backslash character
    is a continuation character to indicate that the class continues on the next line,
    which makes the file more readable. Here’s a sample of the beginning of one class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This class is called `default` ➊. I’ve shown three of the dozens of variables
    in this class. The variable `passwd_format` ➋, for example, is set to `sha512`
    ➌. These variable assignments and the class name describe the class, and you can
    change the user’s experience on the system by assigning the user to another class.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Some of *login.conf* ’s variables don’t have a value and instead change account
    behavior just by being present. For example, the `requirehome` variable takes
    effect just by being included in the class. If this value is present, the user
    must have a valid home directory.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After editing *login.conf*, you must update the login database to make the changes
    take effect.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This rebuilds the database file */etc/login.conf.db* that’s used for fast lookups,
    much like */etc/spwd.db*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The default */etc/login.conf* includes several example classes of users. If
    you want an idea of what sort of restrictions to put on users for various situations,
    check those examples. The following section offers ideas about what can be set
    in a login class. For a complete listing of supported settings in your version
    of FreeBSD, read man login.conf(5).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource Limits**'
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Resource limits allow you to control how much of the system any one user can
    monopolize at any one time. If you have several hundred users logged in to one
    machine and one of those users decides to compile LibreOffice, that person will
    consume far more than his fair share of processor time, memory, and I/O. By limiting
    the resources one user can monopolize, you can make the system more responsive
    for all users.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-2 defines the resource-limiting *login.conf* variables.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2:** Some *login.conf* Variables for Limiting Resource Use'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable** | **Description** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| `cputime` | The maximum CPU time any one process may use |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: '| `filesize` | The maximum size of any one file |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
- en: '| `datasize` | The maximum memory size of data that can be consumed by one
    process |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: '| `stacksize` | The maximum amount of stack memory usable by a process |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| `coredumpsize` | The maximum size of a core dump |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| `memoryuse` | The maximum amount of memory a process can lock |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '| `maxproc` | The maximum number of processes the user can have running |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| `openfiles` | The maximum number of open files per process |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| `Sbsize` | The maximum socket buffer size a user’s application can set |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: Note that resource limits are frequently set per process. If you permit each
    process 200MB of RAM and allow each user 40 processes, you’ve just allowed each
    user about 8GB of memory. Perhaps your system has a lot of memory, but does it
    really have that much?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '**Current and Maximum Resource Limits**'
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In addition to the limits listed previously, you can specify current and maximum
    resource limits. *Current* limits are advisory, and the user can override them
    at will. This works well on a cooperative system, where multiple users willingly
    share resources but you want to notify those users who exceed the standard resource
    allocation. Many users want to be good citizens, and readily cooperate when they’re
    told they’re pushing their limits.^([3](footnote.xhtml#ch09fn3)) Users cannot
    exceed *maximum* limits.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t specify a limit as current or maximum, FreeBSD treats it as a maximum
    limit.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a current limit, add `-cur` to the variable name. To make a maximum
    limit, add `-max`. For example, to set a current and a maximum limit on the number
    of processes the user can have, use this input:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: One counterpart to resource limits is resource accounting. These days, accounting
    isn’t as important as it was when today’s inexpensive computers would cost millions
    of dollars, so we won’t discuss it in this book. It’s more important to restrict
    a single user from consuming your system than to bill for every CPU cycle someone
    uses. You should know that the capability exists, however.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: If you need more complicated resource restrictions, investigate rctl(8).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**Class Environment**'
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can also define environment settings in */etc/login.conf*. This can work
    better than setting them in the default *.cshrc* or *.profile* because *login.conf*
    settings affect all user accounts immediately upon their next login. Some shells,
    such as zsh(1), don’t read either of these configuration files, so using a class
    environment sets the proper environment variables for those users.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the environment fields recognize two special characters. A tilde (`~`)
    represents the user’s home directory, while a cash symbol (`$`) represents the
    username. Here are a few examples from the default class that illustrate this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: By using the `$` character, the environment variable `MAIL` is set to */var/mail/<username>*
    ➊. Similarly, the last directory in the `PATH` variable is the *bin* subdirectory
    in the user’s home directory ➋.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-3 lists some common *login.conf* environment settings.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-3:** Common *login.conf* Environment Settings'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable** | **Description** |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| `hushlogin` | If present, no system information is given out during login.
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| `ignorenologin` | If present, these users can log in even when */var/run/nologin*
    exists. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| `manpath` | A list of directories for the `$MANPATH` environment variable.
    |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| `nologin` | If present, the user cannot log in. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| `path` | A list of directories for the `$PATH` environment variable. |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| `priority` | Priority (nice) for the user’s processes (see [Chapter 21](ch21.xhtml#ch21)).
    |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| `requirehome` | User must have a valid home directory to log in. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| `setenv` | A comma-separated list of environment variables and their values.
    |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| `shell` | The full path of a shell to be executed upon login. This overrides
    the shell in */etc/master.passwd*. The user’s `$SHELL`, however, contains the
    shell from the password file, resulting in an inconsistent environment. Playing
    games with this is an excellent way to annoy your users. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| `term` | The default terminal type. Just about anything that tries to set
    a terminal type overrides this. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| `timezone` | The default value of the `$TZ` environment variable. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| `umask` | Initial umask setting; should always start with 0, see builtin(1).
    |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| `welcome` | Path to the login welcome message, usually */etc/motd*. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: Remember, changes to a class affect all users in that class. If a user needs
    a change from the class settings, you’ll need to change their class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '**Password and Login Control**'
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Unlike the environment settings, many of which can be set in places other than
    the login class, most login and authentication options can be controlled only
    from the login class. Here are some common authentication options:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: passwd_format
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: This option sets the cryptographic hash used to store passwords in */etc/master.passwd*.
    The default is `sha512`, for SHA512 hashing. Other permissible options are `des`
    (DES), `blf` (Blowfish), `md5`, and `sha256` (SHA256). DES and Blowfish are most
    useful when you want to share password files between different Unix-like operating
    systems, but are very weak. SHA256 is for compatibility with older password files,
    from before SHA512 was the default.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: mixpasswordcase
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: If present, FreeBSD complains if the user changes his password to an all-lowercase
    word. Despite the name, all-uppercase passwords satisfy this option.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: host.allow, host.deny
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: These values let users in this class use rlogin and rsh. Avoid them like the
    fuzzy green meat your creepy roommate tried to feed you that one time.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: times.allow
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'This option allows you to schedule when users may log in with a comma-delimited
    list of days and times. Days are given as the first two letters of the day’s name
    (Su, Mo, Tu, We, Th, Fr, and Sa). Time is in standard 24-hour format. For example,
    if a user can log in only on Wednesdays between 8 AM and 5 PM, you’d use this
    entry:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: times.deny
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: This option allows you to specify a time window when the user can’t log in.
    Note that this does not kick off users who are already logged in. The format is
    the same as for `times.allow`. If `times.allow` and `times.deny` overlap, `times.deny`
    takes precedence.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: You can’t make that overworking developer go home, but you can keep him from
    opening another terminal window.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '**File Flags**'
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All Unix-like operating systems have the same filesystem permissions, assigning
    read, write, and execute privileges for a file to the file’s owner, its group,
    and all others. FreeBSD extends the permissions scheme with *file flags*, which
    work with permissions to enhance your system’s security.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Many flags have different effects depending on the system securelevel, which
    we’ll cover in the next section. Understanding securelevels requires an understanding
    of file flags, while file flags rely on securelevels. For the moment, just nod
    and smile when you encounter a mention of securelevels; all becomes clear in the
    next few pages.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: A few file flags are useful only in specialized cases. We’ll look only at the
    most commonly useful flags. See chflags(1) for the complete list.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Many flags have multiple names; while only one name appears in ls(1) output,
    you can use any name at the command line. These alternate names exist because
    people got tired of getting an error when they typed `sapp`e`nd` instead of `sappnd`.
    Here, I show the flag’s primary name first and then the user-friendly aliases.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: sappnd, sappend
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: This system-level, append-only flag can be set only by root. Files with this
    flag can be added to but can’t be removed or otherwise edited. This flag is particularly
    useful for log files. Setting `sappnd` on a user’s *.history* file can be interesting
    if the account is compromised. Since a common intruder tactic is to remove *.history*
    or symlink it to */dev/null* so that the admin can’t see what happened, `sappnd`
    ensures that script kiddies cannot cover their tracks in this manner. It’s almost
    funny to review the record of someone trying to remove a `sappnd` file; you can
    almost see the attacker’s frustration grow as he tries various methods.^([4](footnote.xhtml#ch09fn4))
    This flag can’t be removed when the system is running at securelevel 1 or higher.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: schg
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Only root can set the system-level immutable flag. Files with this flag set
    can’t be changed in any way. They can’t be edited, moved, replaced, or overwritten.
    Basically, the filesystem itself prevents all attempts to alter this file. The
    flag can’t be removed when the system is running at securelevel 1 or greater.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: sunlnk
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Only root can set the system-level undeletable flag on a file. The file can
    be edited or altered, but it can’t be deleted. This isn’t as secure as the previous
    two flags because if a file can be edited, it can be emptied. It’s still useful
    for certain circumstances, however. I’ve used it when a program insisted on deleting
    its own log files upon a crash. It’s not generally useful to set on any standard
    system files, however. This flag can’t be removed when the system is running at
    securelevel 1 or higher.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: uappnd
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: This user-level, append-only flag can be set only by the file owner or root.
    Like the system-level append-only flag `sappnd`, a file with this flag set can
    be added to but not otherwise edited or removed. This flag is most useful for
    logs from personal programs and the like; it’s primarily a means to let users
    prevent accidental removal of their own files. The owner or root can remove this
    flag.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: uchg
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: This user-level, immutable flag can be set only by the owner or root. Like the
    `schg` flag, this immutable flag prevents anyone from changing the file. Again,
    root can override this, and it can be disabled by the user at any securelevel.
    This flag helps prevent mistakes, but it’s not a way to secure your system.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: uunlnk
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: This user-level, undeletable flag can be set only by the owner or root. A file
    with this flag set can’t be deleted by the owner. Root can override that, and
    the user can turn this flag off at any time, making this mostly useless.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting and Viewing File Flags***'
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Set flags with chflags(1). For example, to be sure that nothing replaces a
    server’s kernel, you could do this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You’d need to remove this flag to perform system updates.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'You can recursively change the flags on an entire directory tree with the `-R`
    flag. For example, to make all of */bin* directory immutable, run this command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And boom! Your basic system binaries can’t be changed.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: To see what flags are set on a file, use `ls -lo`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `sappnd` entry tells us that the system append-only flag is set on this
    log. For comparison, if a file has no flags set, it looks like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The hyphen in place of the flag name tells us that no flag has been set.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: An out-of-the-box FreeBSD install doesn’t have many files marked with flags,
    but you can flag anything you want. On one system that I fully expected to be
    hacked, I went berserk with `chflags -R schg` in various system directories to
    prevent anyone from replacing system binaries with trojaned versions. It might
    not stop an attacker from getting in, but imagining their frustration improved
    my mood.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a file flag, use `chflags` and a `no` in front of the flag name.
    For example, to unset the `schg` flag on your kernel, enter this command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That said, you must be running at securelevel –1 to unset many flags. So, without
    further ado, let’s discuss securelevels and what they mean to you.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '**Securelevels**'
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Securelevels are kernel settings that change basic system behavior to disallow
    certain actions. The kernel behaves slightly differently as you raise the securelevel.
    For example, at low securelevels, file flags can be removed. A file might be flagged
    immutable—but you can remove the flag, edit the file, and reflag it. When you
    increase the securelevel, the file flag can’t be removed. Similar changes take
    place in other parts of the system. Taken as a whole, the behavior changes that
    result from increased securelevels either frustrate or stop an intruder. Enable
    securelevels at boot with the *rc.conf* option `kern_securelevel_enable="YES"`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Securelevels complicate system maintenance by imposing restrictions on your
    behavior. After all, many system administration tasks are also things intruders
    might do to cover their tracks. For example, at certain securelevels, you can’t
    format or mount new hard drives while the system is running. On the other hand,
    securelevels hamper intruders even more than they hamper you.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '***Securelevel Definitions***'
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Securelevels come in 5 degrees: –1, 0, 1, 2, and 3, with –1 being the lowest
    and 3 the highest. Once you enable securelevels with the `kern_securelevel_enable`
    *rc.conf* option, you can set the securelevel at boot with the `kern_securelevel`
    *rc.conf* variable. You can raise the securelevel at any time, not just at boot,
    but you can’t lower it without rebooting into single-user mode. After all, if
    you could lower the securelevel at any time, so could your intruder!'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The effects of each securelevel vary depending on your FreeBSD release. To get
    the latest information, read security(7).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '**Securelevel –1**'
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The default provides no additional kernel security whatsoever. If you’re learning
    FreeBSD and are frequently changing your configuration, remain at securelevel
    –1 and use the built-in file permissions and other Unix safeguards for security.
    Flags like `sappnd` and `schg` will work, but chflags(1) can easily remove the
    flags.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '**Securelevel 0**'
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Securelevel 0 is used only during booting and offers no special features over
    securelevel –1\. When the system reaches multiuser mode, however, the securelevel
    is automatically raised to 1\. Setting `kern_securelevel=0` in */etc/rc.conf*
    is effectively the same as setting `kern_securelevel=1`. Securelevel 0 is helpful
    if you have startup scripts that perform actions prohibited by securelevel 1.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '**Securelevel 1**'
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At securelevel 1, the basic secure mode, things become interesting:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: System-level file flags may not be turned off.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t load or unload kernel modules (see [Chapter 6](ch06.xhtml#ch06)).
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs can’t write directly to system memory via either */dev/mem* or */dev/kmem*.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing can access */dev/io*.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t enter the kernel debugger with the `debug.kdb.enter` sysctl.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t panic the system with the `debug.kdb.panic` sysctl.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounted disks can’t be written to directly. (You can write files to disk; you
    just can’t address the raw disk devices.)
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most obvious effect of securelevel 1 for ordinary users is that the BSD-specific
    filesystem flags can’t be altered. If a file is marked system-level immutable,
    and you want to replace it, too bad.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '**Securelevel 2**'
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Securelevel 2 has all the behaviors of securelevel 1, with two additions:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Disks can’t be opened for writing, whether mounted or not.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t alter system time by more than one second.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these seem irrelevant to new sysadmins, but they provide important security
    protections. Although Unix provides handy tools, like text editors to write files,
    it’s also possible to bypass both those tools and the actual filesystem to access
    the underlying ones and zeros on the hard drive. Poking at the hard drive lets
    you change any file regardless of the file permissions. The only time this commonly
    happens is when you install a new hard drive and must create a filesystem on it.
    Normally, only the root user can write directly to the disk in this manner. At
    securelevel 2, even root can’t use newfs(8), zpool(8), and so on.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, another old hacker trick is to change the system time, edit a file,
    and change the time back. That way, when the administrator looks for files that
    might be causing trouble, the tampered file appears to have been untouched for
    months or years and hence doesn’t seem an obvious source of concern.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '**Securelevel 3**'
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Securelevel 3 is the *network secure mode*. In addition to the settings of securelevels
    1 and 2, you can’t adjust packet filter rules. The firewall on your host is immutable.
    If you have a system with packet filtering or bandwidth management enabled and
    those rules are well tuned and unlikely to change, you can use securelevel 3.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '***Which Securelevel Do You Need?***'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The securelevel appropriate for your environment depends entirely upon your
    situation. If you’ve just put a FreeBSD machine into production and are still
    fine-tuning it, leave the securelevel at –1\. Once your system is tuned, however,
    you can raise the securelevel. Most production systems run just fine at securelevel
    2.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: If you use one of FreeBSD’s packet filtering or firewall packages, securelevel
    3 might look tempting. Be very sure of your firewall rules before you enable this,
    however! Securelevel 3 makes it impossible to change your firewall without disrupting
    your connection. Are you 100 percent certain that none of your customers will
    ever call in to say, “Here’s a check. Now give me more servers!”?
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '***What Won’t Securelevels and File Flags Accomplish?***'
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider a case where someone compromises a CGI script on your web server, uses
    that to bootstrap into a shell, and then uses the shell to bootstrap himself into
    root access.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve set the securelevel accordingly, perhaps this attacker will become
    frustrated because not only can’t she replace your kernel with her specially compiled
    one, she also can’t even load a kernel module. No problem—she can still replace
    assorted system programs with trojaned versions so that the next time you log
    in, your new version of login(1) sends your password to an anonymous web-based
    mailbox or to an internet newsgroup.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: So, to protect your key files, you run around doing `chflags schg -R /bin/*`,
    `chflags schg -R /usr/lib`, and so on. Fine. If you forget one file—say, something
    obscure like */etc/rc.bsdextended* —your intruder can edit that file to include
    `chflags -R noschg /`. She can then reboot your system late at night when you
    might not notice. How often do you sit down and exhaustively audit your */etc/rc*
    files?
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: You think that your system is safe, with every file completely protected. But
    what about */usr/local/etc/rc.d*, the local program startup directory? The system
    boot process tries to execute any executable file in this directory that contains
    a line starting with `#PROVIDE:` (see [Chapter 17](ch17.xhtml#ch17) for why).
    Your intruder could therefore do a lot of damage by placing a simple shell script
    there. After all, */etc/rc* raises the securelevel at the end of the boot process.
    What if she were to create a shell script that kills the running */etc/rc* before
    it could raise the securelevel and then she turned around and ran his own */var/.hidden/rc.rootkit*
    to finish bringing the system up?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these are only a couple of possibilities. There are others, limited
    only by your intruder’s creativity. Remember that system security is a thorny
    problem with no easy solution. Once intruders have a command prompt, it’s you
    against them. And if they’re any good, you won’t even notice the penetration until
    it’s too late. By following good computing practices and keeping your system up
    to date, you can stop them from intruding in the first place. Do not allow securelevels
    to make you lazy!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '***Living with Securelevels***'
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve been liberal with the `schg` flag, you’ll soon find that you can’t
    upgrade or patch your system conveniently. The fact is, the same conditions that
    make intruders’ lives difficult can make yours a living hell if you don’t know
    how to work with them.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve frozen */etc/rc.conf* with `schg`, you must lower the securelevel
    to change the programs running on your system. Of course, the securelevel setting
    is in that file, so in order to edit it, you must take control of the system before
    */etc/rc* runs. That means you must boot into single-user mode (as discussed in
    [Chapter 4](ch04.xhtml#ch04)), mount your filesystems, run `chflags noschg` on
    the files in question, and continue booting. You can even entirely disable securelevels
    in */etc/rc.conf* and work normally while the system runs or add commands to */etc/rc.local*
    so they take effect before the securelevel is set. You’ll restore service more
    quickly that way but lose the protections of the file flags.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve finished maintenance, you can raise (but not lower) the securelevel
    by changing the `kern.securelevel` sysctl to your desired securelevel.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now that you can control file changes, let’s consider controlling access to
    your system from the network.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Targets**'
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Intruders normally break into applications that listen to the network, not the
    operating system itself. An operating system may or may not help defend a piece
    of software against network attacks, but the intrusion itself starts with the
    application. One way to reduce the number of attacks that can be carried out against
    your server is to identify all of the programs that are listening to the network
    and disable any that aren’t strictly necessary. FreeBSD provides sockstat(1) as
    an easy way to identify programs that are listening to the network.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: We cover sockstat in detail in [Chapter 8](ch08.xhtml#ch08); running `sockstat
    -4` shows all open IPv4 TCP/IP ports. Every network port you have open is a potential
    weakness and a potential target. Shut down unnecessary network services and secure
    those you must offer.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good idea to regularly review which ports are open on your systems because
    you might learn something that surprises you. You might find that some piece of
    software you’ve installed has a network component that you weren’t aware of and
    that it’s been quietly listening to the network.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you know what’s running, how do you turn off what you don’t need? The
    best way to close these ports is to not start the programs that run them. Network
    daemons generally start in one of two places: */etc/rc.conf* or a startup script
    in */etc/rc.d*. Programs that are integrated with the main FreeBSD system, such
    as sendmail(8), sshd(8), and rpcbind(8), have flags in *rc.conf* to enable or
    disable them, as do many add-on programs. See [Chapter 4](ch04.xhtml#ch04) for
    details on enabling and disabling programs at startup.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKSTATION VS. SERVER SECURITY**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Many companies I’ve seen have tightly secured servers but pay little attention
    to workstation security. A prospective intruder doesn’t care whether a system
    is a server or a workstation, however. Many servers and firewalls have special
    rules for the sysadmin’s workstation. An intruder will happily penetrate a workstation
    and try to leverage that into server access. While server security is key, don’t
    neglect workstations—especially *your* workstation!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Network probes are strange in that you really don’t know when someone pokes
    at your hosts. To see how much of this goes on, set `log_in_vain` to 1 in */etc/rc.conf*
    on one of your public servers. This tells the kernel to log all connection attempts
    to closed ports. When someone checks your host for a nonexistent telnet, Squid,
    or database listener, the kernel logs the attempt to */var/log/messages*. Watch
    that log only long enough to realize clear down to your marrow that the whole
    internet really is out to get you—and then disable `log_in_vain`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '**Putting It All Together**'
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have only the necessary network ports open and you know which programs
    are using those ports, you know which programs you must be most concerned about
    securing. If the FreeBSD security team sends out an announcement of a problem
    with a service you don’t run, you can safely delay implementing a fix until your
    next maintenance window. If, however, the security team announces a hole in programs
    you’re using, you know you have to implement a fix as soon as possible. If they
    announce a serious security problem with a piece of network software you’re using,
    you know you must act quickly. Simply being able to respond intelligently and
    quickly to real risks helps protect you against most intruders. Tools such as
    file flags and securelevels minimize the damage successful intruders can do. Finally,
    using groups to restrict your own system administrators to particular sections
    of the system can protect your computers from both accidental and deliberate damage.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Let’s shift gears now and talk storage.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
