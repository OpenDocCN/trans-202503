<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_181"/><strong><span class="big">7</span><br/>EXPRESSIONS</strong></h2>&#13;
<p class="quote"><em>Here is the essence of mankind’s creative genius: not the edifices of civilization nor the bang-flash weapons which can end it, but the words which fertilize new concepts like spermatozoa attacking an ovum.<br/>—Dan Simmons,</em> Hyperion</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent"><em>Expressions</em> are computations that produce results and side effects. Generally, expressions contain operands and operators that do work on them. A number of operators are baked into the core language, and you’ll see a majority of them in this chapter. The chapter begins with a discussion of built-in operators before moving on to discuss the overloading operator <span class="literal">new</span> and user-defined literals and then diving into an exploration of type conversions. When you create your own user-defined types, you’ll often need to describe how these types convert into other types. You’ll explore these user-defined conversions before learning about <span class="literal">constexpr</span> constant expressions and the widely misunderstood <span class="literal">volatile</span> keyword.</p>&#13;
<h3 class="h3" id="ch07lev1sec1"><strong><span epub:type="pagebreak" id="page_182"/>Operators</strong></h3>&#13;
<p class="noindent">Operators, such as the addition (<span class="literal">+</span>) and address-of (<span class="literal">&amp;</span>) operators, do work on arguments called operands, such as numerical values or objects. In this section, we’ll look at logical, arithmetic, assignment, increment/decrement, comparison, member access, ternary conditional, and comma operators.</p>&#13;
<h4 class="h4" id="ch07lev2sec1"><strong><em>Logical Operators</em></strong></h4>&#13;
<p class="noindent">The C++ expression suite includes a full complement of logical operators. Within this category are the (regular) operators AND (<span class="literal">&amp;&amp;</span>), OR (<span class="literal">||</span>), and NOT (<span class="literal">!</span>), which take <span class="literal">bool</span>-convertible operands and return an object of type <span class="literal">bool</span>. Also, <em>bitwise logical operators</em> work on integral types like <span class="literal">bool, int</span>, and <span class="literal">unsigned long</span>. These operators include AND (<span class="literal">&amp;</span>), OR (<span class="literal">|</span>), XOR (<span class="literal">^</span>), complement (<span class="literal">~</span>), left shift (<span class="literal">&lt;&lt;</span>), and right shift (<span class="literal">&gt;&gt;</span>). Each performs a Boolean operation at the bit level and returns an integral type matching its operands.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07tab01">Table 7-1</a> lists all of these logical operators alongside some examples.</p>&#13;
<p class="tabcap" id="ch07tab01"><strong>Table 7-1:</strong> Logical Operators</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Name</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Example expression</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Result</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x &amp; y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise AND</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">0b1100 &amp; 0b1010</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">0b1000</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x | y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Bitwise OR</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0b1100 | 0b1010</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0b1110</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x ^ y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise XOR</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">0b1100 ^ 0b1010</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">0b0110</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">~x</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Bitwise complement</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">~0b1010</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0b0101</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x &lt;&lt; y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise left shift</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">0b1010 &lt;&lt; 2</span></p>&#13;
<p class="taba"><span class="literal">0b0011 &lt;&lt; 4</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">0b101000</span></p>&#13;
<p class="taba"><span class="literal">0b110000</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x &gt;&gt; y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Bitwise right shift</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0b1010 &gt;&gt; 2</span></p>&#13;
<p class="taba"><span class="literal">0b10110011 &gt;&gt; 4</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0b10</span></p>&#13;
<p class="taba"><span class="literal">0b1011</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x &amp;&amp; y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">AND</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">true &amp;&amp; false</span></p>&#13;
<p class="taba"><span class="literal">true &amp;&amp; true</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">false</span></p>&#13;
<p class="taba"><span class="literal">true</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x || y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">OR</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">true || false</span></p>&#13;
<p class="taba"><span class="literal">false || false</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">true</span></p>&#13;
<p class="taba"><span class="literal">false</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">!x</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">NOT</p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">!true</span></p>&#13;
<p class="taba"><span class="literal">!false</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">false</span></p>&#13;
<p class="taba"><span class="literal">true</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch07lev2sec2"><strong><em>Arithmetic Operators</em></strong></h4>&#13;
<p class="noindent">Additional unary and binary <em>arithmetic operators</em> work with both integral and floating-point types (also called the <em>arithmetic types</em>). You’ll use built-in arithmetic operators wherever you need to perform mathematical computations. They perform some of the most basic elements of work, whether you’re incrementing an index variable or performing computationally intensive statistical simulations.</p>&#13;
<h5 class="h5" id="ch07lev3sec1"><span epub:type="pagebreak" id="page_183"/><strong>Unary Arithmetic Operators</strong></h5>&#13;
<p class="noindent">The <em>unary plus</em> <span class="literal">+</span> and <em>unary minus</em> <span class="literal">-</span> operators take a single arithmetic operand. Both operators <em>promote</em> their operands to <span class="literal">int</span>. So, if the operand is of type <span class="literal">bool, char</span>, or <span class="literal">short int</span>, the result of the expression is an <span class="literal">int</span>.</p>&#13;
<p class="indent">Unary plus doesn’t do much besides promotion; unary minus, on the other hand, will flip the sign of the operand. For example, given <span class="literal">char x = 10, +x</span> results in an <span class="literal">int</span> with a value of 10 and <span class="literal">-x</span> results in an <span class="literal">int</span> with a value of –10.</p>&#13;
<h5 class="h5" id="ch07lev3sec2"><strong>Binary Arithmetic Operators</strong></h5>&#13;
<p class="noindent">Aside from the two unary arithmetic operators, there are five <em>binary</em> arithmetic operators: <em>addition</em> <span class="literal">+</span>, <em>subtraction</em> <span class="literal">-</span>, <em>multiplication</em> <span class="literal">*</span>, <em>division</em> <span class="literal">/</span>, and <em>modulo</em> <span class="literal">%</span>. These operators take two operands and perform the indicated mathematical operation. Like their unary counterparts, these binary operators cause integer promotion on their operands. For example, adding two <span class="literal">char</span> operands will result in an <span class="literal">int</span>. There are floating-point promotion rules, too:</p>&#13;
<ul>&#13;
<li class="noindent">If an operand is <span class="literal">long double</span>, the other operand is promoted to <span class="literal">long double</span>.</li>&#13;
<li class="noindent">If an operand is <span class="literal">double</span>, the other operand is promoted to <span class="literal">double</span>.</li>&#13;
<li class="noindent">If an operand is <span class="literal">float</span>, the other operand is promoted to <span class="literal">float</span>.</li>&#13;
</ul>&#13;
<p class="indent">If none of the floating-point promotion rules apply, you then check whether either argument is signed. If so, both operands become signed. Finally, as with the promotion rules for floating-point types, the size of the largest operand is used to promote the other operand:</p>&#13;
<ul>&#13;
<li class="noindent">If an operand is <span class="literal">long long</span>, the other operand is promoted to <span class="literal">long long</span>.</li>&#13;
<li class="noindent">If an operand is <span class="literal">long</span>, the other operand is promoted to <span class="literal">long</span>.</li>&#13;
<li class="noindent">If an operand is <span class="literal">int</span>, the other operand is promoted to <span class="literal">int</span>.</li>&#13;
</ul>&#13;
<p class="indent">Although these rules are not too complicated to memorize, I recommend checking your work by leaning on <span class="literal">auto</span> type deduction. Just assign the result of an expression to an <span class="literal">auto</span>-declared variable and check the deduced type.</p>&#13;
<p class="indent">Don’t confuse casting and promotion. Casting is when you have an object of one type and need to convert it to another type. Promotion is the set of rules for interpreting literals. For example, if you have a platform with a 2-byte <span class="literal">short</span> and you performed signed conversion on an <span class="literal">unsigned short</span> with a value of 40000, the result is an integer overflow and undefined behavior. This is entirely different from processing promotion rules on the literal 40000. If it needs to be signed, the literal’s type is signed <span class="literal">int</span>, because a signed <span class="literal">short</span> is not large enough to hold such a value.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can use your IDE or even RTTI’s <span class="literal"><em>typeid</em></span> to print the type to console.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_184"/><a href="ch07.xhtml#ch07tab02">Table 7-2</a> summarizes the arithmetic operators.</p>&#13;
<p class="tabcap" id="ch07tab02"><strong>Table 7-2:</strong> Arithmetic Operators</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Name</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Examples</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Result</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">+x</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Unary plus</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">+10</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">10</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">-x</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Unary minus</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">-10</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">-10</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x + y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Binary addition</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">1 + 2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">3</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x - y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Binary subtraction</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">1 - 2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">-1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x * y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Binary multiplication</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">10 * 20</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">200</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x / y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Binary division</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">300 / 15</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">20</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x % y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Binary modulo</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">42 % 5</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">2</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Many of the binary operators in <a href="ch07.xhtml#ch07tab01">Tables 7-1</a> and <a href="ch07.xhtml#ch07tab02">7-2</a> have corollary as <em>assignment operators</em> as well.</p>&#13;
<h4 class="h4" id="ch07lev2sec3"><strong><em>Assignment Operators</em></strong></h4>&#13;
<p class="noindent">An assignment operator performs a given operation and then assigns the result to the first operand. For example, the <em>addition assignment</em> <span class="literal">x += y</span> computes the value <span class="literal">x + y</span> and assigns <span class="literal">x</span> equal to the result. You can achieve similar results with the expression <span class="literal">x = x + y</span>, but the <em>assignment operator</em> is more syntactically compact and at least as runtime efficient. <a href="ch07.xhtml#ch07tab03">Table 7-3</a> summarizes all of the available assignment operators.</p>&#13;
<p class="tabcap"><a id="ch07tab03"><strong>Table 7-3:</strong> Assignment Operators</a></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Name</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Examples</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Result (value of <span class="codestrong">x</span>)</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x = y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Simple assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x = 10</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">10</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x += y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Addition assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x += 10</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">15</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x -= y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Subtraction assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x -= 10</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">-5</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x *= y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Multiplication assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x *= 10</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">50</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x /= y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Division assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x /= 2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">2</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x %= y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Modulo assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x %= 2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x &amp;= y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise <em>AND</em> assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x &amp;= 0b1100</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">0b0100</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x |= y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Bitwise <em>OR</em> assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x |= 0b1100</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0b1101</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x ^= y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise <em>XOR</em> assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x ^= 0b1100</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">0b1001</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x &lt;&lt;= y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Bitwise <em>left-shift</em> assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x &lt;&lt;= 2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0b10100</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x &gt;&gt;= y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise <em>right-shift</em> assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x &gt;&gt;= 2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">0b0001</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Promotion rules don’t really apply when using assignment operators; the type of the assigned to operand won’t change. For example, given int <span class="literal">x = 5</span>, the type of <span class="literal">x</span> after <span class="literal">x /= 2.0f</span> is still <span class="literal">int</span>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch07lev2sec4"><span epub:type="pagebreak" id="page_185"/><strong><em>Increment and Decrement Operators</em></strong></h4>&#13;
<p class="noindent">There are four (unary) <em>increment</em>/<em>decrement</em> operators, as outlined in <a href="ch07.xhtml#ch07tab04">Table 7-4</a>.</p>&#13;
<p class="tabcap"><a id="ch07tab04"><strong>Table 7-4:</strong> The Increment and Decrement Operators (values given for <span class="literal">x=5</span>)</a></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba">Operator</p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba">Name</p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba">Value of <span class="codestrong">x</span> after evaluation</p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba">Value of expression</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">++x</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Prefix increment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">6</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">6</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x++</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Postfix increment</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">6</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">5</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">--x</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Prefix decrement</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">4</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">4</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x--</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Postfix decrement</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">4</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">5</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">As <a href="ch07.xhtml#ch07tab04">Table 7-4</a> shows, increment operators increase the value of their operand by 1, whereas decrement operators decrease by 1. The value returned by the operator depends on whether it is prefix or postfix. A prefix operator will return the value of the operand after modification, whereas a postfix operator will return the value before modification.</p>&#13;
<h4 class="h4" id="ch07lev2sec5"><strong><em>Comparison Operators</em></strong></h4>&#13;
<p class="noindent">Six comparison operators compare the given operands and evaluate to a <span class="literal">bool</span>, as outlined in <a href="ch07.xhtml#ch07tab05">Table 7-5</a>. For arithmetic operands, the same type conversions (promotions) occur as with the arithmetic operators. The comparison operators also work with pointers, and they work approximately how you would expect them to.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There are some nuances to pointer comparison. Interested readers should refer to [expr.rel].</em></p>&#13;
</div>&#13;
<p class="tabcap"><a id="ch07tab05"><strong>Table 7-5:</strong> The Comparison Operators</a></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Name</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Examples (all evaluate to <span class="codestrong">true</span>)</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x == y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Equal-to operator</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">100 == 100</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x != y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Not-equal-to operator</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">100 != 101</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x &lt; y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Less-than operator</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">10 &lt; 20</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x &gt; y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Greater-than operator</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">-10 &gt; -20</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">x &lt;= y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Less-than-or-equal-to operator</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">10 &lt;= 10</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">x &gt;= y</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Greater-than-or-equal-to operator</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">20 &gt;= 10</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch07lev2sec6"><strong><em>Member Access Operators</em></strong></h4>&#13;
<p class="noindent">You use <em>member access operators</em> to interact with pointers, arrays, and many of the classes you’ll meet in <a href="part02.xhtml#part02">Part II</a>. The six such operators include <em>subscript</em> <span class="literal">[]</span>, <em>indirection</em> <span class="literal">*</span>, <em>address-of</em>  <span class="literal">&amp;</span>, <em>member-of-object</em> <span class="literal">.</span>, and <em>member-of-pointer</em> <span class="literal">-&gt;</span>. You met these operators in <a href="ch03.xhtml#ch03">Chapter 3</a>, but this section provides a brief summary.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em><span epub:type="pagebreak" id="page_186"/>There are also</em> pointer-to-member-of-object .* <em>and</em> pointer-to-member-of-pointer -&gt;* <em>operators, but these are uncommon. Refer to [expr.mptr.oper]</em>.</p>&#13;
</div>&#13;
<p class="indent">The subscript operator <span class="literal">x[y]</span> provides access to the <span class="literal">y</span>th element of the array pointed to by <span class="literal">x</span>, whereas the indirection operator <span class="literal">*x</span> provides access to the element pointed to by <span class="literal">x</span>. You can create a pointer to an element <span class="literal">x</span> using the address-of operator <span class="literal">&amp;x</span>. This is essentially the inverse operation to the indirection operator. For elements <span class="literal">x</span> with a member <span class="literal">y</span>, you use the member-of-object operator <span class="literal">x.y</span>. You can also access members of a pointed-to object; given a pointer <span class="literal">x</span>, you use the member-of-pointer operator <span class="literal">x-&gt;y</span> to access an object pointed to by <span class="literal">x</span>.</p>&#13;
<h4 class="h4" id="ch07lev2sec7"><strong><em>Ternary Conditional Operator</em></strong></h4>&#13;
<p class="noindent">The <em>ternary conditional operator</em> <span class="literal">x ? y : z</span> is a lump of syntactic sugar that takes three operands (hence “ternary”). It evaluates the first operand <span class="literal">x</span> as a Boolean expression and returns the second operand <span class="literal">y</span> or the third operand <span class="literal">z</span> depending on whether the Boolean is <span class="literal">true</span> or <span class="literal">false</span> (respectively). Consider the following step function that returns 1 if the parameter <span class="literal">input</span> is positive; otherwise, it returns zero:</p>&#13;
<pre>int step(int input) {&#13;
  return input &gt; 0 ? 1 : 0;&#13;
}</pre>&#13;
<p class="indent">Using an equivalent if-then statement, you could also implement <span class="literal">step</span> the following way:</p>&#13;
<pre>int step(int input) {&#13;
  if (input &gt; 0) {&#13;
    return 1;&#13;
  } else {&#13;
    return 0;&#13;
  }&#13;
}</pre>&#13;
<p class="indent">These two approaches are runtime equivalent, but the ternary conditional operator requires less typing and usually results in cleaner code. Use it generously.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The conditional ternary operator has a more fashionable moniker: the</em> Elvis operator. <em>If you rotate the book 90 degrees clockwise and squint, you’ll see why: <span class="literal">?:</span></em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch07lev2sec8"><strong><em>The Comma Operator</em></strong></h4>&#13;
<p class="noindent">The <em>comma operator</em>, on the other hand, doesn’t usually promote cleaner code. It allows several expressions separated by commas to be evaluated within a larger expression. The expressions evaluate from left to right, and the rightmost expression is the return value, as <a href="ch07.xhtml#ch07ex01">Listing 7-1</a> illustrates.</p>&#13;
<pre><span epub:type="pagebreak" id="page_187"/>#include &lt;cstdio&gt;&#13;
&#13;
int confusing(int &amp;x) {&#13;
  return x = 9, x++, x / 2;&#13;
}&#13;
&#13;
int main() {&#13;
  int x{}; <span class="ent">➊</span>&#13;
  auto y = confusing(x); <span class="ent">➋</span>&#13;
  printf("x: %d\ny: %d", x, y);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">x: 10</span>&#13;
<span class="color1">y: 5</span></pre>&#13;
<p class="listing"><a id="ch07ex01"/><em>Listing 7-1: A confusing function employing the comma operator</em></p>&#13;
<p class="indent">After invoking <span class="literal">confusing, x</span> equals <span class="literal">10</span> <span class="ent">➊</span> and <span class="literal">y</span> equals <span class="literal">5</span> <span class="ent">➋</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A vestigial structure from C’s wilder and altogether less-inhibited college days, the comma operator permits a particular kind of expression-oriented programming. Eschew the comma operator; its use is exceedingly uncommon and likely to sow confusion.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch07lev2sec9"><strong><em>Operator Overloading</em></strong></h4>&#13;
<p class="noindent">For each fundamental type, some portion of the operators covered in this section will be available. For user-defined types, you can specify custom behavior for these operators by employing <em>operator overloading</em>. To specify behavior for an operator in a user-defined class, simply name the method with the word <span class="literal">operator</span> immediately followed by the operator; ensure that the return types and parameters match the types of the operands you want to deal with.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07ex02">Listing 7-2</a> defines a <span class="literal">CheckedInteger</span>.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
struct CheckedInteger {&#13;
  CheckedInteger(unsigned int value) : value{ value } <span class="ent">➊</span> { }&#13;
&#13;
  CheckedInteger operator+(unsigned int other) const { <span class="ent">➋</span>&#13;
    CheckedInteger result{ value + other }; <span class="ent">➌</span>&#13;
    if (result.value &lt; value) throw std::runtime_error{ "Overflow!" }; <span class="ent">➍</span>&#13;
    return result;&#13;
  }&#13;
&#13;
  const unsigned int value; <span class="ent">➎</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch07ex02"/><em>Listing 7-2: A <span class="literal">CheckedInteger</span> class that detects overflow at runtime</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_188"/>In this class, you’ve defined a constructor that takes a single <span class="literal">unsigned int</span>. This argument is used <span class="ent">➊</span> to member initialize the public field <span class="literal">value</span> <span class="ent">➎</span>. Because <span class="literal">value</span> is <span class="literal">const, CheckedInteger</span> is <em>immutable</em>—after construction, it’s not possible to modify the state of a <span class="literal">CheckedInteger</span>. The method of interest here is <span class="literal">operator+</span> <span class="ent">➋</span>, which allows you to add an ordinary <span class="literal">unsigned int</span> to a <span class="literal">CheckedInteger</span> to produce a new <span class="literal">CheckedInteger</span> with the correct <span class="literal">value</span>. The return value of <span class="literal">operator+</span> is constructed at <span class="ent">➌</span>. Whenever addition results in the overflow of an <span class="literal">unsigned int</span>, the result will be less than the original values. You check for this condition at <span class="ent">➍</span>. If an overflow is detected, you throw an exception.</p>&#13;
<p class="indent"><a href="ch06.xhtml">Chapter 6</a> described <span class="literal">type_traits</span>, which allow you to determine features of your types at compile time. A related family of type support is available in the <span class="literal">&lt;limits&gt;</span> header, which allows you to query various properties of arithmetic types.</p>&#13;
<p class="indent">Within <span class="literal">&lt;limits&gt;</span>, the template class <span class="literal">numeric_limits</span> exposes a number of member constants that provide information about the template parameter. One such example is the <span class="literal">max()</span> method, which returns the highest finite value of a given type. You can use this method to kick the tires of the <span class="literal">CheckedInteger</span> class. <a href="ch07.xhtml#ch07ex03">Listing 7-3</a> illustrates the behavior of the <span class="literal">CheckedInteger</span>.</p>&#13;
<pre>#include &lt;limits&gt;&#13;
#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
struct CheckedInteger {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
int main() {&#13;
  CheckedInteger a{ 100 }; <span class="ent">➊</span>&#13;
  auto b = a + 200; <span class="ent">➋</span>&#13;
  printf("a + 200 = %u\n", b.value);&#13;
  try {&#13;
    auto c = a + std::numeric_limits&lt;unsigned int&gt;::max(); <span class="ent">➌</span>&#13;
  } catch(const std::overflow_error&amp; e) {&#13;
    printf("(a + max) Exception: %s\n", e.what());&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">a + 200 = 300</span>&#13;
<span class="color1">(a + max) Exception: Overflow!</span></pre>&#13;
<p class="listing"><a id="ch07ex03"/><em>Listing 7-3: A program illustrating the use of <span class="literal">CheckedInteger</span></em></p>&#13;
<p class="indent">After constructing a <span class="literal">CheckedInteger</span> <span class="ent">➊</span>, you can add it to an <span class="literal">unsigned int</span> <span class="ent">➋</span>. Because the resulting value, 300, is guaranteed to fit inside an <span class="literal">unsigned int</span>, this statement executes without throwing an exception. Next, you add the same <span class="literal">CheckedInteger a</span> to the maximum value of an <span class="literal">unsigned int</span> via <span class="literal">numeric_limits</span> <span class="ent">➌</span>. This causes an overflow, which is detected by the <span class="literal">operator+</span> overload and results in a thrown <span class="literal">overflow_error</span>.</p>&#13;
<h4 class="h4" id="ch07lev2sec10"><strong><em><span epub:type="pagebreak" id="page_189"/>Overloading Operator new</em></strong></h4>&#13;
<p class="noindent">Recall from <a href="ch04.xhtml#ch04">Chapter 4</a> that you allocate objects with dynamic storage duration using operator <span class="literal">new</span>. By default, operator <span class="literal">new</span> will allocate memory on the free store to make space for your dynamic objects. The <em>free store</em>, also known as the <em>heap</em>, is an implementation-defined storage location. On desktop operating systems, the kernel usually manages the free store (see the <span class="literal">HeapAlloc</span> on Windows and <span class="literal">malloc</span> on Linux and macOS) and is generally vast.</p>&#13;
<h5 class="h5" id="ch07lev3sec3"><strong>Free Store Availability</strong></h5>&#13;
<p class="noindent">In some environments, like the Windows kernel or embedded systems, there is no free store available to you by default. In other settings, such as game development or high-frequency trading, free store allocations simply involve too much latency, because you’ve delegated its management to the operating system.</p>&#13;
<p class="indent">You could try to avoid using the free store entirely, but this is severely limiting. One major limitation this would introduce is to preclude the use of stdlib containers, which after reading <a href="part02.xhtml#part02">Part II</a> you’ll agree is a major loss. Rather than settling for these severe restrictions, you can overload the free store operations and take control over allocations. You do this by overloading operator <span class="literal">new</span>.</p>&#13;
<h5 class="h5" id="ch07lev3sec4"><strong>The &lt;new&gt; Header</strong></h5>&#13;
<p class="noindent">In environments that support free store operations, the <span class="literal">&lt;new&gt;</span> header contains the following four operators:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">void* operator new(size_t);</span></li>&#13;
<li class="noindent"><span class="literal">void operator delete(void*);</span></li>&#13;
<li class="noindent"><span class="literal">void* operator new[](size_t);</span></li>&#13;
<li class="noindent"><span class="literal">void operator delete[](void*);</span></li>&#13;
</ul>&#13;
<p class="indent">Notice that the return type of operator <span class="literal">new</span> is <span class="literal">void*</span>. The free store operators deal in raw, uninitialized memory.</p>&#13;
<p class="indent">It’s possible to provide your own versions of these four operators. All you do is define them once in your program. The compiler will use your versions rather than the defaults.</p>&#13;
<p class="indent">Free store management is a surprisingly complicated task. One of the major issues is <em>memory fragmentation</em>. Over time, large numbers of memory allocations and releases can leave free blocks of memory scattered throughout the region dedicated for the free store. It’s possible to get into situations where there is plenty of free memory, but it’s scattered across allocated memory. When this happens, large requests for memory will fail, even though there is technically enough free memory to provide to the requester. <a href="ch07.xhtml#ch07fig01">Figure 7-1</a> illustrates such a situation. There is plenty of memory for the desired allocation, but the available memory is noncontiguous.</p>&#13;
<div class="image"><img src="../images/fig7_1.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch07fig01"><span epub:type="pagebreak" id="page_190"/><em>Figure 7-1: The memory fragmentation problem</em></p>&#13;
<h5 class="h5" id="ch07lev3sec5"><strong>Buckets</strong></h5>&#13;
<p class="noindent">One approach is to chop allocated memory into so-called <em>buckets</em> of a fixed size. When you request memory, the environment allocates a whole bucket, even if you didn’t request all the memory. For example, Windows provides two functions for allocating dynamic memory: <span class="literal">VirtualAllocEx</span> and <span class="literal">HeapAlloc</span>.</p>&#13;
<p class="indent">The <span class="literal">VirtualAllocEx</span> function is low level, which allows you to provide many options, such as which process to allocate memory into, the preferred memory address, the requested size, and permissions, like whether the memory should be readable, writable, and executable. This function will never allocate fewer than 4096 bytes (a so-called <em>page</em>).</p>&#13;
<p class="indent">On the other hand, <span class="literal">HeapAlloc</span> is a higher-level function that hands out less than a page of memory when it can; otherwise, it will invoke <span class="literal">VirtualAllocEx</span> on your behalf. At least with the Visual Studio compiler, <span class="literal">new</span> will call <span class="literal">HeapAlloc</span> by default.</p>&#13;
<p class="indent">This arrangement prevents memory fragmentation in exchange for some overhead associated with rounding up allocations to bucket size. Modern operating systems like Windows will have fairly complex schemes for allocating memory of different sizes. You don’t see any of this complexity unless you want to take control.</p>&#13;
<h5 class="h5" id="ch07lev3sec6"><strong>Taking Control of the Free Store</strong></h5>&#13;
<p class="noindent"><a href="ch07.xhtml#ch07ex04">Listing 7-4</a> demonstrates implementing very simple <span class="literal">Bucket</span> and <span class="literal">Heap</span> classes. These will facilitate taking control over dynamic memory allocation:</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
#include &lt;new&gt;&#13;
&#13;
struct Bucket { <span class="ent">➊</span>&#13;
  const static size_t data_size{ 4096 };&#13;
  std::byte data[data_size];&#13;
};&#13;
&#13;
struct Heap {&#13;
  void* allocate(size_t bytes) { <span class="ent">➋</span>&#13;
    if (bytes &gt; Bucket::data_size) throw std::bad_alloc{};&#13;
    for (size_t i{}; i &lt; n_heap_buckets; i++) {&#13;
      if (!bucket_used[i]) {&#13;
        bucket_used[i] = true;&#13;
        return buckets[i].data;&#13;
<span epub:type="pagebreak" id="page_191"/>      }&#13;
    }&#13;
    throw std::bad_alloc{};&#13;
  }&#13;
&#13;
  void free(void* p) { <span class="ent">➌</span>&#13;
    for (size_t i{}; i &lt; n_heap_buckets; i++) {&#13;
      if (buckets[i].data == p) {&#13;
        bucket_used[i] = false;&#13;
        return;&#13;
      }&#13;
    }&#13;
  }&#13;
  static const size_t n_heap_buckets{ 10 };&#13;
  Bucket buckets[n_heap_buckets]{}; <span class="ent">➍</span>&#13;
  bool bucket_used[n_heap_buckets]{}; <span class="ent">➎</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch07ex04"/><em>Listing 7-4: <span class="literal">Heap</span> and <span class="literal">Bucket</span> classes</em></p>&#13;
<p class="indent">The <span class="literal">Bucket</span> class <span class="ent">➊</span> is responsible for taking up space in memory. As an homage to the Windows heap manager, the bucket size is hardcoded to 4096. All of the management logic goes into the <span class="literal">Heap</span> class.</p>&#13;
<p class="indent">Two important accounting members are in <span class="literal">Heap</span>: <span class="literal">buckets</span> <span class="ent">➍</span> and <span class="literal">bucket_used</span> <span class="ent">➎</span>. The <span class="literal">buckets</span> member houses all the <span class="literal">Buckets</span>, neatly packed into a contiguous string. The <span class="literal">bucket_used</span> member is a relatively tiny array containing objects of type <span class="literal">bool</span> that keeps track of whether a <span class="literal">Bucket</span> in <span class="literal">buckets</span> with the same index has been loaned out yet. Both members are initialized to zero.</p>&#13;
<p class="indent">The <span class="literal">Heap</span> class has two methods: <span class="literal">allocate</span> <span class="ent">➋</span> and <span class="literal">free</span> <span class="ent">➌</span>. The <span class="literal">allocate</span> method first checks whether the number of bytes requested is greater than the bucket size. If it is, it throws a <span class="literal">std::bad_alloc</span> exception. Once the size check passes, <span class="literal">Heap</span> iterates through the <span class="literal">buckets</span> looking for one that isn’t marked <span class="literal">true</span> in <span class="literal">bucket_used</span>. If it finds one, it returns the <span class="literal">data</span> member pointer for the associated <span class="literal">Bucket</span>. If it can’t find an unused <span class="literal">Bucket</span>, it throws a <span class="literal">std::bad_alloc</span> exception. The <span class="literal">free</span> method accepts a <span class="literal">void*</span> and iterates through all the <span class="literal">buckets</span> looking for a matching <span class="literal">data</span> member pointer. If it finds one, it sets <span class="literal">bucket_used</span> for the corresponding bucket to <span class="literal">false</span> and returns.</p>&#13;
<h5 class="h5" id="ch07lev3sec7"><strong>Using Our Heap</strong></h5>&#13;
<p class="noindent">One way to allocate a <span class="literal">Heap</span> is to declare it at namespace scope so it has static storage duration. Because its lifetime begins when the program starts, you can use it inside the <span class="literal">operator new</span> and <span class="literal">operator delete</span> overrides, as shown in <a href="ch07.xhtml#ch07ex05">Listing 7-5</a>.</p>&#13;
<pre>Heap heap; <span class="ent">➊</span>&#13;
&#13;
void* operator new(size_t n_bytes) {&#13;
  return heap.allocate(n_bytes); <span class="ent">➋</span>&#13;
}&#13;
<span epub:type="pagebreak" id="page_192"/>void operator delete(void* p) {&#13;
  return heap.free(p); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch07ex05"/><em>Listing 7-5: Overriding the <span class="literal">new</span> and <span class="literal">delete</span> operators to use the <span class="literal">Heap</span> class from <a href="ch07.xhtml#ch07ex04">Listing 7-4</a></em></p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07ex05">Listing 7-5</a> declares a <span class="literal">Heap</span> <span class="ent">➊</span> and uses it inside the operator <span class="literal">new</span> overload <span class="ent">➋</span> and the operator <span class="literal">delete</span> overload <span class="ent">➌</span>. Now if you use <span class="literal">new</span> and <span class="literal">delete</span>, dynamic memory management will use <span class="literal">heap</span> instead of the default free store offered by the environment. <a href="ch07.xhtml#ch07ex06">Listing 7-6</a> kicks the tires of the overloaded dynamic memory management.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  printf("Buckets:   %p\n", heap.buckets); <span class="ent">➊</span>&#13;
  auto breakfast = new unsigned int{ 0xC0FFEE };&#13;
  auto dinner = new unsigned int { 0xDEADBEEF };&#13;
  printf("Breakfast: %p 0x%x\n", breakfast, *breakfast); <span class="ent">➋</span>&#13;
  printf("Dinner:    %p 0x%x\n", dinner, *dinner); <span class="ent">➌</span>&#13;
  delete breakfast;&#13;
  delete dinner;&#13;
  try {&#13;
    while (true) {&#13;
      new char;&#13;
      printf("Allocated a char.\n"); <span class="ent">➍</span>&#13;
    }&#13;
  } catch (const std::bad_alloc&amp;) {&#13;
    printf("std::bad_alloc caught.\n"); <span class="ent">➎</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Buckets:   00007FF792EE3320 <span class="ent">➊</span></span>&#13;
<span class="color1">Breakfast: 00007FF792EE3320 0xc0ffee <span class="ent">➋</span></span>&#13;
<span class="color1">Dinner:    00007FF792EE4320 0xdeadbeef <span class="ent">➌</span></span>&#13;
<span class="color1">Allocated a char. <span class="ent">➍</span></span>&#13;
<span class="color1">Allocated a char.</span>&#13;
<span class="color1">Allocated a char.</span>&#13;
<span class="color1">Allocated a char.</span>&#13;
<span class="color1">Allocated a char.</span>&#13;
<span class="color1">Allocated a char.</span>&#13;
<span class="color1">Allocated a char.</span>&#13;
<span class="color1">Allocated a char.</span>&#13;
<span class="color1">Allocated a char.</span>&#13;
<span class="color1">Allocated a char.</span>&#13;
<span class="color1">std::bad_alloc caught. <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch07ex06"/><em>Listing 7-6: A program illustrating the use of <span class="literal">Heap</span> to manage dynamic allocations</em></p>&#13;
<p class="indent">You’ve printed the memory address of the first <span class="literal">buckets</span> element of the <span class="literal">heap</span> <span class="ent">➊</span>. This is the memory location loaned out to the first <span class="literal">new</span> invocation. You verify that this is the case by printing the memory address and value pointed to by <span class="literal">breakfast</span> <span class="ent">➋</span>. Notice that the memory address matches the memory address of the first <span class="literal">Bucket</span> in <span class="literal">heap</span>. You’ve done the same for <span epub:type="pagebreak" id="page_193"/>the memory pointed to by <span class="literal">dinner</span> <span class="ent">➌</span>. Notice that the memory address is exactly <span class="literal">0x1000</span> greater than that of <span class="literal">breakfast</span>. This coincides exactly with the 4096-byte length of a <span class="literal">Bucket</span>, as defined in the <span class="literal">const static</span> member <span class="literal">Bucket::data_size</span>.</p>&#13;
<p class="indent">After printing printing <span class="ent">➋➌</span>, you delete <span class="literal">breakfast</span> and <span class="literal">dinner</span>. Then, you allocate <span class="literal">char</span> objects with reckless abandon until a <span class="literal">std::bad_alloc</span> is thrown when <span class="literal">heap</span> runs out of memory. Each time you make an allocation, you print <span class="literal">Allocated</span> a <span class="literal">char</span>. starting at <span class="ent">➍</span>. There are 10 lines before you see a <span class="literal">std::bad_alloc</span> exception <span class="ent">➎</span>. Notice that this is exactly the number of <span class="literal">buckets</span> you’ve set in <span class="literal">Heap::n_heap_buckets</span>. This means that, for each <span class="literal">char</span> you’ve allocated, you’ve taken up 4096 bytes of memory!</p>&#13;
<h5 class="h5" id="ch07lev3sec8"><strong>Placement Operators</strong></h5>&#13;
<p class="noindent">Sometimes, you don’t want to override <em>all</em> free store allocations. In such situations, you can use the placement operators, which perform the appropriate initialization on preallocated memory:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">void* operator new(size_t, void*);</span></li>&#13;
<li class="noindent"><span class="literal">void operator delete(size_t, void*);</span></li>&#13;
<li class="noindent"><span class="literal">void* operator new[](void*, void*);</span></li>&#13;
<li class="noindent"><span class="literal">void operator delete[](void*, void*);</span></li>&#13;
</ul>&#13;
<p class="indent">Using placement operators, you can manually construct objects in arbitrary memory. This has the advantage of enabling you to manually manipulate an object’s lifetime. However, you cannot use <span class="literal">delete</span> to release the resulting dynamic objects. You must call the object’s destructor directly (and exactly once!), as demonstrated in <a href="ch07.xhtml#ch07ex07">Listing 7-7</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstddef&gt;&#13;
#include &lt;new&gt;&#13;
&#13;
struct Point {&#13;
  Point() : x{}, y{}, z{} {&#13;
    printf("Point at %p constructed.\n", this); <span class="ent">➊</span>&#13;
  }&#13;
  ~Point() {&#13;
    printf("Point at %p destructed.\n", this); <span class="ent">➋</span>&#13;
  }&#13;
  double x, y, z;&#13;
};&#13;
&#13;
int main() {&#13;
  const auto point_size = sizeof(Point);&#13;
  std::byte data[3 * point_size];&#13;
  printf("Data starts at %p.\n", data); <span class="ent">➌</span>&#13;
  auto point1 = new(&amp;data[0 * point_size]) Point{}; <span class="ent">➍</span>&#13;
  auto point2 = new(&amp;data[1 * point_size]) Point{}; <span class="ent">➎</span>&#13;
  auto point3 = new(&amp;data[2 * point_size]) Point{}; <span class="ent">➏</span>&#13;
  point1-&gt;~Point(); <span class="ent">➐</span>&#13;
<span epub:type="pagebreak" id="page_194"/>  point2-&gt;~Point(); <span class="ent">➑</span>&#13;
  point3-&gt;~Point(); <span class="ent">➒</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Data starts at 0000004D290FF8E8. <span class="ent">➌</span></span>&#13;
<span class="color1">Point at 0000004D290FF8E8 constructed. <span class="ent">➍</span></span>&#13;
<span class="color1">Point at 0000004D290FF900 constructed. <span class="ent">➎</span></span>&#13;
<span class="color1">Point at 0000004D290FF918 constructed. <span class="ent">➏</span></span>&#13;
<span class="color1">Point at 0000004D290FF8E8 destructed. <span class="ent">➐</span></span>&#13;
<span class="color1">Point at 0000004D290FF900 destructed. <span class="ent">➑</span></span>&#13;
<span class="color1">Point at 0000004D290FF918 destructed. <span class="ent">➒</span></span></pre>&#13;
<p class="listing"><a id="ch07ex07"/><em>Listing 7-7: Using placement <span class="literal">new</span> to initialize dynamic objects</em></p>&#13;
<p class="indent">The constructor <span class="ent">➊</span> prints a message indicating that a <span class="literal">Point</span> at a particular address was constructed, and the destructor <span class="ent">➋</span> prints a corresponding message indicating that the <span class="literal">Point</span> is getting destructed. You’ve printed the address of <span class="literal">data</span>, which is the first address where placement <span class="literal">new</span> initializes a <span class="literal">Point</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">Observe that each placement <span class="literal">new</span> has allocated the <span class="literal">Point</span> within the memory occupied by your <span class="literal">data</span> array <span class="ent">➍➎➏</span>. You must invoke each destructor individually <span class="ent">➐➑➒</span>.</p>&#13;
<h4 class="h4" id="ch07lev2sec11"><strong><em>Operator Precedence and Associativity</em></strong></h4>&#13;
<p class="noindent">When more than one operator appears in an expression, <em>operator precedence</em> and <em>operator associativity</em> decide how the expression parses. Operators with higher precedence are bound tighter to their arguments than operators with lower precedence. If two operators have the same precedence, their associativity breaks the tie to decide how arguments bind. Associativity is either <em>left to right</em> or <em>right to left</em>.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07tab06">Table 7-6</a> contains every C++ operator sorted by its precedence and annotated with its associativity. Each row contains one or more operators with the same precedence along with a description and its associativity. Higher rows have higher precedence.</p>&#13;
<p class="tabcap"><a id="ch07tab06"><strong>Table 7-6:</strong> Operator Precedence and Associativity</a></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Associativity</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a::b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Scope resolution</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a++</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Postfix increment</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a--</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Postfix decrement</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">fn()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Function call</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a[b]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Subscript</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a-&gt;b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Member of pointer</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a.b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Member of object</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Type(a)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Functional cast</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Type{ a }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Functional cast</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_195"/><span class="literal">++a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Prefix increment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Right to left</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">--a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Prefix decrement</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">+a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Unary plus</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">-a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Unary minus</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">!a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Logical NOT</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">~a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise complement</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">(Type)a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">C-style cast</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">*a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dereference</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">&amp;a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Address of</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">sizeof(Type)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Size of</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">new Type</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dynamic allocation</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">new Type[]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dynamic allocation (array)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">delete a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dynamic deallocation</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">delete[] a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dynamic deallocation (array)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">.*</span></p>&#13;
<p class="taba"><span class="literal">-&gt;*</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Pointer-to-member-of-pointer</p>&#13;
<p class="taba">Pointer-to-member-of-object</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a * b</span></p>&#13;
<p class="taba"><span class="literal">a / b</span></p>&#13;
<p class="taba"><span class="literal">a % b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Multiplication</p>&#13;
<p class="taba">Division</p>&#13;
<p class="taba">Modulo division</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a + b</span></p>&#13;
<p class="taba"><span class="literal">a - b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Addition</p>&#13;
<p class="taba">Subtraction</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a &lt;&lt; b</span></p>&#13;
<p class="taba"><span class="literal">a &gt;&gt; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise left shift</p>&#13;
<p class="taba">Bitwise right shift</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a &lt; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Less than</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a &gt; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Greater than</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a &lt;= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Less than or equal to</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a &gt;= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Greater than or equal to</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a == b</span></p>&#13;
<p class="taba"><span class="literal">a != b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Equals</p>&#13;
<p class="taba">Not equals</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a &amp; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Bitwise AND</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a ^ b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise XOR</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a | b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Bitwise OR</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a &amp;&amp; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Logical AND</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">a || b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Logical OR</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a ? b : c</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Ternary</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Right to left</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">throw a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Throw</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a = b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a += b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Sum assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a -= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Difference assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a *= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Product assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a /= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Quotient assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a %= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Remainder assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a &lt;&lt;= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise-left-shift assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a &gt;&gt;= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise-right-shift assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a &amp;= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise AND assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a ^= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise XOR assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a |= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Bitwise OR assignment</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">a, b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Comma</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Left to right</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_196"/><em>You haven’t yet met the scope resolution operator (it first appears in <a href="ch08.xhtml#ch08">Chapter 8</a>), but <a href="ch07.xhtml#ch07tab06">Table 7-6</a> includes it for completeness.</em></p>&#13;
</div>&#13;
<p class="indent">Because C++ has many operators, the operator precedence and associativity rules can be hard to keep track of. For the mental health of those reading your code, try to make expressions as clear as possible.</p>&#13;
<p class="indent">Consider the following expression:</p>&#13;
<pre>*a++ + b * c</pre>&#13;
<p class="indent">Because postfix addition has higher precedence than the dereference operator <span class="literal">*</span>, it binds first to the argument <span class="literal">a</span>, meaning the result of <span class="literal">a++</span> is the argument to the dereference operator. Multiplication <span class="literal">*</span> has higher precedence than addition <span class="literal">+</span>, so the multiplication operator <span class="literal">*</span> binds to <span class="literal">b</span> and <span class="literal">c</span>, and the addition operator <span class="literal">+</span> binds to the results of <span class="literal">*a++</span> and <span class="literal">b * c</span>.</p>&#13;
<p class="indent">You can impose precedence within an expression by adding parentheses, which have higher precedence than any operator. For example, you can rewrite the preceding expression using parentheses:</p>&#13;
<pre>(*(a++)) + (b * c)</pre>&#13;
<p class="indent">As a general rule, add parentheses wherever a reader could become confused about operator precedence. If the result is a bit ugly (as in this example), your expression is probably too complicated; you might consider breaking it up into multiple statements.</p>&#13;
<h4 class="h4" id="ch07lev2sec12"><strong><em>Evaluation Order</em></strong></h4>&#13;
<p class="noindent">Evaluation order determines the execution sequence of operators in an expression. A common misconception is that precedence and evaluation order are equivalent: they are not. <em>Precedence</em> is a compile time concept that drives how operators bind to operands. <em>Evaluation order</em> is a runtime concept that drives the scheduling of operator execution.</p>&#13;
<p class="indent"><em>In general, C++ has no clearly specified execution order for operands.</em> Although operators bind to operands in the well-defined way explained in the preceding sections, those operands evaluate in an undefined order. The compiler can order operand evaluation however it likes.</p>&#13;
<p class="indent">You might be tempted to think that the parentheses in the following expression drive evaluation order for the functions <span class="literal">stop, drop</span>, and <span class="literal">roll</span>, or that some left-to-right associativity has some runtime effect:</p>&#13;
<pre>(stop() + drop()) + roll()</pre>&#13;
<p class="indent">They do not. The <span class="literal">roll</span> function might execute before, after, or between evaluations of <span class="literal">stop</span> and <span class="literal">drop</span>. If you require operations to execute in a specific <span epub:type="pagebreak" id="page_197"/>order, simply place them into separate statements in the desired sequence, as shown here:</p>&#13;
<pre>auto result = stop();&#13;
result = result + drop();&#13;
result = result + roll();</pre>&#13;
<p class="indent">If you aren’t careful, you can even get undefined behavior. Consider the following expression:</p>&#13;
<pre>b = ++a + a;</pre>&#13;
<p class="indent">Because the ordering of the expressions <span class="literal">++a</span> and <span class="literal">a</span> is not specified, and because the value of <span class="literal">++a + a</span> depends on which expression evaluates first, the value of <span class="literal">b</span> cannot be well defined.</p>&#13;
<p class="indent">In some special situations, execution order is specified by the language. The most commonly encountered scenarios are as follows:</p>&#13;
<ul>&#13;
<li class="noindent">The built-in logical AND operator <span class="literal">a &amp;&amp; b</span> and built-in logical OR operator <span class="literal">a || b</span> guarantee that <span class="literal">a</span> executes before <span class="literal">b</span>.</li>&#13;
<li class="noindent">The ternary operator <span class="literal">a ? b : c</span> guarantees that <span class="literal">a</span> executes before <span class="literal">b</span> and <span class="literal">c</span>.</li>&#13;
<li class="noindent">The comma operator <span class="literal">a, b</span> guarantees that <span class="literal">a</span> executes before <span class="literal">b</span>.</li>&#13;
<li class="noindent">The constructor arguments in a <span class="literal">new</span> expression evaluate before the call to the allocator function.</li>&#13;
</ul>&#13;
<p class="indent">You might be wondering why C++ doesn’t enforce execution order, say from left to right, to avoid confusion. The answer is simply that by not arbitrarily constraining execution order, the language is allowing compiler writers to find clever optimization opportunities.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For more information on execution order, see [expr].</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch07lev1sec2"><strong>User-Defined Literals</strong></h3>&#13;
<p class="noindent"><a href="ch02.xhtml">Chapter 2</a> covered how to declare literals, constant values that you use directly in your programs. These help the compiler to turn embedded values into the desired types. Each fundamental type has its own syntax for literals. For example, a <span class="literal">char</span> literal is declared in single quotes like <span class="literal">'J'</span>, whereas a <span class="literal">wchar_t</span> is declared with an <span class="literal">L</span> prefix like <span class="literal">L'J'</span>. You can specify the precision of floating-point numbers using either the <span class="literal">F</span> or <span class="literal">L</span> suffix.</p>&#13;
<p class="indent">For convenience, you can also make your own <em>user-defined literals</em>. As with the baked-in literals, these provide you with some syntactical support for giving type information to the compiler. Although you’d rarely ever need to declare a user-defined literal, it’s worth mentioning because you might find them in libraries. The stdlib <span class="literal">&lt;chrono&gt;</span> header uses literals extensively to give programmers a clean syntax for using time types—for <span epub:type="pagebreak" id="page_198"/>example, <span class="literal">700ms</span> denotes 700 milliseconds. Because user-defined literals are fairly rare, I won’t cover them in any more detail here.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For further reference, see Section 19.2.6 of  <em>The C++ Programming Language</em>, 4th Edition, by Bjarne Stroustrup.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch07lev1sec3"><strong>Type Conversions</strong></h3>&#13;
<p class="noindent">You perform type conversions when you have one type but want to convert it to another type. Depending on the situation, type conversions can be explicit or implicit. This section treats both sorts of conversions while covering promotions, floating-point-to-integer conversions, integer-to-integer conversions, and floating-point-to-floating-point conversions.</p>&#13;
<p class="indent">Type conversions are fairly common. For example, you might need to compute the mean of some integers given a count and a sum. Because the count and sum are stored in variables of integral type (and you don’t want to truncate fractional values), you’ll want to compute the mean as a floating-point number. To do this, you’ll need to use type conversion.</p>&#13;
<h4 class="h4" id="ch07lev2sec13"><strong><em>Implicit Type Conversions</em></strong></h4>&#13;
<p class="noindent">Implicit type conversions can occur anywhere a particular type is called for but you provide a different type. These conversions occur in several different contexts.</p>&#13;
<p class="indent">“Binary Arithmetic Operators” on <a href="ch07.xhtml#page_183">page 183</a> outlined so-called <em>promotion rules</em>. In fact, these are a form of implicit conversion. Whenever an arithmetic operation occurs, shorter integral types are promoted to <span class="literal">int</span> types. Integral types can also be promoted to floating-point types during arithmetic operation. All of this happens in the background. The result is that, in most situations, the type system simply gets out of your way so you can focus on programming logic.</p>&#13;
<p class="indent">Unfortunately, in some situations, C++ is a bit overzealous in silently converting types. Consider the following implicit conversion from a <span class="literal">double</span> to a <span class="literal">uint_8</span>:</p>&#13;
<pre>#include &lt;cstdint&gt;&#13;
&#13;
int main() {&#13;
  auto x = 2.7182818284590452353602874713527L;&#13;
  uint8_t y = x; // Silent truncation&#13;
}</pre>&#13;
<p class="indent">You should hope that the compiler will generate a warning here, but technically this is valid C++. Because this conversion loses information, it’s a narrowing conversion that would be prevented by braced initialization <span class="literal">{}</span>:</p>&#13;
<pre>#include &lt;cstdint&gt;&#13;
&#13;
int main() {&#13;
<span epub:type="pagebreak" id="page_199"/>  auto x = 2.7182818284590452353602874713527L;&#13;
  uint8_t y{ x }; // Bang!&#13;
}</pre>&#13;
<p class="indent">Recall that braced initialization doesn’t permit narrowing conversions. Technically, the braced initializer is an explicit conversion, so I’ll discuss that in “Explicit Type Conversion” on <a href="ch07.xhtml#page_201">page 201</a>.</p>&#13;
<h5 class="h5" id="ch07lev3sec9"><strong>Floating-Point-to-Integer Conversion</strong></h5>&#13;
<p class="noindent">Floating-point and integral types can coexist peacefully within arithmetic expressions. The reason is implicit type conversion: when the compiler encounters mixed types, it performs the necessary promotions so arithmetic proceeds as expected.</p>&#13;
<h5 class="h5" id="ch07lev3sec10"><strong>Integer-to-Integer Conversion</strong></h5>&#13;
<p class="noindent">Integers can be converted into other integer types. If the destination type is <span class="literal">signed</span>, all is well, as long as the value can be represented. If it cannot, the behavior is implementation defined. If the destination type is <span class="literal">unsigned</span>, the result is as many bits as can fit into the type. In other words, the high-order bits are lost.</p>&#13;
<p class="indent">Consider the example in <a href="ch07.xhtml#ch07ex08">Listing 7-8</a>, which demonstrates how you can get undefined behavior resulting from signed conversion.</p>&#13;
<pre>#include &lt;cstdint&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  // 0b111111111 = 511&#13;
  uint8_t x = 0b111111111; <span class="ent">➊</span>// 255&#13;
  int8_t y =  0b111111111; <span class="ent">➋</span>// Implementation defined.&#13;
  printf("x: %u\ny: %d", x, y);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">x: 255 <span class="ent">➊</span></span>&#13;
<span class="color1">y: -1 <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch07ex08"/><em>Listing 7-8: Undefined behavior resulting from signed conversion</em></p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07ex08">Listing 7-8</a> implicitly casts an integer that is too big to fit in an 8-bit integer (511, or 9 bits of ones) into <span class="literal">x</span> and <span class="literal">y</span>, which are <span class="literal">unsigned</span> and <span class="literal">signed</span>. The value of <span class="literal">x</span> is guaranteed to be 255 <span class="ent">➊</span>, whereas the value of <span class="literal">y</span> is implementation dependent. On a Windows 10 x64 machine, <span class="literal">y</span> equals <span class="literal">-1</span> <span class="ent">➋</span>. The assignment of both <span class="literal">x</span> and <span class="literal">y</span> involve narrowing conversions that could be avoided using the braced initialization syntax.</p>&#13;
<h5 class="h5" id="ch07lev3sec11"><strong>Floating-Point-to-Floating-Point Conversions</strong></h5>&#13;
<p class="noindent">Floating-point numbers can be implicitly cast to and from other floating-point numbers. As long as the destination value can fit the source value, all is well. When it cannot, you have undefined behavior. Again, braced <span epub:type="pagebreak" id="page_200"/>initialization can prevent potentially dangerous conversions. Consider the example in <a href="ch07.xhtml#ch07ex09">Listing 7-9</a>, which demonstrates undefined behavior resulting from a narrowing conversion.</p>&#13;
<pre>#include &lt;limits&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  double x = std::numeric_limits&lt;float&gt;::max(); <span class="ent">➊</span>&#13;
  long double y = std::numeric_limits&lt;double&gt;::max(); <span class="ent">➋</span>&#13;
  float z = std::numeric_limits&lt;long double&gt;::max(); <span class="ent">➌</span>  // Undefined Behavior&#13;
  printf("x: %g\ny: %Lg\nz: %g", x, y, z);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">x: 3.40282e+38</span>&#13;
<span class="color1">y: 1.79769e+308</span>&#13;
<span class="color1">z: inf</span></pre>&#13;
<p class="listing"><a id="ch07ex09"/><em>Listing 7-9: Undefined behavior resulting from narrowing conversion</em></p>&#13;
<p class="indent">You have completely safe implicit conversions from <span class="literal">float</span> to <span class="literal">double</span> <span class="ent">➊</span> and <span class="literal">double</span> to <span class="literal">long double</span> <span class="ent">➋</span> respectively. Unfortunately, assigning the maximum value of a <span class="literal">long double</span> to a <span class="literal">float</span> results in undefined behavior <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch07lev3sec12"><strong>Conversion to bool</strong></h5>&#13;
<p class="noindent">Pointers, integers, and floating-point numbers can all be implicitly converted to <span class="literal">bool</span> objects. If the value is nonzero, the result of implicit conversion is <span class="literal">true</span>. Otherwise, the result is <span class="literal">false</span>. For example, the value <span class="literal">int{ 1 }</span> converts to <span class="literal">true</span>, and the value <span class="literal">int{}</span> converts to <span class="literal">false</span>.</p>&#13;
<h5 class="h5" id="ch07lev3sec13"><strong>Pointer to void*</strong></h5>&#13;
<p class="noindent">Pointers can always be implicitly converted to <span class="literal">void*</span>, as demonstrated in <a href="ch07.xhtml#ch07ex10">Listing 7-10</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
void print_addr(void* x) {&#13;
  printf("0x%p\n", x);&#13;
}&#13;
&#13;
int main() {&#13;
  int x{};&#13;
  print_addr(&amp;x); <span class="ent">➊</span>&#13;
  print_addr(nullptr); <span class="ent">➋</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">0x000000F79DCFFB74 <span class="ent">➊</span></span>&#13;
<span class="color1">0x0000000000000000 <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch07ex10"/><em>Listing 7-10: Implicit pointer conversion to <span class="literal">void*</span>. Output is from a Windows 10 x64 machine.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_201"/><a href="ch07.xhtml#ch07ex10">Listing 7-10</a> compiles thanks to the pointers’ implicit conversion to <span class="literal">void*</span>. The <span class="literal">print_addr</span> function prints the address of <span class="literal">x</span> <span class="ent">➊</span> and the value of <span class="literal">nullptr</span>, <span class="literal">0</span> <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch07lev2sec14"><strong><em>Explicit Type Conversion</em></strong></h4>&#13;
<p class="noindent">Explicit type conversions are also called <em>casts</em>. The first port of call for conducting an explicit type conversion is braced initialization <span class="literal">{}</span>. This approach has the major benefit of being fully type safe and non-narrowing. The use of braced initialization ensures at compile time that only safe, well-behaved, non-narrowing conversions are allowed. <a href="ch07.xhtml#ch07ex11">Listing 7-11</a> shows an example.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
int main() {&#13;
  int32_t a = 100;&#13;
  int64_t b{ a }; <span class="ent">➊</span>&#13;
  if (a == b) printf("Non-narrowing conversion!\n"); <span class="ent">➋</span>&#13;
  //int32_t c{ b }; // Bang! <span class="ent">➌</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Non-narrowing conversion! <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch07ex11"/><em>Listing 7-11: Explicit type conversion for 4- and 8-byte integers</em></p>&#13;
<p class="indent">This simple example uses braced initialization <span class="ent">➊</span> to build an <span class="literal">int64_t</span> from an <span class="literal">int32_t</span>. This is a well-behaved conversion because you’re guaranteed not to have lost any information. You can always store 32 bits inside 64 bits. After a well-behaved conversion of a fundamental type, the original will always equal the result (according to <span class="literal">operator==</span>).</p>&#13;
<p class="indent">The example attempts a badly behaved (narrowing) conversion <span class="ent">➌</span>. The compiler will generate an error. If you hadn’t used the braced initializer <span class="literal">{}</span>, the compiler wouldn’t have complained, as demonstrated in <a href="ch07.xhtml#ch07ex12">Listing 7-12</a>.</p>&#13;
<pre>#include &lt;limits&gt;&#13;
#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
int main() {&#13;
  int64_t b = std::numeric_limits&lt;int64_t&gt;::max();&#13;
  int32_t c(b); <span class="ent">➊</span> // The compiler abides.&#13;
  if (c != b) printf("Narrowing conversion!\n"); <span class="ent">➋</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Narrowing conversion! <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch07ex12"/><em>Listing 7-12: A refactor of <a href="ch07.xhtml#ch07ex11">Listing 7-11</a> without the braced initializer.</em></p>&#13;
<p class="indent">You make a narrowing conversion from a 64-bit integer to a 32-bit integer <span class="ent">➊</span>. Because this narrows, the expression <span class="literal">c != b</span> evaluates to <span class="literal">true</span> <span class="ent">➋</span>. This behavior is very dangerous, which is why <a href="ch02.xhtml#ch02">Chapter 2</a> recommends using the braced initializer as much as possible.</p>&#13;
<h4 class="h4" id="ch07lev2sec15"><span epub:type="pagebreak" id="page_202"/><strong><em>C-Style Casts</em></strong></h4>&#13;
<p class="noindent">Recall from <a href="ch06.xhtml#ch06">Chapter 6</a> that the named conversion functions allow you to perform dangerous casts that braced initialization won’t permit. You can also perform C-style casts, but this is done mainly to maintain some compatibility between the languages. Their usage is as follows:</p>&#13;
<pre>(desired-type)object-to-cast</pre>&#13;
<p class="indent">For each C-style cast, there exists some incantation of <span class="literal">static_casts, const_casts</span>, and <span class="literal">reinterpret_casts</span> that would achieve the desired type conversion. C-style casts are far more dangerous than the named casts (and this is saying quite a bit).</p>&#13;
<p class="indent">The syntax of the C++ explicit casts is intentionally ugly and verbose. This calls attention to a point in the code where the rigid rules of the type system are being bent or broken. The C-style cast doesn’t do this. In addition, it’s not clear from the cast what kind of conversion the programmer is intending. When you use finer instruments like the named casts, the compiler can at least enforce <em>some</em> constraints. For example, it’s all too easy to forget <span class="literal">const</span> correctness when using a C-style cast when you only intended a <span class="literal">reinterpret_cast</span>.</p>&#13;
<p class="indent">Suppose you wanted to treat a <span class="literal">const char*</span> array as unsigned within the body of a function. It would be too easy to write code like that demonstrated in <a href="ch07.xhtml#ch07ex13">Listing 7-13</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
void trainwreck(const char* read_only) {&#13;
  auto as_unsigned = (unsigned char*)read_only;&#13;
  *as_unsigned = 'b'; <span class="ent">➊</span> // Crashes on Windows 10 x64&#13;
}&#13;
&#13;
int main() {&#13;
  auto ezra = "Ezra";&#13;
  printf("Before trainwreck: %s\n", ezra);&#13;
  trainwreck(ezra);&#13;
  printf("After trainwreck: %s\n", ezra);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Before trainwreck: Ezra</span></pre>&#13;
<p class="listing"><a id="ch07ex13"/><em>Listing 7-13: A train wreck of a C-style cast that accidentally gets rid of the <span class="literal">const</span> qualifier on <span class="literal">read_only</span>. (This program has undefined behavior; output is from a Windows 10 x64 machine.)</em></p>&#13;
<p class="indent">Modern operating systems enforce memory access patterns. <a href="ch07.xhtml#ch07ex13">Listing 7-13</a> attempts to write into the memory storing the string literal <span class="literal">Ezra</span> <span class="ent">➊</span>. On Windows 10 x64, this crashes the program with a memory access violation (it’s read-only memory).</p>&#13;
<p class="indent">If you tried this with a <span class="literal">reinterpret_cast</span>, the compiler would generate an error, as <a href="ch07.xhtml#ch07ex14">Listing 7-14</a> demonstrates.</p>&#13;
<pre><span epub:type="pagebreak" id="page_203"/>#include &lt;cstdio&gt;&#13;
&#13;
void trainwreck(const char* read_only) {&#13;
  auto as_unsigned = reinterpret_cast&lt;unsigned char*&gt;(read_only); <span class="ent">➊</span>&#13;
  *as_unsigned = 'b'; // Crashes on Windows 10 x64&#13;
}&#13;
&#13;
int main() {&#13;
  auto ezra = "Ezra";&#13;
  printf("Before trainwreck: %s\n", ezra);&#13;
  trainwreck(ezra);&#13;
  printf("After trainwreck: %s\n", ezra);&#13;
}</pre>&#13;
<p class="listing"><a id="ch07ex14"/><em>Listing 7-14: A refactor of <a href="ch07.xhtml#ch07ex13">Listing 7-13</a> using a <span class="literal">reinterpret_cast</span>. (This code does not compile.)</em></p>&#13;
<p class="indent">If you really intended to throw away <span class="literal">const</span> correctness, you’d need to tack on a <span class="literal">const_cast</span> here <span class="ent">➊</span>. The code would self-document these intentions and make such intentional rule breakages easy to find.</p>&#13;
<h4 class="h4" id="ch07lev2sec16"><strong><em>User-Defined Type Conversions</em></strong></h4>&#13;
<p class="noindent">In user-defined types, you can provide user-defined conversion functions. These functions tell the compiler how your user-defined types behave during implicit and explicit type conversion. You can declare these conversion functions using the following usage pattern:</p>&#13;
<pre>struct MyType {&#13;
  operator destination-type() const {&#13;
    // return a destination-type from here.&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  }&#13;
}</pre>&#13;
<p class="indent">For example, the <span class="literal">struct</span> in <a href="ch07.xhtml#ch07ex15">Listing 7-15</a> can be used like a read-only <span class="literal">int</span>.</p>&#13;
<pre>struct ReadOnlyInt {&#13;
  ReadOnlyInt(int val) : val{ val } { }&#13;
  operator int() const { <span class="ent">➊</span>&#13;
    return val;&#13;
  }&#13;
private:&#13;
  const int val;&#13;
};</pre>&#13;
<p class="listing"><a id="ch07ex15"/><em>Listing 7-15: A <span class="literal">ReadOnlyInt</span> class containing a user-defined type conversion to an <span class="literal">int</span></em></p>&#13;
<p class="indent">The operator <span class="literal">int</span> method at <span class="ent">➊</span> defines the user-defined type conversion <em>from</em> a <span class="literal">ReadOnlyInt</span> <em>to</em> an <span class="literal">int</span>. You can now use <span class="literal">ReadOnlyInt</span> types just like regular <span class="literal">int</span> types thanks to implicit conversion:</p>&#13;
<pre>struct ReadOnlyInt {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
<span epub:type="pagebreak" id="page_204"/>};&#13;
int main() {&#13;
  ReadOnlyInt the_answer{ 42 };&#13;
  auto ten_answers = the_answer * 10; // int with value 420&#13;
}</pre>&#13;
<p class="indent">Sometimes, implicit conversions can cause surprising behavior. You should always try to use explicit conversions, especially with user-defined types. You can achieve explicit conversions with the <span class="literal">explicit</span> keyword. Explicit constructors instruct the compiler not to consider the constructor as a means for implicit conversion. You can provide the same guidelines for your user-defined conversion functions:</p>&#13;
<pre>struct ReadOnlyInt {&#13;
  ReadOnlyInt(int val) : val{ val } { }&#13;
  explicit operator int() const {&#13;
    return val;&#13;
  }&#13;
private:&#13;
  const int val;&#13;
};</pre>&#13;
<p class="indent">Now, you must explicitly cast a <span class="literal">ReadOnlyInt</span> to an <span class="literal">int</span> using <span class="literal">static_cast</span>:</p>&#13;
<pre>struct ReadOnlyInt {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
int main() {&#13;
  ReadOnlyInt the_answer{ 42 };&#13;
  auto ten_answers = static_cast&lt;int&gt;(the_answer) * 10;&#13;
}</pre>&#13;
<p class="indent">Generally, this approach tends to promote less ambiguous code.</p>&#13;
<h3 class="h3" id="ch07lev1sec4"><strong>Constant Expressions</strong></h3>&#13;
<p class="noindent">Constant expressions are expressions that can be evaluated at compile time. For performance and safety reasons, whenever a computation can be done at compile time rather than runtime, you should do it. Simple mathematical operations involving literals are an obvious example of expressions that can be evaluated at compile time.</p>&#13;
<p class="indent">You can extend the reach of the compiler by using the expression <span class="literal">constexpr</span>. Whenever all the information required to compute an expression is present at compile time, the compiler is <em>compelled to do so</em> if that expression is marked <span class="literal">constexpr</span>. This simple commitment can enable a surprisingly large impact on code readability and runtime performance.</p>&#13;
<p class="indent">Both <span class="literal">const</span> and <span class="literal">constexpr</span> are closely related. Whereas <span class="literal">constexpr</span> enforces that an expression is compile time evaluable, <span class="literal">const</span> enforces that a variable cannot change within some scope (at runtime). All <span class="literal">constexpr</span> expressions are <span class="literal">const</span> because they’re always fixed at runtime.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_205"/>All <span class="literal">constexpr</span> expressions begin with one or more fundamental types (<span class="literal">int, float, wchar_t</span>, and so on). You can build on top of these types by using operators and <span class="literal">constexpr</span> functions. Constant expressions are used mainly to replace manually computed values in your code. This generally produces code that is more robust and easier to understand, because you can eliminate so-called <em>magic values</em>—manually calculated constants copy and pasted directly into source code.</p>&#13;
<h4 class="h4" id="ch07lev2sec17"><strong><em>A Colorful Example</em></strong></h4>&#13;
<p class="noindent">Consider the following example where some library you’re using for your project uses <span class="literal">Color</span> objects that are encoded using the hue-saturation-value (HSV) representation:</p>&#13;
<pre>struct Color {&#13;
  float H, S, V;&#13;
};</pre>&#13;
<p class="indent">Very roughly, hue corresponds with a family of colors like red, green, or orange. Saturation corresponds with colorfulness or intensity. Value corresponds with the color’s brightness.</p>&#13;
<p class="indent">Suppose you want to instantiate <span class="literal">Color</span> objects using red-green-blue (RGB) representations. You could use a converter to calculate the RGB to HSV manually, but this is a prime example where you can use <span class="literal">constexpr</span> to eliminate magic values. Before you can write the conversion function, you need a few utility functions, namely <span class="literal">min, max</span>, and <span class="literal">modulo</span>. <a href="ch07.xhtml#ch07ex16">Listing 7-16</a> implements these functions.</p>&#13;
<pre>#include &lt;cstdint&gt;&#13;
constexpr uint8_t max(uint8_t a, uint8_t b) { <span class="ent">➊</span>&#13;
  return a &gt; b ? a : b;&#13;
}&#13;
constexpr uint8_t max(uint8_t a, uint8_t b, uint8_t c) { <span class="ent">➋</span>&#13;
  return max(max(a, b), max(a, c));&#13;
}&#13;
constexpr uint8_t min(uint8_t a, uint8_t b) { <span class="ent">➌</span>&#13;
  return a &lt; b ? a : b;&#13;
}&#13;
constexpr uint8_t min(uint8_t a, uint8_t b, uint8_t c) { <span class="ent">➍</span>&#13;
  return min(min(a, b), min(a, c));&#13;
}&#13;
constexpr float modulo(float dividend, float divisor) { <span class="ent">➎</span>&#13;
  const auto quotient = dividend / divisor; <span class="ent">➏</span>&#13;
  return divisor * (quotient - static_cast&lt;uint8_t&gt;(quotient));&#13;
}</pre>&#13;
<p class="listing"><a id="ch07ex16"/><em>Listing 7-16: Several <span class="literal">constexpr</span> functions for manipulating <span class="literal">uint8_t</span> objects</em></p>&#13;
<p class="indent">Each function is marked <span class="literal">constexpr</span>, which tells the compiler that the function must be evaluable at compile time. The <span class="literal">max</span> function <span class="ent">➊</span> uses the ternary operator to return the value of the argument that is greatest. The <span epub:type="pagebreak" id="page_206"/>three-argument version of <span class="literal">max</span> <span class="ent">➋</span> uses the transitive property of comparison; by evaluating the two-argument <span class="literal">max</span> for the pairs <span class="literal">a, b</span> and <span class="literal">a, c</span>, you can find the max of this intermediate result to find the overall max. Because the two-argument version of max is <span class="literal">constexpr</span>, this is totally legal.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can’t use <span class="literal">fmax</span> from the <span class="literal">&lt;math.h&gt;</span> header for the same reason: it’s not <span class="literal">constexpr</span>.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">min</span> versions <span class="ent">➌</span> <span class="ent">➍</span> follow exactly with the obvious modification that the comparison is flipped. The <span class="literal">modulo</span> function <span class="ent">➎</span> is a quick-and-dirty, <span class="literal">constexpr</span> version of the C function <span class="literal">fmod</span>, which computes the floating-point remainder of dividing the first argument (<span class="literal">dividend</span>) by the second argument (<span class="literal">divisor</span>). Because <span class="literal">fmod</span> is <em>not</em> <span class="literal">constexpr</span>, you’ve hand-rolled your own. First, you obtain the quotient <span class="ent">➏</span>. Next, you subtract the integral part of quotient using a <span class="literal">static_cast</span> and a subtraction. Multiplying the decimal portion of the quotient by <span class="literal">divisor</span> yields the result.</p>&#13;
<p class="indent">With a collection of <span class="literal">constexpr</span> utility functions in your arsenal, you can now implement your conversion function <span class="literal">rgb_to_hsv</span>, as demonstrated in <a href="ch07.xhtml#ch07ex17">Listing 7-17</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
constexpr Color rgb_to_hsv(uint8_t r, uint8_t g, uint8_t b) {&#13;
  Color c{}; <span class="ent">➊</span>&#13;
  const auto c_max = max(r, g, b);&#13;
  c.V = c_max / 255.0f; <span class="ent">➋</span>&#13;
&#13;
  const auto c_min = min(r, g, b);&#13;
  const auto delta = c.V - c_min / 255.0f;&#13;
  c.S = c_max == 0 ? 0 : delta / c.V; <span class="ent">➌</span>&#13;
&#13;
  if (c_max == c_min) { <span class="ent">➍</span>&#13;
    c.H = 0;&#13;
    return c;&#13;
  }&#13;
  if (c_max == r) {&#13;
    c.H = (g / 255.0f - b / 255.0f) / delta;&#13;
  } else if (c_max == g) {&#13;
    c.H = (b / 255.0f - r / 255.0f) / delta + 2.0f;&#13;
  } else if (c_max == b) {&#13;
    c.H = (r / 255.0f - g / 255.0f) / delta + 4.0f;&#13;
  }&#13;
  c.H *= 60.0f;&#13;
  c.H = c.H &gt;= 0.0f ? c.H : c.H + 360.0f;&#13;
  c.H = modulo(c.H, 360.0f); <span class="ent">➎</span>&#13;
  return c;&#13;
}</pre>&#13;
<p class="listing"><a id="ch07ex17"/><em>Listing 7-17: A <span class="literal">constexpr</span> conversion function from RGB to HSV</em></p>&#13;
<p class="indent">You’ve declared and initialized <span class="literal">Color c</span> <span class="ent">➊</span>, which will eventually get returned by <span class="literal">rgb_to_hsv</span>. The value of the <span class="literal">Color, V</span>, is computed at <span class="ent">➋</span> by scaling the maximum value of <span class="literal">r, g</span>, and <span class="literal">b</span>. Next, the saturation <span class="literal">S</span> is calculated by computing the distance between the minimum and maximum RGB <span epub:type="pagebreak" id="page_207"/>values and scaling by <span class="literal">V</span> <span class="ent">➌</span>. If you imagine the HSV values as existing inside a cylinder, <em>saturation</em> is the distance along the horizontal axis and <em>value</em> is the distance along the vertical axis. <em>Hue</em> is the angle. For brevity, I won’t go into detail about how this angle is computed, but the calculation is implemented between <span class="ent">➍</span> and <span class="ent">➎</span>. Essentially, it entails computing the angle as an offset from the dominant color component’s angle. This is scaled and modulo-ed to fit on the 0- to 360-degree interval and stored into <span class="literal">H</span>. Finally, <span class="literal">c</span> is returned.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For an explanation of the formula used to convert HSV to RGB, refer to <a href="https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae</a>.</em></p>&#13;
</div>&#13;
<p class="indent">There’s quite a bit going on here, but it’s all computed at compile time. This means when you initialize colors, the compiler initializes a <span class="literal">Color</span> with all of the HSV field floats filled in:</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  auto black   = rgb_to_hsv(0,     0,   0);&#13;
  auto white   = rgb_to_hsv(255, 255, 255);&#13;
  auto red     = rgb_to_hsv(255,   0,   0);&#13;
  auto green   = rgb_to_hsv(  0, 255,   0);&#13;
  auto blue    = rgb_to_hsv(  0,   0, 255);&#13;
  // TODO: Print these, output.&#13;
}</pre>&#13;
<p class="indent">You’ve told the compiler that each of these color values is compile-time evaluable. Depending on how you use these values within the rest of the program, the compiler can decide whether or not to evaluate them at compile time or runtime. The upshot is that the compiler can usually emit instructions with hardcoded <em>magic numbers</em> corresponding to the correct HSV values for each <span class="literal">Color</span>.</p>&#13;
<h4 class="h4" id="ch07lev2sec18"><strong><em>The Case for constexpr</em></strong></h4>&#13;
<p class="noindent">There are some restrictions on what sorts of functions can be <span class="literal">constexpr</span>, but these restrictions have been relaxed with each new C++ version.</p>&#13;
<p class="indent">In certain contexts, like embedded development, <span class="literal">constexpr</span> is indispensable. In general, if an expression can be declared <span class="literal">constexpr</span>, you should strongly consider doing so. Using <span class="literal">constexpr</span> rather than manually calculated literals can make your code more expressive. Often, it can also seriously boost performance and safety at runtime.</p>&#13;
<h3 class="h3" id="ch07lev1sec5"><strong>Volatile Expressions</strong></h3>&#13;
<p class="noindent">The <span class="literal">volatile</span> keyword tells the compiler that every access made through this expression must be treated as a visible side effect. This means access cannot be optimized out or reordered with another visible side effect. This keyword is crucial in some settings, like embedded programming, <span epub:type="pagebreak" id="page_208"/>where reads and writes to some special portions of memory have effects on the underlying system. The <span class="literal">volatile</span> keyword keeps the compiler from optimizing such accesses away.  <a href="ch07.xhtml#ch07ex18">Listing 7-18</a> illustrates why you might need the <span class="literal">volatile</span> keyword by containing instructions that the compiler would normally optimize away.</p>&#13;
<pre>int foo(int&amp; x) {&#13;
  x = 10; <span class="ent">➊</span>&#13;
  x = 20; <span class="ent">➋</span>&#13;
  auto y = x; <span class="ent">➌</span>&#13;
  y = x; <span class="ent">➍</span>&#13;
  return y;&#13;
}</pre>&#13;
<p class="listing"><a id="ch07ex18"/><em>Listing 7-18: A function containing a dead store and a redundant load</em></p>&#13;
<p class="indent">Because <span class="literal">x</span> is assigned <span class="ent">➊</span> but never used before getting reassigned <span class="ent">➋</span>, it’s called a <em>dead store</em> and is a straightforward candidate for getting optimized away. There’s a similar story where <span class="literal">x</span> is used to set the value of <span class="literal">y</span> twice without any intervening instructions <span class="ent">➌➍</span>. This is called a <em>redundant load</em> and is also a candidate for optimization.</p>&#13;
<p class="indent">You might expect any decent compiler to optimize the preceding function into something resembling <a href="ch07.xhtml#ch07ex19">Listing 7-19</a>.</p>&#13;
<pre>int foo(int&amp; x) {&#13;
  x = 20;&#13;
  return x;&#13;
}</pre>&#13;
<p class="listing"><a id="ch07ex19"/><em>Listing 7-19: A plausible optimization of <a href="ch07.xhtml#ch07ex18">Listing 7-18</a></em></p>&#13;
<p class="indent">In some settings, the redundant reads and dead stores might have visible side effects on the system. By adding the <span class="literal">volatile</span> keyword to the argument of <span class="literal">foo</span>, you can avoid the optimizer getting rid of these important accesses, as demonstrated in <a href="ch07.xhtml#ch07ex20">Listing 7-20</a>.</p>&#13;
<pre>int foo(volatile int&amp; x) {&#13;
  x = 10;&#13;
  x = 20;&#13;
  auto y = x;&#13;
  y = x;&#13;
  return y;&#13;
}</pre>&#13;
<p class="listing"><a id="ch07ex20"/><em>Listing 7-20: A <span class="literal">volatile</span> modification of <a href="ch07.xhtml#ch07ex18">Listing 7-18</a></em></p>&#13;
<p class="indent">Now the compiler will emit instructions to perform each of the reads and writes you’ve programmed.</p>&#13;
<p class="indent">A common misconception is that <span class="literal">volatile</span> has to do with concurrent programming. It does not. Variables marked <span class="literal">volatile</span> are not generally thread safe. <a href="part02.xhtml#part02">Part II</a> discusses <span class="literal">std::atomic</span>, which guarantees certain thread safe primitives on types. Too often, <span class="literal">volatile</span> is confused with <span class="literal">atomic</span>!</p>&#13;
<h3 class="h3" id="ch07lev1sec6"><strong><span epub:type="pagebreak" id="page_209"/>Summary</strong></h3>&#13;
<p class="noindent">This chapter covered the major features of operators, which are the fundamental units of work in a program. You explored several aspects of type conversions and took control of dynamic memory management from the environment. You were also introduced to <span class="literal">constexpr</span>/<span class="literal">volatile</span> expressions. With these tools in hand, you can perform almost any system-programming task.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>7-1.</strong> Create an <span class="literal">UnsignedBigInteger</span> class that can handle numbers bigger than a <span class="literal">long</span>. You can use a byte array as the internal representation (for example, <span class="literal">uint8_t[]</span> or <span class="literal">char[]</span>). Implement operator overloads for <span class="literal">operator+</span> and <span class="literal">operator-</span>. Perform runtime checks for overflow. For the intrepid, also implement <span class="literal">operator*, operator/</span>, and <span class="literal">operator%</span>. Make sure that your operator overloads work for both <span class="literal">int</span> types and <span class="literal">UnsignedBigInteger</span> types. Implement an <span class="literal">operator int</span> type conversion. Perform a runtime check if narrowing would occur.</p>&#13;
<p class="noindent"><strong>7-2.</strong> Create a <span class="literal">LargeBucket</span> class that can store up to 1MB of data. Extend the  <span class="literal">Heap</span> class so it gives out a  <span class="literal">LargeBucket</span> for allocations greater than 4096 bytes. Make sure that you still throw  <span class="literal">std::bad_alloc</span> whenever the  <span class="literal">Heap</span> is unable to allocate an appropriately sized bucket.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland; <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>