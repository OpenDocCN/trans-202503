- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Persistence
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 持续性
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Once malware has successfully gained access to a system, its next goal is usually
    to persist. *Persistence* is the means by which malware installs itself on a system
    to ensure it will automatically re-execute upon startup, user login, or some other
    deterministic event. The vast majority of Mac malware attempts to gain persistence;
    otherwise, a system reboot may act as its death knell.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件成功入侵系统，它的下一个目标通常是保持持久性。*持久性*是恶意软件通过在系统中安装自身来确保其在启动时、用户登录时或其他确定性事件发生时自动重新执行的手段。绝大多数
    Mac 恶意软件都试图获得持久性，否则系统重启可能会成为它的终结。
- en: Of course, not all malware persists. One notable kind of malware that generally
    doesn’t persist is *ransomware*, a type of malicious code that encrypts user files
    and then demands a ransom in order to restore the files. Once the malware has
    encrypted the user’s files and provided ransom instructions, there’s no need for
    it to hang around. Similarly, sophisticated attackers may leverage memory-only
    payloads that, by design, won’t survive a system reboot. The appeal? An incredibly
    high level of stealth.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有恶意软件都会保持持久性。有一种特别的恶意软件通常不会保持持久性，即*勒索软件*，这是一种加密用户文件并要求赎金以恢复文件的恶意代码。一旦恶意软件加密了用户的文件并提供了赎金说明，就没有必要继续停留在系统中。类似地，复杂的攻击者可能会利用仅存在于内存中的有效负载，这些有效负载设计上不会在系统重启后存活。其吸引力在于？极高的隐蔽性。
- en: Still, the majority of malware persists in some manner. Modern operating systems,
    including macOS, provide various ways for legitimate software to persist. Security
    tools, updaters, and other programs often make use of such mechanisms to ensure
    they restart automatically each time the system is rebooted. Throughout the years,
    malware authors have leveraged these same mechanisms to continuously execute their
    malicious creations. In this chapter, we’ll discuss the persistence mechanisms
    that Mac malware frequently abuses (or in a few cases, could abuse). Where applicable,
    we’ll highlight actual malicious specimens that leverage each persistence technique.
    Armed with a comprehensive understanding of these methods, you should be able
    to more effectively analyze Mac malware, as well as uncover persistent malware
    on an infected system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，大多数恶意软件以某种方式保持持久性。现代操作系统，包括 macOS，提供了多种方式让合法软件保持持久性。安全工具、更新程序和其他程序通常会利用这些机制，确保它们在每次系统重启时自动重新启动。多年来，恶意软件作者也利用这些相同的机制不断执行他们的恶意创作。在本章中，我们将讨论
    Mac 恶意软件常常滥用的持久性机制（或者在少数情况下，可能滥用的机制）。在适用的情况下，我们将重点介绍利用每种持久性技术的实际恶意样本。通过全面了解这些方法，你应该能够更有效地分析
    Mac 恶意软件，并且在感染系统上发现持久性恶意软件。
- en: Login Items
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录项
- en: If an application should be automatically executed each time the user logs in,
    Apple recommends installing it as a *login item*. Login items run within the user’s
    desktop session, inheriting the user’s permissions, and start automatically at
    user login. Due to this afforded persistence, Mac malware will commonly install
    itself as a login item. You can find examples of this technique in malware like
    Kitm, NetWire, and WindTail.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个应用程序应该在用户每次登录时自动执行，Apple 推荐将其安装为*登录项*。登录项在用户的桌面会话中运行，继承用户的权限，并在用户登录时自动启动。由于这种持久性，Mac
    恶意软件通常会将自己安装为登录项。你可以在像 Kitm、NetWire 和 WindTail 这样的恶意软件中找到这一技术的示例。
- en: You can view login items in the System Preferences application. Select the **Login
    Items** tab of the **Users & Groups** pane ([Figure 2-1](#figure2-1)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在“系统偏好设置”应用中查看登录项。选择**用户与群组**面板中的**登录项**标签页（[图 2-1](#figure2-1)）。
- en: '![<< The Users & Groups pane of Mac’s System Preferences application, in which
    Login Items is selected and shows items that open automatically when the user
    logs in. The Finder application is the only login item listed here.>>](image_fi/501942c02/f02001.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![<< Mac 系统偏好设置中的“用户与群组”面板，其中选中了“登录项”，并显示了用户登录时自动打开的项目。Finder 应用是这里列出的唯一登录项。>>](image_fi/501942c02/f02001.png)'
- en: 'Figure 2-1: Persistent login items. The Finder item is actually malware (NetWire).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：持久化的登录项。Finder 项目实际上是恶意软件（NetWire）。
- en: Unfortunately, as macOS doesn’t readily show the full path to a persisted login
    item in its interface (unless you hover over the item for a few seconds), malware
    will often successfully masquerade as legitimate software. For example, in [Figure
    2-1](#figure2-1), the Finder item is actually malware, known as NetWire, persisting
    as a login item.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于 macOS 并不直接在其界面中显示持久化登录项的完整路径（除非你将鼠标悬停在该项上几秒钟），恶意软件通常能够成功伪装成合法软件。例如，在
    [Figure 2-1](#figure2-1) 中，Finder 项实际上是恶意软件，名为 NetWire，作为登录项持久存在。
- en: Apple’s `backgroundtaskmanagementagent` program, which manages various background
    tasks such as login items, stores these items in a file named *backgrounditems.btm*.
    For more technical details on this file and its format, see my blog post “Block
    Blocking Login Items.”^([1](#-endnote-1))
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Apple 的 `backgroundtaskmanagementagent` 程序负责管理各种后台任务，如登录项，它将这些项目存储在名为 *backgrounditems.btm*
    的文件中。有关此文件及其格式的更多技术细节，请参阅我关于“阻止登录项的博客”文章。^([1](#-endnote-1))
- en: To programmatically create a login item, software can invoke various shared
    file list (`LSSharedFileList*`) APIs. For example, the `LSSharedFileListCreate`
    function returns a reference to the list of existing login items. This list can
    then be passed to the `LSSharedFileListInsertItemURL` function, along with the
    path of a new application you want to persist as a login item. To illustrate this
    concept, take a look at the following decompiled code from the NetWire malware.
    The malware has copied itself to *~/.defaults/Finder.app* and now is persisting
    as a login item,ensuring that each time the user logs in, macOS will automatically
    execute it ([Listing 2-1](#listing2-1)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以编程方式创建登录项，软件可以调用各种共享文件列表（`LSSharedFileList*`）API。例如，`LSSharedFileListCreate`
    函数返回现有登录项列表的引用。然后，可以将该列表传递给 `LSSharedFileListInsertItemURL` 函数，并提供要作为登录项持久化的新应用程序的路径。为了说明这一概念，请查看以下来自
    NetWire 恶意软件的反编译代码。该恶意软件已将自己复制到 *~/.defaults/Finder.app*，并作为登录项持久存在，确保每次用户登录时，macOS
    会自动执行它（[Listing 2-1](#listing2-1)）。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 2-1: Login item persistence (NetWire)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-1: 登录项持久化（NetWire）'
- en: In this code snippet, the malware first constructs the full path to its location
    on disk 1. It then invokes various `LSSharedFileList*` APIs to install itself
    as a login item 2. Persistence achieved!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，恶意软件首先构建其在磁盘 1 上的位置的完整路径。然后，它调用多个 `LSSharedFileList*` API，将自己安装为登录项
    2。持久性实现！
- en: WindTail is another malware specimen that persists as a login item. By means
    of macOS’s `nm` utility, you can view the imported APIs a binary invokes, including,
    in this case, those related to persistence ([Listing 2-2](#listing2-2)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: WindTail 是另一种作为登录项持久存在的恶意软件。通过 macOS 的 `nm` 工具，你可以查看二进制文件调用的导入 API，包括在这种情况下与持久性相关的
    API（[Listing 2-2](#listing2-2)）。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 2-2: Imports, including `LSSharedFileList*` APIs (WindTail)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-2: 导入，包括 `LSSharedFileList*` API（WindTail）'
- en: In the output from the `nm` utility, note that WindTail contains references
    to both the `LSSharedFileListCreate` and `LSSharedFileListInsertItemURL` APIs,
    which it invokes in order to ensure it will be automatically started each time
    the user logs in.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `nm` 工具的输出中，注意到 WindTail 包含对 `LSSharedFileListCreate` 和 `LSSharedFileListInsertItemURL`
    API 的引用，它调用这些 API 以确保每次用户登录时都会自动启动。
- en: Recent versions of macOS also support application-specific helper login items.
    Found within the *LoginItems* subdirectory of an application’s bundle, these helpers
    can ensure that they will be automatically re-executed whenever the user logs
    in, by invoking the `SMLoginItemSetEnabled` API. Unfortunately, these helper login
    items do not show up in the aforementioned System Preferences pane, making them
    even harder to detect. For more information on these helper login items, see the
    “Modern Login Items” blog post or Apple’s documentation on the topic.^([2](#-endnote-2))
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: macOS 的最新版本还支持特定应用程序的辅助登录项。这些辅助项位于应用程序包的 *LoginItems* 子目录中，它们可以通过调用 `SMLoginItemSetEnabled`
    API 来确保在用户登录时会自动重新执行。不幸的是，这些辅助登录项不会出现在前述的系统偏好设置面板中，使得它们更难以检测。如需了解有关这些辅助登录项的更多信息，请参见“现代登录项”博客文章或
    Apple 关于该主题的文档。^([2](#-endnote-2))
- en: Launch Agents and Daemons
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动代理和守护进程
- en: While Apple offers login items as a way to persist applications, it also has
    a mechanism called *launch items* for persisting non-application binaries, such
    as software updaters and background processes. As the majority of Mac malware
    seeks to run surreptitiously in the background, it’s no surprise that most Mac
    malware leverages launch items in order to persist. In fact, according to my “Mac
    Malware of 2019” report, every piece of analyzed malware in that year that chose
    to persist did so as a launch item.^([3](#-endnote-3)) These specimens include
    NetWire, Siggen, GMERA, and many more.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然苹果提供登录项作为持久化应用程序的一种方式，但它也有一个机制，称为*启动项*，用于持久化非应用程序二进制文件，如软件更新程序和后台进程。由于大多数Mac恶意软件试图在后台偷偷运行，因此大多数Mac恶意软件利用启动项来实现持久化也就不足为奇了。事实上，根据我撰写的《2019年Mac恶意软件报告》，2019年所有选择持久化的恶意软件都作为启动项执行。^([3](#-endnote-3))
    这些样本包括NetWire、Siggen、GMERA等。
- en: 'There are two kinds of launch items: launch agents and launch daemons. *Launch
    daemons* are non-interactive and are often launched before user login. In addition,
    they run with root permissions. An example of such a daemon is Apple’s software
    updater, `softwareupdated`. On the other hand, *launch agents* run once the user
    has logged in with standard user permissions, and they may interact with the user
    session. Apple’s `NotificationCenter` program, which handles displaying notifications
    to the user, runs as a persistent launch agent.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 启动项有两种类型：启动代理和启动守护进程。*启动守护进程*是非交互式的，通常在用户登录之前启动。此外，它们以root权限运行。一个例子是苹果的软件更新程序`softwareupdated`。另一方面，*启动代理*在用户登录后以标准用户权限运行，并且可能与用户会话进行交互。苹果的`NotificationCenter`程序处理向用户显示通知，作为一个持久化的启动代理运行。
- en: You’ll find third-party launch daemons stored in macOS’s */Library/LaunchDaemons*
    directory, and third-party launch agents are stored in either the */Library/LaunchAgents*
    or *~/Library/LaunchAgents* directory. To persist as a launch item, a launch item
    property list should be created in one of these directories. A property list,
    or *plist*, is an XML, JSON, or binary file that contains key/value pairs that
    may store data such as configuration information, settings, serialized objects,
    and more. These files are ubiquitous in macOS. In fact, we already explored applications’
    *Info.plist* files in Chapter 1. To view the contents of a property list file,
    regardless of its format, use either of the following utilities ([Listing 2-3](#listing2-3)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在macOS的*/Library/LaunchDaemons*目录中找到第三方启动守护进程，第三方启动代理则存储在*/Library/LaunchAgents*或*~/Library/LaunchAgents*目录中。为了持久化为启动项，启动项属性列表应当被创建在这些目录中的一个。属性列表，或称*plist*，是一种XML、JSON或二进制文件，包含键/值对，用于存储如配置信息、设置、序列化对象等数据。这些文件在macOS中无处不在。事实上，我们在第一章已经探索过应用程序的*Info.plist*文件。要查看属性列表文件的内容，无论其格式如何，请使用以下任一工具（[列表
    2-3](#listing2-3)）。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 2-3: macOS utilities for parsing *.plist* files'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-3：解析*.plist*文件的macOS工具
- en: 'A launch item’s property list file describes the launch item to `launchd`,
    the system daemon responsible for processing such plists. In terms of persistence,
    the most pertinent key/value pairs include:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 启动项的属性列表文件描述了该启动项，以供负责处理此类plist文件的系统守护进程`launchd`使用。在持久化方面，最相关的键/值对包括：
- en: '`Label`: A name that identifies the launch item. It’s usually written in reverse
    domain name notation, `com.``companyName``.``itemName`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`：用于标识启动项的名称。通常以反向域名表示法书写，`com.``companyName``.``itemName`。'
- en: '`Program` or `ProgramArguments`: Contains the path to the launch item’s executable
    script or binary. Arguments to be passed to this executable item are optional,
    but they can be specified if using the `ProgramArguments` key.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program`或`ProgramArguments`：包含启动项可执行脚本或二进制文件的路径。要传递给此可执行项的参数是可选的，但如果使用`ProgramArguments`键，可以指定这些参数。'
- en: '`RunAtLoad`: Contains a Boolean that, if set to `true`, instructs `launchd`
    to automatically start the launch item. If the item is a launch daemon, it will
    be started during system initialization. On the other hand, as launch agents are
    user-specific, they will be started later, once the user has initiated the login
    process.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RunAtLoad`：包含一个布尔值，如果设置为`true`，则指示`launchd`自动启动该启动项。如果该项是启动守护进程，它将在系统初始化时启动。另一方面，由于启动代理是特定于用户的，它们会在用户启动登录过程后再启动。'
- en: These three key/value pairs are enough to create a persistent launch item. To
    demonstrate this, let’s create a launch item named `com.foo.bar` ([Listing 2-4](#listing2-4)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个键值对足以创建一个持久的启动项。为了演示这一点，让我们创建一个名为`com.foo.bar`的启动项（[清单 2-4](#listing2-4)）。
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 2-4: An example launch item property list'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-4：一个示例的启动项属性列表
- en: 'By means of the `ProgramArguments` array, this launch item instructs `launchd`
    to execute the file */Users/user/launchItem* with two command line arguments:
    `foo` and `bar`. As the `RunAtLoad` key is set to `true` 1, this file will be
    automatically executed, even before a user logs in. For a comprehensive discussion
    of all things related to launch items, including plists and their key/value pairs,
    see “A Launchd Tutorial” or “Getting Started with Launchd.”^([4](#-endnote-4))
    These resources include discussions of other key/value pairs (beyond `RunAtLoad`)
    that may be used by persistent malware, such as `PathState` and `StartCalendarInterval`.
    As malware persisting as launch items is rather ubiquitous, let’s now look at
    a few examples.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ProgramArguments`数组，这个启动项指示`launchd`执行文件*/Users/user/launchItem*，并带有两个命令行参数：`foo`和`bar`。由于`RunAtLoad`键设置为`true`
    1，这个文件将在用户登录之前自动执行。关于启动项的所有相关讨论，包括plist及其键值对的综述，请参阅“一个Launchd教程”或“入门Launchd”。^([4](#-endnote-4))
    这些资源包括讨论其他键值对（超出`RunAtLoad`）的内容，这些键值对可能被持久恶意软件使用，例如`PathState`和`StartCalendarInterval`。由于作为启动项持久存在的恶意软件相当普遍，现在让我们看几个示例。
- en: Earlier in this chapter, we showed how NetWire persists as a login item. Interestingly,
    it also persists as a launch agent. If victims find and remove one persistence
    mechanism, they may assume it’s the only such mechanism and overlook the other.
    Thus, the malware will continue to automatically restart each time the user logs
    in. Examining the malware’s binary reveals an embedded property list template
    at address `0x0000db60` ([Listing 2-5](#listing2-5)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面部分，我们展示了NetWire作为登录项持久存在的方式。有趣的是，它也作为一个启动代理持久存在。如果受害者找到并移除了一个持久化机制，他们可能会假设这是唯一的机制，并忽视其他机制。因此，恶意软件将会在用户每次登录时自动重新启动。检查恶意软件的二进制代码会在地址`0x0000db60`处发现一个嵌入的属性列表模板（[清单
    2-5](#listing2-5)）。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 2-5: A launch item property list template (NetWire)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-5：一个启动项属性列表模板（NetWire）
- en: At install time, the malware will dynamically populate this plist template by,
    for example, replacing the `%s` in the `ProgramArguments` array with a path to
    the malware’s binary on the infected system. As the `RunAtLoad` key is set to
    `true` 1, macOS will start this binary any time the system reboots and the user
    logs in.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装时，恶意软件将动态填充这个plist模板，例如，通过用感染系统上恶意软件二进制文件的路径替换`ProgramArguments`数组中的`%s`。由于`RunAtLoad`键设置为`true`
    1，macOS会在系统重新启动并且用户登录时启动此二进制文件。
- en: The following snippet of decompiled code from NetWire shows that, once it has
    configured the launch agent property list, this property list is written out to
    the user’s launch agent directory, *~/Library/LaunchAgents* ([Listing 2-6](#listing2-6)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: NetWire的反编译代码片段显示，一旦它配置了启动代理属性列表，这个属性列表就会被写入用户的启动代理目录*~/Library/LaunchAgents*（[清单
    2-6](#listing2-6)）。
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 2-6: Launch agent persistence logic (NetWire)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-6：启动代理持久化逻辑（NetWire）
- en: In the decompiled code, you can see the malware first invoking the `getenv`
    API to get the value of the `HOME` environment variable, which is set to the current
    user’s home directory. This value is then passed to the `snprintf_chk` API to
    dynamically build the path to the user’s *LaunchAgents* directory 1. The malware
    then invokes `snprintf_chk` again to append the name of the property list file
    2. As this name gets decrypted by the malware at runtime, it doesn’t show up as
    a plaintext string in [Listing 2-6](#listing2-6).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在反编译的代码中，您可以看到恶意软件首先调用`getenv` API来获取`HOME`环境变量的值，该值设置为当前用户的主目录。然后将此值传递给`snprintf_chk`
    API来动态构建到用户*LaunchAgents*目录的路径 1。然后，恶意软件再次调用`snprintf_chk`来追加属性列表文件的名称 2。由于此名称在运行时由恶意软件解密，因此在[清单
    2-6](#listing2-6)中不显示为明文字符串。
- en: Once the malware has constructed a full path, it writes out the dynamically
    configured plist 3. After the code has executed, you can inspect the *.plist*
    file *(~/Library/LaunchAgents/com.mac.host.plist*) via a tool such as macOS’s
    `defaults` ([Listing 2-7](#listing2-7)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件构建了完整的路径，它就会写出动态配置的plist 3。在代码执行之后，你可以通过macOS的`defaults`工具检查*.plist*文件（*~/Library/LaunchAgents/com.mac.host.plist*）（[清单
    2-7](#listing2-7)）。
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 2-7: A malicious launch item property list (NetWire)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-7：一个恶意的启动项属性列表（NetWire）
- en: 'Notice from the output that the path to the persistent component of the malware
    can be found in the `ProgramArguments` array: */Users/user/.defaults/Finder.app/Contents/MacOS/Finder*.
    As noted, the malware programmatically determines the current user’s home directory
    at runtime, because this directory name is likely unique to each infected system.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，恶意软件持久化组件的路径可以在`ProgramArguments`数组中找到：*/Users/user/.defaults/Finder.app/Contents/MacOS/Finder*。如前所述，恶意软件在运行时通过编程确定当前用户的主目录，因为这个目录名称很可能在每个被感染的系统中都是唯一的。
- en: In order to hide to some extent, NetWire installs its persistent binary, *Finder*,
    into a directory it creates, named *.defaults*. Normally, macOS won’t display
    directories that begin with a period. Thus, the malware may remain hidden from
    the majority of unsuspecting users. (You can instruct Finder to show such hidden
    files by pressing command-shift-space [⌘-⇧-space] or using the `ls` command with
    the `-a` option in the Terminal.) You can also see that in the *.plist* file the
    `RunAtLoad` key is set to `1` (true), which instructs the system to automatically
    start the malware’s binary each time the user logs in. Persistence achieved!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在一定程度上隐藏自己，NetWire将其持久化二进制文件*Finder*安装到它创建的一个名为*.defaults*的目录中。通常，macOS不会显示以句点开头的目录。因此，恶意软件可能会对大多数毫无察觉的用户保持隐藏状态。（你可以通过按下command-shift-space
    [⌘-⇧-space] 或在终端中使用`ls`命令并加上`-a`选项来显示这些隐藏文件。）你还可以看到，在*.plist*文件中，`RunAtLoad`键被设置为`1`（true），这指示系统在每次用户登录时自动启动恶意软件的二进制文件。持久性实现！
- en: Another example of a Mac malware specimen that persists as a launch item is
    GMERA. Distributed as a trojanized cryptocurrency trading application, it contains
    an installer script named *run.sh* in the *Resources/* directory of its application
    bundle ([Figure 2-2](#figure2-2)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个作为启动项保持持久性的Mac恶意软件示例是GMERA。它作为一个木马化的加密货币交易应用程序分发，包含一个名为*run.sh*的安装脚本，该脚本位于其应用程序包的*Resources/*目录中（[图2-2](#figure2-2)）。
- en: '![<<Stockfoli.app contents in finder, which includes a Resources folder. This
    folder contains documents, the application, and a shell script named run.sh.>>](image_fi/501942c02/f02002.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![<<Finder中的Stockfoli.app内容，包含一个Resources文件夹。该文件夹包含文档、应用程序和一个名为run.sh的shell脚本。>>](image_fi/501942c02/f02002.png)'
- en: 'Figure 2-2: A trojanized application (GMERA)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-2：一个被木马化的应用程序（GMERA）
- en: Examining this script reveals commands that will install a persistent and hidden
    launch agent to *~/Library/LaunchAgents/.com.apple.upd.plist* ([Listing 2-8](#listing2-8)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 检查该脚本会发现，它将安装一个持久化且隐藏的启动代理到*~/Library/LaunchAgents/.com.apple.upd.plist*（[列表2-8](#listing2-8)）。
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 2-8: A malicious installer script, *run.sh* (GMERA)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2-8：一个恶意的安装脚本，*run.sh*（GMERA）
- en: Notice that the obfuscated contents of the plist are found in a variable named
    `plist_text`. The malware decodes the plist using the macOS `base64` command 1
    and writes it out to the */tmp* directory as *.com.apple.upd.plist*. Then, via
    the `cp` command, it copies it to the user’s *LaunchAgents* directory 2. Finally,
    it starts the launch agent via the `launchctl` command 3.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，plist中的混淆内容位于名为`plist_text`的变量中。恶意软件使用macOS的`base64`命令 1 解码plist，并将其写入*/tmp*目录，命名为*.com.apple.upd.plist*。然后，通过`cp`命令，它将该文件复制到用户的*LaunchAgents*目录
    2。最后，它通过`launchctl`命令 3 启动该启动代理。
- en: Once the installer script has been executed, you can examine the now-decoded
    launch agent property list, *.com.apple.upd.plist* ([Listing 2-9](#listing2-9)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装脚本被执行，你可以检查现在已经解码的启动代理属性列表，*.com.apple.upd.plist*（[列表2-9](#listing2-9)）。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 2-9: A malicious launch agent plist (GMERA)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2-9：一个恶意的启动代理plist（GMERA）
- en: As the `RunAtLoad` key is set to `true` 1, the commands specified in the `ProgramArguments`
    array, which decode to a remote shell, will be automatically executed each time
    the user logs in.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`RunAtLoad`键被设置为`true` 1，`ProgramArguments`数组中指定的命令（解码为远程shell）将在每次用户登录时自动执行。
- en: For a final example of launch item persistence, let’s take a look at EvilQuest.
    This malware will persist as a launch daemon if it is running with root privileges,
    but because launch daemons run as root, the user has to possess root privileges
    in order to create one. Thus, if EvilQuest finds itself only running with user
    privileges, it instead creates a user launch agent.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个启动项持久性的例子是EvilQuest。如果该恶意软件以root权限运行，它将作为一个启动守护进程保持持久性，但因为启动守护进程是以root身份运行的，用户必须拥有root权限才能创建一个启动守护进程。因此，如果EvilQuest发现自己仅以用户权限运行，它会创建一个用户启动代理。
- en: To handle this persistence, EvilQuest contains an embedded property list template
    that’s used to create launch items. However, in an attempt to complicate analysis,
    this template is encrypted. In subsequent chapters, I’ll describe how to defeat
    anti-analysis attempts like these, but for now you just need to know that we can
    leverage a debugger and simply wait until the malware has decrypted the embedded
    property list template itself. Then we can view the unencrypted plist template
    in memory ([Listing 2-10](#listing2-10)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种持久性，EvilQuest包含一个嵌入的属性列表模板，用于创建启动项。然而，为了增加分析难度，这个模板被加密了。在后续章节中，我将描述如何应对这些反分析手段，但现在你只需要知道，我们可以利用调试器，简单地等待恶意软件解密嵌入的属性列表模板。然后我们可以查看内存中未加密的plist模板（[Listing
    2-10](#listing2-10)）。
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 2-10: A decrypted property list template (EvilQuest)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-10：解密后的属性列表模板（EvilQuest）
- en: Here we’re using `lldb`, the macOS debugger, to launch the file named *toolroomd*.
    Sometime later, the malware decrypts the plist template and stores its memory
    address in the `RAX` register. This allows us to display the now-decrypted template
    via the `x/s` command.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用`lldb`，macOS的调试器，启动名为*toolroomd*的文件。一段时间后，恶意软件解密属性列表模板并将其内存地址存储在`RAX`寄存器中。这使我们能够通过`x/s`命令显示现在已经解密的模板。
- en: Oftentimes, a simpler approach is to execute the malware in a standalone analysis
    or virtual machine and wait until the malware writes out its launch item property
    list. Once EvilQuest has completed its installation and persistently infected
    the system, you can find its launch daemon property list, named *com.apple.questd.plist*,
    in the */Library/LaunchDaemons* directory ([Listing 2-11](#listing2-11)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个更简单的方法是将恶意软件执行在独立分析或虚拟机中，等待恶意软件写出其启动项属性列表。一旦EvilQuest完成安装并持久性地感染系统，你可以在*/Library/LaunchDaemons*目录中找到它的启动守护进程属性列表，名为*com.apple.questd.plist*（[Listing
    2-11](#listing2-11)）。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 2-11: A launch item plist (EvilQuest)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-11：启动项plist（EvilQuest）
- en: As the `RunAtLoad` key is set to `true` 2, the values held in the `ProgramArguments`
    array 1 will be automatically executed each time the system is rebooted.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`RunAtLoad`键被设置为`true` 2，`ProgramArguments`数组 1 中的值将在每次系统重启时自动执行。
- en: Scheduled Jobs and Tasks
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度的作业和任务
- en: On macOS there are various ways to schedule jobs or tasks to run at specified
    intervals. Malware can (and does) abuse these mechanisms as a means to maintain
    persistence on infected macOS systems. This section looks at several of these
    scheduling mechanisms, such as cron jobs, at jobs, and periodic scripts. Note
    that launch items, too, can be scheduled to run at regular intervals via the `StartCalendarInterval`
    key, but as we discussed them earlier in this chapter, we won’t cover them again
    here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS中，有多种方式可以调度作业或任务在指定时间间隔内运行。恶意软件可以（并且确实）滥用这些机制来保持在感染的macOS系统上的持久性。本节将介绍几种调度机制，如cron作业、at作业和定期脚本。需要注意的是，启动项也可以通过`StartCalendarInterval`键调度在定期的时间间隔内运行，但由于我们在本章早些时候已经讨论过它们，这里不再重复介绍。
- en: Cron Jobs
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cron作业
- en: Due to its core foundations in BSD, macOS affords several Unix-like persistence
    mechanisms. *Cron jobs* are one such example. Often leveraged by sysadmins, they
    provide a way to persistently execute scripts, commands, and binaries at certain
    times. Unlike the login and launch items discussed earlier, persistent cron jobs
    generally execute automatically at specified intervals, such as hourly, daily,
    or weekly, rather than at specified events like user login. You can schedule a
    persistent cron job via the built-in */usr/bin/crontab* utility.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其基于BSD的核心基础，macOS提供了几种类Unix的持久性机制。*Cron作业*就是其中之一。通常由系统管理员使用，它们提供了一种在特定时间持久执行脚本、命令和二进制文件的方法。与前面讨论的登录项和启动项不同，持久性cron作业通常在指定的时间间隔内自动执行，例如每小时、每天或每周，而不是在特定事件（如用户登录）发生时执行。你可以通过内置的*/usr/bin/crontab*工具调度持久性cron作业。
- en: Abusing cron jobs for persistence isn’t particularly common in macOS malware.
    However, the popular open source post-exploitation agent EmPyre, which is sometimes
    used by attackers targeting macOS users, provides an example.^([5](#-endnote-5))
    In its crontab persistence module, EmPyre directly invokes the *crontab* binary
    to install itself as a cron job ([Listing 2-12](#listing2-12)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS恶意软件中，利用cron作业保持持久性并不特别常见。然而，流行的开源后渗透工具EmPyre，攻击者有时会使用它来攻击macOS用户，提供了一个例子。^([5](#-endnote-5))
    在它的crontab持久性模块中，EmPyre直接调用*crontab*二进制文件将自己安装为一个cron作业（[Listing 2-12](#listing2-12)）。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 2-12: Cron job persistence (EmPyre)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-12：Cron作业持久性（EmPyre）
- en: EmPyre first builds a string by concatenating several subcommands that together
    add a new malicious cron job with any current ones. The `crontab` command (with
    the `-l` flag) will list the user’s existing cron jobs 1. The `cat` and `echo`
    commands append the new command. Finally, the `crontab` command (with the `-`
    flag) will reinstall any existing jobs, along with the new cron job 2. Once these
    commands have been concatenated together (and stored into the `cmd` variable),
    they will then be executed via the Popen API of the Python subprocess module 3.
    The `%s` in the `cmd` variable will be updated at runtime with the path of the
    item to persist, and the `0 * * * *` component instructs macOS to execute the
    job each and every hour. For a comprehensive discussion of cron jobs, including
    the syntax of job creation, take a look at Wikipedia’s page titled “Cron.”^([6](#-endnote-6))
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: EmPyre首先通过连接多个子命令构建一个字符串，这些命令将新的恶意cron作业与当前的作业一起添加。`crontab`命令（带有`-l`标志）将列出用户现有的cron作业
    1。`cat`和`echo`命令将附加新命令。最后，`crontab`命令（带有`-`标志）将重新安装现有作业以及新的cron作业 2。一旦这些命令被连接在一起（并存储到`cmd`变量中），它们将通过Python
    subprocess模块的Popen API 3执行。`cmd`变量中的`%s`将在运行时用要持久化项的路径更新，`0 * * * *`组件指示macOS每小时执行一次该作业。关于cron作业的全面讨论，包括作业创建的语法，可以查看Wikipedia上的“Cron”页面。^([6](#-endnote-6))
- en: Let’s briefly look at another example of cron job persistence, courtesy of Janicab.
    This malware persists a compiled Python script, *runner.pyc*, as a cron job ([Listing
    2-13](#listing2-13)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看一下Janicab的另一个cron作业持久性示例。该恶意软件将编译后的Python脚本*runner.pyc*作为cron作业持久化（[Listing
    2-13](#listing2-13)）。
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 2-13: Cron job persistence (Janicab)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-13: cron作业持久性（Janicab）'
- en: Janicab’s Python installer first saves any existing cron jobs into a temporary
    file named */tmp/dump* 1. It then appends its new job to this file 2, before invoking
    `crontab` to complete the cron job installation 3. Once the new cron job has been
    added, macOS will execute the specified command, `python ~/.t/runner.pyc`, every
    minute. This compiled Python script ensures that the malware is always running,
    restarting it if necessary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Janicab的Python安装程序首先将现有的cron作业保存到名为*/tmp/dump* 1的临时文件中。然后，它将其新作业附加到该文件 2中，最后调用`crontab`来完成cron作业的安装
    3。一旦新cron作业添加完成，macOS将每分钟执行指定的命令`python ~/.t/runner.pyc`。这个编译后的Python脚本确保恶意软件始终在运行，并在必要时重新启动它。
- en: At Jobs
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: at作业
- en: Another way to achieve persistence on macOS is via *at jobs*, which are scheduled
    one-time tasks.^([7](#-endnote-7)) You can find at jobs stored in the */private/var/at/jobs/*
    directory and enumerate them via the */usr/bin/atq* utility. On a default install
    of macOS, the at scheduler, */usr/libexec/atrun,* is disabled. However, malware
    can enable it with root privileges ([Listing 2-14](#listing2-14)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实现macOS持久性的另一种方式是通过*at作业*，它们是一次性任务。^([7](#-endnote-7)) 你可以在*/private/var/at/jobs/*目录中找到at作业，并通过*/usr/bin/atq*实用程序列举它们。在默认安装的macOS中，at调度器*/usr/libexec/atrun*是禁用的。然而，恶意软件可以通过root权限启用它（[Listing
    2-14](#listing2-14)）。
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 2-14: Enabling the at scheduler'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-14: 启用at调度器'
- en: After enabling this scheduler, malware can create an at job by simply piping
    persistent commands into */usr/bin/at*, specifying the time and date of execution.
    Once executed, it can simply reschedule the job to maintain persistence. Currently,
    though, no Mac malware leverages this method for persistence.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此调度器后，恶意软件可以通过将持久命令传递到*/usr/bin/at*，并指定执行的时间和日期，轻松创建一个at作业。一旦执行，它可以简单地重新安排该作业以保持持久性。不过，目前没有Mac恶意软件利用此方法保持持久性。
- en: Periodic Scripts
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定期脚本
- en: If you list the contents of */etc/periodic*, you’ll find a directory containing
    scripts that will run on well-defined intervals ([Listing 2-15](#listing2-15)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你列出*/etc/periodic*的内容，你会找到一个包含将在特定时间间隔内运行的脚本的目录（[Listing 2-15](#listing2-15)）。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 2-15: Periodic scripts'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-15: 定期脚本'
- en: Though this directory is owned by root, malware with adequate privileges may
    be able to create (or subvert) a periodic script in order to achieve persistence
    at regular intervals. Although periodic scripts are conceptually rather similar
    to cron jobs, there are a few differences, such as the fact that they are handled
    by a separate daemon.^([8](#-endnote-8)) Similar to at jobs, no malware currently
    leverages this method for persistence.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该目录由root拥有，但具有足够权限的恶意软件可能能够创建（或颠覆）一个定期脚本，从而在固定时间间隔内实现持久性。尽管定期脚本在概念上与cron作业相似，但它们之间还是有一些区别，例如它们由一个独立的守护进程处理。^([8](#-endnote-8))
    与at作业类似，目前没有恶意软件利用此方法保持持久性。
- en: Login and Logout Hooks
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录和注销钩子
- en: Yet another way to achieve persistence on macOS is via *login* and *logout hooks*.
    Scripts or commands installed as login or logout hooks will execute automatically
    whenever a user logs in or out. You’ll find these hooks stored in the user-specific
    *~/Library/Preferences/com.apple.loginwindow.plist* file as key/value pairs. The
    key’s name should be either `LoginHook` or `LogoutHook`, with a string value set
    to the path of the file to execute at either login or logout ([Listing 2-16](#listing2-16)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上实现持久性的另一种方式是通过 *登录* 和 *登出钩子*。安装为登录或登出钩子的脚本或命令会在用户每次登录或登出时自动执行。你会在用户特定的
    *~/Library/Preferences/com.apple.loginwindow.plist* 文件中找到这些钩子，以键值对的形式存储。键的名称应为
    `LoginHook` 或 `LogoutHook`，值为在登录或登出时要执行的文件路径（[示例 2-16](#listing2-16)）。
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 2-16: An example `LoginHook`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-16：一个 `LoginHook` 示例
- en: In this example, the script *hook.sh* 1 will be executed each time the user
    logs in. Note that there can only be one `LoginHook` and one `LogoutHook` key/value
    pair specified at any given time. However, if malware encounters a system with
    a legitimate login or logout hook already present, it could append additional
    commands to the existing hook to gain persistence. Perhaps due to the fact that
    Apple has moved to deprecate this persistence technique, no malware leverages
    such hooks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，*hook.sh* 脚本将会在每次用户登录时执行。请注意，在任何给定时刻，系统中只能指定一个 `LoginHook` 和一个 `LogoutHook`
    键值对。然而，如果恶意软件遇到已经存在合法登录或登出钩子的系统，它可能会将额外的命令附加到现有的钩子上，从而获得持久性。或许由于苹果已经开始弃用这种持久性技术，目前没有恶意软件利用这些钩子。
- en: Dynamic Libraries
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态库
- en: '*Dynamic libraries (dylibs)* are modules containing executable code that a
    process can load and execute. Apple’s developer documentation explains the reasoning
    behind the use of dynamic libraries, pointing out that operating systems already
    “implement much of the functionality apps need in libraries.”^([9](#-endnote-9))
    Thus, app programmers can link their code against these libraries rather than
    re-create the functionality from scratch. Though you can statically link libraries
    into a program, doing so increases both the size of the program as well as its
    memory usage. In addition, if a flaw were discovered in the library, the program
    would need to be rebuilt to take advantage of any fixes or updated functionality.
    On the other hand, dynamically linking a library merely adds a specified dependency
    to the program; the actual library code is not compiled in. When the program is
    launched or needs to access library functionality, the library is then dynamically
    loaded. This reduces both the size of the program and its total memory usage.
    Programs that dynamically load these libraries will automatically benefit from
    any fixes and updated functionality.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态库（dylibs）*是包含可执行代码的模块，进程可以加载并执行这些代码。苹果的开发者文档解释了使用动态库的原因，指出操作系统已经“在库中实现了应用所需的大部分功能”^([9](#-endnote-9))。因此，应用程序开发者可以将他们的代码链接到这些库，而不是从头开始重新实现功能。虽然可以将库静态链接到程序中，但这样做会增加程序的大小和内存使用量。此外，如果库中发现了缺陷，程序就需要重新构建才能利用修复或更新的功能。另一方面，动态链接库只是将指定的依赖项添加到程序中；实际的库代码并未编译进来。当程序启动或需要访问库功能时，库会被动态加载。这减少了程序的大小和总内存使用量。动态加载这些库的程序将自动受益于任何修复和更新的功能。'
- en: The majority of persistence mechanisms abused by Mac malware coerce the operating
    system into automatically launching some standalone application or binary. While
    this is all well and good in terms of gaining and maintaining persistence, it
    generally results in a new untrusted process running on the system. An inquisitive
    user may notice this, especially if they peek at list of running processes. Moreover,
    security tools, which largely focus on process-level events, may readily detect
    such new processes, thus uncovering the malware.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数被Mac恶意软件滥用的持久性机制强制操作系统自动启动某个独立的应用程序或二进制文件。虽然这在获得和维持持久性方面没有问题，但通常会导致系统上运行一个新的不受信任的进程。一个好奇的用户可能会注意到这一点，尤其是如果他们查看正在运行的进程列表。更重要的是，安全工具主要关注进程级事件，可能很容易发现这些新进程，从而揭露恶意软件。
- en: More stealthy persistence mechanisms instead leverage dynamic libraries. Because
    these libraries are loaded within a trusted host process, they themselves do not
    result in a new process. Thus, an examination of running processes will not readily
    reveal their presence, which may also remain undetected by security tools. The
    idea of using dynamic libraries for persistence is fairly straightforward. Malware
    first locates an existing process that regularly gets started, either automatically
    by the system or manually by the user (the user’s browser is a good example of
    such a process). It then coerces that process into loading malicious libraries.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更隐蔽的持久化机制则利用动态库。由于这些库是在受信任的宿主进程中加载的，它们本身不会导致新进程的创建。因此，对正在运行的进程的检查不会轻易揭示它们的存在，这可能也不会被安全工具检测到。使用动态库进行持久化的思路非常直接。恶意软件首先定位到一个定期启动的现有进程，这个进程可能由系统自动启动，或者由用户手动启动（例如，用户的浏览器就是这样一个进程）。然后，它强迫该进程加载恶意库。
- en: In this section, we’ll first discuss generic methods of dylib persistence that
    malware could abuse to target a wide range of processes. Following this, we’ll
    explore specific plug-in–based persistence approaches that malware can leverage
    for a stealthy means of re-execution. Note that malware authors may also abuse
    dynamic libraries for purposes other than persistence, like to subvert processes
    of interest, such as the user’s browser. Moreover, once it’s loaded in a process,
    a dynamic library inherits that process’s permissions, which may provide the malware
    with access to protected devices, such as the webcam or mic as well as other sensitive
    resources.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先讨论恶意软件可能利用的 dylib 持久化的一般方法，这些方法能够针对广泛的进程进行攻击。接下来，我们将探讨恶意软件可以利用的具体基于插件的持久化方法，这些方法能够以隐秘的方式实现重新执行。请注意，恶意软件作者也可能滥用动态库执行其他目的，而不仅仅是持久化，例如篡改感兴趣的进程，如用户的浏览器。此外，一旦动态库被加载到某个进程中，该动态库将继承该进程的权限，这可能使恶意软件能够访问受保护的设备，如摄像头或麦克风以及其他敏感资源。
- en: DYLD_* Environment Variables
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DYLD_* 环境变量
- en: Any code can use the `DYLD_*` environment variables, such as `DYLD_INSERT_LIBRARIES`
    and `DYLD_FRAMEWORK_PATH`, to inject any dynamic library into a target process
    at load time. When loading a process, the dynamic loader will examine the `DYLD_INSERT_LIBRARIES`
    variable and load any libraries it specifies. By abusing this technique, an attacker
    can ensure that the target process loads a malicious library whenever that process
    is started. If the process often starts automatically or the user frequently starts
    it, this technique affords a fairly reliable and highly stealthy persistence technique.^([10](#-endnote-10))
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 任何代码都可以使用 `DYLD_*` 环境变量，如 `DYLD_INSERT_LIBRARIES` 和 `DYLD_FRAMEWORK_PATH`，在加载时将任何动态库注入目标进程。当加载进程时，动态加载器将检查
    `DYLD_INSERT_LIBRARIES` 变量并加载它指定的任何库。通过滥用这一技术，攻击者可以确保每次启动该进程时都会加载恶意库。如果该进程经常自动启动，或者用户频繁启动它，那么这种技术就提供了一种相当可靠且高度隐蔽的持久化方式。^([10](#-endnote-10))
- en: The specific means of persistently injecting a dynamic library via `DYLD_*`
    environment variables varies. If the malware is targeting a launch item, it could
    modify the item’s property list by inserting a new key/value pair into it. The
    key, `EnvironmentVariables`, would reference a dictionary containing a `DYLD_INSERT_LIBRARIES`
    key/value pair that points to the malicious dynamic library. If the malware is
    targeting an application, the approach involves modifying the application’s *Info.plist*
    file and inserting a similar key/value pair, albeit with a key name of `LSEnvironment`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `DYLD_*` 环境变量持久化注入动态库的具体方法各不相同。如果恶意软件的目标是启动项，它可能会通过向启动项的属性列表中插入一个新的键/值对来进行修改。键名
    `EnvironmentVariables` 会引用一个包含 `DYLD_INSERT_LIBRARIES` 键/值对的字典，指向恶意的动态库。如果恶意软件的目标是某个应用程序，则该方法涉及修改应用程序的
    *Info.plist* 文件并插入类似的键/值对，但键名为 `LSEnvironment`。
- en: Let’s look at an example. The notorious FlashBack malware abused this technique
    to maintain persistence by targeting users’ browsers. [Listing 2-17](#listing2-17)
    is a snippet of a Safari *Info.plist* file that FlashBack has subverted.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个例子。臭名昭著的 FlashBack 恶意软件通过滥用这种技术来保持持久化，目标是用户的浏览器。[列表 2-17](#listing2-17)
    是一个被 FlashBack 篡改的 Safari *Info.plist* 文件片段。
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 2-17: `DYLD_INSERT_LIBRARIES` persistence (FlashBack)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-17：`DYLD_INSERT_LIBRARIES` 持久化（FlashBack）
- en: Notice that the FlashBack malware has added an `LSEnvironment` dictionary to
    the file, containing a `DYLD_INSERT_LIBRARIES` key/value pair. The value points
    to the malware’s malicious dynamic library 1, which macOS will now load and execute
    within Safari’s context whenever the browser is launched.^([11](#-endnote-11))
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，FlashBack恶意软件已经向文件中添加了一个`LSEnvironment`字典，其中包含一个`DYLD_INSERT_LIBRARIES`键/值对。该值指向恶意动态库1，当浏览器启动时，macOS将加载并在Safari上下文中执行它。^([11](#-endnote-11))
- en: Since 2012, when FlashBack abused this technique, Apple has drastically reduced
    the scope of the `DYLD_*` environment variables. For example, the dynamic loader
    (`dyld`) now ignores these variables in a wide range of cases, such as for Apple’s
    platform binaries or for third-party applications compiled with the hardened runtime.
    It is also worth noting that platform binaries and those protected by the hardened
    runtime may be insusceptible to other dynamic library insertions, like those discussed
    later in this section. For more details on the security features afforded by the
    hardened runtime, see Apple’s documentation titled “Hardened Runtime.”^([12](#-endnote-12))
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 自2012年FlashBack滥用此技术以来，Apple大幅度减少了`DYLD_*`环境变量的作用范围。例如，动态加载器（`dyld`）现在在多种情况下会忽略这些变量，比如Apple平台的二进制文件或使用强化运行时编译的第三方应用程序。值得注意的是，平台二进制文件以及那些受强化运行时保护的应用程序，可能对其他动态库插入（如本节后续讨论的那些）不易受到影响。有关强化运行时提供的安全功能的更多详细信息，请参见Apple的文档《强化运行时》。^([12](#-endnote-12))
- en: Despite these precautions, many operating system components and popular third-party
    applications still support the loading of arbitrary dynamic libraries. Moreover,
    platform binaries and applications that have opted in to the hardened runtime
    may provide exceptions such as `com.apple.security.cs.allow-dyld-environment-variables`
    or `com.apple.security.cs.disable-library-validation` entitlements, which allow
    malicious dynamic libraries to be loaded. Thus, ample opportunities for dynamic
    library-based persistence still exist.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管采取了这些预防措施，许多操作系统组件和流行的第三方应用程序仍然支持加载任意动态库。此外，选择加入强化运行时的操作系统二进制文件和应用程序，可能会提供例如`com.apple.security.cs.allow-dyld-environment-variables`或`com.apple.security.cs.disable-library-validation`等特权，允许加载恶意动态库。因此，基于动态库的持久性依然存在大量机会。
- en: Dylib Proxying
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dylib代理
- en: A more modern approach to dynamic library injection involves a technique I’ve
    dubbed *dylib proxying*. In short, dylib proxying replaces a library that a target
    process depends on with a malicious library. Now, whenever the targeted application
    starts, the malicious dynamic library will be loaded and executed instead.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更现代的动态库注入方法涉及一种我称之为*dylib代理*的技术。简而言之，dylib代理通过将目标进程依赖的库替换为恶意库来实现。当目标应用程序启动时，恶意动态库将被加载并执行。
- en: To keep the application from losing legitimate functionality, the malicious
    library proxies requests to and from the original library. It can achieve this
    proxying by creating a dynamic library that contains a `LC_REEXPORT_DYLIB` load
    command. We’ll discuss load commands in Chapter 5; for now just know that the
    `LC_REEXPORT_DYLIB` load command essentially tells the dynamic loader, “Hey, while
    I, the malicious library, don’t implement the required functionality you’re looking
    for, I know who does!” As it turns out, this is the only information the loader
    needs to maintain the functionality provided by the proxied library.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持应用程序的合法功能，恶意库代理原始库的请求和返回。它可以通过创建一个包含`LC_REEXPORT_DYLIB`加载命令的动态库来实现这种代理。我们将在第5章讨论加载命令；现在只需知道，`LC_REEXPORT_DYLIB`加载命令本质上告诉动态加载器：“嘿，虽然我这个恶意库并未实现你所需要的功能，但我知道谁有！”事实证明，这就是加载器维持代理库提供的功能所需的唯一信息。
- en: Though we’ve yet to see malware abuse this dylib proxying technique, security
    researchers (myself included) have leveraged it in order to subvert various applications.
    Notably, I’ve abused Zoom to access a user’s webcam and achieved stealthy persistence
    each time they open the video conferencing application. Let’s briefly examine
    the details of this specific attack against Zoom, as it provides a practical example
    of how an attacker or malware could achieve stealthy dynamic library-based persistence.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们尚未看到恶意软件滥用这种dylib代理技术，但安全研究人员（包括我自己）已经利用它来破坏各种应用程序。特别是，我曾滥用Zoom应用，访问用户的摄像头，并在每次用户打开视频会议应用时实现隐秘的持久性。让我们简要回顾一下针对Zoom的这一特定攻击的细节，因为它提供了一个实际的例子，说明攻击者或恶意软件如何实现隐秘的基于动态库的持久性。
- en: Though Zoom compiles its application with a hardened runtime, which normally
    thwarts dynamic library injection attacks, older versions contained the `com.apple.security.cs.disable-library-validation`
    entitlement. This entitlement instructs macOS to disable library validation, allowing
    arbitrary libraries to be loaded into Zoom. To gain persistence, malware could
    proxy one of Zoom’s dependencies, such as its SSL library, *libssl.1.0.0.dylib*.
    The malware could make a copy of the legitimate SSL library, named something like
    *libssl.1.0.0_COPY.dylib*, and then create a malicious proxy library with the
    same name as the original SSL library. This malicious library would contain an
    `LC_REEXPORT_DYLIB` load command that points to the SSL library copy. To see this
    process in practice, take a look at the following output from macOS’s `otool`,
    run with the `-l` flag, to list the malicious dynamic library’s load commands
    ([Listing 2-18](#listing2-18)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Zoom 使用强化运行时编译其应用程序，通常可以防止动态库注入攻击，但旧版本包含 `com.apple.security.cs.disable-library-validation`
    权限。此权限指示 macOS 禁用库验证，允许任意库加载到 Zoom 中。为了获取持久性，恶意软件可以代理 Zoom 的依赖项之一，例如其 SSL 库 *libssl.1.0.0.dylib*。恶意软件可以复制合法的
    SSL 库，命名为 *libssl.1.0.0_COPY.dylib*，然后创建一个带有与原始 SSL 库相同名称的恶意代理库。这个恶意库将包含一个 `LC_REEXPORT_DYLIB`
    加载命令，指向 SSL 库的副本。要查看此过程的实际情况，请查看 macOS 的 `otool` 输出，使用 `-l` 标志运行，列出恶意动态库的加载命令（[图例
    2-18](#listing2-18)）。
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 2-18: A proxy dynamic library'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图例 2-18：代理动态库
- en: Note that this library contains a reexport directive 1 that points to the original
    SSL library 2. This ensures that the SSL functionality required to run the app
    isn’t lost. Once the malicious proxy library is in place, it will load automatically
    and execute its constructor any time the user launches Zoom. Now, in addition
    to persistence, the malware has access to Zoom’s privacy permissions, such as
    those for the mic and camera, allowing it to spy on the user via their webcam!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此库包含一个重新导出指令 1，指向原始的 SSL 库 2。这确保了运行应用所需的 SSL 功能不会丢失。一旦恶意代理库就位，它将自动加载并在用户启动
    Zoom 时执行其构造函数。现在，除了持久性外，恶意软件还可以访问 Zoom 的隐私权限，例如麦克风和摄像头权限，从而通过网络摄像头监视用户！
- en: Dylib Hijacking
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dylib 劫持
- en: Dylib hijacking is a stealthier, albeit less generic, version of dylib proxying.
    In a *dylib hijack*, malware can exploit a program that either attempts to load
    dynamic libraries from multiple attacker-writable locations or that has a weak
    dependency on a dynamic library that does not exist. In the former case, if the
    primary location doesn’t contain the library, the app will search for it in a
    second location. In this case, malware could install itself as a malicious library
    of the same name in the first location that the program would then naively load.
    For example, say an application attempts to load *foo.dylib* from the application’s
    *Library/* directory first, and then from the */System/Library* directory. If
    *foo.dylib* doesn’t exist in the application’s *Library/* directory, an attacker
    could add a malicious library of the same name at that location. This malicious
    library would load automatically at runtime.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Dylib 劫持是 Dylib 代理的更隐蔽但更专用版本。在 *Dylib 劫持* 中，恶意软件可以利用试图从多个攻击者可写位置加载动态库的程序，或者对一个不存在的动态库有弱依赖的程序。在前一种情况下，如果主要位置不包含库，则应用程序将在第二位置搜索它。在这种情况下，恶意软件可以将自己安装为同名的恶意库，放在程序首先搜索的位置。例如，假设应用程序首先尝试从应用程序的
    *Library/* 目录加载 *foo.dylib*，然后再从 */System/Library* 目录加载。如果 *foo.dylib* 在应用程序的
    *Library/* 目录中不存在，攻击者可以在该位置添加同名的恶意库。这个恶意库将在运行时自动加载。
- en: Let’s look at a specific example. On certain older versions of macOS, including
    OS X 10.10, Apple’s iCloud photo stream agent would attempt to load a dynamic
    library named *PhotoFoundation* from either the *iPhoto.app/Contents/Library/LoginItems/*
    or the *iPhoto.app/Contents/Framework* directory. As the library was found in
    the second directory, malware could plant a malicious dynamic library of the same
    name in the primary directory. On subsequent launches, the agent would first encounter
    and load the malicious dynamic library. And as the agent was automatically started
    each time the user logged in, it afforded a highly stealthy means of persistence
    ([Listing 2-19](#listing2-19)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个具体的例子。在某些较老版本的 macOS（包括 OS X 10.10）上，Apple 的 iCloud 照片流代理会尝试从 *iPhoto.app/Contents/Library/LoginItems/*
    或 *iPhoto.app/Contents/Framework* 目录加载一个名为 *PhotoFoundation* 的动态库。由于该库出现在第二个目录，恶意软件可以将一个同名的恶意动态库植入主目录。在随后的启动中，代理首先会遇到并加载恶意动态库。由于该代理在每次用户登录时都会自动启动，这提供了一种非常隐蔽的持久化手段
    ([Listing 2-19](#listing2-19))。
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 2-19: A dynamic library hijacker, PhotoFoundation, loaded by Apple’s
    Photo Stream Agent'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-19: 一个动态库劫持器，PhotoFoundation，由 Apple 的照片流代理加载'
- en: A program may also be vulnerable to a dylib hijack if it has an optional, or
    *weak*, dependency on a dynamic library that does not exist. When a dependency
    is weak, the program will always look for the dynamic library but can still execute
    if it doesn’t exist. However, if malware is able to plant a malicious dynamic
    library in the weakly specified location, the program will then load it on subsequent
    launches. If you’re interested in learning more about dylib hijacking, see either
    my research paper on the topic, “Dylib hijacking on OS X,” or “MacOS Dylib Injection
    through Mach-O Binary Manipulation.”^([13](#-endnote-13))
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序存在对一个动态库的可选或*弱*依赖，并且该动态库不存在，它也可能容易受到 dylib 劫持。当依赖关系较弱时，程序始终会查找该动态库，但如果该库不存在，程序仍然可以执行。然而，如果恶意软件能够将恶意动态库放置在弱指定的位置，程序在后续启动时就会加载它。如果你有兴趣了解更多关于
    dylib 劫持的内容，可以查看我在这个主题上的研究论文《OS X 上的 dylib 劫持》或《通过 Mach-O 二进制操作进行 MacOS dylib
    注入》^([13](#-endnote-13))。
- en: Though Mac malware hasn’t been known to leverage this technique in the wild
    in order to persist, the post-exploitation agent EmPyre has a persistence module
    that leverages dylib hijacking ([Listing 2-20](#listing2-20)):^([14](#-endnote-14))
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管目前尚未发现 Mac 恶意软件利用这一技术在现实环境中进行持久化，但后渗透代理 EmPyre 有一个利用 dylib 劫持的持久化模块 ([Listing
    2-20](#listing2-20))：^([14](#-endnote-14))
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 2-20: A dylib hijacking persistence module, *CreateHijacker.py* (EmPyre)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-20: 一个 dylib 劫持持久化模块，*CreateHijacker.py*（EmPyre）'
- en: These dylib hijack techniques only work against applications that are specifically
    vulnerable, which is to say, ones that search for dynamic libraries in multiple
    locations or that have a weak, nonexistent dependency. Moreover, if malware hopes
    to use this technique for persistence, the vulnerable programs must be either
    started automatically or commonly launched. Finally, on recent versions of macOS,
    mitigations such as the hardened runtime may minimize that impact of all dylib
    injection, as these protections generically prevent the loading of arbitrary dynamic
    libraries.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 dylib 劫持技术仅对特定脆弱的应用程序有效，也就是说，只有那些在多个位置查找动态库或具有弱、不存在的依赖关系的程序才会受到影响。此外，如果恶意软件希望利用这一技术实现持久化，那么这些脆弱的程序必须是自动启动的或常常被启动的。最后，在较新的
    macOS 版本中，像硬化运行时这样的缓解措施可能会最小化所有 dylib 注入的影响，因为这些保护机制会通用地防止加载任意动态库。
- en: Plug-ins
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件
- en: Many Apple daemons and third-party applications support plug-ins or extensions
    by design, whether as dynamic libraries, packages, or various other file formats.
    While plug-ins can legitimately extend a program’s functionality, malware may
    abuse these features to achieve stealthy persistence within the context of the
    process. How? Generally by creating a compatible plug-in and installing it into
    the program’s plug-in directory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Apple 守护进程和第三方应用程序设计上都支持插件或扩展，无论是动态库、包还是其他各种文件格式。虽然插件可以合法地扩展程序的功能，但恶意软件可能会滥用这些功能，在进程上下文中实现隐蔽的持久化。如何实现？通常通过创建一个兼容的插件并将其安装到程序的插件目录中。
- en: For example, all modern browsers support plug-ins or extensions that a browser
    automatically executes each time it’s started, providing a convenient way for
    malicious code to persist. Moreover, such plug-ins are afforded direct access
    to users’ browsing sessions, allowing malicious code, such as adware, to display
    ads, hijack traffic, extract saved passwords, and more.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，所有现代浏览器都支持插件或扩展，这些插件或扩展在每次浏览器启动时会自动执行，为恶意代码提供了一个便捷的持久化方式。此外，这些插件直接访问用户的浏览会话，使恶意代码（如广告软件）能够显示广告、劫持流量、提取保存的密码等。
- en: 'These extensions can operate quite stealthily. Consider the malicious browser
    extension Pitchofcase, shown in [Figure 2-3](#figure2-3). In a write-up, security
    researcher Phil Stokes notes that “at first blush, Pitchofcase seems like any
    other adware extension: when enabled it redirects user searches through a few
    pay-for-click addresses before landing on *pitchofcase.com*. The extension runs
    invisibly in the background without a toolbar button or any other means to interact
    with it.”^([15](#-endnote-15)) Moreover, Phil noted that if one clicks the Uninstall
    button, shown in [Figure 2-3](#figure2-3), the browser extension won’t actually
    be uninstalled.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扩展可以非常隐蔽地运行。考虑恶意浏览器扩展 Pitchofcase，如[图 2-3](#figure2-3)所示。在一篇报道中，安全研究员 Phil
    Stokes 指出，“乍一看，Pitchofcase 看起来像任何其他广告软件扩展：启用时，它会将用户搜索通过一些按点击付费的地址重定向，最后跳转到 *pitchofcase.com*。该扩展在后台隐形运行，没有工具栏按钮或其他交互方式。”^([15](#-endnote-15))
    此外，Phil 还指出，如果点击[图 2-3](#figure2-3)中的卸载按钮，浏览器扩展实际上并不会被卸载。
- en: '![<<Pitchofcase website with Safari’s Preferences window opened. The Extensions
    tab is selected, which displays Pitchofcase and its permissions, such as reading
    sensitive information on all web pages, including passwords, phone numbers, and
    credit cards, and viewing the user’s entire browsing history.>>](image_fi/501942c02/f02003.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![<<Pitchofcase 网站与 Safari 的偏好设置窗口打开。选中了扩展标签，显示了 Pitchofcase 及其权限，如读取所有网页上的敏感信息，包括密码、电话号码和信用卡，并查看用户的完整浏览历史。>>](image_fi/501942c02/f02003.png)'
- en: 'Figure 2-3: A malicious browser extension (adware)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3：恶意浏览器扩展（广告软件）
- en: More recent examples of malicious browser extensions include Shlayer, Bundlore,
    and Pirrit. The latter is especially notable, as it was the first malware to natively
    target Apple’s new M1 chips, which were released in 2020.^([16](#-endnote-16))
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 近期的恶意浏览器扩展示例包括 Shlayer、Bundlore 和 Pirrit。后者尤其值得注意，因为它是首个原生针对苹果新发布的 M1 芯片的恶意软件，该芯片于
    2020 年发布。^([16](#-endnote-16))
- en: Of course, malware can subvert other kinds of applications in a similar manner.
    For example, in the “iTunes Evil Plugin Proof of Concept” blog post, security
    researcher Pedro Vilaça illustrated how an attacker could coerce iTunes to load
    a malicious plug-in on OS X 10.9\. Because a user could write to the iTunes plug-in
    folder, Vilaça observes that “a trojan dropper can easily load a malicious plug-in.
    Or it can be used as [a] communication channel for a RAT.”^([17](#-endnote-17))
    From there, Vilaça describes how the malware could subvert iTunes in order to
    steal users’ credentials, but the malicious plug-in could also provide persistence,
    as it’s automatically loaded and executed each time iTunes is launched.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，恶意软件也可以以类似的方式颠覆其他类型的应用程序。例如，在“iTunes 恶意插件概念验证”博客文章中，安全研究员Pedro Vilaça 说明了攻击者如何迫使
    iTunes 在 OS X 10.9 上加载恶意插件。因为用户可以写入 iTunes 插件文件夹，Vilaça 观察到“一个特洛伊木马投放器可以轻松加载恶意插件。或者它可以作为[一个]
    RAT 的通信通道。”^([17](#-endnote-17)) 在此基础上，Vilaça 描述了恶意软件如何颠覆 iTunes 来窃取用户凭证，但恶意插件也可以提供持久性，因为它会在每次启动
    iTunes 时自动加载和执行。
- en: Finally, various Apple daemons support third-party plug-ins, including those
    for authorization, directory services, QuickLook, and Spotlight, that malware
    could abuse for stealthy persistence.^([18](#-endnote-18)) That said, each new
    release of macOS continues to limit the impact of plug-ins through entitlements,
    code-signing checks, sandboxing, and other security features. Perhaps due to their
    ever-limited impact, no known malware currently abuses these plug-ins for persistence.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，各种 Apple 守护进程支持第三方插件，包括用于授权、目录服务、QuickLook 和 Spotlight 的插件，恶意软件可以利用这些插件实现隐蔽的持久性。^([18](#-endnote-18))
    尽管如此，每个新的 macOS 版本都通过权限、代码签名检查、沙箱以及其他安全功能继续限制插件的影响。也许由于它们的影响越来越有限，目前尚无已知恶意软件滥用这些插件来实现持久性。
- en: Scripts
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本
- en: Mac malware might modify various system scripts to achieve persistence. One
    such script is the *rc.common* file found in */etc*. On older versions of macOS,
    this shell script executes during the boot process, allowing malware to insert
    arbitrary commands into it that would execute whenever such systems start. For
    example, the iKitten malware abuses this file using a method, aptly named `addToStartup`,
    that persists a malicious shell script whose path is passed in as the method’s
    sole parameter ([Listing 2-21](#listing2-21)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Mac恶意软件可能会修改各种系统脚本以实现持久化。其中一个脚本是位于*/etc*中的*rc.common*文件。在旧版本的macOS中，这个shell脚本在启动过程中执行，使得恶意软件可以将任意命令插入其中，在系统启动时执行。例如，iKitten恶意软件使用一个名为`addToStartup`的方法滥用此文件，该方法将恶意shell脚本的路径作为唯一参数传递并保持其持久性（[清单2-21](#listing2-21)）。
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 2-21: Subversion of the *rc.common* file for persistence (iKitten)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-21：为了持久化而修改*rc.common*文件（iKitten）
- en: This method builds a command whose logic first checks if the name of the shell
    script is already present in the *rc.common* file 1. If not, the `else` logic
    will append the script to the end of the file. This command then is executed by
    a call to a method named `ExecuteBash` 2.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法构建了一个命令，其逻辑首先检查*rc.common*文件中是否已存在该shell脚本的名称。如果没有，`else`逻辑将把脚本附加到文件的末尾。然后，通过调用名为`ExecuteBash`的方法执行该命令。
- en: Other scripts ripe for persistent subversion may be application-specific. One
    such example is shell initialization scripts, such as *.bashrc* or *.bash_profile*,
    which may be automatically executed when a user launches a shell.^([19](#-endnote-19))
    Though the modification of such scripts affords a potential avenue for persistence,
    this persistence is dependent on the application being executed, and thus won’t
    occur if the user doesn’t spawn a shell.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能用于持久化篡改的脚本可能是特定于应用程序的。例如，shell初始化脚本，如*.bashrc*或*.bash_profile*，可能会在用户启动shell时自动执行。^([19](#-endnote-19))
    虽然修改这些脚本为持久化提供了一个潜在途径，但这种持久化依赖于应用程序的执行，因此如果用户没有启动shell，持久化就不会发生。
- en: Event Monitor Rules
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件监视规则
- en: Volume I of Jonathan Levin’s **OS Internals* describes how Mac malware might
    abuse the event monitor daemon (`emond`) to achieve persistence.^([20](#-endnote-20))
    As the operating system automatically launches `emond` during system boot, processing
    and executing any specified rules, malware can simply create a rule for the daemon
    to automatically execute. You can find the rules that `emond` will execute in
    the */etc/emond.d/rules* or */private/var/db/emondClients* directories. At this
    time, no malware is known to leverage such rules for persistence.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Jonathan Levin的**《OS Internals》**第一卷描述了Mac恶意软件如何可能滥用事件监视守护进程（`emond`）实现持久化。^([20](#-endnote-20))
    由于操作系统在系统启动时自动启动`emond`，处理并执行任何指定的规则，恶意软件可以简单地创建一个规则，使得守护进程自动执行。你可以在*/etc/emond.d/rules*或*/private/var/db/emondClients*目录中找到`emond`将要执行的规则。目前，尚无已知恶意软件利用此类规则实现持久化。
- en: Reopened Applications
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新打开的应用程序
- en: Mac users are likely familiar with the following prompt, shown upon logging
    out ([Figure 2-4](#figure2-4)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Mac用户可能熟悉以下提示框，它会在退出时显示（[图2-4](#figure2-4)）。
- en: '![<<Pop-up window asking “Are you sure you want to quit all applications and
    log out now?” The user has checked the box “Reopen windows when logging back in.”>>](image_fi/501942c02/f02004.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![<<弹出窗口询问“您确定要退出所有应用程序并立即注销吗？”用户已勾选“重新登录时重新打开窗口”选项。>>](image_fi/501942c02/f02004.png)'
- en: 'Figure 2-4: The reopen applications prompt'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-4：重新打开应用程序提示
- en: 'If the box is left checked, macOS will automatically relaunch any running applications
    upon the next login. Behind the scenes, it stores the applications to be reopened
    in a property list named *com.apple.loginwindow.<UUID>.plist* within the *~/Library/Preferences/ByHost*
    directory. The UUID in the path is simply the system hardware’s unique identifier.
    Using macOS’s `plutil`, you can view the contents of this property list ([Listing
    2-22](#listing2-22)):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果勾选了该框，macOS将在下次登录时自动重新启动所有正在运行的应用程序。在后台，它将要重新打开的应用程序存储在名为*com.apple.loginwindow.<UUID>.plist*的属性列表中，该列表位于*~/Library/Preferences/ByHost*目录下。路径中的UUID是系统硬件的唯一标识符。使用macOS的`plutil`，你可以查看此属性列表的内容（[清单2-22](#listing2-22)）：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 2-22: The reopened applications property list'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-22：重新打开的应用程序属性列表
- en: As you can see, the file contains various key/value pairs, including the bundle
    identifier and the path to the application to relaunch. Though no malware is known
    to persist in this manner, it could add itself directly to this property list
    and thus be automatically re-executed the next time the user logs in. To ensure
    continued persistence, it would be wise for the malware to monitor this plist
    and re-add itself if needed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，文件包含了各种键/值对，包括捆绑标识符和应用程序重新启动的路径。虽然没有已知的恶意软件以这种方式持续存在，但它可能会直接将自身添加到这个属性列表中，从而在用户下次登录时自动重新执行。为了确保持续的持久性，恶意软件监控这个plist并在需要时重新添加自己是明智的做法。
- en: Application and Binary Modifications
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序和二进制文件修改
- en: Stealthy malware may achieve persistence by modifying legitimate programs found
    on the infected system in such a way that launching these programs runs the malicious
    code. In early 2020, security researcher Thomas Reed released a report that highlighted
    the sophistication of adware targeting macOS. In this report, he notes that the
    prolific adware Crossrider subverts Safari in order to persist various malicious
    browser extensions. By creating a modified version of the application, Crossrider
    makes the application enable malicious Safari extensions whenever the user opens
    the browser, without requiring user actions. It then deletes this copy of Safari,
    Reed wrote, “leaving the real copy of Safari thinking that it’s got a couple additional
    browser extensions installed and enabled.”^([21](#-endnote-21))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 隐秘的恶意软件可能通过修改感染系统上的合法程序，确保启动这些程序时运行恶意代码，从而实现持久性。在2020年初，安全研究员Thomas Reed发布了一份报告，突出了针对macOS的广告软件的复杂性。在这份报告中，他指出，广泛传播的广告软件Crossrider通过破坏Safari浏览器来保持各种恶意浏览器扩展的持久性。通过创建修改版的应用程序，Crossrider使得每当用户打开浏览器时，恶意的Safari扩展会被启用，而无需用户采取任何操作。然后它删除了这个修改过的Safari副本，Reed写道，“让真正的Safari副本误以为它安装并启用了几个额外的浏览器扩展。”^([21](#-endnote-21))
- en: Another example from early 2020, EvilQuest combines several persistence techniques.
    The malware initially persists as a launch item but also virally infects various
    binaries on the system. This measure ensures that, even if a user removes the
    launch item, the malware retains persistence! This kind of viral persistence is
    rare on macOS, so it merits taking a closer look. When initially executed, EvilQuest
    spawns a new background thread to find and infect other binaries. The function
    responsible for generating a list of candidates is descriptively named `get_targets`,
    while the infection function is called `append_ei`. You can see these in the following
    disassembly ([Listing 2-23](#listing2-23)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 2020年初的另一个例子，EvilQuest结合了几种持久性技术。该恶意软件最初作为启动项存在，但也通过病毒传播感染系统中的多个二进制文件。此措施确保即使用户删除了启动项，恶意软件仍能保持持久性！这种病毒性持久性在macOS上很少见，因此值得仔细观察。当最初执行时，EvilQuest会生成一个新的后台线程来查找并感染其他二进制文件。负责生成候选列表的函数被形象地命名为`get_targets`，而感染函数则叫做`append_ei`。你可以在以下反汇编中看到这些内容（[列表
    2-23](#listing2-23)）。
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 2-23: Viral infection logic (EvilQuest)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-23: 病毒感染逻辑（EvilQuest）'
- en: As shown here, each candidate executable found via the `get_targets` function
    1 is passed to the `append_ei` function 2. The `append_ei` function inserts a
    copy of the malware at the start of the target binary, and then rewrites the original
    target bytes to the end of the file. Finally, it adds a trailer to the end of
    the file that includes an infection marker, `0xdeadface`, and the offset in the
    file to the original target’s bytes. We’ll discuss this further in Chapter 11.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，通过`get_targets`函数1找到的每个候选可执行文件都会传递给`append_ei`函数2。`append_ei`函数将恶意软件的副本插入到目标二进制文件的开头，然后将原始目标字节重写到文件的末尾。最后，它在文件末尾添加一个尾部，包含一个感染标记`0xdeadface`，以及指向原始目标字节的文件偏移量。我们将在第11章进一步讨论这个过程。
- en: Once the malware has infected a binary by wholly inserting itself at the start
    of the file, it will run whenever anyone executes the file. When it runs, the
    first thing it does is check if its main persistence mechanism, the launch item,
    has been removed; if it has, it replaces its malicious launch item. To avoid detection,
    the malware also executes the contents of the original file by parsing the trailer
    to get the location of the file’s original bytes. These bytes are then written
    out to a new file, named *<originalfilename>1*, which the malware then executes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件通过完全插入自身到文件的开头感染了一个二进制文件，它将在任何人执行该文件时运行。当它运行时，首先检查其主要的持久化机制——启动项是否被删除；如果删除了，它会替换其恶意的启动项。为了避免被检测到，恶意软件还会通过解析尾部来执行原始文件的内容，以获取文件原始字节的位置。这些字节随后会被写入到一个新的文件中，命名为
    *<originalfilename>1*，然后恶意软件执行这个文件。
- en: KnockKnock . . . Who’s There?
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KnockKnock . . . 谁在那儿？
- en: If you’re interested in finding out what software or malware is persistently
    installed on your macOS system, I’ve created a free open source utility just for
    this purpose. KnockKnock tells you who’s there, querying your system for any software
    that leverages many of the myriad of persistence mechanisms discussed in this
    chapter ([Figure 2-5](#figure2-5)).^([22](#-endnote-22)) It’s worth pointing out
    that, as legitimate software will often persist as well, the vast majority (if
    not all) of the items displayed by KnockKnock will be wholly benign.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣了解在你的 macOS 系统上持续安装了哪些软件或恶意软件，我为此目的创建了一个免费的开源工具。KnockKnock 会告诉你谁在那儿，通过查询系统中利用本章讨论的多种持久化机制的任何软件
    ([图 2-5](#figure2-5))。^([22](#-endnote-22)) 值得指出的是，由于合法软件也会持久存在，KnockKnock 显示的绝大多数（如果不是全部）项目将是完全无害的。
- en: '![KnockKnock’s home page contains a play button at the top center of the screen
    to Start Scan. On the left side, there is a list of categories that includes Library
    Proxies, Login Items, Login/Logout Hooks, Periodic Scripts, Quicklook Plugins,
    Spotlight Importers, and Startup Scripts.](image_fi/501942c02/f02005.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![KnockKnock 的主页包含一个位于屏幕顶部中央的播放按钮，用于启动扫描。在左侧，有一个包含多个类别的列表，包括 Library Proxies、Login
    Items、Login/Logout Hooks、Periodic Scripts、Quicklook Plugins、Spotlight Importers
    和 Startup Scripts。](image_fi/501942c02/f02005.png)'
- en: 'Figure 2-5: KnockKnock? Who’s there? . . . Hopefully only legitimate software!'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-5：KnockKnock？谁在那儿？. . . 希望只有合法软件！
- en: Up Next
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: In this chapter we discussed numerous persistence mechanisms that macOS malware
    can abuse to maintain its access to infected systems. For good measure, we also
    discussed several potential methods of persisting on a macOS system that malware
    has yet to leverage in the wild.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 macOS 恶意软件可以滥用的多种持久化机制，以维持对感染系统的访问。为了全面性，我们还讨论了几种恶意软件在野外尚未利用的可能持久化方法。
- en: Creating a truly comprehensive list of these persistence methods is most likely
    an exercise in futility. First, Apple has deprecated several very dated ways to
    persist, such as via the *StartupParameters.plist* file, and thus these no longer
    work on recent versions of macOS. That’s why I didn’t cover such methods in this
    chapter. Secondly, Mac malware authors are a creative bunch. Though we’ve shed
    light on many methods of persistence, we’d be naive to assume that malware authors
    will stick solely to those methods. Instead, they’ll surely find new or innovative
    ways to persist their malicious creations!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个真正全面的持久化方法列表很可能是一项徒劳的工作。首先，苹果已经弃用了几种非常过时的持久化方式，例如通过 *StartupParameters.plist*
    文件，因此这些方法在最近版本的 macOS 中不再有效。这就是为什么我在本章中没有涉及这些方法。其次，Mac 恶意软件作者是一个富有创意的群体。尽管我们已经揭示了许多持久化方法，但我们如果认为恶意软件作者只会使用这些方法，那就太天真了。他们肯定会找到新的或创新的方式来保持他们的恶意创作！
- en: 'If you’re interested in learning more about methods of persistence, including
    historical methods that no longer function and methods uncovered after the publication
    of this book, I encourage you to explore the following resources:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣了解更多关于持久化的方法，包括已经不再有效的历史方法以及本书出版后发现的方法，建议你查看以下资源：
- en: “Persistence,” MITRE ATT&CK, [https://attack.mitre.org/tactics/TA0003/](https://attack.mitre.org/tactics/TA0003/)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “持久化，”MITRE ATT&CK，[https://attack.mitre.org/tactics/TA0003/](https://attack.mitre.org/tactics/TA0003/)
- en: “Beyond the good ol’ LaunchAgents,” Theevilbit blog, [https://theevilbit.github.io/beyond/beyond_intro/](https://theevilbit.github.io/beyond/beyond_intro/)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “超越老旧的 LaunchAgents，” Theevilbit 博客，[https://theevilbit.github.io/beyond/beyond_intro/](https://theevilbit.github.io/beyond/beyond_intro/)
- en: “Methods of Malware Persistence on Mac OS X,” Virus Bulletin, [https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf](https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Mac OS X 上的恶意软件持久化方法，”《病毒公报》，[https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf](https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf)
- en: In the next chapter, we’ll explore the objectives of malware once it has persistently
    infected a Mac system.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨恶意软件在持续感染 Mac 系统后，所追求的目标。
- en: Endnotes
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
