["```\n    val1 = 0\n    val2 = val1 + 1\n    val3 = val2 + 1\n    etc.\n    ```", "```\n    push rbp\n    mov  rbp, rsp\n    sub  rsp, sizeOfLocals ; Assuming there are local variables\n    ```", "```\n    leave\n    ret\n    ```", "```\n    mov rax, parm4\n    mov al, [rax]\n    ```", "```\n    mov eax, x\n    add eax, y\n    mov x, eax\n    ```", "```\n    mov eax, y\n    sub eax, z\n    mov x, eax\n    ```", "```\n    mov  eax, y\n    imul eax, z\n    mov  x, eax\n    ```", "```\n    mov  eax, z\n    imul eax, t\n    add  eax, y\n    mov  x, eax\n    ```", "```\n    mov  eax, y\n    add  eax, z\n    imul eax, t\n    mov  x, eax\n    ```", "```\n    mov  eax, x\n    imul y          ; Note: Sign-extends into EDX\n    idiv z\n    mov  x, eax\n    ```", "```\n    mov   eax, y\n    cmp   eax, z\n    sete  bl\n    cmp   t, 0\n    setne bh\n    and   bl, bh\n    movzx eax, bl   ; Because x is a 32-bit integer\n    mov   x, eax\n    ```", "```\n    shl   x, 1\n    ```", "```\n    mov   eax, y\n    lea   eax, [eax][eax*4]\n    mov   x, eax\n    ```", "```\n    mov   eax, y\n    mov   ebx, eax\n    shl   eax, 2\n    add   eax, ebx\n    mov   x, eax\n    ```", "```\n    mov   eax, y\n    shl   eax, 3\n    mov   x, eax\n    ```", "```\n    shr   x, 1\n    ```", "```\n    mov   ax, y\n    shr   ax, 3\n    mov   x, ax\n    ```", "```\n    movzx eax, z\n    imul  eax, 6554  ; Or 6553\n    shr   eax, 16\n    mov   x, ax\n    ```", "```\n    fld   x\n    fld   y\n    faddp\n    fstp  x\n    ```", "```\n    fld   y\n    fld   z\n    fsubp\n    fstp  x\n    ```", "```\n    fld   y\n    fld   z\n    fmulp\n    fstp  x\n    ```", "```\n    fld   y\n    fld   z\n    fld   t\n    fmulp\n    faddp\n    fstp  x\n    ```", "```\n    fld   y\n    fld   z\n    faddp\n    fld   t\n    fmulp\n    fstp  x\n    ```", "```\n    fld   x\n    fld   y\n    fmulp\n    fld   z\n    fdivp\n    fchs\n    fstp  x\n    ```", "```\n    movss xmm0, x\n    addss xmm0, y\n    movss x, xmm0\n    ```", "```\n    movss xmm0, y\n    subss xmm0, z\n    movss x, xmm0\n    ```", "```\n    movss xmm0, y\n    mulss xmm0, z\n    movss x, xmm0\n    ```", "```\n    movss xmm0, z\n    mulss xmm0, t\n    addss xmm0, y\n    movss x, xmm0\n    ```", "```\n    fld    y\n    fld    x\n    fcomip st(0), st(1)\n    setb   b\n    fstp   st(0)\n    ```", "```\n    fld    y\n    fld    x\n    fcomip st(0), st(1)\n    setae  bl\n    fstp   st(0)\n    fld    z\n    fld    x\n    fcomip st(0), st(1)\n    setb   bh\n    fstp   st(0)\n    and    bl, bh\n    mov    b, bl\n    ```", "```\n    if(x == y || z > t)\n    {\n        `Do something` \n    }\n        mov  eax, x\n        cmp  eax, y\n        sete bl\n        mov  eax, z\n        cmp  eax, t\n        seta bh\n        or   bl, bh\n        jz   skipIF\n         `Code for statements that \"do something\"`\n    skipIF:\n\n    if(x != y && z < t)\n    {\n         `THEN statements`\n    }\n    Else\n    {\n         `ELSE statements`\n    }\n        mov   eax, x\n        cmp   eax, y\n        setne bl\n        mov   eax, z\n        cmp   eax, t\n        setb  bh\n        and   bl, bh\n        jz    doElse\n        ` Code for THEN statements`\n        jmp   endOfIF\n\n    doElse:\n        ` Code for ELSE statements`\n    endOfIF:\n    ```", "```\n    1st IF:\n        mov  ax, x\n        cmp  ax, y\n        jeq  doBlock\n        mov  eax, z\n        cmp  eax, t\n        jnl  skipIF\n    doBlock:     `Code for statements that \"do something\"`\n    skipIF:\n\n    2nd IF:\n        mov   eax, x\n        cmp   eax, y\n        je    doElse\n        mov   eax, z\n        cmp   eax, t\n        jnl   doElse\n        ` Code for THEN statements`\n        jmp   endOfIF\n\n    doElse:\n        ` Code for ELSE statements`\n    endOfIF:\n    ```", "```\n    switch(s)\n    {\n       case 0:   `case 0 code`  break;\n       case 1:   `case 1 code`  break;\n       case 2:   `case 2 code`  break;\n       case 3:   `case 3 code`  break;\n    }\n\n        mov eax, s ; Zero-extends!\n        cmp eax, 3\n        ja  skipSwitch\n        lea rbx, jmpTbl\n        jmp [rbx][rax * 8]\n    jmpTbl qword case0, case1, case2, case3\n\n    case0: `case 0 code`\n           jmp skipSwitch\n\n    case1: `case 1 code`\n           jmp skipSwitch\n\n    case2: `case 2 code`\n           jmp skipSwitch\n\n    case3: `case 3 code`\n     skipSwitch:\n\n    switch(t)\n    {\n       case 2:  `case 0 code` break;\n       case 4:  `case 4 code` break;\n       case 5:  `case 5 code` break;\n       case 6:  `case 6 code` break;\n       default: `default code`\n    }\n        mov eax, t ; Zero-extends!\n        cmp eax, 2\n        jb  swDefault\n        cmp eax, 6\n        ja  swDefault\n        lea rbx, jmpTbl\n        jmp [rbx][rax * 8 – 2 * 8]\n    jmpTbl qword case2, swDefault, case4, case5, case6\n\n    swDefault: `default code`\n           jmp endSwitch\n\n    case2: `case 2 code`\n           jmp endSwitch\n\n    case4: `case 4 code`\n           jmp endSwitch\n\n    case5: `case 5 code`\n           jmp endSwitch\n\n    case6: `case 6 code`\n\n    endSwitch:\n\n    switch(u)\n    {\n       case 10:  ` case 10 code ` break;\n       case 11:  ` case 11 code ` break;\n       case 12:  ` case 12 code ` break;\n       case 25:  ` case 25 code ` break;\n       case 26:  ` case 26 code ` break;\n       case 27:  ` case 27 code ` break;\n       default:  ` default code`\n    } \n         lea rbx, jmpTbl1  ; Assume cases 10-12\n         mov eax, u        ; Zero-extends!\n         cmp eax, 10\n         jb  swDefault\n         cmp eax, 12\n         jbe sw1\n         cmp eax, 25\n         jb  swDefault\n         cmp eax, 27\n     ja  swDefault\n         lea rbx, jmpTbl2\n         jmp [rbx][rax * 8 – 25 * 8]\n    sw1: jmp [rbx][rax*8-2*8]\n    jmpTbl1 qword case10, case11, case12\n    jmpTbl2 qword case25, case26, case27\n\n    swDefault: `default code`\n           jmp endSwitch\n\n    case10: `case 10 code`\n           jmp endSwitch\n\n    case11: `case 11 code`\n           jmp endSwitch\n\n    case12: `case 12 code`\n           jmp endSwitch\n\n    case25: `case 25 code`\n           jmp endSwitch\n\n    case26: `case 26 code`\n           jmp endSwitch\n\n    case27: `case 27 code`\n\n    endSwitch:\n    ```", "```\n    while(i < j)\n    {\n         `Code for loop body`\n    }\n\n    whlLp:\n         mov eax, i\n         cmp eax, j\n         jnl endWhl\n          `Code for loop body`\n         jmp whlLp\n    endWhl:\n\n    while(i < j && k != 0)\n    {\n         `Code for loop body, part a`\n        if(m == 5) continue;\n         `Code for loop body, part b`\n        if(n < 6) break;\n         `Code for loop body, part c`\n    }\n\n    ; Assume short-circuit evaluation:\n     whlLp:\n         mov eax, i\n         cmp eax, j\n         jnl endWhl\n         mov eax, k\n         cmp eax, 0\n         je  endWhl\n         ` Code for loop body, part a`\n         cmp m, 5\n         je  whlLp\n         ` Code for loop body, part b`\n         cmp n, 6\n         jl  endWhl\n        `  Code for loop body, part c`\n         jmp whlLp\n    endWhl:\n\n    do\n    {\n       `Code for loop body`\n    } while(i != j);\n\n    doLp:\n       `Code for loop body`\n         mov eax, i\n         cmp eax, j\n         jne doLp\n\n    do\n    {\n       `Code for loop body, part a`\n        if(m != 5) continue;\n       `Code for loop body, part b`\n        if(n == 6) break;\n       `Code for loop body, part c`\n    } while(i < j && k > j);\n\n    doLp:\n      ` Code for loop body, part a`\n         cmp m, 5\n         jne doCont\n      ` Code for loop body, part b`\n         cmp n, 6\n         je  doExit\n      ` Code for loop body, part c`\n    doCont:     mov eax, i\n         cmp eax, j\n         jnl doExit\n         mov eax, k\n         cmp eax, j\n         jg  doLp\n    doExit:\n\n    for(int i = 0; i < 10; ++i)\n    {\n       `Code for loop body`\n    }\n\n           mov i, 0\n    forLp: cmp i, 10\n           jnl forDone\n           ` Code for loop body`\n           inc i\n           jmp forLp\n    forDone:\n    ```", "```\n        mov rax, qword ptr y\n        add rax, qword ptr z\n        mov qword ptr x, rax\n        mov rax, qword ptr y[8]\n        adc rax, qword ptr z[8]\n        mov qword ptr x[8], rax\n        ```", "```\n        mov rax, qword ptr y\n        add rax, qword ptr z\n        mov qword ptr x, rax\n        mov eax, dword ptr z[8] \n        adc eax, qword ptr y[8]\n        mov dword ptr x[8], eax\n        ```", "```\n        mov eax, dword ptr y\n        add eax, dword ptr z\n        mov dword ptr x, eax\n        mov ax, word ptr z[4]\n        adc ax, word ptr y[4]\n        mov word ptr x[4], ax\n        ```", "```\n        mov rax, qword ptr y\n        sub rax, qword ptr z\n        mov qword ptr x, rax\n        mov rax, qword ptr y[8]\n        sbb rax, qword ptr z[8]\n        mov qword ptr x[8], rax\n        mov rax, qword ptr y[16]\n        sbb rax, qword ptr z[16]\n        mov qword ptr x[16], rax\n        ```", "```\n        mov rax, qword ptr y\n        sub rax, qword ptr z\n        mov qword ptr x, rax\n        mov eax, dword ptr y[8]\n        sbb eax, dword ptr z[8]\n        mov dword ptr x[8], eax\n        ```", "```\n    mov rax, qword ptr y\n    mul qword ptr z\n    mov qword ptr x, rax\n    mov rbx, rdx\n\n    mov rax, qword ptr y\n    mul qword ptr z[8]\n    add rax, rbx\n    adc rdx, 0\n    mov qword ptr x[8], rax\n    mov rbx, rdx\n\n    mov rax, qword ptr y[8]\n    mul qword ptr z\n    add x[8], rax\n    adc rbx, rdx\n\n    mov rax, qword ptr y[8]\n    mul qword ptr z[8]\n    add rax, rbx\n    mov qword ptr x[16], rax\n    adc rdx, 0\n    mov qword ptr x[24], rdx\n    ```", "```\n    mov  rax, qword ptr y[8]\n    cqo\n    idiv qword ptr z\n    mov  qword ptr x[8], rax\n    mov  rax, qword ptr y\n    idiv qword ptr z\n    mov  qword ptr x, rax\n    ```", "```\n        ; Note: order of comparison (HO vs. LO) is irrelevant\n        ; for \"==\" comparison.\n\n         mov rax, qword ptr x[8]\n            cmp rax, qword ptr y[8]\n            jne skipElse\n            mov rax, qword ptr x\n            cmp rax, qword ptr y\n            jne skipElse\n            `then code`\n        skipElse:\n        ```", "```\n         mov rax, qword ptr x[8]\n            cmp rax, qword ptr y[8]\n            jnb skipElse\n            mov rax, qword ptr x\n            cmp rax, qword ptr y\n            jnb skipElse\n           ` then code`\n        skipElse:\n        ```", "```\n         mov rax, qword ptr x[8]\n            cmp rax, qword ptr y[8]\n            jna skipElse\n            mov rax, qword ptr x\n            cmp rax, qword ptr y\n            jna skipElse\n            `then code`\n        skipElse:\n        ```", "```\n        ; Note: order of comparison (HO vs. LO) is irrelevant\n        ; for \"!=\" comparison.\n\n            mov rax, qword ptr x[8]\n            cmp rax, qword ptr y[8]\n            jne doElse\n            mov rax, qword ptr x\n            cmp rax, qword ptr y\n            je skipElse\n        doElse:\n            `then code`\n        skipElse:\n        ```", "```\n        ; Note: order of comparison (HO vs. LO) is irrelevant\n        ; for \"==\" comparison.\n\n            mov eax, dword ptr x[8]\n            cmp eax, dword ptr y[8]\n         jne skipElse\n            mov rax, qword ptr x\n            cmp rax, qword ptr y\n            jne skipElse\n            `then code`\n        skipElse:\n        ```", "```\n         mov eax, dword ptr x[8]\n            cmp eax, dword ptr y[8]\n            jnb skipElse\n            mov rax, qword ptr x\n            cmp rax, qword ptr y\n            jnb skipElse\n            `then code`\n        skipElse:\n        ```", "```\n         mov eax, dword ptr x[8]\n            cmp eax, dword ptr y[8]\n            jna skipElse\n            mov rax, qword ptr x\n            cmp rax, qword ptr y\n            jna skipElse\n            `then code`\n        skipElse:\n        ```", "```\n        neg qword ptr x[8]\n        neg qword ptr x\n        sbb qword ptr x[8], 0\n\n        xor rax, rax\n        xor rdx, rdx\n        sub rax, qword ptr x\n        sbb rdx, qword ptr x[8]\n        mov qword ptr x, rax\n        mov qword ptr x[8], rdx\n        ```", "```\n        mov rax, qword ptr y\n        mov rdx, qword ptr y[8]\n        neg rdx\n        neg rax\n        sbb rdx, 0\n        mov qword ptr x, rax\n        mov qword ptr x[8], rdx\n\n        xor rdx, rdx\n        xor rax, rax\n        sub rax, qword ptr y\n        sbb rdx, qword ptr y[8]\n        mov qword ptr x, rax\n        mov qword ptr x[8], rdx\n        ```", "```\n        mov rax, qword ptr y\n        and rax, qword ptr z\n        mov qword ptr x, rax\n        mov rax, qword ptr y[8]\n        and rax, qword ptr z[8]\n        mov qword ptr x[8], rax\n        ```", "```\n        mov rax, qword ptr y\n        or  rax, qword ptr z\n        mov qword ptr x, rax\n        mov rax, qword ptr y[8]\n        or  rax, qword ptr z[8]\n        mov qword ptr x[8], rax\n        ```", "```\n        mov rax, qword ptr y\n        xor rax, qword ptr z\n        mov qword ptr x, rax\n        mov rax, qword ptr y[8]\n        xor rax, qword ptr z[8]\n        mov qword ptr x[8], rax\n        ```", "```\n        mov rax, qword ptr y\n        not rax\n        mov qword ptr x, rax\n        mov rax, qword ptr y[8]\n        not rax\n        mov qword ptr x[8], rax\n        ```", "```\n        mov rax, qword ptr y\n        shl rax, 1\n        mov qword ptr x, rax\n        mov rax, qword ptr y[8]\n        rcl rax, 1\n        mov qword ptr x[8], rax\n        ```", "```\n        mov rax, qword ptr y[8]\n        shr rax, 1\n        mov qword ptr x[8], rax\n        mov rax, qword ptr y\n        rcr rax, 1\n        mov qword ptr x rax\n        ```", "```\n    mov rax, qword ptr y[8]\n    sar rax, 1\n    mov qword ptr x[8], rax\n    mov rax, qword ptr y\n    rcr rax, 1\n    mov qword ptr x, rax\n    ```", "```\n    rcl qword ptr x, 1\n    rcl qword ptr x[8], 1\n    ```", "```\n    rcr qword ptr x[8], 1\n    rcr qword ptr x, 1\n    ```", "```\n    btoh        proc\n\n                mov     ah, al      ; Do HO nibble first\n                shr     ah, 4       ; Move HO nibble to LO\n                or      ah, '0'     ; Convert to char\n                cmp     ah, '9' + 1 ; Is it \"A\" to \"F\"?\n                jb      AHisGood\n\n    ; Convert 3Ah to 3Fh to \"A\" to \"F\".\n\n                add     ah, 7\n\n    ; Process the LO nibble here.\n\n    AHisGood:   and     al, 0Fh     ; Strip away HO nibble\n                or      al, '0'     ; Convert to char\n                cmp     al, '9' + 1 ; Is it \"A\" to \"F\"?\n                jb      ALisGood\n\n    ; Convert 3Ah to 3Fh to \"A\" to \"F\".\n\n     add     al, 7\n    ALisGood:   ret\n    btoh        endp\n    ```", "```\n    ; Inputs:\n    ;    RAX -   Number to convert to string.\n    ;    CL  -   minDigits (minimum print positions).\n    ;    CH  -   Padding character.\n    ;    RDI -   Buffer pointer for output string.\n    ```", "```\n    ; On Entry:\n\n       ; r10        - Real10 value to convert.\n       ;              Passed in ST(0).\n\n       ; fWidth     - Field width for the number (note that this\n       ;              is an *exact* field width, not a minimum\n       ;              field width).\n       ;              Passed in EAX (RAX).\n\n       ; decimalpts - # of digits to display after the decimal pt.\n       ;              Passed in EDX (RDX). \n\n       ; fill       - Padding character if the number is smaller\n       ;              than the specified field width.\n       ;              Passed in CL (RCX).\n\n       ; buffer     - r10ToStr stores the resulting characters\n       ;              in this string.\n       ;              Address passed in RDI.\n\n       ; maxLength  - Maximum string length.\n       ;              Passed in R8D (R8).\n    ```", "```\n    ; On Entry:\n\n    ;    e10     - Real10 value to convert.\n    ;              Passed in ST(0).\n\n    ;    width   - Field width for the number (note that this\n    ;              is an *exact* field width, not a minimum\n    ;              field width).\n    ;              Passed in RAX (LO 32 bits).\n\n    ;    fill    - Padding character if the number is smaller\n    ;              than the specified field width.\n    ;              Passed in RCX.\n\n    ;    buffer  - e10ToStr stores the resulting characters in\n    ;              this buffer (passed in EDI).\n    ;              Passed in RDI (LO 32 bits).\n\n    ;    expDigs - Number of exponent digits (2 for real4,\n    ;              3 for real8, and 4 for real10).\n    ;              Passed in RDX (LO 8 bits).\n    ```", "```\n        lea rbx, f\n        mov al, input\n        xlat\n        ```", "```\n        lea rbx, f\n        movzx rax, input\n        mov ax, [rbx][rax * 2]\n        ```", "```\n        lea rbx, f\n        movzx rax, input\n        mov al, [rbx][rax * 1]\n        ```", "```\n        lea rbx, f\n        movzx rax, input\n        mov ax, [rbx][rax * 2]\n        ```", "```\n    data  segment align(64) 'DATA'\n               .\n               .\n               .\n    data  ends\n    ```", "```\n    `target`: `dependencies`\n        `commands`\n    ```"]