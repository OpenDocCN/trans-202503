<html><head></head><body>
<section epub:type="introduction" role="doc-introduction" aria-labelledby="int">&#13;
<hgroup>&#13;
<h1 class="CT" id="int"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxi" aria-label=" Page xxi. "/><samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</samp></h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">Nearly all programming jobs today require at least a cursory understanding of full-stack development, but if you’re a beginner, you might struggle to find the right entry point to this overwhelming topic. You might not even know what the term means.</p>&#13;
<p class="TX">Simply put, <i>full-stack web development</i> typically refers to the creation of complete web applications using JavaScript and the many frameworks built for it. It requires a mastery of the traditional disciplines of frontend and backend development, as well as the ability to write middleware and various kinds of application programming interfaces (APIs).</p>&#13;
<p class="TX">Lastly, a well-rounded full-stack developer can handle databases and has professional skills, such as the ability to craft automated tests and deploy their code by themselves. To do all of this, they must understand HTML, CSS, and JavaScript, as well as the language’s typed counterpart, TypeScript. For a crash course on some of this terminology, see <span class="Xref">“The Parts of a Full-Stack Application” on page xxiv</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxii" aria-label=" Page xxii. "/>If this sounds like a lot, you’ve come to the right place. This book will introduce you to each component of a modern application and teach you how to use some of the most widely used technologies to build them.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-1"/><samp class="SANS_Futura_Std_Bold_B_11">Who Should Read This Book?</samp></h2>&#13;
<p class="TNI">There are two primary audiences for the book. The first includes professional frontend or backend engineers who want to advance their careers by mastering full-stack development. The second includes inexperienced, beginning developers interested in learning about web development.</p>&#13;
<p class="TX">While the book introduces many technologies from scratch, it assumes some prior familiarity with HTML, CSS, and JavaScript, as well as the client/server architecture of most web applications. For a refresher, see <i>The Coding Workbook</i> by Sam Taylor (No Starch Press, 2020), which teaches you how to build a website with HTML and CSS, and <i>The Book of CSS3</i>, 2nd edition, by Peter Gasston (No Starch Press, 2014) to sharpen your CSS skills. To familiarize yourself with JavaScript, I recommend <i>JavaScript Crash Course</i> by Nick Morgan (No Starch Press, 2024), which is a fast-paced JavaScript tutorial for beginners, and <i>Eloquent JavaScript</i>, 3rd edition, by Marijn Haverbeke (No Starch Press, 2018), for a deep dive into JavaScript.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h1-2"/><samp class="SANS_Futura_Std_Bold_B_11">What’s in This Book?</samp></h2>&#13;
<p class="TNI">The book is split into two parts. <a href="part1.xhtml">Part I</a>, comprising <a href="chapter1.xhtml">Chapters 1</a> through <a href="chapter10.xhtml">10</a>, introduces you to the components of a modern technology stack. Each chapter focuses on one technology and highlights the topics you need to know as a full-stack developer. The exercises will encourage you to begin writing application code from page 1.</p>&#13;
<p class="RunInPara1"><b><a href="chapter1.xhtml">Chapter 1</a>: Node.js  </b>Introduces you to Node.js and its ecosystem, which let you run JavaScript code outside a browser. Then you’ll use Node.js and the Express.js framework to create your own simple web server with JavaScript.</p>&#13;
<p class="RunInPara"><b><a href="chapter2.xhtml">Chapter 2</a>: Modern JavaScript  </b>Focuses on contemporary JavaScript syntax useful for full-stack developers, including how to use modules to write maintainable code packages. We look at the different ways to define variables and constants, the arrow function, and techniques for asynchronous code. You’ll use these to rewrite your JavaScript server.</p>&#13;
<p class="RunInPara"><b><a href="chapter3.xhtml">Chapter 3</a>: TypeScript  </b>Introduces TypeScript, a superset of JavaScript, and highlights how modern full-stack development benefits from it. We discuss the shortcomings and pitfalls of JavaScript and how to effectively leverage TypeScript’s type system through inference. You’ll conclude the chapter by refactoring your JavaScript server with type annotations, custom types, and interfaces.</p>&#13;
<p class="RunInPara"><b><a href="chapter4.xhtml">Chapter 4</a>: React  </b>Discusses React, one of the most common libraries for creating user interface components. You’ll see how its components simplify full-stack development and learn how to use its JSX elements, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxiii" aria-label=" Page xxiii. "/>the virtual DOM, and hooks. You’ll then use React to add a reactive user interface to your Express.js server.</p>&#13;
<p class="RunInPara"><b><a href="chapter5.xhtml">Chapter 5</a>: Next.js  </b>Focuses on Next.js, the leading web application framework built on top of React. You’ll create pages and custom API routes with Next.js’s file-based routing before learning different ways to render a page within the framework. Finally, you’ll migrate the Express.js server to Next.js as an exercise.</p>&#13;
<p class="RunInPara"><b><a href="chapter6.xhtml">Chapter 6</a>: REST and GraphQL APIs  </b>Teaches you all about APIs, what they are, and how to use them for full-stack web development. We explore two kinds of APIs: REST and GraphQL. You’ll conclude the chapter by adding an Apollo GraphQL server to your Next.js full-stack application.</p>&#13;
<p class="RunInPara"><b><a href="chapter7.xhtml">Chapter 7</a>: MongoDB and Mongoose  </b>Discusses the differences between traditional relational databases and non-relational databases such as MongoDB. You’ll add the Mongoose object data modeling tool to your technology stack to simplify working with a database. You’ll then connect the GraphQL API to your own MongoDB database.</p>&#13;
<p class="RunInPara"><b><a href="chapter8.xhtml">Chapter 8</a>: Testing with the Jest Framework  </b>Explains the importance of automated tests and test-driven development to full-stack development. We explore different types of tests, common test patterns, and the concepts of test doubles, stubs, fakes, and mocks. Lastly, you’ll add a few basic snapshot tests to your Next.js application with the Jest framework.</p>&#13;
<p class="RunInPara"><b><a href="chapter9.xhtml">Chapter 9</a>: Authorization with OAuth  </b>Discusses authentication and authorization and how full-stack developers can use the OAuth protocol to handle those tasks by integrating with a third-party service. We walk through this authorization flow and its components. You’ll run through a complete OAuth interaction on the command line to explore each step in depth.</p>&#13;
<p class="RunInPara2"><b><a href="chapter10.xhtml">Chapter 10</a>: Containerization with Docker  </b>Introduces you to using Docker to deploy your application. We cover the concept of a microservice architecture, then cover all relevant components of the Docker ecosystem: the host, the Docker daemon, Dockerfiles, images, containers, volumes, and Docker Compose. You’ll conclude by splitting your application into self-contained microservices.</p>&#13;
<p class="TX">In <a href="part2.xhtml">Part II</a>, you’ll use your newfound knowledge to build a web application that applies the concepts, tools, and frameworks introduced in <a href="part1.xhtml">Part I</a>. The Food Finder application is a location search service that lets users log in with their GitHub account and maintain a wish list of places to visit.</p>&#13;
<p class="RunInPara1"><b><a href="chapter11.xhtml">Chapter 11</a>: Setting Up the Docker Environment  </b>Create the foundation of your Food Finder application by using your knowledge of Docker and containerization to set up your development environment. You’ll use Docker Compose to decouple the application development from your local system and then add a MongoDB server as its own service.</p>&#13;
<p class="RunInPara"><b><a href="chapter12.xhtml">Chapter 12</a>: Building the Middleware  </b>Create the first part of the Food Finder application’s middleware. Here you’ll connect Mongoose to the MongoDB service and create its schema, model, services, and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxiv" aria-label=" Page xxiv. "/>custom types. With these pieces in place, you’ll be able to create, read, update, and delete data from your database.</p>&#13;
<p class="RunInPara"><b><a href="chapter13.xhtml">Chapter 13</a>: Building the GraphQL API  </b>Use your knowledge of GraphQL to add an Apollo GraphQL server to your Food Finder application, then implement a public GraphQL API. You’ll be able to use the Apollo sandbox to read and update data with GraphQL on your MongoDB server.</p>&#13;
<p class="RunInPara"><b><a href="chapter14.xhtml">Chapter 14</a>: Building the Frontend  </b>Use React components and the Next.js framework to build the frontend for the Food Finder application. At this point, you’ll have implemented a complete modern full-stack application that reads data from the database through your custom middleware and renders the data to your application’s frontend.</p>&#13;
<p class="RunInPara"><b><a href="chapter15.xhtml">Chapter 15</a>: Adding OAuth  </b>Add an OAuth flow to your app so that visitors can log in to maintain a personal wish list of locations. You’ll use the <i>next-auth</i> package from Auth.js to add login options using GitHub.</p>&#13;
<p class="RunInPara2"><b><a href="chapter16.xhtml">Chapter 16</a>: Running Automated Tests in Docker  </b>Set up automated snapshot tests with Jest and configure a new service to run the tests automatically.</p>&#13;
<p class="TX">Then, in the appendices, you’ll get detailed information on the TypeScript Compiler options and the most common Jest matchers. Also, you’ll use your newfound knowledge to explore and understand Next.js’s modern app directory approach.</p>&#13;
<p class="RunInPara1"><b><a href="appendix-A.xhtml">Appendix A</a>: TypeScript Compiler Options  </b>Shows the most common TypeScript Compiler (TSC) options so that you can customize your own TypeScript projects to your liking.</p>&#13;
<p class="RunInPara"><b><a href="appendix-B.xhtml">Appendix B</a>: The Next.js app Directory  </b>Explores a new routing pattern using the <i>app</i> directory that Next.js introduced in version 13. You can then choose to work with either the traditional pages approach covered in <span class="runinpara_Xref"><a href="chapter5.xhtml">Chapter 5</a></span> or the modern <i>app</i> directory in your own upcoming projects.</p>&#13;
<p class="RunInPara2"><b><a href="appendix-C.xhtml">Appendix C</a>: Common Matchers  </b>Shows the most common matchers for testing your applications with Jest and the Jest DOM.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h2 class="H1" id="sec3"><span id="h1-3"/><samp class="SANS_Futura_Std_Bold_B_11">The Parts of a Full-Stack Application</samp></h2>&#13;
<p class="TNI">Throughout this book, we’ll discuss various portions of an application. This section gives you a crash course on what we mean when we use the terms <i>frontend</i>, <i>middleware</i>, and <i>backend</i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h2-1"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Frontend</samp></h3>&#13;
<p class="TNI">The frontend is the user-facing part of a website or web application. It runs on the client, typically a web browser. You can think of it as the “front <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxv" aria-label=" Page xxv. "/>office” of the web application. For example, on <a href="https://www.google.com"><i>https://<wbr/>www<wbr/>.google<wbr/>.com</i></a>, the frontend is a page with a simple search bar, though of course, frontend development can be much more complex than this; take a look at Google’s search results page or the interface of the last website you visited.</p>&#13;
<p class="TX">Frontend developers focus on user engagement, experiences, and interfaces. They rely on HTML for creating the elements of the website’s interface, CSS for styling, JavaScript for user interactions, and frameworks such as Next.js to pull everything together.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h2-2"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Middleware</samp></h3>&#13;
<p class="TNI">The middleware connects an application’s frontend and backend and performs all of its chores, such as integrating with third-party services and transferring and updating data. You can think of it as the employees on the company floor.</p>&#13;
<p class="TX">As full-stack developers, we often write middleware for <i>routing</i> our applications, which means serving the correct data for a particular URL, handling database connections, and performing authorization. For example, on <a href="https://www.google.com"><i>https://<wbr/>www<wbr/>.google<wbr/>.com</i></a>, the middleware asks the server for the landing page’s HTML. Then a different part of the middleware checks whether the user is logged in, and if so, which personal data it should show. Meanwhile, a third part of the middleware consolidates the information from each of these data streams and then answers the server’s requests with the correct HTML.</p>&#13;
<p class="TX">One essential part of a full-stack application’s middleware is its <i>API layer</i>, which exposes the application’s APIs. Generally, an API is code written to connect two machines. Often, an API lets the frontend code (or a third party) access the application’s backend. JavaScript-driven development relies on two primary architectural frameworks for creating APIs: REST and GraphQL, both of which are covered in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.</p>&#13;
<p class="TX">You could write the middleware by using any programming language. Most full-stack developers use modern JavaScript or TypeScript, but they could instead use PHP, Ruby, or Go.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h2-3"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Backend</samp></h3>&#13;
<p class="TNI">The backend is the invisible part of a web application. In a JavaScript-driven application, the backend runs on a server, typically Express.js, though others might use Apache or NGINX. You can think of it as the “back office” of the web application.</p>&#13;
<p class="TX">More concretely, the backend handles any operations involving the application’s data. It performs create, read, update, and delete (CRUD) operations on the values stored in the database and returns the datasets requested by the user through the middleware’s API layer. For <a href="https://www.google.com"><i>https://<wbr/>www<wbr/>.google<wbr/>.com</i></a>, the backend is the code that searches the database for the keywords you entered in the frontend, which the backend received through the middleware. The middleware would combine these search results with other relevant pieces of information. Then the user would see the search results page rendered by the frontend.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxvi" aria-label=" Page xxvi. "/>Backend development can be done in any programming language. Full-stack developers usually employ modern JavaScript or TypeScript. Other options include PHP, Ruby, Elixir, Python, Java, and frameworks like Symfony, Ruby on Rails, Phoenix, and Django.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h2 class="H1" id="sec7"><span id="h1-4"/><samp class="SANS_Futura_Std_Bold_B_11">A Brief History of JavaScript and Full-Stack Development</samp></h2>&#13;
<p class="TNI">All developers should understand the context of the tools they’re using. Before we begin developing, let’s start with a bit of history.</p>&#13;
<p class="TX">The full-stack developer position evolved alongside JavaScript, which began as nothing more than a scripting language that ran in users’ browsers. Developers used it to add elements to their websites, such as accordions, pop-up menus, and overlays, that reacted immediately to a user’s behavior, without requiring requests to the application’s server.</p>&#13;
<p class="TX">Until the late 2000s, most JavaScript libraries were designed to provide consistent interfaces to handle vendor-specific quirks. Often, the JavaScript engines were slow, especially when interacting with, updating, or modifying the HTML. Hence, JavaScript was considered a quirky scripting language for the frontend and was frowned upon by backend developers.</p>&#13;
<p class="TX">Several projects attempted to popularize the use of JavaScript in the backend, but until the release of Node.js in 2009, these didn’t gain any traction. Node.js, covered in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, is a JavaScript tool for developing backends. Shortly thereafter, the Node.js package manager npm built the missing ecosystem for full-stack JavaScript development.</p>&#13;
<p class="TX">This ecosystem includes a host of JavaScript libraries for working with databases, building user interfaces, and writing server-side code (many of which we’ll explore in this book). These new tools allowed developers to use JavaScript reliably on both the client and the server. Of particular importance, Google released the Angular framework in 2010, and Meta (known as Facebook at the time) released React in 2013. The commitment of these internet giants to building JavaScript tools turned full-stack web development into a sought-after role.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h2 class="H1" id="sec8"><span id="h1-5"/><samp class="SANS_Futura_Std_Bold_B_11">Setting Up</samp></h2>&#13;
<p class="TNI">Throughout this book, you’ll write code and run command line tools. You can use any development environment you’d like, but here are some guidelines.</p>&#13;
<p class="TX">The most common code editor these days is Visual Studio Code, which you can download from <a href="https://code.visualstudio.com"><i>https://<wbr/>code<wbr/>.visualstudio<wbr/>.com</i></a>. It is Microsoft’s open source editor and is free for Windows, macOS, and Linux. In addition, you can extend and configure it through a plethora of third-party plug-ins and adjust its appearance to your liking. However, if you’re used to a different editor, such as Vim or Emacs, you can keep using it. The book doesn’t require a particular tool.</p>&#13;
<p class="TX">Depending on your operating system, your default command line program will be either the <i>Command Prompt</i> (on Windows) or the <i>Terminal</i> (on <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxvii" aria-label=" Page xxvii. "/>macOS and Linux). These programs use slightly different syntax for tasks like creating, changing, and listing the contents of a directory. This book shows the Linux and macOS versions of these commands. If you’re using Windows, you’ll have to adapt the commands for your operating system. For example, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp>, Windows uses <samp class="SANS_TheSansMonoCd_W5Regular_11">dir</samp> to list files and folders in the current directory. Microsoft’s official command line reference lists all available commands here: <a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands#command-line-reference-a-z"><i>https://<wbr/>learn<wbr/>.microsoft<wbr/>.com<wbr/>/en<wbr/>-us<wbr/>/windows<wbr/>-server<wbr/>/administration<wbr/>/windows<wbr/>-commands<wbr/>/windows<wbr/>-commands#command<wbr/>-line<wbr/>-reference<wbr/>-a<wbr/>-z</i></a>.</p>&#13;
<p class="TX">The most notable difference between operating systems relevant to this book is the escape character used for line breaks in multiline cURL commands. This escape character is <samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp> on macOS and <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp> on Windows. We’ll point out these differences in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, when we first use cURL.</p>&#13;
<p class="TX">You can download the code listings for the first part of the book and the complete source code for the Food Finder application from <a href="https://www.usemodernfullstack.dev/downloads"><i>https://<wbr/>www<wbr/>.usemodernfullstack<wbr/>.dev<wbr/>/downloads</i></a>.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>