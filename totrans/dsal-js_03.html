<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_23" aria-label="23"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch2">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">2</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">FUNCTIONAL PROGRAMMING IN</span> <span class="SANS_Dogma_OT_Bold_B_11">JAVASCRIPT</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO"><i>Functional programming (FP)</i> is a programming paradigm based on functions, which are the only building blocks for your code. Using FP improves your code’s modularity and helps you write more understandable, testable, and easy-to-maintain code while avoiding bugs; it’s a win all around.</p>&#13;
<p class="TX">Some people claim that FP is an enlightened approach to programming that leaves <i>object-oriented programming (OOP)</i> and other paradigms far behind. Others say that it is only theoretical, is not applicable “in the real world,” and causes more problems than it solves. As in most domains, the differences aren’t black or white, but a shade of gray. It’s not a matter of using only FP or never using FP. We’ll use it in this book, but not dogmatically, and in this chapter, you’ll see how JavaScript lets you work functionally, how and when to use FP, and instances when <i>not</i> to use it. Wherever FP applies and is more appropriate, we’ll use it, but if OOP is better suited, it will be used instead.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_24" aria-label="24"/><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>FP is not a modern fad. The second-oldest programming language still in common use (after FORTRAN, which appeared in 1957) is LISP (which appeared one year later), and it’s completely based on FP. Many other FP languages have appeared in the more than 60 years since, and even nonfunctional languages, such as JavaScript, also provide the same kind of functionality.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-7"/><span class="SANS_Futura_Std_Bold_B_11">Why Use Functional Programming?</span></h3>&#13;
<p class="TNI1">Consider what features are most important to you when programming and then ask whether FP provides them. Most programmers usually want the code they write to be:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>Understandable </b>Code is written once but read many times, and users should be able to “get” your functions and their relationships without great effort. FP tends to produce shorter and cleaner code, which is easier to understand.</p>&#13;
<p class="RunInPara"><b>Maintainable </b>Your code most likely will need maintenance sometime in the future, and it should be easy to do. The same features that make FP code easier to understand also allow for easier maintenance. You also don’t need to worry about breaking other things when modifying any given function.</p>&#13;
<p class="RunInPara"><b>Testable </b>Unit testing is a common part of development work, allowing you to verify the behavior of each component of your code. Unit tests also serve as a sort of documentation, providing examples of how to use any given function to people reading your code. If your programming style doesn’t favor writing easily testable code, you’ll have problems. FP always produces functions you can test on your own.</p>&#13;
<p class="RunInPara"><b>Modular </b>You should divide your code’s features into independent modules, each pertaining to one specific aspect of your program, so that if you make changes in one module, they won’t affect the rest of your code. The goal in FP is to write independent functions you can refactor or modify without impacting other functions. Writing independent functions helps you achieve <i>separation of concerns</i> (distinct parts of a program have little overlap). Also, modules tend to be <i>highly cohesive</i>, which means they include functions that really belong together, and they are <i>loosely coupled</i>, so changes in a function are not likely to require changes in other functions.</p>&#13;
<p class="RunInPara"><b>Reusable </b>Reusing code saves time and money. Because functions stand on their own in FP, you can use a well-written set of functions anywhere.</p>&#13;
</div>&#13;
<p class="TX">Of course, object-oriented code can do all of these things as well. No one is ever going to say that FP is a silver bullet that solves all your software development problems. I always suggest taking the middle road; a well-thought-out, balanced mix is usually the best solution.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_25" aria-label="25"/>&#13;
<h3 class="H1" id="sec2"><span id="h1-8"/><span class="SANS_Futura_Std_Bold_B_11">JavaScript as a Functional Language</span></h3>&#13;
<p class="TNI1"><i>Is JavaScript functional?</i> When people discuss functional languages, they typically mention Haskell, Erlang, Scala, and the like; no one usually includes JavaScript. That might be because no precise definition exists for what constitutes a functional language, what features a functional language should provide, or how it should work. For the purposes of this book, we’ll consider a language to be functional if (and only if) it supports common FP features; you’ll see how JavaScript compares. We’ll take advantage of items like functions as first-class objects, array functions, pure functions, higher-order functions, and recursion and avoid side effects (or <i>impurities</i>, in FP lexicon) using (local or global) state, mutating objects or arguments, and so on.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-14"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Functions as First-Class Objects</span></h4>&#13;
<p class="TNI1">In JavaScript, to say that functions are <i>first-class objects</i> means you can do anything with them that you’d be able to do with other objects. You can store functions in variables, pass functions as arguments, or return a function as a result from some other function.</p>&#13;
<p class="TX">Consider an example of doing an application programming interface (API) call. If you work with something like Axios (or SuperAgent, or other similar libraries that simplify the process of doing an async call to a remote server), you’ve likely seen code like this:</p>&#13;
<pre id="pre-27"><code>axios.get("your/url/api").then(<b>(response) =&gt; {</b>&#13;
<b>  // ...do something with the response</b>&#13;
<b>}</b>)</code></pre>&#13;
<p class="TX">The parameter to the <span class="SANS_TheSansMonoCd_W5Regular_11">.then()</span> method is a function, and it’s passed in the same way you pass a number or an array.</p>&#13;
<p class="TX">In <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, we’ll be doing that as well, and we’ll be also able to assign default values to function parameters in order to change the way the function performs:</p>&#13;
<pre id="pre-28"><code>const preOrder = (tree, <b>visit = (x) =&gt; console.log(x)</b>) =&gt; {&#13;
  if (tree !== null) {&#13;
    visit(tree.key);&#13;
    preOrder(tree.left, visit);&#13;
    preOrder(tree.right, visit);&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">preOrder()</span> function takes two arguments: a <span class="SANS_TheSansMonoCd_W5Regular_11">tree</span> (you’ll learn about trees later) and a <span class="SANS_TheSansMonoCd_W5Regular_11">visit</span> function; if you don’t provide the <span class="SANS_TheSansMonoCd_W5Regular_11">visit</span> function, the default value will be a simple function that just logs whatever you pass to it.</p>&#13;
<p class="TX">Taking one or more functions as parameters makes the function a <i>higher-order function</i>; the other identifying characteristic for such a function is returning a function as a result. Common functions (those that do not receive or return functions) are called <i>first-order functions</i>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_26" aria-label="26"/>Working with the same example, you could also write the following:</p>&#13;
<pre id="pre-29"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const myVisit = (x) =&gt; {&#13;
  // ...do some interesting things with x&#13;
}&#13;
&#13;
let myTree = newTree();&#13;
// ...set up myTree, add to it, etc.&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> preOrder(myTree, <b>myVisit</b>);</code></pre>&#13;
<p class="TX">The function is stored in a variable <span class="CodeAnnotation" aria-label="annotation1">❶</span>, as functions are just another type of value that can go in a variable, and then the variable’s contents are passed to a function <span class="CodeAnnotation" aria-label="annotation2">❷</span> in exactly the same way that you pass <span class="SANS_TheSansMonoCd_W5Regular_11">myTree</span>, another variable with a different kind of value.</p>&#13;
<p class="TX">You’ll see more examples throughout this chapter, including functions that return functions as results.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-15"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Declarative-Style Programming</span></h4>&#13;
<p class="TNI1">FP works in a higher-level, <i>declarative</i> style instead of the imperative style used in procedural, “common” programming. With declarative programming, you specify what you want, but not the individual detailed steps necessary to accomplish it, as you would do in procedural coding. The best example of declarative coding involves arrays. Working with arrays usually entails loops, which you can do “by hand” (think of using a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop) or with the preferred <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> statement, but JavaScript lets you work declaratively with some specific array functions. In fact, we’ll look at some <i>methods</i> for this, but the same concept applies; a method is just a function after all.</p>&#13;
<p class="TX">The following list details some of the available array functions that let you search or select elements from an array:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>.filter() </b>Picks elements that satisfy some condition out of an array</p>&#13;
<p class="RunInPara"><b>.find() and .findIndex() </b>Search an array to find an element that satisfies some condition</p>&#13;
<p class="RunInPara"><b>.some() </b>Lets you know whether at least one element of an array satisfies a condition</p>&#13;
<p class="RunInPara"><b>.every() </b>Lets you test whether all elements of an array satisfy a condition</p>&#13;
</div>&#13;
<p class="TX">Other functions transform an array into a new array or a single result:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>.map() </b>Lets you transform one array into another by applying a given function to its elements</p>&#13;
<p class="RunInPara"><b>.reduce() </b>Applies a given operation to the whole array from left to right, reducing it to a single result</p>&#13;
<p class="RunInPara"><b>.reduceRight() </b>Works like <span class="SANS_TheSansMonoCd_W5Regular_11">.reduce()</span> but from right to left</p>&#13;
</div>&#13;
<p class="TX">This list isn’t meant to be complete: there are more functions that transform arrays, like <span class="SANS_TheSansMonoCd_W5Regular_11">.flat()</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">.flatMap()</span>, but you won’t see them here.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_27" aria-label="27"/><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Some people say that these functions are slower than the corresponding hand-written loops and that you’ll suffer some performance hit for using them. Even if those things were true, they are irrelevant. Unless you are having some real performance problems and after analyzing your code you reach the conclusion that the array functions are to blame, writing longer, more bug-prone code doesn’t really make much sense.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h5 class="H3" id="sec5"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Filtering an Array</span></h5>&#13;
<p class="TNI1">Let’s take a look at a common task: going through an array, selecting elements that satisfy some condition, and dropping the rest. The <span class="SANS_TheSansMonoCd_W5Regular_11">.filter()</span> method does exactly that: you provide a <i>predicate</i> (a function that produces a boolean result in terms of its arguments), and a new array is produced, with only the elements of the original array for which the predicate returned true.</p>&#13;
<p class="TX">For example, to select all values under 21, the following predicate would be useful:</p>&#13;
<pre id="pre-30"><code>const under21 = (value) =&gt; value &lt; 21;</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">under21()</span> function gets a value and returns true if the value is less than 21. Now you can write the code as follows:</p>&#13;
<pre id="pre-31"><code>let myArray = [22, 9, 60, 12, 4, 56];&#13;
let newArray = <b>myArray.filter(under21)</b>;&#13;
console.log(newArray); // [9, 12, 4]</code></pre>&#13;
<p class="TX">This specifies that you want to apply the “under 21” check to filter the original array, and the result is a new array with only the values that satisfied the given test. You don’t need to write anything to control a loop, initialize an output array, or anything else. The code is much shorter and truly declarative; it specifies only <i>what</i> you wanted to get, not <i>how</i> to get it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h5 class="H3" id="sec6"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Searching an Array</span></h5>&#13;
<p class="TNI1">Other methods let you search an array for some element that satisfies a predicate, returning either the element or its position in the array:</p>&#13;
<p class="RunInHead"><b>find() </b>Goes through the array from beginning to end, testing for the given predicate; if an element of the array satisfies it, the element is returned; if no elements satisfy the predicate, <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span> is returned. A recent new method, <span class="SANS_TheSansMonoCd_W5Regular_11">findLast()</span>, does the same, but searches from the end to the beginning.</p>&#13;
<p class="RunInHead"><b>findIndex() </b>Is similar to <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span>, but it returns the position of the first element satisfying the predicate or <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> if no elements satisfy it. The new <span class="SANS_TheSansMonoCd_W5Regular_11">findLastIndex()</span> returns the position of the last element that satisfies the predicate.</p>&#13;
<p class="TX">These methods are practical, because they provide all the needed search code in a single line. There is no limit to the complexity of a search <span role="doc-pagebreak" epub:type="pagebreak" id="pg_28" aria-label="28"/>predicate. You aren’t limited to looking only for a value, for example, and can test any condition, as you did with <span class="SANS_TheSansMonoCd_W5Regular_11">under21()</span> previously.</p>&#13;
<p class="TX">Here are examples of using both of these searching methods at once, since they are related and similar:</p>&#13;
<pre id="pre-32"><code>let myArray = [22, 9, 60, 12, 4, 56];&#13;
const under21 = (value) =&gt; value &lt; 21;&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> console.log(myArray.find(under21));      <b>// 9</b>&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> console.log(myArray.findIndex(under21)); <b>// 1</b>&#13;
&#13;
const equal21 = (value) =&gt; value === 21;&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> console.log(myArray.find(equal21));      <b>// undefined</b>&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> console.log(myArray.findIndex(equal21)); <b>// -1</b></code></pre>&#13;
<p class="TX">The first element of <span class="SANS_TheSansMonoCd_W5Regular_11">myArray</span> that satisfies the <span class="SANS_TheSansMonoCd_W5Regular_11">under21</span> predicate is <span class="SANS_TheSansMonoCd_W5Regular_11">9</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and it’s at position 1 of the array <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If you redo the calls using an <span class="SANS_TheSansMonoCd_W5Regular_11">equal21</span> predicate that checks whether a value is 21, you get <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>, because no such element is found in the array.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you are searching for a specific value,</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.includes()</span><i>,</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.index()</span><i>, and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.lastIndexOf()</span> <i>are quite useful, though less flexible than the FP-oriented methods described earlier, because they just let you search for a value and not test for any possible condition.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3" id="sec7"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Testing an Array</span></h5>&#13;
<p class="TNI1">Related methods for searching are <span class="SANS_TheSansMonoCd_W5Regular_11">.some()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.every()</span>. The first checks whether <i>any</i> element of an array satisfies some predicate, and the second checks whether <i>all</i> elements satisfy it:</p>&#13;
<pre id="pre-33"><code>let myArray = [22, 9, 60, 12, 4, 56];&#13;
const under21 = (value) =&gt; value &lt; 21;&#13;
console.log(myArray.some(under21));  <b>// true</b>&#13;
console.log(myArray.every(under21)); <b>// false</b>&#13;
&#13;
const equal21 = (value) =&gt; value === 21;&#13;
console.log(myArray.some(equal21));  <b>// false</b>&#13;
console.log(myArray.every(equal21)); <b>// false</b></code></pre>&#13;
<p class="TX">If you test whether some elements of the array are under 21, the answer is true, but not all elements are true. If you repeat these tests for equality to 21, both answers are false.</p>&#13;
<p class="TX">You could omit these functions if you have the methods in the previous section (see question 2.7 at the end of the chapter).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Transforming an Array</span></h5>&#13;
<p class="TNI1">Algorithms often need to go through a set of elements (such as an array) and apply some operation to each of them to create a new set. For instance, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_29" aria-label="29"/>in a web application, you could have a list of strings, which could represent numbers, and you’d want to transform that list into a list of the corresponding numeric values. Setting up a loop to go through all elements of an array systematically, processing elements one by one, and producing a new array is a common procedure and usually taught early on to developers. This kind of transformation is also key in FP, and JavaScript calls it the <span class="SANS_TheSansMonoCd_W5Regular_11">.map()</span> function.</p>&#13;
<p class="TX">Consider an introductory example that just produces a new array, with all values multiplied by 10:</p>&#13;
<pre id="pre-34"><code>let myArray = [22, 9, 60, 12, 4, 56];&#13;
console.log(<b>myArray.map((x) =&gt; 10*x)</b>);&#13;
// [220, 90, 600, 120, 40, 560]</code></pre>&#13;
<p class="TX">Start with the same array you’ve been using. If you map it with a function that multiplies its argument by 10, you get a new array whose values are 10 times the original ones.</p>&#13;
<p class="TX">Using <span class="SANS_TheSansMonoCd_W5Regular_11">.map()</span> instead of a common loop means clearer code, and mapping is a well-known pattern in FP. The code is also shorter, which means fewer chances of introducing bugs. And finally, the code produces a new array instead of modifying the original one, so the function is <i>pure</i> (you’ll learn what that means later in this chapter). Whenever possible, use <span class="SANS_TheSansMonoCd_W5Regular_11">.map()</span>, but be aware that some of its features could bite you; see question 2.4 at the end of this chapter for an example.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3" id="sec9"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Reducing an Array to a Single Value</span></h5>&#13;
<p class="TNI1">Here is another common task: writing loops that go through a complete array, performing some kind of operation and ending up with a single computed value. (A typical example is an array with a list of numbers and adding them up.) You can implement this kind of task in a functional way using either the <span class="SANS_TheSansMonoCd_W5Regular_11">.reduce()</span> or, less frequently, the <span class="SANS_TheSansMonoCd_W5Regular_11">.reduceRight()</span> function. The following sums up a complete array:</p>&#13;
<pre id="pre-35"><code>const myArray = [22, 9, 60, 12, 4, 56];&#13;
const mySum = myArray.<b>reduce((a, v) =&gt; a + v, 0)</b>; <b>// 163</b></code></pre>&#13;
<p class="TX">This logic does all that’s needed to apply a function that receives two values and returns their sum to the complete array, starting with 0. In other words, it sums all the elements of the array. The <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> argument stands for <i>accumulator</i> (initially 0), and <span class="SANS_TheSansMonoCd_W5Regular_11">v</span> stands for <i>value</i> (each of the elements of the array). You don’t need to provide the initial value for <span class="SANS_TheSansMonoCd_W5Regular_11">.reduce()</span>, but it’s safer to do so. If you try to reduce an empty array without an initial value, you’ll get a runtime error.</p>&#13;
<p class="TX">To show the power of <span class="SANS_TheSansMonoCd_W5Regular_11">.reduce()</span>, look at another case where you calculate more than one result: averaging the array values. For that, you need not only their sum, which you already know how to get, but also their count <span role="doc-pagebreak" epub:type="pagebreak" id="pg_30" aria-label="30"/>(forget that you could use <span class="SANS_TheSansMonoCd_W5Regular_11">myArray.length</span> to provide the latter; this is just an example):</p>&#13;
<pre id="pre-36"><code>const myArray = [22, 9, 60, 12, 4, 56];&#13;
myArray.<b>reduce((a, v) =&gt; ({s: a.s + v, c: a.c + 1}), {s: 0, c: 0})</b>;&#13;
// {s: 163, c: 6}</code></pre>&#13;
<p class="TX">The object has two fields (<span class="SANS_TheSansMonoCd_W5Regular_11">s</span> for the sum and <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> for the count), and the reducing function recalculates those values at each step; the final result matches the previous example.</p>&#13;
<p class="TX">If you need to process an array from right to left, <span class="SANS_TheSansMonoCd_W5Regular_11">.reduceRight()</span> works the same way, but it starts at the end of the array and goes back to the first element. Of course, you also could reverse the original array by first using <span class="SANS_TheSansMonoCd_W5Regular_11">.reverse()</span> and then <span class="SANS_TheSansMonoCd_W5Regular_11">.reduce()</span>, but that would cause a side effect. The array would be reversed in place (see “<span class="Xref">Mutating Arguments</span>” on page <span class="Xref">33</span> for more about this).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Looping Through Arrays</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">.forEach()</span> array function takes care of looping through an array, invoking a callback for each element, so you just have to declare what kind of work you want to do and nothing else. You can redo the array summing logic using this function:</p>&#13;
<pre id="pre-37"><code>const myArray = [22, 9, 60, 12, 4, 56];&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> let sum = 0;&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> myArray.forEach((v) =&gt; {&#13;
  sum += v;&#13;
});&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> console.log(sum); // 163, as earlier</code></pre>&#13;
<p class="TX">First set the <span class="SANS_TheSansMonoCd_W5Regular_11">sum</span> variable to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>; this variable will get the sum of all elements in the array <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then go through the array <span class="CodeAnnotation" aria-label="annotation2">❷</span> and specify what you want to do with each <span class="SANS_TheSansMonoCd_W5Regular_11">v</span> element. In this case, add it to <span class="SANS_TheSansMonoCd_W5Regular_11">sum</span>, and the final result <span class="CodeAnnotation" aria-label="annotation3">❸</span> is exactly the same as before.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-16"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Higher-Order Functions</span></h4>&#13;
<p class="TNI1">As mentioned previously, functions that receive other functions as arguments or that return functions as results are called <i>higher-order functions</i>. This means all functions that work with callbacks are higher-order functions, and so are all the array methods just discussed. Some of these functions allow you to work in a more declarative style (like the ones you saw earlier), and others allow you to extend a function and modify what it does—for example, adding logging as an aid for debugging or memoizing for better performance.</p>&#13;
<p class="TX">Consider one of the uses for higher-order functions: returning a new function, with an example of wrapped behavior. Wrapping produces a new function that keeps its original functionality but adds some extra behavior. Imagine you want to add logging to a function for debugging <span role="doc-pagebreak" epub:type="pagebreak" id="pg_31" aria-label="31"/>purposes. You could modify the function of course, but doing so is risky, because you could accidentally touch something you shouldn’t. You also could use a debugger, but a wrapper function provides more flexibility.</p>&#13;
<p class="TX">The original function could be something like this:</p>&#13;
<pre id="pre-38"><code>const myFunction = (arg1, arg2) =&gt; {&#13;
  // Do something with arg1 and arg2&#13;
  // and eventually return something.&#13;
}</code></pre>&#13;
<p class="TX">You then could modify it to add logging:</p>&#13;
<pre id="pre-39"><code>const myFunction = (arg1, arg2) =&gt; {&#13;
<b>  console.log("Entering myFunction with ", arg1, arg2);</b>&#13;
  // Do something with arg1 and arg2&#13;
  // and calculate something to return.&#13;
<b>  const toReturn = something;</b>&#13;
<b>  console.log("Exiting myFunction, returning ", toReturn);</b>&#13;
<b>  return toReturn;</b>&#13;
}</code></pre>&#13;
<p class="TX">If the function had several <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statements, however, you’d need to modify them all.</p>&#13;
<p class="TX">Using a higher-order logging function is better:</p>&#13;
<pre id="pre-40"><code>const addLogging = (fn) =&gt; (...args) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> console.log("Entering ", fn.name, " with ", . . .args);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const toReturn = fn(...args);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> console.log("Exiting ", fn.name, " returning ", toReturn);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> return toReturn;&#13;
}</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">addLogging()</span> function receives a function as argument and returns a new function <span class="CodeAnnotation" aria-label="annotation4">❹</span>. First, this new function logs the original function’s name <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the arguments it received. Then it actually calls the original function to calculate whatever the function calculated <span class="CodeAnnotation" aria-label="annotation2">❷</span>. After that, the new function logs the result <span class="CodeAnnotation" aria-label="annotation3">❸</span> and finally returns that value.</p>&#13;
<p class="TX">Here’s a simple example:</p>&#13;
<pre id="pre-41"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const sum2 = (a, b) =&gt; {&#13;
  console.log("Calculating...");&#13;
  return a+b;&#13;
}&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> addLogging(sum2)(22, 9);&#13;
<b>// Entering sum2 with 22 9</b>&#13;
<b>// Calculating...</b>&#13;
<b>// Exiting sum2 returning 31</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">sum2()</span> function logs something and returns the sum of its arguments <span class="CodeAnnotation" aria-label="annotation1">❶</span>. When you pass <span class="SANS_TheSansMonoCd_W5Regular_11">sum2</span> as a parameter to <span class="SANS_TheSansMonoCd_W5Regular_11">addLogging</span> and call the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_32" aria-label="32"/>resulting function <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you get the extra logging you wanted without touching the original function.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-17"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Side Effects</span></h4>&#13;
<p class="TNI1">When a function depends only on the parameters it receives and doesn’t produce any side effects, it is called a <i>pure function</i>. The concept of pure functions is closely related to mathematical functions: given an <i>f</i>(<i>x</i>) function, all it does when given a value for <i>x</i> is calculate a new value.</p>&#13;
<p class="TX">Using pure functions is advantageous because they don’t produce any side effects, such as changing the program state, modifying variables, mutating objects, and so on. This means that when you call a pure function, you don’t need to worry about any possible changes anywhere in your code or the possibility of something else getting broken; you can concentrate on which arguments you pass to the function, knowing no “surprises” will happen. When given the same arguments, the function will always return the same result. That result won’t depend on any “outside” variables or state, which could change and then cause the function to produce a different result. On the other hand, a pure function cannot depend on random numbers, the time of day, the result of input/output (I/O) functions, and so on; it depends only on its input.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h5 class="H3" id="sec13"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Using Global State</span></h5>&#13;
<p class="TNI1">The most common reason for side effects is using nonlocal variables that are shared with other parts of the code. Since a pure function always produces the same output given the same inputs, if a function depends somehow on variables outside it, it automatically becomes impure.</p>&#13;
<p class="TX">The problem goes deeper; debugging a function that depends on global state is more difficult, because in order to understand why a function returned a given value, you must also understand how the program state was reached, and that itself requires understanding all the previous history of the running code. The injunction against using global variables is a good one, even if you aren’t specifically following FP tenets.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h5 class="H3" id="sec14"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Keeping Inner State</span></h5>&#13;
<p class="TNI1">You can extend the practice of not using external variables to include avoiding internal variables, which keep state between calls. Even if no global variables are present, internal variables may cause future calls to the function to return different output, even when provided with the same input arguments.</p>&#13;
<p class="TX">Using internal state is why functional programmers don’t like working with objects. OOP requires data to be stored in an object to use for calculations, which automatically enables the possibility of impure code, because some methods could calculate results depending not only on their arguments but on the internal attributes as well.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_33" aria-label="33"/>&#13;
<h5 class="H3" id="sec15"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Mutating Arguments</span></h5>&#13;
<p class="TNI1">We’ve considered working with (and possibly modifying) external or internal variables, but there is one more “sin” you might commit: modifying the actual arguments to the function. In JavaScript, arguments are passed by value, unless they are objects or arrays, which are passed by reference. The latter implies that if the function modifies the arguments, it will actually be modifying the original object or array, which is certainly a side effect. You saw a possible case earlier in the chapter when emulating <span class="SANS_TheSansMonoCd_W5Regular_11">.reduceRight()</span> by first applying <span class="SANS_TheSansMonoCd_W5Regular_11">.reverse()</span> to reverse an array—an unexpected side effect (see the section “<span class="Xref">Reducing an Array to a Single Value</span>” on page <span class="Xref">29</span>).</p>&#13;
<p class="TX">Detecting this kind of error can be difficult, because JavaScript itself provides several functions and methods that modify their input by definition. For example, if you decided to sort an input array, doing <span class="SANS_TheSansMonoCd_W5Regular_11">myArray.sort()</span> would actually modify the original array, which is something the caller of your function might not be aware of. Other array methods, such as <span class="SANS_TheSansMonoCd_W5Regular_11">pop()</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">splice()</span>, also affect the involved array; many such <i>mutator</i> methods exist. (Note, however, that ECMAScript recently added the <span class="SANS_TheSansMonoCd_W5Regular_11">toSorted()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">toReversed()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">toSpliced()</span> methods that do not affect the original array.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3" id="sec16"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Returning Impure Functions</span></h5>&#13;
<p class="TNI1">Some functions are inherently impure. For example, if you call an API to get the daily news, you expect it to return new results every time. If you’re programming a game and need to use <span class="SANS_TheSansMonoCd_W5Regular_11">Math.random()</span> to generate randomness, you’ll want a different result every time; it won’t be useful if it always returns the same number. Similarly, any function that deals with the current date or time will be impure, because its results depend on an outside condition (the time), which could be considered a part of global state.</p>&#13;
<p class="TX">For I/O-related functions, the returned result could vary for other reasons. I/O errors can happen unexpectedly; for example, an external service could crash or access rights to some filesystem could change. This means that at any time, the function might throw an exception instead of returning data. Even a seemingly safe function like <span class="SANS_TheSansMonoCd_W5Regular_11">console.log()</span>, which doesn’t produce internal changes, is impure, because the user will see a change in console output.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-18"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Impure Functions</span></h4>&#13;
<p class="TNI1">Doing away with all impurities likely isn’t feasible, so the next option is to consider how to reduce the problem size. One solution is to avoid the usage of state, and another solution is to use the <i>injection</i> pattern to control impurity.</p>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h5 class="H3" id="sec18"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Avoiding State</span></h5>&#13;
<p class="TNI1">With regard to setting global state, fortunately, there is a well-known solution. If a function needs to <i>get</i> global state, just provide the function whatever state elements it needs as arguments. This method solves that problem, because the function won’t then need to access global state directly. On the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_34" aria-label="34"/>other hand, if a function needs to <i>set</i> global state, it shouldn’t do so directly. The function should produce an updated state and return it, and the caller should be responsible for updating the global state. If there’s a need to update state, at least it will be done at a higher level; whatever provides the state data to the function also will update the state.</p>&#13;
<p class="TX">These two rules also simplify testing. Instead of having to set some global state, provide the function with the initial state and then check whether the returned new state is correct.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h5 class="H3" id="sec19"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Using Injection</span></h5>&#13;
<p class="TNI1">So the problem of working with state is solved, but what about when you really need some impure function—for instance, for I/O or for random numbers? The technique shown here provides more flexible code, simplifies unit testing, and allows easier maintenance.</p>&#13;
<p class="TX">Suppose a function needed to call an API and did it directly by using Axios, as shown earlier in this chapter (see the section “<span class="Xref">Functions as First-Class Objects</span>” on page <span class="Xref">25</span>):</p>&#13;
<pre id="pre-42"><code>doSomething(a, b, c);&#13;
...&#13;
function doSomething(x, y, z) {&#13;
  // ...&#13;
  <b>axios.get("/some/url");</b>&#13;
  // ...&#13;
}</code></pre>&#13;
<p class="TX">Instead of calling the API directly, provide (or inject) a function to do it:</p>&#13;
<pre id="pre-43"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const getData = (url) =&gt; axios.get(url);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> doSomething(a, b, c, <b>getData</b>);&#13;
&#13;
function doSomething(x, y, z, getter) {&#13;
  // ...&#13;
  <b>getter("/some/url");</b>&#13;
  // ...&#13;
}</code></pre>&#13;
<p class="TX">You define a new <span class="SANS_TheSansMonoCd_W5Regular_11">getData()</span> function that actually calls the API <span class="CodeAnnotation" aria-label="annotation1">❶</span> and passes it to the (modified) <span class="SANS_TheSansMonoCd_W5Regular_11">doSomething()</span> function as a new extra argument <span class="CodeAnnotation" aria-label="annotation2">❷</span>. You haven’t actually avoided using impurities (such as doing I/O), but now the caller is in control by injecting a relevant function.</p>&#13;
<p class="TX">This solution is the same as what was used for avoiding global state, since using <span class="SANS_TheSansMonoCd_W5Regular_11">axios.get()</span> directly is in fact using a method of a global object, and what you are doing to avoid this situation is providing an extra parameter to be used by the function, so it won’t have to access anything global directly. The whole code still will be doing its I/O as required, but now the lower <span class="SANS_TheSansMonoCd_W5Regular_11">doSomething()</span> function is pure, and for testing purposes, you can provide a mock function.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_35" aria-label="35"/>&#13;
<h3 class="H1" id="sec20"><span id="h1-9"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter, we’ve described features of FP, how it’s supported by JavaScript, and a few examples of its usage. Working in an FP-oriented way allows for clearer, more maintainable code, and we’ll be using that style throughout the book whenever it makes sense. In later chapters, we’ll aim to apply FP and use functions for algorithms and data structures. <span class="Xref"><a href="chapter18.xhtml">Chapter 18</a></span> takes a totally functional route and explores how the concept of FP extends to functional data structures.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h3 class="H1" id="sec21"><span id="h1-10"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>2.1  Pure or Impure?</b></p>&#13;
<p class="ListPlainFirst">Consider the following function that calculates the circumference of a circle given its radius but accesses a global variable to do it. Is it pure or impure?</p>&#13;
<pre class="pre" id="pre-44"><code>const PI = 3.14159265358979;&#13;
const circumference = (r) =&gt; 2 * PI * r;</code></pre>&#13;
<p class="ListHead"><b>2.2  Prepare for Failure</b></p>&#13;
<p class="ListPlainFirst">The <span class="SANS_TheSansMonoCd_W5Regular_11">addLogging()</span> function doesn’t take into account the possibility of the original function throwing an exception. Can you modify it to produce proper results in that case as well?</p>&#13;
<p class="ListHead"><b>2.3  You Got Time?</b></p>&#13;
<p class="ListPlainFirst">Write an <span class="SANS_TheSansMonoCd_W5Regular_11">addTiming()</span> higher-order function that will take a function as a parameter and produce an equivalent new function, but will log timing data on the console. The kind of solution you want is along the lines of the <span class="SANS_TheSansMonoCd_W5Regular_11">addLogging()</span> function mentioned in this chapter; take care to account for exceptions as well.</p>&#13;
<p class="ListHead"><b>2.4  Parsing Problem</b></p>&#13;
<p class="ListPlainFirst">If you attempt to do <span class="SANS_TheSansMonoCd_W5Regular_11">["1", "2", "4", "8", "16", "32"].map(parseInt)</span>, a weird <span class="SANS_TheSansMonoCd_W5Regular_11">[1, NaN, NaN, NaN, 1, 17]</span> result is produced; can you explain why? Hint: check what parameters are passed by <span class="SANS_TheSansMonoCd_W5Regular_11">map()</span> to your function.</p>&#13;
<p class="ListHead"><b>2.5  Deny Everything</b></p>&#13;
<p class="ListPlainFirst">Write a <span class="SANS_TheSansMonoCd_W5Regular_11">negate()</span> higher-order function that, given a predicate, will produce a complementary predicate that returns the opposite result. For example, if you had an <span class="SANS_TheSansMonoCd_W5Regular_11">isAdult()</span> function that checked whether its argument was 21 or more, <span class="SANS_TheSansMonoCd_W5Regular_11">negate(isAdult)</span> would check whether its argument was <i>not</i> 21 or more. (Tip: you may find this function useful for the next two questions.)</p>&#13;
<p class="ListHead"><b>2.6  Every, Some ... None?</b></p>&#13;
<p class="ListPlainFirst">Create a <span class="SANS_TheSansMonoCd_W5Regular_11">.none()</span> method that will check whether no element of an array satisfies a given predicate.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_36" aria-label="36"/><b>2.7  No Some, No Every</b></p>&#13;
<p class="ListPlainFirst">Write the equivalents of <span class="SANS_TheSansMonoCd_W5Regular_11">.some()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.every()</span> based on <span class="SANS_TheSansMonoCd_W5Regular_11">.find()</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">.findIndex()</span>.</p>&#13;
<p class="ListHead"><b>2.8  What Does It Do?</b></p>&#13;
<p class="ListPlainFirst">Explain what the following code produces and why:</p>&#13;
<pre class="pre" id="pre-45"><code>["James Bond", 0, 0, 7].map(Boolean)</code></pre>&#13;
</section>&#13;
</section>&#13;
</body></html>