- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**NETWORK LAYER PROTOCOLS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络层协议**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Whether you’re troubleshooting latency issues, identifying malfunctioning applications,
    or zeroing in on security threats in order to spot abnormal traffic, you must
    first understand normal traffic. In the next couple of chapters, you’ll learn
    how normal network traffic works at the packet level as we journey from the bottom
    of the OSI model all the way to the top. Each protocol section has at least one
    associated capture file, which you can download and work with directly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在排查延迟问题、识别故障的应用程序，还是为了发现异常流量而寻找安全威胁，你都必须首先了解正常流量。在接下来的几章中，你将学习正常网络流量如何在数据包层面上工作，我们将从
    OSI 模型的底层一路走到顶层。每个协议部分至少有一个相关的抓包文件，你可以直接下载并操作。
- en: 'In this chapter, we’ll specifically focus on the network layer protocols that
    are the workhorses of network communication: ARP, IPv4, IPv6, ICMP, and ICMPv6.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将特别关注网络层协议，这些协议是网络通信的主力军：ARP、IPv4、IPv6、ICMP 和 ICMPv6。
- en: The next three chapters on network protocols are arguably the most important
    chapters in this book. Skipping this discussion would be like making Thanksgiving
    dinner without preheating the oven. Even if you already have a good grasp of how
    each protocol functions, give these chapters at least a quick read in order to
    review the packet structure of each.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三章关于网络协议的内容可以说是本书中最重要的章节。跳过这部分讨论就像做感恩节晚餐却没有预热烤箱。即使你已经很好地掌握了每个协议的功能，仍然建议至少快速阅读这些章节，以便复习每个协议的数据包结构。
- en: '**Address Resolution Protocol (ARP)**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**地址解析协议（ARP）**'
- en: Both logical and physical addresses are used for communication on a network.
    Logical addresses allow for communication among multiple networks and indirectly
    connected devices. Physical addresses facilitate communication on a single network
    segment for devices that are directly connected to each other with a switch. In
    most cases, these two types of addressing must work together in order for communication
    to occur.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑地址和物理地址都用于网络中的通信。逻辑地址允许跨多个网络以及间接连接的设备进行通信。物理地址则便于在通过交换机直接连接的设备之间，在同一个网络段内进行通信。在大多数情况下，这两种类型的地址必须协同工作，才能实现通信。
- en: Consider a scenario in which you wish to communicate with a device on your network.
    This device may be a server of some sort or just another workstation you need
    to share files with. The application you are using to initiate the communication
    is already aware of the remote host’s IP address (via DNS, covered in [Chapter
    9](ch09.xhtml#ch09)), meaning the system should have all it needs to build the
    layer 3 through 7 information of the packet it wants to transmit. The only piece
    of information it needs at this point is the layer 2 data link information containing
    the MAC address of the target host.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望与网络上的某个设备进行通信。这个设备可能是某种服务器，或者只是你需要共享文件的另一台工作站。你正在使用的应用程序已经知道远程主机的 IP 地址（通过
    DNS，在 [第 9 章](ch09.xhtml#ch09)中介绍），这意味着系统应该拥有构建它想要传输的数据包的第 3 层到第 7 层信息所需的所有内容。此时唯一需要的信息是包含目标主机
    MAC 地址的数据链路层信息。
- en: MAC addresses are needed because a switch that interconnects devices on a network
    uses a *Content Addressable Memory (CAM) table*, which lists the MAC addresses
    of all devices plugged into each of its ports. When the switch receives traffic
    destined for a particular MAC address, it uses this table to know which port to
    send the traffic through. If the destination MAC address is unknown, the transmitting
    device will first check for the address in its cache; if the address isn’t there,
    then it must be resolved through additional communication on the network.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 需要 MAC 地址是因为交换机在网络中连接设备时，使用 *内容寻址存储器（CAM）表*，该表列出了所有设备在其各个端口上的 MAC 地址。当交换机接收到发送到特定
    MAC 地址的流量时，它会使用该表来判断应通过哪个端口转发流量。如果目标 MAC 地址未知，发送设备将首先检查其缓存中是否有该地址；如果没有，则必须通过网络上的额外通信来解析该地址。
- en: 'The resolution process that TCP/IP networking (with IPv4) uses to resolve an
    IP address to a MAC address is called the *Address Resolution Protocol (ARP)*,
    which is defined in RFC 826\. The ARP resolution process uses only two packets:
    an ARP request and an ARP response (see [Figure 7-1](ch07.xhtml#ch07fig1)).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 网络（使用 IPv4）将 IP 地址解析为 MAC 地址的过程称为 *地址解析协议（ARP）*，该协议在 RFC 826 中定义。ARP
    解析过程仅使用两个数据包：一个 ARP 请求和一个 ARP 响应（见 [图 7-1](ch07.xhtml#ch07fig1)）。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*An RFC, or Request for Comments, is a technical publication from the Internet
    Engineering Task Force (IETF) and Internet Society (ISOC) and is the mechanism
    used to define the implementation standards for protocols. You can search for
    RFC documentation at the RFC Editor home page,* http://www.rfc-editor.org/.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*RFC（请求评论）是互联网工程任务组（IETF）和互联网协会（ISOC）发布的技术文献，是定义协议实现标准的机制。你可以在RFC编辑器主页上查找RFC文档，*
    http://www.rfc-editor.org/。'
- en: The transmitting computer sends out an ARP request that basically says, “Howdy,
    everybody. My IP address is 192.168.0.101, and my MAC address is f2:f2:f2:f2:f2:f2\.
    I need to send something to whoever has the IP address 192.168.0.1, but I don’t
    know the hardware address. Will whoever has this IP address please respond with
    your MAC address?”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 发送计算机发送出一个ARP请求，基本内容是：“大家好，我的IP地址是192.168.0.101，我的MAC地址是f2:f2:f2:f2:f2:f2。我需要将数据发送给拥有IP地址192.168.0.1的设备，但我不知道其硬件地址。请拥有此IP地址的设备回复你的MAC地址。”
- en: This packet is broadcast to every device on the network segment. Any device
    that doesn’t have this IP address simply discards the packet. The device that
    does have the address sends an ARP reply with an answer such as “Hey, transmitting
    device, I’m the one you’re looking for with the IP address 192.168.0.1\. My MAC
    address is 02:f2:02:f2:02:f2.”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据包会广播到网络段上的每个设备。任何没有这个IP地址的设备都会丢弃这个数据包。拥有该IP地址的设备会发送一个ARP回复，内容例如：“嘿，发送设备，我就是你在找的，IP地址是192.168.0.1，MAC地址是02:f2:02:f2:02:f2。”
- en: Once this resolution process is completed, the transmitting device updates its
    cache with the MAC-to-IP address association of the receiving device and can begin
    sending data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解析过程完成，发送设备会更新其缓存，记录接收设备的MAC与IP地址关联关系，并可以开始发送数据。
- en: '![image](../images/f121-01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f121-01.jpg)'
- en: '*Figure 7-1: The ARP resolution process*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：ARP解析过程*'
- en: '**NOTE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can view the ARP table of a Windows host by typing `arp –a` from a command
    prompt.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过在命令提示符下输入`arp –a`来查看Windows主机的ARP表。*'
- en: Seeing this process in action will help you understand how it works. But before
    we look at some examples, let’s examine the ARP packet header.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这个过程的实际操作将帮助你理解它是如何工作的。但在我们查看一些示例之前，先来了解一下ARP数据包头部。
- en: '***ARP Packet Structure***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ARP数据包结构***'
- en: 'As shown in [Figure 7-2](ch07.xhtml#ch07fig2), the ARP header includes the
    following fields:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图7-2](ch07.xhtml#ch07fig2)所示，ARP头部包括以下字段：
- en: '**Hardware Type**   The layer 2 type used—in most cases, this is Ethernet (type
    1)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件类型**   使用的第二层类型——在大多数情况下是以太网（类型1）'
- en: '**Protocol Type**   The higher-layer protocol for which the ARP request is
    being used'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议类型**   ARP请求所使用的上层协议'
- en: '**Hardware Address Length**   The length (in octets/bytes) of the hardware
    address in use (6 for Ethernet)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件地址长度**   使用的硬件地址的长度（以八位字节为单位）（以太网为6）'
- en: '**Protocol Address Length**   The length (in octets/bytes) of the logical address
    of the specified protocol type'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议地址长度**   指定协议类型的逻辑地址的长度（以八位字节为单位）'
- en: '**Operation**   The function of the ARP packet: either 1 for a request or 2
    for a reply'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作**   ARP数据包的功能：1表示请求，2表示回复'
- en: '![image](../images/f122-01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f122-01.jpg)'
- en: '*Figure 7-2: The ARP packet structure*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：ARP数据包结构*'
- en: '**Sender Hardware Address**   The hardware address of the sender'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送方硬件地址**   发送方的硬件地址'
- en: '**Sender Protocol Address**   The sender’s upper-layer protocol address'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送方协议地址**   发送方的上层协议地址'
- en: '**Target Hardware Address**   The intended receiver’s hardware address (all
    zeroes in ARP requests)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标硬件地址**   目标接收方的硬件地址（ARP请求中为全零）'
- en: '**Target Protocol Address**   The intended receiver’s upper-layer protocol
    address'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标协议地址**   目标接收方的上层协议地址'
- en: '*arp_resolution.pcapng*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*arp_resolution.pcapng*'
- en: Now open the file *arp_resolution.pcapng* to see this resolution process in
    action. We’ll focus on each packet individually as we walk through this process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开文件*arp_resolution.pcapng*，查看这个解析过程的实际操作。我们将在讲解这个过程时，逐个关注每个数据包。
- en: '***Packet 1: ARP Request***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据包1：ARP请求***'
- en: The first packet is the ARP request, as shown in [Figure 7-3](ch07.xhtml#ch07fig3).
    We can confirm that this packet is a true broadcast packet by examining the Ethernet
    header in Wireshark’s Packet Details pane. The packet’s destination address is
    ff:ff:ff:ff:ff:ff ➊. This is the Ethernet broadcast address, and anything sent
    to it will be broadcast to all devices on the current network segment. The source
    address of this packet in the Ethernet header is listed as our MAC address ➋.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据包是ARP请求，如[图7-3](ch07.xhtml#ch07fig3)所示。我们可以通过检查Wireshark的“数据包详情”窗格中的以太网头部来确认该数据包是一个真正的广播数据包。该数据包的目的地址是ff:ff:ff:ff:ff:ff
    ➊。这是以太网广播地址，发送到该地址的任何数据包都会被广播到当前网络段上的所有设备。数据包在以太网头部中的源地址列出了我们的MAC地址 ➋。
- en: Given this structure, we can discern that this is indeed an ARP request on an
    Ethernet network using IPv4\. The sender’s IP address (192.168.0.114) and MAC
    address (00:16:ce:6e:8b:24) are listed ➌, as is the IP address of the target (192.168.0.1)
    ➎. The MAC address of the target—the information we are trying to get—is unknown,
    so the target MAC is listed as 00:00:00:00:00:00 ➍.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个结构，我们可以判断这确实是一个在以太网网络上使用IPv4的ARP请求。发送者的IP地址（192.168.0.114）和MAC地址（00:16:ce:6e:8b:24）已列出
    ➌，目标的IP地址（192.168.0.1）也列出 ➎。目标的MAC地址——我们试图获取的信息——未知，因此目标MAC列出了00:00:00:00:00:00
    ➍。
- en: '![image](../images/f123-01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f123-01.jpg)'
- en: '*Figure 7-3: An ARP request packet*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：ARP请求数据包*'
- en: '***Packet 2: ARP Response***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据包2：ARP应答***'
- en: 'In the response to the initial request (see [Figure 7-4](ch07.xhtml#ch07fig4)),
    the Ethernet header now has a destination address of the source MAC address from
    the first packet. The ARP header looks similar to that of the ARP request, with
    a few changes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在对初始请求的应答中（见[图7-4](ch07.xhtml#ch07fig4)），以太网头部的目的地址现在是第一个数据包中的源MAC地址。ARP头部与ARP请求的相似，只是有一些变化：
- en: •     The packet’s operation code (opcode) is now 0x0002 ➊, indicating a reply
    rather than a request.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: •     该数据包的操作码（opcode）现在是0x0002 ➊，表示这是一个应答而不是请求。
- en: •     The addressing information is reversed—the sender MAC address and IP address
    are now the target MAC address and IP address ➌.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: •     地址信息被反转——发送者的MAC地址和IP地址现在成为目标MAC地址和IP地址 ➌。
- en: •     Most important, all the information is present, meaning we now have the
    MAC address (00:13:46:0b:22:ba) ➋ of our host at 192.168.0.1.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: •     最重要的是，所有信息都已呈现，这意味着我们现在得到了我们的主机在192.168.0.1上的MAC地址（00:13:46:0b:22:ba）
    ➋。
- en: '![image](../images/f123-02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f123-02.jpg)'
- en: '*Figure 7-4: An ARP reply packet*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：ARP应答数据包*'
- en: '***Gratuitous ARP***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无偿ARP***'
- en: '*arp_gratuitous.pcapng*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*arp_gratuitous.pcapng*'
- en: Where I come from, when something is done “gratuitously,” the word usually carries
    a negative connotation. A *gratuitous ARP*, however, is a good thing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我所在的地方，当某事是“无偿”做的时，这个词通常带有负面含义。然而，*无偿的ARP*却是一件好事。
- en: In many cases, a device’s IP address can change. When this happens, the IP-to-MAC
    address mappings that hosts on the network have in their caches will be invalid.
    To prevent this from causing communication errors, a gratuitous ARP packet is
    transmitted on the network to force any device that receives it to update its
    cache with the new IP-to-MAC address mapping (see [Figure 7-5](ch07.xhtml#ch07fig5)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，设备的IP地址可能会发生变化。当这种情况发生时，网络中主机的IP到MAC地址映射会变得无效。为了防止这导致通信错误，一个无偿的ARP数据包会在网络上发送，强制任何接收到该数据包的设备更新其缓存中的IP到MAC地址映射（见[图7-5](ch07.xhtml#ch07fig5)）。
- en: '![image](../images/f124-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f124-01.jpg)'
- en: '*Figure 7-5: The gratuitous ARP process*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：无偿ARP过程*'
- en: A few different scenarios can spawn a gratuitous ARP packet. One of the most
    common is the changing of an IP address. Open the capture file *arp_gratuitous.pcapng*,
    and you’ll see this in action. This file contains only a single packet (see [Figure
    7-6](ch07.xhtml#ch07fig6)) because that’s all that’s involved in gratuitous ARP.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的场景可能会生成无偿的ARP数据包。最常见的一种情况是IP地址的变化。打开捕获文件*arp_gratuitous.pcapng*，你会看到这个过程的实际情况。这个文件仅包含一个数据包（见[图7-6](ch07.xhtml#ch07fig6)），因为无偿的ARP只涉及一个数据包。
- en: '![image](../images/f124-02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f124-02.jpg)'
- en: '*Figure 7-6: A gratuitous ARP packet*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：一个无偿ARP数据包*'
- en: Examining the Ethernet header, you can see that this packet is sent as a broadcast
    so that all hosts on the network receive it ➊. The ARP header looks like an ARP
    request, except that the sender IP address ➋ and the target IP address ➌ are the
    same. When received by other hosts on the network, this packet will cause them
    to update their ARP tables with the new IP-to-MAC address association. Because
    this ARP packet is unsolicited but results in a client updating its ARP cache,
    the packet is considered gratuitous.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以太网头部，你可以看到这个数据包作为广播发送，这样网络上的所有主机都能接收到它 ➊。ARP 头部看起来像是一个 ARP 请求，不同之处在于发送方的
    IP 地址 ➋ 和目标 IP 地址 ➌ 是相同的。当网络中的其他主机接收到这个数据包时，它会导致它们更新 ARP 表，将新的 IP 到 MAC 地址的映射加入其中。由于这个
    ARP 数据包是无请求的，但却导致客户端更新其 ARP 缓存，因此该数据包被视为不必要的。
- en: You’ll notice gratuitous ARP packets in a few situations. As mentioned, changing
    a device’s IP address will generate a gratuitous packet. Also, some operating
    systems will perform a gratuitous ARP on startup. Additionally, some systems use
    gratuitous ARP packets to support load balancing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在一些情况下注意到不必要的 ARP 数据包。如前所述，改变设备的 IP 地址会生成一个不必要的数据包。此外，一些操作系统在启动时会执行不必要的 ARP
    请求。此外，一些系统使用不必要的 ARP 数据包来支持负载均衡。
- en: '**Internet Protocol (IP)**'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**互联网协议（IP）**'
- en: The primary purpose of protocols at layer 3 of the OSI model is to allow for
    communication between networks. As you just saw, MAC addresses are used for communication
    on a single network at layer 2\. In much the same fashion, layer 3 is responsible
    for addresses used in internetwork communication. A few protocols can do this,
    but the most common is the *Internet Protocol (IP)*, which currently has two versions
    in use—IP version 4 and IP version 6\. We’ll start by examining IP version 4 (IPv4),
    which is defined in RFC 791.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: OSI 模型第 3 层的协议主要目的是允许不同网络之间的通信。正如你刚才看到的，MAC 地址用于第 2 层单一网络上的通信。类似地，第 3 层负责处理用于不同网络间通信的地址。有一些协议可以实现这一点，但最常见的是*互联网协议（IP）*，目前有两个版本在使用——IP
    版本 4 和 IP 版本 6。我们将从 RFC 791 中定义的 IP 版本 4（IPv4）开始。
- en: '***Internet Protocol Version 4 (IPv4)***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***互联网协议版本 4 (IPv4)***'
- en: To understand the functionality of IPv4, you need to know how traffic flows
    between networks. IPv4 is the workhorse of the communication process and is ultimately
    responsible for carrying data between devices, regardless of where the communication
    endpoints are located.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 IPv4 的功能，你需要知道网络间流量是如何流动的。IPv4 是通信过程中的主力军，最终负责在设备之间传递数据，无论通信端点位于何处。
- en: A simple network in which all devices are connected via hubs or switches is
    called a *local area network (LAN)*. When you want to connect two LANs, you can
    do so with a router. Complex networks can consist of thousands of LANs connected
    through thousands of routers worldwide. The internet itself is a collection of
    millions of LANs and routers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有设备通过集线器或交换机连接的简单网络称为 *局域网（LAN）*。当你想要连接两个局域网时，可以通过路由器来实现。复杂的网络可以由成千上万的局域网通过成千上万的路由器连接在全球范围内组成。互联网本身就是由数百万个局域网和路由器组成的。
- en: '**IPv4 Addresses**'
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**IPv4 地址**'
- en: '*IPv4 addresses* are 32-bit assigned numbers used to uniquely identify devices
    connected to a network. It’s a bit much to expect someone to remember a sequence
    of ones and zeros that is 32 characters long, so IP addresses are written in *dotted-quad*
    (or *dotted-decimal*) *notation*.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv4 地址*是 32 位分配的数字，用于唯一标识连接到网络的设备。要记住一个由 32 个字符长的零和一组成的序列是相当困难的，因此 IP 地址采用
    *点分四段*（或 *点分十进制*）*表示法*来书写。'
- en: In dotted-quad notation, each of the four sets of ones and zeros that make up
    an IP address is converted to base 10 and represented as a number between 0 and
    255 in the format *A.B.C.D* (see [Figure 7-7](ch07.xhtml#ch07fig7)). For example,
    consider the IP address 11000000 10101000 00000000 00000001\. This value is obviously
    a bit much to remember or notate. Fortunately, using dotted-quad notation, we
    can represent it as 192.168.0.1.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在点分四段表示法中，构成 IP 地址的四组零和一被转换为十进制，并表示为 0 到 255 之间的数字，格式为 *A.B.C.D*（见 [图 7-7](ch07.xhtml#ch07fig7)）。例如，考虑
    IP 地址 11000000 10101000 00000000 00000001。这个值显然是难以记住或标注的。幸运的是，使用点分四段表示法，我们可以将其表示为
    192.168.0.1。
- en: '![image](../images/f126-01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f126-01.jpg)'
- en: '*Figure 7-7: Dotted-quad IPv4 address notation*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：点分四段 IPv4 地址表示法*'
- en: 'An IP address consists of two parts: a *network portion* and a *host portion*.
    The network portion identifies the LAN the device is connected to, and the host
    portion identifies the device itself on that network. The determination of which
    part of the IP address belongs to the network or host portion is not always the
    same. This information is communicated by another set of addressing information
    called the *network mask (netmask)* or sometimes referred to as a *subnet mask*.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个IP地址由两部分组成：*网络部分*和*主机部分*。网络部分标识设备连接的局域网，而主机部分标识该网络中的设备。确定IP地址的哪一部分属于网络部分或主机部分并不总是相同的。这些信息通过另一组地址信息传达，这组信息称为*网络掩码（netmask）*，有时也叫做*子网掩码*。
- en: '**NOTE**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this book, when we refer to an IP address, we will always be referring
    to an IPv4 address. Later in this chapter, we will look at IP version 6, which
    uses a different set of rules for addressing. Whenever we refer to an IPv6 address,
    it will be explicitly labeled as such.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，当我们提到IP地址时，我们总是指IPv4地址。稍后在本章中，我们将讨论使用不同地址规则的IP版本6。每当我们提到IPv6地址时，都会明确标注。*'
- en: The netmask identifies which part of the IP address belongs to the network portion
    and which part belongs to the host portion. The netmask number is also 32 bits
    long, and every bit that is set to a 1 identifies the part of the IP address that
    is reserved for the network portion. The remaining bits are set to 0 to identify
    the host portion.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 网络掩码标识了IP地址中哪一部分属于网络部分，哪一部分属于主机部分。网络掩码的长度也是32位，每个位为1的部分标识IP地址中保留给网络部分的部分。其余的位被设置为0，以标识主机部分。
- en: For example, consider the IP address 10.10.1.22, represented in binary as 00001010
    00001010 00000001 00010110\. To determine the allocation of each section of the
    IP address, we can apply our netmask. In this case, our netmask is 11111111 11111111
    00000000 00000000\. This means that the first half of the IP address (10.10 or
    00001010 00001010) is reserved for the network portion, and the last half of the
    IP address (.1.22 or 00000001 00010110) identifies the individual host on this
    network, as shown in [Figure 7-8](ch07.xhtml#ch07fig8).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑IP地址10.10.1.22，二进制表示为00001010 00001010 00000001 00010110。为了确定IP地址各部分的分配方式，我们可以应用我们的网络掩码。在这种情况下，我们的网络掩码是11111111
    11111111 00000000 00000000。这意味着IP地址的前半部分（10.10或00001010 00001010）保留给网络部分，而IP地址的后半部分（.1.22或00000001
    00010110）标识此网络中的单个主机，如[图 7-8](ch07.xhtml#ch07fig8)所示。
- en: '![image](../images/f126-02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f126-02.jpg)'
- en: '*Figure 7-8: The netmask determines the allocation of the bits in an IP address.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：子网掩码决定了IP地址中各位的分配方式。*'
- en: As indicated in [Figure 7-8](ch07.xhtml#ch07fig8), netmasks can also be written
    in dotted-quad notation. For example, the netmask 11111111 11111111 00000000 00000000
    is written as 255.255.0.0.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 7-8](ch07.xhtml#ch07fig8)所示，网络掩码也可以用点分十进制表示法表示。例如，网络掩码11111111 11111111
    00000000 00000000表示为255.255.0.0。
- en: IP addresses and netmasks are commonly written in *Classless Inter-Domain Routing
    (CIDR) notation*. In this form, an IP address is written in full, followed by
    a forward slash (/) and the number of bits that represent the network portion
    of the IP address. For example, an IP address of 10.10.1.22 and a netmask of 255.255.0.0
    would be written in CIDR notation as 10.10.1.22/16.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址和网络掩码通常采用*无类域间路由（CIDR）表示法*书写。在这种形式下，IP地址写出完整，然后是一个斜杠（/）和表示IP地址网络部分的位数。例如，IP地址10.10.1.22和网络掩码255.255.0.0会写成CIDR表示法为10.10.1.22/16。
- en: '**IPv4 Packet Structure**'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**IPv4数据包结构**'
- en: The source and destination IP addresses are the crucial components of the IPv4
    packet header, but that’s not all of the IP information you’ll find in a packet.
    The IP header is quite complex compared to the ARP packet we just examined; it
    includes a lot of extra functionality that helps IP do its job.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 源IP地址和目的IP地址是IPv4数据包头部的关键组成部分，但这并不是数据包中包含的所有IP信息。与我们刚刚检查过的ARP数据包相比，IP头部要复杂得多；它包括许多额外的功能，帮助IP完成其任务。
- en: 'As shown in [Figure 7-9](ch07.xhtml#ch07fig9), the IPv4 header has the following
    fields:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 7-9](ch07.xhtml#ch07fig9)所示，IPv4头部包含以下字段：
- en: '**Version**   The version of IP being used (this will always be 4 for IPv4).
    **Header Length** The length of the IP header.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本**   正在使用的IP版本（IPv4时始终为4）。**头部长度**  IP头部的长度。'
- en: '**Type of Service**   A precedence flag and type of service flag, which are
    used by routers to prioritize traffic.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务类型**   优先级标志和服务类型标志，路由器用来优先处理流量。'
- en: '**Total Length**   The length of the IP header and the data included in the
    packet.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**总长度（Total Length）** IP 头部和数据包中包含的数据的长度。'
- en: '**Identification**   A unique identification number used to identify a packet
    or sequence of fragmented packets.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**标识符（Identification）** 用于标识数据包或碎片化数据包序列的唯一标识号码。'
- en: '**Flags**   Used to identify whether a packet is part of a sequence of fragmented
    packets.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**标志（Flags）** 用于标识数据包是否是碎片化数据包序列的一部分。'
- en: '**Fragment Offset**   If a packet is a fragment, the value of this field is
    used to reassemble the packets in the correct order.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**碎片偏移量（Fragment Offset）** 如果数据包是碎片，使用此字段的值来按正确顺序重新组装数据包。'
- en: '**Time to Live**   Defines the lifetime of the packet, measured in hops or
    seconds through routers.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**生存时间（Time to Live）** 定义数据包的生命周期，以跳数或通过路由器的秒数来衡量。'
- en: '**Protocol**   Identifies the transport layer header that encapsulates the
    IPv4 header.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议（Protocol）** 标识封装IPv4头部的传输层头部。'
- en: '**Header Checksum**   An error-detection mechanism used to verify that the
    contents of the IP header are not damaged or corrupted.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**头部校验和（Header Checksum）** 用于错误检测的机制，用以验证IP头部的内容是否损坏或受损。'
- en: '**Source IP Address**   The IP address of the host that sent the packet.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**源IP地址（Source IP Address）** 发送数据包的主机的IP地址。'
- en: '**Destination IP Address**   The IP address of the packet’s destination.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的地IP地址（Destination IP Address）** 数据包目的地的IP地址。'
- en: '**Options**   Reserved for additional IP options. It includes options for source
    routing and timestamps.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项（Options）** 预留用于额外的IP选项。包括源路由和时间戳选项。'
- en: '**Data**   The actual data being transmitted with IP.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据（Data）** 实际上传输的IP数据。'
- en: '![image](../images/f128-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f128-01.jpg)'
- en: '*Figure 7-9: The IPv4 packet structure*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：IPv4 数据包结构*'
- en: '**Time to Live**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生存时间（Time to Live）**'
- en: '*ip_ttl_source.pcapng ip_ttl_dest.pcapng*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*ip_ttl_source.pcapng ip_ttl_dest.pcapng*'
- en: The *Time to Live (TTL)* value defines a period of time that can elapse or a
    maximum number of routers a packet can traverse before the packet is discarded
    for IPv4\. A TTL is defined when a packet is created and generally is decremented
    by 1 every time the packet is forwarded by a router. For example, if a packet
    has a TTL of 2, the first router it reaches will decrement the TTL to 1 and forward
    it to the second router. This router will then decrement the TTL to zero, and
    if the final destination of the packet is not on that network, the packet will
    be discarded (see [Figure 7-10](ch07.xhtml#ch07fig10)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*生存时间（TTL）* 值定义了数据包可以经过的最大时间或最大路由器数量，超过此时间或数量后数据包会被丢弃（适用于IPv4）。TTL 在数据包创建时被定义，通常每次数据包被路由器转发时，TTL
    值会减 1。例如，如果数据包的 TTL 为 2，第一个到达的路由器会将 TTL 减为 1，并将数据包转发到第二个路由器。第二个路由器会再将 TTL 减为 0，如果数据包的最终目的地不在该网络上，数据包将被丢弃（见
    [图 7-10](ch07.xhtml#ch07fig10)）。'
- en: '![image](../images/f128-02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f128-02.jpg)'
- en: '*Figure 7-10: The TTL of a packet decreases every time it traverses a router.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：数据包的TTL每次经过路由器时都会减少。*'
- en: Why is the TTL value important? Typically, we are concerned about the lifetime
    of a packet only in terms of the time that it takes to travel from its source
    to its destination. However, consider a packet that must travel to a host across
    the internet while traversing dozens of routers. At some point in that packet’s
    path, it could encounter a misconfigured router and lose the path to its final
    destination. In such a case, the router could do a number of things, one of which
    could result in the packet’s being forwarded around a network in a never-ending
    loop.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么TTL值很重要？通常，我们只关心数据包从源地址到目的地所需的时间。然而，考虑到一个数据包必须通过多个路由器传输到互联网上的主机。在该数据包的路径中，可能会遇到配置错误的路由器，并失去到达最终目的地的路径。在这种情况下，路由器可以执行多种操作，其中一种可能导致数据包在网络中永无止境地循环。
- en: An infinite loop can cause all sorts of issues, but it typically results in
    the crash of a program or an entire operating system. Theoretically, the same
    thing could occur with packets on a network. The packets would keep looping between
    routers. As the number of looping packets increased, the available bandwidth on
    the network would deplete until a denial of service condition occurred. To prevent
    this, TTL was created.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 无限循环可能会引发各种问题，但通常会导致程序或整个操作系统崩溃。从理论上讲，网络中的数据包也可能发生类似情况。数据包将不断地在路由器之间循环。随着循环数据包的数量增加，网络中的带宽将被耗尽，直到发生拒绝服务的情况。为防止这种情况发生，TTL
    被创建。
- en: Let’s look at an example of this in Wireshark. The file *ip_ttl_source.pcapng*
    contains two ICMP packets. ICMP (discussed later in this chapter) uses IP to deliver
    packets, as we can see by expanding the IP header section in the Packet Details
    pane (see [Figure 7-11](ch07.xhtml#ch07fig11)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Wireshark中看一个示例。文件*ip_ttl_source.pcapng*包含两个ICMP数据包。ICMP（在本章稍后讨论）使用IP来传输数据包，我们可以通过展开“数据包详情”窗格中的IP头部部分来查看这一点（见[图7-11](ch07.xhtml#ch07fig11)）。
- en: '![image](../images/f129-01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f129-01.jpg)'
- en: '*Figure 7-11: The IP header of the source packet*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-11：源数据包的IP头部*'
- en: You can see that the version of IP being used is version 4 ➊, the IP header
    length is 20 bytes ➋, the total length of the header and payload is 60 bytes ➌,
    and the value of the TTL field is 128 ➍.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到使用的IP版本是版本4 ➊，IP头长度是20字节 ➋，头部和负载的总长度是60字节 ➌，TTL字段的值是128 ➍。
- en: The primary purpose of an ICMP ping is to test communication between devices.
    Data is sent from one host to another as a request, and the receiving host should
    send that data back as a reply. In this file, we have one device with the address
    of 10.10.0.3 ➎ sending an ICMP request to a device with the address 192.168.0.128
    ➏. This initial capture file was created at the source host, 10.10.0.3.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP Ping的主要目的是测试设备间的通信。数据从一个主机发送到另一个主机作为请求，接收主机应该将数据作为回复发回。在这个文件中，我们有一个地址为10.10.0.3
    ➎的设备向一个地址为192.168.0.128 ➏的设备发送ICMP请求。这个初始的捕获文件是在源主机10.10.0.3处创建的。
- en: Now open the file *ip_ttl_dest.pcapng*. In this file, the data was captured
    at the destination host, 192.168.0.128\. Expand the IP header of the first packet
    in this capture to examine its TTL value (see [Figure 7-12](ch07.xhtml#ch07fig12)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开文件*ip_ttl_dest.pcapng*。在这个文件中，数据是在目标主机192.168.0.128处捕获的。展开这个捕获中第一个数据包的IP头部以检查其TTL值（见[图7-12](ch07.xhtml#ch07fig12)）。
- en: You should immediately notice that the TTL value is 127 ➊, 1 less than the original
    TTL of 128\. Without even knowing the architecture of the network, we can conclude
    that one router separates these devices and thus the passage through that router
    reduced the TTL value by 1.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该立刻注意到TTL值为127 ➊，比原始TTL值128少了1。即使不了解网络的架构，我们也可以得出结论：有一台路由器将这些设备隔开，因此通过该路由器的传输将TTL值减少了1。
- en: '![image](../images/f130-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f130-01.jpg)'
- en: '*Figure 7-12: The IP header shows us that the TTL has been decremented by 1.*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-12：IP头部显示TTL已经减少了1。*'
- en: '**IP Fragmentation**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**IP分片**'
- en: '*ip_frag_source.pcapng*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*ip_frag_source.pcapng*'
- en: '*Packet fragmentation* is a feature of IP that permits reliable delivery of
    data across varying types of networks by splitting a data stream into smaller
    fragments.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据包分片*是IP的一个特性，它通过将数据流分割成更小的片段，从而允许在不同类型的网络中可靠地传输数据。'
- en: The fragmentation of a packet is based on the *maximum transmission unit (MTU)*
    size of the layer 2 data link protocol in use and the configuration of the devices
    using this layer 2 protocol. In most cases, the layer 2 data link protocol in
    use is Ethernet. Ethernet has a default MTU of 1,500, which means that the maximum
    packet size that can be transmitted over an Ethernet network is 1,500 bytes (not
    including the 14-byte Ethernet header itself).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包的分片是基于使用的第2层数据链路协议的*最大传输单元（MTU）*大小以及使用该第2层协议的设备配置。在大多数情况下，使用的第2层数据链路协议是以太网。以太网的默认MTU为1,500字节，这意味着可以通过以太网网络传输的最大数据包大小为1,500字节（不包括14字节的以太网头部）。
- en: '**NOTE**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although there are standard MTU settings, the MTU of a device can be reconfigured
    manually in most cases. An MTU setting is assigned on a per-interface basis and
    can be modified on Windows and Linux systems, as well as on the interfaces of
    managed routers.*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管有标准的MTU设置，但在大多数情况下，设备的MTU可以手动重新配置。MTU设置是按每个接口分配的，并且可以在Windows和Linux系统上修改，也可以在管理型路由器的接口上进行修改。*'
- en: 'When a device prepares to transmit an IP packet, it determines whether it must
    fragment the packet by comparing the packet’s data size to the MTU of the network
    interface from which the packet will be transmitted. If the data size is greater
    than the MTU, the packet will be fragmented. Fragmenting a packet involves the
    following steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备准备发送IP数据包时，它会通过将数据包的大小与将要传输该数据包的网络接口的MTU进行比较，来决定是否需要分片。如果数据包的大小大于MTU，则该数据包将被分片。分片数据包的步骤如下：
- en: The device splits the data into the number of packets required for successful
    data transmission.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备将数据分割成成功传输所需的数据包数量。
- en: The Total Length field of each IP header is set to the segment size of each
    fragment.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个IP头的总长度字段设置为每个碎片的段大小。
- en: The More fragments flag is set to 1 on all packets in the data stream, except
    for the last one.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据流中的所有数据包，除了最后一个，都设置了更多碎片标志为1。
- en: The Fragment offset field is set in the IP header of the fragments.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 碎片偏移字段被设置在碎片的IP头中。
- en: The packets are transmitted.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据包被传输。
- en: The file *ip_frag_source.pcapng* was taken from a computer with the address
    10.10.0.3, transmitting a ping request to a device with the address 192.168.0.128\.
    Notice that the Info column of the Packet List pane lists two fragmented IP packets,
    followed by the ICMP (ping) request.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*ip_frag_source.pcapng*是从地址为10.10.0.3的计算机上获取的，该计算机向地址为192.168.0.128的设备发送了ping请求。注意，在数据包列表窗格中的信息列列出了两个碎片化的IP数据包，后面是ICMP（ping）请求。
- en: Begin by examining the IP header of packet 1 (see [Figure 7-13](ch07.xhtml#ch07fig13)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从检查数据包1的IP头开始（见[图 7-13](ch07.xhtml#ch07fig13)）。
- en: '![image](../images/f131-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f131-01.jpg)'
- en: '*Figure 7-13: More fragments and Fragment offset values can indicate a fragmented
    packet.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：更多碎片标志和碎片偏移值可以指示一个碎片化的数据包。*'
- en: You can see that this packet is part of a fragment based on the More fragments
    and Fragment offset fields. Packets that are fragments will either have a positive
    Fragment offset value or have the More fragments flag set. In the first packet,
    the More fragments flag is set ➊, indicating that the receiving device should
    expect to receive another packet in this sequence. The Fragment offset is set
    to 0 ➋, indicating that this packet is the first in a series of fragments.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据更多碎片标志和碎片偏移字段看出该数据包是一个碎片。碎片数据包要么具有正的碎片偏移值，要么设置了更多碎片标志。在第一个数据包中，设置了更多碎片标志➊，表示接收设备应该期待接收到此序列中的另一个数据包。碎片偏移设置为0➋，表示该数据包是碎片序列中的第一个。
- en: The IP header of the second packet (see [Figure 7-14](ch07.xhtml#ch07fig14))
    also has the More fragments flag set ➊, but in this case, the Fragment offset
    value is 1480 ➋. This is indicative of the 1,500-byte MTU, minus 20 bytes for
    the IP header.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数据包的IP头（见[图 7-14](ch07.xhtml#ch07fig14)）也设置了更多碎片标志➊，但在这种情况下，碎片偏移值为1480➋。这表明MTU为1,500字节，减去20字节的IP头。
- en: The third packet (see [Figure 7-15](ch07.xhtml#ch07fig15)) does not have the
    More fragments flag set ➋, which marks it as the last fragment in the data stream,
    and the Fragment offset is set to 2960 ➌, the result of 1480 + (1500 – 20). These
    fragments can all be identified as part of the same series of data because they
    have the same values in the Identification field of the IP header ➊.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个数据包（见[图 7-15](ch07.xhtml#ch07fig15)）没有设置更多碎片标志➋，这标志着它是数据流中的最后一个碎片，碎片偏移值设置为2960➌，这是1480
    + (1500 – 20)的结果。由于它们在IP头的标识符字段中有相同的值➊，因此这些碎片可以被识别为同一数据系列的一部分。
- en: '![image](../images/f132-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f132-01.jpg)'
- en: '*Figure 7-14: The Fragment offset value increases based on the size of the
    packets.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-14：碎片偏移值会根据数据包的大小增加。*'
- en: '![image](../images/f132-02.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f132-02.jpg)'
- en: '*Figure 7-15: More fragments is not set, indicating that this fragment is the
    last.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-15：更多碎片标志未设置，表示该碎片是最后一个。*'
- en: While it isn’t as common to see fragmented packets on a network as it used to
    be, understanding why packets are fragmented is useful so that when you do encounter
    them, you can diagnose issues or spot missing fragments.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在网络中看到碎片化的数据包不像过去那么常见，但理解为什么数据包会被碎片化是很有用的，这样当你遇到它们时，便能诊断问题或发现丢失的碎片。
- en: '***Internet Protocol Version 6 (IPv6)***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***互联网协议第六版（IPv6）***'
- en: When the IPv4 specification was written, nobody had any idea that we would eventually
    have the number of internet-connected devices that exist today. The maximum IPv4
    addressable space was limited to just south of 4.3 billion addresses. The actual
    amount of addressable space shrinks even further when you subtract ranges reserved
    for special uses such as testing, broadcast traffic, and RFC1918 internal addresses.
    While several efforts were made to delay the exhaustion of IPv4 addresses, ultimately
    the only way to address this limitation was to develop a new version of the IP
    specification.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写IPv4规范时，没人预料到我们最终会拥有今天那么多的互联网连接设备。IPv4最大可寻址空间仅限于大约43亿个地址。实际的可寻址空间在减去保留给特殊用途的地址范围（如测试、广播流量和RFC1918内部地址）后，进一步缩小。尽管进行了多次努力以延缓IPv4地址的枯竭，但最终解决这一限制的唯一方法是开发新的IP规范版本。
- en: Thus, the IPv6 specification was created, with its first version released in
    1998 as RFC 2460\. This version provided several performance enhancements, including
    a much larger address space. In this section, we’ll look at the IPv6 packet structure
    and discuss how IPv6 communications differ from those of its predecessor.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，IPv6 规范应运而生，第一版于 1998 年发布，作为 RFC 2460。这一版本提供了几项性能提升，包括更大的地址空间。在本节中，我们将研究
    IPv6 数据包的结构，并讨论 IPv6 通信与其前身的区别。
- en: '**IPv6 Addresses**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**IPv6 地址**'
- en: IPv4 addresses were limited to 32 bits, a length that provided an addressable
    space measured in the billions. IPv6 addresses are 128 bit, providing an addressable
    space measured in undecillions (a trillion trillion trillion). That’s quite an
    upgrade!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 地址的位数限制为 32 位，提供了一个以十亿为单位的可寻址空间。IPv6 地址为 128 位，提供了一个以不可计数大数（万亿万亿万亿）为单位的可寻址空间。这可真是一次大升级！
- en: 'Since IPv6 addresses are 128 bits, they are unwieldy to manage in binary form.
    Most of the time, an IPv6 address is written in eight groups of 2 bytes in hexadecimal
    notation, with each group separated by a colon. For example, a very simple IPv6
    address looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 IPv6 地址为 128 位，因此以二进制形式管理它们比较笨重。大多数情况下，IPv6 地址以八组 2 字节的十六进制表示，每组之间用冒号分隔。例如，一个非常简单的
    IPv6 地址看起来是这样的：
- en: '[PRE0]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Your first thought is probably the same one many have who are used to remembering
    IPv4 addresses: IPv6 addresses are virtually impossible to memorize. That is an
    unfortunate trade-off for a much larger address space.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个想法可能和许多习惯记住 IPv4 地址的人一样：IPv6 地址几乎不可能记住。这是一个为了更大的地址空间所作的无奈取舍。
- en: 'One feature of IPv6 address notation that will help in some cases is that some
    groups of zeroes can be collapsed. For example, consider the following IPv6 address:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址表示法的一个特点是在某些情况下可以折叠零组。例如，考虑以下 IPv6 地址：
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can collapse the grouping containing the zeroes completely so it isn’t
    visible, like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将包含零的分组完全折叠，以使其不可见，如下所示：
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, you can only collapse a single group of zeroes, so the following address
    would be invalid:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你只能折叠单一的一组零，因此以下地址将是无效的：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another consideration is that leading zeroes can be dropped from IPv6 addresses.
    Consider this example in which there are zeroes in front of the fourth, fifth,
    and six groups:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是 IPv6 地址中的前导零可以被省略。考虑以下示例，其中第四、第五和第六组前面有零：
- en: '[PRE4]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You could represent the address more efficiently like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样更高效地表示地址：
- en: '[PRE5]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This isn’t quite as easy to use as an IPv4 address, but it’s a lot easier to
    deal with than the longer notation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这不像 IPv4 地址那样容易使用，但比起更长的表示法，处理起来要容易得多。
- en: 'An IPv6 address has a network portion and a host portion, often called a *network
    prefix* and *interface identifier*, respectively. The distribution of these fields
    varies depending on the classification of the IPv6 communication. IPv6 traffic
    is broken down into three classifications: unicast, multicast, or anycast. In
    most cases, you’ll probably be working with link-local unicast traffic, which
    is communication from one device to another inside a network. The format of a
    link-local unicast IPv6 address is shown in [Figure 7-16](ch07.xhtml#ch07fig16).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址包含网络部分和主机部分，通常分别称为 *网络前缀* 和 *接口标识符*。这些字段的分配方式取决于 IPv6 通信的分类。IPv6 流量被分为三种分类：单播、多播或任播。在大多数情况下，你可能会处理链路本地单播流量，即在网络内部一个设备与另一个设备之间的通信。链路本地单播
    IPv6 地址的格式如 [图 7-16](ch07.xhtml#ch07fig16) 所示。
- en: '![image](../images/f134-01.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f134-01.jpg)'
- en: '*Figure 7-16: The parts of an IPv6 link-local unicast address*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-16：IPv6 链路本地单播地址的各个部分*'
- en: Link-local addresses are used when communication is intended for another device
    within the same network. A link-local address can be identified by having its
    most significant 10 bits set to 1111111010 and the next 54 bits set to all zeroes.
    Thus, you can spot a link-local address when the first half is fe80:0000:0000:0000.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 链路本地地址用于当通信目标是同一网络内的另一台设备时。链路本地地址的标识方法是其最重要的 10 位设置为 1111111010，接下来的 54 位全部为零。因此，当地址的前半部分为
    fe80:0000:0000:0000 时，你可以辨认出这是一个链路本地地址。
- en: The second half of a link-local IPv6 address is the interface ID portion, which
    uniquely identifies a network interface on an endpoint host. On Ethernet networks,
    this can be based on the MAC address of the interface. However, a MAC address
    is only 48 bits. To fill up the entire 64-bit space, the MAC address is cut in
    half, and the value 0xfffe is added between each half as padding to create a unique
    identifier. Lastly, the seventh bit of the first byte is inverted. That’s a bit
    complex, but consider the interface ID in [Figure 7-17](ch07.xhtml#ch07fig17).
    The original MAC address for the device represented by this ID was 78:31:c1:cb:b2:56\.
    The bytes 0xfffe were added in the middle, and flipping the seventh bit of the
    first byte changed the *8* to an *a*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 链路本地IPv6地址的后半部分是接口ID部分，它唯一标识端点主机上的网络接口。在以太网网络中，这可以基于接口的MAC地址。然而，MAC地址只有48位。为了填满整个64位空间，MAC地址被分成两半，并在每一半之间添加值0xfffe作为填充，以创建唯一标识符。最后，第一个字节的第七位被反转。这有点复杂，但可以参考[图
    7-17](ch07.xhtml#ch07fig17)中的接口ID。表示此ID的设备的原始MAC地址是78:31:c1:cb:b2:56。字节0xfffe被添加在中间，反转第一个字节的第七位将*8*变为*a*。
- en: '![image](../images/f134-02.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f134-02.jpg)'
- en: '*Figure 7-17: The interface ID utilizes an interface MAC address and padding.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-17：接口ID使用接口的MAC地址和填充。*'
- en: 'IPv6 addresses can be represented with CIDR notation just like IPv4 addresses.
    In this example, 64 bits of addressable space are represented with a link-local
    address:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址可以像IPv4地址一样使用CIDR表示法表示。在这个例子中，64位的可寻址空间使用链路本地地址表示：
- en: '[PRE6]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The composition of an IPv6 address changes when it is used with global unicast
    traffic that is routed over the public internet (see [Figure 7-18](ch07.xhtml#ch07fig18)).
    When used in this manner, a global unicast is identified by having its first 3
    bits set to 001, followed by a 45-bit global routing prefix. The global routing
    prefix, which is assigned to organizations by the Internet Assigned Numbers Authority
    (IANA), is used to uniquely identify an organization’s IP space. The next 16 bits
    are the subnet ID, which can be used for hierarchical addressing, similar to the
    netmask portion of an IPv4 address. The final 64 bits are used for the interface
    ID, just as with link-local unicast addresses. The routing prefix and subnet ID
    can vary in size.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当IPv6地址用于通过公共互联网路由的全局单播流量时，其组成会发生变化（见[图 7-18](ch07.xhtml#ch07fig18)）。以这种方式使用时，全局单播的特点是其前3个位设置为001，后跟一个45位的全局路由前缀。全局路由前缀由互联网号码分配局（IANA）分配给组织，用于唯一标识一个组织的IP空间。接下来的16位是子网ID，可用于分层地址分配，类似于IPv4地址的网络掩码部分。最后的64位用于接口ID，和链路本地单播地址一样。路由前缀和子网ID的大小可以有所不同。
- en: '![image](../images/f135-01.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f135-01.jpg)'
- en: '*Figure 7-18: The parts of an IPv6 global unicast address*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-18：IPv6全局单播地址的各部分*'
- en: IPv6 provides a lot more efficiency than IPv4 in terms of routing packets to
    their destination and making effective use of address space. This efficiency is
    due to the larger range of addresses available and the use of link-local and global
    addressing along with unique host identifiers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 相较于IPv4，IPv6在路由数据包到达目的地和有效利用地址空间方面提供了更高的效率。这种效率得益于更大的地址范围，以及链路本地和全局地址的使用，结合唯一的主机标识符。
- en: '**NOTE**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s easy for you to visually differentiate IPv6 and IPv4 addresses, but many
    programs cannot do so. If you need to specify an IPv6 address, some applications,
    such as browsers or command line utilities, require you to place square brackets
    around the address, like this: [1111::2222:333:44:5:ffff]. This requirement isn’t
    always documented well and has been a source of frustration for many as they learn
    IPv6.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以很容易地视觉区分IPv6和IPv4地址，但许多程序不能这样做。如果你需要指定IPv6地址，一些应用程序，如浏览器或命令行工具，要求你将地址放在方括号内，例如：[1111::2222:333:44:5:ffff]。这个要求并不总是有很好的文档说明，许多人在学习IPv6时因此感到沮丧。*'
- en: '**IPv6 Packet Structure**'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**IPv6数据包结构**'
- en: '*http_ip4and6.pcapng*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*http_ip4and6.pcapng*'
- en: The structure of the IPv6 header has grown to support more features, but it
    was also designed to be easier to parse. Instead of being variable in size with
    a header length field that needs to be checked to parse the header, headers are
    now a fixed 40 bytes. Additional options are provided via extension headers. The
    benefit is that most routers only need to process the 40-byte header to forward
    the packet along.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 头部的结构已经扩展，以支持更多功能，但它也被设计得更易解析。头部现在是固定的 40 字节，而不是具有需要检查的头部长度字段的可变大小。附加选项通过扩展头部提供。其好处是，大多数路由器只需要处理
    40 字节的头部即可转发数据包。
- en: 'As shown in [Figure 7-19](ch07.xhtml#ch07fig19), the IPv6 header has the following
    fields:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 7-19](ch07.xhtml#ch07fig19) 所示，IPv6 头部包含以下字段：
- en: '**Version**   The version of IP being used (this is always 6 for IPv6).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本**   正在使用的 IP 版本（对于 IPv6，总是为 6）。'
- en: '**Traffic Class**   Used to prioritize certain classes of traffic.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**流量类别**   用于对某些类别的流量进行优先级排序。'
- en: '![image](../images/f136-01.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f136-01.jpg)'
- en: '*Figure 7-19: The IPv6 packet structure*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-19：IPv6 数据包结构*'
- en: '**Flow Label**   Used by a source to label a set of packets belonging to the
    same flow. This field is typically used for quality of service (QoS) management
    and to ensure packets that are part of the same flow take the same path.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**流标签**   由源使用来标记属于同一流的一组数据包。此字段通常用于服务质量（QoS）管理，并确保属于同一流的数据包走相同的路径。'
- en: '**Payload Length**   The length of the data payload following the IPv6 header.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**有效载荷长度**   紧随 IPv6 头部后的数据载荷的长度。'
- en: '**Next Header**   Identifies the layer 4 header that encapsulates the IPv6
    header. This field replaces the Protocol field in IPv4.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一个头部**   标识封装 IPv6 头部的第 4 层头部。此字段替代了 IPv4 中的协议字段。'
- en: '**Hop Limit**   Defines the lifetime of the packet, measured in hops through
    routers. This field replaces the TTL field in IPv4.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**跳数限制**   定义数据包的生命周期，以通过路由器的跳数来衡量。此字段替代了 IPv4 中的 TTL 字段。'
- en: '**Source IP Address**   The IP address of the host that sent the packet.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**源 IP 地址**   发送数据包的主机的 IP 地址。'
- en: '**Destination IP Address**   The IP address of the packet’s destination.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的地 IP 地址**   数据包目的地的 IP 地址。'
- en: Let’s compare an IPv4 and an IPv6 packet to examine a few of the differences
    by looking at *http_ip4and6.pcapng*. In this capture, a web server was configured
    to listen for both IPv4 and IPv6 connections on the same physical host. A single
    client configured with both IPv4 and IPv6 addresses browsed to a server using
    each of its addresses independently and downloaded the *index.php* page using
    HTTP via the curl application ([Figure 7-20](ch07.xhtml#ch07fig20)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过比较 IPv4 和 IPv6 数据包，查看一些差异，参见 *http_ip4and6.pcapng*。在此抓包中，配置了一个 Web 服务器，监听同一物理主机上的
    IPv4 和 IPv6 连接。一个配置了 IPv4 和 IPv6 地址的客户端独立地使用各自的地址浏览服务器，并通过 curl 应用程序使用 HTTP 下载
    *index.php* 页面（见 [图 7-20](ch07.xhtml#ch07fig20)）。
- en: Upon opening the capture, you should readily see which packets belong to which
    conversation based on the addresses in the Source and Destination columns in the
    Packet List area. Packets 1 through 10 represent the IPv4 stream (stream 0), and
    packets 11 through 20 represent the IPv6 stream (stream 1). You can filter for
    each of these streams from the Conversations window or by entering tcp.stream
    == 0 or tcp.stream == 1 in the filter bar.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 打开抓包文件后，你应该能够根据数据包列表区域中的源和目的地列地址，轻松看到哪些数据包属于哪个会话。数据包 1 到 10 表示 IPv4 流（流 0），数据包
    11 到 20 表示 IPv6 流（流 1）。你可以从会话窗口过滤每个流，或在过滤栏中输入 tcp.stream == 0 或 tcp.stream ==
    1。
- en: '![image](../images/f137-01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f137-01.jpg)'
- en: '*Figure 7-20: Connections between the same physical hosts using different IP
    versions*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-20：使用不同 IP 版本的相同物理主机之间的连接*'
- en: We’ll cover HTTP, the protocol responsible for serving web pages on the internet,
    in depth in [Chapter 8](ch08.xhtml#ch08). In this example, just note that the
    business of serving web pages remains consistent regardless of which lower-layer
    network protocol is used. The same can be said of TCP, which also operates in
    a consistent manner. This is a prime example of encapsulation in action. Although
    IPv4 and IPv6 function differently, the protocols functioning at different layers
    are unaffected.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 8 章](ch08.xhtml#ch08) 中深入讨论 HTTP，这是负责提供网页的协议。在这个例子中，只需注意，无论使用哪种下层网络协议，提供网页的业务始终保持一致。TCP
    也是如此，它的操作方式也始终一致。这是封装作用的一个典型例子。尽管 IPv4 和 IPv6 的工作方式不同，但不同层次的协议并不受影响。
- en: '[Figure 7-21](ch07.xhtml#ch07fig21) provides a side-by-side comparison of two
    packets with the same function—packets 1 and 11\. Both packets are TCP SYN packets
    designed to initiate a connection from the client to the server. The Ethernet
    and TCP sections of these packets are nearly identical. However, the IP sections
    are completely different.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-21](ch07.xhtml#ch07fig21)提供了两个数据包的并排比较，功能相同——数据包1和数据包11。两个数据包都是TCP SYN数据包，旨在从客户端发起与服务器的连接。这些数据包的以太网和TCP部分几乎相同。然而，IP部分完全不同。'
- en: •     The source and destination address formats are different ➏➓.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: •     源地址和目标地址格式不同 ➏➓。
- en: •     The IPv4 packet is 74 bytes with a 60-byte total length ➊, which includes
    both the IPv4 header and payload and a 14-byte Ethernet header. The IPv6 packet
    is 96 bytes with a 40-byte IPv6 payload ➐ and a separate 40-byte IPv6 header along
    with the 14-byte Ethernet header. The IPv6 header is 40 bytes, double the IPv4
    header’s 20 bytes, to accommodate the larger address size.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: •     IPv4数据包为74字节，总长度为60字节 ➊，其中包括IPv4头和有效载荷，以及14字节的以太网头。IPv6数据包为96字节，其中包括40字节的IPv6有效载荷
    ➐，并且有一个独立的40字节IPv6头和14字节的以太网头。IPv6头是40字节，是IPv4头20字节的两倍，以适应更大的地址大小。
- en: •     IPv4 identifies the protocol with the Protocol field ➍, whereas IPv6 identifies
    it with the Next header field (which can also be used to specify extension headers)
    ➑.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: •     IPv4通过协议字段 ➍识别协议，而IPv6通过下一个头字段（也可以用于指定扩展头） ➑识别协议。
- en: •     IPv4 has a TTL field ➌, whereas IPv6 accomplishes the same functionality
    using the Hop limit field ➒.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: •     IPv4有TTL字段 ➌，而IPv6使用跳数限制字段 ➒来实现相同的功能。
- en: •     IPv4 includes a header checksum value ➎, while IPv6 does not.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: •     IPv4包含一个头部校验和值 ➎，而IPv6则没有。
- en: •     The IPv4 packet is not fragmented, but it still includes values for those
    options ➋. The IPv6 header doesn’t contain this information because, if fragmentation
    were required, it would be implemented in an extension header.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: •     IPv4数据包没有被分片，但它仍包括这些选项的值 ➋。IPv6头部不包含这些信息，因为如果需要分片，它将在扩展头中实现。
- en: '![image](../images/f138-01.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f138-01.jpg)'
- en: '*Figure 7-21: A side-by-side comparison of IPv4 (top) and IPv6 (bottom) packets
    performing the same function*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-21：IPv4（上）和IPv6（下）数据包并排比较，执行相同功能*'
- en: Performing side-by-side comparisons of IPv4 and IPv6 traffic is a great way
    to fully appreciate the difference between how the two protocols operate.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 并排比较IPv4和IPv6流量是完全理解这两种协议如何操作差异的好方法。
- en: '**Neighbor Solicitation and ARP**'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**邻居请求与ARP**'
- en: '*icmpv6_neighbor_solicitation.pcapng*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*icmpv6_neighbor_solicitation.pcapng*'
- en: When we discussed the different classifications of traffic earlier, I listed
    uni-cast, multicast, and anycast but did not list broadcast traffic. IPv6 doesn’t
    support broadcast traffic because broadcast is viewed as an inefficient mechanism
    for transmission. Because there is no broadcast, ARP can’t be used for hosts to
    find each other on a network. So, how do IPv6 devices find each other?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前讨论不同的流量分类时，我列出了单播、多播和任播，但没有列出广播流量。IPv6不支持广播流量，因为广播被视为一种低效的传输机制。由于没有广播，ARP无法用于主机之间在网络上的相互发现。那么，IPv6设备是如何找到彼此的呢？
- en: The answer lies with a new feature called *neighbor solicitation*, a function
    of Neighbor Discovery Protocol (NDP), which utilizes ICMPv6 (discussed in the
    last section of this chapter) to do its legwork. To accomplish this task, ICMPv6
    uses multicast, a type of communication in which only hosts that subscribe to
    a data stream will receive and process it. Multicast traffic can be identified
    quickly because it has its own reserved IP space (ff00::/8).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于一个名为*邻居请求*的新特性，这是邻居发现协议（NDP）的一部分，它利用ICMPv6（在本章最后一节讨论）来完成这项工作。为了实现这个任务，ICMPv6使用多播，一种通信方式，只有订阅特定数据流的主机才能接收并处理它。多播流量可以迅速识别，因为它有自己保留的IP空间（ff00::/8）。
- en: Although the address resolution process relies on a different protocol, it still
    uses a very simple request/response workflow. For example, let’s consider a scenario
    in which a host with the IPv6 address 2001:db8:1:2::1003 wants to communicate
    with another host identified by the address 2001:db8:1:2::1000\. Just as with
    IPv4, the source device must be able to determine the link-layer (MAC) address
    of the host it wants to communicate with, since this is intra-network communication.
    This process is described in [Figure 7-22](ch07.xhtml#ch07fig22).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管地址解析过程依赖于不同的协议，但它仍然使用非常简单的请求/响应工作流。例如，假设一个 IPv6 地址为 2001:db8:1:2::1003 的主机想与另一个地址为
    2001:db8:1:2::1000 的主机通信。就像 IPv4 一样，源设备必须能够确定它想要通信的主机的链路层（MAC）地址，因为这是网络内部通信。该过程如
    [图 7-22](ch07.xhtml#ch07fig22) 所示。
- en: '![image](../images/f139-01.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f139-01.jpg)'
- en: '*Figure 7-22: The neighbor solicitation process for address resolution*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-22：地址解析的邻居请求过程*'
- en: In this process, the host 2001:db8:1:2::1003 sends a Neighbor Solicitation (ICMPv6
    type 135) packet to every device on the network via multicast, asking, “What is
    the MAC address for the device whose IP address is 2001:db8:1:2::1000? My MAC
    address is 00:0C:29:2f:80:31.”
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，主机 2001:db8:1:2::1003 通过多播向网络上的每个设备发送一个邻居请求（ICMPv6 类型 135）包，询问：“IP 地址为
    2001:db8:1:2::1000 的设备的 MAC 地址是什么？我的 MAC 地址是 00:0C:29:2f:80:31。”
- en: The device assigned that IPv6 address will receive this multicast transmission
    and respond to the originating host with a Neighbor Advertisement (ICMPv6 type
    136) packet. This packet says, “Hi, my network address is 2001:db8:1:2::1000 and
    my MAC address is 00:0c:29:1f:a7:55.” Once this message is received, communication
    can begin.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 被分配了该 IPv6 地址的设备将接收到此多播传输，并通过邻居广告（ICMPv6 类型 136）包响应源主机。此包内容为：“你好，我的网络地址是 2001:db8:1:2::1000，我的
    MAC 地址是 00:0c:29:1f:a7:55。”收到此消息后，通信可以开始。
- en: You can see this process in action in the capture file *icmpv6_neighbor _solicitation.pcapng*.
    This capture embodies the example we’ve just discussed in which 2001:db8:1:2::1003
    wants to communicate with 2001:db8:1:2::1000\. Look at the first packet and expand
    the ICMPv6 portion in the Packet Details window ([Figure 7-23](ch07.xhtml#ch07fig23))
    to see that the packet is ICMP type 135 ➋ and was sent from 2001:db8:1:2::1003
    to the multicast address ff02::1:ff00:1000 ➊. The source host provided the target
    IPv6 address it wanted to communicate with ➌, along with its own layer 2 MAC address
    ➍.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捕获文件 *icmpv6_neighbor_solicitation.pcapng* 中看到此过程的实际操作。该捕获文件展示了我们刚才讨论的示例，其中
    2001:db8:1:2::1003 想与 2001:db8:1:2::1000 通信。查看第一个包并展开“包详细信息”窗口中的 ICMPv6 部分（[图
    7-23](ch07.xhtml#ch07fig23)），可以看到该包是 ICMP 类型 135 ➋，从 2001:db8:1:2::1003 发送到多播地址
    ff02::1:ff00:1000 ➊。源主机提供了它想要通信的目标 IPv6 地址 ➌，以及它自己的第 2 层 MAC 地址 ➍。
- en: '![image](../images/f140-01.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f140-01.jpg)'
- en: '*Figure 7-23: A neighbor solicitation packet*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-23：一个邻居请求包*'
- en: The response to the solicitation is found in the second packet in the capture
    file. Expanding the ICMPv6 portion of the Packet Details window ([Figure 7-24](ch07.xhtml#ch07fig24))
    reveals this packet is ICMP type 136 ➋, was sent from 2001:db8:1:2::1000 back
    to 2001:db8:1:2::1003 ➊, and contains the MAC address 00:0c:29:1f:a7:55 associated
    with 2001:db8:1:2::1000 ➌.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对请求的响应可以在捕获文件的第二个包中找到。展开“包详细信息”窗口中的 ICMPv6 部分（[图 7-24](ch07.xhtml#ch07fig24)）可以看到，该包是
    ICMP 类型 136 ➋，从 2001:db8:1:2::1000 发送回 2001:db8:1:2::1003 ➊，并包含与 2001:db8:1:2::1000
    相关的 MAC 地址 00:0c:29:1f:a7:55 ➌。
- en: '![image](../images/f141-01.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f141-01.jpg)'
- en: '*Figure 7-24: A neighbor advertisement packet*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-24：一个邻居广告包*'
- en: Upon completion of this process, 2001:db8:1:2::1003 and 2001:db8:1:2::1000 begin
    communicating normally with ICMPv6 echo request and reply packets, indicating
    the neighbor solicitation process and link-layer address resolution was successful.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此过程后，2001:db8:1:2::1003 和 2001:db8:1:2::1000 将开始正常通信，使用 ICMPv6 回显请求和回复包，表示邻居请求过程和链路层地址解析成功。
- en: '**IPv6 Fragmentation**'
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**IPv6 分片**'
- en: '*ipv6_fragments.pcapng*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*ipv6_fragments.pcapng*'
- en: Fragmentation support was built into the IPv4 header because it ensured packets
    could traverse all sorts of networks at a time when network MTUs varied wildly.
    In IPv6, fragmentation is used less, so the options supporting it are not included
    in the IPv6 header. A device transmitting IPv6 packets is expected to perform
    a process called *MTU discovery* to determine the maximum size of packets it can
    send before actually sending them. In the event that a router receives a packet
    that is too large for the MTU on the network it is forwarding to, it will drop
    the packet and return an ICMPv6 Packet Too Big (type 2) message to the originating
    host. Upon receipt, the originating host will attempt to resend the packet with
    a smaller MTU, if such action is supported by the upper-layer protocol. This process
    will repeat until a small enough MTU is reached or until the payload can be fragmented
    no more ([Figure 7-25](ch07.xhtml#ch07fig25)). A router will never be responsible
    for fragmenting packets on its own; the source device is responsible for determining
    an appropriate MTU for the transmission path and fragmenting appropriately.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 分段支持被内置在IPv4头部中，因为它确保了数据包可以在各种网络中传输，而那时网络的最大传输单元（MTU）差异极大。在IPv6中，分段的使用较少，因此支持分段的选项没有包含在IPv6头部中。传输IPv6数据包的设备需要执行一个叫做*MTU发现*的过程，以确定它在发送数据包之前可以发送的最大数据包大小。如果路由器接收到一个超出其转发的网络MTU的数据包，它将丢弃该数据包并返回一个ICMPv6的"数据包过大"（类型2）消息给源主机。接收到此消息后，源主机会尝试使用更小的MTU重新发送数据包（前提是上层协议支持这种操作）。这一过程将不断重复，直到达到足够小的MTU，或者直到负载无法再进行分段为止（[图7-25](ch07.xhtml#ch07fig25)）。路由器永远不会自己负责分段数据包；源设备负责确定传输路径的合适MTU，并适当分段。
- en: '![image](../images/f142-01.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f142-01.jpg)'
- en: '*Figure 7-25: IPv6 MTU path discovery*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-25：IPv6 MTU路径发现*'
- en: If the upper-layer protocol being used in conjunction with IPv6 can’t limit
    the size of the packet payload, then fragmentation must still be used. A fragmentation
    extension header can be added to the IPv6 packet to support this scenario. You
    will find a sample capture showing IPv6 fragmentation in the file named *ipv6_fragments.pcapng*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与IPv6一起使用的上层协议无法限制数据包负载的大小，则仍然必须使用分段。可以将分段扩展头部添加到IPv6数据包中，以支持这种情况。你可以在名为*ipv6_fragments.pcapng*的文件中找到显示IPv6分段的示例捕获。
- en: Because the receiving device has a smaller MTU than the sending device, there
    are two fragmented packets to represent each ICMPv6 echo request and reply in
    the capture file. The fragmentation header from the first packet is shown in [Figure
    7-26](ch07.xhtml#ch07fig26).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接收设备的MTU小于发送设备，因此在捕获文件中，每个ICMPv6回显请求和回显应答都有两个分段的数据包。第一个数据包的分段头部如[图7-26](ch07.xhtml#ch07fig26)所示。
- en: '![image](../images/f142-02.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f142-02.jpg)'
- en: '*Figure 7-26: An IPv6 fragment header extension*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-26：IPv6分段头部扩展*'
- en: The 8-byte extension header contains all the same fragmentation properties that
    are found in an IPv4 packet, such as a Fragment offset ➋, More Fragments flag
    ➌, and Identification field ➍. Instead of being present in every packet, it is
    only added to the end of packets requiring fragmentation. This more efficient
    process still allows the receiving system to reassemble the fragments appropriately.
    Additionally, if this extension header is present, the Next header field will
    point to the extension header rather than the encapsulating protocol ➊.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 8字节的扩展头部包含了与IPv4数据包中相同的所有分段属性，例如分段偏移量 ➋、更多分段标志 ➌ 和标识字段 ➍。它并非出现在每个数据包中，而是仅添加到需要分段的数据包的末尾。这个更高效的过程仍然允许接收系统适当地重新组装分段。此外，如果存在这个扩展头部，下一头部字段将指向扩展头部，而不是封装协议
    ➊。
- en: '**IPv6 Transitional Protocols**'
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**IPv6过渡协议**'
- en: 'IPv6 addresses a very real problem, but its adoption has been slow because
    of the effort required to transition network infrastructure to it. To ease this
    transition, several protocols allow IPv6 communication to be tunneled across networks
    that support only IPv4 communication. In this respect, tunneling means that IPv6
    communication is encapsulated inside of IPv4 communications just as other protocols
    may be encapsulated. Encapsulation is usually done in one of three ways:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6解决了一个非常实际的问题，但由于将网络基础设施迁移到IPv6所需的工作量，其采用速度较慢。为了简化这一过渡，几种协议允许IPv6通信通过只支持IPv4通信的网络进行隧道传输。在这个意义上，隧道传输意味着IPv6通信被封装在IPv4通信中，就像其他协议可能被封装一样。封装通常通过三种方式之一进行：
- en: '**Router to Router**   Uses a tunnel to encapsulate IPv6 traffic from the transmitting
    and receiving hosts on their networks over an IPv4 network. This method allows
    entire networks to communicate in IPv6 over intermediary IPv4 links.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由器到路由器**    使用隧道封装IPv6流量，将传输和接收主机的网络上的流量通过IPv4网络传输。此方法允许整个网络通过中介IPv4链接进行IPv6通信。'
- en: '**Host to Router**   Uses encapsulation at the router level to transmit traffic
    from an IPv6 host over an IPv4 network. This method allows an individual host
    to communicate in IPv6 to an IPv6 network when the host resides on an IPv4-only
    network.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机到路由器**    在路由器级别使用封装将IPv6主机上的流量通过IPv4网络进行传输。该方法允许当主机位于仅支持IPv4网络时，主机可以在IPv6网络中进行IPv6通信。'
- en: '**Host to Host**   Uses a tunnel between two endpoints to encapsulate IPv6
    traffic between IPv4- or IPv6-capable hosts. This method allows IPv6 endpoints
    to communicate directly across an IPv4 network.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机到主机**    通过两个端点之间的隧道封装IPv6流量，实现IPv4或IPv6主机之间的通信。该方法允许IPv6端点直接通过IPv4网络进行通信。'
- en: 'While this book won’t cover transitional protocols in depth, it’s helpful to
    be aware of their existence in case you ever need to investigate them while performing
    analysis at the packet level. The following are a few common protocols:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书不会深入讨论过渡协议，但了解它们的存在很有帮助，以防在进行数据包级别的分析时需要研究它们。以下是一些常见的协议：
- en: '**6to4**   Also known as *IPv6 over IPv4*, this transitional protocol allows
    IPv6 packets to be transmitted across an IPv4 network. This protocol supports
    relays and routers to provide router-to-router, host-to-router, and host-to-host
    IPv6 communication.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**6to4**    也称为*IPv6 over IPv4*，该过渡协议允许IPv6数据包通过IPv4网络进行传输。此协议支持中继和路由器提供路由器到路由器、主机到路由器以及主机到主机的IPv6通信。'
- en: '**Teredo**   This protocol, used for IPv6 unicast communications over an IPv4
    network using NAT (network address translation), works by sending IPv6 packets
    over IPv4 encapsulated in the UDP transport protocol.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**Teredo**    该协议用于通过NAT（网络地址转换）在IPv4网络上传输IPv6单播通信，其工作原理是将IPv6数据包封装在UDP传输协议中，通过IPv4进行传输。'
- en: '**ISATAP**   This intrasite protocol allows communication between IPv4-and
    IPv6-only devices within a network in a host-to-host manner.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**ISATAP**    该站内协议允许在同一网络内进行IPv4和IPv6设备之间的主机到主机通信。'
- en: '**Internet Control Message Protocol (ICMP)**'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**互联网控制消息协议（ICMP）**'
- en: '*Internet Control Message Protocol (ICMP)* is the utility protocol of TCP/IP,
    responsible for providing information regarding the availability of devices, services,
    or routes on a TCP/IP network. Most network-troubleshooting techniques and tools
    center around common ICMP message types. ICMP is defined in RFC 792.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*互联网控制消息协议（ICMP）*是TCP/IP的实用协议，负责提供有关TCP/IP网络上设备、服务或路由可用性的信息。大多数网络故障排除技术和工具都集中在常见的ICMP消息类型上。ICMP定义在RFC
    792中。'
- en: '***ICMP Packet Structure***'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ICMP数据包结构***'
- en: 'ICMP is part of IP, and it relies on IP to transmit its messages. ICMP contains
    a relatively small header that changes depending on its purpose. As shown in [Figure
    7-27](ch07.xhtml#ch07fig27), the ICMP header contains the following fields:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP是IP的一部分，依赖于IP来传输其消息。ICMP包含一个相对较小的头部，根据其目的的不同而变化。如[图7-27](ch07.xhtml#ch07fig27)所示，ICMP头部包含以下字段：
- en: '**Type**   The type or classification of the ICMP message, based on the RFC
    specification'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**    根据RFC规范，ICMP消息的类型或分类。'
- en: '**Code**   The subclassification of the ICMP message, based on the RFC specification'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**    根据RFC规范对ICMP消息的子分类。'
- en: '**Checksum**   Used to ensure that the contents of the ICMP header and data
    are intact upon arrival'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**校验和**    用于确保ICMP头部和数据在到达时完整无损。'
- en: '**Variable**   A portion that varies depending on the Type and Code fields'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变**    根据类型和代码字段的不同而变化的一部分。'
- en: '![image](../images/f144-01.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f144-01.jpg)'
- en: '*Figure 7-27: The ICMP header*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-27：ICMP头部*'
- en: '***ICMP Types and Messages***'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ICMP类型和消息***'
- en: As noted, the structure of an ICMP packet depends on its purpose, as defined
    by the values in the *Type* and *Code* fields.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ICMP数据包的结构取决于其目的，这由*类型*和*代码*字段中的值定义。
- en: You might consider the ICMP Type field the packet’s classification and the Code
    field its subclass. For example, a Type field value of 3 indicates “destination
    unreachable.” While this information alone might not be enough to troubleshoot
    a problem, if that packet were also to specify a Code field value of 3, indicating
    “port unreachable,” you could conclude that there is an issue with the port with
    which you are attempting to communicate.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 ICMP 类型字段看作是数据包的分类，而代码字段则是其子分类。例如，类型字段的值为 3 表示“目标不可达”。虽然仅凭这些信息可能不足以解决问题，但如果该数据包同时指定了代码字段值为
    3，表示“端口不可达”，你就可以推测你尝试通信的端口存在问题。
- en: '**NOTE**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For a full list of available ICMP types and codes, see* http://www.iana.org/assignments/icmp-parameters/.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关可用 ICMP 类型和代码的完整列表，请参见* http://www.iana.org/assignments/icmp-parameters/.'
- en: '***Echo Requests and Responses***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回显请求与回应***'
- en: '*icmp_echo.pcapng*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*icmp_echo.pcapng*'
- en: ICMP’s biggest claim to fame is the ping utility. *Ping* is used to test for
    connectivity to a device. While ping itself isn’t a part of the ICMP spec, it
    utilizes ICMP to achieve its core functionality.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP 最著名的应用就是 ping 工具。*Ping* 用于测试与设备的连接性。虽然 ping 本身并不是 ICMP 规范的一部分，但它利用了 ICMP
    来实现其核心功能。
- en: To use ping, enter `ping ipaddress` at the command prompt, replacing ipaddress
    with the actual IP address of a device on your network. If the target device is
    turned on, your computer has a communication route to it, and there is no firewall
    blocking that communication, you should see replies to your `ping` command.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ping 时，在命令提示符中输入 `ping ipaddress`，将 ipaddress 替换为你网络中某个设备的实际 IP 地址。如果目标设备已开启，且你的计算机能够与之通信，并且没有防火墙阻止该通信，你应该能够看到对
    `ping` 命令的回应。
- en: The example in [Figure 7-28](ch07.xhtml#ch07fig28) shows four successful replies
    that display their size; round trip time (or RTT), which is the time it takes
    for the packet to arrive and a response to be received; and TTL used. The Windows
    utility also provides a summary detailing how many packets were sent, received,
    and lost. If communication fails, you should see a message telling you why.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-28](ch07.xhtml#ch07fig28)中的例子显示了四个成功的回复，展示了其大小、往返时间（或 RTT，指的是数据包到达并接收到回应所需的时间）和使用的
    TTL 值。Windows 工具还提供了一个总结，详细列出了发送、接收和丢失的数据包数量。如果通信失败，你应该看到一条信息，告诉你原因。'
- en: '![image](../images/f145-01.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f145-01.jpg)'
- en: '*Figure 7-28: The `ping` command being used to test connectivity*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-28：使用`ping`命令测试连接性*'
- en: Basically, the `ping` command sends one packet at a time to a device and listens
    for a reply to determine whether there is connectivity to that device, as shown
    in [Figure 7-29](ch07.xhtml#ch07fig29).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`ping` 命令一次只向设备发送一个数据包，并监听回应来判断是否与该设备存在连接性，如[图 7-29](ch07.xhtml#ch07fig29)所示。
- en: '![image](../images/f145-02.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f145-02.jpg)'
- en: '*Figure 7-29: The `ping` command involves only two steps.*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-29：`ping`命令仅涉及两个步骤。*'
- en: '**NOTE**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although ping has long been the bread and butter of IT, its results can be
    a bit deceiving when host-based firewalls are deployed. Many of today’s firewalls
    limit the ability of a device to respond to ICMP packets. This is great for security,
    because potential attackers using ping to determine whether a host is accessible
    might be deterred, but troubleshooting is also more difficult—it can be frustrating
    to ping a device to test for connectivity and not receive a reply when you know
    you can communicate with that device.*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然 ping 长期以来一直是 IT 领域的基础工具，但当主机防火墙部署时，它的结果可能会有些误导。如今的许多防火墙限制了设备响应 ICMP 数据包的能力。这对安全性非常有利，因为潜在的攻击者使用
    ping 来判断主机是否可达时可能会被阻止，但故障排除也变得更加困难——当你知道自己能与设备通信时，ping 设备测试连接性却没有得到回应，可能会让人感到沮丧。*'
- en: The ping utility in action is a great example of simple ICMP communication.
    The packets in the file *icmp_echo.pcapng* demonstrate what happens when you run
    ping.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ping 工具的实际应用是一个简单的 ICMP 通信的很好的例子。文件中的数据包 *icmp_echo.pcapng* 展示了当你运行 ping 时发生的情况。
- en: The first packet (see [Figure 7-30](ch07.xhtml#ch07fig30)) shows that host 192.168.100.138
    is sending a packet to 192.168.100.1 ➊. When you expand the ICMP portion of this
    packet, you can determine the ICMP packet type by looking at the Type and Code
    fields. In this case, the packet is type 8 ➋ and the code is 0 ➌, indicating an
    echo request. (Wireshark should tell you what the displayed type/code actually
    is.) This echo (ping) request is the first half of the equation. It is a simple
    ICMP packet, sent using IP, that contains a small amount of data. Along with the
    type and code designations and the checksum, we also have a sequence number that
    is used to pair requests with replies, and there is a random text string in the
    variable portion of the ICMP packet.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据包（见[图 7-30](ch07.xhtml#ch07fig30)）显示主机 192.168.100.138 正在向 192.168.100.1
    发送数据包 ➊。当你展开此数据包的 ICMP 部分时，可以通过查看类型和代码字段来确定 ICMP 数据包类型。在这种情况下，数据包类型为 8 ➋，代码为 0
    ➌，表示回显请求。（Wireshark 应该会告诉你显示的类型/代码是什么。）这个回显（ping）请求是公式的前半部分。它是一个简单的 ICMP 数据包，通过
    IP 发送，包含少量数据。除了类型和代码标识以及校验和之外，我们还有一个用于将请求与回复配对的序列号，并且 ICMP 数据包的可变部分中还包含一个随机文本字符串。
- en: '![image](../images/f146-01.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f146-01.jpg)'
- en: '*Figure 7-30: An ICMP echo request packet*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-30：一个 ICMP 回显请求数据包*'
- en: '**NOTE**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The terms* echo *and* ping *are often used interchangeably, but remember that*
    ping *is actually the name of a tool. The ping tool is used to send ICMP echo
    request packets.*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*术语* echo *和* ping *常常可以互换使用，但请记住* ping *实际上是一个工具的名称。ping 工具用于发送 ICMP 回显请求数据包。*'
- en: The second packet in this sequence is the reply to our request (see [Figure
    7-31](ch07.xhtml#ch07fig31)). The ICMP portion of the packet is type 0 ➊ and code
    0 ➋, indicating that this is an echo reply. Because the sequence number and identifier
    in the second packet match those of the first ➌, we know that this echo reply
    matches the echo request in the previous packet. Wireshark displays the values
    of these fields in big-endian (BE) and little-endian (LE) format. In other words,
    it represents the data in a different order based on how a particular endpoint
    might process the data. This reply packet also contains the same 32-byte string
    of data that was transmitted with the initial request ➍. Once this second packet
    has been received by 192.168.100.138, ping will report success.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列中的第二个数据包是对我们请求的回复（见[图 7-31](ch07.xhtml#ch07fig31)）。数据包的 ICMP 部分类型为 0 ➊，代码为
    0 ➋，表明这是一个回显回复。由于第二个数据包中的序列号和标识符与第一个数据包相同 ➌，我们知道这个回显回复与前一个数据包中的回显请求相匹配。Wireshark
    以大端（BE）和小端（LE）格式显示这些字段的值。换句话说，它根据特定端点处理数据的方式，以不同的顺序表示数据。这个回复数据包还包含与初始请求一起传输的相同的
    32 字节数据字符串 ➍。一旦 192.168.100.138 收到第二个数据包，ping 将报告成功。
- en: '![image](../images/f147-01.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f147-01.jpg)'
- en: '*Figure 7-31: An ICMP echo reply packet*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-31：一个 ICMP 回显回复数据包*'
- en: Note that you can use variations of the ping command to increase the size of
    the data padding in echo requests, which forces packets to be fragmented for various
    types of network troubleshooting. This may be necessary when you’re troubleshooting
    networks that require a smaller fragment size.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以使用 ping 命令的不同变种来增加回显请求中的数据填充大小，这将迫使数据包在各种类型的网络故障排除中进行分段。当你在故障排除需要更小分段大小的网络时，这可能是必需的。
- en: '**NOTE**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The random text used in an ICMP echo request can be of great interest to a
    potential attacker. Attackers can use the information in this padding to profile
    the operating system used on a device. Additionally, attackers can place small
    bits of data in this field as a method of covert communication.*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*ICMP 回显请求中使用的随机文本可能对潜在攻击者非常有价值。攻击者可以利用此填充中的信息来分析设备使用的操作系统。此外，攻击者还可以将少量数据放入此字段，以便进行隐蔽通信。*'
- en: '***traceroute***'
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***traceroute***'
- en: '*icmp_traceroute.pcapng*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*icmp_traceroute.pcapng*'
- en: The traceroute utility is used to identify the path from one device to another.
    On a simple network, a path may go through only a single router or no router at
    all. On a complex network, however, a packet may need to go through dozens of
    routers to reach its final destination. Thus, it is crucial to be able to trace
    the exact path a packet takes from one destination to another in order to troubleshoot
    communication.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: traceroute 工具用于识别从一个设备到另一个设备的路径。在简单的网络中，一条路径可能仅经过一个路由器，或者根本不经过路由器。然而，在复杂的网络中，一个数据包可能需要经过数十个路由器才能到达最终目的地。因此，能够追踪数据包从一个目的地到另一个目的地的确切路径，对于故障排除通信非常关键。
- en: By using ICMP (with a little help from IP), traceroute can map the path packets
    take. For example, the first packet in the file *icmp_traceroute.pcapng* is pretty
    similar to the echo request we looked at in the previous section (see [Figure
    7-32](ch07.xhtml#ch07fig32)).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: In this capture, the packets were generated by running the command `tracert
    4.2.2.1`. To use traceroute on Windows, enter `tracert ipaddress` at the command
    prompt, replacing ipaddress with the actual IP address of a device whose path
    you want to discover. To use traceroute on Linux or Mac, use the command `traceroute
    ipaddress`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f148-01.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-32: An ICMP echo request packet with a TTL value of 1*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, this packet appears to be a simple echo request ➌ from 192.168.100.138
    to 4.2.2.1 ➊, and everything in the ICMP portion of the packet is identical to
    the formatting of an echo request packet. However, when you expand the IP header
    of this packet, you’ll notice something odd: the packet’s TTL value is set to
    1 ➋, meaning that the packet will be dropped at the first router that it hits.
    Because the destination 4.2.2.1 address is an internet address, we know that there
    must be at least one router between our source and destination devices, so there
    is no way this packet will reach its destination. That’s good for us, because
    traceroute relies on the fact that this packet will make it to only the first
    router it traverses.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The second packet is, as expected, a reply from the first router we reached
    along the path to our destination (see [Figure 7-33](ch07.xhtml#ch07fig33)). This
    packet reached this device at 192.168.100.1, its TTL was decremented to 0, and
    the packet could not be transmitted further, so the router replied with an ICMP
    response. This packet is type 11 ➊ and code 0 ➋, data that tells us that the destination
    was unreachable because the packet’s TTL was exceeded during transit.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: This ICMP packet is sometimes called a *double-headed packet*, because the tail
    end of its ICMP portion contains a copy of the IP header ➌ and ICMP data ➍ that
    were sent in the original echo request. This information can prove very useful
    for troubleshooting.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f149-01.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-33: An ICMP response from the first router along the path*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: This process of sending packets with a TTL value of 1 occurs two more times
    before we get to packet 7\. Here, you see the same thing you saw in the first
    packet, except that this time, the TTL value in the IP header is set to 2, which
    ensures the packet will make it to the second hop router before it is dropped.
    As expected, we receive a reply from the next hop router, 12.180.241.1, with the
    same ICMP destination unreachable and TTL exceeded messages.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: This process continues, with the TTL value increasing by 1, until the destination
    4.2.2.1 is reached. Right before that happens, however, you’ll see in [Figure
    7-34](ch07.xhtml#ch07fig34) that the request on line 8 timed out. How can a request
    along the path time out and the process still complete successfully? Typically,
    this happens when a router is configured to not respond to ICMP requests. The
    router still receives the request and passes the data forward to the next router,
    which is why we’re able to see the next hop on line 9 in [Figure 7-34](ch07.xhtml#ch07fig34).
    It just didn’t generate the ICMP time to live exceeded packet as the other hops
    did. With no response, tracert assumes the request has timed out and moves on
    to the next one.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, this traceroute process has communicated with each router along the
    path, building a map of the route to the destination. An example map is shown
    in [Figure 7-34](ch07.xhtml#ch07fig34).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f150-01.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-34: A sample output from the traceroute utility*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '*The discussion here on traceroute is generally Windows focused because this
    utility uses ICMP exclusively. The traceroute utility on Linux is a bit more versatile
    and can utilize other protocols in order to perform route path tracing.*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '***ICMP Version 6 (ICMPv6)***'
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The updated version of IP relies heavily on ICMP for functions such as neighbor
    solicitation and path discovery, as demonstrated in earlier examples. *ICMPv6*
    was established with RFC 4443 to support the feature set needed for IPv6, along
    with additional enhancements. We don’t cover ICMPv6 separately in this book because
    it uses the same packet structure as do ICMP packets.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'ICMPv6 packets are generally classified as either error messages or informational
    messages. You can find a full list of the available types and codes from IANA
    here: *http://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml*.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has introduced you to a few of the most important protocols you
    will examine during the process of packet analysis. ARP, IP, and ICMP are at the
    foundation of all network communications, and they are critical to just about
    every daily task you will perform. In [Chapter 8](ch08.xhtml#ch08), we will look
    at common transport layer protocols, TCP and UDP.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
