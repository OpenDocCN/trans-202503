- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">B</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    NEXT.JS APP DIRECTORY</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In version 13, Next.js introduced a new routing paradigm that uses an *app*
    directory instead of the *pages* directory. This appendix discusses this new feature
    so that you can explore it further on your own. As there are no plans to deprecate
    the *pages* directory, you can continue using the routing approach you learned
    in [Chapter 5](chapter5.xhtml). You can even use both directories simultaneously;
    just be careful not to add to both directories folders and files that would create
    the same route, as this could cause errors.
  prefs: []
  type: TYPE_NORMAL
- en: Both the *app* and *pages* directories use folders and files to create routes.
    However, the *app* directory distinguishes between server and client components.
    In the *pages* folder, everything is a *client component*, meaning that all the
    code is part of the JavaScript bundle Next.js sends to the client. But every file
    in the *app* directory is a *server component* by default, and its code is never
    sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: This appendix takes a look at the basic concepts of the new approach and then
    initializes a Next.js application using the new structure.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Server Components vs. Client Components</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The terms *client* and *server* in this context refer to the environments in
    which the Next.js runtime renders a component. The client environment is the user’s
    environment (usually the browser), whereas the server refers to the Next.js server
    that receives the request from the client, whether it runs on your local host
    or in a remote location.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of server components, Next.js no longer purely uses client-side
    routing. In *server-centric* routing, the server renders components and then sends
    the rendered code to the client. This means the client doesn’t download a routing
    map, which reduces the initial page size. Additionally, the user doesn’t have
    to wait until all resources have loaded before the page becomes interactive. Next.js
    server components leverage React’s streaming architecture to progressively render
    each component’s content. With this model, the page becomes interactive before
    it has finished loading.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Server Components</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next.js server components build upon the React server components that have been
    available since React version 18\. Because the server renders these components,
    they don’t add anything to the JavaScript sent to the client, reducing the overall
    page size and increasing page performance scores. Also, the JavaScript bundle
    is cacheable, so the client won’t redownload it when we add new additional server
    components, only when we add new client-side scripts through additional client
    components.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, because these components are rendered completely on the server,
    they can contain sensitive server information, such as access tokens and API keys.
    (To add an additional layer of protection, Next.js’s rendering engine replaces
    with an empty string all environment variables that are not explicitly prefixed
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">NEXT_PUBLIC</samp>.) Finally,
    we can use large-scale dependencies and additional frameworks without bloating
    the client-side scripts and access backend resources directly, increasing the
    application’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing B-1](appendix-B.xhtml#LisB-1) shows the basic structure of a server
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-1: A basic server component'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](chapter4.xhtml), you learned that a React component is a JavaScript
    function that returns a React element; Next.js server components follow that same
    structure, except that they’re asynchronous functions, so we can use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    pattern with <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>. Thus,
    instead of returning the React element, it returns a promise of it. The code in
    [Listing B-1](appendix-B.xhtml#LisB-1) should remind you of the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>
    created in the previous chapters, except it doesn’t contain any client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Client Components</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By contrast, a client component is a component rendered by the browser rather
    than by the server. You already know how to write client components, because all
    React and Next.js components were traditionally client components.
  prefs: []
  type: TYPE_NORMAL
- en: To render these components, the client needs to receive all required scripts
    and their dependencies. Each component increases the bundle size, decreasing the
    application’s performance. For that reason, Next.js offers options to optimize
    the application’s performance, such as server-side rendering (SSR), which pre-renders
    the pages on the server, then lets the client add interactive elements to the
    page.
  prefs: []
  type: TYPE_NORMAL
- en: All components in the *app* directory are server components by default. Client
    components, however, can reside anywhere (for example, in the *components* directory
    we’ve used previously). [Listing B-2](appendix-B.xhtml#LisB-2) shows the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp> created in [Listing
    5-4](chapter5.xhtml#Lis5-4) refactored into a client component that works with
    the *app* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-2: A basic client component that is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WeatherComponent</samp>
    created in [Listing 5-4](chapter5.xhtml#Lis5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We export the component as the default function with the name <samp class="SANS_TheSansMonoCd_W5Regular_11">ClientComponent</samp>.
    Because we’re using the client-side hooks <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> as well as the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp> event handler, we
    need to declare the component as a client component with the <samp class="SANS_TheSansMonoCd_W5Regular_11">"use
    client"</samp> directive at the top of the file. Otherwise, Next.js will throw
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Rendering Components</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 5](chapter5.xhtml), we performed server-side rendering with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp> function
    and used static site generation (SSG) with the <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>
    function. In the *app* directory, both functions are obsolete. If we want to optimize
    an application, we can instead use Next.js’s built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API, which controls data retrieval and rendering at the component level.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fetching Data</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The new asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API extends the native fetch web API and returns a promise. Because server components
    are just exported functions that return a JSX element, we can declare them as
    asynchronous functions and then use <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is beneficial because it allows us to fetch data for only the segment
    that uses the data rather than for an entire page. This lets us leverage React
    features to automatically display loading states and gracefully catch errors,
    as discussed in “Exploring the Project Structure” on page 269. If we follow this
    pattern, a loading state will block the rendering of only a particular server
    component and its user interface; the rest of the page will be fully functional
    and interactive.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Client components shouldn’t be asynchronous functions, because the way JavaScript
    handles asynchronous calls can easily lead to multiple re-renders and slow down
    the whole application. Next.js developers have discussed adding a generic use
    hook that lets us use asynchronous functions in client components by caching the
    results, but this hook is not yet finalized. If you absolutely need client-side
    data fetching, I recommend using a specialized library such as SWR, which you
    can find at* [https://<wbr>swr<wbr>.vercel<wbr>.app](https://swr.vercel.app)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: You might worry that, when each server component loads its own data, you’ll
    end up with a massive number of requests. How do these numbers impact the overall
    page performance? Well, Next.js’s <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    comes with multiple optimizations to speed up the application. For example, it
    automatically caches the response data for GET requests sent from a server component
    to the same API, reducing the number of requests.
  prefs: []
  type: TYPE_NORMAL
- en: However, POST requests aren’t usually cacheable, as the data they contain might
    change, so <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> won’t automatically
    cache them. This is a problem for us because GraphQL typically uses POST requests.
    Fortunately, React exposes a <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    function that memorizes the result of the function it wraps. [Listing B-3](appendix-B.xhtml#LisB-3)
    shows an example of using <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    with a GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-3: A simple outline of a cached POST API call'
  prefs: []
  type: TYPE_NORMAL
- en: We wrap the API call in the <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    function we imported from React and return the API’s response object. Note that
    the cached arguments can use only primitive values because the <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    function doesn’t perform a deep comparison for the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Another optimization we can implement is to leverage the asynchronous nature
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> to request data
    for the server component in a parallel fashion instead of sequentially. Here,
    the most common pattern is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp>
    to start all requests at the same time and block the rendering until all requests
    have been completed. [Listing B-4](appendix-B.xhtml#LisB-4) shows us the relevant
    code for this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-4: Two parallel API calls with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Promise.all</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We set up two requests, both of which return a promise user object. Then we
    await the result of both promises and call <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp>
    with an array of the previously created asynchronous API calls. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp>
    function resolves as soon as both promises return their data, and then the server
    component’s code continues.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Rendering</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Static rendering is the default setting for both server and client components.
    It resembles static site generation, which we used with <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>
    in [Chapter 5](chapter5.xhtml). This rendering option pre-renders both client
    and server components in the server environment at build time. As a result, requests
    will always return the same HTML, which remains static and is never re-created.
  prefs: []
  type: TYPE_NORMAL
- en: Each component type is rendered slightly differently. For client components,
    the server pre-renders the HTML and JSON data; the client then receives the pre-rendered
    data, including the client-side script, to add interactivity to the HTML. For
    server components, the browser receives only the rendered payload to hydrate the
    component. They neither have client-side JavaScript nor use JavaScript for hydration;
    hence they do not send any JavaScript to the client and, in turn, don’t bloat
    the bundled scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing B-5](appendix-B.xhtml#LisB-5) shows how to statically render the *utils/fetch-names.ts*
    file from [Listing 5-8](chapter5.xhtml#Lis5-8).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-5: A server component that uses static rendering'
  prefs: []
  type: TYPE_NORMAL
- en: First we define a server component as an asynchronous function that directly
    returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp> wrapped
    in a promise.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](chapter5.xhtml), we returned the page’s data and then used the
    page <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> to pass it the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> function, where
    we generated the element. Here, after setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">url</samp>,
    we use the asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    function to get the data from the remote API. Next.js will cache the results of
    the API call and the rendered component, and the server will reuse the generated
    code and never re-create it.
  prefs: []
  type: TYPE_NORMAL
- en: If you use <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> without
    an explicit cache setting, it will use <samp class="SANS_TheSansMonoCd_W5Regular_11">force-cache</samp>
    as the default to perform static rendering. To switch to incremental static regeneration
    instead, replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    call from [Listing B-5](appendix-B.xhtml#LisB-5) with the one in [Listing B-6](appendix-B.xhtml#LisB-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-6: The modified <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fetch</samp>
    call for ISR-like rendering'
  prefs: []
  type: TYPE_NORMAL
- en: We simply add the <samp class="SANS_TheSansMonoCd_W5Regular_11">revalidate</samp>
    property with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">30</samp>.
    The server will then render the component statically but invalidate the current
    HTML 30 seconds after the first page request and re-render it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic Rendering</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Dynamic rendering replaces Next.js’s traditional server-side rendering (SSR),
    which we used by exporting the <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>
    function from a page route in [Chapter 5](chapter5.xhtml). Because Next.js uses
    static rendering by default, we must actively opt in to using dynamic rendering
    in one of two ways: by disabling the cache in our fetch requests or by using a
    dynamic function. In [Listing B-7](appendix-B.xhtml#LisB-7), we disable the cache.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-7: A server component that uses dynamic rendering by disabling the
    cache'
  prefs: []
  type: TYPE_NORMAL
- en: We explicitly set the <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    property to <samp class="SANS_TheSansMonoCd_W5Regular_11">no-cache</samp>. Now
    the server will re-fetch the data for the component upon each request.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of disabling the cache, we could use dynamic functions, including the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">header</samp> function or the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cookies</samp> function in server components
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSearchParams</samp> hook
    in client components. These functions use dynamic data such as request headers,
    cookies, and search parameters that are unknown during build time and are part
    of the request object we pass to the function. The server needs to run these functions
    for each request because the required data depends on the request.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that dynamic rendering affects the whole route. If one server component
    in a route opts for dynamic rendering, Next.js will render the whole route dynamically
    at request time.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Exploring the Project Structure</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s set up a new Next.js application to explore the features we’ve discussed.
    First, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">npx create-next-app@latest</samp>
    command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--typescript --use-npm</samp>
    flags to create a sample application. When answering the setup wizard’s questions,
    choose to use the *app* directory instead of the *pages* directory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can also use the online playground at* [https://<wbr>codesandbox<wbr>.io<wbr>/s<wbr>/](https://codesandbox.io/s/)
    *to run the Next.js code examples in this appendix. Search for the official* Next.js
    (App router) *template when creating a new code sandbox there.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now enter the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">npm run dev</samp>
    command to start the application in development mode. You should see a Next.js
    welcome screen in your browser at *http://localhost:3000*. Unlike the welcome
    screen you saw in [Chapter 5](chapter5.xhtml), which encouraged us to edit the
    *pages/index.tsx* file, here the welcome screen directs us to the *app/page.tsx*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the files and folders the wizard created and compare them with
    the ones from [Chapter 5](chapter5.xhtml). You should see that the *pages* and
    *styles* directories are not part of the new structure. Instead, the router replaces
    both with the *app* directory. Inside it, you should see neither the *_app.tsx*
    file nor the *_document.tsx* file. Instead, it uses the root layout file *layout.tsx*
    to define the HTML wrapper for all rendered pages and the *page.tsx* file to render
    the root segment (the home page).
  prefs: []
  type: TYPE_NORMAL
- en: The *pages* directory uses only one file to create the final content of the
    page route. By contrast, the *app* directory uses multiple files to create a page
    route and add additional behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The *page.tsx* file generates the user interface and the content for the route,
    and its parent folder defines the leaf segment. Without a *page.tsx* file, the
    URL path won’t be accessible. We can then add other special files to the page’s
    folder. Next.js will automatically apply them to this URL segment and its children.
    The most important of these special files are *layout.tsx*, which creates a general
    user interface; *loading.tsx*, which uses a React suspense boundary to automatically
    create a “loading” user interface while the page loads; and *error.tsx*, which
    uses a React error boundary to catch errors and then show the user a custom error
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure B-1](appendix-B.xhtml#figB-1) compares the files and folders for the
    *components/weather* page route when using the *pages* directory and the *app*
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureB-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-1: Comparing the
    page route</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">in the pages and app directory
    structures</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When the *app* directory is the root folder, its subfolders still correspond
    to URL segments, but now the folder that contains the *page.tsx* file defines
    the URL’s final leaf segment. The optional special files next to it affect only
    the contents of the *components/weather* page.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s rebuild the *components/weather* page route you created in [Listing 5-1](chapter5.xhtml#Lis5-1)
    with the *app* directory. Create the *components* folder and *weather* subfolder
    inside the *app* directory and then copy the *custom.d.ts* file from the previous
    code exercises into the root folder.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating the CSS</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Begin by opening the existing *app/globals.css* file and replacing its content
    with the code from [Listing B-8](appendix-B.xhtml#LisB-8). We’ll need to make
    some modifications to use special files in our component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-8: The app/globals.css file with basic styles for our code examples'
  prefs: []
  type: TYPE_NORMAL
- en: We create one <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp> element
    for the navigation with a <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    content area below it. Then we add styles for the loading and error states we’ll
    create later. In addition, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">section</samp>
    element to outline the boundaries of the files and <samp class="SANS_TheSansMonoCd_W5Regular_11">flag</samp>
    styles to add labels to the sections.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining a Layout</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Layouts are server components that define the user interface for a particular
    route segment. Next.js renders this layout when this segment is active. Layouts
    are shared across all pages, so they can be nested into each other, and all layouts
    for a specific route and its children will be rendered when this route segment
    is active. [Figure B-2](appendix-B.xhtml#figB-2) shows the relationship between
    the URL, the files, and the component hierarchy for the *components/weather* route.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureB-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-2: The simplified
    layout component hierarchy</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, each folder contains a *layout.tsx* file. Next.js will render
    these in a nested fashion and make the page’s content the final rendered component.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can fetch data in a layout, we can’t share data between a parent
    layout and its children. Instead, we can leverage the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API’s automatic deduplication to reuse data in each child segment or component.
    When we navigate from one page to another, only the layouts that change are re-rendered.
    Shared layouts won’t be re-rendered when their child segments change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The root layout, which returns the skeleton structure with the <samp class="SANS_TheSansMonoCd_W5Regular_11">html</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp> elements for the
    page, is required, while all other layouts we create are optional. Let’s create
    a root layout. First, add a new interface to the end of the *custom.d.ts* file,
    which we copied from the previous exercise. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>
    interface to type the layout’s properties object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now open the *app/layout.tsx* file and replace its content with the code from
    [Listing B-9](appendix-B.xhtml#LisB-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-9: The file app/layout.tsx defines the root layout.'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *global.css* file that we created earlier and then define the
    default SEO metadata, the page title, and the page description through the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp> object. This replaces
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp> component we
    used in the *pages* directory for all pages in the *app* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Then we define the <samp class="SANS_TheSansMonoCd_W5Regular_11">RootLayout</samp>
    component, which accepts an object of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>
    type and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>.
    We also create the <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>,
    explicitly adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">html</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp> elements, then use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">section</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">span</samp>
    with the CSS class <samp class="SANS_TheSansMonoCd_W5Regular_11">flag</samp> to
    outline the page structure. We add the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    property from the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>
    object to wrap them with our root HTML structure.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s add optional layouts to the *app/components* and *app/components/weather*
    folders. Create a *layout.tsx* file in each and then place the code from [Listing
    B-10](appendix-B.xhtml#LisB-10) to the *app/components/layout.tsx* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-10: The file app/components/layout.tsx defines the segment layout.'
  prefs: []
  type: TYPE_NORMAL
- en: This segment layout file follows the same basic structure as the root layout.
    We define a layout component that receives the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>
    object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    property and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>.
    Unlike in the root layout, we set only the inner structure, the <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp>
    element with the navigation placeholder, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    content area where we render the child elements from the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>
    object, representing this segment’s child content (the leaf).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, create the leaf’s layout by adding the code from [Listing B-11](appendix-B.xhtml#LisB-11)
    to the *app/components/weather/layout.tsx* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-11: The file app/components/weather/layout.tsx defines the leaf layout.'
  prefs: []
  type: TYPE_NORMAL
- en: The leaf’s layout resembles the segment layout from [Listing B-10](appendix-B.xhtml#LisB-10),
    but it returns a more straightforward HTML structure, as the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    property does not contain another layout; instead, it contains the page’s content
    (in *page.tsx*), and the suspense boundary and error boundary from *loading.tsx*
    and *error.tsx*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Content
    and Route</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To expose the page route, we need to create the *page.tsx* file; otherwise,
    if we tried to visit the *components/weather* page route at *http://localhost:3000/components/weather*,
    we’d see Next.js’s default *404* error page. To re-create the page content from
    [Listing 5-1](chapter5.xhtml#Lis5-1), we’ll create two files. One is *component
    .tsx*, which contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>,
    and the other is *page.tsx*, which resembles the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    wrapper we used in [Listing 5-1](chapter5.xhtml#Lis5-1). Of course, pages could
    contain additional components located in other folders.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating the *component.tsx* file inside the *apps/components/weather*
    folder and adding the code from [Listing B-12](appendix-B.xhtml#LisB-12) into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-12: The file app/components/weather/component.tsx defines the <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WeatherComponent</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is similar to the code in [Listing 5-1](chapter5.xhtml#Lis5-1) for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp> constant,
    except we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">"use client"</samp>
    statement to explicitly set it as a client component and export it as the default
    function instead of storing it in a constant. The component itself has the same
    functionality as before: we create a headline that shows the weather string and
    a counter we can increase by clicking the headline.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we add the *page.tsx* file and the code from [Listing B-13](appendix-B.xhtml#LisB-13)
    to create the page route and expose the route to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-13: The file app/components/weather/page.tsx defines the page route.'
  prefs: []
  type: TYPE_NORMAL
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>
    we just created and then set the SEO metadata on the page level. Then we export
    the page route as the default async function. When we compare it to [Listing 5-1](chapter5.xhtml#Lis5-1),
    which contains a similar page, we see that we no longer need to export a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>; instead, we use a basic
    function. The *app* directory simplifies the structure of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now visit our *components/weather* page route at *http://localhost:3000/components/weather*
    in the browser. You should see a page that looks similar to [Figure B-3](appendix-B.xhtml#figB-3).
  prefs: []
  type: TYPE_NORMAL
- en: Notice two things here. First, you should recognize the component from [Chapter
    5](chapter5.xhtml), whose counter increases when we click the headline. In addition,
    the combination of the styles and the <samp class="SANS_TheSansMonoCd_W5Regular_11">span</samp>
    elements we added to each *.tsx* file visualizes the relations between the files.
    We see that the nested layout files resemble the simplified component hierarchy
    from [Figure B-3](appendix-B.xhtml#figB-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureB-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-3: The</samp> <samp
    class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page
    showing the nested components</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Catching Errors</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As soon as we add an *error.tsx* file to the folder, Next.js wraps our page’s
    content with a React error boundary. [Figure B-4](appendix-B.xhtml#figB-4) shows
    the simplified component hierarchy of the *components/weather* route with an added
    *error.tsx* file.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureB-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-4: The simplified
    layout component hierarchy includes the error boundary.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We see that the *error.tsx* file automatically creates an error boundary around
    the page’s content. By doing so, Next.js enables us to catch errors on a page
    level and gracefully handle those instead of freezing the whole user interface
    or redirecting the user to a generic error page. Think about it as a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp>
    block on a component level. We can now show a tailored error message and display
    a button that lets the user re-render the page content in a previously working
    state without reloading the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: The *error.tsx* file exports a client component that the error boundary uses
    as the fallback interface. In other words, this component replaces the content
    when the code throws an error and activates the error boundary. As soon as it
    is active, it contains the error, ensuring that the layouts above the boundary
    remain active and maintain their internal state. The error component receives
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">error</samp> object and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">reset</samp> function as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add an error boundary to the *components/weather* route. Start by adding
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">ErrorProps</samp> interface
    to type the component’s properties into the *customs.d.ts* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, create the *error.tsx* file next to *page.tsx* in the *app/components/weather*
    directory and add the code from [Listing B-14](appendix-B.xhtml#LisB-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-14: The file app/components/weather/error.tsx adds the error boundary
    and the fallback UI.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we know that the error component needs to be a client component, we
    add the <samp class="SANS_TheSansMonoCd_W5Regular_11">"use client"</samp> directive
    to the top of the file and then define and export the component. We use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ErrorProps</samp> interface we just created
    to type the component’s properties. We then convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">error</samp>
    property to a string and display it to inform the user of the type of error that
    occurred. Finally, we render a button that calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">reset</samp>
    function that the component received through the properties object. The user can
    re-render the component into a previous working state by clicking the button.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the error boundary in place, we’ll modify *component.tsx* to throw
    an error if the counter hits 4 or more. Open the file and add the code from [Listing
    B-15](appendix-B.xhtml#LisB-15) below the first <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-15: The additional <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">useEffect</samp>
    hook for app/components/weather/component.tsx'
  prefs: []
  type: TYPE_NORMAL
- en: The additional <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook we add to the component is straightforward; as soon as the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    variable changes, we verify the error condition, and as soon as the variable’s
    value is 4 or more, we throw an error with the message <samp class="SANS_TheSansMonoCd_W5Regular_11">Count</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4!</samp>,
    which the error boundary catches and gracefully handles by showing the fallback
    user interface that the *error.tsx* file exports.
  prefs: []
  type: TYPE_NORMAL
- en: To test this feature, open *http://localhost:3000/components/weather* in the
    browser and click the headline until you trigger the error. You should see the
    error component instead of the weather component, as in [Figure B-5](appendix-B.xhtml#figB-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureB-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-5: The</samp> <samp
    class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page
    in the error state</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout markers show us that *error.tsx* has replaced *page.tsx*. We also
    see the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Error: Count</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">>=4!</samp>, which we passed to
    the error constructor. As soon as we click the re-render button, *page.tsx* should
    replace *error.tsx*, and the screen will look like [Figure B-4](appendix-B.xhtml#figB-4)
    previously.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Showing an Optional
    Loading Interface</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll create the *loading.tsx* file. With this feature in place, Next.js
    automatically wraps the page content with a React suspense component, creating
    a component hierarchy that looks similar to [Figure B-6](appendix-B.xhtml#figB-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureB-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-6: The simplified
    layout component hierarchy with the loading interface</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The *loading.tsx* file is a basic server component that returns the pre-rendered
    loading user interface. When we load a page or navigate between pages, Next.js
    will instantly display this component while loading the new segment’s content.
    Once rendering is complete, the runtime will swap the loading state with the new
    content. In this way, we can easily display meaningful loading states, such as
    skeletons or custom animations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a basic loading user interface to the weather component route by adding
    the code from [Listing B-16](appendix-B.xhtml#LisB-16) to the *loading.tsx* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-16: The file app/components/weather/loading.tsx adds a suspense boundary
    with the loading user interface.'
  prefs: []
  type: TYPE_NORMAL
- en: We define and export the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLoading</samp>
    component, which returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>.
    In the HTML, we add a headline element similar to the one in *page.tsx*, except
    this one adds the loading class we created in the *global.css* file to the headline
    and shows an animated placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: When we open *http://localhost:3000/components/weather* in the browser, we should
    see a loading interface similar to [Figure B-7](appendix-B.xhtml#figB-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureB-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-7: The</samp> <samp
    class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page
    while loading the page’s content</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the animated placeholder, this means Next.js has already cached
    your segment’s content.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding a Server Component
    That Fetches Remote Data</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you understand the folders and files in the *app* directory, let’s
    add a server component that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API to receive the list of users from the remote API *https://www.usemodernfullstack.dev/api/v1/users*
    and renders it to the browser. We wrote a version of this code in [Chapter 5](chapter5.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Create the folder *app/components/server-component* and add the special files
    *component.tsx*, *loading.tsx*, *error.tsx*, *layout.tsx*, and *page.tsx* to it.
    Then set up the component’s functionality by adding the code from [Listing B-17](appendix-B.xhtml#LisB-17)
    to the *component.tsx* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-17: The app/components/server-component/component.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: Here we create a default server component that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API to <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> the API response.
    To be able to do so, we define it as an asynchronous function that returns a promise
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp> or an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Error</samp>. Then we store the API endpoint
    in a constant and define the variables we’ll need later on. We wrap the API call
    in a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> statement
    to activate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Error Boundary</samp>
    if the API request fails. We then transform the data in a manner similarly to
    the way we did in [Chapter 5](chapter5.xhtml) and return a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>
    that displays a list of users.
  prefs: []
  type: TYPE_NORMAL
- en: Now we add the loading user interface that Next.js automatically displays while
    we await the API’s response and the component’s JSX response. Place the code from
    [Listing B-18](appendix-B.xhtml#LisB-18) into the *loading.tsx* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-18: The app/components/server-component/loading.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: As before, the loading component is a server component that returns a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>. This time, the loading
    skeleton is a list with 10 items resembling the component’s rendered HTML structure.
    You’ll see that this gives the user a good impression of the expected content
    and should improve the user’s experience.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the error boundary by adding the code from [Listing B-19](appendix-B.xhtml#LisB-19)
    to the *error.tsx* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-19: The app/components/server-component/error.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: Except for the flag outlining the file structure, the error boundary is similar
    to the one we used in the weather component.
  prefs: []
  type: TYPE_NORMAL
- en: Then we add the code from [Listing B-20](appendix-B.xhtml#LisB-20) to the *layout.tsx*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-20: The app/components/server-component/layout.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: Again, the code is similar to the code we used for the weather component. We
    adjust only the flag outlining the component hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with all the parts in place, we add the code from [Listing B-21](appendix-B.xhtml#LisB-21)
    to the *page.tsx* file to expose the page route.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-21: The app/components/server-component/page.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Completing the Application
    with the Navigation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With two pages in the application, we can now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>
    component to replace the navigation placeholder in the <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp>
    element. This should create a fully functional application prototype that lets
    us navigate between the pages. Open the *app/components/layout.tsx* file and replace
    the code in the file with the code from [Listing B-22](appendix-B.xhtml#LisB-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-22: The updated app/components/layout.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>
    component and then add two links to our navigation, one pointing to the user list
    server component we just created and the other pointing to the weather client
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s visit the application’s weather component page at *http://localhost:3000/components/weather*.
    You should see an application that looks similar to the screenshot in [Figure
    B-8](appendix-B.xhtml#figB-8).
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you navigate between the pages, you should see the loading user interface.
    With the outlines we’ve added to all the files, we easily keep track of which
    files Next.js uses to render the current page.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureB-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-8: The</samp> <samp
    class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page
    with the functional navigation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing API Routes
    with Route Handlers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you look at the folder structure Next.js created for you, you should see
    that the *app* directory contains an *api* subfolder. You probably already guessed
    that we use this folder to define APIs. But unlike the API routes discussed in
    [Chapter 5](chapter5.xhtml), which were regular functions, the *app* directory
    uses *route handlers*, which are functions that require a particular naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: These route handlers belong in special files named *route.ts* that usually reside
    in a subfolder of the *app/api* folder. They are asynchronous functions that receive
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Request</samp> object and an optional
    context object as parameters. We name each function after the HTTP method it should
    react to. For example, the code in [Listing B-23](appendix-B.xhtml#LisB-23) shows
    how to define route handlers that handle GET and POST requests for the same API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-23: A skeleton structure of a route.ts file defining route handlers'
  prefs: []
  type: TYPE_NORMAL
- en: To create the route handlers, we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp> objects
    from Next.js’s server package. Next.js adds additional convenience methods for
    cookie handling, redirects, and rewrites. You can read more about them in the
    official documentation at [*https://<wbr>nextjs<wbr>.org*](https://nextjs.org).
  prefs: []
  type: TYPE_NORMAL
- en: We then define two asynchronous functions, both of which receive a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp>
    and return a promise of a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp>.
    The function names correspond to the HTTP method they should respond to. Next.js
    supports using the GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS methods as
    function names.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining page routes and route handlers, remember that these files take
    over all requests for a given segment. This means that a *route.ts* file cannot
    be in the same folder as a *page.tsx* file. Also, route handlers are the only
    way to define APIs if you use the *app* directory: you can’t have an *api* folder
    in both the *pages* directory and *app* directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Next.js has statically and dynamically evaluated route handlers. Statically
    evaluated route handlers will be cached and reused for every request, whereas
    dynamically evaluated route handlers must request the data upon each request.
    By default, the runtime statically evaluates all GET route handlers that don’t
    use a dynamic function or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp>
    object. As soon as we use a different HTTP method, the dynamic <samp class="SANS_TheSansMonoCd_W5Regular_11">cookies</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">headers</samp> function, or the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp> object, the route
    handler becomes dynamically evaluated. The same applies to APIs with dynamic segments,
    which receive the dynamic parameters through the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s re-create the API route *api/v1/weather/[zipcode].ts* from [Listing 5-1](chapter5.xhtml#Lis5-1)
    as a route handler that we can use in the *app* directory. Add the code from [Listing
    B-24](appendix-B.xhtml#LisB-24) to a *route.ts* file in the folder structure *app/api/v1/weather/[zipcode]*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing B-24: The route handler in app/api/v1/weather/[zipcode]/route.ts'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’ve used the square brackets pattern on the folder structure to
    access the dynamic segment through the function’s second parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Within the file, we import the Next.js <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp> objects from
    the server package and then define the interfaces for the route handler. On the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestContext</samp> interface,
    we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> property
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp>, representing the
    API’s dynamic segment. Finally, we export the asynchronous GET function, the API
    route handler that reacts to all GET requests for this API endpoint. It receives
    the request object and the request context as parameters and uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp>’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> function to return the
    response data. We access the URL parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> object’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> object and then add
    it to the response data. We set additional response options through the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">json</samp> function’s second parameter,
    explicitly setting the HTTP status code to *200*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try querying the API with <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should receive this JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is the same response received in [Chapter 5](chapter5.xhtml), where we
    accessed the API through the browser.
  prefs: []
  type: TYPE_NORMAL
