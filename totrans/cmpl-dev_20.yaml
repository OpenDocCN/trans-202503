- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">B</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    NEXT.JS APP DIRECTORY</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">B</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NEXT.JS
    应用目录</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: In version 13, Next.js introduced a new routing paradigm that uses an *app*
    directory instead of the *pages* directory. This appendix discusses this new feature
    so that you can explore it further on your own. As there are no plans to deprecate
    the *pages* directory, you can continue using the routing approach you learned
    in [Chapter 5](chapter5.xhtml). You can even use both directories simultaneously;
    just be careful not to add to both directories folders and files that would create
    the same route, as this could cause errors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 13 版中，Next.js 引入了一种新的路由范式，使用 *app* 目录替代 *pages* 目录。本附录讨论了这一新特性，以便您能进一步探索。由于没有计划废弃
    *pages* 目录，您仍然可以继续使用在[第 5 章](chapter5.xhtml)中学习的路由方法。您甚至可以同时使用这两个目录；只需小心不要在两个目录中添加相同路由的文件夹和文件，因为这可能会导致错误。
- en: Both the *app* and *pages* directories use folders and files to create routes.
    However, the *app* directory distinguishes between server and client components.
    In the *pages* folder, everything is a *client component*, meaning that all the
    code is part of the JavaScript bundle Next.js sends to the client. But every file
    in the *app* directory is a *server component* by default, and its code is never
    sent to the client.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*app* 目录和 *pages* 目录都使用文件夹和文件来创建路由。然而，*app* 目录区分了服务器组件和客户端组件。在 *pages* 文件夹中，一切都是
    *客户端组件*，这意味着所有代码都是 Next.js 发送给客户端的 JavaScript 包的一部分。但是，*app* 目录中的每个文件默认都是 *服务器组件*，其代码从未发送到客户端。'
- en: This appendix takes a look at the basic concepts of the new approach and then
    initializes a Next.js application using the new structure.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录将介绍新方法的基本概念，然后使用新结构初始化一个 Next.js 应用程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Server Components vs. Client Components</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">服务器组件与客户端组件</samp>
- en: The terms *client* and *server* in this context refer to the environments in
    which the Next.js runtime renders a component. The client environment is the user’s
    environment (usually the browser), whereas the server refers to the Next.js server
    that receives the request from the client, whether it runs on your local host
    or in a remote location.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，*客户端*和*服务器*这两个术语指的是 Next.js 运行时渲染组件的环境。客户端环境是用户的环境（通常是浏览器），而服务器则指 Next.js
    服务器，它接收来自客户端的请求，无论它是在本地主机上运行还是在远程位置。
- en: With the introduction of server components, Next.js no longer purely uses client-side
    routing. In *server-centric* routing, the server renders components and then sends
    the rendered code to the client. This means the client doesn’t download a routing
    map, which reduces the initial page size. Additionally, the user doesn’t have
    to wait until all resources have loaded before the page becomes interactive. Next.js
    server components leverage React’s streaming architecture to progressively render
    each component’s content. With this model, the page becomes interactive before
    it has finished loading.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着服务器组件的引入，Next.js 不再纯粹使用客户端路由。在 *以服务器为中心* 的路由中，服务器渲染组件并将渲染后的代码发送给客户端。这意味着客户端不需要下载路由映射，从而减少了初始页面大小。此外，用户不必等到所有资源加载完毕后才可以与页面互动。Next.js
    服务器组件利用 React 的流式架构，逐步渲染每个组件的内容。在这种模式下，页面在加载完成之前就变得可互动。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Server Components</samp>
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">服务器组件</samp>
- en: Next.js server components build upon the React server components that have been
    available since React version 18\. Because the server renders these components,
    they don’t add anything to the JavaScript sent to the client, reducing the overall
    page size and increasing page performance scores. Also, the JavaScript bundle
    is cacheable, so the client won’t redownload it when we add new additional server
    components, only when we add new client-side scripts through additional client
    components.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 服务器组件基于自 React 18 版本以来提供的 React 服务器组件。由于这些组件由服务器渲染，它们不会向客户端添加任何 JavaScript，从而减少了整体页面大小并提高了页面性能分数。此外，JavaScript
    包是可缓存的，因此客户端不会在我们添加新的额外服务器组件时重新下载它，而只有在我们通过额外的客户端组件添加新的客户端脚本时，才会重新下载。
- en: In addition, because these components are rendered completely on the server,
    they can contain sensitive server information, such as access tokens and API keys.
    (To add an additional layer of protection, Next.js’s rendering engine replaces
    with an empty string all environment variables that are not explicitly prefixed
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">NEXT_PUBLIC</samp>.) Finally,
    we can use large-scale dependencies and additional frameworks without bloating
    the client-side scripts and access backend resources directly, increasing the
    application’s performance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这些组件完全在服务器上渲染，它们可以包含敏感的服务器信息，如访问令牌和 API 密钥。（为了增加额外的保护层，Next.js 的渲染引擎将所有未显式以
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NEXT_PUBLIC</samp> 前缀的环境变量替换为空字符串。）最后，我们可以使用大规模的依赖项和额外的框架，而不会使客户端脚本臃肿，并可以直接访问后端资源，从而提高应用程序的性能。
- en: '[Listing B-1](appendix-B.xhtml#LisB-1) shows the basic structure of a server
    component.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 B-1](appendix-B.xhtml#LisB-1)展示了一个服务器组件的基本结构。'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing B-1: A basic server component'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-1：一个基本的服务器组件
- en: In [Chapter 4](chapter4.xhtml), you learned that a React component is a JavaScript
    function that returns a React element; Next.js server components follow that same
    structure, except that they’re asynchronous functions, so we can use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    pattern with <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>. Thus,
    instead of returning the React element, it returns a promise of it. The code in
    [Listing B-1](appendix-B.xhtml#LisB-1) should remind you of the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>
    created in the previous chapters, except it doesn’t contain any client-side code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](chapter4.xhtml)中，你学到 React 组件是一个返回 React 元素的 JavaScript 函数；Next.js
    服务器组件遵循相同的结构，不同之处在于它们是异步函数，因此我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp> 模式与 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>。因此，它返回的不是
    React 元素，而是该元素的一个 Promise。 [列表 B-1](appendix-B.xhtml#LisB-1) 中的代码应该让你想起前面章节中创建的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>，不过它不包含任何客户端代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Client Components</samp>
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">客户端组件</samp>
- en: By contrast, a client component is a component rendered by the browser rather
    than by the server. You already know how to write client components, because all
    React and Next.js components were traditionally client components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，客户端组件是由浏览器而非服务器渲染的组件。你已经知道如何编写客户端组件，因为所有 React 和 Next.js 组件传统上都是客户端组件。
- en: To render these components, the client needs to receive all required scripts
    and their dependencies. Each component increases the bundle size, decreasing the
    application’s performance. For that reason, Next.js offers options to optimize
    the application’s performance, such as server-side rendering (SSR), which pre-renders
    the pages on the server, then lets the client add interactive elements to the
    page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染这些组件，客户端需要接收所有必需的脚本及其依赖项。每个组件都会增加打包文件的大小，从而降低应用程序的性能。为此，Next.js 提供了优化应用性能的选项，如服务器端渲染（SSR），它在服务器上预渲染页面，然后让客户端为页面添加交互元素。
- en: All components in the *app* directory are server components by default. Client
    components, however, can reside anywhere (for example, in the *components* directory
    we’ve used previously). [Listing B-2](appendix-B.xhtml#LisB-2) shows the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp> created in [Listing
    5-4](chapter5.xhtml#Lis5-4) refactored into a client component that works with
    the *app* directory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*app* 目录中的所有组件默认为服务器组件。然而，客户端组件可以存在于任何地方（例如，我们之前使用的 *components* 目录中）。[列表 B-2](appendix-B.xhtml#LisB-2)
    展示了 [列表 5-4](chapter5.xhtml#Lis5-4) 中创建的 <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>，它被重构为一个可以与
    *app* 目录一起使用的客户端组件。'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing B-2: A basic client component that is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WeatherComponent</samp>
    created in [Listing 5-4](chapter5.xhtml#Lis5-4)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-2：一个基本的客户端组件，类似于在 [列表 5-4](chapter5.xhtml#Lis5-4) 中创建的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WeatherComponent</samp>
- en: We export the component as the default function with the name <samp class="SANS_TheSansMonoCd_W5Regular_11">ClientComponent</samp>.
    Because we’re using the client-side hooks <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> as well as the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp> event handler, we
    need to declare the component as a client component with the <samp class="SANS_TheSansMonoCd_W5Regular_11">"use
    client"</samp> directive at the top of the file. Otherwise, Next.js will throw
    an error.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组件作为默认函数导出，名称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ClientComponent</samp>。因为我们使用了客户端钩子
    <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>，以及
    <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp> 事件处理器，我们需要在文件顶部用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"use client"</samp> 指令声明该组件为客户端组件。否则，Next.js
    会抛出错误。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Rendering Components</samp>
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">渲染组件</samp>
- en: In [Chapter 5](chapter5.xhtml), we performed server-side rendering with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp> function
    and used static site generation (SSG) with the <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>
    function. In the *app* directory, both functions are obsolete. If we want to optimize
    an application, we can instead use Next.js’s built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API, which controls data retrieval and rendering at the component level.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](chapter5.xhtml)中，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>
    函数进行了服务器端渲染，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>
    函数进行了静态站点生成（SSG）。在 *app* 目录中，这两个函数已被废弃。如果我们希望优化应用程序，可以改为使用 Next.js 内置的 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API，它在组件级别控制数据获取和渲染。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fetching Data</samp>
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">获取数据</samp>
- en: The new asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API extends the native fetch web API and returns a promise. Because server components
    are just exported functions that return a JSX element, we can declare them as
    asynchronous functions and then use <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    pattern.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 新的异步 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API 扩展了原生的 fetch
    网络 API，并返回一个 promise。由于服务器组件只是导出的返回 JSX 元素的函数，我们可以将其声明为异步函数，然后使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    配合 <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    模式。
- en: This pattern is beneficial because it allows us to fetch data for only the segment
    that uses the data rather than for an entire page. This lets us leverage React
    features to automatically display loading states and gracefully catch errors,
    as discussed in “Exploring the Project Structure” on page 269. If we follow this
    pattern, a loading state will block the rendering of only a particular server
    component and its user interface; the rest of the page will be fully functional
    and interactive.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式很有优势，因为它允许我们仅为使用数据的部分获取数据，而不是为整个页面获取数据。这使我们能够利用 React 的特性，自动显示加载状态并优雅地捕获错误，正如在第
    269 页的“探索项目结构”中讨论的那样。如果我们遵循这种模式，加载状态只会阻止特定服务器组件及其用户界面的渲染；页面的其余部分将完全功能化并可交互。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Client components shouldn’t be asynchronous functions, because the way JavaScript
    handles asynchronous calls can easily lead to multiple re-renders and slow down
    the whole application. Next.js developers have discussed adding a generic use
    hook that lets us use asynchronous functions in client components by caching the
    results, but this hook is not yet finalized. If you absolutely need client-side
    data fetching, I recommend using a specialized library such as SWR, which you
    can find at* [https://<wbr>swr<wbr>.vercel<wbr>.app](https://swr.vercel.app)*.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*客户端组件不应为异步函数，因为 JavaScript 处理异步调用的方式可能会导致多次重新渲染，从而减慢整个应用程序的速度。Next.js 开发者曾讨论过添加一个通用的钩子，使我们能够通过缓存结果在客户端组件中使用异步函数，但这个钩子尚未最终确定。如果您绝对需要客户端数据获取，建议使用像
    SWR 这样的专用库，您可以在* [https://<wbr>swr<wbr>.vercel<wbr>.app](https://swr.vercel.app)*
    找到。*'
- en: You might worry that, when each server component loads its own data, you’ll
    end up with a massive number of requests. How do these numbers impact the overall
    page performance? Well, Next.js’s <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    comes with multiple optimizations to speed up the application. For example, it
    automatically caches the response data for GET requests sent from a server component
    to the same API, reducing the number of requests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会担心，当每个服务器组件加载自己的数据时，最终会产生大量的请求。那么，这些请求的数量会如何影响整体页面性能呢？其实，Next.js 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> 提供了多项优化，帮助加速应用程序。例如，它会自动缓存从服务器组件发送到同一
    API 的 GET 请求的响应数据，从而减少请求的数量。
- en: However, POST requests aren’t usually cacheable, as the data they contain might
    change, so <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> won’t automatically
    cache them. This is a problem for us because GraphQL typically uses POST requests.
    Fortunately, React exposes a <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    function that memorizes the result of the function it wraps. [Listing B-3](appendix-B.xhtml#LisB-3)
    shows an example of using <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    with a GraphQL API.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，POST 请求通常是不可缓存的，因为它们包含的数据可能会发生变化，因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    不会自动缓存这些请求。这对我们来说是一个问题，因为 GraphQL 通常使用 POST 请求。幸运的是，React 提供了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    函数，可以记住它所包装的函数的结果。[列表 B-3](appendix-B.xhtml#LisB-3) 展示了如何使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    与 GraphQL API 的示例。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing B-3: A simple outline of a cached POST API call'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-3：一个简单的缓存 POST API 调用大纲
- en: We wrap the API call in the <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    function we imported from React and return the API’s response object. Note that
    the cached arguments can use only primitive values because the <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    function doesn’t perform a deep comparison for the arguments.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 API 调用包装在从 React 导入的 <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    函数中，并返回 API 的响应对象。需要注意的是，缓存的参数只能使用原始值，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    函数不会对参数进行深度比较。
- en: Another optimization we can implement is to leverage the asynchronous nature
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> to request data
    for the server component in a parallel fashion instead of sequentially. Here,
    the most common pattern is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp>
    to start all requests at the same time and block the rendering until all requests
    have been completed. [Listing B-4](appendix-B.xhtml#LisB-4) shows us the relevant
    code for this pattern.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现的另一个优化是利用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> 的异步特性，以并行的方式请求服务器组件的数据，而不是按顺序请求。这里，最常见的模式是使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp> 同时启动所有请求，并阻塞渲染，直到所有请求完成。[列表
    B-4](appendix-B.xhtml#LisB-4) 展示了这种模式的相关代码。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing B-4: Two parallel API calls with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Promise.all</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-4：使用 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Promise.all</samp>
    的两个并行 API 调用
- en: We set up two requests, both of which return a promise user object. Then we
    await the result of both promises and call <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp>
    with an array of the previously created asynchronous API calls. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp>
    function resolves as soon as both promises return their data, and then the server
    component’s code continues.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了两个请求，它们都返回一个 promise 用户对象。然后我们等待这两个 promise 的结果，并使用一个包含先前创建的异步 API 调用的数组来调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp>。当两个 promise 返回数据时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Promise.all</samp> 函数会解析，然后服务器组件的代码继续执行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Rendering</samp>
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">静态渲染</samp>
- en: Static rendering is the default setting for both server and client components.
    It resembles static site generation, which we used with <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>
    in [Chapter 5](chapter5.xhtml). This rendering option pre-renders both client
    and server components in the server environment at build time. As a result, requests
    will always return the same HTML, which remains static and is never re-created.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 静态渲染是服务器和客户端组件的默认设置。它类似于静态网站生成，我们在[第 5 章](chapter5.xhtml)中使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>。此渲染选项在构建时预渲染服务器环境中的客户端和服务器组件。因此，请求将始终返回相同的
    HTML，该 HTML 保持静态且永远不会重新创建。
- en: Each component type is rendered slightly differently. For client components,
    the server pre-renders the HTML and JSON data; the client then receives the pre-rendered
    data, including the client-side script, to add interactivity to the HTML. For
    server components, the browser receives only the rendered payload to hydrate the
    component. They neither have client-side JavaScript nor use JavaScript for hydration;
    hence they do not send any JavaScript to the client and, in turn, don’t bloat
    the bundled scripts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每种组件类型的渲染方式略有不同。对于客户端组件，服务器会预渲染 HTML 和 JSON 数据；客户端然后接收预渲染的数据，包括客户端脚本，以便为 HTML
    添加交互性。对于服务器组件，浏览器仅接收渲染后的有效负载来激活组件。它们既没有客户端 JavaScript，也不使用 JavaScript 来进行激活；因此，它们不会向客户端发送任何
    JavaScript，从而避免了打包脚本的膨胀。
- en: '[Listing B-5](appendix-B.xhtml#LisB-5) shows how to statically render the *utils/fetch-names.ts*
    file from [Listing 5-8](chapter5.xhtml#Lis5-8).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 B-5](appendix-B.xhtml#LisB-5) 显示了如何静态渲染来自 [列表 5-8](chapter5.xhtml#Lis5-8)
    的 *utils/fetch-names.ts* 文件。'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing B-5: A server component that uses static rendering'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-5：使用静态渲染的服务器组件
- en: First we define a server component as an asynchronous function that directly
    returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp> wrapped
    in a promise.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将服务器组件定义为一个异步函数，直接返回一个包装在 Promise 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>。
- en: In [Chapter 5](chapter5.xhtml), we returned the page’s data and then used the
    page <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> to pass it the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> function, where
    we generated the element. Here, after setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">url</samp>,
    we use the asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    function to get the data from the remote API. Next.js will cache the results of
    the API call and the rendered component, and the server will reuse the generated
    code and never re-create it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](chapter5.xhtml)中，我们返回了页面的数据，并使用页面的 <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    将其传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> 函数，在那里我们生成了元素。在这里，设置
    <samp class="SANS_TheSansMonoCd_W5Regular_11">url</samp> 后，我们使用异步的 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    函数从远程 API 获取数据。Next.js 会缓存 API 调用的结果和渲染后的组件，服务器将重用已生成的代码而不重新创建它。
- en: If you use <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> without
    an explicit cache setting, it will use <samp class="SANS_TheSansMonoCd_W5Regular_11">force-cache</samp>
    as the default to perform static rendering. To switch to incremental static regeneration
    instead, replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    call from [Listing B-5](appendix-B.xhtml#LisB-5) with the one in [Listing B-6](appendix-B.xhtml#LisB-6).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在没有显式缓存设置的情况下使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>，它将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">force-cache</samp> 作为默认设置进行静态渲染。要切换到增量静态再生，只需将
    [列表 B-5](appendix-B.xhtml#LisB-5) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    调用替换为 [列表 B-6](appendix-B.xhtml#LisB-6) 中的调用。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing B-6: The modified <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fetch</samp>
    call for ISR-like rendering'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-6：用于 ISR 风格渲染的修改版 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fetch</samp>
    调用
- en: We simply add the <samp class="SANS_TheSansMonoCd_W5Regular_11">revalidate</samp>
    property with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">30</samp>.
    The server will then render the component statically but invalidate the current
    HTML 30 seconds after the first page request and re-render it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">revalidate</samp> 属性，并将其值设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">30</samp>。服务器将静态渲染组件，但会在首次页面请求后的
    30 秒内使当前 HTML 失效，并重新渲染它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic Rendering</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">动态渲染</samp>
- en: 'Dynamic rendering replaces Next.js’s traditional server-side rendering (SSR),
    which we used by exporting the <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>
    function from a page route in [Chapter 5](chapter5.xhtml). Because Next.js uses
    static rendering by default, we must actively opt in to using dynamic rendering
    in one of two ways: by disabling the cache in our fetch requests or by using a
    dynamic function. In [Listing B-7](appendix-B.xhtml#LisB-7), we disable the cache.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 动态渲染取代了 Next.js 传统的服务器端渲染（SSR），我们在[第5章](chapter5.xhtml)中通过导出页面路由中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>
    函数来实现 SSR。由于 Next.js 默认使用静态渲染，我们必须通过两种方式之一来主动选择使用动态渲染：要么在我们的 fetch 请求中禁用缓存，要么使用动态函数。在[列表
    B-7](appendix-B.xhtml#LisB-7)中，我们禁用了缓存。
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing B-7: A server component that uses dynamic rendering by disabling the
    cache'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-7：通过禁用缓存使用动态渲染的服务器组件
- en: We explicitly set the <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp>
    property to <samp class="SANS_TheSansMonoCd_W5Regular_11">no-cache</samp>. Now
    the server will re-fetch the data for the component upon each request.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显式地将 <samp class="SANS_TheSansMonoCd_W5Regular_11">cache</samp> 属性设置为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">no-cache</samp>。现在，服务器将在每次请求时重新获取该组件的数据。
- en: Instead of disabling the cache, we could use dynamic functions, including the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">header</samp> function or the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cookies</samp> function in server components
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSearchParams</samp> hook
    in client components. These functions use dynamic data such as request headers,
    cookies, and search parameters that are unknown during build time and are part
    of the request object we pass to the function. The server needs to run these functions
    for each request because the required data depends on the request.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了禁用缓存外，我们还可以使用动态函数，包括在服务器组件中使用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">header</samp>
    函数或 <samp class="SANS_TheSansMonoCd_W5Regular_11">cookies</samp> 函数，以及在客户端组件中使用的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">useSearchParams</samp> 钩子。这些函数使用在构建时未知的动态数据，如请求头、Cookies
    和查询参数，这些数据是我们传递给函数的请求对象的一部分。服务器需要为每个请求运行这些函数，因为所需的数据依赖于请求。
- en: Keep in mind that dynamic rendering affects the whole route. If one server component
    in a route opts for dynamic rendering, Next.js will render the whole route dynamically
    at request time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，动态渲染会影响整个路由。如果路由中的一个服务器组件选择使用动态渲染，Next.js 将在请求时动态渲染整个路由。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Exploring the Project Structure</samp>
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">探索项目结构</samp>
- en: Let’s set up a new Next.js application to explore the features we’ve discussed.
    First, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">npx create-next-app@latest</samp>
    command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--typescript --use-npm</samp>
    flags to create a sample application. When answering the setup wizard’s questions,
    choose to use the *app* directory instead of the *pages* directory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个新的 Next.js 应用来探索我们已经讨论过的特性。首先，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">npx
    create-next-app@latest</samp> 命令，并加上 <samp class="SANS_TheSansMonoCd_W5Regular_11">--typescript
    --use-npm</samp> 标志来创建一个示例应用。在回答设置向导的问题时，选择使用 *app* 目录而不是 *pages* 目录。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*You can also use the online playground at* [https://<wbr>codesandbox<wbr>.io<wbr>/s<wbr>/](https://codesandbox.io/s/)
    *to run the Next.js code examples in this appendix. Search for the official* Next.js
    (App router) *template when creating a new code sandbox there.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*你也可以使用在线 Playground 在* [https://<wbr>codesandbox<wbr>.io<wbr>/s<wbr>/](https://codesandbox.io/s/)
    *上运行本附录中的 Next.js 代码示例。在那里创建新代码沙盒时，搜索官方的* Next.js (App router) *模板。*'
- en: Now enter the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">npm run dev</samp>
    command to start the application in development mode. You should see a Next.js
    welcome screen in your browser at *http://localhost:3000*. Unlike the welcome
    screen you saw in [Chapter 5](chapter5.xhtml), which encouraged us to edit the
    *pages/index.tsx* file, here the welcome screen directs us to the *app/page.tsx*
    file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">npm run dev</samp> 命令以启动应用的开发模式。你应该能在浏览器中看到一个
    Next.js 欢迎页面，网址是 *http://localhost:3000*。与[第5章](chapter5.xhtml)中你看到的欢迎页面不同，后者建议我们编辑
    *pages/index.tsx* 文件，而这里的欢迎页面则指引我们去编辑 *app/page.tsx* 文件。
- en: Take a look at the files and folders the wizard created and compare them with
    the ones from [Chapter 5](chapter5.xhtml). You should see that the *pages* and
    *styles* directories are not part of the new structure. Instead, the router replaces
    both with the *app* directory. Inside it, you should see neither the *_app.tsx*
    file nor the *_document.tsx* file. Instead, it uses the root layout file *layout.tsx*
    to define the HTML wrapper for all rendered pages and the *page.tsx* file to render
    the root segment (the home page).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 查看向导创建的文件和文件夹，并将它们与[第5章](chapter5.xhtml)中的文件进行对比。你应该会看到*pages*和*styles*目录不再是新结构的一部分。相反，路由器将它们替换为*app*目录。在其中，你应该看不到*_app.tsx*文件和*_document.tsx*文件。而是使用根布局文件*layout.tsx*来定义所有渲染页面的
    HTML 包装器，并使用*page.tsx*文件来渲染根段（主页）。
- en: The *pages* directory uses only one file to create the final content of the
    page route. By contrast, the *app* directory uses multiple files to create a page
    route and add additional behavior.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*pages*目录仅使用一个文件来创建页面路由的最终内容。相比之下，*app*目录使用多个文件来创建页面路由并添加额外的行为。'
- en: The *page.tsx* file generates the user interface and the content for the route,
    and its parent folder defines the leaf segment. Without a *page.tsx* file, the
    URL path won’t be accessible. We can then add other special files to the page’s
    folder. Next.js will automatically apply them to this URL segment and its children.
    The most important of these special files are *layout.tsx*, which creates a general
    user interface; *loading.tsx*, which uses a React suspense boundary to automatically
    create a “loading” user interface while the page loads; and *error.tsx*, which
    uses a React error boundary to catch errors and then show the user a custom error
    interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*page.tsx*文件生成用户界面和路由内容，其父文件夹定义了叶段。如果没有*page.tsx*文件，URL路径将无法访问。然后，我们可以向页面的文件夹中添加其他特殊文件。Next.js会自动将它们应用于该URL段及其子段。最重要的特殊文件包括*layout.tsx*，它创建通用用户界面；*loading.tsx*，它使用React悬挂边界在页面加载时自动创建一个“加载”用户界面；以及*error.tsx*，它使用React错误边界捕获错误，并显示自定义错误界面。'
- en: '[Figure B-1](appendix-B.xhtml#figB-1) compares the files and folders for the
    *components/weather* page route when using the *pages* directory and the *app*
    directory.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure B-1](appendix-B.xhtml#figB-1)比较了使用*pages*目录和*app*目录时，*components/weather*页面路由的文件和文件夹。'
- en: '![](../images/FigureB-1.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureB-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-1: Comparing the
    page route</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">in the pages and app directory
    structures</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-1: 比较页面路由</samp>
    <samp class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">在
    pages 和 app 目录结构中的比较</samp>'
- en: When the *app* directory is the root folder, its subfolders still correspond
    to URL segments, but now the folder that contains the *page.tsx* file defines
    the URL’s final leaf segment. The optional special files next to it affect only
    the contents of the *components/weather* page.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当*app*目录是根文件夹时，其子文件夹仍然对应 URL 段，但现在包含*page.tsx*文件的文件夹定义了 URL 的最终叶段。旁边的可选特殊文件只会影响*components/weather*页面的内容。
- en: Let’s rebuild the *components/weather* page route you created in [Listing 5-1](chapter5.xhtml#Lis5-1)
    with the *app* directory. Create the *components* folder and *weather* subfolder
    inside the *app* directory and then copy the *custom.d.ts* file from the previous
    code exercises into the root folder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用*app*目录重建你在[Listing 5-1](chapter5.xhtml#Lis5-1)中创建的*components/weather*页面路由。在*app*目录下创建*components*文件夹和*weather*子文件夹，然后将之前代码练习中的*custom.d.ts*文件复制到根文件夹。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating the CSS</samp>
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">更新 CSS</samp>
- en: Begin by opening the existing *app/globals.css* file and replacing its content
    with the code from [Listing B-8](appendix-B.xhtml#LisB-8). We’ll need to make
    some modifications to use special files in our component.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开现有的*app/globals.css*文件，并将其内容替换为[Listing B-8](appendix-B.xhtml#LisB-8)中的代码。我们需要做一些修改，以便在我们的组件中使用特殊文件。
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing B-8: The app/globals.css file with basic styles for our code examples'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing B-8: 包含基本样式的app/globals.css文件，用于我们的代码示例'
- en: We create one <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp> element
    for the navigation with a <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    content area below it. Then we add styles for the loading and error states we’ll
    create later. In addition, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">section</samp>
    element to outline the boundaries of the files and <samp class="SANS_TheSansMonoCd_W5Regular_11">flag</samp>
    styles to add labels to the sections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个<samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp>元素用于导航，并在其下方定义一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp>内容区域。然后，我们为稍后创建的加载和错误状态添加样式。此外，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">section</samp>元素来划定文件的边界，并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">flag</samp>样式为各部分添加标签。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining a Layout</samp>
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义布局</samp>
- en: Layouts are server components that define the user interface for a particular
    route segment. Next.js renders this layout when this segment is active. Layouts
    are shared across all pages, so they can be nested into each other, and all layouts
    for a specific route and its children will be rendered when this route segment
    is active. [Figure B-2](appendix-B.xhtml#figB-2) shows the relationship between
    the URL, the files, and the component hierarchy for the *components/weather* route.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是服务器组件，用于定义特定路由段的用户界面。当该路由段处于活动状态时，Next.js会渲染这个布局。布局是跨所有页面共享的，因此可以相互嵌套，且特定路由及其子路由的所有布局将在该路由段活动时一并渲染。[图B-2](appendix-B.xhtml#figB-2)显示了URL、文件和*components/weather*路由组件层次之间的关系。
- en: '![](../images/FigureB-2.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureB-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-2: The simplified
    layout component hierarchy</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图B-2：简化的布局组件层次结构</samp>
- en: In this example, each folder contains a *layout.tsx* file. Next.js will render
    these in a nested fashion and make the page’s content the final rendered component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，每个文件夹包含一个*layout.tsx*文件。Next.js会以嵌套的方式渲染这些布局，并将页面内容作为最终渲染的组件。
- en: Although we can fetch data in a layout, we can’t share data between a parent
    layout and its children. Instead, we can leverage the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API’s automatic deduplication to reuse data in each child segment or component.
    When we navigate from one page to another, only the layouts that change are re-rendered.
    Shared layouts won’t be re-rendered when their child segments change.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以在布局中获取数据，但无法在父布局和子布局之间共享数据。相反，我们可以利用<samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API的自动去重功能，在每个子路由段或组件中重用数据。当我们从一个页面导航到另一个页面时，只有变化的布局会重新渲染。共享布局在其子路由段发生变化时不会被重新渲染。
- en: 'The root layout, which returns the skeleton structure with the <samp class="SANS_TheSansMonoCd_W5Regular_11">html</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp> elements for the
    page, is required, while all other layouts we create are optional. Let’s create
    a root layout. First, add a new interface to the end of the *custom.d.ts* file,
    which we copied from the previous exercise. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>
    interface to type the layout’s properties object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根布局返回页面的骨架结构，包括<samp class="SANS_TheSansMonoCd_W5Regular_11">html</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">body</samp>元素，这是必须的，而我们创建的所有其他布局都是可选的。让我们创建一个根布局。首先，在*custom.d.ts*文件的末尾添加一个新接口，该文件是我们从上一个练习中复制的。我们将使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>接口来为布局的属性对象类型：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now open the *app/layout.tsx* file and replace its content with the code from
    [Listing B-9](appendix-B.xhtml#LisB-9).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开*app/layout.tsx*文件，并将其内容替换为[Listing B-9](appendix-B.xhtml#LisB-9)中的代码。
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing B-9: The file app/layout.tsx defines the root layout.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Listing B-9：文件app/layout.tsx定义了根布局。
- en: We import the *global.css* file that we created earlier and then define the
    default SEO metadata, the page title, and the page description through the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp> object. This replaces
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp> component we
    used in the *pages* directory for all pages in the *app* directory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了之前创建的*global.css*文件，然后通过<samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>对象定义默认的SEO元数据、页面标题和页面描述。这替代了我们在*pages*目录中为所有页面使用的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp>组件。
- en: Then we define the <samp class="SANS_TheSansMonoCd_W5Regular_11">RootLayout</samp>
    component, which accepts an object of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>
    type and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>.
    We also create the <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>,
    explicitly adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">html</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp> elements, then use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">section</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">span</samp>
    with the CSS class <samp class="SANS_TheSansMonoCd_W5Regular_11">flag</samp> to
    outline the page structure. We add the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    property from the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>
    object to wrap them with our root HTML structure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">RootLayout</samp>` 组件，它接受一个
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>` 类型的对象，并返回一个
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>`。我们还创建了 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>`，显式地添加了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">html</samp>`
    和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp>` 元素，然后使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">section</samp>`
    和一个带有 CSS 类 `<samp class="SANS_TheSansMonoCd_W5Regular_11">flag</samp>` 的 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">span</samp>` 来勾画页面结构。我们从 `<samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>`
    对象中添加了 `children` 属性，将它们包装在我们的根 HTML 结构中。
- en: Now let’s add optional layouts to the *app/components* and *app/components/weather*
    folders. Create a *layout.tsx* file in each and then place the code from [Listing
    B-10](appendix-B.xhtml#LisB-10) to the *app/components/layout.tsx* file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在 *app/components* 和 *app/components/weather* 文件夹中添加可选布局。在每个文件夹中创建一个 *layout.tsx*
    文件，然后将 [Listing B-10](appendix-B.xhtml#LisB-10) 中的代码放入 *app/components/layout.tsx*
    文件中。
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing B-10: The file app/components/layout.tsx defines the segment layout.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing B-10: 文件 *app/components/layout.tsx* 定义了段落布局。'
- en: This segment layout file follows the same basic structure as the root layout.
    We define a layout component that receives the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>
    object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    property and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>.
    Unlike in the root layout, we set only the inner structure, the <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp>
    element with the navigation placeholder, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    content area where we render the child elements from the <samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>
    object, representing this segment’s child content (the leaf).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该段落布局文件遵循与根布局相同的基本结构。我们定义了一个布局组件，它接收包含 `children` 属性的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>`
    对象，并返回一个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>`。与根布局不同，我们只设置了内部结构，即带有导航占位符的
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp>` 元素，以及 `<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>`
    内容区，在此区我们渲染来自 `<samp class="SANS_TheSansMonoCd_W5Regular_11">LayoutProps</samp>`
    对象的子元素，表示该段的子内容（叶子）。
- en: Lastly, create the leaf’s layout by adding the code from [Listing B-11](appendix-B.xhtml#LisB-11)
    to the *app/components/weather/layout.tsx* file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将 [Listing B-11](appendix-B.xhtml#LisB-11) 中的代码添加到 *app/components/weather/layout.tsx*
    文件中，创建叶子布局。
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing B-11: The file app/components/weather/layout.tsx defines the leaf layout.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing B-11: 文件 *app/components/weather/layout.tsx* 定义了叶子布局。'
- en: The leaf’s layout resembles the segment layout from [Listing B-10](appendix-B.xhtml#LisB-10),
    but it returns a more straightforward HTML structure, as the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    property does not contain another layout; instead, it contains the page’s content
    (in *page.tsx*), and the suspense boundary and error boundary from *loading.tsx*
    and *error.tsx*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 叶子的布局类似于 [Listing B-10](appendix-B.xhtml#LisB-10) 中的段落布局，但它返回的是一个更简单的 HTML 结构，因为
    `children` 属性不包含另一个布局；而是包含页面的内容（在 *page.tsx* 中），以及来自 *loading.tsx* 和 *error.tsx*
    的 suspense 边界和错误边界。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Content
    and Route</samp>
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">添加内容和路由</samp>
- en: To expose the page route, we need to create the *page.tsx* file; otherwise,
    if we tried to visit the *components/weather* page route at *http://localhost:3000/components/weather*,
    we’d see Next.js’s default *404* error page. To re-create the page content from
    [Listing 5-1](chapter5.xhtml#Lis5-1), we’ll create two files. One is *component
    .tsx*, which contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>,
    and the other is *page.tsx*, which resembles the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    wrapper we used in [Listing 5-1](chapter5.xhtml#Lis5-1). Of course, pages could
    contain additional components located in other folders.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了暴露页面路由，我们需要创建*page.tsx*文件；否则，如果我们尝试访问*components/weather*页面路由，网址为*http://localhost:3000/components/weather*，我们将看到Next.js的默认*404*错误页面。为了重新创建[清单5-1](chapter5.xhtml#Lis5-1)中的页面内容，我们将创建两个文件。一个是*component.tsx*，它包含了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>，另一个是*page.tsx*，它类似于我们在[清单5-1](chapter5.xhtml#Lis5-1)中使用的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>包装器。当然，页面可以包含位于其他文件夹中的额外组件。
- en: Let’s start by creating the *component.tsx* file inside the *apps/components/weather*
    folder and adding the code from [Listing B-12](appendix-B.xhtml#LisB-12) into
    it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在*apps/components/weather*文件夹中创建*component.tsx*文件，并将[清单B-12](appendix-B.xhtml#LisB-12)中的代码添加到其中。
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing B-12: The file app/components/weather/component.tsx defines the <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WeatherComponent</samp>.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 清单B-12：文件app/components/weather/component.tsx定义了<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WeatherComponent</samp>。
- en: 'This code is similar to the code in [Listing 5-1](chapter5.xhtml#Lis5-1) for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp> constant,
    except we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">"use client"</samp>
    statement to explicitly set it as a client component and export it as the default
    function instead of storing it in a constant. The component itself has the same
    functionality as before: we create a headline that shows the weather string and
    a counter we can increase by clicking the headline.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[清单5-1](chapter5.xhtml#Lis5-1)中定义的<samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>常量的代码相似，唯一不同的是我们添加了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"use client"</samp>声明，明确将其设置为客户端组件，并将其作为默认函数导出，而不是存储在常量中。该组件本身与之前一样具有相同的功能：我们创建一个标题来显示天气字符串，并且可以通过点击标题来增加计数器。
- en: Now we add the *page.tsx* file and the code from [Listing B-13](appendix-B.xhtml#LisB-13)
    to create the page route and expose the route to the user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加*page.tsx*文件，并将[清单B-13](appendix-B.xhtml#LisB-13)中的代码添加进去，以创建页面路由并将路由暴露给用户。
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing B-13: The file app/components/weather/page.tsx defines the page route.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 清单B-13：文件app/components/weather/page.tsx定义了页面路由。
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>
    we just created and then set the SEO metadata on the page level. Then we export
    the page route as the default async function. When we compare it to [Listing 5-1](chapter5.xhtml#Lis5-1),
    which contains a similar page, we see that we no longer need to export a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>; instead, we use a basic
    function. The *app* directory simplifies the structure of the code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入刚刚创建的<samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>，然后在页面级别设置SEO元数据。接着，我们将页面路由作为默认的异步函数进行导出。当我们与[清单5-1](chapter5.xhtml#Lis5-1)中的类似页面进行比较时，我们发现不再需要导出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>；相反，我们使用一个基本函数。*app*目录简化了代码结构。
- en: Now visit our *components/weather* page route at *http://localhost:3000/components/weather*
    in the browser. You should see a page that looks similar to [Figure B-3](appendix-B.xhtml#figB-3).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中访问我们的*components/weather*页面路由，网址为*http://localhost:3000/components/weather*。你应该看到一个页面，看起来类似于[图B-3](appendix-B.xhtml#figB-3)。
- en: Notice two things here. First, you should recognize the component from [Chapter
    5](chapter5.xhtml), whose counter increases when we click the headline. In addition,
    the combination of the styles and the <samp class="SANS_TheSansMonoCd_W5Regular_11">span</samp>
    elements we added to each *.tsx* file visualizes the relations between the files.
    We see that the nested layout files resemble the simplified component hierarchy
    from [Figure B-3](appendix-B.xhtml#figB-3).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里的两件事。首先，你应该能够认出来自[第5章](chapter5.xhtml)的组件，当我们点击标题时，它的计数器会增加。此外，我们在每个*.tsx*文件中添加的样式和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">span</samp>元素展示了文件之间的关系。我们可以看到，嵌套的布局文件类似于[图B-3](appendix-B.xhtml#figB-3)中的简化组件层次结构。
- en: '![](../images/FigureB-3.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureB-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-3: The</samp> <samp
    class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page
    showing the nested components</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 B-3：该</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">页面显示嵌套组件</samp>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Catching Errors</samp>
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">捕获错误</samp>
- en: As soon as we add an *error.tsx* file to the folder, Next.js wraps our page’s
    content with a React error boundary. [Figure B-4](appendix-B.xhtml#figB-4) shows
    the simplified component hierarchy of the *components/weather* route with an added
    *error.tsx* file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们向文件夹中添加了 *error.tsx* 文件，Next.js 会用一个 React 错误边界包装我们页面的内容。[图 B-4](appendix-B.xhtml#figB-4)
    展示了添加了 *error.tsx* 文件的 *components/weather* 路由的简化组件层次结构。
- en: '![](../images/FigureB-4.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureB-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-4: The simplified
    layout component hierarchy includes the error boundary.</samp>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 B-4：简化的布局组件层次结构包括了错误边界。</samp>
- en: We see that the *error.tsx* file automatically creates an error boundary around
    the page’s content. By doing so, Next.js enables us to catch errors on a page
    level and gracefully handle those instead of freezing the whole user interface
    or redirecting the user to a generic error page. Think about it as a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp>
    block on a component level. We can now show a tailored error message and display
    a button that lets the user re-render the page content in a previously working
    state without reloading the whole application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 *error.tsx* 文件会自动在页面内容周围创建一个错误边界。通过这样做，Next.js 使我们能够在页面级别捕获错误，并优雅地处理这些错误，而不是冻结整个用户界面或将用户重定向到通用错误页面。可以把它看作是组件级别的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> 块。现在，我们可以显示定制的错误信息，并展示一个按钮，让用户在不重新加载整个应用的情况下重新渲染页面内容到之前的正常状态。
- en: The *error.tsx* file exports a client component that the error boundary uses
    as the fallback interface. In other words, this component replaces the content
    when the code throws an error and activates the error boundary. As soon as it
    is active, it contains the error, ensuring that the layouts above the boundary
    remain active and maintain their internal state. The error component receives
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">error</samp> object and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">reset</samp> function as parameters.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*error.tsx* 文件导出了一个客户端组件，错误边界使用该组件作为回退界面。换句话说，当代码抛出错误并激活错误边界时，该组件会替换内容。一旦激活，它就会包含错误，确保边界上方的布局保持活动状态并维护其内部状态。错误组件接收
    <samp class="SANS_TheSansMonoCd_W5Regular_11">error</samp> 对象和 <samp class="SANS_TheSansMonoCd_W5Regular_11">reset</samp>
    函数作为参数。'
- en: 'Let’s add an error boundary to the *components/weather* route. Start by adding
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">ErrorProps</samp> interface
    to type the component’s properties into the *customs.d.ts* file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 *components/weather* 路由中添加一个错误边界。从在 *customs.d.ts* 文件中添加一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ErrorProps</samp>
    接口开始，用于为组件的属性类型化：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, create the *error.tsx* file next to *page.tsx* in the *app/components/weather*
    directory and add the code from [Listing B-14](appendix-B.xhtml#LisB-14).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 *app/components/weather* 目录中创建 *error.tsx* 文件，紧挨着 *page.tsx* 文件，并添加来自
    [列表 B-14](appendix-B.xhtml#LisB-14) 的代码。
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing B-14: The file app/components/weather/error.tsx adds the error boundary
    and the fallback UI.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-14：文件 app/components/weather/error.tsx 添加了错误边界和回退 UI。
- en: Because we know that the error component needs to be a client component, we
    add the <samp class="SANS_TheSansMonoCd_W5Regular_11">"use client"</samp> directive
    to the top of the file and then define and export the component. We use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ErrorProps</samp> interface we just created
    to type the component’s properties. We then convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">error</samp>
    property to a string and display it to inform the user of the type of error that
    occurred. Finally, we render a button that calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">reset</samp>
    function that the component received through the properties object. The user can
    re-render the component into a previous working state by clicking the button.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道错误组件需要是客户端组件，所以我们在文件顶部添加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">"use
    client"</samp> 指令，然后定义并导出该组件。我们使用刚才创建的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ErrorProps</samp>
    接口来定义组件的属性类型。接着，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">error</samp>
    属性转换为字符串，并将其显示出来，以便告知用户发生了什么类型的错误。最后，我们渲染了一个按钮，调用组件通过属性对象传递的 <samp class="SANS_TheSansMonoCd_W5Regular_11">reset</samp>
    函数。用户可以通过点击按钮将组件重新渲染到之前的正常状态。
- en: Now, with the error boundary in place, we’ll modify *component.tsx* to throw
    an error if the counter hits 4 or more. Open the file and add the code from [Listing
    B-15](appendix-B.xhtml#LisB-15) below the first <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，错误边界已经设置好，我们将修改 *component.tsx*，使其在计数器达到 4 或更多时抛出错误。打开该文件，并在第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    钩子下添加 [列表 B-15](appendix-B.xhtml#LisB-15) 中的代码。
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing B-15: The additional <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">useEffect</samp>
    hook for app/components/weather/component.tsx'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-15：app/components/weather/component.tsx 的额外 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">useEffect</samp>
    钩子
- en: The additional <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook we add to the component is straightforward; as soon as the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    variable changes, we verify the error condition, and as soon as the variable’s
    value is 4 or more, we throw an error with the message <samp class="SANS_TheSansMonoCd_W5Regular_11">Count</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4!</samp>,
    which the error boundary catches and gracefully handles by showing the fallback
    user interface that the *error.tsx* file exports.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为组件添加的额外 <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> 钩子非常简单；每当
    <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> 变量发生变化时，我们会验证错误条件，一旦变量值达到
    4 或更多，我们就会抛出一个错误，信息为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Count</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4!</samp>，该错误被错误边界捕获，并通过显示
    *error.tsx* 文件导出的回退用户界面优雅地处理。
- en: To test this feature, open *http://localhost:3000/components/weather* in the
    browser and click the headline until you trigger the error. You should see the
    error component instead of the weather component, as in [Figure B-5](appendix-B.xhtml#figB-5).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此功能，请在浏览器中打开 *http://localhost:3000/components/weather* 并点击标题，直到触发错误。你应该看到错误组件而非天气组件，如同
    [图 B-5](appendix-B.xhtml#figB-5) 所示。
- en: '![](../images/FigureB-5.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureB-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-5: The</samp> <samp
    class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page
    in the error state</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 B-5：</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">页面的错误状态</samp>
- en: 'The layout markers show us that *error.tsx* has replaced *page.tsx*. We also
    see the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Error: Count</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">>=4!</samp>, which we passed to
    the error constructor. As soon as we click the re-render button, *page.tsx* should
    replace *error.tsx*, and the screen will look like [Figure B-4](appendix-B.xhtml#figB-4)
    previously.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '布局标记告诉我们，*error.tsx* 已经替代了 *page.tsx*。我们还看到了字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">Error:
    Count</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>=4!</samp>，这是我们传递给错误构造函数的内容。当我们点击重新渲染按钮时，*page.tsx*
    应该替代 *error.tsx*，屏幕会恢复到 [图 B-4](appendix-B.xhtml#figB-4) 的状态。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Showing an Optional
    Loading Interface</samp>
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">显示可选加载界面</samp>
- en: Now we’ll create the *loading.tsx* file. With this feature in place, Next.js
    automatically wraps the page content with a React suspense component, creating
    a component hierarchy that looks similar to [Figure B-6](appendix-B.xhtml#figB-6).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建*loading.tsx*文件。通过这个功能，Next.js会自动将页面内容包装在一个React悬挂组件中，创建一个类似于[图B-6](appendix-B.xhtml#figB-6)的组件层次结构。
- en: '![](../images/FigureB-6.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureB-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-6: The simplified
    layout component hierarchy with the loading interface</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图B-6：带有加载界面的简化布局组件层次结构</samp>
- en: The *loading.tsx* file is a basic server component that returns the pre-rendered
    loading user interface. When we load a page or navigate between pages, Next.js
    will instantly display this component while loading the new segment’s content.
    Once rendering is complete, the runtime will swap the loading state with the new
    content. In this way, we can easily display meaningful loading states, such as
    skeletons or custom animations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*loading.tsx*文件是一个基本的服务器组件，返回预渲染的加载用户界面。当我们加载页面或在页面之间导航时，Next.js会在加载新内容时立即显示此组件。一旦渲染完成，运行时会将加载状态替换为新内容。通过这种方式，我们可以轻松显示有意义的加载状态，例如骨架屏或自定义动画。'
- en: Let’s add a basic loading user interface to the weather component route by adding
    the code from [Listing B-16](appendix-B.xhtml#LisB-16) to the *loading.tsx* file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将[清单B-16](appendix-B.xhtml#LisB-16)中的代码添加到*loading.tsx*文件中，向天气组件路由添加一个基本的加载用户界面。
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing B-16: The file app/components/weather/loading.tsx adds a suspense boundary
    with the loading user interface.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 清单B-16：文件app/components/weather/loading.tsx添加了一个带有加载用户界面的悬挂边界。
- en: We define and export the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLoading</samp>
    component, which returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>.
    In the HTML, we add a headline element similar to the one in *page.tsx*, except
    this one adds the loading class we created in the *global.css* file to the headline
    and shows an animated placeholder.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义并导出了<samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLoading</samp>组件，该组件返回一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>。在HTML中，我们添加了一个类似于*page.tsx*中的标题元素，唯一不同的是，这个标题元素添加了我们在*global.css*文件中创建的加载类，并显示一个动画占位符。
- en: When we open *http://localhost:3000/components/weather* in the browser, we should
    see a loading interface similar to [Figure B-7](appendix-B.xhtml#figB-7).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中打开*http://localhost:3000/components/weather*时，我们应该会看到一个类似于[图B-7](appendix-B.xhtml#figB-7)的加载界面。
- en: '![](../images/FigureB-7.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureB-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-7: The</samp> <samp
    class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page
    while loading the page’s content</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图B-7：加载页面内容时的</samp> <samp
    class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">页面</samp>
- en: If you don’t see the animated placeholder, this means Next.js has already cached
    your segment’s content.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到动画占位符，这意味着Next.js已经缓存了你的段内容。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding a Server Component
    That Fetches Remote Data</samp>
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">添加一个获取远程数据的服务器组件</samp>
- en: Now that you understand the folders and files in the *app* directory, let’s
    add a server component that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API to receive the list of users from the remote API *https://www.usemodernfullstack.dev/api/v1/users*
    and renders it to the browser. We wrote a version of this code in [Chapter 5](chapter5.xhtml).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了*app*目录中的文件夹和文件，让我们添加一个使用<samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API从远程API *https://www.usemodernfullstack.dev/api/v1/users* 获取用户列表并将其渲染到浏览器的服务器组件。我们在[第5章](chapter5.xhtml)中编写了此代码的一个版本。
- en: Create the folder *app/components/server-component* and add the special files
    *component.tsx*, *loading.tsx*, *error.tsx*, *layout.tsx*, and *page.tsx* to it.
    Then set up the component’s functionality by adding the code from [Listing B-17](appendix-B.xhtml#LisB-17)
    to the *component.tsx* file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件夹*app/components/server-component*，并在其中添加特殊文件*component.tsx*、*loading.tsx*、*error.tsx*、*layout.tsx*和*page.tsx*。然后，通过将[清单B-17](appendix-B.xhtml#LisB-17)中的代码添加到*component.tsx*文件中，设置组件的功能。
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing B-17: The app/components/server-component/component.tsx file'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 清单B-17：app/components/server-component/component.tsx文件
- en: Here we create a default server component that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API to <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> the API response.
    To be able to do so, we define it as an asynchronous function that returns a promise
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp> or an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Error</samp>. Then we store the API endpoint
    in a constant and define the variables we’ll need later on. We wrap the API call
    in a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> statement
    to activate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Error Boundary</samp>
    if the API request fails. We then transform the data in a manner similarly to
    the way we did in [Chapter 5](chapter5.xhtml) and return a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>
    that displays a list of users.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个默认的服务器组件，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    API来<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> API响应。为了实现这一点，我们将其定义为一个异步函数，该函数返回一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>或一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Error</samp>。接着，我们将API端点存储在常量中，并定义后续需要的变量。我们将API调用包装在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp>语句中，以便在API请求失败时激活<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Error Boundary</samp>。然后，我们以类似于[第 5 章](chapter5.xhtml)中处理数据的方式进行数据转换，并返回一个显示用户列表的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>。
- en: Now we add the loading user interface that Next.js automatically displays while
    we await the API’s response and the component’s JSX response. Place the code from
    [Listing B-18](appendix-B.xhtml#LisB-18) into the *loading.tsx* file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加 Next.js 在等待API响应和组件的 JSX 响应时自动显示的加载用户界面。将[清单 B-18](appendix-B.xhtml#LisB-18)中的代码放入*loading.tsx*文件中。
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing B-18: The app/components/server-component/loading.tsx file'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 B-18：app/components/server-component/loading.tsx 文件
- en: As before, the loading component is a server component that returns a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>. This time, the loading
    skeleton is a list with 10 items resembling the component’s rendered HTML structure.
    You’ll see that this gives the user a good impression of the expected content
    and should improve the user’s experience.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，加载组件是一个服务器组件，返回一个<samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>。这次，加载骨架是一个包含
    10 个项的列表，类似于组件呈现的 HTML 结构。你会发现，这可以给用户一个良好的预期内容印象，并应当改善用户体验。
- en: Next, we create the error boundary by adding the code from [Listing B-19](appendix-B.xhtml#LisB-19)
    to the *error.tsx* file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过将[清单 B-19](appendix-B.xhtml#LisB-19)中的代码添加到*error.tsx*文件中来创建错误边界。
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing B-19: The app/components/server-component/error.tsx file'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 B-19：app/components/server-component/error.tsx 文件
- en: Except for the flag outlining the file structure, the error boundary is similar
    to the one we used in the weather component.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了概述文件结构的标志外，错误边界与我们在天气组件中使用的类似。
- en: Then we add the code from [Listing B-20](appendix-B.xhtml#LisB-20) to the *layout.tsx*
    file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将[清单 B-20](appendix-B.xhtml#LisB-20)中的代码添加到*layout.tsx*文件中。
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing B-20: The app/components/server-component/layout.tsx file'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 B-20：app/components/server-component/layout.tsx 文件
- en: Again, the code is similar to the code we used for the weather component. We
    adjust only the flag outlining the component hierarchy.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，代码与我们在天气组件中使用的代码类似。我们只调整了概述组件层次结构的标志。
- en: Finally, with all the parts in place, we add the code from [Listing B-21](appendix-B.xhtml#LisB-21)
    to the *page.tsx* file to expose the page route.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有部分就位后，我们将[清单 B-21](appendix-B.xhtml#LisB-21)中的代码添加到*page.tsx*文件中，以暴露页面路由。
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing B-21: The app/components/server-component/page.tsx file'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 B-21：app/components/server-component/page.tsx 文件
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Completing the Application
    with the Navigation</samp>
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">完成带有导航的应用程序</samp>
- en: With two pages in the application, we can now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>
    component to replace the navigation placeholder in the <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp>
    element. This should create a fully functional application prototype that lets
    us navigate between the pages. Open the *app/components/layout.tsx* file and replace
    the code in the file with the code from [Listing B-22](appendix-B.xhtml#LisB-22).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中有了两个页面后，我们现在可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>组件来替换<nav>元素中的导航占位符。这应该会创建一个完全功能的应用程序原型，使我们能够在页面之间导航。打开*app/components/layout.tsx*文件，将文件中的代码替换为[清单
    B-22](appendix-B.xhtml#LisB-22)中的代码。
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing B-22: The updated app/components/layout.tsx file'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-22：更新后的 app/components/layout.tsx 文件
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>
    component and then add two links to our navigation, one pointing to the user list
    server component we just created and the other pointing to the weather client
    component.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> 组件，然后在我们的导航中添加了两个链接，一个指向我们刚刚创建的用户列表服务器组件，另一个指向天气客户端组件。
- en: Let’s visit the application’s weather component page at *http://localhost:3000/components/weather*.
    You should see an application that looks similar to the screenshot in [Figure
    B-8](appendix-B.xhtml#figB-8).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们访问应用程序的天气组件页面，网址为 *http://localhost:3000/components/weather*。你应该会看到一个类似于
    [图 B-8](appendix-B.xhtml#figB-8) 中屏幕截图的应用程序。
- en: As soon as you navigate between the pages, you should see the loading user interface.
    With the outlines we’ve added to all the files, we easily keep track of which
    files Next.js uses to render the current page.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在页面之间进行导航，你应该会看到加载用户界面。通过我们添加到所有文件中的大纲，我们可以轻松地追踪 Next.js 用来渲染当前页面的文件。
- en: '![](../images/FigureB-8.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureB-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure B-8: The</samp> <samp
    class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">page
    with the functional navigation</samp>'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 B-8：带有功能导航的</samp> <samp
    class="SANS_Futura_Std_Book_11">组件/天气</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">页面</samp>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing API Routes
    with Route Handlers</samp>
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">用路由处理程序替换 API 路由</samp>
- en: If you look at the folder structure Next.js created for you, you should see
    that the *app* directory contains an *api* subfolder. You probably already guessed
    that we use this folder to define APIs. But unlike the API routes discussed in
    [Chapter 5](chapter5.xhtml), which were regular functions, the *app* directory
    uses *route handlers*, which are functions that require a particular naming convention.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 Next.js 为你创建的文件夹结构，你应该会看到 *app* 目录中包含一个 *api* 子文件夹。你可能已经猜到，我们使用这个文件夹来定义
    API。但与 [第 5 章](chapter5.xhtml) 中讨论的 API 路由（它们是普通函数）不同，*app* 目录使用 *路由处理程序*，这些函数需要特定的命名约定。
- en: These route handlers belong in special files named *route.ts* that usually reside
    in a subfolder of the *app/api* folder. They are asynchronous functions that receive
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Request</samp> object and an optional
    context object as parameters. We name each function after the HTTP method it should
    react to. For example, the code in [Listing B-23](appendix-B.xhtml#LisB-23) shows
    how to define route handlers that handle GET and POST requests for the same API.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由处理程序应放置在名为 *route.ts* 的特殊文件中，这些文件通常位于 *app/api* 文件夹的子文件夹中。它们是异步函数，接收一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Request</samp> 对象和一个可选的上下文对象作为参数。我们根据它们应响应的
    HTTP 方法来命名每个函数。例如，[列表 B-23](appendix-B.xhtml#LisB-23) 中的代码演示了如何定义处理 GET 和 POST
    请求的路由处理程序。
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing B-23: A skeleton structure of a route.ts file defining route handlers'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-23：定义路由处理程序的 route.ts 文件框架结构
- en: To create the route handlers, we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp> objects
    from Next.js’s server package. Next.js adds additional convenience methods for
    cookie handling, redirects, and rewrites. You can read more about them in the
    official documentation at [*https://<wbr>nextjs<wbr>.org*](https://nextjs.org).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建路由处理程序，我们从 Next.js 的服务器包中导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp> 对象。Next.js
    为 cookie 处理、重定向和重写添加了额外的便捷方法。你可以在官方文档中阅读更多关于它们的信息，网址：[*https://<wbr>nextjs<wbr>.org*](https://nextjs.org)。
- en: We then define two asynchronous functions, both of which receive a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp>
    and return a promise of a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp>.
    The function names correspond to the HTTP method they should respond to. Next.js
    supports using the GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS methods as
    function names.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了两个异步函数，它们都接收一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp>
    并返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp> 的 Promise。函数名对应它们应该响应的
    HTTP 方法。Next.js 支持使用 GET、POST、PUT、PATCH、DELETE、HEAD 和 OPTIONS 方法作为函数名。
- en: 'When defining page routes and route handlers, remember that these files take
    over all requests for a given segment. This means that a *route.ts* file cannot
    be in the same folder as a *page.tsx* file. Also, route handlers are the only
    way to define APIs if you use the *app* directory: you can’t have an *api* folder
    in both the *pages* directory and *app* directory.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义页面路由和路由处理器时，记住这些文件会接管给定段的所有请求。这意味着 *route.ts* 文件不能与 *page.tsx* 文件位于同一文件夹中。此外，路由处理器是定义
    API 的唯一方式，如果你使用的是 *app* 目录：你不能在 *pages* 目录和 *app* 目录中同时存在 *api* 文件夹。
- en: Next.js has statically and dynamically evaluated route handlers. Statically
    evaluated route handlers will be cached and reused for every request, whereas
    dynamically evaluated route handlers must request the data upon each request.
    By default, the runtime statically evaluates all GET route handlers that don’t
    use a dynamic function or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp>
    object. As soon as we use a different HTTP method, the dynamic <samp class="SANS_TheSansMonoCd_W5Regular_11">cookies</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">headers</samp> function, or the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp> object, the route
    handler becomes dynamically evaluated. The same applies to APIs with dynamic segments,
    which receive the dynamic parameters through the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    object.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 具有静态和动态评估的路由处理器。静态评估的路由处理器会被缓存并在每次请求时重用，而动态评估的路由处理器则必须在每次请求时请求数据。默认情况下，运行时会静态评估所有不使用动态函数或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp> 对象的 GET 路由处理器。一旦我们使用了不同的
    HTTP 方法、动态 <samp class="SANS_TheSansMonoCd_W5Regular_11">cookies</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">headers</samp> 函数，或者 <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp>
    对象，路由处理器就会变成动态评估。同样，带有动态段的 API 也适用此规则，它们通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    对象接收动态参数。
- en: Let’s re-create the API route *api/v1/weather/[zipcode].ts* from [Listing 5-1](chapter5.xhtml#Lis5-1)
    as a route handler that we can use in the *app* directory. Add the code from [Listing
    B-24](appendix-B.xhtml#LisB-24) to a *route.ts* file in the folder structure *app/api/v1/weather/[zipcode]*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从[列表 5-1](chapter5.xhtml#Lis5-1)重新创建 API 路由 *api/v1/weather/[zipcode].ts*，作为我们可以在
    *app* 目录中使用的路由处理器。将 [列表 B-24](appendix-B.xhtml#LisB-24) 中的代码添加到 *app/api/v1/weather/[zipcode]*
    文件夹结构中的 *route.ts* 文件中。
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing B-24: The route handler in app/api/v1/weather/[zipcode]/route.ts'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B-24：位于 `app/api/v1/weather/[zipcode]/route.ts` 中的路由处理器
- en: Notice that we’ve used the square brackets pattern on the folder structure to
    access the dynamic segment through the function’s second parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    object.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在文件夹结构中使用了方括号模式，通过函数的第二个参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    对象来访问动态段。
- en: Within the file, we import the Next.js <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp> objects from
    the server package and then define the interfaces for the route handler. On the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestContext</samp> interface,
    we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> property
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp>, representing the
    API’s dynamic segment. Finally, we export the asynchronous GET function, the API
    route handler that reacts to all GET requests for this API endpoint. It receives
    the request object and the request context as parameters and uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp>’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> function to return the
    response data. We access the URL parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> object’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> object and then add
    it to the response data. We set additional response options through the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">json</samp> function’s second parameter,
    explicitly setting the HTTP status code to *200*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中，我们从服务器包导入了 Next.js 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextRequest</samp> 对象，然后定义了路由处理程序的接口。在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestContext</samp> 接口上，我们将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> 属性添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp>
    中，表示 API 的动态段。最后，我们导出了异步的 GET 函数，这个 API 路由处理程序会响应所有对该 API 端点的 GET 请求。它将请求对象和请求上下文作为参数接收，并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NextResponse</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp>
    函数返回响应数据。我们通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> 对象的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> 对象访问 URL 参数 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>，然后将其添加到响应数据中。我们通过 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">json</samp> 函数的第二个参数设置额外的响应选项，明确设置 HTTP
    状态码为 *200*。
- en: 'Now try querying the API with <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> 查询 API：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should receive this JSON response:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该收到以下 JSON 响应：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the same response received in [Chapter 5](chapter5.xhtml), where we
    accessed the API through the browser.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 [第 5 章](chapter5.xhtml) 中收到的相同响应，我们在其中通过浏览器访问了 API。
