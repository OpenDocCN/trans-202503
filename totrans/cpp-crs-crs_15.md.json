["```\n#include <boost/logic/tribool.hpp>\n\nusing boost::logic::indeterminate; ➊\nboost::logic::tribool t = true➋, f = false➌, i = indeterminate➍;\n```", "```\nTEST_CASE(\"Boost tribool converts to bool\") {\n  REQUIRE(t); ➊\n  REQUIRE_FALSE(f); ➋\n  REQUIRE(!f); ➌\n  REQUIRE_FALSE(!t); ➍\n  REQUIRE(indeterminate(i)); ➎\n  REQUIRE_FALSE(indeterminate(t)); ➏\n}\n```", "```\nTEST_CASE(\"Boost Tribool supports Boolean operations\") {\n  auto t_or_f = t || f;\n  REQUIRE(t_or_f); ➊\n  REQUIRE(indeterminate(t && indeterminate)); ➋\n  REQUIRE(indeterminate(f || indeterminate)); ➌\n  REQUIRE(indeterminate(!i)); ➍\n}\n```", "```\nTEST_CASE(\"Boost Tribool works nicely with if statements\") {\n  if (i) FAIL(\"Indeterminate is true.\"); ➊\n  else if (!i) FAIL(\"Indeterminate is false.\"); ➋\n  else {} // OK, indeterminate ➌\n}\n```", "```\n#include <optional>\n\nstruct TheMatrix { ➊\n  TheMatrix(int x) : iteration { x } { }\n  const int iteration;\n};\n\nenum Pill { Red, Blue }; ➋\n\nstd::optional<TheMatrix>➌ take(Pill pill➍) {\n  if(pill == Pill::Blue) return TheMatrix{ 6 }; ➎\n  return std::nullopt; ➏\n}\n```", "```\nTEST_CASE(\"std::optional contains types\") {\n  if (auto matrix_opt = take(Pill::Blue)) { ➊\n    REQUIRE(matrix_opt->iteration == 6); ➋\n    auto& matrix = matrix_opt.value(); \n    REQUIRE(matrix.iteration == 6); ➌\n  } else {\n    FAIL(\"The optional evaluated to false.\");\n  }\n}\n```", "```\nTEST_CASE(\"std::optional can be empty\") {\n  auto matrix_opt = take(Pill::Red); ➊\n  if (matrix_opt) FAIL(\"The Matrix is not empty.\"); ➋\n  REQUIRE_FALSE(matrix_opt.has_value()); ➌\n}\n```", "```\n#include <utility>\n\nstruct Socialite { const char* birthname; };\nstruct Valet { const char* surname; };\nSocialite bertie{ \"Wilberforce\" };\nValet reginald{ \"Jeeves\" };\n```", "```\nTEST_CASE(\"std::pair permits access to members\") {\n  std::pair<Socialite, Valet> inimitable_duo{ bertie, reginald }; ➊\n  REQUIRE(inimitable_duo.first.birthname == bertie.birthname); ➋\n  REQUIRE(inimitable_duo.second.surname == reginald.surname); ➌\n}\n```", "```\nTEST_CASE(\"std::pair works with structured binding\") {\n  std::pair<Socialite, Valet> inimitable_duo{ bertie, reginald };\n  auto& [idle_rich, butler] = inimitable_duo; ➊\n  REQUIRE(idle_rich.birthname == bertie.birthname); ➋\n  REQUIRE(butler.surname == reginald.surname); ➌\n}\n```", "```\nstruct Acquaintance { const char* nickname; };\nAcquaintance hildebrand{ \"Tuppy\" };\n```", "```\nTEST_CASE(\"std::tuple permits access to members with std::get\") {\n  using Trio = std::tuple<Socialite, Valet, Acquaintance>;\n  Trio truculent_trio{ bertie, reginald, hildebrand };\n  auto& bertie_ref = std::get<0>(truculent_trio); ➊\n  REQUIRE(bertie_ref.birthname == bertie.birthname);\n\n  auto& tuppy_ref = std::get<Acquaintance>(truculent_trio); ➋\n  REQUIRE(tuppy_ref.nickname == hildebrand.nickname);\n}\n```", "```\n#include <any>\n\nstruct EscapeCapsule {\n  EscapeCapsule(int x) : weight_kg{ x } { }\n  int weight_kg;\n}; ➊\n\nTEST_CASE(\"std::any allows us to std::any_cast into a type\") {\n  std::any hagunemnon; ➋\n  hagunemnon.emplace<EscapeCapsule>(600); ➌\n  auto capsule = std::any_cast<EscapeCapsule>(hagunemnon); ➍\n  REQUIRE(capsule.weight_kg == 600);\n  REQUIRE_THROWS_AS(std::any_cast<float>(hagunemnon), std::bad_any_cast); ➎\n}\n```", "```\n#include <variant>\n\nstruct BugblatterBeast {\n  BugblatterBeast() : is_ravenous{ true }, weight_kg{ 20000 } { }\n  bool is_ravenous;\n  int weight_kg; ➊\n};\n```", "```\nstd::variant<BugblatterBeast, EscapeCapsule> hagunemnon;\n```", "```\nTEST_CASE(\"std::variant\") {\n  std::variant<BugblatterBeast, EscapeCapsule> hagunemnon;\n  REQUIRE(hagunemnon.index() == 0); ➊\n\n  hagunemnon.emplace<EscapeCapsule>(600); ➋\n  REQUIRE(hagunemnon.index() == 1); ➌\n\n  REQUIRE(std::get<EscapeCapsule>(hagunemnon).weight_kg == 600); ➍\n  REQUIRE(std::get<1>(hagunemnon).weight_kg == 600); ➎\n  REQUIRE_THROWS_AS(std::get<0>(hagunemnon), std::bad_variant_access); ➏\n}\n```", "```\nTEST_CASE(\"std::variant\") {\n  std::variant<BugblatterBeast, EscapeCapsule> hagunemnon;\n  hagunemnon.emplace<EscapeCapsule>(600); ➊\n  auto lbs = std::visit([](auto& x) { return 2.2*x.weight_kg; }, hagunemnon); ➋\n  REQUIRE(lbs == 1320); ➌\n}\n```", "```\n#include <boost/date_time/gregorian/gregorian.hpp>\n```", "```\nboost::gregorian::date d{ 1986, 9, 15 };\n```", "```\nauto d = boost::gregorian::from_string(\"1986/9/15\");\n```", "```\nTEST_CASE(\"Invalid boost::Gregorian::dates throw exceptions\") {\n  using boost::gregorian::date;\n  using boost::gregorian::bad_day_of_month;\n\n  REQUIRE_THROWS_AS(date(1986, 9, 32), bad_day_of_month); ➊\n}\n```", "```\nauto d_local = boost::gregorian::day_clock::local_day();\nauto d_univ = boost::gregorian::day_clock::universal_day();\n```", "```\nTEST_CASE(\"boost::gregorian::date supports basic calendar functions\") {\n  boost::gregorian::date d{ 1986, 9, 15 }; ➊\n  REQUIRE(d.year() == 1986); ➋\n  REQUIRE(d.month() == 9); ➌\n  REQUIRE(d.day() == 15); ➍\n  REQUIRE(d.day_of_year() == 258); ➎\n  REQUIRE(d.day_of_week() == boost::date_time::Monday); ➏\n}\n```", "```\nTEST_CASE(\"boost::gregorian::date supports calendar arithmetic\") {\n  boost::gregorian::date d1{ 1986, 9, 15 }; ➊\n  boost::gregorian::date d2{ 2019, 8, 1 }; ➋\n  auto duration = d2 - d1; ➌\n  REQUIRE(duration.days() == 12008); ➍\n}\n```", "```\nTEST_CASE(\"date and date_duration support addition\") {\n  boost::gregorian::date d1{ 1986, 9, 15 }; ➊\n  boost::gregorian::date_duration dur{ 12008 }; ➋\n  auto d2 = d1 + dur; ➌\n  REQUIRE(d2 == boost::gregorian::from_string(\"2019/8/1\")); ➍\n}\n```", "```\nTEST_CASE(+boost::gregorian::date supports periods+) {\n  boost::gregorian::date d1{ 1986, 9, 15 }; ➊\n  boost::gregorian::date d2{ 2019, 8, 1 }; ➋\n  boost::gregorian::date_period p{ d1, d2 }; ➌\n  REQUIRE(p.contains(boost::gregorian::date{ 1987, 10, 27 })); ➍\n}\n```", "```\nTEST_CASE(\"std::chrono supports several clocks\") {\n  auto sys_now = std::chrono::system_clock::now(); ➊\n  auto hires_now = std::chrono::high_resolution_clock::now(); ➋\n  auto steady_now = std::chrono::steady_clock::now(); ➌\n\n  REQUIRE(sys_now.time_since_epoch().count() > 0); ➍\n  REQUIRE(hires_now.time_since_epoch().count() > 0); ➎\n  REQUIRE(steady_now.time_since_epoch().count() > 0); ➏\n}\n```", "```\n#include <chrono>\nTEST_CASE(\"std::chrono supports several units of measurement\") {\n  using namespace std::literals::chrono_literals; ➊\n  auto one_s = std::chrono::seconds(1); ➋\n  auto thousand_ms = 1000ms; ➌\n  REQUIRE(one_s == thousand_ms); ➍\n}\n```", "```\nTEST_CASE(\"std::chrono supports duration_cast\") {\n  using namespace std::chrono; ➊\n  auto billion_ns_as_s = duration_cast<seconds➋>(1'000'000'000ns➌);\n  REQUIRE(billion_ns_as_s.count() == 1); ➍\n}\n```", "```\n#include <thread>\n#include <chrono>\nTEST_CASE(\"std::chrono used to sleep\") {\n  using namespace std::literals::chrono_literals; ➊\n  auto start = std::chrono::system_clock::now(); ➋\n  std::this_thread::sleep_for(100ms); ➌\n  auto end = std::chrono::system_clock::now(); ➍\n  REQUIRE(end - start >= 100ms); ➎\n}\n```", "```\n#include <chrono>\n\nstruct Stopwatch {\n  Stopwatch(std::chrono::nanoseconds& result➊)\n    : result{ result }, ➋\n    start{ std::chrono::high_resolution_clock::now() } { } ➌\n  ~Stopwatch() {\n    result = std::chrono::high_resolution_clock::now() - start; ➍\n  }\nprivate:\n  std::chrono::nanoseconds& result;\n const std::chrono::time_point<std::chrono::high_resolution_clock> start;\n};\n```", "```\n#include <cstdio>\n#include <cstdint>\n#include <chrono>\n\nstruct Stopwatch {\n--snip--\n};\nint main() {\n  const size_t n = 1'000'000; ➊\n  std::chrono::nanoseconds elapsed; ➋\n  {\n    Stopwatch stopwatch{ elapsed }; ➌\n    volatile double result{ 1.23e45 }; ➍\n    for (double i = 1; i < n; i++) {\n      result /= i; ➎\n    }\n  }\n  auto time_per_division = elapsed.count() / double{ n }; ➏\n  printf(\"Took %gns per division.\", time_per_division); ➐\n}\n--------------------------------------------------------------------------\nTook 6.49622ns per division. ➐\n```", "```\n#include <complex>\n\nTEST_CASE(\"std::complex has a real and imaginary component\") {\n  std::complex<double> a{0.5, 14.13}; ➊\n  REQUIRE(std::real(a) == Approx(0.5)); ➋\n  REQUIRE(std::imag(a) == Approx(14.13)); ➌\n}\n```", "```\n#include <cmath>\n#include <boost/math/constants/constants.hpp>\n\nTEST_CASE(\"boost::math offers constants\") {\n  using namespace boost::math::double_constants; ➊\n  auto sphere_volume = four_thirds_pi * std::pow(10, 3); ➋\n  REQUIRE(sphere_volume == Approx(4188.7902047));\n}\n```", "```\n#include <random>\nTEST_CASE(\"mt19937_64 is pseudorandom\") {\n  std::mt19937_64 mt_engine{ 91586 }; ➊\n REQUIRE(mt_engine() == 8346843996631475880); ➋\n  REQUIRE(mt_engine() == 2237671392849523263); ➌\n  REQUIRE(mt_engine() == 7333164488732543658); ➍\n}\n```", "```\nTEST_CASE(\"std::random_device is invocable\") {\n  std::random_device rd_engine{}; ➊\n  REQUIRE_NOTHROW(rd_engine()); ➋\n}\n```", "```\nTEST_CASE(\"std::uniform_int_distribution produces uniform ints\") {\n  std::mt19937_64 mt_engine{ 102787 }; ➊\n  std::uniform_int_distribution<int> int_d{ 0, 10 }; ➋\n  const size_t n{ 1'000'000 }; ➌\n  int sum{}; ➍\n  for (size_t i{}; i < n; i++)\n    sum += int_d(mt_engine); ➎\n  const auto sample_mean = sum / double{ n }; ➏\n  REQUIRE(sample_mean == Approx(5).epsilon(.1)); ➐\n}\n```", "```\n#include <limits>\nTEST_CASE(\"std::numeric_limits::min provides the smallest finite value.\") {\n  auto my_cup = std::numeric_limits<int>::min(); ➊\n  auto underfloweth = my_cup - 1; ➋\n  REQUIRE(my_cup < underfloweth); ➌\n}\n```", "```\n#include <boost/numeric/conversion/converter.hpp>\nusing double_to_int = boost::numeric::converter<int➊, double➋>;\n```", "```\nTEST_CASE(\"boost::converter offers the static method convert\") {\n  REQUIRE(double_to_int::convert(3.14159) == 3);\n}\n```", "```\nTEST_CASE(\"boost::numeric::converter implements operator()\") {\n  double_to_int dti; ➊\n  REQUIRE(dti(3.14159) == 3); ➋\n  REQUIRE(double_to_int{}(3.14159) == 3); ➌\n}\n```", "```\n#include <limits>\nTEST_CASE(\"boost::numeric::converter checks for overflow\") {\n  auto yuge = std::numeric_limits<double>::max(); ➊\n  double_to_int dti; ➋\n  REQUIRE_THROWS_AS(dti(yuge)➌, boost::numeric::positive_overflow➍);\n}\n```", "```\n#include <limits>\n#include <boost/numeric/conversion/cast.hpp>\n\nTEST_CASE(\"boost::boost::numeric_cast checks overflow\") {\n  auto yuge = std::numeric_limits<double>::max(); ➊\n  REQUIRE_THROWS_AS(boost::numeric_cast<int>(yuge), ➋\n                    boost::numeric::positive_overflow ➌);\n}\n```", "```\n#include <ratio>\n\nTEST_CASE(\"std::ratio\") {\n  using ten = std::ratio<10, 1>; ➊\n  using two_thirds = std::ratio<2, 3>; ➋\n  using result = std::ratio_multiply<ten, two_thirds>; ➌\n  REQUIRE(result::num == 20); ➍\n  REQUIRE(result::den == 3); ➎\n}\n```"]