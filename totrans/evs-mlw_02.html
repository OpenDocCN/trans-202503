<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_3" aria-label="3"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch1">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS FOUNDATIONAL CONCEPTS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">To understand your adversary, first you must understand the battlefield. In our case, the battlefield is the Windows operating system and its underlying components. This chapter will provide an overview of the Windows architecture and introduce the fundamental concepts you’ll need in order to understand the more advanced topics covered in later chapters of this book.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-8"/><samp class="SANS_Futura_Std_Bold_B_11">Windows Architecture Overview</samp></h3>&#13;
<p class="TNI1">Windows is a complex operating system (OS) with an equally complex architecture. In this section, I’ll introduce some of its key concepts, and as we proceed through the chapter, I’ll revisit and elaborate on them.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_4" aria-label="4"/>&#13;
<h4 class="H2" id="sec2"><span id="h-9"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">User and Kernel Modes</samp></h4>&#13;
<p class="TNI1">The Windows architecture consists of two modes: user and kernel, which are the fundamental components of the OS. A <i>mode</i> is a context in which code runs on the system. <i>User mode</i> is what most people think of when using a computer; it consists of the normal, day-to-day software and processes that the user interacts with, such as Microsoft Office programs and web browsers. Conversely, <i>kernel mode</i> is reserved for the core OS functions: those responsible for important, low-level tasks like memory management and hardware interaction.</p>&#13;
<p class="TX">Code running in user mode can’t access or interfere with code running in kernel mode; this is an intentional protection mechanism to prevent misconfigured or malicious applications from altering the OS environment. This separation is critical because all code and programs that run in kernel mode share the same memory address space, meaning that a misbehaving program could cause an unintended crash of the entire OS. It also means that if a malicious program were able to execute in kernel mode, it could directly affect the OS.</p>&#13;
<p class="TX"><a href="chapter1.xhtml#fig1-1">Figure 1-1</a> shows the relationship between user mode and kernel mode.</p>&#13;
<figure class="IMG"><img class="img70" id="fig1-1" src="../images/fig1-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: The relationship between user mode and kernel mode</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Let’s take a closer look at the concepts illustrated here:</p>&#13;
<p class="ListHead"><b>Applications</b></p>&#13;
<p class="List">These are the software and programs that a user runs.</p>&#13;
<p class="ListHead"><b>Windows application programming interface (WinAPI)</b></p>&#13;
<p class="List">This is what applications rely on in order to function. I’ll discuss this further in <span class="Xref">“The Windows API”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_6">page 6</a></span>.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_5" aria-label="5"/><b>Drivers</b></p>&#13;
<p class="List">These control various devices on the system and provide an abstraction layer between the devices and the programs that wish to interact with them. There are two kinds of drivers. <i>Hardware device drivers</i> take input/output (IO) requests and convert them to hardware IO requests, such as for the mouse and keyboard. <i>Nonhardware device drivers</i> control system components such as network interfaces and the filesystem. Some drivers operate in user mode and some in kernel mode.</p>&#13;
<p class="ListHead"><b>Hardware abstraction layer</b></p>&#13;
<p class="ListLast">This provides an interface that device drivers can use to communicate with the underlying system hardware. It enables the kernel and higher-level applications to operate independently of the system hardware.</p>&#13;
<p class="TX">The Windows kernel itself is contained in an executable file called <i>ntoskrnl.exe</i>, and it’s split into two parts: the kernel and the executive layer. The <i>kernel</i> is responsible for fundamental functionality like task synchronization and scheduling; it also provides low-level hardware support, which is essential for the system to run efficiently. The <i>executive layer</i> contains critical system services such as the <i>Memory Manager</i>, which implements virtual memory functionalities (see <span class="Xref">“Virtual Memory”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_11">page 11</a></span>), and the <i>Process Manager</i>, which handles the creation and termination of processes and threads.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-10"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Processes and Threads</samp></h4>&#13;
<p class="TNI1">When an application such as <i>Excel.exe</i> or <i>Calculator.exe</i> is executed, the Windows Portable Executable loader creates a <i>process</i> for that program; the process contains the original program executable and all supporting libraries and code. Each process is assigned its own virtual address space in memory, which is private and isolated to that process. This means that if a process crashes, it does not (or should not) affect other processes or the OS itself.</p>&#13;
<p class="TX">Each running process in Windows can host one or more threads. A <i>thread</i> is simply a series of instructions. The processor can run only one thread at any given time, however. This means that if Process B wishes to execute some code, it must wait for Process A’s current thread to complete. If Windows deems Process B to be more important, it can issue an interrupt to Process A’s current thread and execute Process B’s thread instead. (This is called a <i>context switch.</i>) Windows executes context switching so quickly and efficiently that the end user isn’t even aware that it’s constantly happening.</p>&#13;
<p class="TX">Windows is a multitasking OS. This means that as the processor executes instructions to run the system and its applications, it efficiently switches between executing code in user mode and in kernel mode. To do this, Windows uses <i>time slices</i>, which are atomic segments of time (measured in milliseconds) that are assigned to each thread. A thread is allowed to execute its code, but after its time slice expires, other threads are allowed to run. Because time slices are so small, the system appears to be executing multiple threads and operating multiple programs at the same time.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_6" aria-label="6"/>&#13;
<h4 class="H2" id="sec4"><span id="h-11"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Objects and Handles</samp></h4>&#13;
<p class="TNI1">Processes and threads often interact with <i>objects</i>, which are instances of a certain type of resource, such as a file, another process or thread, a security token (for user access rights), or even a section of memory. The centralized <i>object manager</i> is responsible for tracking all Windows objects, sharing them among processes, and protecting them from unauthorized access.</p>&#13;
<p class="TX">All objects in Windows are simply data structures, typically stored in kernel memory. Since most applications on Windows run in user space, a process uses a unique identifier known as a <i>handle</i> to access an object. Each process may have multiple handles for various objects. Handles are managed in a process’s <i>handle table</i>, which contains pointers to the objects in kernel memory, as illustrated in <a href="chapter1.xhtml#fig1-2">Figure 1-2</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig1-2" src="../images/fig1-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: A Windows process handle table and object structure</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><i>Mutual exclusions</i>, or <i>mutexes</i>, are a method of controlling access to objects to prevent potential issues like Process A and Process B both attempting to access and modify a file at exactly the same time, which is known as a <i>race condition</i>. Depending on how Windows uses this specific file, this situation could potentially cause data inconsistencies, or worse, crash a process or the OS. To avoid unwanted events such as a race condition, Process A may create a mutex object for that file, locking the file for its own use and preventing Process B from being able to access or write to the file until it is unlocked.</p>&#13;
<p class="TX">The program’s interaction with these objects, and with the OS itself, is managed by the Windows API.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-12"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Windows API</samp></h4>&#13;
<p class="TNI1">The <i>Windows application programming interface (WinAPI)</i> is a shared library of code that is exposed to user-mode applications. When a Windows program <span role="doc-pagebreak" epub:type="pagebreak" id="pg_7" aria-label="7"/>runs, WinAPI invokes Windows functions that enable the program to operate as designed within the Windows OS.</p>&#13;
<p class="TX">WinAPI covers nearly all the functionality that a developer could want to implement in their code: everything from user interface and networking capabilities to input devices (mouse, keyboard, and so on) to memory management. For example, if a developer wants to create a new window for their application, they might call the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp> function. If a program needs access to a hard disk, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLogicalDrives</samp> to retrieve a list of the available hard disks.</p>&#13;
<p class="TX">There’s also a lower-level API called the <i>Windows Native API</i>, or simply <i>Native API</i>. While WinAPI is well documented and designed to be used by developers, the Native API is largely undocumented, at least by Microsoft.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>	Thankfully, the reverse engineering community has gone to great lengths to document the Native API internals. Two great examples are the “ntinternals” project (</i><a href="http://undocumented.ntinternals.net"><span class="note_LinkURL_Italic">http://undocumented.ntinternals.net</span></a><i>)</i> <i>and Geoff Chappell’s research (</i><a href="https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm"><span class="note_LinkURL_Italic">https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm</span></a><i>)</i>.</p>&#13;
<p class="TX">The Native API is designed to be internal to the OS, but programs can call Native API functions directly if they so choose. In turn, Native API functions call into even lower-level kernel API code residing in <i>ntoskrnl.exe</i>. A call into the kernel is known as a <i>syscall</i> or <i>sysenter</i>. (There are minor technical differences between syscall and sysenter, but they both have the same objective: allowing user applications access to kernel services. For simplicity’s sake, I’ll use the term <i>syscall</i> in this book.)</p>&#13;
<p class="TX"><a href="chapter1.xhtml#fig1-3">Figure 1-3</a> illustrates the interaction between WinAPI and the Native API.</p>&#13;
<figure class="IMG"><img class="img70" id="fig1-3" src="../images/fig1-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-3: User-mode APIs calling into lower-level APIs</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">At the top, you can see a program calling the WinAPI function <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, which in turn calls WinAPI’s <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> function (not shown in this diagram). This is followed by a call to the Native API’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> function. Finally, the program invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> function inside <i>ntoskrnl.exe</i>. This complex chain of API calls is very common in Windows and allows for code to be developed without the developer needing to understand all of the internals of Windows and the lower-level APIs.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_8" aria-label="8"/>As you may have noticed, WinAPI functions often have one or more suffixes, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>. Generally speaking, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp> suffix is Microsoft’s way of designating a newer, extended (with more features) version of an older function. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExA</samp> function is the newer, extended version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowA</samp> function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> suffix indicates that the function uses ANSI format inputs and outputs, while functions with a <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp> suffix use Unicode inputs and outputs. The usage of ANSI versus Unicode doesn’t matter that often, so I won’t be covering that topic further and I generally won’t include the <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp> in the function name. (For example, I’ll refer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowA</samp> function as simply <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindow</samp>.) For <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp> functions, however, I’ll always include the suffix.</p>&#13;
<p class="TX">Windows Native API functions typically have the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>; examples include <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcess</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwNotifyChangeKey</samp>. Each function in the API typically has both an <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> version. <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> functions are most often used by drivers and other lower-level system software but are largely interchangeable with <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> functions.</p>&#13;
<p class="TX">You may also have noticed the filenames <i>kernel32.dll</i> and <i>ntdll.dll</i> in <a href="chapter1.xhtml#fig1-3">Figure 1-3</a>. These refer to <i>dynamic link libraries (DLLs)</i>, a collection of resources that developers can import into their program to make use of existing code from Microsoft or third-party developers. While Windows programs can import these libraries, DLL files themselves export functions to the program that imported them. For example, if a developer wishes to access a hard disk on the Windows system, they can import the <i>kernel32.dll</i> library, which exports (provides) the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLogicalDrives</samp> function they need. Some of the DLLs used often in Windows programs are as follows:</p>&#13;
<p class="RunInPara1"><b><i>kernel32.dll </i></b>This is one of the primary DLLs required for Windows programs to run, and it contains many of the fundamental user-mode functions.</p>&#13;
<p class="RunInPara"><b><i>user32.dll </i></b>This DLL provides the graphical user interface (GUI) functions required for Windows programs.</p>&#13;
<p class="RunInPara"><b><i>Winhttp.dll </i></b>Also known as the “Windows HTTP Interface,” this DLL provides internet connection functionalities to Windows programs.</p>&#13;
<p class="RunInPara2"><b><i>ntdll.dll </i></b>This critical DLL contains functions for synchronization, threading, and other system tasks; it also communicates with the kernel.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>	If you’re analyzing code with functions exported from</i> <span class="note_Italic">kernel32.dll</span> <i>(as many functions are), you might notice that when a process executes a</i> <span class="note_Italic">kernel32.dll</span> <i>function, there’s an immediate jump to another DLL,</i> <span class="note_Italic">kernelbase.dll</span><i>. Introduced in Windows 7,</i> <span class="note_Italic">kernelbase.dll</span> <i>allows for backward compatibility between older and newer Windows versions. Most</i> <span class="note_Italic">kernel32.dll</span> <i>function calls simply jump to</i> <span class="note_Italic">kernelbase.dll</span><i>, which contains the function’s actual code. For example, the function <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WriteFile</samp> (exported from</i> <span class="note_Italic">kernel32.dll</span><i>), once invoked, will immediately jump to</i> <span class="note_Italic">kernelbase.dll</span><i>, where its code actually resides. For simplicity’s sake, I’ll use</i> <span class="note_Italic">kernel32.dll</span> <i>and</i> <span class="note_Italic">kernelbase.dll</span> <i>synonymously throughout this book.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_9" aria-label="9"/>While legitimate Windows programs heavily rely on the underlying WinAPI and Native API to function, illegitimate software (that is, malware) also uses these functionalities, as you’ll see in later chapters. For now, let’s take an in-depth look at processes.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h-13"/><samp class="SANS_Futura_Std_Bold_B_11">Process Internals</samp></h3>&#13;
<p class="TNI1">Processes are quite complex data structures that point to additional data structures. This network provides the underlying information that Windows relies on to efficiently manage and coordinate the many processes running on a system at any point in time.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-14"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">EPROCESS Structures</samp></h4>&#13;
<p class="TNI1">Even though most processes exposed to the end user run in user mode, they’re represented in kernel address space as objects called <i>EPROCESS</i> structures. Each process has its own EPROCESS structure that contains pointers to elements like the list of handles the process has open, as well as its <i>Process Environment Block (PEB)</i>, which is a structure that contains vital information about the process. EPROCESS structures consist of a doubly linked list; that is, they form a chain in which each structure links to the previous and subsequent structures. EPROCESS structure members called <i>forward links (flinks)</i> are pointers to the next EPROCESS structure in the chain, while <i>backward links (blinks)</i> point to the previous one. <a href="chapter1.xhtml#fig1-4">Figure 1-4</a> illustrates a simplified version of this chain.</p>&#13;
<figure class="IMG"><img class="img100" id="fig1-4" src="../images/fig1-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-4: An EPROCESS structure’s doubly linked list chain</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The EPROCESS structure contains many other data elements and pointers that are mostly outside the scope of this book. The key takeaway here is that each user-mode process in Windows is linked to an EPROCESS structure running in kernel mode. This will be important later on, when we discuss topics like direct kernel object manipulation (DKOM) in <span class="Xref"><a href="part4.xhtml">Part IV</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_10" aria-label="10"/>&#13;
<h4 class="H2" id="sec8"><span id="h-15"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Environment Blocks</samp></h4>&#13;
<p class="TNI1">The PEB memory structure contains information about a running process that the kernel needs to communicate with that process, as well as information for interprocess communication. Each running process has its own PEB that’s stored in user-mode address space inside that process memory. <a href="chapter1.xhtml#tab1-1">Table 1-1</a> lists some of the important data the PEB structure contains. The offset of each structure member is shown for both x86 and x64 architectures.</p>&#13;
<p class="TT" id="tab1-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">PEB Structure Offsets and Data</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Offset (x86)</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Offset (x64)</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Data</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x002</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x002</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp> <samp class="SANS_Futura_Std_Book_11">value, which indicates whether the process is running under the context of a debugger. (This will be important in <a href="chapter10.xhtml">Chapter 10</a>.)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x008</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x10</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Stores the base address of the process executable in memory.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x00C</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x18</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Stores information on the modules and libraries the process has loaded.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x018</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x30</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Stores information about the process’s memory heap.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x064</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0xB8</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NumberOfProcessors</samp> <samp class="SANS_Futura_Std_Book_11">value, which indicates the number of processors the system has.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">You don’t need to memorize all the elements of a PEB, but it’s important to have a basic understanding of it because I’ll be referencing it throughout the book.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h-16"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Thread Environment Blocks</samp></h4>&#13;
<p class="TNI1">A <i>Thread Environment Block (TEB)</i>, sometimes referred to as the <i>Thread Information Block (TIB)</i>, contains information for a process’s running threads. Much like the PEB, it’s simply a data structure that stores critical information for each thread and is stored in the memory address space of the process that owns the thread. <a href="chapter1.xhtml#tab1-2">Table 1-2</a> lists some of the most interesting elements in the TEB.</p>&#13;
<p class="TT" id="tab1-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 1-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">TEB Structure Offsets and Data</samp></p>&#13;
<p class="Anchor"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_11" aria-label="11"/></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Offset (x86)</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Offset (x64)</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Data</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">FS:[0x00]</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">GS:[0x00]</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Stores the current structured exception handler (SEH) frame. (SEH will be covered in more detail in <a href="chapter10.xhtml">Chapters 10</a> and <a href="chapter11.xhtml">11</a>.)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">FS:[0x04]</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">GS:[0x08]</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Points to the base of the thread’s stack (see the next section).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">FS:[0x18]</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">GS:[0x30]</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Points to the TEB itself.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">FS:[0x20]</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">GS:[0x40]</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">process ID (PID)</samp> <samp class="SANS_Futura_Std_Book_11">of the thread’s owning process.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">FS:[0x24]</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">GS:[0x48]</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">thread ID (TID)</samp> <samp class="SANS_Futura_Std_Book_11">of the current thread.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">FS:[0x30]</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">GS:[0x60]</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Points to the PEB of the thread’s owning process.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">FS:[0xE10]</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">GS:[0x1480]</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Points to thread-local storage (TLS) information.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>	</i><span class="note_Italic">Thread-local storage (TLS)</span> <i>is used to store variables and other information across different threads. We’ll talk about how malware can abuse TLS to stealthily execute malicious code in <a href="chapter11.xhtml">Chapter 11</a>.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-17"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Stacks and Heaps</samp></h4>&#13;
<p class="TNI1">A process can have multiple active threads, each of which has its own memory stack. The <i>stack</i> is where the thread stores temporary data such as variables, pointers, and other objects that will inevitably be destroyed once the thread completes execution and is terminated. Since the stack is so volatile and temporary, programs sometimes need a more “permanent” solution for data storage. This is where heaps come in.</p>&#13;
<p class="TX">A <i>heap</i> is a variably sized region of memory that a program dynamically allocates at runtime. Heaps are often used to store objects and data structures that are too large for the stack. They’re also used to store global variables and data that persist and can be used by multiple functions in the same program. It’s important to note that while the stack is largely managed by the OS, heaps are managed by the program itself. If a program doesn’t implement heap memory management techniques well, it can cause stability issues.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h-18"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Virtual Memory</samp></h4>&#13;
<p class="TNI1">Each process running in Windows has a number of virtual memory regions assigned to it that are mapped to physical memory (or RAM). It’s important to understand the distinction between virtual and physical memory. <i>Physical memory</i> is the real, tangible hardware memory that is installed in your system. If you have a computer with 8GB of RAM, then you have 8GB of physical memory that all processes running on your system share. This poses a problem in that any process can interfere with any other process on the system (either inadvertently, such as in the case of a crash, or purposefully), with unwanted side effects. This is where virtual memory comes in.</p>&#13;
<p class="TX"><i>Virtual memory</i> is a sort of barrier between physical memory and process memory address space. When a process is started, it’s assigned an allotment of virtual memory that is mapped to physical memory via the <i>page table</i>. The page table keeps track of where different segments of virtual memory are physically located in RAM. <a href="chapter1.xhtml#fig1-5">Figure 1-5</a> illustrates the relationship between virtual memory, the page table, and physical memory.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_12" aria-label="12"/>&#13;
<figure class="IMG"><img class="img100" id="fig1-5" src="../images/fig1-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-5: Virtual memory mapped to physical memory via the page table</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Each block containing an ellipsis (...) represents a memory address range, or region. Each region of memory is mapped to the page table.</p>&#13;
<p class="TX">It’s quite possible for a system to have less RAM than what is required by all its running processes. To help manage this, virtual memory can be <i>paged out</i>, meaning that it will be temporarily stored on the hard disk when unused. If a process requires access to that virtual memory region again, the memory can be read from disk and remapped to physical memory.</p>&#13;
<p class="TX">You can view the virtual memory of a process using a process analysis tool such as Process Hacker (<a href="https://processhacker.sourceforge.io"><i>https://<wbr/>processhacker<wbr/>.sourceforge<wbr/>.io</i></a>). To do this, start a program (such as <i>Calculator.exe</i>), open Process Hacker, and double-click the process you wish to explore. <a href="chapter1.xhtml#fig1-6">Figure 1-6</a> shows the Memory tab of a process in Process Hacker.</p>&#13;
<figure class="IMG"><img class="img100" id="fig1-6" src="../images/fig1-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-6: Viewing the virtual memory of a process in Process Hacker</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The Base address column contains the base memory address of each virtual memory region assigned to <i>Calculator.exe</i>. The Type column contains the memory type for each region, the Size column gives the allocation size of each region, and the Protection column lists the protection status of the region.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_13" aria-label="13"/>Each virtual memory region is typically assigned one of three common memory types:</p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>Image (IMG)</i> memory usually contains executable files or libraries that have been mapped into memory via the standard Windows loader mechanism (described shortly).</li>&#13;
<li class="BL"><i>Mapped (MAP)</i> memory often contains either files that have been mapped into memory from the disk or other data used by the application running inside the process.</li>&#13;
<li class="BL"><i>Private (PRV)</i> memory is typically allocated via <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> and similar memory allocation functions.</li>&#13;
</ul>&#13;
<p class="TX">Furthermore, each memory region can be either committed or reserved. <i>Committed</i> regions are being actively used and have been mapped to physical memory. <i>Reserved</i> regions are reserved for the process but aren’t in active use and haven’t yet been mapped to RAM.</p>&#13;
<p class="TX">Now let’s dig into the details of how Windows executables (more specifically, Portable Executable files) work internally.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h-19"/><samp class="SANS_Futura_Std_Bold_B_11">The PE File Format</samp></h3>&#13;
<p class="TNI1">Microsoft created the <i>PE (Portable Executable)</i> file format for executable files that run inside the Windows OS. The PE file format contains everything the Windows PE loader needs to execute the embedded code. Understanding the PE format is critical to understanding how malware works, so in this section we’ll look in depth at the structures the PE format comprises.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>	I’ll refer to both x86 and x64 PE files as PE files. In reality, however, x64 has its own version of the PE format called</i> <span class="note_Italic">PE32+</span><i>. Since PE32+ differs only slightly from its x86 equivalent, I won’t cover it separately.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h-20"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Headers and Sections</samp></h4>&#13;
<p class="TNI1">The PE file format contains several <i>headers</i>: metadata or other information at the top of a file, telling the OS and other software what to do with its contents. The <i>DOS header</i> contains information required by MS-DOS and very early versions of Windows, and it mostly exists for legacy reasons. The <i>PE header</i> contains information used by the Windows PE loader, such as the CPU architecture the executable was compiled to run on and metadata like the file’s compilation timestamp. The PE header also includes the <i>optional header</i>, which indicates important information such as the PE’s base memory address (the memory address at which the PE will be mapped into memory), the size of the code inside the executable, and the target OS that the executable will run on. The “optional” header is in fact no longer optional in modern Windows systems.</p>&#13;
<p class="TX">The PE file also includes the <i>section header</i>, which contains metadata related to each of the file’s sections (where the actual file contents are <span role="doc-pagebreak" epub:type="pagebreak" id="pg_14" aria-label="14"/>stored), such as the section’s size, address, and other characteristics. Finally, most PE files contain at least a few of the following sections:</p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table" scope="col"><p class="RunInPara0"><b><i>.text</i></b></p></th>&#13;
<th class="Basic-Table" scope="col"><p class="RunInPara0">The file’s main executable code</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="RunInPara0"><b><i>.rdata</i></b></p></td>&#13;
<td class="Basic-Table"><p class="RunInPara0">Read-only data, such as static variables and constants</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="RunInPara0"><b><i>.bss</i></b></p></td>&#13;
<td class="Basic-Table"><p class="RunInPara0">Uninitialized data, such as variables that haven’t been assigned a value yet</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="RunInPara0"><b><i>.data</i></b></p></td>&#13;
<td class="Basic-Table"><p class="RunInPara0">Variables not embedded in the .<i>rdata</i> and <i>.bss</i> sections, such as global variables</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="RunInPara0"><b><i>.rsrc</i></b></p></td>&#13;
<td class="Basic-Table"><p class="RunInPara0">Assets that will be loaded by the executable at runtime, such as images, fonts, and other supporting files</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="RunInPara0"><b><i>.idata</i></b></p></td>&#13;
<td class="Basic-Table"><p class="RunInPara0">The imports address table (see the next section)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="RunInPara0"><b><i>.edata</i></b></p></td>&#13;
<td class="Basic-Table"><p class="RunInPara0">The exports address table (see the next section)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h-21"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Imports and Exports</samp></h4>&#13;
<p class="TNI1">The <i>.idata</i> and <i>.edata</i> sections are two of the most important components of a PE file. The <i>.idata</i> section contains information about the functions that the PE file will import at runtime. Once the PE file is executed, the program will load the libraries and functions referenced here into memory and build its <i>import address table (IAT)</i>, which maps the imported Windows API functions to their addresses in memory.</p>&#13;
<p class="TX">The <i>.edata</i> section contains information about the functions that the PE file exports to other programs, which they can then import and load into memory for their own use. It’s common for DLL executable files, for example, to contain a list of exported functions. As with imports, exports have their own table called the <i>export address table</i>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In practice, however, both the</i> <span class="note_Italic">.edata</span> <i>and</i> <span class="note_Italic">.idata</span> <i>sections are often contained in the</i> <span class="note_Italic">.rdata</span> <i>section.</i></p>&#13;
<p class="TX">Now let’s take a look at the way Windows loads PE files into memory. The program execution process is a fundamental concept for Windows malware analysis and will tie together all of the concepts you’ve seen so far.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h-22"/><samp class="SANS_Futura_Std_Bold_B_11">The Windows PE Loading Process</samp></h3>&#13;
<p class="TNI1">When you launch an executable file like Firefox in Windows, here’s what happens:</p>&#13;
<p class="ListNumber1">  1.  Windows creates a new EPROCESS data structure for the Firefox program and assigns a new process ID.</p>&#13;
<p class="ListNumber">  2.  Windows initializes the virtual memory required for the process, creates the PEB structure, and loads two libraries that nearly all Windows processes require: <i>ntdll.dll</i> and <i>kernel32.dll</i>. It then prepares to load Firefox’s PE file by initializing the PE loader.</p>&#13;
<p class="ListNumber"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_15" aria-label="15"/>  3.  The PE loader parses the DOS, PE, and optional headers of the PE file to gather all information required to successfully execute the file.</p>&#13;
<p class="ListNumber">  4.  The PE loader parses the section header to prepare for mapping these sections into memory. The PE loader maps each section into virtual memory within the new process.</p>&#13;
<p class="ListNumber">  5.  The PE loader loads all libraries referenced in the imports (usually <i>.idata</i> or <i>.rdata</i>) section and resolves all addresses for the functions required. All addresses are then stored in the IAT inside the process.</p>&#13;
<p class="ListNumber2">  6.  A new thread is created inside the current process, and the loader executes the first bytes of code in the executable (usually in the <i>.text</i> section).</p>&#13;
<p class="TX"><a href="chapter1.xhtml#fig1-7">Figure 1-7</a> illustrates a PE file being loaded and mapped into virtual memory.</p>&#13;
<figure class="IMG"><img class="img60" id="fig1-7" src="../images/fig1-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-7: Loading and mapping a PE file into virtual memory inside a process</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Each section in the PE file is individually mapped into memory, but it appears expanded in virtual memory as there are often regions of memory between each section.</p>&#13;
<aside class="box" aria-label="box-1">&#13;
<p class="BoxTitle" id="box-1"><samp class="SANS_Dogma_OT_Bold_B_11">ADDRESS SPACE LAYOUT RANDOMIZATION</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Address space layout randomization (ASLR)</samp> <samp class="SANS_Futura_Std_Book_11">is a technique used to thwart attacks such as memory corruption.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Memory corruption</samp> <samp class="SANS_Futura_Std_Book_11">can occur when a program controlled by an attacker writes malicious code into a memory region that would normally be outside the program’s scope (such as another process). This can cause</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_16" aria-label="16"/><samp class="SANS_Futura_Std_Book_11">the program or OS to crash, or worse, to grant the attacker control of the system. Memory corruption attacks take advantage of the fact that Windows loads executables and libraries into memory at foreseeable addresses; that is, attackers already know where the Windows loader will map executables and libraries into memory and will try to corrupt this memory to run malicious code.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">ASLR randomizes the locations in memory where these executables and libraries are loaded, making the attacker’s life a lot more difficult. ASLR is an in-depth topic, and much research has been dedicated to both implementing and bypassing it. I will revisit this concept later, but a basic understanding of ASLR’s functionality is all that’s required for this book.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h-23"/><samp class="SANS_Futura_Std_Bold_B_11">The Registry</samp></h3>&#13;
<p class="TNI1">The final Windows concept to discuss is the <i>registry</i>, which is simply a database that the OS and other installed applications use to store configurations and settings. The registry stores data hierarchically, with several primary root keys or <i>hives</i>, each containing additional keys (which you can think of as directories), each of which in turn stores more keys or values.</p>&#13;
<p class="TX"><i>Values</i> are the actual configuration for the settings. For example, the root key <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp> contains a subkey called <samp class="SANS_TheSansMonoCd_W5Regular_11">Control Panel</samp>, which itself contains a subkey called <samp class="SANS_TheSansMonoCd_W5Regular_11">Mouse</samp>. <samp class="SANS_TheSansMonoCd_W5Regular_11">Mouse</samp> contains multiple values, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">MouseSpeed</samp>, which stores the mouse speed configuration for the currently logged-in user. This registry key path can be expressed just like a file or directory path in Windows: <i>HKEY_CURRENT_USER\Control Panel\Mouse\MouseSpeed</i>.</p>&#13;
<p class="TX">These are five of the most important hives in the registry:</p>&#13;
<p class="ListHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_LOCAL_MACHINE (HKLM)</samp></p>&#13;
<p class="ListPlainFirst">Values specific to the system, such as low-level OS and hardware configurations, security policy and account settings, and settings for various software installed.</p>&#13;
<p class="ListHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CURRENT_USER (</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKCU)</samp></p>&#13;
<p class="ListPlainFirst">Values related to user settings and system configurations, like sound, mouse, keyboard, network, and printer settings.</p>&#13;
<p class="ListHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_USERS (HKU)</samp></p>&#13;
<p class="ListPlainFirst">Values related to user settings for each user with an account on the system. Under this root key, there are several other subkeys starting with <samp class="SANS_TheSansMonoCd_W5Regular_11">S</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp>, for example). Each subkey represents the identifier for a user account on the system and stores configuration information for each user.</p>&#13;
<p class="ListHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CURRENT_CONFIG (HKCC)</samp></p>&#13;
<p class="ListPlainFirst">Pointers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp> key for the hardware profile currently in use by the logged-in user. This key is less important for our purposes, as everything of value is stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp> key.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_17" aria-label="17"/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CLASSES_ROOT (HKCR)</samp></p>&#13;
<p class="ListPlainFirst">Information related to registered applications, such as file associations, which map file types to the application that can process them. (For example, <i>.doc</i> files should open in Microsoft Word.)</p>&#13;
<div class="spc"/>&#13;
<p class="TX">Registry hives are stored on the hard disk as files. When Windows boots up, these files are loaded into memory, and the registry is built. Any changes to the registry after the system boots up are stored in memory and not directly on disk. This is why some malware is able to store malicious code and configurations in the registry without necessarily touching the disk.</p>&#13;
<p class="TX">Finally, Windows has a built-in utility called the Registry Editor (<i>Regedit</i>), shown in <a href="chapter1.xhtml#fig1-8">Figure 1-8</a>, that all malware analysts should be intimately familiar with.</p>&#13;
<figure class="IMG"><img class="img100" id="fig1-8" src="../images/fig1-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-8: The Registry Editor tool in Windows</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Regedit allows you to inspect and modify each registry key and value on the system, which is useful for understanding how the registry works. Regedit can also be useful for investigating how malware may have altered this data.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1" id="sec17"><span id="h-24"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">This chapter discussed some of the fundamental concepts, objects, and structures used by the Windows operating system and explored the architecture of Windows at a high level. We’ll return to these concepts throughout the book as we look at ways in which attackers can exploit some of these features to execute malicious code while evading defenses. In the next chapter, we’ll walk through the basics of the malware triage and behavioral- analysis process to lay the groundwork for our investigations in later chapters.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>