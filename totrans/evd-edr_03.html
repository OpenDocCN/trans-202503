<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch3">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch3">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_33" aria-label=" Page 33. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">PROCESS- AND THREAD-CREATION NOTIFICATIONS</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">Most modern EDR solutions rely heavily on functionality supplied through their <i>kernel-mode driver</i>, which is the sensor component running in a privileged layer of the operating system, beneath the user mode. These drivers give developers the ability to leverage features that are only available inside the kernel, supplying EDRs with many of their preventive features and telemetry.</p>&#13;
<p class="TX">While vendors can implement a vast number of security-relevant features in their drivers, the most common one is <i>notification callback routines</i>. These are internal routines that take actions when a designated system event occurs.</p>&#13;
<p class="TX">In the <span class="Xref">next three chapters</span>, we’ll discuss how modern EDRs leverage notification callback routines to gain valuable insight into system events from the kernel. We’ll also cover the evasion techniques relevant to each type of notification and its related callback routines. This chapter focuses <span role="doc-pagebreak" epub:type="pagebreak" id="pg_34" aria-label=" Page 34. "/>on two types of callback routines used very often in EDRs: those related to process creation and thread creation.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-31"/><samp class="SANS_Futura_Std_Bold_B_11">How Notification Callback Routines Work</samp></h2>&#13;
<p class="TNI">One of the most powerful features of drivers in the context of EDRs is the ability to be notified when a system event occurs. These system events might include creating or terminating new processes and threads, requesting to duplicate processes and threads, loading images, taking actions in the registry, or requesting a shutdown of the system. For example, a developer may want to know whether a process attempts to open a new handle to <i>lsass.exe</i>, because this is a core component of most credential-dumping techniques.</p>&#13;
<p class="TX">To do this, the driver registers callback routines, which essentially just say, “Let me know if this type of event occurs on the system so I can do something.” As a result of these notifications, the driver can take action. Sometimes it might simply collect telemetry from the event notification. Alternatively, it might opt to do something like provide only partial access to the sensitive process, such as by returning a handle with a limited-access mask (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_QUERY_LIMITED_INFORMATION</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>).</p>&#13;
<p class="TX">Callback routines may be either <i>pre-operation</i>, occurring before the event completes, or <i>post-operation</i>, occurring after the operation. Pre-operation callbacks are more common in EDRs, as they give the driver the ability to interfere with the event or prevent it from completing, as well as other side benefits that we’ll discuss in this chapter. Post-operation callbacks are useful too, as they can provide information about the result of the system event, but they have some drawbacks. The largest of these is the fact that they’re often executed in an arbitrary thread context, making it difficult for an EDR to collect information about the process or thread that started the operation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h-32"/><samp class="SANS_Futura_Std_Bold_B_11">Process Notifications</samp></h2>&#13;
<p class="TNI">Callback routines can notify drivers whenever a process is created or terminated on the system. These notifications happen as an integral part of the process creation or termination. You can see this in <a href="#list3-1">Listing 3-1</a>, which shows the call stack for creation of a child process of <i>cmd.exe</i>, <i>notepad.exe</i>, that led to the notification of registered callback routines.</p>&#13;
<p class="TX">To obtain this call stack, use WinDbg to set a breakpoint (<samp class="SANS_TheSansMonoCd_W5Regular_11">bp</samp>) on <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCallProcessNotifyRoutines()</samp>, the internal kernel function that notifies drivers with registered callbacks of process-creation events. When the breakpoint is hit, the <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> command returns the call stack for the process under which the break occurred.</p>&#13;
<pre id="list3-1"><code>2: kd&gt; <b>bp nt!PspCallProcessNotifyRoutines</b>&#13;
2: kd&gt; <b>g</b>&#13;
Breakpoint 0 hit&#13;
nt!PspCallProcessNotifyRoutines:<span role="doc-pagebreak" epub:type="pagebreak" id="pg_35" aria-label=" Page 35. "/>&#13;
fffff803`4940283c 48895c2410      mov      qword ptr [rsp+10h],rbx&#13;
1: kd&gt; <b>k</b>&#13;
 # Child-SP          RetAddr                Call Site&#13;
00 ffffee8e`a7005cf8 fffff803`494ae9c2      nt!PspCallProcessNotifyRoutines&#13;
01 ffffee8e`a7005d00 fffff803`4941577d      nt!PspInsertThread+0x68e&#13;
02 ffffee8e`a7005dc0 fffff803`49208cb5      nt!NtCreateUserProcess+0xddd&#13;
03 ffffee8e`a7006a90 00007ffc`74b4e664      nt!KiSystemServiceCopyEnd+0x25&#13;
04 000000d7`6215dcf8 00007ffc`72478e73      ntdll!NtCreateUserProcess+0x14&#13;
05 000000d7`6215dd00 00007ffc`724771a6      KERNELBASE!CreateProcessInternalW+0xfe3&#13;
06 000000d7`6215f2d0 00007ffc`747acbb4      KERNELBASE!CreateProcessW+0x66&#13;
07 000000d7`6215f340 00007ff6`f4184486      KERNEL32!CreateProcessWStub+0x54&#13;
08 000000d7`6215f3a0 00007ff6`f4185b7f      cmd!ExecPgm+0x262&#13;
09 000000d7`6215f5e0 00007ff6`f417c9bd      cmd!ECWork+0xa7&#13;
0a 000000d7`6215f840 00007ff6`f417bea1      cmd!FindFixAndRun+0x39d&#13;
0b 000000d7`6215fce0 00007ff6`f418ebf0      cmd!Dispatch+0xa1&#13;
0c 000000d7`6215fd70 00007ff6`f4188ecd      cmd!main+0xb418&#13;
0d 000000d7`6215fe10 00007ffc`747a7034      cmd!__mainCRTStartup+0x14d&#13;
0e 000000d7`6215fe50 00007ffc`74b02651      KERNEL32!BaseThreadInitThunk+0x14&#13;
0f 000000d7`6215fe80 00000000`00000000      ntdll!RtlUserThreadStart+0x21</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-1: A process-creation call stack</span></p>&#13;
<p class="TX">Whenever a user wants to run an executable, <i>cmd.exe</i> calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd!ExecPgm()</samp> function. In this call stack, we can see this function calling the stub used to create a new process (at output line 07). This stub ends up making the syscall for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateUserProcess()</samp>, where control is transitioned to the kernel (at 04).</p>&#13;
<p class="TX">Now notice that, inside the kernel, another function is executed (at 00). This function is responsible for letting every registered callback know that a process is being created.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h-33"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a Process Callback Routine</samp></h3>&#13;
<p class="TNI">To register process callback routines, EDRs use one of the following two functions: <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateProcessNotifyRoutineEx()</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateProcessNotifyRoutineEx2()</samp>. The latter can provide notifications about non-Win32 subsystem processes. These functions take a pointer to a callback function that will perform some action whenever a new process is created or terminated. <a href="#list3-2">Listing 3-2</a> demonstrates how a callback function is registered.</p>&#13;
<pre id="list3-2"><code>NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING pRegPath)&#13;
{&#13;
    NTSTATUS status = STATUS_SUCCESS;&#13;
    <var>--snip--</var>&#13;
&#13;
    status = <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> PsSetCreateProcessNotifyRoutineEx2(&#13;
        PsCreateProcessNotifySubsystems,&#13;
        (PVOID)ProcessNotifyCallbackRoutine,&#13;
        FALSE&#13;
    );&#13;
&#13;
    <var>--snip--</var>&#13;
}<span role="doc-pagebreak" epub:type="pagebreak" id="pg_36" aria-label=" Page 36. "/>&#13;
&#13;
<span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> void ProcessNotifyCallbackRoutine(&#13;
      PEPROCESS pProcess,&#13;
      HANDLE hPid,&#13;
      PPS_CREATE_NOTIFY_INFO pInfo)&#13;
{&#13;
      if (pInfo)&#13;
      {&#13;
          <var>--snip--</var>&#13;
      }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-2: Registering a process-creation callback routine</span></p>&#13;
<p class="TX">This code registers the callback routine <span class="CodeAnnotation" aria-label="annotation1">❶</span> and passes three arguments to the registration function. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">PsCreateProcessNotifySubsystems</samp>, indicates the type of process notification that is being registered. At the time of this writing, “subsystems” is the only type that Microsoft documents. This value tells the system that the callback routine should be invoked for processes created across all subsystems, including Win32 and Windows Subsystem for Linux (WSL).</p>&#13;
<p class="TX">The next argument defines the entry point of the callback routine to be executed when the process is created. In our example, the code points to the internal <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessNotifyCallbackRoutine()</samp> function. When process creation occurs, this callback function will receive information about the event, which we’ll discuss momentarily.</p>&#13;
<p class="TX">The third argument is a Boolean value indicating whether the callback routine should be removed. Because we’re registering the routine in this example, the value is <samp class="SANS_TheSansMonoCd_W5Regular_11">FALSE</samp>. When we unload the driver, we’d set this to <samp class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp> to remove the callback from the system. After registering the callback routine, we define the callback function itself <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h-34"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing the Callback Routines Registered on a System</samp></h3>&#13;
<p class="TNI">You can use WinDbg to see a list of the process callback routines on your system. When a new callback routine is registered, a pointer to the routine is added to an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">EX_FAST_REF</samp> structures, which are 16-byte aligned pointers stored in an array at <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCreateProcessNotifyRoutine</samp>, as shown in <a href="#list3-3">Listing 3-3</a>.</p>&#13;
<pre id="list3-3"><code>1: kd&gt; <b>dq nt!PspCreateProcessNotifyRoutine</b>&#13;
fffff803`49aec4e0  ffff9b8f`91c5063f ffff9b8f`91df6c0f&#13;
fffff803`49aec4f0  ffff9b8f`9336fcff ffff9b8f`9336fedf&#13;
fffff803`49aec500  ffff9b8f`9349b3ff ffff9b8f`9353a49f&#13;
fffff803`49aec510  ffff9b8f`9353acdf ffff9b8f`9353a9af&#13;
fffff803`49aec520  ffff9b8f`980781cf 00000000`00000000&#13;
fffff803`49aec530  00000000`00000000 00000000`00000000&#13;
fffff803`49aec540  00000000`00000000 00000000`00000000&#13;
fffff803`49aec550  00000000`00000000 00000000`00000000</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-3: An array of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EX_FAST_REF</samp> structures containing the addresses of process- creation callback routines</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_37" aria-label=" Page 37. "/><a href="#list3-4">Listing 3-4</a> shows a way of iterating over this array of <samp class="SANS_TheSansMonoCd_W5Regular_11">EX_FAST_REF</samp> structures to enumerate drivers that implement process-notification callbacks.</p>&#13;
<pre id="list3-4"><code>1: kd&gt; <b>dx ((void**[0x40])&amp;nt!PspCreateProcessNotifyRoutine)</b>&#13;
<b>.Where(a =&gt; a != 0)</b>&#13;
<b>.Select(a =&gt; @$getsym(@$getCallbackRoutine(a).Function))</b>&#13;
  [0]         : nt!ViCreateProcessCallback (fffff803`4915a2a0)&#13;
  [1]         : cng!CngCreateProcessNotifyRoutine (fffff803`4a4e6dd0)&#13;
  [2]         : WdFilter+0x45e00 (fffff803`4ade5e00)&#13;
  [3]         : ksecdd!KsecCreateProcessNotifyRoutine (fffff803`4a33ba40)&#13;
  [4]         : tcpip!CreateProcessNotifyRoutineEx (fffff803`4b3f1f90)&#13;
  [5]         : iorate!IoRateProcessCreateNotify (fffff803`4b95d930)&#13;
  [6]         : CI!I_PEProcessNotify (fffff803`4a46a270)&#13;
  [7]         : dxgkrnl!DxgkProcessNotify (fffff803`4c116610)&#13;
  [8]         : peauth+0x43ce0 (fffff803`4d873ce0)</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-4: Enumerating registered process-creation callbacks</span></p>&#13;
<p class="TX">Here, we can see some of the routines registered on a default system. Note that some of these callbacks do not perform security functions. For instance, the one beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">tcpip</samp> is used in the TCP/IP driver. However, we do see that Microsoft Defender has a callback registered: <samp class="SANS_TheSansMonoCd_W5Regular_11">WdFilter</samp>+<samp class="SANS_TheSansMonoCd_W5Regular_11">0x45e00</samp>. (Microsoft doesn’t publish full symbols for the <i>WdFilter.sys</i> driver.) Using this technique, we could locate an EDR’s callback routine without needing to reverse engineer Microsoft’s driver.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h-35"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Collecting Information from Process Creation</samp></h3>&#13;
<p class="TNI">Once an EDR registers its callback routine, how does it access information? Well, when a new process is created, a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE_NOTIFY_INFO</samp> structure is passed to the callback. You can see the structure defined in <a href="#list3-5">Listing 3-5</a>.</p>&#13;
<pre id="list3-5"><code>typedef struct _PS_CREATE_NOTIFY_INFO {&#13;
  SIZE_T              Size;&#13;
  union {&#13;
    ULONG Flags;&#13;
    struct {&#13;
      ULONG FileOpenNameAvailable : 1;&#13;
      ULONG IsSubsystemProcess : 1;&#13;
      ULONG Reserved : 30;&#13;
    };&#13;
  };&#13;
  HANDLE              ParentProcessId;&#13;
  CLIENT_ID           CreatingThreadId;&#13;
  struct _FILE_OBJECT *FileObject;&#13;
  PCUNICODE_STRING    ImageFileName;&#13;
  PCUNICODE_STRING    CommandLine;&#13;
  NTSTATUS            CreationStatus;&#13;
} PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-5: The definition of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_CREATE_NOTIFY_INFO</samp> structure</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_38" aria-label=" Page 38. "/>This structure contains a significant amount of valuable data relating to process-creation events on the system. This data includes:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ParentProcessId</samp>   The parent process of the newly created process. This isn’t necessarily the one that created the new process.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreatingThreadId</samp>   Handles to the unique thread and process responsible for creating the new process.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FileObject</samp>   A pointer to the process’s executable file object (the image on disk).</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ImageFileName</samp>   A pointer to a string containing the path to the newly created process’s executable file.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CommandLine</samp>   The command line arguments passed to the creating process.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FileOpenNameAvailable</samp>   A value that specifies whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp> member matches the filename used to open the new process’s executable file.</p>&#13;
<p class="TX">One way that EDRs commonly interact with the telemetry returned from this notification is through Sysmon’s Event ID 1, the event for process creation, shown in <a href="#fig3-1">Figure 3-1</a>.</p>&#13;
<figure class="IMG"><img id="fig3-1" class="img60" src="../images/Figure3-1.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: Sysmon Event ID 1 showing process creation</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this event, we can see some of the information from the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE _NOTIFY_INFO</samp> structure passed to Sysmon’s callback routine. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp> properties in the event translate to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp> members of the structure, respectively.</p>&#13;
<p class="TX">You may be wondering why there are so many more properties in this event than there are in the structure received by the callback. The driver collects these supplemental pieces of information by investigating the context of the thread under which the event was generated and expanding on members <span role="doc-pagebreak" epub:type="pagebreak" id="pg_39" aria-label=" Page 39. "/>of the structure. For instance, if we know the ID of the process’s parent, we can easily find the parent’s image path to populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentImage</samp> property.</p>&#13;
<p class="TX">By leveraging the data collected from this event and the associated structure, EDRs can also create internal mappings of process attributes and relationships in order to detect suspicious activity, such as Microsoft Word spawning a <i>powershell.exe</i> child. This data could also provide the agent with useful context for determining whether other activity is malicious. For example, the agent could feed process command line arguments into a machine learning model to figure out whether the command’s invocation is unusual in the environment.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h2 class="H1" id="sec6"><span id="h-36"/><samp class="SANS_Futura_Std_Bold_B_11">Thread Notifications</samp></h2>&#13;
<p class="TNI">Thread-creation notifications are somewhat less valuable than process-creation events. They work relatively similarly, occurring during the creation process, but they receive less information. This is true despite the fact that thread creation happens substantially more often; after all, nearly every process supports multithreading, meaning that there will be more than one thread-creation notification for every process creation.</p>&#13;
<p class="TX">Although thread-creation callbacks pass far less data to the callback, they do provide the EDR with another datapoint against which detections can be built. Let’s explore them a little further.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h-37"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a Thread Callback Routine</samp></h3>&#13;
<p class="TNI">When a thread is created or terminated, the callback routine receives three pieces of data: the ID of the process to which the thread belongs, the unique thread ID, and a Boolean value indicating whether the thread is being created. <a href="#list3-6">Listing 3-6</a> shows how a driver would register a callback routine for thread-creation events.</p>&#13;
<pre id="list3-6"><code>NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING pRegPath)&#13;
{&#13;
    NTSTATUS status = STATUS_SUCCESS;&#13;
    <var>--snip--</var>&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> status = PsSetCreateThreadNotifyRoutine(ThreadNotifyCallbackRoutine);&#13;
    <var>--snip--</var>&#13;
}&#13;
&#13;
void ThreadNotifyCallbackRoutine(&#13;
    HANDLE hProcess,&#13;
    HANDLE hThread,&#13;
    BOOLEAN bCreate)&#13;
{&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if (bCreate)&#13;
    {&#13;
        <var>--snip--</var>&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-6: Registration of a thread-creation notification routine</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_40" aria-label=" Page 40. "/>As with process creation, an EDR can receive notifications about thread creation or termination via its driver by registering a thread-notification callback routine with either <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateThreadNotifyRoutine()</samp> or the extended <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateThreadNotifyRoutineEx()</samp>, which adds the ability to define the notification type.</p>&#13;
<p class="TX">This example driver first registers the callback routine <span class="CodeAnnotation" aria-label="annotation1">❶</span>, passing in a pointer to the internal callback function, which receives the same three pieces of data passed to process callback routines. If the Boolean indicating whether the thread is being created or terminated is <samp class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp>, the driver performs some action defined by the developer <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Otherwise, the callback would simply ignore the thread events, as thread-termination events (which occur when a thread completes its execution and returns) are generally less valuable for security monitoring.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h-38"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Remote Thread Creation</samp></h3>&#13;
<p class="TNI">Despite providing less information than process-creation callbacks, thread-creation notifications offer the EDR data about something other callbacks can’t detect: remote thread creation. <i>Remote thread creation</i> occurs when one process creates a thread inside another process. This technique is core to a ton of attacker tradecraft, which often relies on changing the execution context (as in going from user 1 to user 2). <a href="#list3-7">Listing 3-7</a> shows how an EDR could detect this behavior with its thread-creation callback routine.</p>&#13;
<pre id="list3-7"><code>void ThreadNotifyCallbackRoutine(&#13;
    HANDLE hProcess,&#13;
    HANDLE hThread,&#13;
    BOOLEAN bCreate)&#13;
{&#13;
    if (bCreate)&#13;
    {&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if (PsGetCurrentProcessId() != hProcess)&#13;
        {&#13;
            <var>--snip--</var>&#13;
        }&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-7: Detecting remote thread creation</span></p>&#13;
<p class="TX">Because the notification executes in the context of the process creating the thread, developers can simply check whether the current process ID matches the one passed to the callback routine <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If not, the thread is being created remotely and should be investigated. That’s it: a huge capability, provided through one or two lines of code. It doesn’t get much better than that. You can see this feature implemented in real life through Sysmon’s Event ID 8, shown in <a href="#fig3-2">Figure 3-2</a>. Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">SourceProcessId</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetProcessId</samp> values differ.</p><span role="doc-pagebreak" epub:type="pagebreak" id="pg_41" aria-label=" Page 41. "/>&#13;
<figure class="IMG"><img id="fig3-2" class="img60" src="../images/Figure3-2.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: Sysmon Event ID 8 detecting remote thread creation</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Of course, remote thread creation happens under a number of legitimate circumstances. One example is child process creation. When a process is created, the first thread executes in the context of the parent process. To account for this, many EDRs simply disregard the first thread associated with a process.</p>&#13;
<p class="TX">Certain internal operating system components also perform legitimate remote thread creation. An example of this is Windows Error Reporting (<i>werfault.exe</i>). When an error has occurred on the system, the operating system spawns <i>werfault.exe</i> as a child of <i>svchost.exe</i> (specifically, the <i>WerSvc</i> service) and then injects into the faulting process.</p>&#13;
<p class="TX">Thus, the fact that a thread was created remotely doesn’t automatically make it malicious. To determine this, the EDR has to collect supplemental information, as shown in Sysmon Event ID 8.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h2 class="H1" id="sec9"><span id="h-39"/><samp class="SANS_Futura_Std_Bold_B_11">Evading Process- and Thread-Creation Callbacks</samp></h2>&#13;
<p class="TNI">Process and thread notifications have the most associated detections of all callback types. This is partly due to the fact that the information they provide is critical to most process-oriented detection strategies and is used by almost every commercial EDR product. They’re also generally the easiest to understand. This isn’t to say that they’re also easy to evade. However, there is no shortage of procedures we can follow to increase our chances of slipping through the cracks somewhere.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h-40"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Command Line Tampering</samp></h3>&#13;
<p class="TNI">Some of the most commonly monitored attributes of process-creation events are the command line arguments with which the process was invoked. Certain detection strategies are even built entirely around specific command line arguments associated with a known offensive tool or piece of malware.</p>&#13;
<p class="TX">EDRs can find arguments in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp> member of the structure passed to a process-creation callback routine. When a process is created, its command line arguments are stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp> field of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_42" aria-label=" Page 42. "/>its process environment block (PEB). This field contains a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_USER_PROCESS_PARAMETERS</samp> structure that contains, among other things, a <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp> with the parameters passed to the process at invocation. <a href="#list3-8">Listing 3-8</a> shows how we could manually retrieve a process’s command line arguments with WinDbg.</p>&#13;
<pre id="list3-8"><code>0:000&gt; <b>?? @$peb-&gt;ProcessParameters-&gt;CommandLine.Buffer</b>&#13;
wchar_t * 0x000001be`2f78290a&#13;
 "C:\Windows\System32\rundll32.exe ieadvpack.dll,RegisterOCX payload.exe"</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-8: Retrieving parameters from the PEB with WinDbg</span></p>&#13;
<p class="TX">In this example, we extract the parameters from the current process’s PEB by directly accessing the buffer member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>, which makes up the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp> field.</p>&#13;
<p class="TX">However, because the PEB resides in the process’s user-mode memory space and not in the kernel, a process can change attributes of its own PEB. Adam Chester’s “How to Argue like Cobalt Strike” blog post details how to modify the command line arguments for a process. Before we cover this technique, you should understand what it looks like when a normal program creates a child process. <a href="#list3-9">Listing 3-9</a> contains a simple example of this behavior.</p>&#13;
<pre id="list3-9"><code>void main()&#13;
{&#13;
    STARTUPINFOW si;&#13;
    ZeroMemory(&amp;si, sizeof(si));&#13;
    si.cb = sizeof(si);&#13;
&#13;
    PROCESS_INFORMATION pi;&#13;
    ZeroMemory(&amp;pi, sizeof(pi));&#13;
&#13;
    if (!CreateProcessW(&#13;
        L"C:\\Windows\\System32\\cmd.exe",&#13;
        <b>L"These are my sensitive arguments",</b>&#13;
        NULL, NULL, FALSE, 0,&#13;
        NULL, NULL, &amp;si, &amp;pi))&#13;
    {&#13;
        WaitForSingleObject(pi.hProcess, INFINITE);&#13;
    }&#13;
&#13;
    return;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-9: Typical child-process creation</span></p>&#13;
<p class="TX">This basic implementation spawns a child process of <i>cmd.exe</i> with the arguments “These are my sensitive arguments.” When the process is executed, any standard process-monitoring tool should see this child process and its unmodified arguments by reading them from the PEB. For example, in <a href="#fig3-3">Figure 3-3</a>, we use a tool called Process Hacker to extract command line parameters.</p><span role="doc-pagebreak" epub:type="pagebreak" id="pg_43" aria-label=" Page 43. "/>&#13;
<figure class="IMG"><img id="fig3-3" class="img70" src="../images/Figure3-3.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: Command line arguments retrieved from the PEB</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As expected, <i>cmd.exe</i> was spawned with our string of five arguments passed to it. Let’s keep this example in mind; it will serve as our benign baseline as we start trying to hide our malware.</p>&#13;
<p class="TX">Chester’s blog post describes the following process for modifying the command line arguments used to invoke a process. First, you create the child process in a suspended state using your malicious arguments. Next, you use <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationProcess()</samp> to get the address of the child process’s PEB, and you copy it by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!ReadProcessMemory()</samp>. You retrieve its <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp> field and overwrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp> represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp> member pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp> with spoofed arguments. Lastly, you resume the child process.</p>&#13;
<p class="TX">Let’s overwrite the original arguments from <a href="#list3-9">Listing 3-9</a> with the argument string “Spoofed arguments passed instead.” <a href="#list3-10">Listing 3-10</a> shows this behavior in action, with the updates in bold.</p>&#13;
<pre id="list3-10"><code>void main()&#13;
{&#13;
    <var>--snip--</var>&#13;
&#13;
    if (CreateProcessW(&#13;
        L"C:\\Windows\\System32\\cmd.exe",&#13;
        L"These are my sensitive arguments",&#13;
        NULL, NULL, FALSE,&#13;
        <b>CREATE_SUSPENDED,</b>&#13;
        NULL, NULL, &amp;si, &amp;pi))&#13;
    {&#13;
        <var>--snip--</var>&#13;
&#13;
        <b>LPCWSTR szNewArguments = L"Spoofed arguments passed instead";</b>&#13;
        SIZE_T ulArgumentLength = wcslen(szNewArguments) * sizeof(WCHAR);&#13;
&#13;
        if (<b>WriteProcessMemory(</b>&#13;
<b>            pi.hProcess,</b>&#13;
<b>            pParameters.CommandLine.Buffer,</b>&#13;
<b>            (PVOID)szNewArguments,</b>&#13;
<b>            ulArgumentLength,</b>&#13;
<b>            &amp;ulSize)</b>)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_44" aria-label=" Page 44. "/>&#13;
<b>            </b>{&#13;
                  <b>ResumeThread(pi.hThread);</b>&#13;
            }&#13;
      }&#13;
&#13;
<var>    --snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-10: Overwriting command line arguments</span></p>&#13;
<p class="TX">When we create our process, we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp> flag to the function to start it in a suspended state. Next, we need to get the address of the process’s parameters in the PEB. We’ve omitted this code from <a href="#list3-10">Listing 3-10</a> for brevity, but the way to do this is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationProcess()</samp>, passing in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessBasicInformation</samp> information class. This should return a <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_BASIC_INFORMATION</samp> structure that contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">PebBaseAddress</samp> member.</p>&#13;
<p class="TX">We can then read our child process’s PEB into a buffer that we allocate locally. Using this buffer, we extract the parameters and pass in the address of the PEB. Then we use <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp> to copy it into another local buffer. In our code, this final buffer is called <samp class="SANS_TheSansMonoCd_W5Regular_11">pParameters</samp> and is cast as a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_USER_PROCESS_PARAMETERS</samp> structure. We overwrite the existing parameters with a new string via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WriteProcessMemory()</samp>. Assuming that this all completed without error, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!ResumeThread()</samp> to allow our suspended child process to finish initialization and begin executing.</p>&#13;
<p class="TX">Process Hacker now shows the spoofed argument values, as you can see in <a href="#fig3-4">Figure 3-4</a>.</p>&#13;
<figure class="IMG"><img id="fig3-4" class="img70" src="../images/Figure3-4.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: Command line arguments overwritten with spoofed values</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">While this technique remains one of the more effective ways to evade detection based on suspicious command line arguments, it has a handful of limitations. One such limitation is that a process can’t change its own command line arguments. This means that if we don’t have control of the parent process, as in the case of an initial access payload, the process must execute with the original arguments. Additionally, the value used to overwrite the suspicious arguments in the PEB must be longer than the original value. If it is shorter, the overwrite will be incomplete, and portions of the suspicious arguments will remain. <a href="#fig3-5">Figure 3-5</a> shows this limitation in action.</p><span role="doc-pagebreak" epub:type="pagebreak" id="pg_45" aria-label=" Page 45. "/>&#13;
<figure class="IMG"><img id="fig3-5" class="img70" src="../images/Figure3-5.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: Command line arguments partially overwritten</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Here, we have shortened our arguments to the value “Spoofed arguments.” As you can see, it replaced only part of the original arguments. The inverse is also true: if the length of the spoofed value is greater than that of the original arguments, the spoofed arguments will be truncated.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h-41"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parent Process ID Spoofing</samp></h3>&#13;
<p class="TNI">Nearly every EDR has some way of correlating parent–child processes on the system. This allows the agent to identify suspicious process relationships, such as Microsoft Word spawning <i>rundll32.exe</i>, which could indicate an attacker’s initial access or their successful exploitation of a service.</p>&#13;
<p class="TX">Thus, in order to hide malicious behavior on the host, attackers often wish to spoof their current process’s parent. If we can trick an EDR into believing that our malicious process creation is actually normal, we’re substantially less likely to be detected. The most common way to accomplish this is by modifying the child’s process and thread attribute list, a technique popularized by Didier Stevens in 2009. This evasion relies on the fact that, on Windows, children inherit certain attributes from parent processes, such as the current working directory and environment variables. No dependencies exist between parent and child processes; therefore, we can specify a parent process somewhat arbitrarily, as this section will cover.</p>&#13;
<p class="TX">To better understand this strategy, let’s dig into process creation on Windows. The primary API used for this purpose is the aptly named <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp> API. This function is defined in <a href="#list3-11">Listing 3-11</a>.</p>&#13;
<pre id="list3-11"><code>BOOL CreateProcessW(&#13;
  LPCWSTR                lpApplicationName,&#13;
  LPWSTR                 lpCommandLine,&#13;
  LPSECURITY_ATTRIBUTES  lpProcessAttributes,&#13;
  LPSECURITY_ATTRIBUTES  lpThreadAttributes,&#13;
  BOOL                   bInheritHandles,&#13;
  DWORD                  dwCreationFlags,&#13;
  LPVOID                 lpEnvironment,&#13;
  LPCWSTR                lpCurrentDirectory,&#13;
  LPSTARTUPINFOW         lpStartupInfo,&#13;
  LPPROCESS_INFORMATION  lpProcessInformation&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-11: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!CreateProcess()</samp> API definition</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_46" aria-label=" Page 46. "/>The ninth parameter passed to this function is a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFO</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFOEX</samp> structure. The <samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFOEX</samp> structure, which is defined in <a href="#list3-12">Listing 3-12</a>, extends the basic startup information structure by adding a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_LIST</samp> structure.</p>&#13;
<pre id="list3-12"><code>typedef struct _STARTUPINFOEXA {&#13;
  STARTUPINFOA                 StartupInfo;&#13;
  LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;&#13;
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-12: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">STARTUPINFOEX</samp> structure definition</span></p>&#13;
<p class="TX">When creating our process, we can make a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!InitializeProcThreadAttributeList()</samp> to initialize the attribute list and then make a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!UpdateProcThreadAttribute()</samp> to modify it. This allows us to set custom attributes of the process to be created. When spoofing the parent process, we’re interested in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</samp> attribute, which indicates that a handle to the desired parent process is being passed. To get this handle, we must obtain a handle to the target process, by either opening a new one or leveraging an existing one.</p>&#13;
<p class="TX"><a href="#list3-13">Listing 3-13</a> shows an example of process spoofing to tie all these pieces together. We’ll modify the attributes of the Notepad utility so that VMware Tools appears to be its parent process.</p>&#13;
<pre id="list3-13"><code>Void SpoofParent() {&#13;
    PCHAR szChildProcess = <b>"notepad"</b>;&#13;
    DWORD dwParentProcessId = <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> 7648;&#13;
    HANDLE hParentProcess = NULL;&#13;
    STARTUPINFOEXA si;&#13;
    PROCESS_INFORMATION pi;&#13;
    SIZE_T ulSize;&#13;
&#13;
    memset(&amp;si, 0, sizeof(STARTUPINFOEXA));&#13;
    si.StartupInfo.cb = sizeof(STARTUPINFOEXA);&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> hParentProcess = OpenProcess(&#13;
        PROCESS_CREATE_PROCESS,&#13;
        FALSE,&#13;
        dwParentProcessId);&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> InitializeProcThreadAttributeList(NULL, 1, 0, &amp;ulSize);&#13;
    si.lpAttributeList =&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(&#13;
            GetProcessHeap(),&#13;
            0, ulSize);&#13;
    InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &amp;ulSize);&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span> UpdateProcThreadAttribute(&#13;
        si.lpAttributeList,&#13;
        0,&#13;
        PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,<span role="doc-pagebreak" epub:type="pagebreak" id="pg_47" aria-label=" Page 47. "/>&#13;
        &amp;hParentProcess,&#13;
        sizeof(HANDLE),&#13;
        NULL, NULL);&#13;
&#13;
    CreateProcessA(NULL,&#13;
        szChildProcess,&#13;
        NULL, NULL, FALSE,&#13;
        EXTENDED_STARTUPINFO_PRESENT,&#13;
        NULL, NULL,&#13;
        &amp;si.StartupInfo, &amp;pi);&#13;
    CloseHandle(hParentProcess);&#13;
    DeleteProcThreadAttributeList(si.lpAttributeList);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-13: An example of spoofing a parent process</span></p>&#13;
<p class="TX">We first hardcode the process ID <span class="CodeAnnotation" aria-label="annotation1">❶</span> of <i>vmtoolsd.exe</i>, our desired parent. In the real world, we might instead use logic to find the ID of the parent we’d like to spoof, but I’ve opted not to include this code in the example for the sake of brevity. Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SpoofParent()</samp> function makes a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!OpenProcess()</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This function is responsible for opening a new handle to an existing process with the access rights requested by the developer. In most offensive tools, you may be used to seeing this function used with arguments like <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>, to read the process’s memory, or <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>, which gives us full control over the process. In this example, however, we request <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_CREATE_PROCESS</samp>. We’ll need this access right in order to use the target process as a parent with our externed startup information structure. When the function completes, we’ll have a handle to <i>vmtoolsd.exe</i> with the appropriate rights.</p>&#13;
<p class="TX">The next thing we need to do is create and populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD _ATTRIBUTE_LIST</samp> structure. To do this, we use a pretty common Windows programming trick to get the size of a structure and allocate the correct amount of memory to it. We call the function to initialize the attribute list <span class="CodeAnnotation" aria-label="annotation3">❸</span>, passing in a null pointer instead of the address of the real attribute list. However, we still pass in a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">DWORD</samp>, which will hold the size required after completion. We then use the size stored in this variable to allocate memory on the heap with <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!HeapAlloc()</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Now we can call the attribute list initialization function again, passing in a pointer to the heap allocation we just created.</p>&#13;
<p class="TX">At this point, we’re ready to start spoofing. We do this by first calling the function for modifying the attribute list and passing in the attribute list itself, the flag indicating a handle to the parent process, and the handle we opened to <i>vmtoolsd.exe</i> <span class="CodeAnnotation" aria-label="annotation5">❺</span>. This sets <i>vmtoolsd.exe</i> as the parent process of whatever we create using this attribute list. The last thing we need to do with our attribute list is pass it as input to the process-creation function, specifying the child process to create and the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXTENDED_STARTUPINFO_PRESENT</samp> flag. When this function is executed, <i>notepad.exe</i> will appear to be a child of <i>vmtoolsd.exe</i> in Process Hacker rather than a child of its true parent, <i>ppid-spoof.exe</i> (<a href="#fig3-6">Figure 3-6</a>).</p><span role="doc-pagebreak" epub:type="pagebreak" id="pg_48" aria-label=" Page 48. "/>&#13;
<figure class="IMG"><img id="fig3-6" class="img100" src="../images/Figure3-6.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: A spoofed parent process in Process Hacker</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Unfortunately for adversaries, this evasion technique is relatively simple to detect in a few ways. The first is by using the driver. Remember that the structure passed to the driver on a process-creation event contains two separate fields related to parent processes: <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CreatingThreadId</samp>. While these two fields will point to the same process in most normal circumstances, when the parent process ID (PPID) of a new process is spoofed, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreatingThreadId.UniqueProcess</samp> field will contain the PID of the process that made the call to the process-creation function. <a href="#list3-14">Listing 3-14</a> shows the output from a mock EDR driver captured by DbgView, a tool used to capture debug print messages.</p>&#13;
<pre id="list3-14"><code>12.67045498 Process Name: notepad.exe&#13;
12.67045593 Process ID: 7892&#13;
12.67045593 Parent Process Name: vmtoolsd.exe&#13;
12.67045593 Parent Process ID: 7028&#13;
12.67045689 Creator Process Name: ppid-spoof.exe&#13;
12.67045784 Creator Process ID: 7708</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-14: Capturing parent and creator process information from a driver</span></p>&#13;
<p class="TX">You can see here that the spoofed <i>vmtoolsd.exe</i> shows up as the parent process, but the creator (the true process that launched <i>notepad.exe</i>) is identified as <i>ppid-spoof.exe</i>.</p>&#13;
<p class="TX">Another approach to detecting PPID spoofing uses ETW (a topic we’ll explore further in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>). F-Secure has extensively documented this technique in its “Detecting Parent PID Spoofing” blog post. This detection strategy relies on the fact that the process ID specified in the ETW event header is the creator of the process, rather than the parent process specified in the event data. Thus, in our example, defenders could use an ETW trace to capture process-creation events on the host whenever <i>notepad.exe</i> is spawned. <a href="#fig3-7">Figure 3-7</a> shows the resulting event data.</p>&#13;
<figure class="IMG"><img id="fig3-7" class="img70" src="../images/Figure3-7.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: A spoofed parent process in ETW event data</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_49" aria-label=" Page 49. "/>Highlighted in <a href="#fig3-7">Figure 3-7</a> is the process ID of <i>vmtoolsd.exe</i>, the spoofed parent. If you compare this to the event header, shown in <a href="#fig3-8">Figure 3-8</a>, you can see the discrepancy.</p>&#13;
<figure class="IMG"><img id="fig3-8" class="img70" src="../images/Figure3-8.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-8: A creator process ID captured in an ETW event header</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Note the difference in the two process IDs. While the event data had the ID of <i>vmtoolsd.exe</i>, the header contains the ID of <i>ppid-spoof.exe</i>, the true creator.</p>&#13;
<p class="TX">The information from this ETW provider isn’t quite as detailed as the information provided to us by the mock EDR driver in <a href="#list3-14">Listing 3-14</a>. For example, we’re missing the image name for both the parent and creator processes. This is because the ETW provider doesn’t derive that information for us, like the driver does. In the real world, we’d likely need to add a step to retrieve that information, by either querying the process or pulling it from another data source. Regardless, we can still use this technique as a way to detect PPID spoofing, as we have the core piece of information needed for the strategy: mismatched parent and creator process IDs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h-42"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Process-Image Modification</samp></h3>&#13;
<p class="TNI">In many cases, malware wishes to evade <i>image-based</i> detection, or detections built on the name of the file being used to create the process. While there are many ways to accomplish this, one tactic, which we’ll call <i>process-image modification</i>, has gained substantial traction since 2017, although prolific threat groups have used it since at least 2014. In addition to hiding the execution of the malware or tooling, this tactic could allow attackers to bypass application whitelisting, evade per-application host firewall rules, or pass security checks against the calling image before a server allows a sensitive operation to occur.</p>&#13;
<p class="TX">This section covers four process-image modification techniques, namely hollowing, doppelg<span class="accent">ä</span>nging, herpaderping, and ghosting, all of which achieve their goal in roughly the same way: by remapping the host process’s original image with its own. These techniques also all rely on the same design decision made by Microsoft while implementing the logic for notifying registered callbacks of a process being created.</p>&#13;
<p class="TX">The design decision is this: process creation on Windows involves a complex set of steps, many of which occur before the kernel notifies any <span role="doc-pagebreak" epub:type="pagebreak" id="pg_50" aria-label=" Page 50. "/>drivers. As a result, attackers have an opportunity to modify the process’s attributes in some way during those early steps. Here is the entire process-creation workflow, with the notification step shown in bold:</p>&#13;
<p class="NLF">  1. Validate parameters passed to the process-creation API.</p>&#13;
<p class="NL">  2. Open a handle to the target image.</p>&#13;
<p class="NL">  3. Create a section object from the target image.</p>&#13;
<p class="NL">  4. Create and initialize a process object.</p>&#13;
<p class="NL">  5. Allocate the PEB.</p>&#13;
<p class="NL">  6. Create and initialize the thread object.</p>&#13;
<p class="NL">  <b>7. Send the process-creation notification to the registered callbacks.</b></p>&#13;
<p class="NL">  8. Perform Windows subsystem-specific operations to finish initialization.</p>&#13;
<p class="NL">  9. Start execution of the primary thread.</p>&#13;
<p class="NL">10. Finalize process initialization.</p>&#13;
<p class="NL">11. Start execution at the image entry point.</p>&#13;
<p class="NLL">12. Return to the caller of the process-creation API.</p>&#13;
<p class="TX">The techniques outlined in this section take advantage of step 3, in which the kernel creates a section object from the process image. The memory manager caches this image section once it is created, meaning that the section can deviate from the corresponding target image. Thus, when the driver receives its notification from the kernel process manager, the <samp class="SANS_TheSansMonoCd_W5Regular_11">FileObject</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE_NOTIFY_INFO</samp> structure it processes may not point to the file truly being executed. Beyond exploiting this fact, each of the following techniques has slight variations.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hollowing</samp></h4>&#13;
<p class="TNI"><i>Hollowing</i> is one of the oldest ways of leveraging section modification, dating back to at least 2011. <a href="#fig3-9">Figure 3-9</a> shows the execution flow of this technique.</p>&#13;
<figure class="IMG"><img id="fig3-9" class="img100" src="../images/Figure3-9.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-9: The execution flow of process hollowing</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Using this technique, the attacker creates a process in a suspended state, then unmaps its image after locating its base address in the PEB. Once the unmapping is complete, the attacker maps a new image, such as <span role="doc-pagebreak" epub:type="pagebreak" id="pg_51" aria-label=" Page 51. "/>the adversary’s shellcode runner, to the process and aligns its section. If this succeeds, the process resumes execution.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Doppelgänging</samp></h4>&#13;
<p class="TNI">In their 2017 Black Hat Europe presentation “Lost in Transaction: Process Doppelg<span class="accent">ä</span>nging,” Tal Liberman and Eugene Kogan introduced a new variation on process-image modification. Their technique, <i>process doppelgänging</i>, relies on two Windows features: Transactional NTFS (TxF) and the legacy process-creation API, <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>.</p>&#13;
<p class="TX">TxF is a now-deprecated method for performing filesystem actions as a single atomic operation. It allows code to easily roll back file changes, such as during an update or in the event of an error, and has its own group of supporting APIs.</p>&#13;
<p class="TX">The legacy process-creation API performed process creation prior to the release of Windows 10, which introduced the more robust <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateUserProcess()</samp>. While it’s deprecated for normal process creation, you’ll still find it used on Windows 10, in versions up to 20H2, to create minimal processes. It has the notable benefit of taking a section handle rather than a file for the process image but comes with some significant challenges. These difficulties stem from the fact that many of the process-creation steps, such as writing process parameters to the new process’s address space and creating the main thread object, aren’t handled behind the scenes. In order to use the legacy process-creation function, the developer must re-create those missing steps in their own code to ensure that the process can start.</p>&#13;
<p class="TX"><a href="#fig3-10">Figure 3-10</a> shows the complex flow of process doppelg<span class="accent">ä</span>nging.</p>&#13;
<figure class="IMG"><img id="fig3-10" class="img100" src="../images/Figure3-10.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-10: The execution flow of process doppelgänging</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In their proof of concept, Liberman and Kogan first create a transaction object and open the target file with <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateFileTransacted()</samp>. They then overwrite this transacted file with their malicious code, create an image section that points to the malicious code, and roll back the transaction with <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!RollbackTransaction()</samp>. At this point, the executable has been restored to its original state, but the image section is cached with the malicious code. From here, the authors call <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>, passing in the section handle as a parameter, and create the main thread pointing to the entry point of their malicious code. After these objects are created, they resume the main thread, allowing the doppelg<span class="accent">ä</span>nged process to execute.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H3" id="sec15"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_52" aria-label=" Page 52. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Herpaderping</samp></h4>&#13;
<p class="TNI"><i>Process herpaderping</i>, invented by Johnny Shaw in 2020, leverages many of the same tricks as process doppelg<span class="accent">ä</span>nging, namely its use of the legacy process-creation API to create a process from a section object. While herpaderping can evade a driver’s image-based detections, its primary aim is to evade detection of the contents of the dropped executable. <a href="#fig3-11">Figure 3-11</a> shows how this technique works.</p>&#13;
<figure class="IMG"><img id="fig3-11" class="img100" src="../images/Figure3-11.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-11: The execution flow of process herpaderping</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To perform herpaderping, an attacker first writes the malicious code to be executed to disk and creates the section object, leaving the handle to the dropped executable open. They then call the legacy process-creation API, with the section handle as a parameter, to create the process object. Before initializing the process, they obscure the original executable dropped to disk using the open file handle and <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WriteFile()</samp> or a similar API. Finally, they create the main thread object and perform the remaining process spin-up tasks.</p>&#13;
<p class="TX">At this point, the driver’s callback receives a notification, and it can scan the file’s contents using the <samp class="SANS_TheSansMonoCd_W5Regular_11">FileObject</samp> member of the structure passed to the driver on process creation. However, because the file’s contents have been modified, the scanning function will retrieve bogus data. Additionally, closing the file handle will send an <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CLEANUP</samp> I/O control code to any filesystem minifilters that have been registered. If the minifilter wishes to scan the contents of the file, it will meet the same fate as the driver, potentially resulting in a false-negative scan result.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Ghosting</samp></h4>&#13;
<p class="TNI">One of the newest variations on process-image modification is <i>process ghosting</i>, released in June 2021 by Gabriel Landau. Process ghosting relies on the fact that Windows only prevents the deletion of files <i>after</i> they’re mapped into an image section and doesn’t check whether an associated section actually exists during the deletion process. If a user attempts to open the mapped executable to modify or delete it, Windows will return an error. If the developer marks the file for deletion and then creates the image section from the executable, the file will be deleted when the file handle is closed, but the section object will persist. This technique’s execution flow is shown in <a href="#fig3-12">Figure 3-12</a>.</p><span role="doc-pagebreak" epub:type="pagebreak" id="pg_53" aria-label=" Page 53. "/>&#13;
<figure class="IMG"><img id="fig3-12" class="img100" src="../images/Figure3-12.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-12: The process-ghosting workflow</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To implement this technique in practice, malware might create an empty file on disk and then immediately put it into a delete-pending state using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtSetInformationFile()</samp> API. While the file is in this state, the malware can write its payload to it. Note that external requests to open the file will fail, with <i>ERROR_DELETE_PENDING</i>, at this point. Next, the malware creates the image section from the file and then closes the file handle, deleting the file but preserving the image section. From here, the malware follows the steps to create a new process from a section object described in previous examples. When the driver receives a notification about the process creation and attempts to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp> backing the process (the structure used by Windows to represent a file object), it will receive a <i>STATUS_FILE_DELETED</i> error, preventing the file from being inspected.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Detection</samp></h4>&#13;
<p class="TNI">While process-image modification has a seemingly endless number of variations, we can detect all of these using the same basic methods due to the technique’s reliance on two things: the creation of an image section that differs from the reported executable, whether it is modified or missing, and the use of the legacy process-creation API to create a new, non-minimal process from the image section.</p>&#13;
<p class="TX">Unfortunately, most of the detections for this tactic are reactive, occurring only as part of an investigation, or they leverage proprietary tooling. Still, by focusing on the basics of the technique, we can imagine multiple potential ways to detect it. To demonstrate these methods, Aleksandra Doniec (<span class="LinkTwitter">@hasherezade</span>) created a public proof of concept for process ghosting that we can analyze in a controlled environment. You can find this file, <i>proc_ghost64.exe</i>, at <a href="https://github.com/hasherezade/process_ghosting/releases"><i>https://<wbr/>github<wbr/>.com<wbr/>/hasherezade<wbr/>/process<wbr/>_ghosting<wbr/>/releases</i></a>. Verify that its SHA-256 hash matches the following: <samp class="SANS_TheSansMonoCd_W5Regular_11">8a74a522e9a91b777080d3cb95d8bbeea84cb71fda487bc3d4489188e3fd6855</samp>.</p>&#13;
<p class="TX">First, in kernel mode, the driver could search for information related to the process’s image either in the PEB or in the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> structure, the structure that represents a process object in the kernel. Because the user can control the PEB, the process structure is a better <span role="doc-pagebreak" epub:type="pagebreak" id="pg_54" aria-label=" Page 54. "/>source. It contains process-image information in a number of locations, described in <a href="#tab3-1">Table 3-1</a>.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab3-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">Process-Image Information Contained in the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> <samp class="SANS_Futura_Std_Book_11">Structure</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Location</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Process-image information</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Contains only the filename</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer.FileName</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Contains the rooted Win32 filepath</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeAuditProcessCreationInfo.ImageFileName</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Contains the full NT path but may not always be populated</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePathHash</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Contains the hashed NT, or canonicalized, path via</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PfCalculateProcessHash()</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">Drivers may query these paths by using APIs such as <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!SeLocateProcessImageName()</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!ZwQueryInformationProcess()</samp> to retrieve the true image path, at which point they still need a way to determine whether the process has been tampered with. Despite being unreliable, the PEB provides a point of comparison. Let’s walk through this comparison using WinDbg. First, we attempt to pull the image’s filepath from one of the process structure’s fields (<a href="#list3-15">Listing 3-15</a>).</p>&#13;
<pre id="list3-15"><code>0: kd&gt; <b>dt nt!_EPROCESS SeAuditProcessCreationInfo @$proc</b>&#13;
  +0x5c0 SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO&#13;
0: kd&gt; <b>dt (nt!_OBJECT_NAME_INFORMATION *) @$proc+0x5c0</b>&#13;
0xffff9b8f`96880270&#13;
  +0x000 Name              : _UNICODE_STRING ""</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-15: Pulling the filepath from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SeAuditProcessCreationInfo</samp></span></p>&#13;
<p class="TX">Interestingly, WinDbg returns an empty string as the image name. This is atypical; for example, <a href="#list3-16">Listing 3-16</a> returns what you’d expect to see in the case of an unmodified <i>notepad.exe</i>.</p>&#13;
<pre id="list3-16"><code>1: kd&gt; <b>dt (nt!_OBJECT_NAME_INFORMATION *) @$proc+0x5c0</b>&#13;
Breakpoint 0 hit&#13;
0xffff9b8f`995e6170&#13;
  +0x000 Name             : _UNICODE_STRING&#13;
"\Device\HarddiskVolume2\Windows\System32\notepad.exe"</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">UNICODE_STRING</samp> field populated with the NT path of the image</span></p>&#13;
<p class="TX">Let’s also check another member of the process structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>. While this field won’t return the full image path, it still provides valuable information, as you can see in <a href="#list3-17">Listing 3-17</a>.</p>&#13;
<pre id="list3-17"><code>0: kd&gt; <b>dt nt!_EPROCESS ImageFileName @$proc</b>&#13;
   +0x5a8 ImageFileName : [15]   "THFA8.tmp"</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-17: Reading the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFileName</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EPROCESS</samp> structure</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_55" aria-label=" Page 55. "/>The returned filename should have already attracted attention, as <i>.tmp</i> files aren’t very common executables. To determine whether image tampering might have taken place, we’ll query the PEB. A few locations in the PEB will return the image path: <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters.ImagePathName</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Ldr.InMemoryOrderModuleList</samp><i>.</i> Let’s use WinDbg to demonstrate this (<a href="#list3-18">Listing 3-18</a>).</p>&#13;
<pre id="list3-18"><code>1: kd&gt; <b>dt nt!_PEB ProcessParameters @$peb</b>&#13;
   +0x020 ProcessParameters : 0x000001c1`c9a71b80 _RTL_USER_PROCESS_PARAMETERS&#13;
1: kd&gt; <b>dt nt!_RTL_USER_PROCESS_PARAMETERS ImagePathName poi(@$peb+0x20)</b>&#13;
   +0x060 ImagePathName : _UNICODE_STRING "C:\WINDOWS\system32\notepad.exe"</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-18: Extracting the process image’s path from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImagePathName</samp></span></p>&#13;
<p class="TX">As shown in the WinDbg output, the PEB reports the process image’s path as <i>C:\Windows\System32\notepad.exe</i>. We can verify this by querying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ldr.InMemoryOrderModuleList</samp> field, shown in <a href="#list3-19">Listing 3-19</a>.</p>&#13;
<pre id="list3-19"><code>1: kd&gt; <b>!peb</b>&#13;
PEB at 0000002d609b9000&#13;
    InheritedAddressSpace:    No&#13;
    ReadImageFileExecOptions:  No&#13;
    BeingDebugged:            No&#13;
    ImageBaseAddress:         00007ff60edc0000&#13;
    NtGlobalFlag:             0&#13;
    NtGlobalFlag2:            0&#13;
    Ldr                       00007ffc74c1a4c0&#13;
    Ldr.Initialized:          Yes&#13;
    Ldr.InInitializationOrderModuleList:  000001c1c9a72390 . 000001c1c9aa7f50&#13;
    Ldr.InLoadOrderModuleList:            000001c1c9a72500 . 000001c1c9aa8520&#13;
    Ldr.InMemoryOrderModuleList:          000001c1c9a72510 . 000001c1c9aa8530&#13;
                    Base Module&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> 7ff60edc0000 C:\WINDOWS\system32\notepad.exe</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-19: Extracting the process image’s path from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InMemoryOrderModuleList</samp></span></p>&#13;
<p class="TX">You can see here that <i>notepad.exe</i> is the first image in the module list <span class="CodeAnnotation" aria-label="annotation1">❶</span>. In my testing, this should always be the case. If an EDR found a mismatch like this between the image name reported in the process structures and in the PEB, it could reasonably say that some type of process-image tampering had occurred. It couldn’t, however, determine which technique the attacker had used. To make that call, it would have to collect additional information.</p>&#13;
<p class="TX">The EDR might first try to investigate the file directly, such as by scanning its contents through the pointer stored in the process structure’s <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer</samp> field. If malware created the process by passing an image section object through the legacy process-creation API, as in the proof of concept, this member will be empty (<a href="#list3-20">Listing 3-20</a>).</p>&#13;
<pre id="list3-20"><code>1: kd&gt; <b>dt nt!_EPROCESS ImageFilePointer @$proc</b>&#13;
   +0x5a0 ImageFilePointer : (null)</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-20: The empty <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFilePointer</samp> field</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_56" aria-label=" Page 56. "/>The use of the legacy API to create a process from a section is a major indicator that something weird is going on. At this point, the EDR can reasonably say that this is what happened. To support this assumption, the EDR could also check whether the process is minimal or <i>pico</i> (derived from a minimal process), as shown in <a href="#list3-21">Listing 3-21</a>.</p>&#13;
<pre id="list3-21"><code>1: kd&gt; <b>dt nt!_EPROCESS Minimal PicoCreated @$proc</b>&#13;
   +0x460 PicoCreated   : 0y0&#13;
   +0x87c Minimal       : 0y0</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-21: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Minimal</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PicoCreated</samp> members set to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">false</samp></span></p>&#13;
<p class="TX">Another place to look for anomalies is the virtual address descriptor (VAD) tree used for tracking a process’s contiguous virtual memory allocations. The VAD tree can provide very useful information about loaded modules and the permissions of memory allocations. The root of this tree is stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">VadRoot</samp> member of the process structure, which we can’t directly retrieve through a Microsoft-supplied API, but you can find a reference implementation in Blackbone, a popular driver used for manipulating memory.</p>&#13;
<p class="TX">To detect process-image modifications, you’ll probably want to look at the mapped allocation types, which include <i>READONLY</i> file mappings, such as the COM+ catalog files (for example, <i>C:\Windows\Registration\Rxxxxxxx1.clb</i>), and <i>EXECUTE_WRITECOPY</i> executable files. In the VAD tree, you’ll commonly see the Win32-rooted path for the process image (in other words, the executable file that backs the process as the first mapped executable). <a href="#list3-22">Listing 3-22</a> shows the truncated output of WinDbg’s <samp class="SANS_TheSansMonoCd_W5Regular_11">!vad</samp> command.</p>&#13;
<pre id="list3-22"><code>0: kd&gt; <b>!vad</b>&#13;
VAD              Commit&#13;
ffffa207d5c88d00 7 Mapped   NO_ACCESS              Pagefile section, shared commit 0x1293&#13;
ffffa207d5c89340 6 Mapped   Exe EXECUTE_WRITECOPY  \Windows\System32\notepad.exe&#13;
ffffa207dc976c90 4 Mapped   Exe EXECUTE_WRITECOPY  \Windows\System32\oleacc.dll</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-22: The output of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">!vad</samp> command in WinDbg for a normal process</span></p>&#13;
<p class="TX">The output of this tool shows mapped allocations for an unmodified <i>notepad.exe</i> process. Now let’s see how they look in a ghosted process (<a href="#list3-23">Listing 3-23</a>).</p>&#13;
<pre id="list3-23"><code>0: kd&gt; <b>!vad</b>&#13;
VAD              Commit&#13;
ffffa207d5c96860 2 Mapped      NO_ACCESS          Pagefile section, shared commit 0x1293&#13;
ffffa207d5c967c0 6 Mapped Exe  EXECUTE_WRITECOPY  \Users\dev\AppData\Local\Temp\THF53.tmp&#13;
ffffa207d5c95a00 9 Mapped Exe  EXECUTE_WRITECOPY  \Windows\System32\gdi32full.dll</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-23: The output of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">!vad</samp> command for a ghosted process</span></p>&#13;
<p class="TX">This mapped allocation shows the path to the <i>.tmp</i> file instead of the path to <i>notepad.exe</i>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_57" aria-label=" Page 57. "/>Now that we know the path to the image of interest, we can investigate it further. One way to do this is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationFile()</samp> API with the <samp class="SANS_TheSansMonoCd_W5Regular_11">FileStandardInformation</samp> class, which will return a <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_STANDARD_INFORMATION</samp> structure. This structure contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeletePending</samp> field, which is a Boolean indicating whether the file has been marked for deletion. Under normal circumstances, you could also pull this information from the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeletePending</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp> structure. Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> structure for the relevant process, this is pointed to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer</samp> member. In the case of the ghosted process, this pointer will be null, so the EDR can’t use it. <a href="#list3-24">Listing 3-24</a> shows what a normal process’s image file pointer and deletion status should look like.</p>&#13;
<pre id="list3-24"><code>2: kd&gt; <b>dt nt!_EPROCESS ImageFilePointer @$proc</b>&#13;
   +0x5a0 ImageFilePointer : 0xffffad8b`a3664200 _FILE_OBJECT&#13;
2: kd&gt; <b>dt nt!_FILE_OBJECT DeletePending 0xffffad8b`a3664200</b>&#13;
   +0x049 DeletePending : 0 ' '</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-24: Normal <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFilePointer</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">DeletePending</samp> members</span></p>&#13;
<p class="TX">This listing is from a <i>notepad.exe</i> process executed under normal conditions. In a ghosted process, the image file pointer would be an invalid value, and thus, the deletion status flag would also be invalid.</p>&#13;
<p class="TX">After observing the difference between a normal instance of <i>notepad.exe</i> and one that has been ghosted, we’ve identified a few indicators:</p>&#13;
<ul class="BL">&#13;
<li class="BL">There will be a mismatch between the paths in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePathName</samp> inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp> member of the process’s PEB and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp> in its <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> structure.</li>&#13;
<li class="BL">The process structure’s image file pointer will be null and its <samp class="SANS_TheSansMonoCd_W5Regular_11">Minimal</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PicoCreated</samp> fields will be <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.</li>&#13;
<li class="BL">The filename may be atypical (this isn’t a requirement, however, and the user can control this value).</li>&#13;
</ul>&#13;
<p class="TX">When the EDR driver receives the new process-creation structure from its process-creation callback, it will have access to the key information needed to build a detection. Namely, in the case of process ghosting, it can use <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">FileObject</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">IsSubsystemProcess</samp> to identify potentially ghosted processes. <a href="#list3-25">Listing 3-25</a> shows what this driver logic could look like.</p>&#13;
<pre id="list3-25"><code>void ProcessCreationNotificationCallback(&#13;
    PEPROCESS pProcess,&#13;
    HANDLE hPid,&#13;
    PPS_CREATE_NOTIFY_INFO psNotifyInfo)&#13;
{&#13;
    if (pNotifyInfo)&#13;
    {&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if (!pNotifyInfo-&gt;FileObject &amp;&amp; !pNotifyInfo-&gt;IsSubsystemProcess)&#13;
        {&#13;
            PUNICODE_STRING pPebImage = NULL;&#13;
            PUNICODE_STRING pPebImageNtPath = NULL;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_58" aria-label=" Page 58. "/>&#13;
            PUNICODE_STRING pProcessImageNtPath = NULL;&#13;
&#13;
         <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> GetPebImagePath(pProcess, pPebImage);&#13;
            CovertPathToNt(pPebImage, pPebImageNtPath);&#13;
&#13;
         <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> CovertPathToNt(psNotifyInfo-&gt;ImageFileName, pProcessImageNtPath);&#13;
&#13;
            if (RtlCompareUnicodeString(pPebImageNtPath, pProcessImageNtPath, TRUE))&#13;
            {&#13;
                <var>--snip--</var>&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 3-25: Detecting ghosted processes with the driver</span></p>&#13;
<p class="TX">We first check whether the file pointer is null even though the process being created isn’t a subsystem process <span class="CodeAnnotation" aria-label="annotation1">❶</span>, meaning it was likely created with the legacy process-creation API. Next, we use two mock helper functions <span class="CodeAnnotation" aria-label="annotation2">❷</span> to return the process image path from the PEB and convert it to the NT path. We then repeat this process using the image filename from the process structure for the newly created process <span class="CodeAnnotation" aria-label="annotation3">❸</span>. After that, we compare the image paths in the PEB and process structure. If they’re not equal, we’ve likely found a suspicious process, and it’s time for the EDR to take some action.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h2 class="H1" id="sec18"><span id="h-43"/><samp class="SANS_Futura_Std_Bold_B_11">A Process Injection Case Study: fork&amp;run</samp></h2>&#13;
<p class="TNI">Over time, shifts in attacker tradecraft have affected the importance, to EDR vendors, of detecting suspicious process-creation events. After gaining access to a target system, attackers may leverage any number of command-and-control agents to perform their post-exploitation activities. Each malware agent’s developers must decide how to handle communications with the agent so that they can execute commands on the infected system. While there are numerous approaches to tackling this problem, the most common architecture is referred to as <i>fork&amp;run</i>.</p>&#13;
<p class="TX">Fork&amp;run works by spawning a sacrificial process into which the primary agent process injects its post-exploitation tasking, allowing the task to execute independently of the agent. This comes with the advantage of stability; if a post-exploitation task running inside the primary agent process has an unhandled exception or fault, it could cause the agent to exit. As a result, the attacker could lose access to the environment.</p>&#13;
<p class="TX">The architecture also streamlines the agent’s design. By providing a host process and a means of injecting its post-exploitation capabilities, the developer makes it easier to integrate new features into the agent. Additionally, by keeping post-exploitation tasking contained in another <span role="doc-pagebreak" epub:type="pagebreak" id="pg_59" aria-label=" Page 59. "/>process, the agent doesn’t need to worry too much about cleanup and can instead terminate the sacrificial process altogether.</p>&#13;
<p class="TX">Leveraging fork&amp;run in an agent is so simple that many operators might not even realize they’re using it. One of the most popular agents that makes heavy use of fork&amp;run is Cobalt Strike’s Beacon. Using Beacon, the attacker can specify a sacrificial process, either through their Malleable profile or through Beacon’s integrated commands, into which they can inject their post-exploitation capabilities. Once the target is set, Beacon will spawn this sacrificial process and inject its code whenever a post-exploitation job that requires fork&amp;run is queued. The sacrificial process is responsible for running the job and returning output before exiting.</p>&#13;
<p class="TX">However, this architecture poses a large risk to operational security. Attackers now have to evade so many detections that leveraging the built-in features of an agent like Beacon often isn’t viable. Instead, many teams now use their agent only as a method for injecting their post-exploitation tooling code and maintaining access to the environment. An example of this trend is the rise of offensive tooling written in C# and primarily leveraged through Beacon’s <i>execute-assembly</i>, a way to execute .NET assemblies in memory that makes use of fork&amp;run under the hood.</p>&#13;
<p class="TX">Because of this shift in tradecraft, EDRs highly scrutinize process creation from numerous angles, ranging from the relative frequency of the parent–child relationship in the environment to whether the process’s image is a .NET assembly. Yet, as EDR vendors became better at detecting the “create a process and inject into it” pattern, attackers have begun to consider spawning a new process to be highly risky and have looked for ways to avoid doing it.</p>&#13;
<p class="TX">One of the biggest challenges for EDR vendors came in version 4.1 of Cobalt Strike, which introduced Beacon Object Files (BOFs). BOFs are small programs written in C that are meant to be run in the agent process, avoiding fork&amp;run entirely. Capability developers could continue to use their existing development process but leverage this new architecture to achieve the same results in a safer manner.</p>&#13;
<p class="TX">If attackers remove the artifacts from fork&amp;run, EDR vendors must rely on other pieces of telemetry for their detections. Fortunately for vendors, BOFs only remove the process-creation and injection telemetry related to the sacrificial process creation. They don’t do anything to hide the post-exploitation tooling’s artifacts, such as network traffic, filesystem interactions, or API calls. This means that, while BOFs do make detection more difficult, they are not a silver bullet.</p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec19">&#13;
<h2 class="H1" id="sec19"><span id="h-44"/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">Monitoring the creation of new processes and threads is an immensely important capability for any EDR. It facilitates the mapping of parent–child relationships, the investigation of suspect processes prior to their execution, and the identification of remote thread creation. Although Windows <span role="doc-pagebreak" epub:type="pagebreak" id="pg_60" aria-label=" Page 60. "/>provides other ways to obtain this information, process- and thread-creation callback routines inside the EDR’s driver are by far the most common. In addition to having a great deal of visibility into activity on the system, these callbacks are challenging to evade, relying on gaps in coverage and blind spots rather than fundamental flaws in the underlying technology.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>