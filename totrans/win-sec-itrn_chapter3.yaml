- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">USER-MODE
    APPLICATIONS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">用户模式应用程序</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: In the previous chapter, we discussed the Windows kernel. But a user doesn’t
    typically interact directly with the kernel. Instead, they interact with user-facing
    applications, such as word processors and file managers. This chapter will detail
    how these user-mode applications are created and how they interface with the kernel
    to provide services to the user.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了Windows内核。但是用户通常不会直接与内核交互。相反，他们与面向用户的应用程序进行交互，比如文字处理器和文件管理器。本章将详细介绍这些用户模式应用程序是如何创建的，以及它们如何与内核交互，为用户提供服务。
- en: We’ll start by discussing the Win32 application programming interfaces (APIs)
    designed for user-mode application development and how they relate to the design
    of the Windows operating system. Then we’ll cover the structure of the Windows
    user interface and how you can inspect it programmatically. Multiple users of
    a Windows system can all access a user interface at the same time; we’ll also
    look at how console sessions can isolate one user’s interface and application
    resources from those of other users on the same system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论为用户模式应用程序开发设计的Win32应用程序编程接口（APIs），以及它们与Windows操作系统设计的关系。然后，我们将介绍Windows用户界面的结构，以及如何以编程方式检查它。多个Windows系统用户可以同时访问用户界面；我们还将探讨控制台会话如何隔离一个用户的界面和应用程序资源，以避免与同一系统上其他用户的资源冲突。
- en: To understand how user-mode applications function, it’s important to understand
    how the provided APIs interface with the underlying kernel system call interface.
    We’ll examine this too, along with the conversion process that filepaths must
    undergo to become compatible with the kernel. Next, we’ll cover how Win32 applications
    access the registry; then we’ll consider how Win32 handles process and thread
    creation and look at some important system processes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解用户模式应用程序是如何工作的，首先需要理解提供的API如何与底层内核系统调用接口交互。我们还将研究这一点，以及文件路径为了与内核兼容必须经历的转换过程。接下来，我们将介绍Win32应用程序如何访问注册表；然后，我们将考虑Win32如何处理进程和线程的创建，并查看一些重要的系统进程。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Win32 and the User-Mode Windows APIs</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Win32和用户模式Windows APIs</samp>
- en: Most of the code that runs on Windows does not directly interact with system
    calls. This is an artifact of the *Windows NT* operating system’s original design.
    Microsoft initially developed Windows NT as an updated version of IBM’s OS/2 operating
    system, intending it to have multiple subsystems that implemented different APIs.
    At various times, it supported POSIX, OS/2, and the Win32 APIs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数在Windows上运行的代码并不会直接与系统调用交互。这是*Windows NT*操作系统原始设计的产物。微软最初开发Windows NT时，将其作为IBM
    OS/2操作系统的更新版本，计划它支持多个子系统，来实现不同的API。在不同的时期，它支持过POSIX、OS/2和Win32 API。
- en: Eventually, Microsoft’s relationship with IBM went sour, and Microsoft took
    the API set it had developed for Windows 95, *Win32*, and built a subsystem to
    implement it. The largely unloved OS/2 subsystem was removed in Windows 2000,
    while POSIX survived until Windows 8.1\. By Windows 10, Win32 was the only remaining
    subsystem (though Microsoft subsequently implemented Linux compatibility layers,
    such as Windows Subsystem for Linux, that don’t use the old subsystem extension
    points).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，微软与IBM的关系恶化，微软将其为Windows 95开发的API集*Win32*独立出来，并构建了一个子系统来实现它。那个大多不受欢迎的OS/2子系统在Windows
    2000中被移除，而POSIX一直保留到Windows 8.1版本。到了Windows 10，Win32成为唯一剩下的子系统（尽管微软随后实现了Linux兼容层，如Windows
    Subsystem for Linux，这些并未使用旧的子系统扩展点）。
- en: To allow for these multiple APIs, the Windows kernel implements a generic set
    of system calls. It’s the responsibility of each subsystem’s specific libraries
    and services to convert their APIs to the low-level system call interface. [Figure
    3-1](chapter3.xhtml#fig3-1) shows an overview of the Win32 subsystem API libraries.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这些多个API，Windows内核实现了一组通用的系统调用。每个子系统的特定库和服务负责将其API转换为低级系统调用接口。[图3-1](chapter3.xhtml#fig3-1)展示了Win32子系统API库的概览。
- en: '![](../images/Figure3-1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: The Win32 API modules</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-1：Win32 API模块</samp>
- en: As you can see, the core of the Win32 APIs is implemented in the *KERNEL32*
    and *KERNELBASE* libraries. These libraries call methods in the system-provided
    *NT Layer dynamic link library (NTDLL)*, which implements system call dispatches
    as well as runtime library APIs to perform common low-level operations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Win32 API 的核心实现位于 *KERNEL32* 和 *KERNELBASE* 库中。这些库调用系统提供的 *NT Layer 动态链接库（NTDLL）*
    中的方法，后者实现了系统调用分派以及运行时库 API，以执行常见的低级操作。
- en: 'Most user-mode applications do not directly contain the implementation of the
    Windows system APIs. Instead, *NTDLL* includes the DLL loader, which loads new
    libraries on demand. The loading process is mostly opaque to the developer: when
    building a program, you link against a set of libraries, and the compiler and
    toolchain automatically add an import table to your executable file to reflect
    your dependencies. The DLL loader then inspects the import table, automatically
    loads any dependent libraries, and resolves the imports. You can also specify
    exported functions from your application so that other code can rely on your APIs.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户模式应用程序并不直接包含 Windows 系统 API 的实现。相反，*NTDLL* 包含 DLL 加载器，它按需加载新库。加载过程对于开发人员来说大多是不透明的：在构建程序时，您会链接一组库，编译器和工具链会自动将导入表添加到您的可执行文件中，以反映您的依赖关系。DLL
    加载器随后检查导入表，自动加载任何依赖的库并解析导入。您还可以指定应用程序中的导出函数，以便其他代码可以依赖您的 API。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loading a New Library</samp>
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加载新库</samp>
- en: It’s possible to access exported functions manually at runtime without needing
    an import table entry. You can load a new library using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    Win32 API, which is exposed to PowerShell using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Import-Win32Module</samp>
    command. To find the memory address of a function exported by a DLL, use the Win32
    API <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>, exposed
    with the PowerShell <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleExport</samp>
    command ([Listing 3-1](chapter3.xhtml#Lis3-1)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在运行时手动访问导出的函数，而无需导入表条目。您可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    Win32 API 加载新的库，该 API 可通过 PowerShell 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Import-Win32Module</samp>
    命令暴露。要查找 DLL 导出的函数的内存地址，请使用 Win32 API <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>，该
    API 可通过 PowerShell 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleExport</samp>
    命令暴露（[列表 3-1](chapter3.xhtml#Lis3-1)）。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: Exports for the <samp class="SANS_Futura_Std_Book_11">KERNEL32</samp>
    library'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-1：<samp class="SANS_Futura_Std_Book_11">KERNEL32</samp> 库的导出
- en: Here, we use PowerShell to load the *KERNEL32* library and enumerate the exported
    and imported APIs. First we load it into memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Import
    -Win32Module</samp> ❶. The *KERNEL32* library is always loaded, so this command
    will just return the existing loaded address; for other libraries, however, the
    load will cause the DLL to be mapped into memory and initialized.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 PowerShell 加载 *KERNEL32* 库并枚举导出和导入的 API。首先，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Import
    -Win32Module</samp> 将其加载到内存中 ❶。*KERNEL32* 库总是被加载的，因此此命令将返回已加载的现有地址；然而，对于其他库，加载会导致
    DLL 被映射到内存中并初始化。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">WARNING</samp>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">警告</samp>
- en: '*The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Import-Win32Module</samp>
    command will load a DLL into memory and potentially execute code. In this example,
    this is acceptable, as* KERNEL32 *is one of the trusted system libraries. However,
    do not use the command on an untrusted DLL, especially if you’re analyzing malware,
    as it might result in malicious code execution. To be safe, always perform malware
    analysis on a segregated system dedicated to that purpose.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Import-Win32Module</samp>
    命令将把 DLL 加载到内存中，并可能执行代码。在此示例中，这是可以接受的，因为* KERNEL32 *是受信任的系统库之一。然而，不要对不受信任的 DLL
    使用此命令，尤其是在分析恶意软件时，因为它可能导致恶意代码的执行。为了安全起见，始终在专门用于此目的的隔离系统上执行恶意软件分析。*'
- en: Once it’s loaded into memory, we can display some of the library’s properties
    ❷. These include the name of the library, as well as the loaded memory address
    and the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EntryPoint</samp>.
    A DLL can optionally define a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">DllMain</samp>,
    to run when it’s loaded. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EntryPoint</samp>
    address is the first instruction in memory to execute when the DLL is loaded.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它被加载到内存中，我们可以显示库的一些属性❷。这些包括库的名称，以及加载的内存地址和`<samp class="SANS_TheSansMonoCd_W5Regular_11">EntryPoint</samp>`的地址。一个DLL可以选择定义一个函数`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DllMain</samp>`，当它被加载时执行。`<samp class="SANS_TheSansMonoCd_W5Regular_11">EntryPoint</samp>`地址是DLL加载时在内存中执行的第一条指令。
- en: 'Next, we dump all exported functions from the DLL ❸. In this case, we see three
    pieces of information for each: <samp class="SANS_TheSansMonoCd_W5Regular_11">Ordinal</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Ordinal</samp> is a small number
    that uniquely identifies the exported function in the DLL. It’s possible to import
    an API by its ordinal number, which means there is no need to export a name; you’ll
    see certain names missing from export tables in DLLs whenever Microsoft doesn’t
    want to officially support the function as a public API.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转储DLL中的所有导出函数❸。在这种情况下，我们为每个函数看到三条信息：`<samp class="SANS_TheSansMonoCd_W5Regular_11">Ordinal</samp>`、`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>`和`<samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp>`。`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ordinal</samp>`是一个小数字，唯一标识DLL中的导出函数。通过序号导入API是可能的，这意味着不需要导出名称；当微软不希望将某个函数作为公共API正式支持时，你会看到DLL的导出表中缺少某些名称。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> is just the name
    of the exported function. It doesn’t need to match what the function was called
    in the original source code, although typically it does. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp>
    is the address in memory of the function’s first instruction. You’ll notice that
    the first two exports have a string instead of an address. This is a case of *export
    forwarding*; it allows a DLL to export a function by name and has the loader automatically
    redirect it to another DLL. In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireSRWLockExclusive</samp>
    is implemented as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlAcquireSRWLockExclusive</samp>
    in *NTDLL*. We can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleExport</samp>
    to look up a single exported function using the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    API ❹.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>`只是导出函数的名称。它不需要与原始源代码中调用的函数名称匹配，尽管通常情况下它们是匹配的。最后，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Address</samp>`是函数第一条指令在内存中的地址。你会注意到，前两个导出有一个字符串而不是地址。这是一个*导出转发*的例子；它允许一个DLL通过名称导出函数，并且加载器会自动将其重定向到另一个DLL。在这种情况下，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AcquireSRWLockExclusive</samp>`在*NTDLL*中实现为`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RtlAcquireSRWLockExclusive</samp>`。我们还可以使用`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleExport</samp>`通过`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>`API查找单个导出函数❹。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing Imported
    APIs</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">查看导入的API</samp>
- en: In a similar fashion, we can view the APIs that an executable has imported from
    other DLLs using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp>
    command, as shown in [Listing 3-2](chapter3.xhtml#Lis3-2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以使用`<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp>`命令查看可执行文件从其他DLL导入的API，如[示例3-2](chapter3.xhtml#Lis3-2)所示。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: Enumerating imports for the <samp class="SANS_Futura_Std_Book_11">KERNEL32</samp>
    library'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3-2：枚举`<samp class="SANS_Futura_Std_Book_11">KERNEL32</samp>`库的导入函数
- en: We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp>,
    specifying the *KERNEL32* DLL as the path. When you specify a path, the command
    will call <samp class="SANS_TheSansMonoCd_W5Regular_11">Import-Win32Module</samp>
    for you and display all the imports, including the name of the DLL to load and
    the number of functions imported. The final column indicates whether the DLL was
    marked by the developer as being *delay loaded*. This is a performance optimization;
    it allows a DLL to be loaded only when one of its exported functions is used.
    This delay avoids loading all DLLs into memory during initialization, which decreases
    process startup time and reduces runtime memory usage if the import is never used.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp>
    开始，并指定 *KERNEL32* DLL 作为路径。当你指定路径时，命令会自动调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Import-Win32Module</samp>
    并显示所有导入，包括要加载的 DLL 名称和导入函数的数量。最后一列显示该 DLL 是否被开发者标记为 *延迟加载*。这是一种性能优化，它允许 DLL 仅在使用其导出的某个函数时加载。延迟加载避免了在初始化时加载所有
    DLL，从而减少了进程启动时间，并且如果导入从未被使用，减少了运行时内存占用。
- en: Next, we dump the imported functions for a DLL. As the executable can import
    code from multiple libraries, we specify the one we want using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllName</samp>
    property. We then filter to all imported functions starting with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    prefix; this allows us to see exactly what system calls *KERNEL32* imports from
    *NTDLL*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转储 DLL 的导入函数。由于可执行文件可以从多个库中导入代码，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DllName</samp>
    属性指定我们需要的库。然后我们过滤出所有以 <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    前缀开头的导入函数；这样我们就可以清楚地看到 *KERNEL32* 从 *NTDLL* 导入了哪些系统调用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Searching for DLLs</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">搜索 DLL</samp>
- en: When loading a DLL, the loader creates an image section object from the executable
    file and maps it into memory. The kernel is responsible for mapping the executable
    memory; however, user-mode code still needs to parse the import and export tables.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 DLL 时，加载器从可执行文件创建映像段对象并将其映射到内存。内核负责映射可执行内存；然而，用户模式代码仍然需要解析导入和导出表。
- en: 'Let’s say you pass the string <samp class="SANS_TheSansMonoCd_W5Regular_11">ABC.DLL</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> API. How
    does the API know where to find that DLL? If the file hasn’t been specified as
    an absolute path, the API implements a path-searching algorithm. The algorithm,
    as originally implemented in Windows NT 3.1, searches for files in the following
    order:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">ABC.DLL</samp> 传递给 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> API。那么，API 如何知道去哪里找这个
    DLL 呢？如果文件没有指定为绝对路径，API 会执行路径搜索算法。该算法最初在 Windows NT 3.1 中实现，并按以下顺序搜索文件：
- en: 1.  The same directory as the current process’s executable file
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  与当前进程的可执行文件相同的目录
- en: 2.  The current working directory
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  当前工作目录
- en: 3.  The Windows *System32* directory
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  Windows *System32* 目录
- en: 4.  The *Windows* directory
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  *Windows* 目录
- en: 5.  Each semicolon-separated location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATH</samp>
    environment variable
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  <sup class="SANS_TheSansMonoCd_W5Regular_11">PATH</sup> 环境变量中的每个分号分隔位置
- en: The problem with this load order is that it can lead to a privileged process
    loading a DLL from an insecure location. For example, if a privileged process
    changed its current working directory using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCurrentDirectory</samp>
    API to a location a less privileged user could write to, the DLL would be loaded
    from that location before any DLL from the *System32* directory. This attack is
    called *DLL hijacking*, and it’s a persistent problem on Windows.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加载顺序的问题在于，它可能导致特权进程从不安全的位置加载 DLL。例如，如果一个特权进程通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCurrentDirectory</samp>
    API 改变当前工作目录，指向一个普通用户可以写入的地方，DLL 会从该位置加载，而不是从 *System32* 目录加载。这种攻击被称为 *DLL 劫持*，它是
    Windows 系统中的一个长期存在的问题。
- en: 'Vista changed the default load order to the following, which is safer:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Vista 将默认加载顺序更改为以下方式，这样更安全：
- en: 1.  The same directory as the current process’s executable file
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  与当前进程的可执行文件相同的目录
- en: 2.  The Windows *System32* directory
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  Windows *System32* 目录
- en: 3.  The *Windows* directory
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  *Windows* 目录
- en: 4.  The current working directory
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  当前工作目录
- en: 5.  Each semicolon-separated location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATH</samp>
    environment variable
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 每个由分号分隔的位置在 <samp class="SANS_TheSansMonoCd_W5Regular_11">PATH</samp> 环境变量中
- en: Now we no longer load from the current working directory before the *System32*
    or *Windows* directory. However, if an attacker could write to the executable’s
    directory, a DLL hijack could still take place. Therefore, if an executable is
    run as a privileged process, only administrators should be able to modify its
    directory to prevent a DLL hijack from occurring.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不再从当前工作目录加载 DLL，而是优先加载 *System32* 或 *Windows* 目录。然而，如果攻击者能够写入可执行文件所在的目录，仍然可能发生
    DLL 劫持。因此，如果可执行文件作为特权进程运行，只有管理员才能修改其目录，以防止发生 DLL 劫持。
- en: While the DLL loader will normally turn to the disk to retrieve a library, some
    libraries are used so often that it makes sense to pre-initialize them. This improves
    performance and prevents the DLLs from being hijacked. Two obvious examples are
    *KERNEL32* and *NTDLL*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 DLL 加载器通常会从磁盘中检索库文件，但有些库文件使用频率很高，预先初始化它们是有意义的。这可以提高性能，并防止 DLL 被劫持。两个明显的例子是
    *KERNEL32* 和 *NTDLL*。
- en: Before any user applications start on Windows, the system configures a *KnownDlls*
    OMNS directory containing a list of preloaded image sections. A *KnownDlls* <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object’s name is just the
    filename of the library. The DLL loader can check *KnownDlls* first before going
    to the disk. This improves performance as the loader no longer needs to create
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object for
    the file. It also has a security benefit, ensuring that anything considered to
    be a known DLL can’t be hijacked.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何用户应用程序启动之前，系统会配置一个包含预加载图像段列表的 *KnownDlls* OMNS 目录。*KnownDlls* <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    对象的名称就是库的文件名。DLL 加载器在访问磁盘之前可以首先检查 *KnownDlls*。这样可以提高性能，因为加载器不再需要为文件创建新的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> 对象。它还具有安全性优势，确保任何被认为是已知
    DLL 的文件都无法被劫持。
- en: We can list the object directory using the *NtObject* drive, as shown in [Listing
    3-3](chapter3.xhtml#Lis3-3).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 *NtObject* 驱动器列出对象目录，如 [清单 3-3](chapter3.xhtml#Lis3-3) 所示。
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: Listing the contents of the <samp class="SANS_Futura_Std_Book_11">KnownDlls</samp>
    object directory'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-3：列出 <samp class="SANS_Futura_Std_Book_11">KnownDlls</samp> 对象目录的内容
- en: This section covered the basics of the Win32 subsystem and how it uses libraries
    to implement the APIs that a user-mode application can use to interface with the
    operating system. We’ll come back to the Win32 APIs later, but first we must discuss
    the Windows user interface, which is inextricably linked to how the Win32 subsystem
    functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讲解了 Win32 子系统的基础知识，以及它如何使用库来实现用户模式应用程序可以用来与操作系统交互的 API。我们稍后会回到 Win32 API，但首先我们必须讨论
    Windows 用户界面，它与 Win32 子系统的功能密不可分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Win32 GUI</samp>
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Win32 GUI</samp>
- en: The name “Windows” refers to the structure of the operating system’s graphical
    user interface (GUI). This GUI consists of one or more windows that the user can
    interact with using controls such as buttons and text input. Since Windows 1.0,
    the GUI has been the most important feature of the operating system, so it should
    come as no surprise that its model is complex. The implementation of the GUI is
    split between the kernel and user mode, as shown in [Figure 3-2](chapter3.xhtml#fig3-2).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “Windows”这个名字指的是操作系统图形用户界面（GUI）的结构。这个 GUI 由一个或多个窗口组成，用户可以通过按钮、文本输入等控件与之交互。自
    Windows 1.0 以来，GUI 一直是操作系统最重要的特性，因此它的模型复杂也就不足为奇了。GUI 的实现分为内核模式和用户模式，如 [图 3-2](chapter3.xhtml#fig3-2)
    所示。
- en: '![](../images/Figure3-2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The Win32 GUI modules</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-2：Win32 GUI 模块</samp>
- en: 'You might notice that the left-hand side of [Figure 3-2](chapter3.xhtml#fig3-2)
    looks a lot like [Figure 3-1](chapter3.xhtml#fig3-1), which showed the modules
    for the normal Win32 APIs. In place of *NTDLL*, however, is *WIN32U*, which implements
    system call stubs for the kernel to call. Two libraries call *WIN32U*: *USER32*
    and *GDI32*. *USER32* implements the window UI elements and generally manages
    the GUI, whereas *GDI32* implements drawing primitives, like fonts and shapes.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 [图 3-2](chapter3.xhtml#fig3-2) 的左侧看起来非常像 [图 3-1](chapter3.xhtml#fig3-1)，后者显示了普通
    Win32 API 的模块。只不过，*NTDLL* 被 *WIN32U* 取代，*WIN32U* 实现了供内核调用的系统调用存根。两个库调用 *WIN32U*：*USER32*
    和 *GDI32*。*USER32* 实现了窗口 UI 元素并通常管理 GUI，而 *GDI32* 实现了绘图原语，如字体和形状。
- en: One big difference between [Figure 3-2](chapter3.xhtml#fig3-2) and [Figure 3-1](chapter3.xhtml#fig3-1)
    is that the GUI is not actually implemented inside the main NTOS kernel executive.
    Instead, its system calls are implemented in the *WIN32K* driver, which interfaces
    with the object manager, the kernel, and the display drivers to handle user interactions
    and display the results. The *WIN32K* driver also implements a system call table
    that is separate from the kernel’s.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-2](chapter3.xhtml#fig3-2) 与 [图 3-1](chapter3.xhtml#fig3-1) 之间的一个大区别是，GUI
    并没有实际实现于主 NTOS 内核执行体内。相反，它的系统调用是通过 *WIN32K* 驱动程序实现的，该驱动程序与对象管理器、内核和显示驱动程序接口，以处理用户交互并显示结果。*WIN32K*
    驱动程序还实现了一个与内核分开的系统调用表。'
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In versions of Windows prior to 10, the system call dispatch code in* WIN32U
    *was embedded directly inside the user-mode DLLs. This made it hard for an application
    to directly call* WIN32K *system calls without writing assembly language.*'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在 Windows 10 之前的版本中，*WIN32U* 中的系统调用分派代码是直接嵌入在用户模式 DLL 中的。这使得应用程序难以直接调用 *WIN32K*
    系统调用，而不编写汇编语言。*'
- en: 'The GUI APIs also interact with a special privileged process: the *Client Server
    Runtime Subsystem (CSRSS)*. This process is responsible for handling certain privileged
    operations for lower-privileged clients, such as configuring per-user drive mappings,
    process management, and error handling.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: GUI API 还与一个特殊的特权进程进行交互：*客户端服务器运行时子系统 (CSRSS)*。该进程负责为较低特权的客户端处理某些特权操作，例如配置每用户的驱动器映射、进程管理和错误处理。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GUI Kernel Resources</samp>
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GUI 内核资源</samp>
- en: 'The GUI is made up of four types of kernel resources:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 由四种类型的内核资源组成：
- en: '**Window stations    **Objects that represent the connection to the screen
    and the user interface, such as the keyboard and mouse'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口站**    代表与屏幕和用户界面（如键盘和鼠标）的连接的对象'
- en: '**Windows    **GUI elements for interacting with the user, accepting input,
    and displaying a result'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口**    与用户交互的 GUI 元素，接收输入并显示结果'
- en: '**Desktops    **Objects that represent the visible desktop and act as a host
    for windows'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**桌面**    代表可见桌面的对象，并充当窗口的宿主'
- en: '**Drawing resources    **Bitmaps, fonts, or anything else that needs to be
    displayed to the user'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘图资源**    位图、字体或其他需要展示给用户的内容'
- en: While the Win32 kernel and user components handle the windows, the window stations
    and desktops are accessible through the object manager. There are kernel object
    types for window stations and desktops, as shown in [Listing 3-4](chapter3.xhtml#Lis3-4).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Win32 内核和用户组件处理窗口，但窗口站和桌面是通过对象管理器访问的。如 [列表 3-4](chapter3.xhtml#Lis3-4) 所示，窗口站和桌面有内核对象类型。
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-4: Showing the WindowStation and Desktop type objects'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-4：显示 WindowStation 和 Desktop 类型对象
- en: A window station is assigned to a process either at process startup or using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUserSetProcessWindowStation</samp>
    API. Desktops are assigned on a per-thread basis using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUserSetThreadDesktop</samp>.
    We can query the names of the window stations and desktops with the commands in
    [Listing 3-5](chapter3.xhtml#Lis3-5).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个窗口站在进程启动时或通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUserSetProcessWindowStation</samp>
    API 被分配给一个进程。桌面是按线程分配的，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUserSetThreadDesktop</samp>。我们可以使用
    [列表 3-5](chapter3.xhtml#Lis3-5) 中的命令查询窗口站和桌面的名称。
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-5: Displaying all the current window stations and desktops'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-5：显示所有当前的窗口站和桌面
- en: 'We start by querying the names of all available window stations ❶. In this
    example, there are two: the default <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>
    window station and <samp class="SANS_TheSansMonoCd_W5Regular_11">Service-0x0-b17580b$</samp>,
    which another process has created. The ability to create separate window stations
    allows a process to isolate its GUI interactions from other processes running
    at the same time. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>
    is special, as it is the only object connected to the user’s console.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查询所有可用窗口站的名称❶。在这个例子中，有两个：默认的 <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>
    窗口站和另一个进程创建的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Service-0x0-b17580b$</samp>。创建独立窗口站的能力允许一个进程将其图形界面交互与其他同时运行的进程隔离。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp> 是特殊的，因为它是唯一与用户控制台连接的对象。
- en: Next, we check what our current window station name is by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Current</samp>
    parameter ❷. We can see we’re on <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Current</samp> 参数❷来检查当前窗口站的名称。我们可以看到，我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp> 上。
- en: 'We then query for the names of the desktops on our current window station ❸.
    We see only two desktops: <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WinLogon</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">WinLogon</samp>
    desktop will be visible only if you run the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDesktopName</samp>
    command as an administrator, as it’s used solely to display the login screen,
    which a normal user application shouldn’t be able to access. <samp class="SANS_TheSansMonoCd_W5Regular_11">Desktop</samp>
    objects must be opened relative to a window station path; there isn’t a specific
    object directory for desktops. Therefore, the name of the desktop reflects the
    name of the window station object.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们查询当前窗口站上的桌面名称❸。我们只看到两个桌面：<samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">WinLogon</samp>。只有在以管理员身份运行 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDesktopName</samp> 命令时，<samp class="SANS_TheSansMonoCd_W5Regular_11">WinLogon</samp>
    桌面才会可见，因为它仅用于显示登录屏幕，普通用户应用程序不应能访问该桌面。<samp class="SANS_TheSansMonoCd_W5Regular_11">Desktop</samp>
    对象必须相对于窗口站路径打开；桌面没有特定的对象目录。因此，桌面的名称反映了窗口站对象的名称。
- en: Finally, we check the name of the current thread’s desktop ❹. The desktop we’re
    attached to is shown as <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>,
    as that’s the only desktop available to normal user applications. We can enumerate
    the windows created in a desktop using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDesktop</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtWindow</samp> ([Listing
    3-6](chapter3.xhtml#Lis3-6)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查当前线程桌面的名称❹。我们连接的桌面显示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>，因为这是普通用户应用程序唯一可用的桌面。我们可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDesktop</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtWindow</samp>
    来列举桌面中创建的窗口（见 [Listing 3-6](chapter3.xhtml#Lis3-6)）。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-6: Enumerating windows for the current desktop'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-6: 为当前桌面列举窗口'
- en: As you can see, each window has a few properties. First is its *handle*, which
    is unique to the desktop. This is not the same type of handle we discussed in
    the preceding chapter for kernel objects; instead, it’s a value allocated by the
    Win32 subsystem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个窗口都有一些属性。首先是它的*句柄*，该句柄在桌面中是唯一的。这与我们在前一章讨论的内核对象句柄不同；它是由 Win32 子系统分配的一个值。
- en: To function, a window receives *messages* from the system. For example, when
    you click a mouse button on a window, the system will send a message to notify
    the window of the click and what mouse button was pressed. The window can then
    handle the message and change its behavior accordingly. You can also manually
    send messages to a window using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SendMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PostMessage</samp> APIs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正常工作，窗口需要接收来自系统的*消息*。例如，当你点击窗口上的鼠标按钮时，系统会发送一条消息通知窗口点击事件及按下的鼠标按钮。窗口随后可以处理该消息，并根据需要改变其行为。你也可以通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SendMessage</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">PostMessage</samp>
    API 手动发送消息到窗口。
- en: Each message consists of a numeric identifier—such as <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>,
    which represents the message <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>
    to close a window—and two additional parameters. The meaning of the two parameters
    depends on the message. For example, if the message is <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>,
    then neither parameter is used; for other messages, they might represent pointers
    to strings or integer values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消息由一个数字标识符组成——例如<samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>，它表示消息<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>，用于关闭窗口——以及两个额外的参数。这两个参数的含义取决于消息。例如，如果消息是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>，那么两个参数都不会使用；对于其他消息，它们可能表示指向字符串或整数值的指针。
- en: Messages can be sent or posted. The difference between sending and posting a
    message is that sending waits for the window to handle the message and return
    a value, while posting just sends the message to the window and returns immediately.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以是发送的或发布的。发送消息和发布消息的区别在于，发送消息会等待窗口处理消息并返回一个值，而发布消息则只是将消息发送到窗口并立即返回。
- en: In [Listing 3-6](chapter3.xhtml#Lis3-6), the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessId</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadId</samp> columns identify
    the process and thread that created a window using an API such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp>.
    A window has what’s called *thread affinity*, which means that only the creating
    thread can manipulate the state of the window and handle its messages. However,
    any thread can send messages to the window. To handle messages, the creating thread
    must run a *message loop*, which calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetMessage</samp>
    API to receive the next available message and then dispatches it to the window’s
    message handler callback function using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DispatchMessage</samp>
    API. When an application is not running the loop, you might see Windows applications
    hanging, as without the loop, the GUI cannot be updated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 3-6](chapter3.xhtml#Lis3-6)中，<samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessId</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ThreadId</samp>列标识了使用诸如<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp>等API创建窗口的进程和线程。窗口具有所谓的*线程亲和性*，这意味着只有创建该窗口的线程才能操作窗口的状态并处理其消息。然而，任何线程都可以向窗口发送消息。为了处理消息，创建线程必须运行一个*消息循环*，该循环调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetMessage</samp>API接收下一个可用的消息，然后使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DispatchMessage</samp>API将其分发到窗口的消息处理回调函数。当应用程序没有运行循环时，你可能会看到Windows应用程序挂起，因为没有循环，GUI无法更新。
- en: The final column in [Listing 3-6](chapter3.xhtml#Lis3-6) is the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp>.
    This is the name of a *window class*, which acts as a template for a new window.
    When <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp> is called,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp> is specified
    and the window is initialized with default values from the template, such as the
    style of the border or a default size. It’s common for an application to register
    its own classes to handle unique windows. Alternatively, it can use system-defined
    classes for things like buttons and other common controls.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 3-6](chapter3.xhtml#Lis3-6)的最后一列是<samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp>。这是一个*窗口类*的名称，它充当新窗口的模板。当调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp>时，指定<samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp>，窗口将使用模板中的默认值进行初始化，例如边框样式或默认大小。应用程序通常会注册自己的类来处理独特的窗口。或者，它可以使用系统定义的类来处理按钮和其他常见控件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Window Messages</samp>
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">窗口消息</samp>
- en: Let’s look at a simple example in [Listing 3-7](chapter3.xhtml#Lis3-7), in which
    we send a window message to find the caption text for all the windows on the desktop.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，在[列表 3-7](chapter3.xhtml#Lis3-7)中，我们向窗口发送一个消息，用于查找桌面上所有窗口的标题文本。
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-7: Sending the WM_GETTEXT message to all windows on the desktop'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-7：向桌面上所有窗口发送WM_GETTEXT消息
- en: First, we enumerate all the windows on the current desktop using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtWindow</samp>
    command ❶. Next, we allocate a memory buffer to store 2,048 characters ❷. Keep
    in mind that we’ll be using this buffer to store 16-bit Unicode characters, so
    the number of characters must be multiplied by 2 to determine the size in bytes
    for the buffer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtWindow</samp> 命令❶枚举当前桌面上的所有窗口。接下来，我们分配一个内存缓冲区来存储
    2,048 个字符❷。请记住，我们将使用此缓冲区存储 16 位的 Unicode 字符，因此字符数必须乘以 2，以确定缓冲区的字节大小。
- en: 'In a loop ❸, we then send the <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_GETTEXT</samp>
    message (which is message number <samp class="SANS_TheSansMonoCd_W5Regular_11">0xD</samp>)
    to every window to query the window’s caption. We need to specify two parameters:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LParam</samp>, which is a pointer
    to the buffer we allocated, and <samp class="SANS_TheSansMonoCd_W5Regular_11">WParam</samp>,
    which is the maximum number of Unicode characters in the buffer. The values passed
    in these two parameters will be different for different message types. We wait
    to receive the result of sending the message, which indicates the number of characters
    that were copied into the buffer. We can then read out the caption string and
    print it to the output, ignoring any windows that have an empty caption.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个循环❸中，我们向每个窗口发送 <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_GETTEXT</samp>
    消息（消息号为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xD</samp>），以查询窗口的标题。我们需要指定两个参数：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LParam</samp>，它是指向我们分配的缓冲区的指针，以及 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WParam</samp>，它是缓冲区中 Unicode 字符的最大数量。这两个参数传递的值对于不同的消息类型会有所不同。我们等待接收发送消息的结果，这表明有多少字符被复制到缓冲区中。然后我们可以读取标题字符串并将其打印到输出，忽略任何没有标题的窗口。
- en: There is much more to explore in the windowing system, but those details are
    outside the scope of this book. I recommend Charles Petzold’s seminal work on
    the topic, *Programming Windows*, 5th edition (Microsoft Press, 1998), if you
    want to know more about the development of Win32 applications. Next, we’ll look
    at how multiple users can use their own user interfaces on the same system through
    the creation of console sessions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口系统还有很多内容值得探索，但这些细节超出了本书的范围。如果你想深入了解 Win32 应用程序的开发，我推荐 Charles Petzold 的开创性著作《*Windows
    编程*》第五版（微软出版社，1998年）。接下来，我们将讨论如何通过创建控制台会话，让多个用户在同一系统上使用各自的用户界面。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Console Sessions</samp>
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">控制台会话</samp>
- en: The first version of Windows NT allowed multiple users to be authenticated at
    the same time and each run processes. However, before the introduction of *Remote
    Desktop Services (RDS)*, it wasn’t possible for different interactive desktops
    to run multiple user accounts concurrently on the same machine. All authenticated
    users needed to share a single physical console. Windows NT 4 introduced multiple-console
    support as an optional, server-only feature before it became standard in Windows
    XP.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Windows NT 的第一个版本允许多个用户同时进行身份验证，并各自运行进程。然而，在引入*远程桌面服务（RDS）*之前，无法在同一台机器上并行运行多个用户账户的不同交互式桌面。所有已认证的用户需要共享一个物理控制台。Windows
    NT 4 引入了多控制台支持，作为一种可选的服务器功能，直到它在 Windows XP 中成为标准功能。
- en: RDS is a service on Windows workstations and servers that allows you to remotely
    connect to the GUI and interact with the system. It’s used for remote administration
    and to provide shared hosting for multiple users on the same network-connected
    system. In addition, its functionality has been repurposed to support a mechanism
    that can switch between users on the same system without having to log users out.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: RDS 是 Windows 工作站和服务器上的一项服务，允许你远程连接到图形用户界面并与系统交互。它用于远程管理，并为多个用户提供在同一网络连接系统上的共享主机。此外，它的功能已经被重新用于支持一种机制，可以在同一系统上在不登出用户的情况下切换用户。
- en: To prepare for a new user login to Windows, the session manager service creates
    a new session on the console. This session is used to organize a user’s window
    station and desktop objects so that they’re separate from those belonging to any
    other user authenticated at the same time. The kernel creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp>
    object to keep track of resources, and a named reference to the object is stored
    in the *KernelObjects* OMNS directory. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp>
    object is usually only exposed to the user as an integer. There’s no randomness
    to the integer; it’s just incremented as each new console session is created.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备新的用户登录Windows，会话管理服务在控制台上创建一个新的会话。这个会话用于组织用户的窗口站和桌面对象，使其与同时验证的其他用户的对象隔离。内核创建一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Session</samp>对象来跟踪资源，并将该对象的命名引用存储在*KernelObjects*
    OMNS目录中。然而，<samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp>对象通常仅以整数形式向用户暴露。这个整数没有随机性；它只是随着每个新控制台会话的创建而递增。
- en: The session manager starts several processes in this new session before any
    user logs in. These include a dedicated copy of CSRSS and the Winlogon process,
    which display the *credentials* user interface and handle the authentication of
    the new user. We’ll dig into the authentication process more in [Chapter 12](chapter12.xhtml).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 会话管理器在新的会话中启动几个进程，在任何用户登录之前。这些进程包括CSRSS和Winlogon的专用副本，它们显示*凭据*用户界面并处理新用户的身份验证。我们将在[第12章](chapter12.xhtml)中深入探讨身份验证过程。
- en: The console session that a process belongs to is assigned when the process starts.
    (Technically, the console session is specified in the access token, but that’s
    a topic for [Chapter 4](chapter4.xhtml).) We can observe the processes running
    in each session by running some PowerShell commands, as shown in [Listing 3-8](chapter3.xhtml#Lis3-8).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 进程所属的控制台会话在进程启动时分配。（从技术上讲，控制台会话在访问令牌中指定，但这是[第4章](chapter4.xhtml)的内容。）我们可以通过运行一些PowerShell命令来观察每个会话中运行的进程，如[清单3-8](chapter3.xhtml#Lis3-8)所示。
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-8: Displaying the processes in each console session using Get-NtProcess'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3-8：使用Get-NtProcess显示每个控制台会话中的进程
- en: Windows has only one physical console, which is connected to the keyboard, mouse,
    and monitor. However, it’s possible to create a new remote desktop over the network
    by using a client that communicates using the *Remote Desktop Protocol (RDP)*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Windows只有一个物理控制台，它连接到键盘、鼠标和显示器。不过，可以通过使用客户端并通过*远程桌面协议（RDP）*在网络上创建一个新的远程桌面。
- en: It’s also possible to switch the user logged on to the physical console; this
    enables support for the *Fast User Switching* feature in Windows. When the physical
    console switches to a new user, the previous user is still logged on and running
    in the background, but you cannot interact with that user’s desktop.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以切换登录物理控制台的用户，这支持Windows中的*快速用户切换*功能。当物理控制台切换到新用户时，先前的用户仍然登录并在后台运行，但无法与该用户的桌面进行交互。
- en: Each console session has its own special kernel memory region. Having duplicated
    resources ensures that the console sessions are separated; this acts as a security
    boundary. Session number 0 is special, in that it’s only for privileged services
    and system management. It’s normally not possible to use a GUI with processes
    running in this session.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制台会话都有自己专门的内核内存区域。资源的复制确保了控制台会话的隔离，这充当了一个安全边界。会话编号0是特别的，它仅用于特权服务和系统管理。通常无法在此会话中使用GUI进行操作。
- en: Another important feature associated with console sessions is the separation
    of named objects. In the previous chapter we discussed the *BaseNamedObjects*
    directory, which is a global location for named objects that provides a means
    for multiple users to share resources. However, if multiple users can be logged
    in to the system at the same time, you could easily get name conflicts. Windows
    solves this problem by creating a per-console session BNO directory at *\Sessions\<N>\BaseNamedObjects*,
    where *<N>* is the console session ID. The *\Sessions* directory also contains
    a directory for the window stations, under *\Sessions\<N>\Windows*, which ensures
    that window resources, too, are separated. You can list the BNO directory of the
    current console session with the *NtObjectSession* drive, as shown in [Listing
    3-9](chapter3.xhtml#Lis3-9).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与控制台会话相关的另一个重要特性是命名对象的隔离。在上一章中，我们讨论了 *BaseNamedObjects* 目录，这是一个用于命名对象的全局位置，提供了一种多用户共享资源的方式。然而，如果多个用户可以同时登录系统，就容易出现名称冲突。Windows
    通过在 *\Sessions\<N>\BaseNamedObjects* 目录下创建每个控制台会话的 BNO 目录来解决这个问题，其中 *<N>* 是控制台会话
    ID。*Sessions* 目录还包含一个窗口站的目录，位于 *\Sessions\<N>\Windows* 下，确保窗口资源也得到隔离。你可以使用 *NtObjectSession*
    驱动器列出当前控制台会话的 BNO 目录，如 [列表 3-9](chapter3.xhtml#Lis3-9) 所示。
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-9: The contents of a session’s BNO directory'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-9：一个会话的 BNO 目录内容
- en: There is no per-console session BNO for session 0; it uses the global BNO directory.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 会话 0 没有每个控制台会话的 BNO，它使用全局 BNO 目录。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comparing Win32 APIs and System Calls</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">比较 Win32 API 和系统调用</samp>
- en: Not all system calls are directly exposed through Win32, and in some cases,
    the Win32 API reduces the functionality of exposed system calls. In this section,
    we’ll look at some common differences between system calls and their Win32 API
    equivalents.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的系统调用都直接通过 Win32 公开，在某些情况下，Win32 API 会减少暴露的系统调用的功能。在本节中，我们将探讨一些系统调用与其 Win32
    API 等价物之间的常见差异。
- en: As a case study, we’ll consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    API, the Win32 version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call we looked at in the preceding chapter. The API has the C prototype
    shown in [Listing 3-10](chapter3.xhtml#Lis3-10).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为案例研究，我们将考虑 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    API，这是我们在前一章中讨论的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    系统调用的 Win32 版本。该 API 具有 [列表 3-10](chapter3.xhtml#Lis3-10) 所示的 C 原型。
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-10: The prototype for the CreateMutexEx Win32 API'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-10：CreateMutexEx Win32 API 的原型
- en: Compare it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    prototype, shown in [Listing 3-11](chapter3.xhtml#Lis3-11).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> 原型进行比较，见
    [列表 3-11](chapter3.xhtml#Lis3-11)。
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-11: The prototype for the NtCreateMutant system call'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-11：NtCreateMutant 系统调用的原型
- en: The first difference between the prototypes is that the Win32 API returns a
    handle to the kernel object, while the system call returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    code (and receives the handle via a pointer as the first parameter instead).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 原型之间的第一个区别是，Win32 API 返回一个内核对象的句柄，而系统调用返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    代码（并通过指针将句柄作为第一个参数接收）。
- en: 'You might wonder: How do errors get propagated back to an API’s caller, if
    not via an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> code?
    In this respect, the Win32 APIs are not always consistent. If the API returns
    a handle, then it’s common to return a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>.
    However, some APIs, such as the file APIs, return the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    instead. If a handle is not returned, it’s common to return a Boolean value, with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp> indicating success and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FALSE</samp> indicating an error.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：如果不是通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> 代码，错误如何传递回
    API 的调用者？在这方面，Win32 API 并不总是保持一致。如果 API 返回一个句柄，通常会返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    值。然而，一些 API，如文件 API，会返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    作为值。如果没有返回句柄，通常会返回一个布尔值，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp>
    表示成功，<samp class="SANS_TheSansMonoCd_W5Regular_11">FALSE</samp> 表示出错。
- en: But what if we want to know *why* the API failed? For this purpose, the APIs
    define a set of error codes. Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    codes, these error codes don’t have any structure; they’re just numbers. When
    a Windows API fails, you can query for this error code by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>
    API.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想知道 API 失败的*原因*呢？为此，这些 API 定义了一组错误代码。与 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    代码不同，这些错误代码没有任何结构，它们只是数字。当 Windows API 失败时，可以通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>
    API 查询该错误代码。
- en: '*NTDLL* provides an <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNtStatusToDosError</samp>
    API to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    code to a predefined Win32 error code. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    API can convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    code to a Win32 error code on failure, then write it to the last error location
    for the current thread using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp>
    API.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*NTDLL* 提供了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNtStatusToDosError</samp>
    API，用于将 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> 代码转换为预定义的
    Win32 错误代码。<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    API 可以在失败时将 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> 代码转换为
    Win32 错误代码，然后使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp>
    API 将其写入当前线程的最后错误位置。'
- en: We can look up error codes in PowerShell using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32Error</samp>,
    as shown in [Listing 3-12](chapter3.xhtml#Lis3-12).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 PowerShell 中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32Error</samp>
    查找错误代码，如 [列表 3-12](chapter3.xhtml#Lis3-12) 所示。
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 3-12: Looking up Win32 error code 5'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-12：查找 Win32 错误代码 5
- en: 'The second big difference between the system call and the Win32 API is that
    the API does not take the <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>
    structure. Instead, it splits the attributes between two parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">lpName</samp>,
    used to specify the object’s name, and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpMutexAttributes</samp>,
    which is a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_ATTRIBUTES</samp>
    structure.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用和 Win32 API 之间的第二个主要区别是，API 不接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>
    结构。相反，它将属性分成两个参数：<samp class="SANS_TheSansMonoCd_W5Regular_11">lpName</samp>，用于指定对象的名称，和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lpMutexAttributes</samp>，它是指向 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_ATTRIBUTES</samp> 结构的指针。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">lpName</samp> parameter is
    a NUL-terminated string composed of 16-bit Unicode characters. Even though the
    object manager uses the counted <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>,
    the Win32 API uses a C-style terminated string. This means that while the NUL
    character is a valid character for an object name, it’s impossible to specify
    using the Win32 API.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lpName</samp> 参数是一个以 NUL 结尾的字符串，由
    16 位 Unicode 字符组成。尽管对象管理器使用计数字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>，但
    Win32 API 使用 C 风格的结尾字符串。这意味着，虽然 NUL 字符是对象名称的有效字符，但在 Win32 API 中无法指定它。
- en: Another difference is that the name is not a full path to the OMNS location
    for the object; instead, it’s relative to the current session’s BNO directory.
    This means that if the name is *ABC*, then the final path used is *\Sessions\<N>\BaseNamedObjects\ABC*,
    where *<N>* is the console session ID. If you want to create an object in the
    global BNO directory, you can prefix the name with *Global* (for example, *Global\ABC*).
    This works because *Global* is a symbolic link to *\BaseNamedObjects*, which is
    automatically created along with the per-session BNO directory. If you want to
    simulate this behavior using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">New</samp> PowerShell commands,
    pass them the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Win32Path</samp>
    option, as shown in [Listing 3-13](chapter3.xhtml#Lis3-13).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，名称不是对象 OMNS 位置的完整路径；相反，它是相对于当前会话的 BNO 目录的。这意味着，如果名称是 *ABC*，则最终使用的路径是
    *\Sessions\<N>\BaseNamedObjects\ABC*，其中 *<N>* 是控制台会话 ID。如果你想在全局 BNO 目录中创建对象，可以将名称前缀为
    *Global*（例如，*Global\ABC*）。这之所以有效，是因为 *Global* 是指向 *\BaseNamedObjects* 的符号链接，而
    *\BaseNamedObjects* 会随着每个会话的 BNO 目录一起自动创建。如果你想使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">New</samp> PowerShell 命令模拟这种行为，可以传递
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-Win32Path</samp> 选项，如 [列表 3-13](chapter3.xhtml#Lis3-13)
    所示。
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 3-13: Creating a new Mutant with -Win32Path'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-13：使用 -Win32Path 创建新的 Mutant
- en: '[Listing 3-14](chapter3.xhtml#Lis3-14) shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_ATTRIBUTES</samp>
    structure.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-14](chapter3.xhtml#Lis3-14) 显示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_ATTRIBUTES</samp>
    结构。'
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 3-14: The SECURITY_ATTRIBUTES structure'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-14：SECURITY_ATTRIBUTES 结构
- en: This allows you to specify the security descriptor of the new object, as well
    as whether the handle should be inheritable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    Win32 API exposes no other options from <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你指定新对象的安全描述符，以及句柄是否应可继承。<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    Win32 API 并未暴露来自 <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>
    的其他选项。
- en: 'This brings us to the final two parameters in [Listing 3-10](chapter3.xhtml#Lis3-10):
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp> directly
    maps to <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>, and
    the native <samp class="SANS_TheSansMonoCd_W5Regular_11">InitialOwner</samp> parameter
    is specified through <samp class="SANS_TheSansMonoCd_W5Regular_11">dwFlags</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_MUTEX_INITIAL_OWNER</samp>
    flag.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们来到了 [列表 3-10](chapter3.xhtml#Lis3-10) 中的最后两个参数：<samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    直接映射到 <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>，而本地的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InitialOwner</samp> 参数则通过 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dwFlags</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_MUTEX_INITIAL_OWNER</samp>
    标志来指定。
- en: One surprise you might encounter may occur if you try to look up the address
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp> API
    in the export table of the *KERNEL32* DLL ([Listing 3-15](chapter3.xhtml#Lis3-15)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能遇到的一个意外情况是，如果你尝试在 *KERNEL32* DLL 的导出表中查找 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    API 的地址，会发生异常（参见 [列表 3-15](chapter3.xhtml#Lis3-15)）。
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 3-15: Getting CreateMutexEx from <samp class="SANS_Futura_Std_Book_11">KERNEL32</samp>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-15：从 <samp class="SANS_Futura_Std_Book_11">KERNEL32</samp> 获取 CreateMutexEx
- en: Instead of receiving the address, we get an exception. Did we pick the wrong
    library? Let’s try to find the API by dumping all exports and filtering them by
    name, as shown in [Listing 3-16](chapter3.xhtml#Lis3-16).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有收到地址，而是遇到了异常。我们是不是选错了库？让我们通过转储所有导出项并按名称过滤，来尝试找到该 API，如 [列表 3-16](chapter3.xhtml#Lis3-16)
    所示。
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 3-16: Finding the CreateMutexEx API by listing all exports'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-16：通过列出所有导出项来查找 CreateMutexEx API
- en: As you can see, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    API is there not once, but twice. Each function has a suffix, either <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>. This is because Windows
    95 (where most of the APIs were initially created) didn’t natively support Unicode
    strings, so the APIs used single-character strings in the current text encoding.
    With the introduction of Windows NT, the kernel became 100 percent Unicode, but
    it provided two APIs for a single function to enable older Windows 95 applications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp> API
    出现了不止一次，每个函数都有一个后缀，要么是 <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>，要么是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>。这是因为 Windows 95（大多数 API
    最初创建的地方）并不原生支持 Unicode 字符串，因此这些 API 使用当前文本编码的单字符字符串。随着 Windows NT 的推出，内核完全支持 Unicode，但它为每个函数提供了两个
    API，以便兼容旧版 Windows 95 应用程序。
- en: APIs with an <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> suffix accept
    single-character strings, or *ANSI strings*. These APIs convert their strings
    into Unicode strings to pass to the kernel, and they convert them back again if
    a string needs to be returned. Applications built for Windows NT, on the other
    hand, can use the APIs with the <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>
    suffix, for *wide string*; these don’t need to do any string conversions. Which
    API you get when you build a native application depends on your build configuration
    and is a topic for a completely different book.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> 后缀的 API 接受单字符字符串或
    *ANSI 字符串*。这些 API 会将其字符串转换为 Unicode 字符串并传递给内核，如果需要返回字符串，它们会再转换回去。另一方面，为 Windows
    NT 构建的应用程序可以使用带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp> 后缀的 API，用于
    *宽字符字符串*；这些 API 不需要做任何字符串转换。您在构建本地应用程序时会使用哪个 API 取决于您的构建配置，这是另一本书的主题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Win32 Registry Paths</samp>
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Win32 注册表路径</samp>
- en: In [Chapter 2](chapter2.xhtml), you learned the basics of how to access the
    registry with native system calls using paths in the OMNS. The Win32 APIs used
    to access the registry, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">RegCreateKeyEx</samp>,
    do not expose these OMNS paths. Instead, you access registry keys relative to
    predefined root keys. You’ll be familiar with these keys if you’ve ever used the
    Windows regedit application, shown in [Figure 3-3](chapter3.xhtml#fig3-3).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](chapter2.xhtml)中，您学习了如何使用 OMNS 路径通过本地系统调用访问注册表的基本知识。用于访问注册表的 Win32
    API，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegCreateKeyEx</samp>，并不直接暴露这些
    OMNS 路径。相反，您是相对于预定义的根键访问注册表键的。如果您曾使用过 Windows 的 regedit 应用程序，您应该熟悉这些键，如 [图 3-3](chapter3.xhtml#fig3-3)
    所示。
- en: '![](../images/Figure3-3.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: The main view of
    the regedit utility</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-3：regedit 工具的主视图</samp>
- en: The handle values displayed in [Figure 3-3](chapter3.xhtml#fig3-3) are listed
    in [Table 3-1](chapter3.xhtml#tab3-1) along with their corresponding OMNS paths.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-3](chapter3.xhtml#fig3-3) 中显示的句柄值与它们对应的 OMNS 路径一起列在 [表 3-1](chapter3.xhtml#tab3-1)
    中。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">Predefined
    Registry Handles and Their Native Equivalents</samp>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-1：</samp> <samp class="SANS_Futura_Std_Book_11">预定义的注册表句柄及其本地等效项</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Predefined handle name</samp> |
    <samp class="SANS_Futura_Std_Heavy_B_11">OMNS path</samp> |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">预定义句柄名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">OMNS
    路径</samp> |'
- en: '| --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE</samp> |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_USERS</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER</samp>
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_USERS</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_CONFIG</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE\SYSTEM\CurrentControlSet\Hardware
    Profiles\Current</samp> |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_CONFIG</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE\SYSTEM\CurrentControlSet\Hardware
    Profiles\Current</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER\<SDDL SID></samp>
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER\<SDDL SID></samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CLASSES_ROOT</samp> |
    <samp class="SANS_Futura_Std_Book_11">Merged view of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE\SOFTWARE\Classes</samp>
    <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER\<SDDL
    SID>_Classes</samp> |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CLASSES_ROOT</samp> |
    <samp class="SANS_Futura_Std_Book_11">合并视图</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE\SOFTWARE\Classes</samp>
    <samp class="SANS_Futura_Std_Book_11">与</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER\<SDDL
    SID>_Classes</samp> |'
- en: The first three predefined handles, <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_USERS</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_CONFIG</samp>,
    are not particularly special; they directly map to a single OMNS registry key
    path. The next handle, <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp>,
    is more interesting; it maps to a hive loaded for the currently authenticated
    user. The name of the hive’s key is the SDDL string of the user’s SID.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个预定义句柄，<samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HKEY_USERS</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_CONFIG</samp>，并没有特别的含义；它们直接映射到一个单独的
    OMNS 注册表键路径。下一个句柄，<samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp>，则更有趣；它映射到当前认证用户的
    hive。该 hive 键的名称是用户 SID 的 SDDL 字符串。
- en: The final key, <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CLASSES_ROOT</samp>,
    which stores information such as file extension mappings, is a merged view of
    a user’s classes hive and the machine’s hive. The user’s hive takes precedence
    over the machine’s, allowing the user to change their file extensions without
    needing an administrator.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最终键 <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CLASSES_ROOT</samp> 存储着诸如文件扩展名映射等信息，是用户类
    hive 与机器 hive 的合并视图。用户的 hive 优先于机器的 hive，使得用户可以在无需管理员权限的情况下更改文件扩展名。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opening Keys</samp>
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">开启键</samp>
- en: When using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtKey</samp> commands, we
    can specify a Win32 path by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp>
    parameter ([Listing 3-17](chapter3.xhtml#Lis3-17)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtKey</samp>
    命令时，我们可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp> 参数来指定一个
    Win32 路径（[示例 3-17](chapter3.xhtml#Lis3-17)）。
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 3-17: Interacting with the registry using Win32 paths'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-17：使用 Win32 路径与注册表交互
- en: We start by opening a <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp>
    object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp>
    command. We use the OMNS path to open the key, then convert the path to its Win32
    version using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp>
    property. In this case, we see that *\REGISTRY\MACHINE\SOFTWARE* is mapped to
    *HKEY_LOCAL_MACHINE\SOFTWARE*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp> 命令打开一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> 对象。我们使用 OMNS 路径打开该键，然后使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp> 属性将路径转换为 Win32
    版本。在这种情况下，我们可以看到 *\REGISTRY\MACHINE\SOFTWARE* 被映射到 *HKEY_LOCAL_MACHINE\SOFTWARE*。
- en: 'We then do the reverse and open a key using a Win32 name by specifying the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp> parameter and printing
    its native OMNS path. Here, we use the current user’s hive. Notice we’re using
    a shortened form of the predefined key name: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKCU</samp>,
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp>.
    All the other predefined keys have similar shortened forms; for example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HKLM</samp> refers to <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们执行反向操作，使用 Win32 名称打开一个键，通过指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp>
    参数并打印其本地 OMNS 路径。在这里，我们使用当前用户的 hive。请注意，我们使用了预定义键名称的简写形式：<samp class="SANS_TheSansMonoCd_W5Regular_11">HKCU</samp>，而不是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp>。所有其他预定义键也有类似的简写形式；例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HKLM</samp> 代表 <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>。
- en: In the output, you can see the SDDL SID string, which represents the current
    user. As this example demonstrates, using the Win32 path to access the current
    user’s hive is much simpler than looking up the current user’s SID and opening
    it with the OMNS path.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，你可以看到表示当前用户的 SDDL SID 字符串。如这个例子所示，使用 Win32 路径访问当前用户的 Hive 比查找当前用户的 SID
    并用 OMNS 路径打开它要简单得多。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Listing the Registry’s
    Contents</samp>
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">列出注册表的内容</samp>
- en: 'In the previous chapter, you saw how to list the registry’s contents using
    the *NtObject* or *NtKey* drive provider path. For the Win32 registry, you have
    a few additional options. To simplify accessing the current user’s hive, you can
    use *NtKeyUser*. For example, you can list the current user’s software key with
    the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你已经看到如何使用 *NtObject* 或 *NtKey* 驱动程序路径列出注册表内容。对于 Win32 注册表，你还有一些额外的选项。为了简化访问当前用户的
    Hive，你可以使用 *NtKeyUser*。例如，你可以通过以下命令列出当前用户的 software 键：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'PowerShell also comes with built-in drives, *HKLM* and *HKCU*, for the local
    machine and current user’s hives, respectively. For example, the equivalent to
    the previous command is the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 还内置了驱动器，*HKLM* 和 *HKCU*，分别用于本地机器和当前用户的 Hive。例如，前一个命令的等价命令如下：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Why would you use one of these drive providers over another? Well, the PowerShell
    module’s drive providers have the advantage of allowing you to view the entire
    registry. They also use the native APIs, which use counted strings and support
    the use of NUL characters in the names of the registry keys and values. In contrast,
    the Win32 APIs use NUL-terminated C-style strings, which cannot handle embedded
    NUL characters. Therefore, if a NUL is embedded into a name, it’s impossible for
    the built-in provider to access that key or value. [Listing 3-18](chapter3.xhtml#Lis3-18)
    demonstrates this.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要使用这些驱动程序提供者中的某一个而不是另一个呢？好吧，PowerShell 模块的驱动程序提供者有一个优势，那就是允许你查看整个注册表。它们还使用原生
    API，这些 API 使用计数字符串，并支持在注册表键和值的名称中使用 NUL 字符。相比之下，Win32 API 使用以 NUL 终止的 C 风格字符串，无法处理嵌入的
    NUL 字符。因此，如果名称中嵌入了 NUL 字符，内置的提供者将无法访问该键或值。[示例 3-18](chapter3.xhtml#Lis3-18) 演示了这一点。
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 3-18: Adding and accessing a registry key with a NUL character'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-18：添加并访问包含 NUL 字符的注册表键
- en: We start by creating a new key with a NUL character in the name, indicated by
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">`0</samp> escape ❶. If you access
    this path via the *NtKeyUser* drive, you can successfully retrieve the key ❷.
    However, if you try this with the built-in drive provider, it doesn’t work; it
    can’t find the registry key ❸.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名称中包含 NUL 字符的新键，用 <samp class="SANS_TheSansMonoCd_W5Regular_11">`0</samp>
    转义字符表示❶。通过 *NtKeyUser* 驱动器访问此路径时，你可以成功地检索到该键❷。然而，如果你尝试使用内置驱动程序提供者进行访问，则无法找到该注册表键❸。
- en: This behavior of the Win32 APIs can lead to security issues. For example, it’s
    possible for malicious code to hide registry keys and values from any software
    that uses the Win32 APIs by embedding NUL characters in the name. This can prevent
    the malicious code from being detected. We’ll see how to uncover the use of this
    hiding technique in “Finding Hidden Registry Keys or Values” on page 94.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 API 的这种行为可能导致安全问题。例如，恶意代码通过在名称中嵌入 NUL 字符，可以将注册表键和值隐藏起来，防止任何使用 Win32 API
    的软件检测到。这可以使恶意代码不被发现。在第 94 页的《查找隐藏的注册表键或值》中，我们将看到如何揭示这种隐藏技术的使用。
- en: It’s also possible to get a mismatch if some software uses the native system
    calls and other software uses the Win32 APIs. For example, if some code checks
    the *ABC`0XYZ* path to ensure it has been correctly set up, then hands this to
    another application, which uses the path with the Win32 APIs, the new application
    will instead access the unrelated *ABC* key, which hasn’t been checked. This could
    lead to information disclosure issues if the contents of *ABC* were returned to
    the caller.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一些软件使用原生系统调用，而其他软件使用 Win32 API，也可能导致不匹配。例如，如果某些代码检查 *ABC`0XYZ* 路径以确保其已正确设置，然后将其交给另一个使用
    Win32 API 的应用程序，新应用程序将访问与之无关的 *ABC* 键，而该键并未被检查。如果 *ABC* 的内容返回给调用者，这可能导致信息泄露问题。
- en: 'The built-in registry provider does have an advantage too: it can be used without
    the installation of an external module. It also allows you to create new keys
    and add values, which the module’s provider does not allow you to do.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的注册表提供者也有一个优势：它可以在不安装外部模块的情况下使用。它还允许你创建新键并添加值，而模块的提供者则不允许你这样做。
- en: <samp class="SANS_Futura_Std_Bold_B_11">DOS Device Paths</samp>
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">DOS 设备路径</samp>
- en: Another big difference between the Win32 APIs and the native system calls is
    how they handle filepaths. In the previous chapter, we saw that we can access
    a mounted filesystem using a *Device\<VolumeName>* path. However, we can’t specify
    this native path using the Win32 APIs. Instead, we use well-known paths, such
    as *C:\Windows*, that have drive letters. Because the drive letter paths are a
    vestige of MS-DOS, we call them *DOS device paths*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 API 和原生系统调用之间的另一个主要区别在于它们如何处理文件路径。在上一章中，我们看到可以通过*Device\<VolumeName>*路径访问已挂载的文件系统。然而，我们不能使用
    Win32 API 指定这个原生路径。相反，我们使用的是已知路径，例如*C:\Windows*，并且这些路径包含驱动器字母。由于驱动器字母路径是 MS-DOS
    的遗留物，我们称之为*DOS 设备路径*。
- en: 'Of course, the Win32 API needs to pass the system call a native path for the
    system call to work correctly. The *NTDLL* API <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDosPathNameToNtPathName</samp>
    handles this conversion process. This API takes a DOS device path and returns
    the fully converted native path. The simplest conversion occurs when the caller
    has supplied a full drive path: for example, *C:\Windows*. In these cases, the
    conversion process merely prefixes the path with the predefined path component
    *\??* to get the result *\??\C:\Windows*.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Win32 API 需要传递一个原生路径给系统调用，以便系统调用能正确工作。*NTDLL* API <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDosPathNameToNtPathName</samp>
    负责处理这个转换过程。这个 API 接收一个 DOS 设备路径并返回完全转换后的原生路径。最简单的转换发生在调用者提供了完整的驱动器路径时：例如，*C:\Windows*。在这些情况下，转换过程只是简单地在路径前加上预定义的路径组件*\??*，以获得结果
    *\??\C:\Windows*。
- en: 'The *\??* path, also called the *DOS device map prefix*, indicates that the
    object manager should use a two-step lookup process to find the drive letter.
    The object manager will first check a per-user DOS device map directory, in the
    path *Sessions\0\DosDevices\<AUTHID>*. Because the object manager checks a per-user
    location first, each user can create their own drive mappings. The *<AUTHID>*
    component is related to the authentication session of the caller’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>;
    I’ll describe this in [Chapter 4](chapter4.xhtml), but for now, it’s enough to
    know that its value is unique for each user. Note that the use of *0* for the
    console session ID is not a typo: all DOS device mappings are placed in a single
    location, regardless of which console session the user is logged in to.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*\??* 路径，也叫做*DOS 设备映射前缀*，表示对象管理器应该使用两步查找过程来查找驱动器字母。对象管理器将首先检查每个用户的 DOS 设备映射目录，路径为
    *Sessions\0\DosDevices\<AUTHID>*。由于对象管理器首先检查每个用户的位置，每个用户可以创建自己的驱动器映射。*<AUTHID>*
    组件与调用者的认证会话的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 相关；我将在[第4章](chapter4.xhtml)中描述这一点，但现在了解它的值对于每个用户都是唯一的就足够了。注意，使用*0*作为控制台会话
    ID 不是打字错误：所有的 DOS 设备映射都会放在一个位置，无论用户登录的是哪个控制台会话。'
- en: If the drive letter is not found in the per-user location, the object manager
    will check a global directory, *GLOBAL??*. If it’s not found there, then the file
    lookup fails. The drive letter is an object manager symbolic link that points
    to the mounted volume device. We can see this in action by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSymbolicLink</samp>
    command to open the drive letters and display their properties ([Listing 3-19](chapter3.xhtml#Lis3-19)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在每个用户的位置没有找到驱动器字母，对象管理器将检查一个全局目录 *GLOBAL??*。如果在那里也没有找到，那么文件查找将失败。驱动器字母是一个指向已挂载卷设备的对象管理器符号链接。我们可以通过使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSymbolicLink</samp> 命令来查看驱动器字母并显示它们的属性（[清单
    3-19](chapter3.xhtml#Lis3-19)）。
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 3-19: Displaying the symbolic links for the <samp class="SANS_Futura_Std_Book_11">C:</samp>
    and <samp class="SANS_Futura_Std_Book_11">Z:</samp> drives'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-19：显示 <samp class="SANS_Futura_Std_Book_11">C:</samp> 和 <samp class="SANS_Futura_Std_Book_11">Z:</samp>
    驱动器的符号链接
- en: First, we open the *C:* drive symbolic link and display its <samp class="SANS_TheSansMonoCd_W5Regular_11">FullPath</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> properties. The
    full path is in the *\GLOBAL??* directory, and the target is the volume path ❶.
    We then create a new *Z:* drive using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-DosDevice</samp>
    command, pointing the drive to the *Windows* directory ❷. Note that the *Z:* drive
    is accessible in any user application, not just in PowerShell. Displaying the
    *Z:* drive’s properties reveals that it’s in the per-user DOS device map and that
    the target is the native path to the *Windows* directory ❸. This shows that the
    target of a drive letter doesn’t have to point directly to a volume, as long as
    it gets there eventually (in this case, after following the *C:* drive symbolic
    link). Finally, for completeness, we remove the *Z:* drive with <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-DosDevice</samp>
    ❹.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Path Types</samp>
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 3-2](chapter3.xhtml#tab3-2) shows several different path types that
    the Win32 APIs support, along with example native paths after conversion.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp> <samp class="SANS_Futura_Std_Book_11">Win32
    Path Types</samp>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">DOS path</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Native
    path</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">some\path</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\ABC\some\path</samp> | <samp
    class="SANS_Futura_Std_Book_11">Relative path to current directory</samp> |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">C:\some\path</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp> | <samp class="SANS_Futura_Std_Book_11">Absolute
    path</samp> |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">C:some\path</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\ABC\some\path</samp> | <samp
    class="SANS_Futura_Std_Book_11">Drive relative path</samp> |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\some\path</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp> | <samp class="SANS_Futura_Std_Book_11">Rooted
    to current drive</samp> |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\\.\C:\some\..\path</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\path</samp> | <samp class="SANS_Futura_Std_Book_11">Device
    path, canonicalized</samp> |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\\?\C:\some\..\path</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\..\path</samp> |
    <samp class="SANS_Futura_Std_Book_11">Device path, non-canonicalized</samp> |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp> | <samp
    class="SANS_Futura_Std_Book_11">Device path, non-canonicalized</samp> |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp> | <samp
    class="SANS_Futura_Std_Book_11">设备路径，未规范化</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\\server\share\path</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\UNC\server\share\path</samp>
    | <samp class="SANS_Futura_Std_Book_11">UNC path to share on server</samp> |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\\server\share\path</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\UNC\server\share\path</samp>
    | <samp class="SANS_Futura_Std_Book_11">服务器共享的UNC路径</samp> |'
- en: Due to the way DOS paths are specified, multiple DOS paths might represent the
    same native path. To ensure the final native path is correct, the DOS path must
    go through a *canonicalization* process to convert these different representations
    into the same canonical form.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DOS路径的指定方式，多个DOS路径可能表示相同的原生路径。为了确保最终的原生路径是正确的，DOS路径必须经过*规范化*过程，将这些不同的表示形式转换为相同的规范形式。
- en: One simple operation undertaken in canonicalization is the handling of path
    separators. For native paths, there is only one path separator, the backslash
    (*\*) character. If you use a forward slash (*/*), the object manager will treat
    it as just another filename character. However, DOS paths support both forward
    slashes and backslashes as path separators. The canonicalization process takes
    care of this by ensuring all forward slashes are converted to backslashes. Therefore,
    *C:\Windows* and *C:/Windows* are equivalent.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化过程中的一个简单操作是处理路径分隔符。对于原生路径，只有一个路径分隔符，即反斜杠（*\*）字符。如果使用正斜杠（*/*），对象管理器会将其视为另一个文件名字符。然而，DOS路径支持正斜杠和反斜杠作为路径分隔符。规范化过程通过确保所有正斜杠被转换为反斜杠来处理这个问题。因此，*C:\Windows*
    和 *C:/Windows* 是等价的。
- en: Another canonicalization operation is the resolving of parent directory references.
    When writing a DOS path, you might specify a filename with one dot (*.*) or two
    dots (*..*), each of which has a special meaning. A single dot refers to the current
    directory, and the canonicalization process will remove it from the path. A double
    dot refers to the parent, so the parent directory will be removed. Therefore,
    the path *C:\ABC\.\XYZ* will get converted to *C:\ABC\XYZ*, and *C:\ABC\..\XYZ*
    will get converted to *C:\XYZ*. As with the forward slash, the native APIs do
    not know about these special filenames and will assume that they’re the names
    of the file to look up.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个规范化操作是解析父目录引用。当编写DOS路径时，你可能会指定一个带有一个点（*.*）或两个点（*..*）的文件名，这两者都有特殊含义。一个点表示当前目录，规范化过程会将其从路径中移除。两个点表示父目录，因此父目录会被移除。因此，路径*C:\ABC\.\XYZ*
    会转换为 *C:\ABC\XYZ*，而 *C:\ABC\..\XYZ* 会转换为 *C:\XYZ*。与正斜杠相似，原生API不知道这些特殊文件名，并会假设它们是需要查找的文件名。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Most other operating systems, such as Linux, handle this canonicalization
    process in the kernel. However, due to the subsystem model, Windows must do the
    path canonicalization in user mode, inside the subsystem-specific library. This
    is to support any differences in behavior in OS/2 and POSIX environments.*'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*大多数其他操作系统，如Linux，将此规范化过程处理在内核中。然而，由于子系统模型，Windows必须在用户模式下通过特定子系统库来进行路径规范化。这是为了支持OS/2和POSIX环境中的行为差异。*'
- en: If the DOS path is prefixed with *\\?\* or *\??\*, then the path is not canonicalized
    and is instead used verbatim, including any parent directory references or forward
    slashes. In some cases, the *\??\* prefix can confuse the Win32 APIs with a current
    drive–rooted path, resulting in the opening of a path such as *\??\C:\??\Path*.
    It’s unclear why Microsoft added this DOS path type, considering its potential
    for confusion.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果DOS路径前缀为 *\\?\* 或 *\??\*，则路径不会被规范化，而是按原样使用，包括任何父目录引用或正斜杠。在某些情况下，* \??\* 前缀可能会导致Win32
    API将其误认为是一个根驱动器路径，从而打开像 *\??\C:\??\Path* 这样的路径。不清楚为什么微软会添加这种DOS路径类型，考虑到它可能会引起混淆。
- en: You can manually convert a Win32 path to a native path using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFilePath</samp>
    command. You can also check the path type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFilePathType</samp>
    command. [Listing 3-20](chapter3.xhtml#Lis3-20) shows some examples of using these
    commands.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 3-20: Examples of Win32 filepath conversion'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: When you’re using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFile</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtFile</samp> command, you
    can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp> property
    to treat the path as a Win32 path and automatically convert it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Maximum Path Lengths</samp>
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The maximum filename length supported by Windows is limited by the maximum number
    of characters that can be stored in a <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>
    structure (32,767). However, Win32 APIs have a stricter requirement. By default,
    as shown in [Listing 3-21](chapter3.xhtml#Lis3-21), any attempt to pass a path
    longer than the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">MAX_PATH</samp>,
    defined as 260 characters, will fail. This behavior is implemented inside the
    *NTDLL* API <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDosPathNameToNtPathName</samp>
    when converting the path from Win32 to native format.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 3-21: Testing the Win32 MAX_PATH path limit'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDosPathNameToNtPathName</samp>
    API via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFilePath</samp>
    command. The first path we create is 259 characters long, which we can successfully
    convert to a native path. We then add one more character to the path, making the
    path 260 characters long; this attempt fails with the error <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NAME_TOO_LONG</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">MAX_PATH</samp> is 260, you may
    be wondering: Shouldn’t a 260-character-long path succeed? Unfortunately, no.
    The APIs include the NUL-terminating character as part of the path’s length, so
    the maximum path length is really only 259 characters.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-21](chapter3.xhtml#Lis3-21) also shows a way of bypassing this limitation.
    If we add the device prefix *\\?\* to the path, the conversion succeeds even though
    the length of the path is now 264 characters. This is because the prefix is replaced
    with the DOS device prefix *\??\*, and the remaining path is left verbatim. While
    this technique works, note that it also disables useful features, such as path
    canonicalization. As another workaround, in current versions of Windows there
    is a way of opting into long filenames, as shown in [Listing 3-22](chapter3.xhtml#Lis3-22).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 3-22: Checking and testing long, path-aware applications'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do here is verify that the <samp class="SANS_TheSansMonoCd_W5Regular_11">LongPathsEnabled</samp>
    registry value is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    The value must be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    before the process starts, as it will be read only once during process initialization.
    However, just enabling the long path feature isn’t sufficient: the process’s executable
    file must opt in by specifying a manifest property. We can query this property
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ExecutableManifest</samp>
    command and selecting <samp class="SANS_TheSansMonoCd_W5Regular_11">LongPathAware</samp>.
    Fortunately, PowerShell has this manifest option enabled ❶. We can now convert
    much larger paths successfully, as shown with a 303-character path ❷.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Are long paths a security issue? It’s common for security issues to be introduced
    in places where there is an interface boundary. In this case, the fact that a
    filesystem can support exceptionally long paths could lead to the incorrect assumption
    that a filepath can never be longer than 260 characters. A possible issue might
    occur when an application queries the full path to a file and then copies that
    path into a memory buffer with a fixed size of 260 characters. If the length of
    the filepath is not first checked, this operation could result in the corruption
    of memory after the buffer, which might allow an attacker to gain control of the
    application’s execution.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Creation</samp>
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Processes are the main way to execute user-mode components and isolate them
    for security purposes, so it’s important that we explore how to create them in
    detail. In the previous chapter, I mentioned that you can create a process using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp> system
    call. However, most processes won’t be created directly using this system call;
    rather, they’ll be created with the Win32 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    API, which acts as a wrapper.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The system call isn’t often used directly, because most processes need to interact
    with other user-mode components, especially CSRSS, to interact with the user’s
    desktop. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    API will register the new process created by the system call with the appropriate
    services necessary for correct initialization. We won’t discuss process and thread
    creation in detail in this book, but in this section I’ll give a quick overview.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Command Line Parsing</samp>
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest way to create a new process is to specify a command line string
    representing the executable to run. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    API will then parse the command line to find the executable file to pass to the
    kernel.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this command line parsing, let’s create a new process using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> PowerShell command,
    which executes <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    under the hood. We could use a built-in command such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp>
    to do this, but <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    is useful because it exposes the full set of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    API’s functionality. We can start a process using the following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We provide a command line containing the name of the executable to run, Notepad,
    and the name of a file to open, *test.txt*. This string doesn’t necessarily need
    to provide a full path to the executable; the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    command will parse the command line to try to distinguish the name of the initial
    executable image file from the file to open. That’s not as simple a process as
    it sounds.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    will do is parse the command line using an algorithm that splits on whitespace,
    unless that whitespace is enclosed in double quotes. In this case, it will parse
    the command line into two strings, <samp class="SANS_TheSansMonoCd_W5Regular_11">notepad</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">test.txt</samp>. The command
    then takes the first string and tries to find a matching process. However, there’s
    a slight complication: there is no *notepad* executable file, only *notepad.exe*.
    Though it’s not required, Windows executables commonly have a *.exe* extension,
    so the search algorithm will automatically append this extension if one doesn’t
    already exist.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The command will then search the following locations for the executable, much
    like the DLL path searching we discussed in “Searching for DLLs” on page 68. Note
    that the executable search path is the same as the unsafe DLL search path:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 1.  The same directory as the current process’s executable file
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The current working directory
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The Windows *System32* directory
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The *Windows* directory
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Each semicolon-separated location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATH</samp>
    environment variable
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> can’t
    find *notepad.exe*, it will next try to find the file *notepad test.txt*, in case
    that’s what we meant. As the filename has an extension already, it won’t replace
    it with *.exe*. If <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    can’t find the file, it returns an error. Note that if we passed <samp class="SANS_TheSansMonoCd_W5Regular_11">notepad</samp>
    surrounded by double quotes, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">"notepad"
    test.txt</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    would search for *notepad.exe* only and never fall back to trying all combinations
    of the name with the whitespace.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: This command line parsing behavior has two security implications. First, if
    the process is being created by a more privileged process and a less privileged
    user can write a file to a location earlier in the path search list, then the
    process could be hijacked.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The second security implication is that the path-searching algorithm changes
    if the first value contains a path separator. In this case, instead of using the
    path-searching rules, <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    splits the path by whitespace and then tries each component as if it were a path,
    searching for the name either with the *.exe* extension or without it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. If we specify a command line of <samp class="SANS_TheSansMonoCd_W5Regular_11">C:\Program
    Files\abc.exe</samp>, then the following paths will be searched for the executable
    file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '*C:\Program*'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Program.exe*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Program Files\abc.exe*'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Program Files\abc.exe.exe*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user could write the file *C:\Program* or *C:\Program.exe*, then they
    could hijack execution. Fortunately, on a default installation of Windows, a normal
    user can’t write files to the root of the system drive; however, configuration
    changes sometimes allow this. Also, the executable path might be on a different
    drive that does allow writing to the root.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid both security implications, the caller can specify the executable’s
    full pathname by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ApplicationName</samp>
    property when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we specify the path this way, the command will pass it verbatim to the new
    process.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shell APIs</samp>
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you double-click a non-executable file type, such as a text document, in
    Explorer, it will helpfully start an editor for you. However, if you try to run
    a document with <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>,
    you’ll get the error shown here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This error indicates that the text file is not a valid Win32 application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The reason Explorer can start the editor is that it doesn’t use the underlying
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> API directly;
    instead, it uses a shell API. The main shell API used to start the editor for
    a file is <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecuteEx</samp>,
    implemented in the *SHELL32* library. This API and its simpler sibling, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>, are much too complex
    to cover in detail here. Instead, I’ll give just a brief overview of the latter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, we need to specify three parameters to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The path to the file to execute
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The verb to use on the file
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any additional arguments
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first thing <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>
    does is look up the handler for the extension of the file to execute. For example,
    if the file is *test.txt*, then it needs to look up the handler for the *.txt*
    extension. The handlers are registered in the registry under the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CLASSES_ROOT</samp>
    key, which, as we saw earlier in the chapter, is a merged view of parts of the
    machine software and the user’s registry hive. In [Listing 3-23](chapter3.xhtml#Lis3-23),
    we query the handler.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 3-23: Querying the shell handler for <samp class="SANS_Futura_Std_Book_11">.txt</samp>
    files'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by querying the machine class’s key for the *.txt* extension ❶. Although
    we could have checked for a user-specific key, checking the machine class’s key
    ensures that we inspect the system default. The *.txt* registry key doesn’t directly
    contain the handler. Instead, the default value, represented by an empty name,
    refers to another key: in this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">txtfile</samp>
    ❷. We then list the subkeys of <samp class="SANS_TheSansMonoCd_W5Regular_11">txtfile</samp>
    and find three keys: <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">printto</samp>
    ❸. We can pass these verbs by name to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Each of these verb keys can have a subkey, called <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>,
    that contains a command line to execute ❹. We can see that the default for a *.txt*
    file is to open Notepad ❺; the <samp class="SANS_TheSansMonoCd_W5Regular_11">%1</samp>
    is replaced with the path to the file being executed. (The command could also
    contain <samp class="SANS_TheSansMonoCd_W5Regular_11">%*</samp>, which includes
    any additional arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>.)
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> API can
    now start the executable and handle the file.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: There are many different standard verbs you can pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>.
    [Table 3-3](chapter3.xhtml#tab3-3) shows a list of common ones you’ll encounter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Shell Verbs</samp>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Verb</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> | <samp class="SANS_Futura_Std_Book_11">Open
    the file; this is typically the default.</samp> |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">edit</samp> | <samp class="SANS_Futura_Std_Book_11">Edit
    the file.</samp> |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp> | <samp class="SANS_Futura_Std_Book_11">Print
    the file.</samp> |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">printto</samp> | <samp class="SANS_Futura_Std_Book_11">Print
    to a specified printer.</samp> |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">explore</samp> | <samp class="SANS_Futura_Std_Book_11">Explore
    a directory; this is used to open a directory in an Explorer window.</samp> |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp> | <samp class="SANS_Futura_Std_Book_11">Open
    the file as an administrator; typically, defined for executables only.</samp>
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">runasuser</samp> | <samp class="SANS_Futura_Std_Book_11">Open
    the file as another user; typically, defined for executables only.</samp> |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: You might find it odd that there is both an <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">edit</samp> verb. If you
    opened a *.txt* file, for example, the file would open in Notepad, and you’d be
    able to edit it. But the distinction is useful for files such as batch files,
    where the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> verb would
    execute the file and <samp class="SANS_TheSansMonoCd_W5Regular_11">edit</samp>
    would open it in a text editor.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'To use <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp> from
    PowerShell, you can run the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp>
    command. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>
    will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> verb, but
    you can specify your own verb using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Verb</samp>
    parameter. In the following code, we print a *.txt* file as an administrator using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp> verb:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Verb configurations can also improve security. For example, PowerShell scripts
    with a *.ps1* extension have the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    verb registered. However, clicking a script will open the script file in Notepad
    rather than executing the script. Therefore, if you double-click the script file
    in Explorer, it won’t execute. Instead, you must right-click the file and explicitly
    choose **Run with PowerShell**.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, the full details of the shell APIs are out of scope
    for this book; as you might expect, the full picture is not quite as simple as
    I’ve shown here.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">System Processes</samp>
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this and the preceding chapter, I’ve alluded to various processes
    that run with higher privileges than a normal user. This is because, even when
    no user is logged in to the operating system, the system still needs to perform
    tasks like waiting for authentication, managing hardware, and communicating over
    the network.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel could perform some of these tasks. However, writing kernel code
    is more difficult than user-mode code, for a number of reasons: the kernel doesn’t
    have as wide a range of APIs available; it’s resource constrained, especially
    in terms of memory; and any coding mistake could result in the system crashing
    or being exposed to a security vulnerability.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: To avoid these challenges, Windows runs a variety of processes outside of kernel
    mode, with a high privilege level, to provide important facilities. We’ll go through
    some of these special processes in this section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Session Manager</samp>
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *Session Manager Subsystem (SMSS)* is the first user-mode process started
    by the kernel after boot. It’s responsible for setting up the working environment
    for subsequent processes. Some of its responsibilities include:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Loading known DLLs and creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting subsystem processes such as CSRSS
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing base DOS devices such as serial ports
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running automatic disk integrity checks
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Windows Logon
    Process</samp>
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Windows logon* process is responsible for setting up a new console session,
    as well as displaying the logon user interface (primarily through the LogonUI
    application). It’s also responsible for starting the *user-mode font driver (UMFD)*
    process, which renders fonts to the screen, and the *desktop window manager (DWM)*
    process, which performs desktop compositing operations to allow for fancy, transparent
    windows and modern GUI touches.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Local Security
    Authority Subsystem</samp>
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ve already mentioned LSASS in the context of the SRM. However, it’s worth
    stressing its important role in authentication. Without LSASS, a user would not
    be able to log on to the system. We’ll cover LSASS’s roles and responsibilities
    in much more detail in [Chapter 10](chapter10.xhtml).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Service Control
    Manager</samp>
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *service control manager (SCM)* is responsible for starting most privileged
    system processes on Windows. It manages these processes, referred to as *services*,
    and can start and stop them as needed. For example, the SCM could start a service
    based on certain conditions, such as a network becoming available.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Each service is a securable resource with fine-grained controls determining
    which users can manipulate its state. By default, only an administrator can manipulate
    a service. The following are some of the most important services running on any
    Windows system:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote Procedure Call Subsystem (RPCSS)    **The RPCSS service manages the
    registration of remote procedure call endpoints, exposing the registration to
    local clients as well as over the network. This service is essential to a running
    system; in fact, if this process crashes, it will force Windows to reboot.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '**DCOM Server Process Launcher    **The DCOM Server Process Launcher is a counterpart
    to RPCSS (and used to be part of the same service). It’s used to start Component
    Object Model (COM) server processes on behalf of local or remote clients.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**Task Scheduler    **Being able to schedule an action to run at a specific
    time and date is a useful feature of an operating system. For example, perhaps
    you want to ensure that you delete unused files on a specific schedule. You could
    set up an action with the Task Scheduler service to run a cleanup tool on that
    schedule.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows Installer    **This service can be used to install new programs and
    features. By running as a privileged service, it permits installation and modification
    in normally protected locations on the filesystem.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows Update    **Having a fully up-to-date operating system is crucial
    to the security of your Windows system. When Microsoft releases new security fixes,
    they should be installed as soon as possible. To avoid requiring the user to check
    for updates, this service runs in the background, waking up periodically to check
    the internet for new patches.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Information    **This service provides a mechanism for switching
    between an administrator and non-administrator user on the same desktop. This
    feature is usually referred to as *User Account Control (UAC)*. You can start
    an administrator process by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp>
    verb with the shell APIs. We’ll cover how UAC works under the hood in the next
    chapter.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: We can query the status of all services controlled by the SCM using various
    tools. PowerShell has the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Service</samp>
    command; however, the PowerShell module used in this book provides a more comprehensive
    command, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32Service</samp>,
    that can inspect the configured security of a service as well as additional properties
    not exposed using the default command. [Listing 3-24](chapter3.xhtml#Lis3-24)
    shows how to query for all current services.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 3-24: Displaying all services using Get-Win32Service'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The output shows the name of the service, its status (either <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopped</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Running</samp>), and, if it’s
    running, the process ID of the service process. If you list the service’s properties
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>, you’ll
    also be able to see additional information, such as a full description of the
    service.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s walk through some worked examples to practice using the various commands
    covered in this chapter for security research or systems analysis.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Executables
    That Import Specific APIs</samp>
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the beginning of this chapter, you saw how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp>
    command to extract an executable file’s imported APIs. One use for this command
    that I find especially helpful when I’m trying to track down security issues is
    identifying all the executables that use a particular API, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>,
    and then using this list to reduce the files I need to reverse engineer. You can
    perform such a search with the basic PowerShell script shown in [Listing 3-25](chapter3.xhtml#Lis3-25).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 3-25: Finding executables that import CreateProcess'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Here, we start by enumerating all the *.exe* files in the *Windows* directory.
    For every executable file, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp>
    command. This will load the module and parse its imports. This can be a time-consuming
    process, so it’s best to capture the results into a variable, as we do here.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Next, we select only the imports that contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessW</samp>
    API. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Names</samp> property is
    a list containing the imported names for a single DLL. To get the resulting list
    of executable files that import a specific API, we can select the <samp class="SANS_TheSansMonoCd_W5Regular_11">ModulePath</samp>
    property, which contains the original loaded pathname.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same technique to enumerate DLL files or drivers and quickly
    discover targets for reverse engineering.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Hidden Registry
    Keys or Values</samp>
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In “Listing the Registry’s Contents” on page 81, I mentioned that one of the
    big advantages of using the native system calls over the Win32 APIs to interact
    with the registry is that they allow you to access keys and values with NUL characters
    in their names. It would be useful to be able to find these keys and values so
    you can try to detect software on your system that is actively trying to hide
    registry keys or values from the user (some malware families, such as Kovter and
    Poweliks, are known to use this technique). Let’s start by finding keys with NUL
    characters in the name ([Listing 3-26](chapter3.xhtml#Lis3-26)).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 3-26: Finding hidden registry keys'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: We first create a key in the current user’s hive with a NUL character in it.
    If you try to find this key using the built-in registry provider, it will fail.
    Instead, we do a recursive listing of the current user’s hive and select any keys
    that have a NUL character in the name. In the output, you can see that the hidden
    key was discovered.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: To find hidden values, we can query the list of values of a key by enumerating
    its <samp class="SANS_TheSansMonoCd_W5Regular_11">Values</samp> property. Each
    value contains the name of the key and the data value ([Listing 3-27](chapter3.xhtml#Lis3-27)).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 3-27: Finding hidden registry values'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a normal key, then adding a value with a NUL character
    in the name ❶. We then define a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Select-HiddenValue</samp>
    ❷, that will check keys in the pipeline and select any value with a NUL character
    in the name, returning a custom object to the pipeline ❸.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Next, we recursively enumerate the current user’s hive and filter the keys through
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select-HiddenValue</samp> function
    ❹. You can see in the output that we discovered the hidden value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter provided a quick tour through the Windows user-mode components.
    We started with a dive into Win32 APIs and the loading of DLLs. Understanding
    this topic is important, as it reveals how user-mode applications communicate
    with the kernel and implement common features.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Next, I provided an overview of the Win32 GUI, including a description of the
    separate system call table used for *WIN32K*, which is the kernel-mode component
    of the Win32 subsystem. I introduced the window station and desktop object types
    and outlined the purpose of the console session, as well as how it corresponds
    to the desktop you see as a user.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: I then returned to the topic of Win32 APIs by detailing the differences and
    similarities between a Win32 API (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>)
    and the underlying system call (<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>).
    This discussion should have given you a better understanding of how the Win32
    APIs interact with the rest of the operating system. I also introduced the differences
    between DOS device paths and native paths as understood by a system call, a topic
    that is important for understanding how user-mode applications interact with the
    filesystem.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: I concluded with a discussion of several topics related to Win32 processes and
    threads, covering the APIs used to create processes directly or through the shell
    and providing an overview of well-known system processes. In later chapters, we’ll
    revisit many of these topics in more depth. In the next three chapters, we’ll
    focus on how Windows implements security through the SRM.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
