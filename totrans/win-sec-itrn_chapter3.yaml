- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">USER-MODE
    APPLICATIONS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, we discussed the Windows kernel. But a user doesn’t
    typically interact directly with the kernel. Instead, they interact with user-facing
    applications, such as word processors and file managers. This chapter will detail
    how these user-mode applications are created and how they interface with the kernel
    to provide services to the user.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by discussing the Win32 application programming interfaces (APIs)
    designed for user-mode application development and how they relate to the design
    of the Windows operating system. Then we’ll cover the structure of the Windows
    user interface and how you can inspect it programmatically. Multiple users of
    a Windows system can all access a user interface at the same time; we’ll also
    look at how console sessions can isolate one user’s interface and application
    resources from those of other users on the same system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: To understand how user-mode applications function, it’s important to understand
    how the provided APIs interface with the underlying kernel system call interface.
    We’ll examine this too, along with the conversion process that filepaths must
    undergo to become compatible with the kernel. Next, we’ll cover how Win32 applications
    access the registry; then we’ll consider how Win32 handles process and thread
    creation and look at some important system processes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Win32 and the User-Mode Windows APIs</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the code that runs on Windows does not directly interact with system
    calls. This is an artifact of the *Windows NT* operating system’s original design.
    Microsoft initially developed Windows NT as an updated version of IBM’s OS/2 operating
    system, intending it to have multiple subsystems that implemented different APIs.
    At various times, it supported POSIX, OS/2, and the Win32 APIs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, Microsoft’s relationship with IBM went sour, and Microsoft took
    the API set it had developed for Windows 95, *Win32*, and built a subsystem to
    implement it. The largely unloved OS/2 subsystem was removed in Windows 2000,
    while POSIX survived until Windows 8.1\. By Windows 10, Win32 was the only remaining
    subsystem (though Microsoft subsequently implemented Linux compatibility layers,
    such as Windows Subsystem for Linux, that don’t use the old subsystem extension
    points).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: To allow for these multiple APIs, the Windows kernel implements a generic set
    of system calls. It’s the responsibility of each subsystem’s specific libraries
    and services to convert their APIs to the low-level system call interface. [Figure
    3-1](chapter3.xhtml#fig3-1) shows an overview of the Win32 subsystem API libraries.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: The Win32 API modules</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the core of the Win32 APIs is implemented in the *KERNEL32*
    and *KERNELBASE* libraries. These libraries call methods in the system-provided
    *NT Layer dynamic link library (NTDLL)*, which implements system call dispatches
    as well as runtime library APIs to perform common low-level operations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Most user-mode applications do not directly contain the implementation of the
    Windows system APIs. Instead, *NTDLL* includes the DLL loader, which loads new
    libraries on demand. The loading process is mostly opaque to the developer: when
    building a program, you link against a set of libraries, and the compiler and
    toolchain automatically add an import table to your executable file to reflect
    your dependencies. The DLL loader then inspects the import table, automatically
    loads any dependent libraries, and resolves the imports. You can also specify
    exported functions from your application so that other code can rely on your APIs.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loading a New Library</samp>
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s possible to access exported functions manually at runtime without needing
    an import table entry. You can load a new library using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    Win32 API, which is exposed to PowerShell using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Import-Win32Module</samp>
    command. To find the memory address of a function exported by a DLL, use the Win32
    API <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>, exposed
    with the PowerShell <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleExport</samp>
    command ([Listing 3-1](chapter3.xhtml#Lis3-1)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: Exports for the <samp class="SANS_Futura_Std_Book_11">KERNEL32</samp>
    library'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use PowerShell to load the *KERNEL32* library and enumerate the exported
    and imported APIs. First we load it into memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Import
    -Win32Module</samp> ❶. The *KERNEL32* library is always loaded, so this command
    will just return the existing loaded address; for other libraries, however, the
    load will cause the DLL to be mapped into memory and initialized.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">WARNING</samp>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '*The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Import-Win32Module</samp>
    command will load a DLL into memory and potentially execute code. In this example,
    this is acceptable, as* KERNEL32 *is one of the trusted system libraries. However,
    do not use the command on an untrusted DLL, especially if you’re analyzing malware,
    as it might result in malicious code execution. To be safe, always perform malware
    analysis on a segregated system dedicated to that purpose.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Once it’s loaded into memory, we can display some of the library’s properties
    ❷. These include the name of the library, as well as the loaded memory address
    and the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EntryPoint</samp>.
    A DLL can optionally define a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">DllMain</samp>,
    to run when it’s loaded. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EntryPoint</samp>
    address is the first instruction in memory to execute when the DLL is loaded.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we dump all exported functions from the DLL ❸. In this case, we see three
    pieces of information for each: <samp class="SANS_TheSansMonoCd_W5Regular_11">Ordinal</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Ordinal</samp> is a small number
    that uniquely identifies the exported function in the DLL. It’s possible to import
    an API by its ordinal number, which means there is no need to export a name; you’ll
    see certain names missing from export tables in DLLs whenever Microsoft doesn’t
    want to officially support the function as a public API.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> is just the name
    of the exported function. It doesn’t need to match what the function was called
    in the original source code, although typically it does. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp>
    is the address in memory of the function’s first instruction. You’ll notice that
    the first two exports have a string instead of an address. This is a case of *export
    forwarding*; it allows a DLL to export a function by name and has the loader automatically
    redirect it to another DLL. In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireSRWLockExclusive</samp>
    is implemented as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlAcquireSRWLockExclusive</samp>
    in *NTDLL*. We can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleExport</samp>
    to look up a single exported function using the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    API ❹.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing Imported
    APIs</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a similar fashion, we can view the APIs that an executable has imported from
    other DLLs using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp>
    command, as shown in [Listing 3-2](chapter3.xhtml#Lis3-2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: Enumerating imports for the <samp class="SANS_Futura_Std_Book_11">KERNEL32</samp>
    library'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp>,
    specifying the *KERNEL32* DLL as the path. When you specify a path, the command
    will call <samp class="SANS_TheSansMonoCd_W5Regular_11">Import-Win32Module</samp>
    for you and display all the imports, including the name of the DLL to load and
    the number of functions imported. The final column indicates whether the DLL was
    marked by the developer as being *delay loaded*. This is a performance optimization;
    it allows a DLL to be loaded only when one of its exported functions is used.
    This delay avoids loading all DLLs into memory during initialization, which decreases
    process startup time and reduces runtime memory usage if the import is never used.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Next, we dump the imported functions for a DLL. As the executable can import
    code from multiple libraries, we specify the one we want using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllName</samp>
    property. We then filter to all imported functions starting with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    prefix; this allows us to see exactly what system calls *KERNEL32* imports from
    *NTDLL*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Searching for DLLs</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When loading a DLL, the loader creates an image section object from the executable
    file and maps it into memory. The kernel is responsible for mapping the executable
    memory; however, user-mode code still needs to parse the import and export tables.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you pass the string <samp class="SANS_TheSansMonoCd_W5Regular_11">ABC.DLL</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> API. How
    does the API know where to find that DLL? If the file hasn’t been specified as
    an absolute path, the API implements a path-searching algorithm. The algorithm,
    as originally implemented in Windows NT 3.1, searches for files in the following
    order:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 1.  The same directory as the current process’s executable file
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The current working directory
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The Windows *System32* directory
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The *Windows* directory
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Each semicolon-separated location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATH</samp>
    environment variable
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this load order is that it can lead to a privileged process
    loading a DLL from an insecure location. For example, if a privileged process
    changed its current working directory using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCurrentDirectory</samp>
    API to a location a less privileged user could write to, the DLL would be loaded
    from that location before any DLL from the *System32* directory. This attack is
    called *DLL hijacking*, and it’s a persistent problem on Windows.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Vista changed the default load order to the following, which is safer:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 1.  The same directory as the current process’s executable file
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The Windows *System32* directory
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The *Windows* directory
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The current working directory
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Each semicolon-separated location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATH</samp>
    environment variable
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 每个由分号分隔的位置在 <samp class="SANS_TheSansMonoCd_W5Regular_11">PATH</samp> 环境变量中
- en: Now we no longer load from the current working directory before the *System32*
    or *Windows* directory. However, if an attacker could write to the executable’s
    directory, a DLL hijack could still take place. Therefore, if an executable is
    run as a privileged process, only administrators should be able to modify its
    directory to prevent a DLL hijack from occurring.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不再从当前工作目录加载 DLL，而是优先加载 *System32* 或 *Windows* 目录。然而，如果攻击者能够写入可执行文件所在的目录，仍然可能发生
    DLL 劫持。因此，如果可执行文件作为特权进程运行，只有管理员才能修改其目录，以防止发生 DLL 劫持。
- en: While the DLL loader will normally turn to the disk to retrieve a library, some
    libraries are used so often that it makes sense to pre-initialize them. This improves
    performance and prevents the DLLs from being hijacked. Two obvious examples are
    *KERNEL32* and *NTDLL*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 DLL 加载器通常会从磁盘中检索库文件，但有些库文件使用频率很高，预先初始化它们是有意义的。这可以提高性能，并防止 DLL 被劫持。两个明显的例子是
    *KERNEL32* 和 *NTDLL*。
- en: Before any user applications start on Windows, the system configures a *KnownDlls*
    OMNS directory containing a list of preloaded image sections. A *KnownDlls* <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object’s name is just the
    filename of the library. The DLL loader can check *KnownDlls* first before going
    to the disk. This improves performance as the loader no longer needs to create
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object for
    the file. It also has a security benefit, ensuring that anything considered to
    be a known DLL can’t be hijacked.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何用户应用程序启动之前，系统会配置一个包含预加载图像段列表的 *KnownDlls* OMNS 目录。*KnownDlls* <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    对象的名称就是库的文件名。DLL 加载器在访问磁盘之前可以首先检查 *KnownDlls*。这样可以提高性能，因为加载器不再需要为文件创建新的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> 对象。它还具有安全性优势，确保任何被认为是已知
    DLL 的文件都无法被劫持。
- en: We can list the object directory using the *NtObject* drive, as shown in [Listing
    3-3](chapter3.xhtml#Lis3-3).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 *NtObject* 驱动器列出对象目录，如 [清单 3-3](chapter3.xhtml#Lis3-3) 所示。
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: Listing the contents of the <samp class="SANS_Futura_Std_Book_11">KnownDlls</samp>
    object directory'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-3：列出 <samp class="SANS_Futura_Std_Book_11">KnownDlls</samp> 对象目录的内容
- en: This section covered the basics of the Win32 subsystem and how it uses libraries
    to implement the APIs that a user-mode application can use to interface with the
    operating system. We’ll come back to the Win32 APIs later, but first we must discuss
    the Windows user interface, which is inextricably linked to how the Win32 subsystem
    functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讲解了 Win32 子系统的基础知识，以及它如何使用库来实现用户模式应用程序可以用来与操作系统交互的 API。我们稍后会回到 Win32 API，但首先我们必须讨论
    Windows 用户界面，它与 Win32 子系统的功能密不可分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Win32 GUI</samp>
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Win32 GUI</samp>
- en: The name “Windows” refers to the structure of the operating system’s graphical
    user interface (GUI). This GUI consists of one or more windows that the user can
    interact with using controls such as buttons and text input. Since Windows 1.0,
    the GUI has been the most important feature of the operating system, so it should
    come as no surprise that its model is complex. The implementation of the GUI is
    split between the kernel and user mode, as shown in [Figure 3-2](chapter3.xhtml#fig3-2).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “Windows”这个名字指的是操作系统图形用户界面（GUI）的结构。这个 GUI 由一个或多个窗口组成，用户可以通过按钮、文本输入等控件与之交互。自
    Windows 1.0 以来，GUI 一直是操作系统最重要的特性，因此它的模型复杂也就不足为奇了。GUI 的实现分为内核模式和用户模式，如 [图 3-2](chapter3.xhtml#fig3-2)
    所示。
- en: '![](../images/Figure3-2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The Win32 GUI modules</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-2：Win32 GUI 模块</samp>
- en: 'You might notice that the left-hand side of [Figure 3-2](chapter3.xhtml#fig3-2)
    looks a lot like [Figure 3-1](chapter3.xhtml#fig3-1), which showed the modules
    for the normal Win32 APIs. In place of *NTDLL*, however, is *WIN32U*, which implements
    system call stubs for the kernel to call. Two libraries call *WIN32U*: *USER32*
    and *GDI32*. *USER32* implements the window UI elements and generally manages
    the GUI, whereas *GDI32* implements drawing primitives, like fonts and shapes.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 [图 3-2](chapter3.xhtml#fig3-2) 的左侧看起来非常像 [图 3-1](chapter3.xhtml#fig3-1)，后者显示了普通
    Win32 API 的模块。只不过，*NTDLL* 被 *WIN32U* 取代，*WIN32U* 实现了供内核调用的系统调用存根。两个库调用 *WIN32U*：*USER32*
    和 *GDI32*。*USER32* 实现了窗口 UI 元素并通常管理 GUI，而 *GDI32* 实现了绘图原语，如字体和形状。
- en: One big difference between [Figure 3-2](chapter3.xhtml#fig3-2) and [Figure 3-1](chapter3.xhtml#fig3-1)
    is that the GUI is not actually implemented inside the main NTOS kernel executive.
    Instead, its system calls are implemented in the *WIN32K* driver, which interfaces
    with the object manager, the kernel, and the display drivers to handle user interactions
    and display the results. The *WIN32K* driver also implements a system call table
    that is separate from the kernel’s.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-2](chapter3.xhtml#fig3-2) 与 [图 3-1](chapter3.xhtml#fig3-1) 之间的一个大区别是，GUI
    并没有实际实现于主 NTOS 内核执行体内。相反，它的系统调用是通过 *WIN32K* 驱动程序实现的，该驱动程序与对象管理器、内核和显示驱动程序接口，以处理用户交互并显示结果。*WIN32K*
    驱动程序还实现了一个与内核分开的系统调用表。'
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In versions of Windows prior to 10, the system call dispatch code in* WIN32U
    *was embedded directly inside the user-mode DLLs. This made it hard for an application
    to directly call* WIN32K *system calls without writing assembly language.*'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在 Windows 10 之前的版本中，*WIN32U* 中的系统调用分派代码是直接嵌入在用户模式 DLL 中的。这使得应用程序难以直接调用 *WIN32K*
    系统调用，而不编写汇编语言。*'
- en: 'The GUI APIs also interact with a special privileged process: the *Client Server
    Runtime Subsystem (CSRSS)*. This process is responsible for handling certain privileged
    operations for lower-privileged clients, such as configuring per-user drive mappings,
    process management, and error handling.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: GUI API 还与一个特殊的特权进程进行交互：*客户端服务器运行时子系统 (CSRSS)*。该进程负责为较低特权的客户端处理某些特权操作，例如配置每用户的驱动器映射、进程管理和错误处理。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GUI Kernel Resources</samp>
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GUI 内核资源</samp>
- en: 'The GUI is made up of four types of kernel resources:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 由四种类型的内核资源组成：
- en: '**Window stations    **Objects that represent the connection to the screen
    and the user interface, such as the keyboard and mouse'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口站**    代表与屏幕和用户界面（如键盘和鼠标）的连接的对象'
- en: '**Windows    **GUI elements for interacting with the user, accepting input,
    and displaying a result'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口**    与用户交互的 GUI 元素，接收输入并显示结果'
- en: '**Desktops    **Objects that represent the visible desktop and act as a host
    for windows'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**桌面**    代表可见桌面的对象，并充当窗口的宿主'
- en: '**Drawing resources    **Bitmaps, fonts, or anything else that needs to be
    displayed to the user'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘图资源**    位图、字体或其他需要展示给用户的内容'
- en: While the Win32 kernel and user components handle the windows, the window stations
    and desktops are accessible through the object manager. There are kernel object
    types for window stations and desktops, as shown in [Listing 3-4](chapter3.xhtml#Lis3-4).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Win32 内核和用户组件处理窗口，但窗口站和桌面是通过对象管理器访问的。如 [列表 3-4](chapter3.xhtml#Lis3-4) 所示，窗口站和桌面有内核对象类型。
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-4: Showing the WindowStation and Desktop type objects'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-4：显示 WindowStation 和 Desktop 类型对象
- en: A window station is assigned to a process either at process startup or using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUserSetProcessWindowStation</samp>
    API. Desktops are assigned on a per-thread basis using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUserSetThreadDesktop</samp>.
    We can query the names of the window stations and desktops with the commands in
    [Listing 3-5](chapter3.xhtml#Lis3-5).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个窗口站在进程启动时或通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUserSetProcessWindowStation</samp>
    API 被分配给一个进程。桌面是按线程分配的，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUserSetThreadDesktop</samp>。我们可以使用
    [列表 3-5](chapter3.xhtml#Lis3-5) 中的命令查询窗口站和桌面的名称。
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-5: Displaying all the current window stations and desktops'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-5：显示所有当前的窗口站和桌面
- en: 'We start by querying the names of all available window stations ❶. In this
    example, there are two: the default <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>
    window station and <samp class="SANS_TheSansMonoCd_W5Regular_11">Service-0x0-b17580b$</samp>,
    which another process has created. The ability to create separate window stations
    allows a process to isolate its GUI interactions from other processes running
    at the same time. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>
    is special, as it is the only object connected to the user’s console.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查询所有可用窗口站的名称❶。在这个例子中，有两个：默认的 <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>
    窗口站和另一个进程创建的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Service-0x0-b17580b$</samp>。创建独立窗口站的能力允许一个进程将其图形界面交互与其他同时运行的进程隔离。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp> 是特殊的，因为它是唯一与用户控制台连接的对象。
- en: Next, we check what our current window station name is by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Current</samp>
    parameter ❷. We can see we’re on <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Current</samp> 参数❷来检查当前窗口站的名称。我们可以看到，我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp> 上。
- en: 'We then query for the names of the desktops on our current window station ❸.
    We see only two desktops: <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WinLogon</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">WinLogon</samp>
    desktop will be visible only if you run the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDesktopName</samp>
    command as an administrator, as it’s used solely to display the login screen,
    which a normal user application shouldn’t be able to access. <samp class="SANS_TheSansMonoCd_W5Regular_11">Desktop</samp>
    objects must be opened relative to a window station path; there isn’t a specific
    object directory for desktops. Therefore, the name of the desktop reflects the
    name of the window station object.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们查询当前窗口站上的桌面名称❸。我们只看到两个桌面：<samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">WinLogon</samp>。只有在以管理员身份运行 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDesktopName</samp> 命令时，<samp class="SANS_TheSansMonoCd_W5Regular_11">WinLogon</samp>
    桌面才会可见，因为它仅用于显示登录屏幕，普通用户应用程序不应能访问该桌面。<samp class="SANS_TheSansMonoCd_W5Regular_11">Desktop</samp>
    对象必须相对于窗口站路径打开；桌面没有特定的对象目录。因此，桌面的名称反映了窗口站对象的名称。
- en: Finally, we check the name of the current thread’s desktop ❹. The desktop we’re
    attached to is shown as <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>,
    as that’s the only desktop available to normal user applications. We can enumerate
    the windows created in a desktop using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDesktop</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtWindow</samp> ([Listing
    3-6](chapter3.xhtml#Lis3-6)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查当前线程桌面的名称❹。我们连接的桌面显示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>，因为这是普通用户应用程序唯一可用的桌面。我们可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDesktop</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtWindow</samp>
    来列举桌面中创建的窗口（见 [Listing 3-6](chapter3.xhtml#Lis3-6)）。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-6: Enumerating windows for the current desktop'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-6: 为当前桌面列举窗口'
- en: As you can see, each window has a few properties. First is its *handle*, which
    is unique to the desktop. This is not the same type of handle we discussed in
    the preceding chapter for kernel objects; instead, it’s a value allocated by the
    Win32 subsystem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个窗口都有一些属性。首先是它的*句柄*，该句柄在桌面中是唯一的。这与我们在前一章讨论的内核对象句柄不同；它是由 Win32 子系统分配的一个值。
- en: To function, a window receives *messages* from the system. For example, when
    you click a mouse button on a window, the system will send a message to notify
    the window of the click and what mouse button was pressed. The window can then
    handle the message and change its behavior accordingly. You can also manually
    send messages to a window using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SendMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PostMessage</samp> APIs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正常工作，窗口需要接收来自系统的*消息*。例如，当你点击窗口上的鼠标按钮时，系统会发送一条消息通知窗口点击事件及按下的鼠标按钮。窗口随后可以处理该消息，并根据需要改变其行为。你也可以通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SendMessage</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">PostMessage</samp>
    API 手动发送消息到窗口。
- en: Each message consists of a numeric identifier—such as <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>,
    which represents the message <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>
    to close a window—and two additional parameters. The meaning of the two parameters
    depends on the message. For example, if the message is <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>,
    then neither parameter is used; for other messages, they might represent pointers
    to strings or integer values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消息由一个数字标识符组成——例如<samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>，它表示消息<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>，用于关闭窗口——以及两个额外的参数。这两个参数的含义取决于消息。例如，如果消息是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>，那么两个参数都不会使用；对于其他消息，它们可能表示指向字符串或整数值的指针。
- en: Messages can be sent or posted. The difference between sending and posting a
    message is that sending waits for the window to handle the message and return
    a value, while posting just sends the message to the window and returns immediately.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以是发送的或发布的。发送消息和发布消息的区别在于，发送消息会等待窗口处理消息并返回一个值，而发布消息则只是将消息发送到窗口并立即返回。
- en: In [Listing 3-6](chapter3.xhtml#Lis3-6), the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessId</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadId</samp> columns identify
    the process and thread that created a window using an API such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp>.
    A window has what’s called *thread affinity*, which means that only the creating
    thread can manipulate the state of the window and handle its messages. However,
    any thread can send messages to the window. To handle messages, the creating thread
    must run a *message loop*, which calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetMessage</samp>
    API to receive the next available message and then dispatches it to the window’s
    message handler callback function using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DispatchMessage</samp>
    API. When an application is not running the loop, you might see Windows applications
    hanging, as without the loop, the GUI cannot be updated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 3-6](chapter3.xhtml#Lis3-6)中，<samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessId</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ThreadId</samp>列标识了使用诸如<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp>等API创建窗口的进程和线程。窗口具有所谓的*线程亲和性*，这意味着只有创建该窗口的线程才能操作窗口的状态并处理其消息。然而，任何线程都可以向窗口发送消息。为了处理消息，创建线程必须运行一个*消息循环*，该循环调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetMessage</samp>API接收下一个可用的消息，然后使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DispatchMessage</samp>API将其分发到窗口的消息处理回调函数。当应用程序没有运行循环时，你可能会看到Windows应用程序挂起，因为没有循环，GUI无法更新。
- en: The final column in [Listing 3-6](chapter3.xhtml#Lis3-6) is the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp>.
    This is the name of a *window class*, which acts as a template for a new window.
    When <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp> is called,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp> is specified
    and the window is initialized with default values from the template, such as the
    style of the border or a default size. It’s common for an application to register
    its own classes to handle unique windows. Alternatively, it can use system-defined
    classes for things like buttons and other common controls.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 3-6](chapter3.xhtml#Lis3-6)的最后一列是<samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp>。这是一个*窗口类*的名称，它充当新窗口的模板。当调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp>时，指定<samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp>，窗口将使用模板中的默认值进行初始化，例如边框样式或默认大小。应用程序通常会注册自己的类来处理独特的窗口。或者，它可以使用系统定义的类来处理按钮和其他常见控件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Window Messages</samp>
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">窗口消息</samp>
- en: Let’s look at a simple example in [Listing 3-7](chapter3.xhtml#Lis3-7), in which
    we send a window message to find the caption text for all the windows on the desktop.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，在[列表 3-7](chapter3.xhtml#Lis3-7)中，我们向窗口发送一个消息，用于查找桌面上所有窗口的标题文本。
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-7: Sending the WM_GETTEXT message to all windows on the desktop'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-7：向桌面上所有窗口发送WM_GETTEXT消息
- en: First, we enumerate all the windows on the current desktop using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtWindow</samp>
    command ❶. Next, we allocate a memory buffer to store 2,048 characters ❷. Keep
    in mind that we’ll be using this buffer to store 16-bit Unicode characters, so
    the number of characters must be multiplied by 2 to determine the size in bytes
    for the buffer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'In a loop ❸, we then send the <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_GETTEXT</samp>
    message (which is message number <samp class="SANS_TheSansMonoCd_W5Regular_11">0xD</samp>)
    to every window to query the window’s caption. We need to specify two parameters:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LParam</samp>, which is a pointer
    to the buffer we allocated, and <samp class="SANS_TheSansMonoCd_W5Regular_11">WParam</samp>,
    which is the maximum number of Unicode characters in the buffer. The values passed
    in these two parameters will be different for different message types. We wait
    to receive the result of sending the message, which indicates the number of characters
    that were copied into the buffer. We can then read out the caption string and
    print it to the output, ignoring any windows that have an empty caption.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to explore in the windowing system, but those details are
    outside the scope of this book. I recommend Charles Petzold’s seminal work on
    the topic, *Programming Windows*, 5th edition (Microsoft Press, 1998), if you
    want to know more about the development of Win32 applications. Next, we’ll look
    at how multiple users can use their own user interfaces on the same system through
    the creation of console sessions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Console Sessions</samp>
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first version of Windows NT allowed multiple users to be authenticated at
    the same time and each run processes. However, before the introduction of *Remote
    Desktop Services (RDS)*, it wasn’t possible for different interactive desktops
    to run multiple user accounts concurrently on the same machine. All authenticated
    users needed to share a single physical console. Windows NT 4 introduced multiple-console
    support as an optional, server-only feature before it became standard in Windows
    XP.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: RDS is a service on Windows workstations and servers that allows you to remotely
    connect to the GUI and interact with the system. It’s used for remote administration
    and to provide shared hosting for multiple users on the same network-connected
    system. In addition, its functionality has been repurposed to support a mechanism
    that can switch between users on the same system without having to log users out.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: To prepare for a new user login to Windows, the session manager service creates
    a new session on the console. This session is used to organize a user’s window
    station and desktop objects so that they’re separate from those belonging to any
    other user authenticated at the same time. The kernel creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp>
    object to keep track of resources, and a named reference to the object is stored
    in the *KernelObjects* OMNS directory. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp>
    object is usually only exposed to the user as an integer. There’s no randomness
    to the integer; it’s just incremented as each new console session is created.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The session manager starts several processes in this new session before any
    user logs in. These include a dedicated copy of CSRSS and the Winlogon process,
    which display the *credentials* user interface and handle the authentication of
    the new user. We’ll dig into the authentication process more in [Chapter 12](chapter12.xhtml).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The console session that a process belongs to is assigned when the process starts.
    (Technically, the console session is specified in the access token, but that’s
    a topic for [Chapter 4](chapter4.xhtml).) We can observe the processes running
    in each session by running some PowerShell commands, as shown in [Listing 3-8](chapter3.xhtml#Lis3-8).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-8: Displaying the processes in each console session using Get-NtProcess'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Windows has only one physical console, which is connected to the keyboard, mouse,
    and monitor. However, it’s possible to create a new remote desktop over the network
    by using a client that communicates using the *Remote Desktop Protocol (RDP)*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to switch the user logged on to the physical console; this
    enables support for the *Fast User Switching* feature in Windows. When the physical
    console switches to a new user, the previous user is still logged on and running
    in the background, but you cannot interact with that user’s desktop.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Each console session has its own special kernel memory region. Having duplicated
    resources ensures that the console sessions are separated; this acts as a security
    boundary. Session number 0 is special, in that it’s only for privileged services
    and system management. It’s normally not possible to use a GUI with processes
    running in this session.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Another important feature associated with console sessions is the separation
    of named objects. In the previous chapter we discussed the *BaseNamedObjects*
    directory, which is a global location for named objects that provides a means
    for multiple users to share resources. However, if multiple users can be logged
    in to the system at the same time, you could easily get name conflicts. Windows
    solves this problem by creating a per-console session BNO directory at *\Sessions\<N>\BaseNamedObjects*,
    where *<N>* is the console session ID. The *\Sessions* directory also contains
    a directory for the window stations, under *\Sessions\<N>\Windows*, which ensures
    that window resources, too, are separated. You can list the BNO directory of the
    current console session with the *NtObjectSession* drive, as shown in [Listing
    3-9](chapter3.xhtml#Lis3-9).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-9: The contents of a session’s BNO directory'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: There is no per-console session BNO for session 0; it uses the global BNO directory.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comparing Win32 APIs and System Calls</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all system calls are directly exposed through Win32, and in some cases,
    the Win32 API reduces the functionality of exposed system calls. In this section,
    we’ll look at some common differences between system calls and their Win32 API
    equivalents.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: As a case study, we’ll consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    API, the Win32 version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call we looked at in the preceding chapter. The API has the C prototype
    shown in [Listing 3-10](chapter3.xhtml#Lis3-10).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-10: The prototype for the CreateMutexEx Win32 API'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Compare it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    prototype, shown in [Listing 3-11](chapter3.xhtml#Lis3-11).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-11: The prototype for the NtCreateMutant system call'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The first difference between the prototypes is that the Win32 API returns a
    handle to the kernel object, while the system call returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    code (and receives the handle via a pointer as the first parameter instead).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder: How do errors get propagated back to an API’s caller, if
    not via an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> code?
    In this respect, the Win32 APIs are not always consistent. If the API returns
    a handle, then it’s common to return a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>.
    However, some APIs, such as the file APIs, return the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    instead. If a handle is not returned, it’s common to return a Boolean value, with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp> indicating success and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FALSE</samp> indicating an error.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: But what if we want to know *why* the API failed? For this purpose, the APIs
    define a set of error codes. Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    codes, these error codes don’t have any structure; they’re just numbers. When
    a Windows API fails, you can query for this error code by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>
    API.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '*NTDLL* provides an <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNtStatusToDosError</samp>
    API to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    code to a predefined Win32 error code. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    API can convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    code to a Win32 error code on failure, then write it to the last error location
    for the current thread using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp>
    API.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: We can look up error codes in PowerShell using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32Error</samp>,
    as shown in [Listing 3-12](chapter3.xhtml#Lis3-12).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 3-12: Looking up Win32 error code 5'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The second big difference between the system call and the Win32 API is that
    the API does not take the <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>
    structure. Instead, it splits the attributes between two parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">lpName</samp>,
    used to specify the object’s name, and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpMutexAttributes</samp>,
    which is a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_ATTRIBUTES</samp>
    structure.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">lpName</samp> parameter is
    a NUL-terminated string composed of 16-bit Unicode characters. Even though the
    object manager uses the counted <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>,
    the Win32 API uses a C-style terminated string. This means that while the NUL
    character is a valid character for an object name, it’s impossible to specify
    using the Win32 API.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that the name is not a full path to the OMNS location
    for the object; instead, it’s relative to the current session’s BNO directory.
    This means that if the name is *ABC*, then the final path used is *\Sessions\<N>\BaseNamedObjects\ABC*,
    where *<N>* is the console session ID. If you want to create an object in the
    global BNO directory, you can prefix the name with *Global* (for example, *Global\ABC*).
    This works because *Global* is a symbolic link to *\BaseNamedObjects*, which is
    automatically created along with the per-session BNO directory. If you want to
    simulate this behavior using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">New</samp> PowerShell commands,
    pass them the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Win32Path</samp>
    option, as shown in [Listing 3-13](chapter3.xhtml#Lis3-13).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 3-13: Creating a new Mutant with -Win32Path'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-14](chapter3.xhtml#Lis3-14) shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_ATTRIBUTES</samp>
    structure.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 3-14: The SECURITY_ATTRIBUTES structure'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to specify the security descriptor of the new object, as well
    as whether the handle should be inheritable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    Win32 API exposes no other options from <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the final two parameters in [Listing 3-10](chapter3.xhtml#Lis3-10):
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp> directly
    maps to <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>, and
    the native <samp class="SANS_TheSansMonoCd_W5Regular_11">InitialOwner</samp> parameter
    is specified through <samp class="SANS_TheSansMonoCd_W5Regular_11">dwFlags</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_MUTEX_INITIAL_OWNER</samp>
    flag.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: One surprise you might encounter may occur if you try to look up the address
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp> API
    in the export table of the *KERNEL32* DLL ([Listing 3-15](chapter3.xhtml#Lis3-15)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 3-15: Getting CreateMutexEx from <samp class="SANS_Futura_Std_Book_11">KERNEL32</samp>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Instead of receiving the address, we get an exception. Did we pick the wrong
    library? Let’s try to find the API by dumping all exports and filtering them by
    name, as shown in [Listing 3-16](chapter3.xhtml#Lis3-16).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 3-16: Finding the CreateMutexEx API by listing all exports'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>
    API is there not once, but twice. Each function has a suffix, either <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>. This is because Windows
    95 (where most of the APIs were initially created) didn’t natively support Unicode
    strings, so the APIs used single-character strings in the current text encoding.
    With the introduction of Windows NT, the kernel became 100 percent Unicode, but
    it provided two APIs for a single function to enable older Windows 95 applications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: APIs with an <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> suffix accept
    single-character strings, or *ANSI strings*. These APIs convert their strings
    into Unicode strings to pass to the kernel, and they convert them back again if
    a string needs to be returned. Applications built for Windows NT, on the other
    hand, can use the APIs with the <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>
    suffix, for *wide string*; these don’t need to do any string conversions. Which
    API you get when you build a native application depends on your build configuration
    and is a topic for a completely different book.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Win32 Registry Paths</samp>
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 2](chapter2.xhtml), you learned the basics of how to access the
    registry with native system calls using paths in the OMNS. The Win32 APIs used
    to access the registry, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">RegCreateKeyEx</samp>,
    do not expose these OMNS paths. Instead, you access registry keys relative to
    predefined root keys. You’ll be familiar with these keys if you’ve ever used the
    Windows regedit application, shown in [Figure 3-3](chapter3.xhtml#fig3-3).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-3.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: The main view of
    the regedit utility</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The handle values displayed in [Figure 3-3](chapter3.xhtml#fig3-3) are listed
    in [Table 3-1](chapter3.xhtml#tab3-1) along with their corresponding OMNS paths.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">Predefined
    Registry Handles and Their Native Equivalents</samp>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Predefined handle name</samp> |
    <samp class="SANS_Futura_Std_Heavy_B_11">OMNS path</samp> |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE</samp> |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_USERS</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER</samp>
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_CONFIG</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE\SYSTEM\CurrentControlSet\Hardware
    Profiles\Current</samp> |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER\<SDDL SID></samp>
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CLASSES_ROOT</samp> |
    <samp class="SANS_Futura_Std_Book_11">Merged view of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE\SOFTWARE\Classes</samp>
    <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER\<SDDL
    SID>_Classes</samp> |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: The first three predefined handles, <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_USERS</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_CONFIG</samp>,
    are not particularly special; they directly map to a single OMNS registry key
    path. The next handle, <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp>,
    is more interesting; it maps to a hive loaded for the currently authenticated
    user. The name of the hive’s key is the SDDL string of the user’s SID.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The final key, <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CLASSES_ROOT</samp>,
    which stores information such as file extension mappings, is a merged view of
    a user’s classes hive and the machine’s hive. The user’s hive takes precedence
    over the machine’s, allowing the user to change their file extensions without
    needing an administrator.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opening Keys</samp>
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtKey</samp> commands, we
    can specify a Win32 path by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp>
    parameter ([Listing 3-17](chapter3.xhtml#Lis3-17)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 3-17: Interacting with the registry using Win32 paths'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: We start by opening a <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp>
    object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp>
    command. We use the OMNS path to open the key, then convert the path to its Win32
    version using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp>
    property. In this case, we see that *\REGISTRY\MACHINE\SOFTWARE* is mapped to
    *HKEY_LOCAL_MACHINE\SOFTWARE*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'We then do the reverse and open a key using a Win32 name by specifying the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp> parameter and printing
    its native OMNS path. Here, we use the current user’s hive. Notice we’re using
    a shortened form of the predefined key name: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKCU</samp>,
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp>.
    All the other predefined keys have similar shortened forms; for example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HKLM</samp> refers to <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In the output, you can see the SDDL SID string, which represents the current
    user. As this example demonstrates, using the Win32 path to access the current
    user’s hive is much simpler than looking up the current user’s SID and opening
    it with the OMNS path.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Listing the Registry’s
    Contents</samp>
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the previous chapter, you saw how to list the registry’s contents using
    the *NtObject* or *NtKey* drive provider path. For the Win32 registry, you have
    a few additional options. To simplify accessing the current user’s hive, you can
    use *NtKeyUser*. For example, you can list the current user’s software key with
    the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'PowerShell also comes with built-in drives, *HKLM* and *HKCU*, for the local
    machine and current user’s hives, respectively. For example, the equivalent to
    the previous command is the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Why would you use one of these drive providers over another? Well, the PowerShell
    module’s drive providers have the advantage of allowing you to view the entire
    registry. They also use the native APIs, which use counted strings and support
    the use of NUL characters in the names of the registry keys and values. In contrast,
    the Win32 APIs use NUL-terminated C-style strings, which cannot handle embedded
    NUL characters. Therefore, if a NUL is embedded into a name, it’s impossible for
    the built-in provider to access that key or value. [Listing 3-18](chapter3.xhtml#Lis3-18)
    demonstrates this.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 3-18: Adding and accessing a registry key with a NUL character'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a new key with a NUL character in the name, indicated by
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">`0</samp> escape ❶. If you access
    this path via the *NtKeyUser* drive, you can successfully retrieve the key ❷.
    However, if you try this with the built-in drive provider, it doesn’t work; it
    can’t find the registry key ❸.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: This behavior of the Win32 APIs can lead to security issues. For example, it’s
    possible for malicious code to hide registry keys and values from any software
    that uses the Win32 APIs by embedding NUL characters in the name. This can prevent
    the malicious code from being detected. We’ll see how to uncover the use of this
    hiding technique in “Finding Hidden Registry Keys or Values” on page 94.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to get a mismatch if some software uses the native system
    calls and other software uses the Win32 APIs. For example, if some code checks
    the *ABC`0XYZ* path to ensure it has been correctly set up, then hands this to
    another application, which uses the path with the Win32 APIs, the new application
    will instead access the unrelated *ABC* key, which hasn’t been checked. This could
    lead to information disclosure issues if the contents of *ABC* were returned to
    the caller.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in registry provider does have an advantage too: it can be used without
    the installation of an external module. It also allows you to create new keys
    and add values, which the module’s provider does not allow you to do.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">DOS Device Paths</samp>
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another big difference between the Win32 APIs and the native system calls is
    how they handle filepaths. In the previous chapter, we saw that we can access
    a mounted filesystem using a *Device\<VolumeName>* path. However, we can’t specify
    this native path using the Win32 APIs. Instead, we use well-known paths, such
    as *C:\Windows*, that have drive letters. Because the drive letter paths are a
    vestige of MS-DOS, we call them *DOS device paths*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the Win32 API needs to pass the system call a native path for the
    system call to work correctly. The *NTDLL* API <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDosPathNameToNtPathName</samp>
    handles this conversion process. This API takes a DOS device path and returns
    the fully converted native path. The simplest conversion occurs when the caller
    has supplied a full drive path: for example, *C:\Windows*. In these cases, the
    conversion process merely prefixes the path with the predefined path component
    *\??* to get the result *\??\C:\Windows*.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The *\??* path, also called the *DOS device map prefix*, indicates that the
    object manager should use a two-step lookup process to find the drive letter.
    The object manager will first check a per-user DOS device map directory, in the
    path *Sessions\0\DosDevices\<AUTHID>*. Because the object manager checks a per-user
    location first, each user can create their own drive mappings. The *<AUTHID>*
    component is related to the authentication session of the caller’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>;
    I’ll describe this in [Chapter 4](chapter4.xhtml), but for now, it’s enough to
    know that its value is unique for each user. Note that the use of *0* for the
    console session ID is not a typo: all DOS device mappings are placed in a single
    location, regardless of which console session the user is logged in to.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: If the drive letter is not found in the per-user location, the object manager
    will check a global directory, *GLOBAL??*. If it’s not found there, then the file
    lookup fails. The drive letter is an object manager symbolic link that points
    to the mounted volume device. We can see this in action by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSymbolicLink</samp>
    command to open the drive letters and display their properties ([Listing 3-19](chapter3.xhtml#Lis3-19)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 3-19: Displaying the symbolic links for the <samp class="SANS_Futura_Std_Book_11">C:</samp>
    and <samp class="SANS_Futura_Std_Book_11">Z:</samp> drives'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: First, we open the *C:* drive symbolic link and display its <samp class="SANS_TheSansMonoCd_W5Regular_11">FullPath</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> properties. The
    full path is in the *\GLOBAL??* directory, and the target is the volume path ❶.
    We then create a new *Z:* drive using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-DosDevice</samp>
    command, pointing the drive to the *Windows* directory ❷. Note that the *Z:* drive
    is accessible in any user application, not just in PowerShell. Displaying the
    *Z:* drive’s properties reveals that it’s in the per-user DOS device map and that
    the target is the native path to the *Windows* directory ❸. This shows that the
    target of a drive letter doesn’t have to point directly to a volume, as long as
    it gets there eventually (in this case, after following the *C:* drive symbolic
    link). Finally, for completeness, we remove the *Z:* drive with <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-DosDevice</samp>
    ❹.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Path Types</samp>
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 3-2](chapter3.xhtml#tab3-2) shows several different path types that
    the Win32 APIs support, along with example native paths after conversion.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp> <samp class="SANS_Futura_Std_Book_11">Win32
    Path Types</samp>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">DOS path</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Native
    path</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">some\path</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\ABC\some\path</samp> | <samp
    class="SANS_Futura_Std_Book_11">Relative path to current directory</samp> |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">C:\some\path</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp> | <samp class="SANS_Futura_Std_Book_11">Absolute
    path</samp> |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">C:some\path</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\ABC\some\path</samp> | <samp
    class="SANS_Futura_Std_Book_11">Drive relative path</samp> |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\some\path</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp> | <samp class="SANS_Futura_Std_Book_11">Rooted
    to current drive</samp> |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\\.\C:\some\..\path</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\path</samp> | <samp class="SANS_Futura_Std_Book_11">Device
    path, canonicalized</samp> |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\\?\C:\some\..\path</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\..\path</samp> |
    <samp class="SANS_Futura_Std_Book_11">Device path, non-canonicalized</samp> |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp> | <samp
    class="SANS_Futura_Std_Book_11">Device path, non-canonicalized</samp> |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\\server\share\path</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\UNC\server\share\path</samp>
    | <samp class="SANS_Futura_Std_Book_11">UNC path to share on server</samp> |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: Due to the way DOS paths are specified, multiple DOS paths might represent the
    same native path. To ensure the final native path is correct, the DOS path must
    go through a *canonicalization* process to convert these different representations
    into the same canonical form.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: One simple operation undertaken in canonicalization is the handling of path
    separators. For native paths, there is only one path separator, the backslash
    (*\*) character. If you use a forward slash (*/*), the object manager will treat
    it as just another filename character. However, DOS paths support both forward
    slashes and backslashes as path separators. The canonicalization process takes
    care of this by ensuring all forward slashes are converted to backslashes. Therefore,
    *C:\Windows* and *C:/Windows* are equivalent.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Another canonicalization operation is the resolving of parent directory references.
    When writing a DOS path, you might specify a filename with one dot (*.*) or two
    dots (*..*), each of which has a special meaning. A single dot refers to the current
    directory, and the canonicalization process will remove it from the path. A double
    dot refers to the parent, so the parent directory will be removed. Therefore,
    the path *C:\ABC\.\XYZ* will get converted to *C:\ABC\XYZ*, and *C:\ABC\..\XYZ*
    will get converted to *C:\XYZ*. As with the forward slash, the native APIs do
    not know about these special filenames and will assume that they’re the names
    of the file to look up.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Most other operating systems, such as Linux, handle this canonicalization
    process in the kernel. However, due to the subsystem model, Windows must do the
    path canonicalization in user mode, inside the subsystem-specific library. This
    is to support any differences in behavior in OS/2 and POSIX environments.*'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the DOS path is prefixed with *\\?\* or *\??\*, then the path is not canonicalized
    and is instead used verbatim, including any parent directory references or forward
    slashes. In some cases, the *\??\* prefix can confuse the Win32 APIs with a current
    drive–rooted path, resulting in the opening of a path such as *\??\C:\??\Path*.
    It’s unclear why Microsoft added this DOS path type, considering its potential
    for confusion.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: You can manually convert a Win32 path to a native path using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFilePath</samp>
    command. You can also check the path type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFilePathType</samp>
    command. [Listing 3-20](chapter3.xhtml#Lis3-20) shows some examples of using these
    commands.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 3-20: Examples of Win32 filepath conversion'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: When you’re using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFile</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtFile</samp> command, you
    can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp> property
    to treat the path as a Win32 path and automatically convert it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Maximum Path Lengths</samp>
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The maximum filename length supported by Windows is limited by the maximum number
    of characters that can be stored in a <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>
    structure (32,767). However, Win32 APIs have a stricter requirement. By default,
    as shown in [Listing 3-21](chapter3.xhtml#Lis3-21), any attempt to pass a path
    longer than the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">MAX_PATH</samp>,
    defined as 260 characters, will fail. This behavior is implemented inside the
    *NTDLL* API <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDosPathNameToNtPathName</samp>
    when converting the path from Win32 to native format.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 3-21: Testing the Win32 MAX_PATH path limit'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDosPathNameToNtPathName</samp>
    API via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFilePath</samp>
    command. The first path we create is 259 characters long, which we can successfully
    convert to a native path. We then add one more character to the path, making the
    path 260 characters long; this attempt fails with the error <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NAME_TOO_LONG</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">MAX_PATH</samp> is 260, you may
    be wondering: Shouldn’t a 260-character-long path succeed? Unfortunately, no.
    The APIs include the NUL-terminating character as part of the path’s length, so
    the maximum path length is really only 259 characters.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-21](chapter3.xhtml#Lis3-21) also shows a way of bypassing this limitation.
    If we add the device prefix *\\?\* to the path, the conversion succeeds even though
    the length of the path is now 264 characters. This is because the prefix is replaced
    with the DOS device prefix *\??\*, and the remaining path is left verbatim. While
    this technique works, note that it also disables useful features, such as path
    canonicalization. As another workaround, in current versions of Windows there
    is a way of opting into long filenames, as shown in [Listing 3-22](chapter3.xhtml#Lis3-22).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 3-22: Checking and testing long, path-aware applications'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do here is verify that the <samp class="SANS_TheSansMonoCd_W5Regular_11">LongPathsEnabled</samp>
    registry value is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    The value must be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    before the process starts, as it will be read only once during process initialization.
    However, just enabling the long path feature isn’t sufficient: the process’s executable
    file must opt in by specifying a manifest property. We can query this property
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ExecutableManifest</samp>
    command and selecting <samp class="SANS_TheSansMonoCd_W5Regular_11">LongPathAware</samp>.
    Fortunately, PowerShell has this manifest option enabled ❶. We can now convert
    much larger paths successfully, as shown with a 303-character path ❷.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Are long paths a security issue? It’s common for security issues to be introduced
    in places where there is an interface boundary. In this case, the fact that a
    filesystem can support exceptionally long paths could lead to the incorrect assumption
    that a filepath can never be longer than 260 characters. A possible issue might
    occur when an application queries the full path to a file and then copies that
    path into a memory buffer with a fixed size of 260 characters. If the length of
    the filepath is not first checked, this operation could result in the corruption
    of memory after the buffer, which might allow an attacker to gain control of the
    application’s execution.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Creation</samp>
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Processes are the main way to execute user-mode components and isolate them
    for security purposes, so it’s important that we explore how to create them in
    detail. In the previous chapter, I mentioned that you can create a process using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp> system
    call. However, most processes won’t be created directly using this system call;
    rather, they’ll be created with the Win32 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    API, which acts as a wrapper.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The system call isn’t often used directly, because most processes need to interact
    with other user-mode components, especially CSRSS, to interact with the user’s
    desktop. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    API will register the new process created by the system call with the appropriate
    services necessary for correct initialization. We won’t discuss process and thread
    creation in detail in this book, but in this section I’ll give a quick overview.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Command Line Parsing</samp>
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest way to create a new process is to specify a command line string
    representing the executable to run. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    API will then parse the command line to find the executable file to pass to the
    kernel.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this command line parsing, let’s create a new process using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> PowerShell command,
    which executes <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    under the hood. We could use a built-in command such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp>
    to do this, but <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    is useful because it exposes the full set of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    API’s functionality. We can start a process using the following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We provide a command line containing the name of the executable to run, Notepad,
    and the name of a file to open, *test.txt*. This string doesn’t necessarily need
    to provide a full path to the executable; the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    command will parse the command line to try to distinguish the name of the initial
    executable image file from the file to open. That’s not as simple a process as
    it sounds.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    will do is parse the command line using an algorithm that splits on whitespace,
    unless that whitespace is enclosed in double quotes. In this case, it will parse
    the command line into two strings, <samp class="SANS_TheSansMonoCd_W5Regular_11">notepad</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">test.txt</samp>. The command
    then takes the first string and tries to find a matching process. However, there’s
    a slight complication: there is no *notepad* executable file, only *notepad.exe*.
    Though it’s not required, Windows executables commonly have a *.exe* extension,
    so the search algorithm will automatically append this extension if one doesn’t
    already exist.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The command will then search the following locations for the executable, much
    like the DLL path searching we discussed in “Searching for DLLs” on page 68. Note
    that the executable search path is the same as the unsafe DLL search path:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 1.  The same directory as the current process’s executable file
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The current working directory
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The Windows *System32* directory
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The *Windows* directory
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Each semicolon-separated location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATH</samp>
    environment variable
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> can’t
    find *notepad.exe*, it will next try to find the file *notepad test.txt*, in case
    that’s what we meant. As the filename has an extension already, it won’t replace
    it with *.exe*. If <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    can’t find the file, it returns an error. Note that if we passed <samp class="SANS_TheSansMonoCd_W5Regular_11">notepad</samp>
    surrounded by double quotes, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">"notepad"
    test.txt</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    would search for *notepad.exe* only and never fall back to trying all combinations
    of the name with the whitespace.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: This command line parsing behavior has two security implications. First, if
    the process is being created by a more privileged process and a less privileged
    user can write a file to a location earlier in the path search list, then the
    process could be hijacked.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The second security implication is that the path-searching algorithm changes
    if the first value contains a path separator. In this case, instead of using the
    path-searching rules, <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    splits the path by whitespace and then tries each component as if it were a path,
    searching for the name either with the *.exe* extension or without it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. If we specify a command line of <samp class="SANS_TheSansMonoCd_W5Regular_11">C:\Program
    Files\abc.exe</samp>, then the following paths will be searched for the executable
    file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '*C:\Program*'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Program.exe*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Program Files\abc.exe*'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Program Files\abc.exe.exe*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user could write the file *C:\Program* or *C:\Program.exe*, then they
    could hijack execution. Fortunately, on a default installation of Windows, a normal
    user can’t write files to the root of the system drive; however, configuration
    changes sometimes allow this. Also, the executable path might be on a different
    drive that does allow writing to the root.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid both security implications, the caller can specify the executable’s
    full pathname by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ApplicationName</samp>
    property when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we specify the path this way, the command will pass it verbatim to the new
    process.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shell APIs</samp>
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you double-click a non-executable file type, such as a text document, in
    Explorer, it will helpfully start an editor for you. However, if you try to run
    a document with <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>,
    you’ll get the error shown here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This error indicates that the text file is not a valid Win32 application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The reason Explorer can start the editor is that it doesn’t use the underlying
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> API directly;
    instead, it uses a shell API. The main shell API used to start the editor for
    a file is <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecuteEx</samp>,
    implemented in the *SHELL32* library. This API and its simpler sibling, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>, are much too complex
    to cover in detail here. Instead, I’ll give just a brief overview of the latter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, we need to specify three parameters to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The path to the file to execute
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The verb to use on the file
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any additional arguments
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first thing <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>
    does is look up the handler for the extension of the file to execute. For example,
    if the file is *test.txt*, then it needs to look up the handler for the *.txt*
    extension. The handlers are registered in the registry under the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CLASSES_ROOT</samp>
    key, which, as we saw earlier in the chapter, is a merged view of parts of the
    machine software and the user’s registry hive. In [Listing 3-23](chapter3.xhtml#Lis3-23),
    we query the handler.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 3-23: Querying the shell handler for <samp class="SANS_Futura_Std_Book_11">.txt</samp>
    files'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by querying the machine class’s key for the *.txt* extension ❶. Although
    we could have checked for a user-specific key, checking the machine class’s key
    ensures that we inspect the system default. The *.txt* registry key doesn’t directly
    contain the handler. Instead, the default value, represented by an empty name,
    refers to another key: in this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">txtfile</samp>
    ❷. We then list the subkeys of <samp class="SANS_TheSansMonoCd_W5Regular_11">txtfile</samp>
    and find three keys: <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">printto</samp>
    ❸. We can pass these verbs by name to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Each of these verb keys can have a subkey, called <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>,
    that contains a command line to execute ❹. We can see that the default for a *.txt*
    file is to open Notepad ❺; the <samp class="SANS_TheSansMonoCd_W5Regular_11">%1</samp>
    is replaced with the path to the file being executed. (The command could also
    contain <samp class="SANS_TheSansMonoCd_W5Regular_11">%*</samp>, which includes
    any additional arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>.)
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> API can
    now start the executable and handle the file.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: There are many different standard verbs you can pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>.
    [Table 3-3](chapter3.xhtml#tab3-3) shows a list of common ones you’ll encounter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Shell Verbs</samp>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Verb</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> | <samp class="SANS_Futura_Std_Book_11">Open
    the file; this is typically the default.</samp> |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">edit</samp> | <samp class="SANS_Futura_Std_Book_11">Edit
    the file.</samp> |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp> | <samp class="SANS_Futura_Std_Book_11">Print
    the file.</samp> |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">printto</samp> | <samp class="SANS_Futura_Std_Book_11">Print
    to a specified printer.</samp> |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">explore</samp> | <samp class="SANS_Futura_Std_Book_11">Explore
    a directory; this is used to open a directory in an Explorer window.</samp> |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp> | <samp class="SANS_Futura_Std_Book_11">Open
    the file as an administrator; typically, defined for executables only.</samp>
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">runasuser</samp> | <samp class="SANS_Futura_Std_Book_11">Open
    the file as another user; typically, defined for executables only.</samp> |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: You might find it odd that there is both an <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">edit</samp> verb. If you
    opened a *.txt* file, for example, the file would open in Notepad, and you’d be
    able to edit it. But the distinction is useful for files such as batch files,
    where the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> verb would
    execute the file and <samp class="SANS_TheSansMonoCd_W5Regular_11">edit</samp>
    would open it in a text editor.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'To use <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp> from
    PowerShell, you can run the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp>
    command. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>
    will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> verb, but
    you can specify your own verb using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Verb</samp>
    parameter. In the following code, we print a *.txt* file as an administrator using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp> verb:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Verb configurations can also improve security. For example, PowerShell scripts
    with a *.ps1* extension have the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    verb registered. However, clicking a script will open the script file in Notepad
    rather than executing the script. Therefore, if you double-click the script file
    in Explorer, it won’t execute. Instead, you must right-click the file and explicitly
    choose **Run with PowerShell**.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, the full details of the shell APIs are out of scope
    for this book; as you might expect, the full picture is not quite as simple as
    I’ve shown here.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">System Processes</samp>
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this and the preceding chapter, I’ve alluded to various processes
    that run with higher privileges than a normal user. This is because, even when
    no user is logged in to the operating system, the system still needs to perform
    tasks like waiting for authentication, managing hardware, and communicating over
    the network.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel could perform some of these tasks. However, writing kernel code
    is more difficult than user-mode code, for a number of reasons: the kernel doesn’t
    have as wide a range of APIs available; it’s resource constrained, especially
    in terms of memory; and any coding mistake could result in the system crashing
    or being exposed to a security vulnerability.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: To avoid these challenges, Windows runs a variety of processes outside of kernel
    mode, with a high privilege level, to provide important facilities. We’ll go through
    some of these special processes in this section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Session Manager</samp>
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *Session Manager Subsystem (SMSS)* is the first user-mode process started
    by the kernel after boot. It’s responsible for setting up the working environment
    for subsequent processes. Some of its responsibilities include:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Loading known DLLs and creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting subsystem processes such as CSRSS
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing base DOS devices such as serial ports
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running automatic disk integrity checks
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Windows Logon
    Process</samp>
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Windows logon* process is responsible for setting up a new console session,
    as well as displaying the logon user interface (primarily through the LogonUI
    application). It’s also responsible for starting the *user-mode font driver (UMFD)*
    process, which renders fonts to the screen, and the *desktop window manager (DWM)*
    process, which performs desktop compositing operations to allow for fancy, transparent
    windows and modern GUI touches.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Local Security
    Authority Subsystem</samp>
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ve already mentioned LSASS in the context of the SRM. However, it’s worth
    stressing its important role in authentication. Without LSASS, a user would not
    be able to log on to the system. We’ll cover LSASS’s roles and responsibilities
    in much more detail in [Chapter 10](chapter10.xhtml).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Service Control
    Manager</samp>
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *service control manager (SCM)* is responsible for starting most privileged
    system processes on Windows. It manages these processes, referred to as *services*,
    and can start and stop them as needed. For example, the SCM could start a service
    based on certain conditions, such as a network becoming available.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Each service is a securable resource with fine-grained controls determining
    which users can manipulate its state. By default, only an administrator can manipulate
    a service. The following are some of the most important services running on any
    Windows system:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote Procedure Call Subsystem (RPCSS)    **The RPCSS service manages the
    registration of remote procedure call endpoints, exposing the registration to
    local clients as well as over the network. This service is essential to a running
    system; in fact, if this process crashes, it will force Windows to reboot.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '**DCOM Server Process Launcher    **The DCOM Server Process Launcher is a counterpart
    to RPCSS (and used to be part of the same service). It’s used to start Component
    Object Model (COM) server processes on behalf of local or remote clients.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**Task Scheduler    **Being able to schedule an action to run at a specific
    time and date is a useful feature of an operating system. For example, perhaps
    you want to ensure that you delete unused files on a specific schedule. You could
    set up an action with the Task Scheduler service to run a cleanup tool on that
    schedule.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows Installer    **This service can be used to install new programs and
    features. By running as a privileged service, it permits installation and modification
    in normally protected locations on the filesystem.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows Update    **Having a fully up-to-date operating system is crucial
    to the security of your Windows system. When Microsoft releases new security fixes,
    they should be installed as soon as possible. To avoid requiring the user to check
    for updates, this service runs in the background, waking up periodically to check
    the internet for new patches.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Information    **This service provides a mechanism for switching
    between an administrator and non-administrator user on the same desktop. This
    feature is usually referred to as *User Account Control (UAC)*. You can start
    an administrator process by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp>
    verb with the shell APIs. We’ll cover how UAC works under the hood in the next
    chapter.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: We can query the status of all services controlled by the SCM using various
    tools. PowerShell has the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Service</samp>
    command; however, the PowerShell module used in this book provides a more comprehensive
    command, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32Service</samp>,
    that can inspect the configured security of a service as well as additional properties
    not exposed using the default command. [Listing 3-24](chapter3.xhtml#Lis3-24)
    shows how to query for all current services.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 3-24: Displaying all services using Get-Win32Service'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The output shows the name of the service, its status (either <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopped</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Running</samp>), and, if it’s
    running, the process ID of the service process. If you list the service’s properties
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>, you’ll
    also be able to see additional information, such as a full description of the
    service.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s walk through some worked examples to practice using the various commands
    covered in this chapter for security research or systems analysis.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Executables
    That Import Specific APIs</samp>
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the beginning of this chapter, you saw how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp>
    command to extract an executable file’s imported APIs. One use for this command
    that I find especially helpful when I’m trying to track down security issues is
    identifying all the executables that use a particular API, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>,
    and then using this list to reduce the files I need to reverse engineer. You can
    perform such a search with the basic PowerShell script shown in [Listing 3-25](chapter3.xhtml#Lis3-25).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 3-25: Finding executables that import CreateProcess'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Here, we start by enumerating all the *.exe* files in the *Windows* directory.
    For every executable file, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp>
    command. This will load the module and parse its imports. This can be a time-consuming
    process, so it’s best to capture the results into a variable, as we do here.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Next, we select only the imports that contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessW</samp>
    API. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Names</samp> property is
    a list containing the imported names for a single DLL. To get the resulting list
    of executable files that import a specific API, we can select the <samp class="SANS_TheSansMonoCd_W5Regular_11">ModulePath</samp>
    property, which contains the original loaded pathname.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same technique to enumerate DLL files or drivers and quickly
    discover targets for reverse engineering.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Hidden Registry
    Keys or Values</samp>
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In “Listing the Registry’s Contents” on page 81, I mentioned that one of the
    big advantages of using the native system calls over the Win32 APIs to interact
    with the registry is that they allow you to access keys and values with NUL characters
    in their names. It would be useful to be able to find these keys and values so
    you can try to detect software on your system that is actively trying to hide
    registry keys or values from the user (some malware families, such as Kovter and
    Poweliks, are known to use this technique). Let’s start by finding keys with NUL
    characters in the name ([Listing 3-26](chapter3.xhtml#Lis3-26)).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 3-26: Finding hidden registry keys'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: We first create a key in the current user’s hive with a NUL character in it.
    If you try to find this key using the built-in registry provider, it will fail.
    Instead, we do a recursive listing of the current user’s hive and select any keys
    that have a NUL character in the name. In the output, you can see that the hidden
    key was discovered.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: To find hidden values, we can query the list of values of a key by enumerating
    its <samp class="SANS_TheSansMonoCd_W5Regular_11">Values</samp> property. Each
    value contains the name of the key and the data value ([Listing 3-27](chapter3.xhtml#Lis3-27)).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 3-27: Finding hidden registry values'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a normal key, then adding a value with a NUL character
    in the name ❶. We then define a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Select-HiddenValue</samp>
    ❷, that will check keys in the pipeline and select any value with a NUL character
    in the name, returning a custom object to the pipeline ❸.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Next, we recursively enumerate the current user’s hive and filter the keys through
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select-HiddenValue</samp> function
    ❹. You can see in the output that we discovered the hidden value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter provided a quick tour through the Windows user-mode components.
    We started with a dive into Win32 APIs and the loading of DLLs. Understanding
    this topic is important, as it reveals how user-mode applications communicate
    with the kernel and implement common features.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Next, I provided an overview of the Win32 GUI, including a description of the
    separate system call table used for *WIN32K*, which is the kernel-mode component
    of the Win32 subsystem. I introduced the window station and desktop object types
    and outlined the purpose of the console session, as well as how it corresponds
    to the desktop you see as a user.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: I then returned to the topic of Win32 APIs by detailing the differences and
    similarities between a Win32 API (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>)
    and the underlying system call (<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>).
    This discussion should have given you a better understanding of how the Win32
    APIs interact with the rest of the operating system. I also introduced the differences
    between DOS device paths and native paths as understood by a system call, a topic
    that is important for understanding how user-mode applications interact with the
    filesystem.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: I concluded with a discussion of several topics related to Win32 processes and
    threads, covering the APIs used to create processes directly or through the shell
    and providing an overview of well-known system processes. In later chapters, we’ll
    revisit many of these topics in more depth. In the next three chapters, we’ll
    focus on how Windows implements security through the SRM.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
