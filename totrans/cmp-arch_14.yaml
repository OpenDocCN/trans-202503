- en: '**11**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: '**RETRO ARCHITECTURES**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**复古架构**'
- en: '![Image](../images/f0245-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0245-01.jpg)'
- en: Now that you’ve made it through the theory, let’s have some fun. [Part III](part03.xhtml)
    will consolidate your theoretical knowledge by programming on a series of real,
    emulated architectures. It’s possible to skip around these chapters depending
    on your interests, but they present systems roughly in order of their complexity
    and history, so seeing and programming the earlier systems may help you understand
    the later ones.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了理论部分，接下来让我们开始一些有趣的实践。[第三部分](part03.xhtml)将通过在一系列真实的模拟架构上编程，来巩固你的理论知识。你可以根据自己的兴趣跳过某些章节，但这些章节大致按照复杂性和历史的顺序呈现，因此查看并编程较早的系统，可能有助于你理解后续的系统。
- en: We previously studied the Analytical Engine and Manchester Baby, and in this
    chapter we’ll progress to 1980s 8-bit and then 16-bit systems. Modern embedded
    systems are somewhat similar to these retro systems, so we’ll work with them in
    the next chapter. We’ll then look at 1990s desktop PCs, followed by modern smart
    and parallel architectures. At each step we’ll introduce new features that have
    stuck around into modern designs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前研究过分析机和曼彻斯特婴儿计算机，而在本章中，我们将进阶到1980年代的8位系统，然后是16位系统。现代嵌入式系统与这些复古系统有些相似，因此我们将在下一章对它们进行研究。接下来，我们将研究1990年代的桌面PC，然后是现代智能和并行架构。在每个阶段，我们将介绍一些在现代设计中依然沿用的新特性。
- en: 'The basic structure of the classical CPU didn’t change very much from 1836
    to 1990\. The design served us well, from the Analytical Engine through what’s
    now known as the 1980s golden age of architectures. In this chapter, we’ll look
    at two designs from this golden age: the famous 8-bit 6502, as used in the Commodore
    64, Nintendo Entertainment System (NES), and BBC Micro; and the 16-bit 68000,
    which defined the 16-bit generation of machines, including the Commodore Amiga
    and Sega Megadrive. We’ll study these as relatively simple examples of classical
    CPUs, before things got complicated. These examples should help you to consolidate
    what you’ve learned in the previous chapters, so refer back to them if you need
    to look anything up as you go.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从1836年到1990年，经典CPU的基本结构变化不大。这个设计伴随我们走过了从分析机到现在所说的1980年代黄金时代的架构。在本章中，我们将看两个来自这一黄金时代的设计：著名的8位6502处理器，曾用于Commodore
    64、任天堂娱乐系统（NES）和BBC Micro；以及16位68000处理器，它定义了16位机器的一代，包括Commodore Amiga和Sega Megadrive。我们将把这些作为相对简单的经典CPU示例进行研究，了解在事物变得复杂之前的样貌。这些示例将帮助你巩固前面章节所学的内容，因此在进行时如果有任何需要查阅的地方，随时可以回头参考。
- en: Programming in the 1980s Golden Age
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1980年代黄金时代的编程
- en: Programming in the 1980s was dominated by architecture. The 1980s hardware market
    was highly heterogeneous, with many competing companies designing and producing
    different, incompatible machines. [Figure 11-1](ch11.xhtml#ch11fig1) shows just
    a few of the different machines that came out over the course of the decade.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 1980年代的编程由架构主导。1980年代的硬件市场高度异质化，许多竞争公司设计并生产不同且不兼容的机器。[图11-1](ch11.xhtml#ch11fig1)展示了十年间发布的几款不同机器。
- en: Instead of downloading apps, you could buy magazines full of printed assembly
    code that you would type out to run simple games and applications. Without modern
    operating systems, this code could read and write the machine’s entire memory
    space, so you could see exactly what was going on in your machine and be at one
    with its architecture.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有现代操作系统的情况下，你可以购买满是打印汇编代码的杂志，将其输入以运行简单的游戏和应用程序。这些代码能够读取和写入机器的整个内存空间，因此你可以精确地看到机器中的一切，感受到与其架构的融合。
- en: Computer design companies such as Commodore could produce their own custom ROMs
    at much lower cost using programmable ROMS or PLAs than if they had to do their
    own photolithography, and these technologies were a major enabler of the multitude
    of home computer systems. In today’s language, these ROMs were basic input-output
    systems (BIOSes), collections of subroutines that, for example, print ASCII text
    to the screen; draw points, lines, and triangles; and make sounds. The programmer
    could also perform these tasks directly via I/O—that is, by loading and storing
    directly to I/O module addresses—but subroutines were provided for convenience
    to automate the process. You would call a subroutine on a ROM chip by putting
    the necessary arguments into CPU registers and then doing a jump to the subroutine
    address in the ROM.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 像Commodore这样的计算机设计公司，使用可编程ROM或PLA比起自己进行光刻，能够以更低的成本生产自定义ROM，这些技术是大量家庭计算机系统得以实现的关键。用今天的话来说，这些ROM是基本输入输出系统（BIOS），它们是一些子例程，举个例子，打印ASCII文本到屏幕；绘制点、线和三角形；以及发出声音。程序员也可以通过I/O直接执行这些任务——也就是直接加载和存储到I/O模块地址——但为了方便起见，提供了子例程来自动化这个过程。你可以通过将必要的参数放入CPU寄存器，然后跳转到ROM中的子例程地址，来调用ROM芯片上的子例程。
- en: ROM and RAM were equally important, and they worked together. RAM was a scarce
    resource for user data and user programs that made many calls to the subroutines
    in ROM. In addition to knowing ROM subroutine addresses by heart, programmers
    and communities often had conventions for favorite regions of RAM to use for different
    tasks, so they would generally know their way around the memory map of their whole
    computer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ROM和RAM同样重要，它们协同工作。RAM是用户数据和用户程序的宝贵资源，这些程序频繁调用ROM中的子例程。除了记住ROM子例程地址，程序员和社区通常还会为不同任务约定RAM的常用区域，因此他们通常能够熟悉整个计算机的内存映射。
- en: 'Because of these conventions, users had much more direct access to their computers.
    The number of addresses was quite small: 32,768 (32 k[2]B) or 65,536 (64 k[2]B),
    and this meant you could find where variables like the number of lives in a game
    were stored, and then go inside the memory to edit them. Directly overwriting
    memory like this was called a *poke*, and successful pokes were collected onto
    *cheat disks* and passed around to modify games.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些约定，用户可以更加直接地访问他们的计算机。地址数量相当小：32,768（32 k[2]B）或65,536（64 k[2]B），这意味着你可以找到像游戏中的生命数量这样的变量存储位置，然后直接进入内存进行编辑。直接覆盖内存的操作被称为*poke*，成功的poke会被收集到*作弊器磁盘*中并传播开来，以修改游戏。
- en: '![Image](../images/f0247-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0247-01.jpg)'
- en: '*Figure 11-1: Different computers from the 1980s golden age*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-1：1980年代黄金时代的不同计算机*'
- en: '*8-Bit Era*'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8位时代*'
- en: 'The early 1980s was the 8-bit era: this was the time of the Commodore 64 and
    Atari 2600, games consoles like the Sega Master System and Nintendo NES, and the
    British machines BBC Micro and ZX Spectrum.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 1980年代初期是8位时代：这是Commodore 64和Atari 2600的时代，也是像Sega Master System和Nintendo NES这样的游戏主机时代，还有英国的BBC
    Micro和ZX Spectrum。
- en: Some of these machines shared some subcomponents; for example, the 6502 was
    used in both the Commodore 64 and BBC Micro, and the Spectrum’s Z80 chip could
    be added to the BBC Micro as a second processor, so you could have friends sharing
    programs at this level. But the machines would have different graphics and sound
    chips containing different functions at different addresses that weren’t compatible,
    and typically each machine would have its own friends, user groups, and magazines
    form around it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机器共享了一些子组件；例如，6502处理器被用于Commodore 64和BBC Micro，而Spectrum的Z80芯片可以作为第二处理器添加到BBC
    Micro中，这样你就可以在这个层面上与朋友分享程序。但这些机器的图形和声音芯片不同，包含不同功能，位于不同的地址上，因此不兼容，通常每台机器都会有自己的朋友、用户组以及围绕它形成的杂志。
- en: Computer graphics and music of this era looked (see [Figure 11-2](ch11.xhtml#ch11fig2))
    and sounded *like computers* because they reflected their architecture, creating
    a computer culture that has been lost today. You could actually feel the 8-bit-ness
    of an 8-bit game in a way that you don’t see 64-bit-ness in contemporary games.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时代的计算机图形和音乐看起来（参见[图11-2](ch11.xhtml#ch11fig2)）和听起来*像计算机*，因为它们反映了计算机的架构，创造了一种今天已经失传的计算机文化。你实际上可以感觉到8位游戏的“8位性”，而今天的64位游戏中却无法感受到那种“64位性”。
- en: '![Image](../images/f0248-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0248-01.jpg)'
- en: '*Figure 11-2: An example of typical 8-bit game graphics*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：典型的8位游戏图形示例*'
- en: Even just playing—rather than writing—games in the golden age could be subliminally
    educational about architecture. Games were usually written specifically to play
    with and explore the architecture, to push it to its limits, and to show off programming
    skills. For example, the 8-bit architecture encouraged games to use certain sizes
    of sprites and certain layouts of levels. You could animate *Space Invaders* easily
    by overwriting the area of memory where the *A* character was defined, replacing
    it with an 8×8 pixel space invader, then just print the *A* character on the screen
    to move it around, without needing any graphics commands. (The downside of this
    was that when you listed your program to debug it afterward, all the *A*s had
    also changed into space invaders.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即便只是玩游戏——而不是编写——也能潜移默化地学到架构知识。游戏通常是专门为了与架构互动和探索架构而编写的，目的是将其推到极限，并展示编程技巧。例如，8位架构鼓励游戏使用特定尺寸的精灵和特定布局的关卡。你可以通过覆盖内存中定义字符*A*的区域，将其替换为一个8×8像素的外星人，从而轻松地给*Space
    Invaders*动画，而无需任何图形命令。然后，只需将*A*字符打印到屏幕上，就能移动它。（这样做的缺点是，当你列出程序进行调试时，所有的*A*也会变成外星人了。）
- en: '*16-Bit Era*'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*16位时代*'
- en: The late 1980s introduced 16-bit machines and continued this style of assembly
    programming, but with the extra bits and more advanced I/O modules enabling a
    move to *sampling* of images and sounds rather than their pure computer generation,
    as on 8-bit machines. These developments gave rise to the distinctive 16-bit aesthetics
    of sprite-based games like *Sonic* and *Mario* ([Figure 11-3](ch11.xhtml#ch11fig3)),
    and sample-based music by artists such as The Prodigy and the soundtracks of games
    such as *Streets of Rage 2*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 1980年代末期推出了16位机器，并延续了这种汇编编程风格，但额外的位数和更先进的I/O模块使得图像和声音的*采样*成为可能，而不再像8位机器那样纯粹由计算机生成。这些发展催生了具有鲜明16位美学的精灵式游戏，比如*Sonic*和*Mario*（[图11-3](ch11.xhtml#ch11fig3)），以及The
    Prodigy等艺术家创作的基于采样的音乐和如*Streets of Rage 2*等游戏的原声带。
- en: '![Image](../images/f0249-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0249-01.jpg)'
- en: '*Figure 11-3: An example of typical 16-bit game graphics*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：典型16位游戏图形示例*'
- en: Popular machines included the Commodore Amiga, Atari ST, Sega Megadrive, and
    Nintendo SNES. High-performance programs such as games and demos were still mostly
    written in assembly, with full access to memory, but they would make heavier use
    of calls to additional graphics and sound hardware.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的机器包括Commodore Amiga、Atari ST、Sega Megadrive和Nintendo SNES。像游戏和演示程序等高性能程序仍然主要用汇编语言编写，能够完全访问内存，但它们会更多地使用对额外图形和声音硬件的调用。
- en: Companies continued to produce 16-bit machines into the early 1990s, including
    for many now-classic games. But by this time most programmers had shifted to the
    C language, which could compile into assembly code for multiple machines, making
    it easier to port software between them. Programmers came to rely more on heavyweight
    operating systems, also accessed primarily via C libraries. Together, C and operating
    systems acted to wrap and hide architecture, presenting higher-level and more
    portable interfaces to the machines, but ending the 1980s golden age of architecture-based
    programming.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 各公司继续在1990年代初期生产16位机器，包括许多如今已经成为经典的游戏。但此时大多数程序员已转向使用C语言，它能够编译成多个机器的汇编代码，使得在不同平台间移植软件变得更加容易。程序员们开始更多依赖重量级操作系统，这些操作系统主要通过C库进行访问。C语言和操作系统共同作用，封装并隐藏了硬件架构，提供了更高级且更便携的接口，但也终结了1980年代架构编程的黄金时代。
- en: Good times! Let’s relive them here by learning to program on two classic systems
    from the period, the 8-bit 6502-based Commodore 64 (C64) and the 16-bit 68000-based
    Commodore Amiga. For each system, we’ll first study its CPU in isolation, then
    its wider computer design. In the exercises, we’ll write assembly programs for
    a C64 animated text demo and a simple Amiga game.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 美好的时光！让我们通过在两个经典系统上学习编程来重温这些时光：8位6502架构的Commodore 64（C64）和16位68000架构的Commodore
    Amiga。对于每个系统，我们首先会独立学习其CPU，然后研究它的计算机设计。在练习中，我们将编写C64动画文本演示和简单的Amiga游戏的汇编程序。
- en: Working with the MOS 6502 8-Bit CPU
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MOS 6502 8位CPU进行编程
- en: 'MOS Technology’s MOS 6502 was an 8-bit processor, designed in 1975 by Chuck
    Peddle. *MOS* stands for *metal-oxide semiconductor*, as in the MOS field-effect
    transistors, or MOSFETs, used by the company. The 6502 was used in many of the
    classic 8-bit micros of the 1980s: the Commodore 64, NES, Atari 2600, Apple II,
    and BBC Micro; it was also used in first-generation arcade machines such as *Asteroids*.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: MOS科技的MOS 6502是一个8位处理器，由Chuck Peddle于1975年设计。*MOS*代表*金属氧化物半导体*，指的是公司使用的MOS场效应晶体管（MOSFET）。6502在1980年代许多经典的8位微型计算机中得到了应用：如Commodore
    64、NES、Atari 2600、Apple II和BBC Micro；它还被用于第一代街机游戏机，如*Asteroids*。
- en: Here we’ll study the 6502 using the same steps as for the Analytical Engine
    and Manchester Baby. We’ll first examine its structures, including registers,
    the arithmetic logic unit (ALU), the decoder, and the control unit (CU). We’ll
    then look at its instruction set, including instructions for memory access, arithmetic,
    and control flow.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过与分析引擎（Analytical Engine）和曼彻斯特宝宝（Manchester Baby）相同的步骤来研究6502。我们将首先检查其结构，包括寄存器、算术逻辑单元（ALU）、解码器和控制单元（CU）。然后我们将研究其指令集，包括内存访问、算术运算和控制流的指令。
- en: '*Internal Subcomponents*'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*内部子组件*'
- en: The 6502 had 3,000 transistors and wires connecting them. The layout of these
    components was designed and drawn by hand on transparent sheets, with pens and
    masking tape, and then made directly into chips using photolithography.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 6502有3000个晶体管和连接它们的导线。这些组件的布局是通过透明纸张手工设计并绘制的，使用钢笔和胶带，然后通过光刻技术直接制作成芯片。
- en: '**NOTE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The term* taping out *is still used to refer to the equivalent modern computerized
    process of finalizing photolithography mask designs. For chip designers, a tape-out
    marks the end of their work and handover to a fab plant. Like “shipping” for software
    companies, taping out can be a reason to have a large party, lasting until the
    chips arrive in the mail and fail to work.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*“Taping out”*一词仍然用于指代现代计算机化的光刻掩模设计完成过程。对于芯片设计师来说，taping out标志着他们工作的结束，并交接给制造厂。就像软件公司中的“发布”一样，taping
    out也是举办大型派对的理由，直到芯片通过邮寄到达并无法正常工作为止。'
- en: Physically, the 6502 appears as a plastic-packaged integrated circuit (IC) about
    2 cm long, with 40 pins, as seen in [Figure 9-2](ch09.xhtml#ch09fig2). Eight of
    these are data pins, labeled D0 through D7\. These pins read and write 8-bit words
    of data to and from memory, and they define the CPU as an 8-bit machine. The 6502
    uses a 16-bit address space accessed by writing 16-bit addresses on the 16 address
    pins, A0 through A15\. This enables up to 64 k[2]B to be addressed. The R/W is
    the control line that specifies whether we want to read or write to the address.
    The package also has pins for ground and supply voltage, a clock, and an IRQ (interrupt
    request) line. The clock sets the speed of the CPU, usually to around 1 to 3 MHz.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 物理上，6502呈现为一个长约2厘米的塑料封装集成电路（IC），有40个引脚，如[图9-2](ch09.xhtml#ch09fig2)所示。这些引脚中有8个是数据引脚，标记为D0到D7。这些引脚用于读取和写入8位数据字到内存中，也定义了CPU为8位机器。6502使用一个16位的地址空间，通过在16个地址引脚A0到A15上写入16位地址来进行访问。这使得最多可以寻址64
    k[2]B的内存。R/W是控制线，指示我们是否要读取或写入地址。封装还具有地线、供电电压、时钟和IRQ（中断请求）引脚。时钟设定CPU的速度，通常为1到3
    MHz之间。
- en: The actual silicon chip is much smaller than the outer package, about 5 mm².
    [Figure 11-4](ch11.xhtml#ch11fig4) shows a photograph of the chip under a microscope
    (known as a *die shot*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的硅芯片比外包装小得多，约为5 mm²。[图11-4](ch11.xhtml#ch11fig4)展示了芯片在显微镜下的照片（称为*晶片图*）。
- en: '![Image](../images/f0251-01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0251-01.jpg)'
- en: '*Figure 11-4: A 6502 chip microscope photograph*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-4：6502芯片显微镜照片*'
- en: Details of this chip’s design were lost for several decades, but they were recently
    fully reverse engineered at the transistor level in a heroic effort by the Visual
    6502 project (*[http://visual6502.org](http://visual6502.org)*). The workers on
    this project exposed the silicon by applying acid to dissolve some of the plastic
    casing. They then took die shots of the chip to reverse engineer its circuit diagram.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个芯片的设计细节在几十年间丢失，但最近在Visual 6502项目中通过英雄般的努力，成功地在晶体管级别进行了完全的逆向工程 (*[http://visual6502.org](http://visual6502.org)*)。该项目的工作人员通过施加酸性物质溶解部分塑料外壳来暴露硅片，然后拍摄芯片的晶片图像，逆向工程其电路图。
- en: The circuit contains only transistors and copper wires, but some very skilled
    chip-reading people have learned to look at these and mentally chunk them into
    logic gates. From there, they were chunked into well-known simple machines. This
    painstaking process, guided by the surviving block diagram shown in [Figure 11-5](ch11.xhtml#ch11fig5),
    enabled the whole architecture to be reverse engineered and reconstructed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0252-01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The original 6502 block diagram*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The circuit in [Figure 11-5](ch11.xhtml#ch11fig5) shows some recognizable subcomponents
    that are common to most classic-design chips. Each component is a digital logic
    simple machine. We’ll examine each of the main subcomponents in turn.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**THE MONSTER 6502**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: As a result of the Visual 6502 project, the 6502 is now being manufactured again
    for use as a cheap, embedded processor—for example, in Internet of Things (IoT)
    devices—as well as for education, such as our present study. The design was also
    used by Eric Schlaepfer and Evil Mad Scientist Laboratories to create a fully
    functioning—but slower than the original—MOnSter 6502 rebuild from big transistors
    rather than ICs, shown here.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0253-01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: '**User Registers**'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Figure 11-4](ch11.xhtml#ch11fig4) the registers and ALU are the regular
    area in the lower half of the chip. The 8 bits are stacked vertically, as in Babbage’s
    machines. There are three 8-bit user registers: two general-purpose ones called
    X and Y, and an accumulator called A.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The X and Y registers are intended to be usable together to represent 16-bit
    addresses, with the first 8 of the 16 bits stored in X and the second 8 bits stored
    in Y. It’s quite hard work to manipulate the two halves separately, so the architecture
    often provides methods to manipulate the two 8-bit halves of 16-bit addresses
    together.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to imagine and visualize 8-bit memory as divided into 256 pages
    of 256 bytes each. For example, 8-bit hex editors may display one page of memory
    on the screen at a time, like the pages of a book. Viewed this way, one of the
    two bytes is the page number and the other says what line on the page is used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s common 6502 programming practice to use the 256 addresses in page 0 of
    memory as if they were additional registers. This is slower than using actual
    registers, so A, X, and Y are preferred in the first instance.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal Registers**'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall that the program counter keeps track of the current line number. Here,
    the program counter stores a 2 byte address. It’s automatically incremented by
    the CU after executing each instruction, unless it’s a flow control instruction.
    It can be accessed as 2 individual bytes (PCH, PCL) storing the high and low parts
    of the 16-bit address. On power-up, the 6502 copies the content of addresses FFFC
    and FFFD (usually ROM, and pointing to a ROM subroutine) into the program counter
    to tell it where to begin executing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Here, the stack pointer is a single byte, and it’s assumed to refer to lines
    on page 1 of memory; note this is the second page, after page 0\. In most programming
    styles, the stack isn’t accessed directly by the programmer, but rather is used
    internally by the subroutine instructions to push and pop the address of the calling
    line. However, it can also be accessed directly using instructions (`PHA` and
    `PLA`) that push and pop the contents of the accumulator to and from the stack.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，堆栈指针是一个字节，它被假定为指向内存第1页的行；注意这是第二页，紧跟着第0页。在大多数编程风格中，堆栈不是由程序员直接访问的，而是由子程序指令内部使用，用于推入和弹出调用行的地址。然而，它也可以通过指令（`PHA`
    和 `PLA`）直接访问，这些指令将累加器的内容推入和弹出堆栈。
- en: 'The instruction register holds a copy of the current instruction; in the 6502,
    opcodes are 8 bits long and may require 0, 1, or 2 bytes of operand. Because the
    data bus is 8-bit, fetching instructions usually requires several steps; the opcode
    and operand need to be copied in one byte at a time. This is one of the reasons
    why 8-bit machines are slow: machines with larger word lengths could fetch whole
    instructions, including opcodes and operands, as single words.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 指令寄存器保存当前指令的副本；在6502中，操作码为8位，可能需要0、1或2个字节的操作数。由于数据总线是8位的，因此获取指令通常需要多个步骤；操作码和操作数需要逐字节复制。这是8位机器速度较慢的原因之一：具有较大字长的机器可以将整个指令（包括操作码和操作数）作为单个字取出。
- en: The status register holds 8 bits of flags that can be tested and used by control
    flow instructions. These are set in the ALU, which we’ll turn to next.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 状态寄存器包含8位标志，可以被控制流指令测试和使用。这些标志在ALU中设置，我们接下来将讨论它。
- en: '**Arithmetic Logic Unit**'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算术逻辑单元**'
- en: In the 6502, the ALU is physically built around the registers so that the 8
    bits flow horizontally, as in Babbage’s machines. The registers-ALU area looks
    a lot like Babbage’s Difference Engine, and contains a similar parallel propagation
    of bits and carries. If you miniaturized Babbage’s metal machine onto a chip,
    this is pretty much what it would look like; only the scale has changed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在6502中，ALU的物理结构围绕寄存器构建，使得8位数据水平流动，就像巴贝奇的机器一样。寄存器-ALU区域看起来很像巴贝奇的差分机，并且包含类似的并行传播位和进位。如果你把巴贝奇的金属机器微型化到一块芯片上，它的外观大致就是这样；只是尺度发生了变化。
- en: The ALU provides integer addition and subtraction simple machines, activated
    by instructions (`ADC`, `SBC`), along with dedicated increment and decrement (`INC`,
    `DEC`). There are bitshifts and bitwise Boolean instructions (`ASL,` `ASR; AND,
    ORA, EOR`). There are no multiplication or division instructions—these must be
    constructed in software from what’s available. There is also no floating point.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ALU提供整数加法和减法简单运算，通过指令（`ADC`、`SBC`）激活，以及专门的增量和减量指令（`INC`、`DEC`）。还有位移和按位布尔运算指令（`ASL`、`ASR`；`AND`、`ORA`、`EOR`）。没有乘法或除法指令——这些必须通过可用的软件来构建。同时也没有浮动点运算。
- en: '[Figure 11-6](ch11.xhtml#ch11fig6) shows the ALU’s assigned meanings of the
    bits in the status register, which are written as side effects of its operations.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-6](ch11.xhtml#ch11fig6)显示了ALU在状态寄存器中分配的位的含义，这些位是作为其操作的副作用写入的。'
- en: '![Image](../images/f0255-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0255-01.jpg)'
- en: '*Figure 11-6: The status register flags*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-6：状态寄存器标志*'
- en: The ALU’s operations include flagging if the result was zero (Z) or negative
    (N), if there was an overflow (V), and if there was a carry (C).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ALU的操作包括标记结果是否为零（Z）或负数（N），是否发生溢出（V），以及是否有进位（C）。
- en: '**Decoder**'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解码器**'
- en: In [Figure 11-4](ch11.xhtml#ch11fig4), the decoder is visible in the upper one-fifth
    of the die shot as a semi-regular binary structure. It looks like a load of binary
    numbers stored in an array, which is pretty much what it is. Opcodes are 8 bits,
    meaning that 256 distinct instructions are possible. Each opcode is decoded and
    used to activate a control line.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图11-4](ch11.xhtml#ch11fig4)中，解码器位于芯片照片的上五分之一处，呈现为半规则的二进制结构。它看起来像是存储在数组中的大量二进制数字，实际上就是这样。操作码为8位，意味着最多可以有256条不同的指令。每个操作码都会被解码并用于激活控制线。
- en: '**Control Unit**'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**控制单元**'
- en: In [Figure 11-4](ch11.xhtml#ch11fig4), the CU forms the middle region of the
    chip. It appears visually as a highly irregular region. This is because every
    operation is different, so it’s implemented with entirely different circuitry.
    The 6502 CU often needs to do more work than later 16-bit machines, because the
    6502 operates with 16-bit address and sometimes 16- or 24-bit instructions, which
    the CU has to break up into 8-bit chunks and marshal over the 8-bit bus.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '*Programmer Interface*'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 11-7](ch11.xhtml#ch11fig7) shows the complete instruction set for the
    6502.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0256-01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: The complete 6502 instruction set. For full definitions of these
    instructions, see* [https://en.wikibooks.org/wiki/6502_Assembly](https://en.wikibooks.org/wiki/6502_Assembly).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Because opcodes are 8-bit, there’s space for 256 instructions; notice, though,
    that the instruction set architecture contains a few less, so there are some gaps
    in the table.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '**Load and Store**'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Loading (`LD`) to and storing (`ST`) from the three user registers (X, Y, and
    A) is done using instructions such as:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Offset addressing enables the value of a user register to be used as an offset
    to a given address. This is useful for iterating over arrays. For example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Indirect addressing allows us to specify an address that in turns holds another
    address where we actually want to load or store:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Indirection and offsetting can be used together, such as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Zero-paging* is the 6502 convention that page 0 of memory is intended to function
    similarly to 256 additional registers. This requires specifying and moving around
    only 1 byte of address, as in:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is faster than moving 2 bytes around individually.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic**'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `ADC` instruction means “add data with carry.” It adds the integer contents
    of its address operand, and the carry bit from the status register, to the accumulator.
    The following program should end with hex value 0A[16] (decimal 10) in the accumulator:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`CLC` clears the carry flag; it’s important to do this before any new addition,
    unless you want the carry from a previous operation to get added in as well.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'To add two 16-bit integers, we can make use of the carry status flag state,
    instead of clearing it. Each `ADC` reads and writes it, so we can split a 16-bit
    addition into a pair of two 8-bit additions with a carry. Here, the two inputs,
    `num1` and `num2`, and the output, `result`, are each split into low and high
    bytes:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, `SBC` is “subtract with carry,” so the following computes 7 – 3,
    resulting in the value 4 in the accumulator:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can increment (`INC` or `IN`) and decrement (`DEC` or `DE`) both address
    and register contents with instructions such as:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here again, # denotes that the operand is a constant, with the other operands
    being addresses.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**Jump and Branches**'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`JMP` is the jump instruction. The following program continually increments
    register X, which will overflow after FF[16], going back to 00[16]:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instead of specifying the line number to jump to—as a BASIC programmer of the
    era might—this notation first marks the destination line with a *label*—in this
    case, `mylabel`—then specifies the name of this label in the jump instruction.
    The label line doesn’t compile to machine code; it’s ignored when first seen by
    the assembler. But when the assembler sees the label again in the jump instruction,
    it replaces it with the address of the instruction following the label.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与当时的BASIC程序员可能直接指定跳转的行号不同，这种符号首先用一个*标签*标记目标行——在这个例子中是`mylabel`——然后在跳转指令中指定这个标签的名称。标签行不会被编译成机器码；当汇编器首次看到它时，它会被忽略。但是，当汇编器在跳转指令中再次看到标签时，它会将其替换为标签后面指令的地址。
- en: 'Conditional branching can be done in two stages. First, comparison instructions
    check if some condition is true and store the result in the status register. Then,
    branch instructions consult the status register to decide when to branch. For
    example, the following uses register X to count down from 5 to 2 then halt, by
    comparing X to 2 (`CPX`) and branching if the comparison isn’t equal (`BNE`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 条件分支可以分为两个阶段。首先，比较指令检查某个条件是否为真，并将结果存储在状态寄存器中。然后，分支指令会查询状态寄存器，以决定何时分支。例如，以下程序使用寄存器X从5递减到2，然后停止，通过将X与2进行比较（`CPX`），如果不相等则跳转（`BNE`）：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also branch (`B`) if the comparison was equal (`BEQ`), negative (on
    minus, `BMI`), or positive (on plus, `BPL`). Or if the carry (`C`) or overflow
    (`V`) flag is clear (`C`) or set (`S`): `BCC`, `BVC`, `BCS`, `BVS`, respectively.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以根据比较结果进行分支（`B`），例如如果相等则跳转（`BEQ`），负值（即负数，`BMI`），或正值（即正数，`BPL`）。或者，如果进位标志（`C`）或溢出标志（`V`）为清除（`C`）或设置（`S`）：分别使用`BCC`、`BVC`、`BCS`、`BVS`。
- en: '**Subroutines**'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**子程序**'
- en: '`JSR` and `RTS` jump to and return from a subroutine, respectively. For example,
    the following program uses a common convention of placing arguments for a subroutine
    into addresses at the start of memory, which are then picked up by the subroutine
    code. `BRK` is “break,” roughly the 6502’s halt instruction (actually an interrupt).
    It’s needed to prevent the main program execution overrunning into the code of
    the subroutine after it.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSR`和`RTS`分别是跳转到子程序和从子程序返回的指令。例如，以下程序使用一种常见约定，将子程序的参数放入内存起始地址中，然后由子程序代码取出。`BRK`是“中断”指令，类似于6502的停止指令（实际上是一个中断）。它用于防止主程序执行时超出子程序的代码区域。'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the exercises, you’ll see how to run the above and similar examples on an
    emulated standalone 6502\. A 6502 by itself isn’t very exciting, though. We need
    a computer design to add memory and I/O to the CPU, so now let’s zoom out from
    the 6502 and look at a complete computer design, the Commodore 64, based upon
    it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习中，你将看到如何在模拟的独立6502上运行上述以及类似的示例。单独的6502并不是特别激动人心，我们需要设计一个计算机系统来为CPU增加内存和I/O功能，因此现在让我们从6502的视角缩小，来看一看基于6502的完整计算机设计——Commodore
    64。
- en: 8-Bit Computer Design with the Commodore 64
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Commodore 64的8位计算机设计
- en: The 6502-based Commodore 64, or C64, was and still is the highest-selling computer
    model of all time. Released in 1982, it defined the 8-bit home computing market
    in most of the world by combining gaming features with the potential for business
    and creative applications. Commodore was so named because its founder, the colorful
    Holocaust survivor Jack Tramiel, originally wanted “General Computers,” like “General
    Electric,” but “General” was taken. Commodore is a lower, second-choice rank below
    general. The C64 board was shown previously in [Figure 9-1](ch09.xhtml#ch09fig1).
    Its name comes from the fact that it used the full 64 k[2]B of available memory
    from its 16-bit address space with 8-bit words (2^(16) addresses × 8 bits = 64
    k[2]B), unlike some other 6502-based machines.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于6502的Commodore 64（C64）是有史以来销量最高的计算机型号。它于1982年发布，通过将游戏功能与商业和创意应用的潜力结合，定义了全球大部分地区的8位家用计算机市场。Commodore这个名字源于它的创始人、充满传奇的二战幸存者Jack
    Tramiel，他原本想取名为“General Computers”，就像“General Electric”一样，但“General”已经被使用。Commodore比General低一级，是一个次选的等级。C64的电路板在[图9-1](ch09.xhtml#ch09fig1)中已经展示过。它的名字来自于它使用了其16位地址空间中的64
    k[2]B可用内存，采用8位字（2^(16)个地址 × 8位 = 64 k[2]B），与其他一些基于6502的机器不同。
- en: '*Understanding the Architecture*'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*理解架构*'
- en: MOS produced several variants of the 6502 and assigned different model numbers
    to each. As with 7400 logic chips, “6502” is thus ambiguous, sometimes used to
    mean the original, numbered CPU design, and other times referring to all members
    of the family, which each have related numbers. The 6502 family member used in
    the Commodore 64 is more precisely known as the 6510.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: In addition to a full 64 k[2]B of actual RAM, the C64 also added devices, I/O
    modules, and their own ROMs containing libraries of subroutines for talking to
    them (what we now call a BIOS). It’s this configuration that differentiates the
    C64 from other 6502-based machines as a programming platform.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The physical board layout is connected as in the block diagram of [Figure 11-8](ch11.xhtml#ch11fig8).
    The bus—consisting of 16-bit addressing and 8-bit data—dominates this diagram
    and connects the CPU, RAM, ROM, and I/O.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0261-01.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-8: A C64 block diagram*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-9](ch11.xhtml#ch11fig9) shows the memory map for the C64.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0262-01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-9: A C64 memory map*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In this memory map, the RAM, ROM, and I/O are each assigned address ranges within
    the 16-bit address space. The I/O address space is broken down into ranges used
    by individual I/O modules and chips. (Because address space was a scarce resource
    at this time, the C64 enables the programmer to temporarily disconnect the ROMs
    from it and mount additional RAM in their place.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**PETSCII CHARACTERS**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The Commodore 64 extended ASCII differently from Unicode, into a now dead branch
    of evolution called PETSCII, by using the first digit as a “shift” character and
    defining a second set of ASCII-like symbols. It also defined new visual symbols
    in the unshifted sector in place of control codes, including the C64’s iconic
    playing card symbols and bitmap graphic elements used for drawing and shown here.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0262-02.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: '*Programming the C64*'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Programming the C64 is done in 6502 assembly as discussed in the “Programmer
    Interface” section on [page 255](ch11.xhtml#lev217), but with added interactions
    with the particular ROMs and I/O modules mounted in the address space. The ROMs
    contain libraries of Commodore’s own subroutines (known as “KERNAL,” with an A).
    I/O includes a memory-mapped screen display that can be switched between character
    and pixel modes. Character mode allows PETSCII characters to be drawn at screen
    locations by writing their codes directly into this memory space. The state of
    the keyboard can be read by reading its memory-mapped space, but ROM subroutines
    are provided to simplify this process and decode its state to PETSCII character
    codes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The following program illustrates these structures. It displays a scrolling
    message on a colored screen, and exits when the A key is pressed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This creates a scrolling text result, as in [Figure 11-10](ch11.xhtml#ch11fig10).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0264-01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-10: The hello C64 result. The text scrolls across the screen.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The program can be used as the starting point for writing a game, as it includes
    all of the basic game elements: a loop, display, keyboard read, and state update.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**CHIPTUNES**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In the 8-bit era, the sound chip was a genuine synthesizer, an actual musical
    instrument made in hardware and placed inside the computer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to generate tones is to use square waves. This is how a non-musician
    architect would go about building a sound chip, such as the Texas Instruments
    SN76489\. Square waves alternate at a given frequency (musical pitch) between
    a digital 0 and 1, so they can be made entirely from digital logic rather than
    requiring the analog voltages that would be needed to make other waveforms. Limiting
    chips to square waves gave devices of the era their characteristic, primitive
    8-bit sound.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: As Commodore had bought MOS, they used MOS’s latest tone generator, the 6581
    Sound Interface Device (SID), in the C64\. SID was far superior to previous sound
    chips. It was designed as a real musical instrument, by a musical synthesizer
    designer. It added analog sawtooth and sine waves into the mix, and revolutionized
    8-bit audio by adding analog filters to these waves. Filters emphasize or mute
    bands of harmonics in a musical signal. Both square and sawtooth waves have infinite
    harmonics, which provide good raw material for filters to act upon. Filters can
    be swept over notes in many different ways to create many effects, and this gave
    the C64 its large musical palette.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'SID contains the analog device and an I/O module that interfaces it to the
    address space, so it attaches to the bus. In the C64, it’s controlled by writing
    parameters such as frequencies, volumes, and filter cutoffs to its assigned address
    space, D400 to D7FF, as in the following example, which plays a square wave on
    channel 1:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After SID’s release, the great 8-bit “chiptune” composers such as Rob Hubbard
    found highly creative ways to hack it to play samples and to appear to have many
    more voices than the three it had in hardware. SID presented a limited and constrained
    palette, encouraging minimalist, mathematical aesthetics. Hubbard was influenced
    by Philip Glass, Jean-Michel Jarre, and Kraftwerk. More recently, music producers
    in the 2010s, such as Max Martin and Dr. Luke, have used SID for its retro gaming
    sound.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Motorola 68000 16-Bit CPU
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The 16-bit era is somewhat misnamed: it should have been the “16/32-bit era.”
    This is because the defining chip of the era was the Motorola 68000, used in the
    Commodore Amiga, Atari ST, Apple Macintosh, and Sega Megadrive, as well as in
    arcade machines such as *Street Fighter II*. The 68000 used 16-bit data words,
    but also had 32-bit registers and an ALU inside the CPU. The Atari ST’s name refers
    to this hybrid “*S*ixteen/*T*hirty-two” nature of the 68000\. Also known as the
    68k, the 68000 was released in 1979 and appeared in computers in the later 1980s
    to define the 16-bit era.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Both the 6502 and 68000 descended from the earlier Motorola 6800, in separate
    branches of evolution. Their names reflect this, and they share some structures
    and instructions. This means that learning the 68000 is often an extension of
    what we learned about the 6502\. If you’re unsure of how to do something in the
    68000, you can often make a good guess based on the 6502 equivalent.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '*Internal Subcomponents*'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 11-11](ch11.xhtml#ch11fig11) shows a die shot of the Motorola 68000\.
    In the figure, you can see the same basic structure as in the 6502, with the registers
    and ALU at the bottom, control logic in the center, and decoder near the top.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0266-01.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-11: A 68000 die shot*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the registers and ALU section now has more repeated rows due
    to having more than 8 bits. Unlike the 6502, the digital logic is now too small
    to see when the whole CPU is shown on a printed page.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: There are 16 user registers, all 32-bit, of which 8 are called D0 to D7 for
    “data registers,” and the others are called A0 to A7 for “address registers.”
    A7 is used as the stack pointer. There’s a 16-bit status register containing similar
    status bits to the 6502, and some extra information.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The bus has 16 data lines and 24 address lines. The addresses, however, refer
    to locations of bytes rather than 16-bit words, so there are 2^(24) addressable
    bytes, which is 16 M[2]B of addressable memory. The 24-bit addresses are written
    as six hex characters, such as DFF102[16].
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The 68000 has a two-stage pipeline that fetches the next instruction while simultaneously
    decoding and executing the current one.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '*Programmer Interface*'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we’ve done for other machines, having seen the structure of the 68000 we’ll
    now examine the instruction set that it enables—via memory access, arithmetic,
    and flow control—and that you can use to write your own programs. The 16-bit era
    saw a widespread shift from the use of upper- to lowercase characters in programming,
    which we’ll respect from here onward.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Movement**'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A single `move` instruction is used for load, store, and register data transfers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `l` here stands for “longword” and moves 32 bits at a time. This is fast
    between registers. When accessing memory, the 32 bits must be split up by the
    CPU and sent over the 16-bit bus in two steps, sequenced by the CU.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only want to move 16-bit words (`w`) or 8-bit bytes (`b`) around, you
    can use variants of `move`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Indirect addressing is specified using parentheses:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Offset addressing includes the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A more complicated and unusual 68000 addressing mode combines indirect addressing
    with register incrementation; this is useful for iterating over data stored in
    contiguous addresses:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For C programmers: this is roughly what `*(a++)` and `*(--a)` would compile
    into. Pushing and popping the stack doesn’t need dedicated instructions because
    it can be done using this mode with the stack pointer register:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Load effective addresses (`lea`) is a related 68000 instruction that can load
    the address of indirections. For example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that `lea` loads the numerical address itself, rather than the content
    of the address.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow Control**'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Due to their shared history, jumps, subroutines, and branches on the 68000
    are the same as on the 6502\. For example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That said, stack logic improved: with the 68000 you can push a series of arguments
    to the stack, make a jump to a subroutine, and pop them off from inside the subroutine.
    This allows subroutines to behave like functions with parameters.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic**'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are some examples of arithmetic instructions:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The addition and subtraction instructions are similar to those for the 6502\.
    But unlike the 6502, the 68000 can perform multiplication and division in hardware.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 16-Bit Computer Design with the Commodore Amiga
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Amiga* is the feminine of *amigo*, meaning *friend*, and Commodore’s 1985
    Amiga was intended to have that kind of relationship with its users. Early versions
    of the Amiga were intended as high-end graphics workstations and marketed to self-described
    “creatives”—the market now targeted by Apple. However, the now-classic A500 model
    rapidly became a standard mass-market gaming platform. This became self-fulfilling
    as both developer and gamer populations increased together. Growth was accelerated
    by the ease of (illegally) cracking and copying game disks, with bars in many
    towns around the world hosting “Amiga nights” where they were traded. In Europe,
    the Amiga was adopted by the “demo scene,” a subculture of artistic assembly programmers
    who met up to compete at pushing the graphics and sound to their limits, not in
    games but in multimedia demonstrations. These scenes overlapped, with crackers
    adding demos to the boot sequences of newly cracked games (those with the copy-protection
    removed). Commodore management ignored all this and tried to push the Amiga in
    the business market, where it and the company were destroyed by beige-box PCs.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the Architecture**'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The classic A500 had 0.5 M[2]B of RAM, though it and its successors were upgradable
    to a few mebibytes. (This was still much smaller than the 16 M[2]B addressable
    by the CPU.) [Figure 11-12](ch11.xhtml#ch11fig12) shows the A500 mainboard.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0270-01.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-12: An Amiga A500 mainboard*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The design was based around four large custom chips, given human names:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Agnus** This chip contained a coprocessor (“copper”) with its own separate
    RAM and bus, in addition to the main CPU system. The copper was responsible for
    graphics. Machine code for the copper could be written as data lines and sent
    to the copper as data by the main CPU program. (A similar system is used today
    in GPUs.) Agnus also contained a DMA-based “blitter,” used for copying sprites
    onto video RAM without CPU.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**Paula** This chip contained a sound device and its I/O module, as well as
    several other I/O modules, such as for disks and communications ports. It used
    DMA to read audio samples and other I/O data from RAM without CPU intervention.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Denise** This was the VDU chip, reading sprites and bitplanes from RAM, compositing
    them together under various screen modes, and outputting CRT display controls.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**Gary** This was a memory controller, translating and routing addresses from
    the bus to particular chips and addresses within them.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The A500 BIOS (called Kickstart) provides subroutines for accessing I/O, such
    as graphics and sound. It comes on a chip usually described as a ROM but that
    is more correctly considered an I/O module. This is because, unlike the C64 BIOS,
    these subroutines aren’t mounted into address space directly. Instead, they’re
    stored on a part of the chip that isn’t directly addressed. When a subset (library)
    of the subroutines is needed, a command is sent to the smaller, addressed part
    of the chip to copy them into a new location in RAM.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The whole computer was synchronized to the clock rate of the TV CRT scan display,
    meaning that it (and its games) ran at different speeds in the UK and US due to
    their different TV standards!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The Amiga was designed as a multimedia machine, and a fundamental requirement,
    especially for the 16-bit games of the time, was to quickly draw sprites—small
    images such as game characters—that are overlaid onto backgrounds to build up
    a scene.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: A naive method to draw sprites is to store a primary copy of the sprite at a
    fixed location in RAM, then write a subroutine in assembly language to copy each
    pixel one at a time to a parameterized location in video RAM. However, this is
    very slow because every pixel in the sprite then needs to be loaded into the CPU
    and written out again to video RAM in sequence.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: “Blitting” was a famous use of DMA in the Amiga copper to render sprites more
    efficiently. The copper could be commanded by the CPU to initiate a complete sprite
    “blit” by DMA. It would then read the sprite (or blitter object, “bob”) pixel
    by pixel from its location in regular RAM, and copy it into video RAM without
    any further CPU intervention.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: “Hardware sprites” were a second method, in which the primary copy of the sprite
    was loaded into the VDU at the start of a game. The VDU contained its own dedicated
    digital logic to implement similar blitting commands internally. There were severe
    memory limits inside the VDU, allowing only eight hardware sprites, which could
    often be used for the animation frames of a main character in a game or for the
    mouse pointer symbol.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: For backdrops of 2D games, “playfields” are another hardware acceleration, which
    allow backdrop images to be stored and scrolled around. Several can be overlaid
    with transparency masks to create parallax effects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming the Amiga**'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is a short program that displays a spaceship sprite on the screen:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the sprite is defined in the data segment at the end. Amiga programs tend
    to involve a lot of defining constants for use with the many complex ROM I/O subroutines
    used to call its graphics capabilities. In real life, library files would be included
    to make the most of these definitions, but they’re shown here in full as an illustration
    of a complete program.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of the result is shown in [Figure 11-13](ch11.xhtml#ch11fig13).
    Note that the sprite doesn’t yet move, but further commands could be added to
    create a game loop that repeatedly reads the keyboard, updates the sprite location,
    then does the drawing. In real games, sprites aren’t usually defined as data lines
    in assembly; rather, they’re drawn in the famous pixel art program *Deluxe Paint*,
    then loaded into similar memory areas from files.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0275-01.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-13: The Amiga sprite game result*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Retro Peripherals
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 8-bit and 16-bit eras introduced many peripherals that either are still
    with us today or have had strong influences on modern standards. Let’s look at
    some of the most important ones here to complete our study of retro computing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '*Cathode Ray Tube Displays*'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the Manchester Baby’s Williams tube, seen in the “Historical RAMs” box
    on [page 220](ch10.xhtml#page_220), wasn’t originally intended as a human display
    device, its programmers were quick to realize its potential for this use, and
    they soon began to write deliberately human-readable patterns to some parts of
    the screen as a form of output, with the rest of the screen storing internal data
    that appears as random patterns of on and off pixels. In recent decades, hackers
    have written simple retro arcade games to play on the Baby, displaying *Snake*
    and *Space Invaders* on parts of its Williams tube as the display.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: These green-on-black pixels are the origin of the later cathode ray tube (CRT)
    green screen, and then color monitors, used as human displays in the retro age,
    as seen in [Figure 1-31](ch01.xhtml#ch01fig31).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Programmers grew accustomed to the green color scheme, and in the 1980s often
    switched their RGB monitors into high-resolution green-on-black modes with a hardware
    switch to aid their concentration and familiarity. Some claimed that using only
    the green pixels improved the precision of the display, as the red and blue sub-pixels
    are some distance away from the green so tend to blur the pixel when used. Today,
    we still follow this tradition when we put our terminal emulators and text editors
    such as Vim into green-on-black mode. This classic programming scheme is celebrated
    in the stylized computer code in the movies *Ghost in the Shell* and *The Matrix*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: To reduce costs, home computers of the golden age were often designed to use
    consumer television CRTs as RGB monitors. To display to a CRT monitor or TV, an
    8-bit machine such as the C64 first needs to read the desired pixel values from
    video RAM, then arrange for them to be mapped onto the strength of the CRT beam
    as it periodically scans the columns and rows of the screen.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: CRT monitors produce complex visual halos around each pixel that blur into its
    neighbors, and pixel art for games of the time was optimized to work with this
    blurring, which looks completely unlike the result of playing retro games on a
    modern flat-screen monitor. The arcade game *Asteroids* exploited this effect
    to the extreme by turning up the brightness for the bullets to the maximum, resulting
    in the CRT ray functioning as a kind of death ray firing right into the player’s
    eyes—an effect that’s impossible to capture in emulation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '*User Input*'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Keyboards in the retro age were typically memory-mapped, with each key wired
    directly to an address in memory space to look like RAM. There would be a group
    of addresses together, each mapped to a key, and by loading from one you could
    determine if the key was up or down.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: A mouse of the retro era is shown in [Figure 11-14](ch11.xhtml#ch11fig14).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0276-01.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-14: A ball mouse teardown*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Mice like the one in [Figure 11-14](ch11.xhtml#ch11fig14) work by physically
    rolling a thumb-sized rubber ball over your desk, which in turn spins two roller
    sensors detecting its horizontal and vertical rotations. The sensors convert the
    rotations into analog then digital signals to send down the wire to your computer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '*Serial Port*'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The serial port was, and still is, a simple communications protocol (formally
    the RS232 standard) found on retro machines but still very relevant in embedded
    systems today. The core of a serial port is two wires, called RX and TX, which
    stand for *receive* and *transmit*, respectively. These use digital voltages over
    time to transmit 0s and 1s, so there’s one wire sending information one way and
    another wire sending information the other way. A historical serial port has many
    other wires as well, as in the old days they were used as controls for many things,
    but nowadays we tend to use only RX and TX. Serial port connectors still have
    extra, mostly unused, pins from this history, as shown in [Figure 11-15](ch11.xhtml#ch11fig15).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0277-01.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-15: A traditional serial port connector*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Serial ports can run at different speeds. They may also use different conventions
    for error checking, which can add extra redundant bits, and for *stop bits*, which
    show where the boundaries of characters lie in the stream of 0s and 1s. You have
    to make sure the device at one end of the wire is using the same speed and conventions
    as the device at the other end of the wire.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '*MIDI Interfaces*'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*MIDI (Musical Instrument Device Interface*, as seen in [Figure 11-16](ch11.xhtml#ch11fig16))
    has been the standard bus for musical keyboards, synthesizers, samplers, and 1980s
    keytars to communicate real-time, symbolic musical input and output since its
    standardization in 1983\. It’s an early example of a bus hierarchy, in which an
    optional MIDI interface could be connected to the main bus; it also provides a
    secondary MIDI bus for multiple musical devices to communicate along.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0277-02.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-16: A MIDI connector*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: MIDI connections are composed of a pair of unidirectional buses. One is for
    the manager to send messages to devices, and the other is for devices to send
    messages to the manager. They’re buses in the sense that all devices use the same
    physical wires and can see all the messages on these wires, and so the devices
    must look out for which messages are addressed to them to read, and act on only
    those.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Each direction’s bus has its own connector and runs on three physical wires.
    (In fact, a standard MIDI connector has five pins, with two spare to help with
    related work such as supplying “phantom” power to devices.) One wire is 5 V, one
    is ground, and one is UART (universal asynchronous receiver-transmitter) data.
    The bus nature of the wire from the manager to the devices is seen in the MIDI
    specification that all devices have three sockets: “in,” “out,” and “thru,” where
    “thru” relays all “in” messages to the next device in a daisy-chain wiring scheme;
    other hardware adapters can merge the “out” messages from several devices onto
    a single wire, which is a rarer thing to want to do. As a 1980s standard, all
    messages are 8-bit words (known as “MIDI bytes”), transmitted similarly to a serial
    port connection at a standard rate of 31.25Kbps.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: MIDI, including recent extensions in MIDI 2.0, is still with us today.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For readers of a certain age, understanding and programming golden age machines
    can be a beautiful way to relive their youth and understand what was really going
    on inside their old machines. But for everyone else, these machines are still
    valuable to study because they bridge the gap between the simplest electronic
    computers, such as the Baby, and what you actually have on your desk and in your
    pocket today. Those modern machines have many more features that can be overwhelming,
    so by practicing on older machines of increasing power, you can build your confidence.
    To this end, this chapter studied an 8-bit system, the Commodore 64, and a 16-bit
    system, the Commodore Amiga. The two are related through their CPUs’ common ancestry,
    meaning they share some instructions and styles. Many of the ideas introduced
    by these classic systems are still in use today, as we will see in the next chapters.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**6502 Programming**'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Easy6502 is an open source 6502 emulator that runs in your browser. It’s written
    in JavaScript by Nick Morgan, the author of *JavaScript for Kids* and *JavaScript
    Crash Course*, also available from No Starch Press. Download Easy6502 with:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Open the downloaded *emulator.html* in your browser to run Easy6502\. Then enter
    and run the sample 6502 programs from this chapter. The emulator shows the content
    of the registers on the right.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try writing a 16-bit multiplication subroutine in 6502 assembly using Easy6502.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nick’s own tutorial can be found in the downloaded *tutorial.html*. This gives
    many more 6502 programming details and builds up to writing a retro *Snake*-type
    game. Try to learn enough to understand how this game works, then try to modify
    it in some way, either to change the rules of the game or to transform it into
    another retro game such as *Space Invaders* or *Tetris*. Code built in this emulator
    can be ported to the C64 or other 6502-based machines, with some extra work to
    replace the graphics and I/O with calls to their specific designs.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**C64 Programming**'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Nowadays, we can do C64 programming and assembling on a modern machine, then
    just run the resulting executable machine code on a C64 emulator, such as the
    open source VICE emulator, which can be installed locally. To get started, install
    the Dasm assembler from *[https://dasm-assembler.github.io](https://dasm-assembler.github.io)*.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put your assembly code in a file such as *hello.asm*. Dasm requires the following
    two lines to be added to the start of the file to tell it to generate an executable
    for the C64 rather than other machines. They must have exactly eight spaces of
    indent:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Assemble your code into a C64 program (*.prg*) with:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The *.prg* file can be imported into a C64 emulator, such as the online JavaScript-based
    emulator at *[https://c64emulator.111mb.de](https://c64emulator.111mb.de)*, or
    VICE. (For SID programs: some emulators, such as the JavaScript one mentioned
    here, have sound disabled by default, so you need to turn it on.)'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’re lucky enough to have access to a real physical C64 and tape drive,
    you can also try converting your *.prg* files to tape images (*.tap*) and then
    sound waves (*.wav*) using a program such as *tap2wav.py* available at *[https://github.com/Zibri/C64](https://github.com/Zibri/C64)*.
    Then record the *.wav* to a physical tape to load to the read machine. Try inspecting
    the *.tap* and *.wav* files to see the 0s and 1s along the way.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Programming a Sprite-Based Game on the Amiga**'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Assemble and run the spaceship code shown in the “Programming the Amiga” section
    on [page 271](ch11.xhtml#ch11lev2sec1) as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the vasm cross-assembler from *[http://sun.hasenbraten.de/vasm](http://sun.hasenbraten.de/vasm)*.
    Build it in Amiga mode with:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use vasm to assemble your assembly program with:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Install *amitools* for Python from *[https://pypi.org/project/amitools/](https://pypi.org/project/amitools/)*.
    Create a disk image and write the file to it, and make the disk image bootable
    with:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Download and install the FS-UAE Amiga emulator from *[https://fs-uae.net/download](https://fs-uae.net/download)*.
    Run it and boot from your virtual *mydisk.adf* disk image.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**More Challenging**'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Research how to read the Amiga keyboard or joystick, then extend the spaceship
    example into a simple game using the keyboard to move the sprite around. Research
    how to add double buffering to remove the flicker as the screen is redrawn during
    the loop.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building your own 6502-based computer has recently become a popular hobby. Take
    a look around YouTube and *[https://hackaday.com](https://hackaday.com)* to find
    examples of “6502 breadboard computers” and learn how they are made. You might
    try doing a rebuild of one of these existing designs, or making your own design.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To read the book that taught a generation of 8-bit programmer kids, see Lisa
    Watts and Mike Wharton, *Usborne Introduction to Machine Code for Beginners* (London:
    Usborne, 1983). The book is now freely available online at *[https://archive.org/details/machine-code-for-beginners](https://archive.org/details/machine-code-for-beginners)*.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a guided tour of the C64 system from 1983, see J. Butterfield, ed., “Commodore
    64 Architecture,” *Computer!* 32 (January 1983): 208, *[https://www.atarimagazines.com/compute/issue32/112_1_COMMODORE_64_ARCHITECTURE.php](https://www.atarimagazines.com/compute/issue32/112_1_COMMODORE_64_ARCHITECTURE.php)*.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For information on 8 bit–era audio programming, see James Vogel and Nevin Scrimshaw,
    *The Commodore 64 Music Book* (Boston: Birkhauser, 1983), *[https://archive.org/details/The_Commodore_64_Music_Book/page/n3/mode/2up](https://archive.org/details/The_Commodore_64_Music_Book/page/n3/mode/2up)*.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See *[https://github.com/emu-russia/breaks](https://github.com/emu-russia/breaks)*
    for a 6502 and NES rebuild in LogiSim.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
