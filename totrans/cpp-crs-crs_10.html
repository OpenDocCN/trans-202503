<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_210"/><span epub:type="pagebreak" id="page_211"/><strong><span class="big">8</span><br/>STATEMENTS</strong></h2>&#13;
<p class="quote"><em>Progress doesn’t come from early risers—progress is made by lazy men looking for easier ways to do things.<br/>—Robert A. Heinlein</em>, Time Enough for Love</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">Each C++ function comprises a sequence of <em>statements</em>, which are programming constructs that specify the order of execution. This chapter uses an understanding of the object life cycle, templates, and expressions to explore the nuances of statements.</p>&#13;
<h3 class="h3" id="ch08lev1sec1"><strong>Expression Statements</strong></h3>&#13;
<p class="noindent">An <em>expression statement</em> is an expression followed by a semicolon (<code>;</code>). Expression statements comprise most of the statements in a program. You can turn any expression into a statement, which you should do whenever you need to evaluate an expression but want to discard the result. Of course, this is only useful if evaluating that expression causes a side effect, like printing to the console or modifying the program’s state.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_212"/><a href="ch08.xhtml#ch08ex01">Listing 8-1</a> contains several expression statements.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  int x{};&#13;
  ++x; <span class="ent">➊</span>&#13;
  42; <span class="ent">➋</span>&#13;
  printf("The %d True Morty\n", x); <span class="ent">➌</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The 1 True Morty <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch08ex01"/><em>Listing 8-1: A simple program containing several expression statements</em></p>&#13;
<p class="indent">The expression statement at <span class="ent">➊</span> has a side effect (incrementing <code>x</code>), but the one at <span class="ent">➋</span> doesn’t. Both are valid (although the one at <span class="ent">➋</span> isn’t useful). The function call to <code>printf</code> <span class="ent">➌</span> is also an expression statement.</p>&#13;
<h3 class="h3" id="ch08lev1sec2"><strong>Compound Statements</strong></h3>&#13;
<p class="indent"><em>Compound statements</em>, also called <em>blocks</em>, are a sequence of statements enclosed by braces <code>{ }</code>. Blocks are useful in control structures like <code>if</code> statements, because you might want multiple statements to execute rather than one.</p>&#13;
<p class="indent">Each block declares a new scope, which is called a <em>block scope</em>. As you learned in <a href="ch04.xhtml#ch04">Chapter 4</a>, objects with automatic storage duration declared within a block scope have lifetimes bound by the block. Variables declared within a block get destroyed in a well-defined order: the reverse of the order in which they were declared.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex02">Listing 8-2</a> uses the trusty <code>Tracer</code> class from <a href="ch04.xhtml#ch04ex05">Listing 4-5</a> (on <a href="ch04.xhtml#page_97">page 97</a>) to explore block scope.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Tracer {&#13;
  Tracer(const char* name) : name{ name } {&#13;
    printf("%s constructed.\n", name);&#13;
  }&#13;
  ~Tracer() {&#13;
    printf("%s destructed.\n", name);&#13;
  }&#13;
private:&#13;
  const char* const name;&#13;
};&#13;
&#13;
int main() {&#13;
  Tracer main{ "main" }; <span class="ent">➊</span>&#13;
  {&#13;
    printf("Block a\n"); <span class="ent">➋</span>&#13;
    Tracer a1{ "a1" }; <span class="ent">➌</span>&#13;
    Tracer a2{ "a2" }; <span class="ent">➍</span>&#13;
<span epub:type="pagebreak" id="page_213"/>  }&#13;
  {&#13;
    printf("Block b\n"); <span class="ent">➎</span>&#13;
    Tracer b1{ "b1" }; <span class="ent">➏</span>&#13;
    Tracer b<a id="_idTextAnchor390"/>2{ "b2" }; <span class="ent">➐</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">main constructed. <span class="ent">➊</span></span>&#13;
<span class="color1">Block a <span class="ent">➋</span></span>&#13;
<span class="color1">a1 constructed. <span class="ent">➌</span></span>&#13;
<span class="color1">a2 constructed.<span class="ent">➍</span></span>&#13;
<span class="color1">a2 destructed.</span>&#13;
<span class="color1">a1 destructed.</span>&#13;
<span class="color1">Block b <span class="ent">➎</span></span>&#13;
<span class="color1">b1 constructed. <span class="ent">➏</span></span>&#13;
<span class="color1">b2 constructed. <span class="ent">➐</span></span>&#13;
<span class="color1">b2 destructed.</span>&#13;
<span class="color1">b1 destructed.</span>&#13;
<span class="color1">main destructed.</span></pre>&#13;
<p class="listing"><a id="ch08ex02"/><em>Listing 8-2: A program exploring compound statements with the <code>Tracer</code> class</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex02">Listing 8-2</a> begins by initializing a <code>Tracer</code> called <code>main</code> <span class="ent">➊</span>. Next, you generate two compound statements. The first compound statement begins with a left brace <code>{</code> followed by the block’s first statement, which prints <code>Block a</code> <span class="ent">➋</span>. You create two <code>Tracers</code>, <code>a1</code> <span class="ent">➌</span> and <code>a2</code> <span class="ent">➍</span>, and then close the block with a right brace <code>}</code>. These two tracers get destructed once execution passes through <code>Block a</code>. Notice that these two tracers destruct in reverse order from their initialization: <code>a2</code> then <code>a1</code>.</p>&#13;
<p class="indent">Also notice another compound statement following <code>Block a</code>, where you print <code>Block b</code> <span class="ent">➎</span> and then construct two tracers, <code>b1</code> <span class="ent">➏</span> and <code>b2</code> <span class="ent">➐</span>. Its behavior is identical: <code>b2</code> destructs followed by <code>b1</code>. Once execution passes through <code>Block b</code>, the scope of <code>main</code> ends and <code>Tracer main</code> finally destructs.</p>&#13;
<h3 class="h3" id="ch08lev1sec3"><strong>Declaration Statements</strong></h3>&#13;
<p class="noindent"><em>Declaration statements</em> (or just <em>declarations</em>) introduce identifiers, such as functions, templates, and namespaces, into your programs. This section explores some new features of these familiar declarations, as well as type aliases, attributes, and structured bindings.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The expression <code>static_assert</code>, which you learned about in <a href="ch06.xhtml#ch06">Chapter 6</a>, is also a declaration statement.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec1"><strong><em>Functions</em></strong></h4>&#13;
<p class="noindent">A <em>function declaration</em>, also called the function’s <em>signature</em> or <em>prototype</em>, specifies a function’s inputs and outputs. The declaration doesn’t need to include <span epub:type="pagebreak" id="page_214"/>parameter names, only their types. For example, the following line declares a function called <code>randomize</code> that takes a <code>uint32_t</code> reference and returns <code>void</code>:</p>&#13;
<pre>void randomize(uint32_t&amp;);</pre>&#13;
<p class="indent">Functions that aren’t member functions are called <em>non-member functions</em>, or sometimes <em>free functions</em>, and they’re always declared outside of <code>main()</code> at namespace scope. A <em>function definition</em> includes the function declaration as well as the function’s body. A function’s declaration defines a function’s interface, whereas a function’s definition defines its implementation. For example, the following definition is one possible implementation of the <code>ran</code><code>domize</code> function:</p>&#13;
<pre>void randomize(uint32_t&amp; x) {&#13;
  x = 0x3FFFFFFF &amp; (0x41C64E6D * x + 12345) % 0x80000000;&#13;
}</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This <code>randomize</code> implementation is a linear congruential generator, a primitive kind of random number generator. See “Further Reading” on <a href="ch08.xhtml#page_241">page 241</a> for sources of more information on generating random numbers.</em></p>&#13;
</div>&#13;
<p class="indent">As you’ve probably noticed, function declarations are optional. So why do they exist?</p>&#13;
<p class="indent">The answer is that you can use declared functions throughout your code as long as they’re eventually defined somewhere. Your compiler tool chain can figure it out. (You’ll learn how this works in <a href="ch21.xhtml#ch21">Chapter 21</a>.)</p>&#13;
<p class="indent">The program in <a href="ch08.xhtml#ch08ex03">Listing 8-3</a> determines how many iterations the random number generator takes to get from the number 0x4c4347 to the number 0x474343.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
void randomize(uint32_t&amp;); <span class="ent">➊</span>&#13;
&#13;
int main() {&#13;
  size_t iterations{}; <span class="ent">➋</span>&#13;
  uint32_t number{ 0x4c4347 }; <span class="ent">➌</span>&#13;
  while (number != 0x474343) { <span class="ent">➍</span>&#13;
    randomize(number); <span class="ent">➎</span>&#13;
    ++iterations; <span class="ent">➏</span>&#13;
  }&#13;
  printf("%zu", iterations); <span class="ent">➐</span>&#13;
}&#13;
&#13;
void randomize(uint32_t&amp; x) {&#13;
  x = 0x3FFFFFFF &amp; (0x41C64E6D * x + 12345) % 0x80000000; <span class="ent">➑</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1"><span epub:type="pagebreak" id="page_215"/>927393188 <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch08ex03"/><em>Listing 8-3: A program that uses a function in <code>main</code> that isn’t defined until later</em></p>&#13;
<p class="indent">First, you declare <code>randomize</code> <span class="ent">➊</span>. Within <code>main</code>, you initialize an <code>iterations</code> counter variable to zero <span class="ent">➋</span> and a <code>number</code> variable to 0x4c4347 <span class="ent">➌</span>. A <code>while</code> loop checks whether <code>number</code> equals the target 0x4c4347 <span class="ent">➍</span>. If it doesn’t, you invoke <code>randomize</code> <span class="ent">➎</span> and increment <code>iterations</code> <span class="ent">➏</span>. Notice that you haven’t yet defined <code>randomize</code>. Once <code>number</code> equals the target, you print the number of <code>iterations</code> <span class="ent">➐</span> before returning from <code>main</code>. Finally, you define <code>randomize</code> <span class="ent">➑</span>. The program’s output shows that it takes almost a billion iterations to randomly draw the target value.</p>&#13;
<p class="indent">Try to delete the definition of <code>randomize</code> and recompile. You should get an error stating that the definition of <code>randomize</code> couldn’t be found.</p>&#13;
<p class="indent">You can similarly separate method declarations from their definitions. As with non-member functions, you can declare a method by omitting its body. For example, the following <code>RandomNumberGenerator</code> class replaces the <code>ran</code><code>domize</code> function with <code>next</code>:</p>&#13;
<pre>struct RandomNumberGenerator {&#13;
  explicit RandomNumberGenerator(uint32_t seed) <span class="ent">➊</span>&#13;
    : number{ seed } {} <span class="ent">➋</span>&#13;
  uint32_t next(); <span class="ent">➌</span>&#13;
private:&#13;
  uint32_t number;&#13;
};</pre>&#13;
<p class="indent">You can construct a <code>RandomNumberGenerator</code> with a <code>seed</code> value <span class="ent">➊</span>, which it uses to initialize the <code>number</code> member variable <span class="ent">➋</span>. You’ve declared the <code>next</code> function using the same rules as non-member functions <span class="ent">➌</span>. To provide the definition of <code>next</code>, you must use the scope resolution operator and the class name to identify which method you want to define. Otherwise, defining a method is the same as defining a non-member function:</p>&#13;
<pre>uint32_t<span class="ent">➊</span> RandomNumberGenerator::<span class="ent">➋</span>next() {&#13;
  number = 0x3FFFFFFF &amp; (0x41C64E6D * number + 12345) % 0x80000000; <span class="ent">➌</span>&#13;
  return number; <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">This definition shares the same return type as the declaration <span class="ent">➊</span>. The <code>RandomNumberGenerator::</code> construct specifies that you’re defining a method <span class="ent">➋</span>. The function details are essentially the same <span class="ent">➌</span>, except you’re returning a copy of the random number generator’s state rather than writing into a parameter reference <span class="ent">➍</span>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex04">Listing 8-4</a> illustrates how you can refactor <a href="ch08.xhtml#ch08ex03">Listing 8-3</a> to incorporate <code>RandomNumberGenerator</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
<span epub:type="pagebreak" id="page_216"/>struct RandomNumberGenerator {&#13;
  explicit RandomNumberGenerator(uint32_t seed)&#13;
    : iterations{}<span class="ent">➊</span>, number { seed }<span class="ent">➋</span> {}&#13;
  uint32_t next(); <span class="ent">➌</span>&#13;
  size_t get_iterations() const; <span class="ent">➍</span>&#13;
private:&#13;
  size_t iterations;&#13;
  uint32_t number;&#13;
};&#13;
&#13;
int main() {&#13;
  RandomNumberGenerator rng{ 0x4c4347 }; <span class="ent">➎</span>&#13;
  while (rng.next() != 0x474343) { <span class="ent">➏</span>&#13;
    // Do nothing...&#13;
  }&#13;
  printf("%zu", rng.get_iterations()); <span class="ent">➐</span>&#13;
}&#13;
&#13;
uint32_t RandomNumberGenerator::next() { <span class="ent">➑</span>&#13;
  ++iterations;&#13;
  number = 0x3FFFFFFF &amp; (0x41C64E6D * number + 12345) % 0x80000000;&#13;
  return number;&#13;
}&#13;
&#13;
size_t RandomNumberGenerator::get_iterations() const { <span class="ent">➒</span>&#13;
  return iterations;&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">927393188 <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch08ex04"/><em>Listing 8-4: A refactor of <a href="ch08.xhtml#ch08ex03">Listing 8-3</a> using a <code>RandomNumberGenerator</code> class</em></p>&#13;
<p class="indent">As in <a href="ch08.xhtml#ch08ex03">Listing 8-3</a>, you’ve separated declaration from definition. After declaring a constructor that initializes an <code>iterations</code> member to zero <span class="ent">➊</span> and sets its <code>number</code> member to a <code>seed</code> <span class="ent">➋</span>, the <code>next</code> <span class="ent">➌</span> and <code>get_iterations</code> <span class="ent">➍</span> method declarations don’t contain implementations. Within <code>main</code>, you initialize the <code>RandomNumberGenerator</code> class with your seed value of 0x4c4347 <span class="ent">➎</span> and invoke the <code>next</code> method to extract new random numbers <span class="ent">➏</span>. The results are the same <span class="ent">➐</span>. As before, the definitions of <code>next</code> and <code>get_iterations</code> follow their use in <code>main</code> <span class="ent">➑➒</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The utility of separating definition and declaration might not be apparent because you’ve been dealing with single-source-file programs so far. <a href="ch21.xhtml#ch21">Chapter 21</a> explores multiple-source-file programs where separating declaration and definition provides major benefits.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec2"><strong><em>Namespaces</em></strong></h4>&#13;
<p class="noindent">Namespaces prevent naming conflicts. In large projects or when importing libraries, namespaces are essential for disambiguating exactly the symbols you’re looking for.</p>&#13;
<h5 class="h5" id="ch08lev3sec1"><strong><span epub:type="pagebreak" id="page_217"/>Placing Symbols Within Namespaces</strong></h5>&#13;
<p class="noindent">By default, all symbols you declare go into the <em>global namespace</em>. The global namespace contains all the symbols that you can access without adding any namespace qualifiers. Aside from several classes in the <code>std</code> namespace, you’ve been using objects living exclusively in the global namespace.</p>&#13;
<p class="indent">To place a symbol within a namespace other than the global namespace, you declare the symbol within a <em>namespace block</em>. A namespace block has the following form:</p>&#13;
<pre>namespace BroopKidron13 {&#13;
  // All symbols declared within this block&#13;
  // belong to the BroopKidron13 namespace&#13;
}</pre>&#13;
<p class="indent">Namespaces can be nested in one of two ways. First, you can simply nest namespace blocks:</p>&#13;
<pre>namespace BroopKidron13 {&#13;
  namespace Shaltanac {&#13;
    // All symbols declared within this block&#13;
    // belong to the BroopKidron13::Shaltanac namespace&#13;
  }&#13;
}</pre>&#13;
<p class="indent">Second, you can use the scope-resolution operator:</p>&#13;
<pre>namespace BroopKidron13::Shaltanac {&#13;
  // All symbols declared within this block&#13;
  // belong to the BroopKidron13::Shaltanac namespace&#13;
}</pre>&#13;
<p class="indent">The latter approach is more succinct.</p>&#13;
<h5 class="h5" id="ch08lev3sec2"><strong>Using Symbols in Namespaces</strong></h5>&#13;
<p class="noindent">To use a symbol within a namespace, you can always use the scope-resolution operator to specify the fully qualified name of a symbol. This allows you to prevent naming conflicts in large projects or when you’re using a third-party library. If you and another programmer use the same symbol, you can avoid ambiguity by placing the symbol within a namespace.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex05">Listing 8-5</a> illustrates how you can use fully qualified symbol names to access a symbol within a namespace.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
namespace BroopKidron13::Shaltanac { <span class="ent">➊</span>&#13;
  enum class Color { <span class="ent">➋</span>&#13;
    Mauve,&#13;
    Pink,&#13;
    Russet&#13;
<span epub:type="pagebreak" id="page_218"/>  };&#13;
}&#13;
&#13;
int main() {&#13;
  const auto shaltanac_grass{ BroopKidron13::Shaltanac::Color::Russet<span class="ent">➌</span> };&#13;
  if(shaltanac_grass == BroopKidron13::Shaltanac::Color::Russet) {&#13;
    printf("The other Shaltanac's joopleberry shrub is always "&#13;
           "a more mauvey shade of pinky russet.");&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The other Shaltanac's joopleberry shrub is always a more mauvey shade of pinky russet.</span></pre>&#13;
<p class="listing"><a id="ch08ex05"/><em>Listing 8-5: Nested namespace blocks using the scope-resolution operator</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex05">Listing 8-5</a> uses nested namespaces <span class="ent">➊</span> and declares a <code>Color</code> type <span class="ent">➋</span>. To use <code>Color</code>, you apply the scope-resolution operator to specify the full name of the symbol, <code>BroopKidron13::Shaltanac::Color</code>. Because <code>Color</code> is an <code>enum class</code>, you use the scope-resolution operator to access its values, as when you assign <code>shaltanac_grass</code> to <code>Russet</code> <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch08lev3sec3"><strong>Using Directives</strong></h5>&#13;
<p class="noindent">You can employ a <code>using</code> <em>directive</em> to avoid a lot of typing. A <code>using</code> directive imports a symbol into a block or, if you declare a <code>using</code> directive at namespace scope, into the current namespace. Either way, you have to type the full namespace path only once. The usage has the following pattern:</p>&#13;
<pre>using <span class="codeitalic1">my-type</span>;</pre>&#13;
<p class="indent">The corresponding <span class="codeitalic">my-type</span> gets imported into the current namespace or block, meaning you no longer have to use its full name. <a href="ch08.xhtml#ch08ex06">Listing 8-6</a> refactors <a href="ch08.xhtml#ch08ex05">Listing 8-5</a> with a using directive.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
namespace BroopKidron13::Shaltanac {&#13;
  enum class Color {&#13;
    Mauve,&#13;
    Pink,&#13;
    Russet&#13;
  };&#13;
}&#13;
&#13;
int main() {&#13;
  using BroopKidron13::Shaltanac::Color; <span class="ent">➊</span>&#13;
  const auto shaltanac_grass = Color::Russet<span class="ent">➋</span>;&#13;
  if(shaltanac_grass == Color::Russet<span class="ent">➌</span>) {&#13;
    printf("The other Shaltanac's joopleberry shrub is always "&#13;
           "a more mauvey shade of pinky russet.");&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1"><span epub:type="pagebreak" id="page_219"/>The other Shaltanac's joopleberry shrub is always a more mauvey shade of pinky russet.</span></pre>&#13;
<p class="listing"><a id="ch08ex06"/><em>Listing 8-6: A refactor of <a href="ch08.xhtml#ch08ex05">Listing 8-5</a> employing a using directive</em></p>&#13;
<p class="indent">With a <code>using</code> directive <span class="ent">➊</span> within <code>main</code>, you no longer have to type the namespace <code>BroopKidron13::Shaltanac</code> to use <code>Color</code> <span class="ent">➋</span><span class="ent">➌</span>.</p>&#13;
<p class="indent">If you’re careful, you can introduce all the symbols from a given namespace into the global namespace with the <code>using namespace</code> directive.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex07">Listing 8-7</a> elaborates <a href="ch08.xhtml#ch08ex06">Listing 8-6</a>: the namespace <code>BroopKidron13::Shaltanac</code> contains multiple symbols, which you want to import into the global namespace to avoid a lot of typing.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
namespace BroopKidron13::Shaltanac {&#13;
  enum class Color {&#13;
    Mauve,&#13;
    Pink,&#13;
    Russet&#13;
  };&#13;
&#13;
  struct JoopleberryShrub {&#13;
    const char* name;&#13;
    Color shade;&#13;
  };&#13;
&#13;
  bool is_more_mauvey(const JoopleberryShrub&amp; shrub) {&#13;
    return shrub.shade == Color::Mauve;&#13;
  }&#13;
}&#13;
&#13;
using namespace BroopKidron13::Shaltanac; <span class="ent">➊</span>&#13;
int main() {&#13;
  const JoopleberryShrub<span class="ent">➋</span> yours{&#13;
    "The other Shaltanac",&#13;
    Color::Mauve<span class="ent">➌</span>&#13;
  };&#13;
&#13;
  if (is_more_mauvey(yours)<span class="ent">➍</span>) {&#13;
    printf("%s's joopleberry shrub is always a more mauvey shade of pinky"&#13;
           "russet.", yours.name);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The other Shaltanac's joopleberry shrub is always a more mauvey shade of pinky&#13;
russet.</span></pre>&#13;
<p class="listing"><a id="ch08ex07"/><em>Listing 8-7: A refactor of <a href="ch08.xhtml#ch08ex06">Listing 8-6</a> with multiple symbols imported into the global namespace</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_220"/>With a <code>using namespace</code> directive <span class="ent">➊</span>, you can use classes <span class="ent">➋</span>, enum classes <span class="ent">➌</span>, functions <span class="ent">➍</span>, and so on within your program without having to type fully qualified names. Of course, you need to be very careful about clobbering existing types in the global namespace. Usually, it’s a bad idea to have too many <code>using namespace</code> directives appear in a single translation unit.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You should never put a <span class="codeitalic">using namespace</span> directive within a header file. Every source file that includes your header will dump all the symbols from that using directive into the global namespace. This can cause issues that are very difficult to debug.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec3"><strong><em>Type Aliasing</em></strong></h4>&#13;
<p class="indent">A <em>type alias</em> defines a name that refers to a previously defined name. You can use a type alias as a synonym for the existing type name.</p>&#13;
<p class="indent">There is no difference between a type and any type aliases referring to it. Also, type aliases cannot change the meaning of an existing type name.</p>&#13;
<p class="indent">To declare a type alias, you use the following format, where <span class="codeitalic">type-alias</span> is the type alias name and <span class="codeitalic">type-id</span> is the target type:</p>&#13;
<pre>using <span class="codeitalic1">type-alias</span> = <span class="codeitalic1">type-id</span>;</pre>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex08">Listing 8-8</a> employs two type aliases, <code>String</code> and <code>ShaltanacColor</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
namespace BroopKidron13::Shaltanac {&#13;
  enum class Color {&#13;
    Mauve,&#13;
    Pink,&#13;
    Russet&#13;
  };&#13;
}&#13;
&#13;
using String = const char[260]; <span class="ent">➊</span>&#13;
using ShaltanacColor = BroopKidron13::Shaltanac::Color; <span class="ent">➋</span>&#13;
&#13;
int main() {&#13;
  const auto my_color{ ShaltanacColor::Russet }; <span class="ent">➌</span>&#13;
  String saying { <span class="ent">➍</span>&#13;
    "The other Shaltanac's joopleberry shrub is "&#13;
    "always a more mauvey shade of pinky ru<a id="_idTextAnchor393"/>sset."&#13;
  };&#13;
  if (my_color == ShaltanacColor::Russet) {&#13;
    printf("%s", saying);&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch08ex08"/><em>Listing 8-8: A refactor of <a href="ch08.xhtml#ch08ex07">Listing 8-7</a> with a type alias</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex08">Listing 8-8</a> declares a type alias <code>String</code> that refers to a <code>const char[260]</code> <span class="ent">➊</span>. This listing also declares a <code>ShaltanacColor</code> type alias, which refers to <span epub:type="pagebreak" id="page_221"/><code>BroopKidron13::Shaltanac::Color</code> <span class="ent">➋</span>. You can use these type aliases as drop-in replacements to clean up code. Within <code>main</code>, you use <code>ShaltanacColor</code> to remove all the nested namespaces <span class="ent">➌</span> and <code>String</code> to make the declaration of <code>saying</code> cleaner <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Type aliases can appear in any scope—block, class, or namespace.</em></p>&#13;
</div>&#13;
<p class="indent">You can introduce template parameters into type aliases. This enables two important usages:</p>&#13;
<ul>&#13;
<li class="noindent">You can perform partial application on template parameters. <em>Partial application</em> is the process of fixing some number of arguments to a template, producing another template with fewer template parameters.</li>&#13;
<li class="noindent">You can define a type alias for a template with a fully specified set of template parameters.</li>&#13;
</ul>&#13;
<p class="indent">Template instantiations can be quite verbose, and type aliases help you avoid carpal tunnel syndrome.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex09">Listing 8-9</a> declares a <code>NarrowCaster</code> class with two template parameters. You then use a type alias to partially apply one of its parameters and produce a new type.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
template &lt;typename To, typename From&gt;&#13;
struct NarrowCaster const { <span class="ent">➊</span>&#13;
  To cast(From value) {&#13;
    const auto converted = static_cast&lt;To&gt;(value);&#13;
    const auto backwards = static_cast&lt;From&gt;(converted);&#13;
    if (value != backwards) throw std::runtime_error{ "Narrowed!" };&#13;
    return converted;&#13;
  }&#13;
};&#13;
&#13;
template &lt;typename From&gt;&#13;
using short_caster = NarrowCaster&lt;short, From&gt;; <span class="ent">➋</span>&#13;
&#13;
int main() {&#13;
  try {&#13;
    const short_caster&lt;int&gt; caster; <span class="ent">➌</span>&#13;
    const auto cyclic_short = caster.cast(142857);&#13;
    printf("cyclic_short: %d\n", cyclic_short);&#13;
  } catch (const std::runtime_error&amp; e) {&#13;
    printf("Exception: %s\n", e.what()); <span class="ent">➍</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Exception: Narrowed! <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch08ex09"/><em>Listing 8-9: A partial application of the <code>NarrowCaster</code> class using a type alias</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_222"/>First, you implement a <code>NarrowCaster</code> template class that has the same functionality as the <code>narrow_cast</code> function template in <a href="ch06.xhtml#ch06ex06">Listing 6-6</a> (on <a href="ch06.xhtml#page_154">page 154</a>): it will perform a <code>static_cast</code> and then check for narrowing <span class="ent">➊</span>. Next, you declare a type alias <code>short_caster</code> that partially applies <code>short</code> as the <code>To</code> type to <code>NarrowCast</code>. Within <code>main</code>, you declare a <code>caster</code> object of type <code>short_caster&lt;int&gt;</code> <span class="ent">➌</span>. The single template parameter in the <code>short_caster</code> type alias gets applied to the remaining type parameter from the type alias—<code>From</code> <span class="ent">➋</span>. In other words, the type <code>short_cast&lt;int&gt;</code> is synonymous with <code>NarrowCaster&lt;short, int&gt;</code>. In the end, the result is the same: with a 2-byte short, you get a narrowing exception when trying to cast an <code>int</code> with the value 142857 into a <code>short</code> <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch08lev2sec4"><strong><em>Structured Bindings</em></strong></h4>&#13;
<p class="noindent"><em>Structured bindings</em> enable you to unpack objects into their constituent elements. Any type whose non-static data members are public can be unpacked this way—for example, the POD (plain-old-data class) types introduced in <a href="ch02.xhtml#ch02">Chapter 2</a>. The <em>structured binding syntax</em> is as follows:</p>&#13;
<pre>auto [<span class="codeitalic1">object-1</span>, <span class="codeitalic1">object-2</span>, ...] = <span class="codeitalic1">plain-old-data</span>;</pre>&#13;
<p class="indent">This line will initialize an arbitrary number of objects (<span class="codeitalic">object-1</span>, <span class="codeitalic">object-2</span>, and so on) by peeling them off a POD object one by one. The objects peel off the POD from top to bottom, and they fill in the structured binding from left to right. Consider a <code>read_text_file</code> function that takes a string argument corresponding to the file path. Such a function might fail, for example, if a file is locked or doesn’t exist. You have two options for handling errors:</p>&#13;
<ul>&#13;
<li class="noindent">You can throw an exception within <code>read_text_file</code>.</li>&#13;
<li class="noindent">You can return a success status code from the function.</li>&#13;
</ul>&#13;
<p class="indent">Let’s explore the second option.</p>&#13;
<p class="indent">The POD type in <a href="ch08.xhtml#ch08ex10">Listing 8-10</a> will serve as a fine return type from the <code>read_text_file</code> function.</p>&#13;
<pre>struct TextFile {&#13;
  bool success; <span class="ent">➊</span>&#13;
  const char* contents; <span class="ent">➋</span>&#13;
  size_t n_bytes; <span class="ent">➌</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch08ex10"/><em>Listing 8-10: A <code>TextFile</code> type that will be returned by the <code>read_text_file</code> function</em></p>&#13;
<p class="indent">First, a flag communicates to the caller whether the function call was a <code>success</code> <span class="ent">➊</span>. Next is the contents of the <code>file</code> <span class="ent">➋</span> and its size <code>n_bytes</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The prototype of <code>read_text_file</code> looks like this:</p>&#13;
<pre>TextFile read_text_file(const char* path);</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_223"/>You can use a structured binding declaration to unpack a <code>TextFile</code> into its parts within your program, as in <a href="ch08.xhtml#ch08ex11">Listing 8-11</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct TextFile { <span class="ent">➊</span>&#13;
  bool success;&#13;
  const char* data;&#13;
  size_t n_bytes;&#13;
};&#13;
&#13;
TextFile read_text_file(const char* path) { <span class="ent">➋</span>&#13;
  const static char contents[]{ "Sometimes the goat is you." };&#13;
  return TextFile{&#13;
    true,&#13;
    contents,&#13;
    sizeof(contents)&#13;
  };&#13;
}&#13;
&#13;
int main() {&#13;
  const auto [success, contents, length]<span class="ent">➌</span> = read_text_file("REAMDE.txt"); <span class="ent">➍</span>&#13;
  if (success<span class="ent">➎</span>) {&#13;
    p<a id="_idTextAnchor395"/>rintf("Read %zu bytes: %s\n", length<span class="ent">➏</span>, contents<span class="ent">➐</span>);&#13;
  } else {&#13;
    printf("Failed to open REAMDE.txt.");&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Read 27 bytes: Sometimes the goat is you.</span></pre>&#13;
<p class="listing"><a id="ch08ex11"/><em>Listing 8-11: A program simulating the reading of a text file that returns a POD that you use in a structured binding</em></p>&#13;
<p class="indent">You’ve declared the <code>TextFile</code> <span class="ent">➊</span> and then provided a dummy definition for <code>read_text_file</code> <span class="ent">➋</span>. (It doesn’t actually read a file; more on that in <a href="part02.xhtml#part02">Part II</a>.)</p>&#13;
<p class="indent">Within <code>main</code>, you invoke <code>read_text_file</code> <span class="ent">➍</span> and use a structured binding declaration to unpack the results into three distinct variables: <code>success</code>, <code>contents</code>, and <code>length</code> <span class="ent">➌</span>. After structured binding, you can use all these variables as though you had declared them individually <span class="ent">➎</span><span class="ent">➏</span><span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The types within a structured binding declaration don’t have to match.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec5"><strong><em>Attributes</em></strong></h4>&#13;
<p class="indent">Attributes apply implementation-defined features to an expression statement. You introduce attributes using double brackets <code>[[ ]]</code> containing a list of one or more comma-separated attribute elements.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08tab01">Table 8-1</a> lists the standard attributes.</p>&#13;
<p class="tabcap" id="ch08tab01"><span epub:type="pagebreak" id="page_224"/><strong>Table 8-1:</strong> The Standard Attributes</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Attribute</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Meaning</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>[[noreturn]]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Indicates that a function doesn’t return.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>[[deprecated("</code><span class="codeitalic">reason</span><code>")]]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Indicates that this expression is deprecated; that is, its use is discouraged. The <code>"reason"</code> is optional and indicates the reason for deprecation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>[[fallthrough]]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Indicates that a switch case intends to fall through to the next switch case. This avoids compiler errors that will check for switch case fallthrough, because it’s uncommon.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>[[nodiscard]]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Indicates that the following function or type declaration should be used. If code using this element discards the value, the compiler should emit a warning.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>[[maybe_unused]]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Indicates that the following element might be unused and that the compiler shouldn’t warn about it.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>[[carries_dependency]]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Used within the <code>&lt;atomic&gt;</code> header to help the compiler optimize certain memory operations. You’re unlikely to encounter this directly.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex12">Listing 8-12</a> demonstrates using the <code>[[noreturn]]</code> attribute by defining a function that never returns.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
[[noreturn]] void pitcher() { <span class="ent">➊</span>&#13;
  throw std::runtime_error{ "Knuckleball." }; <span class="ent">➋</span>&#13;
}&#13;
&#13;
int main() {&#13;
  try {&#13;
    pitcher(); <span class="ent">➌</span>&#13;
  } catch(const std::exception&amp; e) {&#13;
    printf("exception: %s\n", e.what()); <span class="ent">➍</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Exception: Knuckleball. <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch08ex12"/><em>Listing 8-12: A program illustrating the use of the <code>[[noreturn]]</code> attribute</em></p>&#13;
<p class="indent">First, you declare the <code>pitcher</code> function with the <code>[[noreturn]]</code> attribute <span class="ent">➊</span>. Within this function, you throw an exception <span class="ent">➋</span>. Because you always throw an exception, <code>pitcher</code> never returns (hence the <code>[[noreturn]]</code> attribute). Within <code>main</code>, you invoke <code>pitcher</code> <span class="ent">➌</span> and handle the caught exception <span class="ent">➍</span>. Of course, this listing works without the <code>[[noreturn]]</code> attribute. But giving this information to the compiler allows it to reason more completely on your code (and potentially to optimize your program).</p>&#13;
<p class="indent">The situations in which you’ll need to use an attribute are rare, but they convey useful information to the compiler nonetheless.</p>&#13;
<h3 class="h3" id="ch08lev1sec4"><strong><span epub:type="pagebreak" id="page_225"/>Selection Statements</strong></h3>&#13;
<p class="indent"><em>Selection statements</em> express conditional control flow. The two varieties of selection statements are the <code>if</code> statement and the <code>switch</code> statement.</p>&#13;
<h4 class="h4" id="ch08lev2sec6"><strong><em>if Statements</em></strong></h4>&#13;
<p class="indent">The <code>if</code> statement has the familiar form shown in <a href="ch08.xhtml#ch08ex13">Listing 8-13</a>.</p>&#13;
<pre>if (<span class="codeitalic1">condition-1</span>) {&#13;
  // Execute only if condition-1 is true <span class="ent">➊</span>&#13;
} else if (<span class="codeitalic1">condition-2</span>) { // optional&#13;
  // Execute only if condition-2 is true <span class="ent">➋</span>&#13;
}&#13;
// ... as many else ifs as desired&#13;
--<span class="codeitalic1">snip</span>--&#13;
} else { // optional&#13;
  // Execute only if none of the conditionals is true <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch08ex13"/><em>Listing 8-13: The syntax of the <code>if</code> statement</em></p>&#13;
<p class="indent">Upon encountering an <code>if</code> statement, you evaluate the <span class="codeitalic">condition-1</span> expression first. If it’s <code>true</code>, the block at <span class="ent">➊</span> is executed and the <code>if</code> statement stops executing (none of the <code>else if</code> or <code>else</code> statements are considered). If it’s <code>false</code>, the <code>else if</code> statements’ conditions evaluate in order. These are optional, and you can supply as many as you like.</p>&#13;
<p class="indent">If <span class="codeitalic">condition-2</span> evaluates to <code>true</code>, for example, the block at <span class="ent">➋</span> will execute and none of the remaining <code>else if</code> or <code>else</code> statements are considered. Finally, the <code>else</code> block at <span class="ent">➌</span> executes if all of the preceding conditions evaluate to <code>false</code>. Like the <code>else if</code> blocks, the <code>else</code> block is optional.</p>&#13;
<p class="indent">The function template in <a href="ch08.xhtml#ch08ex14">Listing 8-14</a> converts an <code>else</code> argument into <code>Positive</code>, <code>Negative</code>, or <code>Zero</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
constexpr const char* sign(const T&amp; x) {&#13;
  const char* result{};&#13;
  if (x == 0) { <span class="ent">➊</span>&#13;
    result = "zero";&#13;
  } else if (x &gt; 0) { <span class="ent">➋</span>&#13;
    result = "positive";&#13;
  } else { <span class="ent">➌</span>&#13;
    result = "negative";&#13;
  }&#13;
  return result;&#13;
}&#13;
&#13;
int main() {&#13;
  printf("float 100 is %s\n", sign(100.0f));&#13;
  printf("int  -200 is %s\n", sign(-200));&#13;
<span epub:type="pagebreak" id="page_226"/>  printf("char    0 is %s\n", sign(char{}));&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">float 100 is positive</span>&#13;
<span class="color1">int  -200 is negative</span>&#13;
<span class="color1">char    0 is zero</span></pre>&#13;
<p class="listing"><a id="ch08ex14"/><em>Listing 8-14: An example usage of the <code>if</code> statement</em></p>&#13;
<p class="indent">The <code>sign</code> function takes a single argument and determines if it’s equal to 0 <span class="ent">➊</span>, greater than 0 <span class="ent">➋</span>, or less than 0 <span class="ent">➌</span>. Depending on which condition matches, it sets the automatic variable result equal to one of three strings—<code>zero</code>, <code>positive</code>, or <code>negative</code>—and returns this value to the caller.</p>&#13;
<h5 class="h5" id="ch08lev3sec4"><strong>Initialization Statements and if</strong></h5>&#13;
<p class="indent">You can bind an object’s scope to an <code>if</code> statement by adding an <code>init-state</code><code>ment</code> to <code>if</code> and <code>else if</code> declarations, as demonstrated in <a href="ch08.xhtml#ch08ex15">Listing 8-15</a>.</p>&#13;
<pre>if (<span class="codeitalic1">init-statement</span>; <span class="codeitalic1">condition-1</span>) {&#13;
  // Execute only if condition-1 is true&#13;
} else if (<span class="codeitalic1">init-statement</span>; <span class="codeitalic1">condition-2</span>) { // optional&#13;
  // Execute only if condition-2 is true&#13;
}&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="listing"><a id="ch08ex15"/><em>Listing 8-15: An <code>if</code> statement with initializations</em></p>&#13;
<p class="indent">You can use this pattern with structured bindings to produce elegant error handling. <a href="ch08.xhtml#ch08ex16">Listing 8-16</a> refactors <a href="ch08.xhtml#ch08ex11">Listing 8-11</a> using the initialization statement to scope a <code>TextFile</code> to the <code>if</code> statement.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct TextFile {&#13;
  bool success;&#13;
  const char* data;&#13;
  size_t n_bytes;&#13;
};&#13;
&#13;
TextFile read_text_file(const char* path) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  if(const auto [success, txt, len]<span class="ent">➊</span> = read_text_file("REAMDE.txt"); success<span class="ent">➋</span>)&#13;
  {&#13;
    printf("Read %d bytes: %s\n", len, txt); <span class="ent">➌</span>&#13;
  } else {&#13;
    printf("Failed to open REAMDE.txt."); <span class="ent">➍</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1"><span epub:type="pagebreak" id="page_227"/>Read 27 bytes: Sometimes the goat is you. <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch08ex16"/><em>Listing 8-16: An extension of <a href="ch08.xhtml#ch08ex11">Listing 8-11</a> using structured binding and an <code>if</code> statement to handle errors</em></p>&#13;
<p class="indent">You’ve moved the structured binding declaration into the initialization statement portion of the <code>if</code> statement <span class="ent">➊</span>. This scopes each of the unpacked objects—<code>success</code>, <code>txt</code>, and <code>len</code>—to the <code>if</code> block. You use <code>success</code> directly within the conditional expression of <code>if</code> to determine whether <code>read_text_file</code> was successful <span class="ent">➋</span>. If it was, you print the contents of <code>REAMDE.txt</code> <span class="ent">➌</span>. If it wasn’t, you print an error message <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch08lev3sec5"><strong>constexpr if Statements</strong></h5>&#13;
<p class="noindent">You can make an <code>if</code> statement <code>constexpr</code>; such statements are known as <code>constexpr if</code> statements. A <code>constexpr if</code> statement is evaluated at compile time. Code blocks that correspond to <code>true</code> conditions get emitted, and the rest is ignored.</p>&#13;
<p class="indent">Usage of the <code>constexpr if</code> follows usage for a regular <code>if</code> statement, as demonstrated in <a href="ch08.xhtml#ch08ex17">Listing 8-17</a>.</p>&#13;
<pre>if constexpr (<span class="codeitalic1">condition-1</span>) {&#13;
  // Compile only if condition-1 is true&#13;
} else if constexpr (<span class="codeitalic1">condition-2</span>) { // optional; can be multiple else ifs&#13;
  // Compile only if condition-2 is true&#13;
}&#13;
--<span class="codeitalic1">snip</span>--&#13;
} else { // optional&#13;
  // Compile only if none of the conditionals is true&#13;
}</pre>&#13;
<p class="listing"><a id="ch08ex17"/><em>Listing 8-17: Usage of the <code>constexpr if</code> statement</em></p>&#13;
<p class="indent">In combination with templates and the <code>&lt;type_traits&gt;</code> header, <code>constexpr</code> <code>if</code> statements are extremely powerful. A major use for <code>constexpr if</code> is to provide custom behavior in a function template depending on some attributes of type parameters.</p>&#13;
<p class="indent">The function template <code>value_of</code> in <a href="ch08.xhtml#ch08ex18">Listing 8-18</a> accepts pointers, references, and values. Depending on which kind of object the argument is, <code>value_of</code> returns either the pointed-to value or the value itself.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
#include &lt;type_traits&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
auto value_of(T x<span class="ent">➊</span>) {&#13;
  if constexpr (std::is_pointer&lt;T&gt;::value) { <span class="ent">➋</span>&#13;
    if (!x) throw std::runtime_error{ "Null pointer dereference." }; <span class="ent">➌</span>&#13;
    return *x; <span class="ent">➍</span>&#13;
<span epub:type="pagebreak" id="page_228"/>  } else {&#13;
    return x; <span class="ent">➎</span>&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  unsigned long level{ 8998 };&#13;
  auto level_ptr = &amp;level;&#13;
  auto &amp;level_ref = level;&#13;
  printf("Power level = %lu\n", value_of(level_ptr)); <span class="ent">➏</span>&#13;
  ++*level_ptr;&#13;
  printf("Power level = %lu\n", value_of(level_ref)); <span class="ent">➐</span>&#13;
  ++level_ref;&#13;
  printf("It's over %lu!\n", value_of(level++)); <span class="ent">➑</span>&#13;
  try {&#13;
    level_ptr = nullptr;&#13;
    value_of(level_ptr);&#13;
  } catch(const std::exception&amp; e) {&#13;
    printf("Exception: %s\n", e.what()); <span class="ent">➒</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Power level = 8998 <span class="ent">➏</span></span>&#13;
<span class="color1">Power level = 8999 <span class="ent">➐</span></span>&#13;
<span class="color1">It's over 9000! <span class="ent">➑</span></span>&#13;
<span class="color1">Exception: Null pointer dereference. <span class="ent">➒</span></span></pre>&#13;
<p class="listing"><a id="ch08ex18"/><em>Listing 8-18: An example function template, <code>value_of</code>, employing a <code>constexpr if</code> statement</em></p>&#13;
<p class="indent">The <code>value_of</code> function template accepts a single argument <code>x</code> <span class="ent">➊</span>. You determine whether the argument is a pointer type using the <code>std::is_pointer&lt;T&gt;</code> type trait as the conditional expression in a <code>constexpr if</code> statement <span class="ent">➋</span>. In case <code>x</code> is a pointer type, you check for <code>nullptr</code> and throw an exception if one is encountered <span class="ent">➌</span>. If <code>x</code> isn’t a <code>nullptr</code>, you dereference it and return the result <span class="ent">➍</span>. Otherwise, <code>x</code> is not a pointer type, so you return it (because it is therefore a value) <span class="ent">➎</span>.</p>&#13;
<p class="indent">Within <code>main</code>, you instantiate <code>value_of</code> multiple times with an <code>unsigned long</code> pointer <span class="ent">➏</span>, an <code>unsigned long</code> reference <span class="ent">➐</span>, an <code>unsigned long</code> <span class="ent">➑</span>, and a <code>nullptr</code> <span class="ent">➒</span> respectively.</p>&#13;
<p class="indent">At runtime, the <code>constexpr if</code> statement disappears; each instantiation of <code>value_of</code> contains one branch of the selection statement or the other. You might be wondering why such a facility is useful. After all, programs are meant to do something useful at runtime, not at compile time. Just flip back to <a href="ch07.xhtml#ch07ex17">Listing 7-17</a> (on <a href="ch07.xhtml#page_206">page 206</a>), and you’ll see that compile time evaluation can substantially simplify your programs by eliminating magic values.</p>&#13;
<p class="indent">There are other examples where compile time evaluation is popular, especially when creating libraries for others to use. Because library writers usually cannot know all the ways their users will utilize their library, they need to write generic code. Often, they’ll use techniques like those you learned in <a href="ch06.xhtml#ch06">Chapter 6</a> so they can achieve compile-time polymorphism. Constructs like <code>constexpr</code> can help when writing this kind of code.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_229"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you have a C background, you’ll immediately recognize the utility of compile time evaluation when considering that it almost entirely replaces the need for preprocessor macros.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec7"><strong><em>switch Statements</em></strong></h4>&#13;
<p class="noindent"><a href="ch02.xhtml">Chapter 2</a> first introduced the venerable <code>switch</code> statement. This section delves into the addition of the initialization statement into the <code>switch</code> declaration. The usage is as follows:</p>&#13;
<pre>switch (<span class="codeitalic1">init-expression</span><span class="ent">➊</span>; <span class="codeitalic1">condition</span>) {&#13;
  case (<span class="codeitalic1">case-a</span>): {&#13;
    // Handle case-a here&#13;
  } break;&#13;
  case (<span class="codeitalic1">case-b</span>): {&#13;
    // Handle case-b here&#13;
  } break;&#13;
    // Handle other conditions as desired&#13;
  default: {&#13;
    // Handle the default case here&#13;
  }&#13;
}</pre>&#13;
<p class="indent">As with <code>if</code> statements, you can instantiate within <code>switch</code> statements <span class="ent">➊</span>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex19">Listing 8-19</a> employs an initialization statement within a <code>switch</code> statement.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
enum class Color { <span class="ent">➊</span>&#13;
  Mauve,&#13;
  Pink,&#13;
  Russet&#13;
};&#13;
&#13;
struct Result { <span class="ent">➋</span>&#13;
  const char* name;&#13;
  Color color;&#13;
};&#13;
&#13;
Result observe_shrub(const char* name) { <span class="ent">➌</span>&#13;
  return Result{ name, Color::Russet };&#13;
}&#13;
&#13;
int main() {&#13;
  const char* description;&#13;
  switch (const auto result<span class="ent">➍</span> = observe_shrub("Zaphod"); result.color<span class="ent">➎</span>) {&#13;
  case Color::Mauve: {&#13;
    description = "mauvey shade of pinky russet";&#13;
    break;&#13;
  } case Color::Pink: {&#13;
    description = "pinky shade of mauvey russet";&#13;
    break;&#13;
  } case Color::Russet: {&#13;
<span epub:type="pagebreak" id="page_230"/>    description = "russety shade of pinky mauve";&#13;
    break;&#13;
  } default: {&#13;
    description = "enigmatic shade of whitish black";&#13;
  }}&#13;
  printf("The other Shaltanac's joopleberry shrub is "&#13;
         "always a more %s.", description); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The other Shaltanac's joopleberry shrub is always a more russety shade of&#13;
pinky mauve. <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch08ex19"/><em>Listing 8-19: Using an initialization expression in a <code>switch</code> statement</em></p>&#13;
<p class="indent">You declare the familiar <code>Color</code> <code>enum class</code> <span class="ent">➊</span> and join it with a <code>char*</code> member to form the POD type <code>Result</code> <span class="ent">➋</span>. The function <code>observe_shrub</code> returns a <code>Result</code> <span class="ent">➌</span>. Within <code>main</code>, you call <code>observe_shrub</code> within the initialization expression and store the result in the <code>result</code> variable <span class="ent">➍</span>. Within the conditional expression of <code>switch</code>, you extract the <code>color</code> element of this <code>result</code> <span class="ent">➎</span>. This element determines the case that executes (and sets the <code>description</code> pointer) <span class="ent">➏</span>.</p>&#13;
<p class="indent">As with the <code>if</code>-statement-plus-initializer syntax, any object initialized in the initialization expression is bound to the scope of the <code>switch</code> statement.</p>&#13;
<h3 class="h3" id="ch08lev1sec5"><strong>Iteration Statements</strong></h3>&#13;
<p class="noindent"><em>Iteration statements</em> execute a statement repeatedly. The four kinds of iteration statements are the <code>while</code> loop, the <code>do</code>-<code>while</code> loop, the <code>for</code> loop, and the range-based <code>for</code> loop.</p>&#13;
<h4 class="h4" id="ch08lev2sec8"><strong><em>while Loops</em></strong></h4>&#13;
<p class="noindent">The <code>while</code> loop is the basic iteration mechanism. The usage is as follows:</p>&#13;
<pre>while (<span class="codeitalic1">condition</span>) {&#13;
  // The statement in the body of the loop&#13;
  // executes upon each iteration&#13;
}</pre>&#13;
<p class="indent">Before executing an iteration of the loop, the <code>while</code> loop evaluates the <code>condition</code> expression. If <code>true</code>, the loop continues. If <code>false</code>, the loop terminates, as demonstrated in <a href="ch08.xhtml#ch08ex20">Listing 8-20</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
bool double_return_overflow(uint8_t&amp; x) { <span class="ent">➊</span>&#13;
  const auto original = x;&#13;
  x *= 2;&#13;
  return original &gt; x;&#13;
}&#13;
<span epub:type="pagebreak" id="page_231"/>int main() {&#13;
  uint8_t x{ 1 }; <span class="ent">➋</span>&#13;
  printf("uint8_t:\n===\n");&#13;
  while (!double_return_overflow(x)<span class="ent">➌</span>) {&#13;
    printf("%u ", x); <span class="ent">➍</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">uint8_t:</span>&#13;
<span class="color1">===</span>&#13;
<span class="color1">2 4 8 16 32 64 128 <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch08ex20"/><em>Listing 8-20: A program that doubles a <code>uint8_t</code> and prints the new value on each iteration</em></p>&#13;
<p class="indent">You declare a <code>double_return_overflow</code> function taking an 8-bit, unsigned integer by reference <span class="ent">➊</span>. This function doubles the argument and checks whether this causes an overflow. If it does, it returns <code>true</code>. If no overflow occurs, it returns <code>false</code>.</p>&#13;
<p class="indent">You initialize the variable <code>x</code> to 1 before entering the <code>while</code> loop <span class="ent">➋</span>. The conditional expression in the <code>while</code> loop evaluates <code>double_return_overflow(x)</code> <span class="ent">➌</span>. This has the side effect of doubling <code>x</code>, because you’ve passed it by reference. It also returns a value telling you whether the doubling caused <code>x</code> to overflow. The loop will execute when the conditional expression evaluates to <code>true</code>, but <code>double_return_overflow</code> is written so it returns <code>true</code> when the loop should stop. You fix this problem by prepending the logical negation operator (<code>!</code>). (Recall from <a href="ch07.xhtml#ch07">Chapter 7</a> that this turns <code>true</code> to <code>false</code> and <code>false</code> to <code>true</code>.) So the <code>while</code> loop is actually asking, “If it’s NOT true that <code>double_return_overflow</code> is true . . .”</p>&#13;
<p class="indent">The end result is that you print the values 2, then 4, then 8, and so on to 128 <span class="ent">➍</span>.</p>&#13;
<p class="indent">Notice that the value 1 never prints, because evaluating the conditional expression doubles <code>x</code>. You can modify this behavior by putting the conditional statement at the end of a loop, which yields a <code>do</code>-<code>while</code> loop.</p>&#13;
<h4 class="h4" id="ch08lev2sec9"><strong><em>do-while Loops</em></strong></h4>&#13;
<p class="indent">A <code>do</code>-<code>while</code> loop is identical to a <code>while</code> loop, except the conditional statement evaluates after a loop completes rather than before. Its usage is as follows:</p>&#13;
<pre>do {&#13;
  // The statement in the body of the loop&#13;
  // executes upon each iteration&#13;
} while (<span class="codeitalic1">condition</span>);</pre>&#13;
<p class="indent">Because the condition evaluates at the end of a loop, you guarantee that the loop will execute at least once.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex21">Listing 8-21</a> refactors <a href="ch08.xhtml#ch08ex20">Listing 8-20</a> into a <code>do</code>-<code>while</code> loop.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
bool double_return_overflow(uint8_t&amp; x) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
<span epub:type="pagebreak" id="page_232"/>}&#13;
&#13;
int main() {&#13;
  uint8_t x{ 1 };&#13;
  printf("uint8_t:\n===\n");&#13;
  do {&#13;
    printf("%u ", x); <span class="ent">➊</span>&#13;
  } while (!double_return_overflow(x)<span class="ent">➋</span>);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">uint8_t:</span>&#13;
<span class="color1">===</span>&#13;
<span class="color1">1 2 4 8 16 32 64 128 <span class="ent">➊</span></span></pre>&#13;
<p class="listing"><a id="ch08ex21"/><em>Listing 8-21: A program that doubles a <code>uint8_t</code> and prints the new value on each iteration</em></p>&#13;
<p class="indent">Notice that the output from <a href="ch08.xhtml#ch08ex21">Listing 8-21</a> now begins with 1 <span class="ent">➊</span>. All you needed to do was reformat the <code>while</code> loop to put the condition at the end of the loop <span class="ent">➋</span>.</p>&#13;
<p class="indent">In most situations involving iterations, you have three tasks:</p>&#13;
<ol>&#13;
<li class="noindent">Initialize some object.</li>&#13;
<li class="noindent">Update the object before each iteration.</li>&#13;
<li class="noindent">Inspect the object’s value for some condition.</li>&#13;
</ol>&#13;
<p class="indent">You can use a <code>while</code> or <code>do</code>-<code>while</code> loop to accomplish part of these tasks, but the <code>for</code> loop provides built-in facilities that make life easier.</p>&#13;
<h4 class="h4" id="ch08lev2sec10"><strong><em>for Loops</em></strong></h4>&#13;
<p class="noindent">The <code>for</code> loop is an iteration statement containing three special expressions: <em>initialization</em>, <em>conditional</em>, and <em>iteration</em>, as described in the sections that follow.</p>&#13;
<h5 class="h5" id="ch08lev3sec6"><strong>The Initialization Expression</strong></h5>&#13;
<p class="noindent">The initialization expression is like the initialization of <code>if</code>: it executes only once before the first iteration executes. Any objects declared within the initialization expression have lifetimes bound by the scope of the <code>for</code> loop.</p>&#13;
<h5 class="h5" id="ch08lev3sec7"><strong>The Conditional Expression</strong></h5>&#13;
<p class="noindent">The <code>for</code> loop conditional expression evaluates just before each iteration of the loop. If the conditional evaluates to <code>true</code>, the loop continues to execute. If the conditional evaluates to <code>false</code>, the loop terminates (this behavior is exactly like the conditional of the <code>while</code> and <code>do</code>-<code>while</code> loops).</p>&#13;
<p class="indent">Like <code>if</code> and <code>switch</code> statements, <code>for</code> permits you to initialize objects with scope equal to the statement’s.</p>&#13;
<h5 class="h5" id="ch08lev3sec8"><strong>The Iteration Expression</strong></h5>&#13;
<p class="noindent">After each iteration of the <code>for</code> loop, the iteration expression evaluates. This happens before the conditional expression evaluates. Note that the iteration <span epub:type="pagebreak" id="page_233"/>expression evaluates after a successful iteration, so the iteration expression won’t execute before the first iteration.</p>&#13;
<p class="indent">To clarify, the following list outlines the typical execution order in a <code>for</code> loop:</p>&#13;
<ol>&#13;
<li class="noindent">Initialization expression</li>&#13;
<li class="noindent">Conditional expression</li>&#13;
<li class="noindent">(Loop body)</li>&#13;
<li class="noindent">Iteration expression</li>&#13;
<li class="noindent">Conditional expression</li>&#13;
<li class="noindent">(Loop body)</li>&#13;
</ol>&#13;
<p class="indent">Steps 4 through 6 repeat until a conditional expression returns <code>false</code>.</p>&#13;
<h5 class="h5" id="ch08lev3sec9"><strong>Usage</strong></h5>&#13;
<p class="noindent"><a href="ch08.xhtml#ch08ex22">Listing 8-22</a> demonstrates the use of a <code>for</code> loop.</p>&#13;
<pre>for(<span class="codeitalic1">initialization</span><span class="ent">➊</span>; <span class="codeitalic1">conditional</span><span class="ent">➋</span>; <span class="codeitalic1">iteration</span><span class="ent">➌</span>) {&#13;
  // The statement in the body of the loop&#13;
  // executes upon each iteration&#13;
}</pre>&#13;
<p class="listing"><a id="ch08ex22"/><em>Listing 8-22: Using a <code>for</code> loop</em></p>&#13;
<p class="indent">The initialization <span class="ent">➊</span>, conditional <span class="ent">➋</span>, and iteration <span class="ent">➌</span> expressions reside in parentheses preceding the body of the <code>for</code> loop.</p>&#13;
<h5 class="h5" id="ch08lev3sec10"><strong>Iterating with an Index</strong></h5>&#13;
<p class="noindent">The <code>for</code> loops are excellent at iterating over an array-like object’s constituent elements. You use an auxiliary <em>index</em> variable to iterate over the range of valid indices for the array-like object. You can use this index to interact with each array element in sequence. <a href="ch08.xhtml#ch08ex23">Listing 8-23</a> employs an index variable to print each element of an array along with its index.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  const int x[]{ 1, 1, 2, 3, 5, 8 }; <span class="ent">➊</span>&#13;
  printf("i: x[i]\n"); <span class="ent">➋</span>&#13;
  for (int i{}<span class="ent">➌</span>; i &lt; 6<span class="ent">➍</span>; i++<span class="ent">➎</span>) {&#13;
    printf("%d: %d\n", i, x[i]);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">i: x[i] <span class="ent">➋</span></span>&#13;
<span class="color1">0: 1</span>&#13;
<span class="color1">1: 1</span>&#13;
<span class="color1">2: 2</span>&#13;
<span class="color1">3: 3</span>&#13;
<span class="color1"><span epub:type="pagebreak" id="page_234"/>4: 5</span>&#13;
<span class="color1">5: 8</span></pre>&#13;
<p class="listing"><a id="ch08ex23"/><em>Listing 8-23: A program iterating over an array of Fibonacci numbers</em></p>&#13;
<p class="indent">You initialize an <code>int</code> array called <code>x</code> with the first six Fibonacci numbers <span class="ent">➊</span>. After printing a header for the output <span class="ent">➋</span>, you build a <code>for</code> loop containing your initialization <span class="ent">➌</span>, conditional <span class="ent">➍</span>, and iteration <span class="ent">➎</span> expressions. The initialization expression executes first, and it initializes the index variable <code>i</code> to zero.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex23">Listing 8-23</a> shows a coding pattern that hasn’t changed since the 1950s. You can eliminate a lot of boilerplate code by using the more modern range-based <code>for</code> loop.</p>&#13;
<h4 class="h4" id="ch08lev2sec11"><strong><em>Ranged-Based for Loops</em></strong></h4>&#13;
<p class="noindent">The range-based <code>for</code> loop iterates over a <em>range</em> of values without needing an index variable. A range (or <em>range expression</em>) is an object that the range-based <code>for</code> loop knows how to iterate over. Many C++ objects are valid range expressions, including arrays. (All of the stdlib containers you’ll learn about in <a href="part02.xhtml#part02">Part II</a> are also valid range expressions.)</p>&#13;
<h5 class="h5" id="ch08lev3sec11"><strong>Usage</strong></h5>&#13;
<p class="noindent">Ranged-based <code>for</code> loop usage looks like this:</p>&#13;
<pre>for(<span class="codeitalic1">range-declaration</span> : <span class="codeitalic1">range-expression</span>) {&#13;
  // The statement in the body of the loop&#13;
  // executes upon each iteration&#13;
}</pre>&#13;
<p class="indent">A <em>range declaration</em> declares a named variable. This variable must have the same type as implied by the range expression (you can use <code>auto</code>).</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex24">Listing 8-24</a> refactors <a href="ch08.xhtml#ch08ex23">Listing 8-23</a> to use a range-based <code>for</code> loop.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  const int x[]{ 1, 1, 2, 3, 5, 8 }; <span class="ent">➊</span>&#13;
  for (const auto element<span class="ent">➋</span> : x<span class="ent">➌</span>) {&#13;
    printf("%d ", element<span class="ent">➍</span>);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 1 2 3 5 8</span></pre>&#13;
<p class="listing"><a id="ch08ex24"/><em>Listing 8-24: A range-based <code>for</code> loop iterating over the first six Fibonacci numbers</em></p>&#13;
<p class="indent">You still declare an array <code>x</code> containing six Fibonacci numbers <span class="ent">➊</span>. The range-based <code>for</code> loop contains a range-declaration expression <span class="ent">➋</span> where you declare the <code>element</code> variable to hold each element of the range. It also contains the range expression <code>x</code> <span class="ent">➌</span>, which contains the elements you want to iterate over to print <span class="ent">➍</span>.</p>&#13;
<p class="indent">This code is a whole lot cleaner!</p>&#13;
<h5 class="h5" id="ch08lev3sec12"><strong><span epub:type="pagebreak" id="page_235"/>Range Expressions</strong></h5>&#13;
<p class="noindent">You can define your own types that are also valid range expressions. But you’ll need to specify several functions on your type.</p>&#13;
<p class="indent">Every range exposes a <code>begin</code> and an <code>end</code> method. These functions represent the common interface that a range-based <code>for</code> loop uses to interact with a range. Both methods return <em>iterators</em>. An iterator is an object that supports <code>operator!=</code>, <code>operator++</code>, and <code>operator*</code>.</p>&#13;
<p class="indent">Let’s look at how all these pieces fit together. Under the hood, a range-based <code>for</code> loop looks just like the loop in <a href="ch08.xhtml#ch08ex25">Listing 8-25</a>.</p>&#13;
<pre>const auto e = range.end();<span class="ent">➊</span>&#13;
for(auto b = range.begin()<span class="ent">➋</span>; b != e<span class="ent">➌</span>; ++b<span class="ent">➍</span>) {&#13;
  const auto&amp; element<span class="ent">➎</span> = *b;&#13;
}</pre>&#13;
<p class="listing"><a id="ch08ex25"/><em>Listing 8-25: A <code>for</code> loop simulating a range-based <code>for</code> loop</em></p>&#13;
<p class="indent">The initialization expression stores two variables, <code>b</code> <span class="ent">➋</span> and <code>e</code> <span class="ent">➊</span>, which you initialize to <code>range.begin()</code> and <code>range.end()</code> respectively. The conditional expression checks whether <code>b</code> equals <code>e</code>, in which case the loop has completed <span class="ent">➌</span> (this is by convention). The iteration expression increments <code>b</code> with the prefix operator <span class="ent">➍</span>. Finally, the iterator supports the dereference operator <code>*</code>, so you can extract the pointed-to element <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The types returned by <code>begin</code> and <code>end</code> don’t need to be the same. The requirement is that <code>operator!=</code> on <code>begin</code> accepts an <code>end</code> argument to support the comparison <code>begin != end</code>.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch08lev3sec13"><strong>A Fibonacci Range</strong></h5>&#13;
<p class="noindent">You can implement a <code>FibonacciRange</code>, which will generate an arbitrarily long sequence of Fibonacci numbers. From the previous section, you know that this range must offer a <code>begin</code> and an <code>end</code> method that returns an iterator. This iterator, which is called <code>FibonacciIterator</code> in this example, must in turn offer <code>operator!=</code>, <code>operator++</code>, and <code>operator*</code>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex26">Listing 8-26</a> implements a <code>FibonacciIterator</code> and a <code>FibonacciRange</code>.</p>&#13;
<pre>struct FibonacciIterator {&#13;
  bool operator!=(int x) const {&#13;
    return x &gt;= current; <span class="ent">➊</span>&#13;
  }&#13;
&#13;
  FibonacciIterator&amp; operator++() {&#13;
    const auto tmp = current; <span class="ent">➋</span>&#13;
    current += last; <span class="ent">➌</span>&#13;
    last = tmp; <span class="ent">➍</span>&#13;
    return *this; <span class="ent">➎</span>&#13;
  }&#13;
&#13;
  int operator*() const {&#13;
    return current; <span class="ent">➏</span>&#13;
<span epub:type="pagebreak" id="page_236"/>  }&#13;
private:&#13;
  int current{ 1 }, last{ 1 };&#13;
};&#13;
&#13;
struct FibonacciRange {&#13;
  explicit FibonacciRange(int max<span class="ent">➐</span>) : max{ max } { }&#13;
  FibonacciIterator begin() const { <span class="ent">➑</span>&#13;
    return FibonacciIterator{};&#13;
  }&#13;
  int end() const { <span class="ent">➒</span>&#13;
    return max;&#13;
  }&#13;
private:&#13;
  const int max;&#13;
};</pre>&#13;
<p class="listing"><a id="ch08ex26"/><em>Listing 8-26: An implementation of <code>FibonacciIterator</code> and <code>FibonacciRange</code></em></p>&#13;
<p class="indent">The <code>FibonacciIterator</code> has two fields, <code>current</code> and <code>last</code>, which are initialized to 1. These keep track of two values in the Fibonacci sequence. Its <code>operator!=</code> checks whether the argument is greater than or equal to <code>current</code> <span class="ent">➊</span>. Recall that this argument is used within the range-based <code>for</code> loop in the conditional expression. It should return <code>true</code> if elements remain in the range; otherwise, it returns <code>false</code>. The <code>operator++</code> appears in the iteration expression and is responsible for setting up the iterator for the next iteration. You first save <code>current</code> value into the temporary variable <code>tmp</code> <span class="ent">➋</span>. Next, you increment current by <code>last</code>, yielding the next Fibonacci number <span class="ent">➌</span>. (This follows from the definition of a Fibonacci sequence.) Then you set <code>last</code> equal to <code>tmp</code> <span class="ent">➍</span> and return a reference to <code>this</code> <span class="ent">➎</span>. Finally, you implement <code>operator*</code>, which returns <code>current</code> <span class="ent">➏</span> directly.</p>&#13;
<p class="indent"><code>FibonacciRange</code> is much simpler. Its constructor takes a max argument that defines an upper limit for the range <span class="ent">➐</span>. The <code>begin</code> method returns a fresh <code>FibonacciIterator</code> <span class="ent">➑</span>, and the <code>end</code> method returns <code>max</code> <span class="ent">➒</span>.</p>&#13;
<p class="indent">It should now be apparent why you need to implement <code>bool operator!=(int x)</code> on <code>FibonacciIterator</code> rather than, for example, <code>bool operator!=(const FibonacciIterator&amp; x)</code>: a <code>FibonacciRange</code> returns an <code>int</code> from <code>end()</code>.</p>&#13;
<p class="indent">You can use the <code>FibonacciRange</code> in a ranged-based <code>for</code> loop, as demonstrated in <a href="ch08.xhtml#ch08ex27">Listing 8-27</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct FibonacciIterator {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct FibonacciRange {&#13;
  --<span class="codeitalic1">snip</span>--;&#13;
};&#13;
&#13;
int main() {&#13;
<span epub:type="pagebreak" id="page_237"/>  for (const auto i : FibonacciRange{ 5000 }<span class="ent">➊</span>) {&#13;
    printf("%d ", i); <span class="ent">➋</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch08ex27"/><em>Listing 8-27: Using <code>FibonacciRange</code> in a program</em></p>&#13;
<p class="indent">It took a little work to implement <code>FibonacciIterator</code> and <code>FibonacciRange</code> in <a href="ch08.xhtml#ch08ex26">Listing 8-26</a>, but the payoff is substantial. Within <code>main</code>, you simply construct a <code>FibonacciRange</code> with the desired upper limit <span class="ent">➊</span>, and the range-based <code>for</code> loop takes care of everything else for you. You simply use the resulting elements within the <code>for</code> loop <span class="ent">➋</span>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex27">Listing 8-27</a> is functionally equivalent to <a href="ch08.xhtml#ch08ex28">Listing 8-28</a>, which converts the range-based <code>for</code> loop to a traditional <code>for</code> loop.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct FibonacciIterator {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct FibonacciRange {&#13;
  --<span class="codeitalic1">snip</span>--;&#13;
};&#13;
&#13;
int main() {&#13;
  FibonacciRange range{ 5000 };&#13;
  const auto end = range.end();<span class="ent">➊</span>&#13;
  for (auto x = range.begin()<span class="ent">➋</span>; x != end <span class="ent">➌</span>; ++x <span class="ent">➍</span>) {&#13;
    const auto i = *x;&#13;
    printf("%d ", i);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181</span></pre>&#13;
<p class="listing"><a id="ch08ex28"/><em>Listing 8-28: A refactor of <a href="ch08.xhtml#ch08ex27">Listing 8-27</a> using a traditional <code>for</code> loop</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex28">Listing 8-28</a> demonstrates how all of the pieces fit together. Calling <code>range.begin()</code> <span class="ent">➋</span> yields a <code>FibonacciIterator</code>. When you call <code>range.end()</code> <span class="ent">➊</span>, it yields an <code>int</code>. These types come straight from the method definitions of <code>begin()</code> and <code>end()</code> on <code>FibonacciRange</code>. The conditional statement <span class="ent">➌</span> uses <code>operator!=(int)</code> on <code>FibonacciIterator</code> to get the following behavior: if the iterator <code>x</code> has gone past the <code>int</code> argument to <code>operator!=</code>, the conditional evaluates to <code>false</code> and the loop ends. You’ve also implemented <code>operator++</code> on <code>FibonacciIterator</code> so <code>++x</code> <span class="ent">➍</span> increments the Fibonacci number within <code>FibonacciIterator</code>.</p>&#13;
<p class="indent">When you compare <a href="ch08.xhtml#ch08ex27">Listings 8-27</a> and <a href="ch08.xhtml#ch08ex28">8-28</a>, you can see just how much tedium range-based <code>for</code> loops hide.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_238"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You might be thinking, “Sure, the range-based <code>for</code> loop looks a lot cleaner, but implementing <code>FibonacciIterator</code> and <code>FibonacciRange</code> is a lot of work.” That’s a great point, and for one-time-use code, you probably wouldn’t refactor code in this way. Ranges are mainly useful if you’re writing library code, writing code that you’ll reuse often, or simply consuming ranges that someone else has written.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev1sec6"><strong>Jump Statements</strong></h3>&#13;
<p class="noindent"><em>Jump statements</em>, including the <code>break</code>, <code>continue</code>, and <code>goto</code> statements, transfer control flow. Unlike selection statements, jump statements are not conditional. You should avoid using them because they can almost always be replaced with higher-level control structures. They’re discussed here because you might see them in older C++ code and they still play a central role in a lot of C code.</p>&#13;
<h4 class="h4" id="ch08lev2sec12"><strong><em>break Statements</em></strong></h4>&#13;
<p class="noindent">The <code>break</code> statement terminates execution of the enclosing iteration or <code>switch</code> statement. Once <code>break</code> completes, execution transfers to the statement immediately following the <code>for</code>, range-based <code>for</code>, <code>while</code>, <code>do</code>-<code>while</code>, or <code>switch</code> statement.</p>&#13;
<p class="indent">You’ve already used <code>break</code> within <code>switch</code> statements; once a case completes, the <code>break</code> statement terminates the <code>switch</code>. Recall that, without a <code>break</code> statement, the <code>switch</code> statement would continue executing all of the following cases.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex29">Listing 8-29</a> refactors <a href="ch08.xhtml#ch08ex27">Listing 8-27</a> to break out of a range-based <code>for</code> loop if the iterator <code>i</code> equals 21.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct FibonacciIterator {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct FibonacciRange {&#13;
  --<span class="codeitalic1">snip</span>--;&#13;
};&#13;
&#13;
int main() {&#13;
  for (auto i : FibonacciRange{ 5000 }) {&#13;
    if (i == 21) { <span class="ent">➊</span>&#13;
      printf("*** "); <span class="ent">➋</span>&#13;
      break; <span class="ent">➌</span>&#13;
    }&#13;
    printf("%d ", i);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 2 3 5 8 13 *** <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch08ex29"/><em>Listing 8-29: A refactor of <a href="ch08.xhtml#ch08ex27">Listing 8-27</a> that breaks if the iterator equals 21</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_239"/>An <code>if</code> statement is added that checks whether <code>i</code> is 21 <span class="ent">➊</span>. If it is, you print three asterisks <code>***</code> <span class="ent">➋</span> and <code>break</code> <span class="ent">➌</span>. Notice the output: rather than printing 21, the program prints three asterisks and the <code>for</code> loop terminates. Compare this to the output of <a href="ch08.xhtml#ch08ex27">Listing 8-27</a>.</p>&#13;
<h4 class="h4" id="ch08lev2sec13"><strong><em>continue Statements</em></strong></h4>&#13;
<p class="noindent">The <code>continue</code> statement skips the remainder of an enclosing iteration statement and continues with the next iteration. <a href="ch08.xhtml#ch08ex30">Listing 8-30</a> replaces the <code>break</code> in <a href="ch08.xhtml#ch08ex29">Listing 8-29</a> with a <code>continue</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct FibonacciIterator {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct FibonacciRange {&#13;
  --<span class="codeitalic1">snip</span>--;&#13;
};&#13;
&#13;
int main() {&#13;
  for (auto i : FibonacciRange{ 5000 }) {&#13;
    if (i == 21) {&#13;
      printf("*** "); <span class="ent">➊</span>&#13;
      continue; <span class="ent">➋</span>&#13;
    }&#13;
    printf("%d ", i);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 2 3 5 8 13 *** <span class="ent">➊</span>34 55 89 144 233 377 610 987 1597 2584 4181</span></pre>&#13;
<p class="listing"><a id="ch08ex30"/><em>Listing 8-30: A refactor of <a href="ch08.xhtml#ch08ex29">Listing 8-29</a> to use <code>continue</code> instead of <code>break</code></em></p>&#13;
<p class="indent">You still print three asterisks <span class="ent">➊</span> when <code>i</code> is 21, but you use <code>continue</code> instead of <code>break</code> <span class="ent">➋</span>. This causes 21 not to print, like <a href="ch08.xhtml#ch08ex29">Listing 8-29</a>; however, unlike <a href="ch08.xhtml#ch08ex29">Listing 8-29</a>, <a href="ch08.xhtml#ch08ex30">Listing 8-30</a> continues iterating. (Compare the output.)</p>&#13;
<h4 class="h4" id="ch08lev2sec14"><strong><em>goto Statements</em></strong></h4>&#13;
<p class="noindent">The <code>goto</code> statement is an unconditional jump. The target of a <code>goto</code> statement is a label.</p>&#13;
<h5 class="h5" id="ch08lev3sec14"><strong>Labels</strong></h5>&#13;
<p class="noindent"><em>Labels</em> are identifiers you can add to any statement. Labels give statements a name, and they have no direct impact on the program. To assign a label, prepend a statement with the desired name of the label followed by a colon.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex31">Listing 8-31</a> adds the labels <code>luke</code> and <code>yoda</code> to a simple program.</p>&#13;
<pre><span epub:type="pagebreak" id="page_240"/>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
luke: <span class="ent">➊</span>&#13;
  printf("I'm not afraid.\n");&#13;
yoda: <span class="ent">➋</span>&#13;
  printf("You will be.");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">I'm not afraid.</span>&#13;
<span class="color1">You will be.</span></pre>&#13;
<p class="listing"><a id="ch08ex31"/><em>Listing 8-31: A simple program with labels</em></p>&#13;
<p class="indent">The labels <span class="ent">➊</span><span class="ent">➋</span> do nothing on their own.</p>&#13;
<h5 class="h5" id="ch08lev3sec15"><strong>goto Usage</strong></h5>&#13;
<p class="noindent">The <code>goto</code> statement’s usage is as follows:</p>&#13;
<pre>goto <span class="codeitalic1">label</span>;</pre>&#13;
<p class="indent">For example, you can employ <code>goto</code> statements to needlessly obfuscate the simple program in <a href="ch08.xhtml#ch08ex32">Listing 8-32</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  goto silent_bob; <span class="ent">➊</span>&#13;
luke:&#13;
  printf("I'm not afraid.\n");&#13;
  goto yoda; <span class="ent">➌</span>&#13;
silent_bob:&#13;
  goto luke; <span class="ent">➋</span>&#13;
yoda:&#13;
  printf("You will be.");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">I'm not afraid.</span>&#13;
<span class="color1">You will be.</span></pre>&#13;
<p class="listing"><a id="ch08ex32"/><em>Listing 8-32: Spaghetti code showcasing the <code>goto</code> statement</em></p>&#13;
<p class="indent">Control flow in <a href="ch08.xhtml#ch08ex32">Listing 8-32</a> passes to <code>silent_bob</code> <span class="ent">➊</span>, then to <code>luke</code> <span class="ent">➋</span>, and then to <code>yoda</code> <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch08lev3sec16"><strong>The Role of goto in Modern C++ Programs</strong></h5>&#13;
<p class="noindent">In modern C++, there is no good role for <code>goto</code> statements. Don’t use them.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_241"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In poorly written C++ (and in most C code), you might see <code>goto</code> used as a primitive error-handling mechanism. A lot of system programming entails acquiring resources, checking for error conditions, and cleaning up resources. The RAII paradigm neatly abstracts all of these details, but C doesn’t have RAII available. See the Overture to C Programmers on <a href="anoverture.xhtml#page_xxxvii">page  xxxvii</a> for more information.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev1sec7"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you worked through different kinds of statements you can employ in your programs. They included declarations and initializations, selection statements, and iteration statements.</p>&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Keep in mind that <code>try-catch</code> blocks are also statements, but they were already discussed in great detail in <a href="ch04.xhtml#ch04">Chapter 4</a>.</em></p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>8-1.</strong> Refactor <a href="ch08.xhtml#ch08ex27">Listing 8-27</a> into separate translation units: one for <code>main</code> and another for <code>FibonacciRange</code> and <code>FibonacciIterator</code>. Use a header file to share definitions between the two translation units.</p>&#13;
<p class="noindent"><strong>8-2.</strong> Implement a <code>PrimeNumberRange</code> class that can be used in a range expression to iterate over all prime numbers less than a given value. Again, use a separate header and source file.</p>&#13;
<p class="noindent"><strong>8-3.</strong> Integrate <code>PrimeNumberRange</code> into <a href="ch08.xhtml#ch08ex27">Listing 8-27</a>, adding another loop that generates all prime numbers less than 5,000.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland; <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>Random Number Generation and Monte Carlo Methods</em>, 2nd Edition, by James E. Gentle (Springer-Verlag, 2003)</li>&#13;
<li class="noindent"><em>Random Number Generation and Quasi-Monte Carlo Methods</em> by Harald Niederreiter (SIAM Vol. 63, 1992)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>