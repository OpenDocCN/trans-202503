<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_210"/><span epub:type="pagebreak" id="page_211"/><strong><span class="big">8</span><br/>STATEMENTS</strong></h2>&#13;
<p class="quote"><em>Progress doesn’t come from early risers—progress is made by lazy men looking for easier ways to do things.<br/>—Robert A. Heinlein</em>, Time Enough for Love</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">Each C++ function comprises a sequence of <em>statements</em>, which are programming constructs that specify the order of execution. This chapter uses an understanding of the object life cycle, templates, and expressions to explore the nuances of statements.</p>&#13;
<h3 class="h3" id="ch08lev1sec1"><strong>Expression Statements</strong></h3>&#13;
<p class="noindent">An <em>expression statement</em> is an expression followed by a semicolon (<span class="literal">;</span>). Expression statements comprise most of the statements in a program. You can turn any expression into a statement, which you should do whenever you need to evaluate an expression but want to discard the result. Of course, this is only useful if evaluating that expression causes a side effect, like printing to the console or modifying the program’s state.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_212"/><a href="ch08.xhtml#ch08ex01">Listing 8-1</a> contains several expression statements.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  int x{};&#13;
  ++x; <span class="ent">➊</span>&#13;
  42; <span class="ent">➋</span>&#13;
  printf("The %d True Morty\n", x); <span class="ent">➌</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The 1 True Morty <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch08ex01"/><em>Listing 8-1: A simple program containing several expression statements</em></p>&#13;
<p class="indent">The expression statement at <span class="ent">➊</span> has a side effect (incrementing <span class="literal">x</span>), but the one at <span class="ent">➋</span> doesn’t. Both are valid (although the one at <span class="ent">➋</span> isn’t useful). The function call to <span class="literal">printf</span> <span class="ent">➌</span> is also an expression statement.</p>&#13;
<h3 class="h3" id="ch08lev1sec2"><strong>Compound Statements</strong></h3>&#13;
<p class="indent"><em>Compound statements</em>, also called <em>blocks</em>, are a sequence of statements enclosed by braces <span class="literal">{ }</span>. Blocks are useful in control structures like <span class="literal">if</span> statements, because you might want multiple statements to execute rather than one.</p>&#13;
<p class="indent">Each block declares a new scope, which is called a <em>block scope</em>. As you learned in <a href="ch04.xhtml#ch04">Chapter 4</a>, objects with automatic storage duration declared within a block scope have lifetimes bound by the block. Variables declared within a block get destroyed in a well-defined order: the reverse of the order in which they were declared.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex02">Listing 8-2</a> uses the trusty <span class="literal">Tracer</span> class from <a href="ch04.xhtml#ch04ex05">Listing 4-5</a> (on <a href="ch04.xhtml#page_97">page 97</a>) to explore block scope.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Tracer {&#13;
  Tracer(const char* name) : name{ name } {&#13;
    printf("%s constructed.\n", name);&#13;
  }&#13;
  ~Tracer() {&#13;
    printf("%s destructed.\n", name);&#13;
  }&#13;
private:&#13;
  const char* const name;&#13;
};&#13;
&#13;
int main() {&#13;
  Tracer main{ "main" }; <span class="ent">➊</span>&#13;
  {&#13;
    printf("Block a\n"); <span class="ent">➋</span>&#13;
    Tracer a1{ "a1" }; <span class="ent">➌</span>&#13;
    Tracer a2{ "a2" }; <span class="ent">➍</span>&#13;
<span epub:type="pagebreak" id="page_213"/>  }&#13;
  {&#13;
    printf("Block b\n"); <span class="ent">➎</span>&#13;
    Tracer b1{ "b1" }; <span class="ent">➏</span>&#13;
    Tracer b<a id="_idTextAnchor390"/>2{ "b2" }; <span class="ent">➐</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">main constructed. <span class="ent">➊</span></span>&#13;
<span class="color1">Block a <span class="ent">➋</span></span>&#13;
<span class="color1">a1 constructed. <span class="ent">➌</span></span>&#13;
<span class="color1">a2 constructed.<span class="ent">➍</span></span>&#13;
<span class="color1">a2 destructed.</span>&#13;
<span class="color1">a1 destructed.</span>&#13;
<span class="color1">Block b <span class="ent">➎</span></span>&#13;
<span class="color1">b1 constructed. <span class="ent">➏</span></span>&#13;
<span class="color1">b2 constructed. <span class="ent">➐</span></span>&#13;
<span class="color1">b2 destructed.</span>&#13;
<span class="color1">b1 destructed.</span>&#13;
<span class="color1">main destructed.</span></pre>&#13;
<p class="listing"><a id="ch08ex02"/><em>Listing 8-2: A program exploring compound statements with the <span class="literal">Tracer</span> class</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex02">Listing 8-2</a> begins by initializing a <span class="literal">Tracer</span> called <span class="literal">main</span> <span class="ent">➊</span>. Next, you generate two compound statements. The first compound statement begins with a left brace <span class="literal">{</span> followed by the block’s first statement, which prints <span class="literal">Block a</span> <span class="ent">➋</span>. You create two <span class="literal">Tracers</span>, <span class="literal">a1</span> <span class="ent">➌</span> and <span class="literal">a2</span> <span class="ent">➍</span>, and then close the block with a right brace <span class="literal">}</span>. These two tracers get destructed once execution passes through <span class="literal">Block a</span>. Notice that these two tracers destruct in reverse order from their initialization: <span class="literal">a2</span> then <span class="literal">a1</span>.</p>&#13;
<p class="indent">Also notice another compound statement following <span class="literal">Block a</span>, where you print <span class="literal">Block b</span> <span class="ent">➎</span> and then construct two tracers, <span class="literal">b1</span> <span class="ent">➏</span> and <span class="literal">b2</span> <span class="ent">➐</span>. Its behavior is identical: <span class="literal">b2</span> destructs followed by <span class="literal">b1</span>. Once execution passes through <span class="literal">Block b</span>, the scope of <span class="literal">main</span> ends and <span class="literal">Tracer main</span> finally destructs.</p>&#13;
<h3 class="h3" id="ch08lev1sec3"><strong>Declaration Statements</strong></h3>&#13;
<p class="noindent"><em>Declaration statements</em> (or just <em>declarations</em>) introduce identifiers, such as functions, templates, and namespaces, into your programs. This section explores some new features of these familiar declarations, as well as type aliases, attributes, and structured bindings.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The expression <span class="literal">static_assert</span>, which you learned about in <a href="ch06.xhtml#ch06">Chapter 6</a>, is also a declaration statement.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec1"><strong><em>Functions</em></strong></h4>&#13;
<p class="noindent">A <em>function declaration</em>, also called the function’s <em>signature</em> or <em>prototype</em>, specifies a function’s inputs and outputs. The declaration doesn’t need to include <span epub:type="pagebreak" id="page_214"/>parameter names, only their types. For example, the following line declares a function called <span class="literal">randomize</span> that takes a <span class="literal">uint32_t</span> reference and returns <span class="literal">void</span>:</p>&#13;
<pre>void randomize(uint32_t&amp;);</pre>&#13;
<p class="indent">Functions that aren’t member functions are called <em>non-member functions</em>, or sometimes <em>free functions</em>, and they’re always declared outside of <span class="literal">main()</span> at namespace scope. A <em>function definition</em> includes the function declaration as well as the function’s body. A function’s declaration defines a function’s interface, whereas a function’s definition defines its implementation. For example, the following definition is one possible implementation of the <span class="literal">ran</span><span class="literal">domize</span> function:</p>&#13;
<pre>void randomize(uint32_t&amp; x) {&#13;
  x = 0x3FFFFFFF &amp; (0x41C64E6D * x + 12345) % 0x80000000;&#13;
}</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This <span class="literal">randomize</span> implementation is a linear congruential generator, a primitive kind of random number generator. See “Further Reading” on <a href="ch08.xhtml#page_241">page 241</a> for sources of more information on generating random numbers.</em></p>&#13;
</div>&#13;
<p class="indent">As you’ve probably noticed, function declarations are optional. So why do they exist?</p>&#13;
<p class="indent">The answer is that you can use declared functions throughout your code as long as they’re eventually defined somewhere. Your compiler tool chain can figure it out. (You’ll learn how this works in <a href="ch21.xhtml#ch21">Chapter 21</a>.)</p>&#13;
<p class="indent">The program in <a href="ch08.xhtml#ch08ex03">Listing 8-3</a> determines how many iterations the random number generator takes to get from the number 0x4c4347 to the number 0x474343.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
void randomize(uint32_t&amp;); <span class="ent">➊</span>&#13;
&#13;
int main() {&#13;
  size_t iterations{}; <span class="ent">➋</span>&#13;
  uint32_t number{ 0x4c4347 }; <span class="ent">➌</span>&#13;
  while (number != 0x474343) { <span class="ent">➍</span>&#13;
    randomize(number); <span class="ent">➎</span>&#13;
    ++iterations; <span class="ent">➏</span>&#13;
  }&#13;
  printf("%zu", iterations); <span class="ent">➐</span>&#13;
}&#13;
&#13;
void randomize(uint32_t&amp; x) {&#13;
  x = 0x3FFFFFFF &amp; (0x41C64E6D * x + 12345) % 0x80000000; <span class="ent">➑</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1"><span epub:type="pagebreak" id="page_215"/>927393188 <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch08ex03"/><em>Listing 8-3: A program that uses a function in <span class="literal">main</span> that isn’t defined until later</em></p>&#13;
<p class="indent">First, you declare <span class="literal">randomize</span> <span class="ent">➊</span>. Within <span class="literal">main</span>, you initialize an <span class="literal">iterations</span> counter variable to zero <span class="ent">➋</span> and a <span class="literal">number</span> variable to 0x4c4347 <span class="ent">➌</span>. A <span class="literal">while</span> loop checks whether <span class="literal">number</span> equals the target 0x4c4347 <span class="ent">➍</span>. If it doesn’t, you invoke <span class="literal">randomize</span> <span class="ent">➎</span> and increment <span class="literal">iterations</span> <span class="ent">➏</span>. Notice that you haven’t yet defined <span class="literal">randomize</span>. Once <span class="literal">number</span> equals the target, you print the number of <span class="literal">iterations</span> <span class="ent">➐</span> before returning from <span class="literal">main</span>. Finally, you define <span class="literal">randomize</span> <span class="ent">➑</span>. The program’s output shows that it takes almost a billion iterations to randomly draw the target value.</p>&#13;
<p class="indent">Try to delete the definition of <span class="literal">randomize</span> and recompile. You should get an error stating that the definition of <span class="literal">randomize</span> couldn’t be found.</p>&#13;
<p class="indent">You can similarly separate method declarations from their definitions. As with non-member functions, you can declare a method by omitting its body. For example, the following <span class="literal">RandomNumberGenerator</span> class replaces the <span class="literal">ran</span><span class="literal">domize</span> function with <span class="literal">next</span>:</p>&#13;
<pre>struct RandomNumberGenerator {&#13;
  explicit RandomNumberGenerator(uint32_t seed) <span class="ent">➊</span>&#13;
    : number{ seed } {} <span class="ent">➋</span>&#13;
  uint32_t next(); <span class="ent">➌</span>&#13;
private:&#13;
  uint32_t number;&#13;
};</pre>&#13;
<p class="indent">You can construct a <span class="literal">RandomNumberGenerator</span> with a <span class="literal">seed</span> value <span class="ent">➊</span>, which it uses to initialize the <span class="literal">number</span> member variable <span class="ent">➋</span>. You’ve declared the <span class="literal">next</span> function using the same rules as non-member functions <span class="ent">➌</span>. To provide the definition of <span class="literal">next</span>, you must use the scope resolution operator and the class name to identify which method you want to define. Otherwise, defining a method is the same as defining a non-member function:</p>&#13;
<pre>uint32_t<span class="ent">➊</span> RandomNumberGenerator::<span class="ent">➋</span>next() {&#13;
  number = 0x3FFFFFFF &amp; (0x41C64E6D * number + 12345) % 0x80000000; <span class="ent">➌</span>&#13;
  return number; <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="indent">This definition shares the same return type as the declaration <span class="ent">➊</span>. The <span class="literal">RandomNumberGenerator::</span> construct specifies that you’re defining a method <span class="ent">➋</span>. The function details are essentially the same <span class="ent">➌</span>, except you’re returning a copy of the random number generator’s state rather than writing into a parameter reference <span class="ent">➍</span>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex04">Listing 8-4</a> illustrates how you can refactor <a href="ch08.xhtml#ch08ex03">Listing 8-3</a> to incorporate <span class="literal">RandomNumberGenerator</span>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
<span epub:type="pagebreak" id="page_216"/>struct RandomNumberGenerator {&#13;
  explicit RandomNumberGenerator(uint32_t seed)&#13;
    : iterations{}<span class="ent">➊</span>, number { seed }<span class="ent">➋</span> {}&#13;
  uint32_t next(); <span class="ent">➌</span>&#13;
  size_t get_iterations() const; <span class="ent">➍</span>&#13;
private:&#13;
  size_t iterations;&#13;
  uint32_t number;&#13;
};&#13;
&#13;
int main() {&#13;
  RandomNumberGenerator rng{ 0x4c4347 }; <span class="ent">➎</span>&#13;
  while (rng.next() != 0x474343) { <span class="ent">➏</span>&#13;
    // Do nothing...&#13;
  }&#13;
  printf("%zu", rng.get_iterations()); <span class="ent">➐</span>&#13;
}&#13;
&#13;
uint32_t RandomNumberGenerator::next() { <span class="ent">➑</span>&#13;
  ++iterations;&#13;
  number = 0x3FFFFFFF &amp; (0x41C64E6D * number + 12345) % 0x80000000;&#13;
  return number;&#13;
}&#13;
&#13;
size_t RandomNumberGenerator::get_iterations() const { <span class="ent">➒</span>&#13;
  return iterations;&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">927393188 <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch08ex04"/><em>Listing 8-4: A refactor of <a href="ch08.xhtml#ch08ex03">Listing 8-3</a> using a <span class="literal">RandomNumberGenerator</span> class</em></p>&#13;
<p class="indent">As in <a href="ch08.xhtml#ch08ex03">Listing 8-3</a>, you’ve separated declaration from definition. After declaring a constructor that initializes an <span class="literal">iterations</span> member to zero <span class="ent">➊</span> and sets its <span class="literal">number</span> member to a <span class="literal">seed</span> <span class="ent">➋</span>, the <span class="literal">next</span> <span class="ent">➌</span> and <span class="literal">get_iterations</span> <span class="ent">➍</span> method declarations don’t contain implementations. Within <span class="literal">main</span>, you initialize the <span class="literal">RandomNumberGenerator</span> class with your seed value of 0x4c4347 <span class="ent">➎</span> and invoke the <span class="literal">next</span> method to extract new random numbers <span class="ent">➏</span>. The results are the same <span class="ent">➐</span>. As before, the definitions of <span class="literal">next</span> and <span class="literal">get_iterations</span> follow their use in <span class="literal">main</span> <span class="ent">➑➒</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The utility of separating definition and declaration might not be apparent because you’ve been dealing with single-source-file programs so far. <a href="ch21.xhtml#ch21">Chapter 21</a> explores multiple-source-file programs where separating declaration and definition provides major benefits.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec2"><strong><em>Namespaces</em></strong></h4>&#13;
<p class="noindent">Namespaces prevent naming conflicts. In large projects or when importing libraries, namespaces are essential for disambiguating exactly the symbols you’re looking for.</p>&#13;
<h5 class="h5" id="ch08lev3sec1"><strong><span epub:type="pagebreak" id="page_217"/>Placing Symbols Within Namespaces</strong></h5>&#13;
<p class="noindent">By default, all symbols you declare go into the <em>global namespace</em>. The global namespace contains all the symbols that you can access without adding any namespace qualifiers. Aside from several classes in the <span class="literal">std</span> namespace, you’ve been using objects living exclusively in the global namespace.</p>&#13;
<p class="indent">To place a symbol within a namespace other than the global namespace, you declare the symbol within a <em>namespace block</em>. A namespace block has the following form:</p>&#13;
<pre>namespace BroopKidron13 {&#13;
  // All symbols declared within this block&#13;
  // belong to the BroopKidron13 namespace&#13;
}</pre>&#13;
<p class="indent">Namespaces can be nested in one of two ways. First, you can simply nest namespace blocks:</p>&#13;
<pre>namespace BroopKidron13 {&#13;
  namespace Shaltanac {&#13;
    // All symbols declared within this block&#13;
    // belong to the BroopKidron13::Shaltanac namespace&#13;
  }&#13;
}</pre>&#13;
<p class="indent">Second, you can use the scope-resolution operator:</p>&#13;
<pre>namespace BroopKidron13::Shaltanac {&#13;
  // All symbols declared within this block&#13;
  // belong to the BroopKidron13::Shaltanac namespace&#13;
}</pre>&#13;
<p class="indent">The latter approach is more succinct.</p>&#13;
<h5 class="h5" id="ch08lev3sec2"><strong>Using Symbols in Namespaces</strong></h5>&#13;
<p class="noindent">To use a symbol within a namespace, you can always use the scope-resolution operator to specify the fully qualified name of a symbol. This allows you to prevent naming conflicts in large projects or when you’re using a third-party library. If you and another programmer use the same symbol, you can avoid ambiguity by placing the symbol within a namespace.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex05">Listing 8-5</a> illustrates how you can use fully qualified symbol names to access a symbol within a namespace.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
namespace BroopKidron13::Shaltanac { <span class="ent">➊</span>&#13;
  enum class Color { <span class="ent">➋</span>&#13;
    Mauve,&#13;
    Pink,&#13;
    Russet&#13;
<span epub:type="pagebreak" id="page_218"/>  };&#13;
}&#13;
&#13;
int main() {&#13;
  const auto shaltanac_grass{ BroopKidron13::Shaltanac::Color::Russet<span class="ent">➌</span> };&#13;
  if(shaltanac_grass == BroopKidron13::Shaltanac::Color::Russet) {&#13;
    printf("The other Shaltanac's joopleberry shrub is always "&#13;
           "a more mauvey shade of pinky russet.");&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The other Shaltanac's joopleberry shrub is always a more mauvey shade of pinky russet.</span></pre>&#13;
<p class="listing"><a id="ch08ex05"/><em>Listing 8-5: Nested namespace blocks using the scope-resolution operator</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex05">Listing 8-5</a> uses nested namespaces <span class="ent">➊</span> and declares a <span class="literal">Color</span> type <span class="ent">➋</span>. To use <span class="literal">Color</span>, you apply the scope-resolution operator to specify the full name of the symbol, <span class="literal">BroopKidron13::Shaltanac::Color</span>. Because <span class="literal">Color</span> is an <span class="literal">enum class</span>, you use the scope-resolution operator to access its values, as when you assign <span class="literal">shaltanac_grass</span> to <span class="literal">Russet</span> <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch08lev3sec3"><strong>Using Directives</strong></h5>&#13;
<p class="noindent">You can employ a <span class="literal">using</span> <em>directive</em> to avoid a lot of typing. A <span class="literal">using</span> directive imports a symbol into a block or, if you declare a <span class="literal">using</span> directive at namespace scope, into the current namespace. Either way, you have to type the full namespace path only once. The usage has the following pattern:</p>&#13;
<pre>using <span class="codeitalic1">my-type</span>;</pre>&#13;
<p class="indent">The corresponding <span class="codeitalic">my-type</span> gets imported into the current namespace or block, meaning you no longer have to use its full name. <a href="ch08.xhtml#ch08ex06">Listing 8-6</a> refactors <a href="ch08.xhtml#ch08ex05">Listing 8-5</a> with a using directive.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
namespace BroopKidron13::Shaltanac {&#13;
  enum class Color {&#13;
    Mauve,&#13;
    Pink,&#13;
    Russet&#13;
  };&#13;
}&#13;
&#13;
int main() {&#13;
  using BroopKidron13::Shaltanac::Color; <span class="ent">➊</span>&#13;
  const auto shaltanac_grass = Color::Russet<span class="ent">➋</span>;&#13;
  if(shaltanac_grass == Color::Russet<span class="ent">➌</span>) {&#13;
    printf("The other Shaltanac's joopleberry shrub is always "&#13;
           "a more mauvey shade of pinky russet.");&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1"><span epub:type="pagebreak" id="page_219"/>The other Shaltanac's joopleberry shrub is always a more mauvey shade of pinky russet.</span></pre>&#13;
<p class="listing"><a id="ch08ex06"/><em>Listing 8-6: A refactor of <a href="ch08.xhtml#ch08ex05">Listing 8-5</a> employing a using directive</em></p>&#13;
<p class="indent">With a <span class="literal">using</span> directive <span class="ent">➊</span> within <span class="literal">main</span>, you no longer have to type the namespace <span class="literal">BroopKidron13::Shaltanac</span> to use <span class="literal">Color</span> <span class="ent">➋</span><span class="ent">➌</span>.</p>&#13;
<p class="indent">If you’re careful, you can introduce all the symbols from a given namespace into the global namespace with the <span class="literal">using namespace</span> directive.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex07">Listing 8-7</a> elaborates <a href="ch08.xhtml#ch08ex06">Listing 8-6</a>: the namespace <span class="literal">BroopKidron13::Shaltanac</span> contains multiple symbols, which you want to import into the global namespace to avoid a lot of typing.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
namespace BroopKidron13::Shaltanac {&#13;
  enum class Color {&#13;
    Mauve,&#13;
    Pink,&#13;
    Russet&#13;
  };&#13;
&#13;
  struct JoopleberryShrub {&#13;
    const char* name;&#13;
    Color shade;&#13;
  };&#13;
&#13;
  bool is_more_mauvey(const JoopleberryShrub&amp; shrub) {&#13;
    return shrub.shade == Color::Mauve;&#13;
  }&#13;
}&#13;
&#13;
using namespace BroopKidron13::Shaltanac; <span class="ent">➊</span>&#13;
int main() {&#13;
  const JoopleberryShrub<span class="ent">➋</span> yours{&#13;
    "The other Shaltanac",&#13;
    Color::Mauve<span class="ent">➌</span>&#13;
  };&#13;
&#13;
  if (is_more_mauvey(yours)<span class="ent">➍</span>) {&#13;
    printf("%s's joopleberry shrub is always a more mauvey shade of pinky"&#13;
           "russet.", yours.name);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The other Shaltanac's joopleberry shrub is always a more mauvey shade of pinky&#13;
russet.</span></pre>&#13;
<p class="listing"><a id="ch08ex07"/><em>Listing 8-7: A refactor of <a href="ch08.xhtml#ch08ex06">Listing 8-6</a> with multiple symbols imported into the global namespace</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_220"/>With a <span class="literal">using namespace</span> directive <span class="ent">➊</span>, you can use classes <span class="ent">➋</span>, enum classes <span class="ent">➌</span>, functions <span class="ent">➍</span>, and so on within your program without having to type fully qualified names. Of course, you need to be very careful about clobbering existing types in the global namespace. Usually, it’s a bad idea to have too many <span class="literal">using namespace</span> directives appear in a single translation unit.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You should never put a <span class="codeitalic">using namespace</span> directive within a header file. Every source file that includes your header will dump all the symbols from that using directive into the global namespace. This can cause issues that are very difficult to debug.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec3"><strong><em>Type Aliasing</em></strong></h4>&#13;
<p class="indent">A <em>type alias</em> defines a name that refers to a previously defined name. You can use a type alias as a synonym for the existing type name.</p>&#13;
<p class="indent">There is no difference between a type and any type aliases referring to it. Also, type aliases cannot change the meaning of an existing type name.</p>&#13;
<p class="indent">To declare a type alias, you use the following format, where <span class="codeitalic">type-alias</span> is the type alias name and <span class="codeitalic">type-id</span> is the target type:</p>&#13;
<pre>using <span class="codeitalic1">type-alias</span> = <span class="codeitalic1">type-id</span>;</pre>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex08">Listing 8-8</a> employs two type aliases, <span class="literal">String</span> and <span class="literal">ShaltanacColor</span>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
namespace BroopKidron13::Shaltanac {&#13;
  enum class Color {&#13;
    Mauve,&#13;
    Pink,&#13;
    Russet&#13;
  };&#13;
}&#13;
&#13;
using String = const char[260]; <span class="ent">➊</span>&#13;
using ShaltanacColor = BroopKidron13::Shaltanac::Color; <span class="ent">➋</span>&#13;
&#13;
int main() {&#13;
  const auto my_color{ ShaltanacColor::Russet }; <span class="ent">➌</span>&#13;
  String saying { <span class="ent">➍</span>&#13;
    "The other Shaltanac's joopleberry shrub is "&#13;
    "always a more mauvey shade of pinky ru<a id="_idTextAnchor393"/>sset."&#13;
  };&#13;
  if (my_color == ShaltanacColor::Russet) {&#13;
    printf("%s", saying);&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch08ex08"/><em>Listing 8-8: A refactor of <a href="ch08.xhtml#ch08ex07">Listing 8-7</a> with a type alias</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex08">Listing 8-8</a> declares a type alias <span class="literal">String</span> that refers to a <span class="literal">const char[260]</span> <span class="ent">➊</span>. This listing also declares a <span class="literal">ShaltanacColor</span> type alias, which refers to <span epub:type="pagebreak" id="page_221"/><span class="literal">BroopKidron13::Shaltanac::Color</span> <span class="ent">➋</span>. You can use these type aliases as drop-in replacements to clean up code. Within <span class="literal">main</span>, you use <span class="literal">ShaltanacColor</span> to remove all the nested namespaces <span class="ent">➌</span> and <span class="literal">String</span> to make the declaration of <span class="literal">saying</span> cleaner <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Type aliases can appear in any scope—block, class, or namespace.</em></p>&#13;
</div>&#13;
<p class="indent">You can introduce template parameters into type aliases. This enables two important usages:</p>&#13;
<ul>&#13;
<li class="noindent">You can perform partial application on template parameters. <em>Partial application</em> is the process of fixing some number of arguments to a template, producing another template with fewer template parameters.</li>&#13;
<li class="noindent">You can define a type alias for a template with a fully specified set of template parameters.</li>&#13;
</ul>&#13;
<p class="indent">Template instantiations can be quite verbose, and type aliases help you avoid carpal tunnel syndrome.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex09">Listing 8-9</a> declares a <span class="literal">NarrowCaster</span> class with two template parameters. You then use a type alias to partially apply one of its parameters and produce a new type.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
template &lt;typename To, typename From&gt;&#13;
struct NarrowCaster const { <span class="ent">➊</span>&#13;
  To cast(From value) {&#13;
    const auto converted = static_cast&lt;To&gt;(value);&#13;
    const auto backwards = static_cast&lt;From&gt;(converted);&#13;
    if (value != backwards) throw std::runtime_error{ "Narrowed!" };&#13;
    return converted;&#13;
  }&#13;
};&#13;
&#13;
template &lt;typename From&gt;&#13;
using short_caster = NarrowCaster&lt;short, From&gt;; <span class="ent">➋</span>&#13;
&#13;
int main() {&#13;
  try {&#13;
    const short_caster&lt;int&gt; caster; <span class="ent">➌</span>&#13;
    const auto cyclic_short = caster.cast(142857);&#13;
    printf("cyclic_short: %d\n", cyclic_short);&#13;
  } catch (const std::runtime_error&amp; e) {&#13;
    printf("Exception: %s\n", e.what()); <span class="ent">➍</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Exception: Narrowed! <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch08ex09"/><em>Listing 8-9: A partial application of the <span class="literal">NarrowCaster</span> class using a type alias</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_222"/>First, you implement a <span class="literal">NarrowCaster</span> template class that has the same functionality as the <span class="literal">narrow_cast</span> function template in <a href="ch06.xhtml#ch06ex06">Listing 6-6</a> (on <a href="ch06.xhtml#page_154">page 154</a>): it will perform a <span class="literal">static_cast</span> and then check for narrowing <span class="ent">➊</span>. Next, you declare a type alias <span class="literal">short_caster</span> that partially applies <span class="literal">short</span> as the <span class="literal">To</span> type to <span class="literal">NarrowCast</span>. Within <span class="literal">main</span>, you declare a <span class="literal">caster</span> object of type <span class="literal">short_caster&lt;int&gt;</span> <span class="ent">➌</span>. The single template parameter in the <span class="literal">short_caster</span> type alias gets applied to the remaining type parameter from the type alias—<span class="literal">From</span> <span class="ent">➋</span>. In other words, the type <span class="literal">short_cast&lt;int&gt;</span> is synonymous with <span class="literal">NarrowCaster&lt;short, int&gt;</span>. In the end, the result is the same: with a 2-byte short, you get a narrowing exception when trying to cast an <span class="literal">int</span> with the value 142857 into a <span class="literal">short</span> <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch08lev2sec4"><strong><em>Structured Bindings</em></strong></h4>&#13;
<p class="noindent"><em>Structured bindings</em> enable you to unpack objects into their constituent elements. Any type whose non-static data members are public can be unpacked this way—for example, the POD (plain-old-data class) types introduced in <a href="ch02.xhtml#ch02">Chapter 2</a>. The <em>structured binding syntax</em> is as follows:</p>&#13;
<pre>auto [<span class="codeitalic1">object-1</span>, <span class="codeitalic1">object-2</span>, ...] = <span class="codeitalic1">plain-old-data</span>;</pre>&#13;
<p class="indent">This line will initialize an arbitrary number of objects (<span class="codeitalic">object-1</span>, <span class="codeitalic">object-2</span>, and so on) by peeling them off a POD object one by one. The objects peel off the POD from top to bottom, and they fill in the structured binding from left to right. Consider a <span class="literal">read_text_file</span> function that takes a string argument corresponding to the file path. Such a function might fail, for example, if a file is locked or doesn’t exist. You have two options for handling errors:</p>&#13;
<ul>&#13;
<li class="noindent">You can throw an exception within <span class="literal">read_text_file</span>.</li>&#13;
<li class="noindent">You can return a success status code from the function.</li>&#13;
</ul>&#13;
<p class="indent">Let’s explore the second option.</p>&#13;
<p class="indent">The POD type in <a href="ch08.xhtml#ch08ex10">Listing 8-10</a> will serve as a fine return type from the <span class="literal">read_text_file</span> function.</p>&#13;
<pre>struct TextFile {&#13;
  bool success; <span class="ent">➊</span>&#13;
  const char* contents; <span class="ent">➋</span>&#13;
  size_t n_bytes; <span class="ent">➌</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch08ex10"/><em>Listing 8-10: A <span class="literal">TextFile</span> type that will be returned by the <span class="literal">read_text_file</span> function</em></p>&#13;
<p class="indent">First, a flag communicates to the caller whether the function call was a <span class="literal">success</span> <span class="ent">➊</span>. Next is the contents of the <span class="literal">file</span> <span class="ent">➋</span> and its size <span class="literal">n_bytes</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The prototype of <span class="literal">read_text_file</span> looks like this:</p>&#13;
<pre>TextFile read_text_file(const char* path);</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_223"/>You can use a structured binding declaration to unpack a <span class="literal">TextFile</span> into its parts within your program, as in <a href="ch08.xhtml#ch08ex11">Listing 8-11</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct TextFile { <span class="ent">➊</span>&#13;
  bool success;&#13;
  const char* data;&#13;
  size_t n_bytes;&#13;
};&#13;
&#13;
TextFile read_text_file(const char* path) { <span class="ent">➋</span>&#13;
  const static char contents[]{ "Sometimes the goat is you." };&#13;
  return TextFile{&#13;
    true,&#13;
    contents,&#13;
    sizeof(contents)&#13;
  };&#13;
}&#13;
&#13;
int main() {&#13;
  const auto [success, contents, length]<span class="ent">➌</span> = read_text_file("REAMDE.txt"); <span class="ent">➍</span>&#13;
  if (success<span class="ent">➎</span>) {&#13;
    p<a id="_idTextAnchor395"/>rintf("Read %zu bytes: %s\n", length<span class="ent">➏</span>, contents<span class="ent">➐</span>);&#13;
  } else {&#13;
    printf("Failed to open REAMDE.txt.");&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Read 27 bytes: Sometimes the goat is you.</span></pre>&#13;
<p class="listing"><a id="ch08ex11"/><em>Listing 8-11: A program simulating the reading of a text file that returns a POD that you use in a structured binding</em></p>&#13;
<p class="indent">You’ve declared the <span class="literal">TextFile</span> <span class="ent">➊</span> and then provided a dummy definition for <span class="literal">read_text_file</span> <span class="ent">➋</span>. (It doesn’t actually read a file; more on that in <a href="part02.xhtml#part02">Part II</a>.)</p>&#13;
<p class="indent">Within <span class="literal">main</span>, you invoke <span class="literal">read_text_file</span> <span class="ent">➍</span> and use a structured binding declaration to unpack the results into three distinct variables: <span class="literal">success</span>, <span class="literal">contents</span>, and <span class="literal">length</span> <span class="ent">➌</span>. After structured binding, you can use all these variables as though you had declared them individually <span class="ent">➎</span><span class="ent">➏</span><span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The types within a structured binding declaration don’t have to match.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec5"><strong><em>Attributes</em></strong></h4>&#13;
<p class="indent">Attributes apply implementation-defined features to an expression statement. You introduce attributes using double brackets <span class="literal">[[ ]]</span> containing a list of one or more comma-separated attribute elements.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08tab01">Table 8-1</a> lists the standard attributes.</p>&#13;
<p class="tabcap" id="ch08tab01"><span epub:type="pagebreak" id="page_224"/><strong>Table 8-1:</strong> The Standard Attributes</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Attribute</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Meaning</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">[[noreturn]]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Indicates that a function doesn’t return.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">[[deprecated("</span><span class="codeitalic">reason</span><span class="literal">")]]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Indicates that this expression is deprecated; that is, its use is discouraged. The <span class="literal">"reason"</span> is optional and indicates the reason for deprecation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">[[fallthrough]]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Indicates that a switch case intends to fall through to the next switch case. This avoids compiler errors that will check for switch case fallthrough, because it’s uncommon.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">[[nodiscard]]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Indicates that the following function or type declaration should be used. If code using this element discards the value, the compiler should emit a warning.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">[[maybe_unused]]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Indicates that the following element might be unused and that the compiler shouldn’t warn about it.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">[[carries_dependency]]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Used within the <span class="literal">&lt;atomic&gt;</span> header to help the compiler optimize certain memory operations. You’re unlikely to encounter this directly.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex12">Listing 8-12</a> demonstrates using the <span class="literal">[[noreturn]]</span> attribute by defining a function that never returns.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
[[noreturn]] void pitcher() { <span class="ent">➊</span>&#13;
  throw std::runtime_error{ "Knuckleball." }; <span class="ent">➋</span>&#13;
}&#13;
&#13;
int main() {&#13;
  try {&#13;
    pitcher(); <span class="ent">➌</span>&#13;
  } catch(const std::exception&amp; e) {&#13;
    printf("exception: %s\n", e.what()); <span class="ent">➍</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Exception: Knuckleball. <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch08ex12"/><em>Listing 8-12: A program illustrating the use of the <span class="literal">[[noreturn]]</span> attribute</em></p>&#13;
<p class="indent">First, you declare the <span class="literal">pitcher</span> function with the <span class="literal">[[noreturn]]</span> attribute <span class="ent">➊</span>. Within this function, you throw an exception <span class="ent">➋</span>. Because you always throw an exception, <span class="literal">pitcher</span> never returns (hence the <span class="literal">[[noreturn]]</span> attribute). Within <span class="literal">main</span>, you invoke <span class="literal">pitcher</span> <span class="ent">➌</span> and handle the caught exception <span class="ent">➍</span>. Of course, this listing works without the <span class="literal">[[noreturn]]</span> attribute. But giving this information to the compiler allows it to reason more completely on your code (and potentially to optimize your program).</p>&#13;
<p class="indent">The situations in which you’ll need to use an attribute are rare, but they convey useful information to the compiler nonetheless.</p>&#13;
<h3 class="h3" id="ch08lev1sec4"><strong><span epub:type="pagebreak" id="page_225"/>Selection Statements</strong></h3>&#13;
<p class="indent"><em>Selection statements</em> express conditional control flow. The two varieties of selection statements are the <span class="literal">if</span> statement and the <span class="literal">switch</span> statement.</p>&#13;
<h4 class="h4" id="ch08lev2sec6"><strong><em>if Statements</em></strong></h4>&#13;
<p class="indent">The <span class="literal">if</span> statement has the familiar form shown in <a href="ch08.xhtml#ch08ex13">Listing 8-13</a>.</p>&#13;
<pre>if (<span class="codeitalic1">condition-1</span>) {&#13;
  // Execute only if condition-1 is true <span class="ent">➊</span>&#13;
} else if (<span class="codeitalic1">condition-2</span>) { // optional&#13;
  // Execute only if condition-2 is true <span class="ent">➋</span>&#13;
}&#13;
// ... as many else ifs as desired&#13;
--<span class="codeitalic1">snip</span>--&#13;
} else { // optional&#13;
  // Execute only if none of the conditionals is true <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch08ex13"/><em>Listing 8-13: The syntax of the <span class="literal">if</span> statement</em></p>&#13;
<p class="indent">Upon encountering an <span class="literal">if</span> statement, you evaluate the <span class="codeitalic">condition-1</span> expression first. If it’s <span class="literal">true</span>, the block at <span class="ent">➊</span> is executed and the <span class="literal">if</span> statement stops executing (none of the <span class="literal">else if</span> or <span class="literal">else</span> statements are considered). If it’s <span class="literal">false</span>, the <span class="literal">else if</span> statements’ conditions evaluate in order. These are optional, and you can supply as many as you like.</p>&#13;
<p class="indent">If <span class="codeitalic">condition-2</span> evaluates to <span class="literal">true</span>, for example, the block at <span class="ent">➋</span> will execute and none of the remaining <span class="literal">else if</span> or <span class="literal">else</span> statements are considered. Finally, the <span class="literal">else</span> block at <span class="ent">➌</span> executes if all of the preceding conditions evaluate to <span class="literal">false</span>. Like the <span class="literal">else if</span> blocks, the <span class="literal">else</span> block is optional.</p>&#13;
<p class="indent">The function template in <a href="ch08.xhtml#ch08ex14">Listing 8-14</a> converts an <span class="literal">else</span> argument into <span class="literal">Positive</span>, <span class="literal">Negative</span>, or <span class="literal">Zero</span>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
constexpr const char* sign(const T&amp; x) {&#13;
  const char* result{};&#13;
  if (x == 0) { <span class="ent">➊</span>&#13;
    result = "zero";&#13;
  } else if (x &gt; 0) { <span class="ent">➋</span>&#13;
    result = "positive";&#13;
  } else { <span class="ent">➌</span>&#13;
    result = "negative";&#13;
  }&#13;
  return result;&#13;
}&#13;
&#13;
int main() {&#13;
  printf("float 100 is %s\n", sign(100.0f));&#13;
  printf("int  -200 is %s\n", sign(-200));&#13;
<span epub:type="pagebreak" id="page_226"/>  printf("char    0 is %s\n", sign(char{}));&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">float 100 is positive</span>&#13;
<span class="color1">int  -200 is negative</span>&#13;
<span class="color1">char    0 is zero</span></pre>&#13;
<p class="listing"><a id="ch08ex14"/><em>Listing 8-14: An example usage of the <span class="literal">if</span> statement</em></p>&#13;
<p class="indent">The <span class="literal">sign</span> function takes a single argument and determines if it’s equal to 0 <span class="ent">➊</span>, greater than 0 <span class="ent">➋</span>, or less than 0 <span class="ent">➌</span>. Depending on which condition matches, it sets the automatic variable result equal to one of three strings—<span class="literal">zero</span>, <span class="literal">positive</span>, or <span class="literal">negative</span>—and returns this value to the caller.</p>&#13;
<h5 class="h5" id="ch08lev3sec4"><strong>Initialization Statements and if</strong></h5>&#13;
<p class="indent">You can bind an object’s scope to an <span class="literal">if</span> statement by adding an <span class="literal">init-state</span><span class="literal">ment</span> to <span class="literal">if</span> and <span class="literal">else if</span> declarations, as demonstrated in <a href="ch08.xhtml#ch08ex15">Listing 8-15</a>.</p>&#13;
<pre>if (<span class="codeitalic1">init-statement</span>; <span class="codeitalic1">condition-1</span>) {&#13;
  // Execute only if condition-1 is true&#13;
} else if (<span class="codeitalic1">init-statement</span>; <span class="codeitalic1">condition-2</span>) { // optional&#13;
  // Execute only if condition-2 is true&#13;
}&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="listing"><a id="ch08ex15"/><em>Listing 8-15: An <span class="literal">if</span> statement with initializations</em></p>&#13;
<p class="indent">You can use this pattern with structured bindings to produce elegant error handling. <a href="ch08.xhtml#ch08ex16">Listing 8-16</a> refactors <a href="ch08.xhtml#ch08ex11">Listing 8-11</a> using the initialization statement to scope a <span class="literal">TextFile</span> to the <span class="literal">if</span> statement.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct TextFile {&#13;
  bool success;&#13;
  const char* data;&#13;
  size_t n_bytes;&#13;
};&#13;
&#13;
TextFile read_text_file(const char* path) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  if(const auto [success, txt, len]<span class="ent">➊</span> = read_text_file("REAMDE.txt"); success<span class="ent">➋</span>)&#13;
  {&#13;
    printf("Read %d bytes: %s\n", len, txt); <span class="ent">➌</span>&#13;
  } else {&#13;
    printf("Failed to open REAMDE.txt."); <span class="ent">➍</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1"><span epub:type="pagebreak" id="page_227"/>Read 27 bytes: Sometimes the goat is you. <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch08ex16"/><em>Listing 8-16: An extension of <a href="ch08.xhtml#ch08ex11">Listing 8-11</a> using structured binding and an <span class="literal">if</span> statement to handle errors</em></p>&#13;
<p class="indent">You’ve moved the structured binding declaration into the initialization statement portion of the <span class="literal">if</span> statement <span class="ent">➊</span>. This scopes each of the unpacked objects—<span class="literal">success</span>, <span class="literal">txt</span>, and <span class="literal">len</span>—to the <span class="literal">if</span> block. You use <span class="literal">success</span> directly within the conditional expression of <span class="literal">if</span> to determine whether <span class="literal">read_text_file</span> was successful <span class="ent">➋</span>. If it was, you print the contents of <span class="literal">REAMDE.txt</span> <span class="ent">➌</span>. If it wasn’t, you print an error message <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch08lev3sec5"><strong>constexpr if Statements</strong></h5>&#13;
<p class="noindent">You can make an <span class="literal">if</span> statement <span class="literal">constexpr</span>; such statements are known as <span class="literal">constexpr if</span> statements. A <span class="literal">constexpr if</span> statement is evaluated at compile time. Code blocks that correspond to <span class="literal">true</span> conditions get emitted, and the rest is ignored.</p>&#13;
<p class="indent">Usage of the <span class="literal">constexpr if</span> follows usage for a regular <span class="literal">if</span> statement, as demonstrated in <a href="ch08.xhtml#ch08ex17">Listing 8-17</a>.</p>&#13;
<pre>if constexpr (<span class="codeitalic1">condition-1</span>) {&#13;
  // Compile only if condition-1 is true&#13;
} else if constexpr (<span class="codeitalic1">condition-2</span>) { // optional; can be multiple else ifs&#13;
  // Compile only if condition-2 is true&#13;
}&#13;
--<span class="codeitalic1">snip</span>--&#13;
} else { // optional&#13;
  // Compile only if none of the conditionals is true&#13;
}</pre>&#13;
<p class="listing"><a id="ch08ex17"/><em>Listing 8-17: Usage of the <span class="literal">constexpr if</span> statement</em></p>&#13;
<p class="indent">In combination with templates and the <span class="literal">&lt;type_traits&gt;</span> header, <span class="literal">constexpr</span> <span class="literal">if</span> statements are extremely powerful. A major use for <span class="literal">constexpr if</span> is to provide custom behavior in a function template depending on some attributes of type parameters.</p>&#13;
<p class="indent">The function template <span class="literal">value_of</span> in <a href="ch08.xhtml#ch08ex18">Listing 8-18</a> accepts pointers, references, and values. Depending on which kind of object the argument is, <span class="literal">value_of</span> returns either the pointed-to value or the value itself.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
#include &lt;type_traits&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
auto value_of(T x<span class="ent">➊</span>) {&#13;
  if constexpr (std::is_pointer&lt;T&gt;::value) { <span class="ent">➋</span>&#13;
    if (!x) throw std::runtime_error{ "Null pointer dereference." }; <span class="ent">➌</span>&#13;
    return *x; <span class="ent">➍</span>&#13;
<span epub:type="pagebreak" id="page_228"/>  } else {&#13;
    return x; <span class="ent">➎</span>&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  unsigned long level{ 8998 };&#13;
  auto level_ptr = &amp;level;&#13;
  auto &amp;level_ref = level;&#13;
  printf("Power level = %lu\n", value_of(level_ptr)); <span class="ent">➏</span>&#13;
  ++*level_ptr;&#13;
  printf("Power level = %lu\n", value_of(level_ref)); <span class="ent">➐</span>&#13;
  ++level_ref;&#13;
  printf("It's over %lu!\n", value_of(level++)); <span class="ent">➑</span>&#13;
  try {&#13;
    level_ptr = nullptr;&#13;
    value_of(level_ptr);&#13;
  } catch(const std::exception&amp; e) {&#13;
    printf("Exception: %s\n", e.what()); <span class="ent">➒</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Power level = 8998 <span class="ent">➏</span></span>&#13;
<span class="color1">Power level = 8999 <span class="ent">➐</span></span>&#13;
<span class="color1">It's over 9000! <span class="ent">➑</span></span>&#13;
<span class="color1">Exception: Null pointer dereference. <span class="ent">➒</span></span></pre>&#13;
<p class="listing"><a id="ch08ex18"/><em>Listing 8-18: An example function template, <span class="literal">value_of</span>, employing a <span class="literal">constexpr if</span> statement</em></p>&#13;
<p class="indent">The <span class="literal">value_of</span> function template accepts a single argument <span class="literal">x</span> <span class="ent">➊</span>. You determine whether the argument is a pointer type using the <span class="literal">std::is_pointer&lt;T&gt;</span> type trait as the conditional expression in a <span class="literal">constexpr if</span> statement <span class="ent">➋</span>. In case <span class="literal">x</span> is a pointer type, you check for <span class="literal">nullptr</span> and throw an exception if one is encountered <span class="ent">➌</span>. If <span class="literal">x</span> isn’t a <span class="literal">nullptr</span>, you dereference it and return the result <span class="ent">➍</span>. Otherwise, <span class="literal">x</span> is not a pointer type, so you return it (because it is therefore a value) <span class="ent">➎</span>.</p>&#13;
<p class="indent">Within <span class="literal">main</span>, you instantiate <span class="literal">value_of</span> multiple times with an <span class="literal">unsigned long</span> pointer <span class="ent">➏</span>, an <span class="literal">unsigned long</span> reference <span class="ent">➐</span>, an <span class="literal">unsigned long</span> <span class="ent">➑</span>, and a <span class="literal">nullptr</span> <span class="ent">➒</span> respectively.</p>&#13;
<p class="indent">At runtime, the <span class="literal">constexpr if</span> statement disappears; each instantiation of <span class="literal">value_of</span> contains one branch of the selection statement or the other. You might be wondering why such a facility is useful. After all, programs are meant to do something useful at runtime, not at compile time. Just flip back to <a href="ch07.xhtml#ch07ex17">Listing 7-17</a> (on <a href="ch07.xhtml#page_206">page 206</a>), and you’ll see that compile time evaluation can substantially simplify your programs by eliminating magic values.</p>&#13;
<p class="indent">There are other examples where compile time evaluation is popular, especially when creating libraries for others to use. Because library writers usually cannot know all the ways their users will utilize their library, they need to write generic code. Often, they’ll use techniques like those you learned in <a href="ch06.xhtml#ch06">Chapter 6</a> so they can achieve compile-time polymorphism. Constructs like <span class="literal">constexpr</span> can help when writing this kind of code.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_229"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you have a C background, you’ll immediately recognize the utility of compile time evaluation when considering that it almost entirely replaces the need for preprocessor macros.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec7"><strong><em>switch Statements</em></strong></h4>&#13;
<p class="noindent"><a href="ch02.xhtml">Chapter 2</a> first introduced the venerable <span class="literal">switch</span> statement. This section delves into the addition of the initialization statement into the <span class="literal">switch</span> declaration. The usage is as follows:</p>&#13;
<pre>switch (<span class="codeitalic1">init-expression</span><span class="ent">➊</span>; <span class="codeitalic1">condition</span>) {&#13;
  case (<span class="codeitalic1">case-a</span>): {&#13;
    // Handle case-a here&#13;
  } break;&#13;
  case (<span class="codeitalic1">case-b</span>): {&#13;
    // Handle case-b here&#13;
  } break;&#13;
    // Handle other conditions as desired&#13;
  default: {&#13;
    // Handle the default case here&#13;
  }&#13;
}</pre>&#13;
<p class="indent">As with <span class="literal">if</span> statements, you can instantiate within <span class="literal">switch</span> statements <span class="ent">➊</span>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex19">Listing 8-19</a> employs an initialization statement within a <span class="literal">switch</span> statement.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
enum class Color { <span class="ent">➊</span>&#13;
  Mauve,&#13;
  Pink,&#13;
  Russet&#13;
};&#13;
&#13;
struct Result { <span class="ent">➋</span>&#13;
  const char* name;&#13;
  Color color;&#13;
};&#13;
&#13;
Result observe_shrub(const char* name) { <span class="ent">➌</span>&#13;
  return Result{ name, Color::Russet };&#13;
}&#13;
&#13;
int main() {&#13;
  const char* description;&#13;
  switch (const auto result<span class="ent">➍</span> = observe_shrub("Zaphod"); result.color<span class="ent">➎</span>) {&#13;
  case Color::Mauve: {&#13;
    description = "mauvey shade of pinky russet";&#13;
    break;&#13;
  } case Color::Pink: {&#13;
    description = "pinky shade of mauvey russet";&#13;
    break;&#13;
  } case Color::Russet: {&#13;
<span epub:type="pagebreak" id="page_230"/>    description = "russety shade of pinky mauve";&#13;
    break;&#13;
  } default: {&#13;
    description = "enigmatic shade of whitish black";&#13;
  }}&#13;
  printf("The other Shaltanac's joopleberry shrub is "&#13;
         "always a more %s.", description); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The other Shaltanac's joopleberry shrub is always a more russety shade of&#13;
pinky mauve. <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch08ex19"/><em>Listing 8-19: Using an initialization expression in a <span class="literal">switch</span> statement</em></p>&#13;
<p class="indent">You declare the familiar <span class="literal">Color</span> <span class="literal">enum class</span> <span class="ent">➊</span> and join it with a <span class="literal">char*</span> member to form the POD type <span class="literal">Result</span> <span class="ent">➋</span>. The function <span class="literal">observe_shrub</span> returns a <span class="literal">Result</span> <span class="ent">➌</span>. Within <span class="literal">main</span>, you call <span class="literal">observe_shrub</span> within the initialization expression and store the result in the <span class="literal">result</span> variable <span class="ent">➍</span>. Within the conditional expression of <span class="literal">switch</span>, you extract the <span class="literal">color</span> element of this <span class="literal">result</span> <span class="ent">➎</span>. This element determines the case that executes (and sets the <span class="literal">description</span> pointer) <span class="ent">➏</span>.</p>&#13;
<p class="indent">As with the <span class="literal">if</span>-statement-plus-initializer syntax, any object initialized in the initialization expression is bound to the scope of the <span class="literal">switch</span> statement.</p>&#13;
<h3 class="h3" id="ch08lev1sec5"><strong>Iteration Statements</strong></h3>&#13;
<p class="noindent"><em>Iteration statements</em> execute a statement repeatedly. The four kinds of iteration statements are the <span class="literal">while</span> loop, the <span class="literal">do</span>-<span class="literal">while</span> loop, the <span class="literal">for</span> loop, and the range-based <span class="literal">for</span> loop.</p>&#13;
<h4 class="h4" id="ch08lev2sec8"><strong><em>while Loops</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">while</span> loop is the basic iteration mechanism. The usage is as follows:</p>&#13;
<pre>while (<span class="codeitalic1">condition</span>) {&#13;
  // The statement in the body of the loop&#13;
  // executes upon each iteration&#13;
}</pre>&#13;
<p class="indent">Before executing an iteration of the loop, the <span class="literal">while</span> loop evaluates the <span class="literal">condition</span> expression. If <span class="literal">true</span>, the loop continues. If <span class="literal">false</span>, the loop terminates, as demonstrated in <a href="ch08.xhtml#ch08ex20">Listing 8-20</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
bool double_return_overflow(uint8_t&amp; x) { <span class="ent">➊</span>&#13;
  const auto original = x;&#13;
  x *= 2;&#13;
  return original &gt; x;&#13;
}&#13;
<span epub:type="pagebreak" id="page_231"/>int main() {&#13;
  uint8_t x{ 1 }; <span class="ent">➋</span>&#13;
  printf("uint8_t:\n===\n");&#13;
  while (!double_return_overflow(x)<span class="ent">➌</span>) {&#13;
    printf("%u ", x); <span class="ent">➍</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">uint8_t:</span>&#13;
<span class="color1">===</span>&#13;
<span class="color1">2 4 8 16 32 64 128 <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch08ex20"/><em>Listing 8-20: A program that doubles a <span class="literal">uint8_t</span> and prints the new value on each iteration</em></p>&#13;
<p class="indent">You declare a <span class="literal">double_return_overflow</span> function taking an 8-bit, unsigned integer by reference <span class="ent">➊</span>. This function doubles the argument and checks whether this causes an overflow. If it does, it returns <span class="literal">true</span>. If no overflow occurs, it returns <span class="literal">false</span>.</p>&#13;
<p class="indent">You initialize the variable <span class="literal">x</span> to 1 before entering the <span class="literal">while</span> loop <span class="ent">➋</span>. The conditional expression in the <span class="literal">while</span> loop evaluates <span class="literal">double_return_overflow(x)</span> <span class="ent">➌</span>. This has the side effect of doubling <span class="literal">x</span>, because you’ve passed it by reference. It also returns a value telling you whether the doubling caused <span class="literal">x</span> to overflow. The loop will execute when the conditional expression evaluates to <span class="literal">true</span>, but <span class="literal">double_return_overflow</span> is written so it returns <span class="literal">true</span> when the loop should stop. You fix this problem by prepending the logical negation operator (<span class="literal">!</span>). (Recall from <a href="ch07.xhtml#ch07">Chapter 7</a> that this turns <span class="literal">true</span> to <span class="literal">false</span> and <span class="literal">false</span> to <span class="literal">true</span>.) So the <span class="literal">while</span> loop is actually asking, “If it’s NOT true that <span class="literal">double_return_overflow</span> is true . . .”</p>&#13;
<p class="indent">The end result is that you print the values 2, then 4, then 8, and so on to 128 <span class="ent">➍</span>.</p>&#13;
<p class="indent">Notice that the value 1 never prints, because evaluating the conditional expression doubles <span class="literal">x</span>. You can modify this behavior by putting the conditional statement at the end of a loop, which yields a <span class="literal">do</span>-<span class="literal">while</span> loop.</p>&#13;
<h4 class="h4" id="ch08lev2sec9"><strong><em>do-while Loops</em></strong></h4>&#13;
<p class="indent">A <span class="literal">do</span>-<span class="literal">while</span> loop is identical to a <span class="literal">while</span> loop, except the conditional statement evaluates after a loop completes rather than before. Its usage is as follows:</p>&#13;
<pre>do {&#13;
  // The statement in the body of the loop&#13;
  // executes upon each iteration&#13;
} while (<span class="codeitalic1">condition</span>);</pre>&#13;
<p class="indent">Because the condition evaluates at the end of a loop, you guarantee that the loop will execute at least once.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex21">Listing 8-21</a> refactors <a href="ch08.xhtml#ch08ex20">Listing 8-20</a> into a <span class="literal">do</span>-<span class="literal">while</span> loop.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
bool double_return_overflow(uint8_t&amp; x) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
<span epub:type="pagebreak" id="page_232"/>}&#13;
&#13;
int main() {&#13;
  uint8_t x{ 1 };&#13;
  printf("uint8_t:\n===\n");&#13;
  do {&#13;
    printf("%u ", x); <span class="ent">➊</span>&#13;
  } while (!double_return_overflow(x)<span class="ent">➋</span>);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">uint8_t:</span>&#13;
<span class="color1">===</span>&#13;
<span class="color1">1 2 4 8 16 32 64 128 <span class="ent">➊</span></span></pre>&#13;
<p class="listing"><a id="ch08ex21"/><em>Listing 8-21: A program that doubles a <span class="literal">uint8_t</span> and prints the new value on each iteration</em></p>&#13;
<p class="indent">Notice that the output from <a href="ch08.xhtml#ch08ex21">Listing 8-21</a> now begins with 1 <span class="ent">➊</span>. All you needed to do was reformat the <span class="literal">while</span> loop to put the condition at the end of the loop <span class="ent">➋</span>.</p>&#13;
<p class="indent">In most situations involving iterations, you have three tasks:</p>&#13;
<ol>&#13;
<li class="noindent">Initialize some object.</li>&#13;
<li class="noindent">Update the object before each iteration.</li>&#13;
<li class="noindent">Inspect the object’s value for some condition.</li>&#13;
</ol>&#13;
<p class="indent">You can use a <span class="literal">while</span> or <span class="literal">do</span>-<span class="literal">while</span> loop to accomplish part of these tasks, but the <span class="literal">for</span> loop provides built-in facilities that make life easier.</p>&#13;
<h4 class="h4" id="ch08lev2sec10"><strong><em>for Loops</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">for</span> loop is an iteration statement containing three special expressions: <em>initialization</em>, <em>conditional</em>, and <em>iteration</em>, as described in the sections that follow.</p>&#13;
<h5 class="h5" id="ch08lev3sec6"><strong>The Initialization Expression</strong></h5>&#13;
<p class="noindent">The initialization expression is like the initialization of <span class="literal">if</span>: it executes only once before the first iteration executes. Any objects declared within the initialization expression have lifetimes bound by the scope of the <span class="literal">for</span> loop.</p>&#13;
<h5 class="h5" id="ch08lev3sec7"><strong>The Conditional Expression</strong></h5>&#13;
<p class="noindent">The <span class="literal">for</span> loop conditional expression evaluates just before each iteration of the loop. If the conditional evaluates to <span class="literal">true</span>, the loop continues to execute. If the conditional evaluates to <span class="literal">false</span>, the loop terminates (this behavior is exactly like the conditional of the <span class="literal">while</span> and <span class="literal">do</span>-<span class="literal">while</span> loops).</p>&#13;
<p class="indent">Like <span class="literal">if</span> and <span class="literal">switch</span> statements, <span class="literal">for</span> permits you to initialize objects with scope equal to the statement’s.</p>&#13;
<h5 class="h5" id="ch08lev3sec8"><strong>The Iteration Expression</strong></h5>&#13;
<p class="noindent">After each iteration of the <span class="literal">for</span> loop, the iteration expression evaluates. This happens before the conditional expression evaluates. Note that the iteration <span epub:type="pagebreak" id="page_233"/>expression evaluates after a successful iteration, so the iteration expression won’t execute before the first iteration.</p>&#13;
<p class="indent">To clarify, the following list outlines the typical execution order in a <span class="literal">for</span> loop:</p>&#13;
<ol>&#13;
<li class="noindent">Initialization expression</li>&#13;
<li class="noindent">Conditional expression</li>&#13;
<li class="noindent">(Loop body)</li>&#13;
<li class="noindent">Iteration expression</li>&#13;
<li class="noindent">Conditional expression</li>&#13;
<li class="noindent">(Loop body)</li>&#13;
</ol>&#13;
<p class="indent">Steps 4 through 6 repeat until a conditional expression returns <span class="literal">false</span>.</p>&#13;
<h5 class="h5" id="ch08lev3sec9"><strong>Usage</strong></h5>&#13;
<p class="noindent"><a href="ch08.xhtml#ch08ex22">Listing 8-22</a> demonstrates the use of a <span class="literal">for</span> loop.</p>&#13;
<pre>for(<span class="codeitalic1">initialization</span><span class="ent">➊</span>; <span class="codeitalic1">conditional</span><span class="ent">➋</span>; <span class="codeitalic1">iteration</span><span class="ent">➌</span>) {&#13;
  // The statement in the body of the loop&#13;
  // executes upon each iteration&#13;
}</pre>&#13;
<p class="listing"><a id="ch08ex22"/><em>Listing 8-22: Using a <span class="literal">for</span> loop</em></p>&#13;
<p class="indent">The initialization <span class="ent">➊</span>, conditional <span class="ent">➋</span>, and iteration <span class="ent">➌</span> expressions reside in parentheses preceding the body of the <span class="literal">for</span> loop.</p>&#13;
<h5 class="h5" id="ch08lev3sec10"><strong>Iterating with an Index</strong></h5>&#13;
<p class="noindent">The <span class="literal">for</span> loops are excellent at iterating over an array-like object’s constituent elements. You use an auxiliary <em>index</em> variable to iterate over the range of valid indices for the array-like object. You can use this index to interact with each array element in sequence. <a href="ch08.xhtml#ch08ex23">Listing 8-23</a> employs an index variable to print each element of an array along with its index.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  const int x[]{ 1, 1, 2, 3, 5, 8 }; <span class="ent">➊</span>&#13;
  printf("i: x[i]\n"); <span class="ent">➋</span>&#13;
  for (int i{}<span class="ent">➌</span>; i &lt; 6<span class="ent">➍</span>; i++<span class="ent">➎</span>) {&#13;
    printf("%d: %d\n", i, x[i]);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">i: x[i] <span class="ent">➋</span></span>&#13;
<span class="color1">0: 1</span>&#13;
<span class="color1">1: 1</span>&#13;
<span class="color1">2: 2</span>&#13;
<span class="color1">3: 3</span>&#13;
<span class="color1"><span epub:type="pagebreak" id="page_234"/>4: 5</span>&#13;
<span class="color1">5: 8</span></pre>&#13;
<p class="listing"><a id="ch08ex23"/><em>Listing 8-23: A program iterating over an array of Fibonacci numbers</em></p>&#13;
<p class="indent">You initialize an <span class="literal">int</span> array called <span class="literal">x</span> with the first six Fibonacci numbers <span class="ent">➊</span>. After printing a header for the output <span class="ent">➋</span>, you build a <span class="literal">for</span> loop containing your initialization <span class="ent">➌</span>, conditional <span class="ent">➍</span>, and iteration <span class="ent">➎</span> expressions. The initialization expression executes first, and it initializes the index variable <span class="literal">i</span> to zero.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex23">Listing 8-23</a> shows a coding pattern that hasn’t changed since the 1950s. You can eliminate a lot of boilerplate code by using the more modern range-based <span class="literal">for</span> loop.</p>&#13;
<h4 class="h4" id="ch08lev2sec11"><strong><em>Ranged-Based for Loops</em></strong></h4>&#13;
<p class="noindent">The range-based <span class="literal">for</span> loop iterates over a <em>range</em> of values without needing an index variable. A range (or <em>range expression</em>) is an object that the range-based <span class="literal">for</span> loop knows how to iterate over. Many C++ objects are valid range expressions, including arrays. (All of the stdlib containers you’ll learn about in <a href="part02.xhtml#part02">Part II</a> are also valid range expressions.)</p>&#13;
<h5 class="h5" id="ch08lev3sec11"><strong>Usage</strong></h5>&#13;
<p class="noindent">Ranged-based <span class="literal">for</span> loop usage looks like this:</p>&#13;
<pre>for(<span class="codeitalic1">range-declaration</span> : <span class="codeitalic1">range-expression</span>) {&#13;
  // The statement in the body of the loop&#13;
  // executes upon each iteration&#13;
}</pre>&#13;
<p class="indent">A <em>range declaration</em> declares a named variable. This variable must have the same type as implied by the range expression (you can use <span class="literal">auto</span>).</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex24">Listing 8-24</a> refactors <a href="ch08.xhtml#ch08ex23">Listing 8-23</a> to use a range-based <span class="literal">for</span> loop.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  const int x[]{ 1, 1, 2, 3, 5, 8 }; <span class="ent">➊</span>&#13;
  for (const auto element<span class="ent">➋</span> : x<span class="ent">➌</span>) {&#13;
    printf("%d ", element<span class="ent">➍</span>);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 1 2 3 5 8</span></pre>&#13;
<p class="listing"><a id="ch08ex24"/><em>Listing 8-24: A range-based <span class="literal">for</span> loop iterating over the first six Fibonacci numbers</em></p>&#13;
<p class="indent">You still declare an array <span class="literal">x</span> containing six Fibonacci numbers <span class="ent">➊</span>. The range-based <span class="literal">for</span> loop contains a range-declaration expression <span class="ent">➋</span> where you declare the <span class="literal">element</span> variable to hold each element of the range. It also contains the range expression <span class="literal">x</span> <span class="ent">➌</span>, which contains the elements you want to iterate over to print <span class="ent">➍</span>.</p>&#13;
<p class="indent">This code is a whole lot cleaner!</p>&#13;
<h5 class="h5" id="ch08lev3sec12"><strong><span epub:type="pagebreak" id="page_235"/>Range Expressions</strong></h5>&#13;
<p class="noindent">You can define your own types that are also valid range expressions. But you’ll need to specify several functions on your type.</p>&#13;
<p class="indent">Every range exposes a <span class="literal">begin</span> and an <span class="literal">end</span> method. These functions represent the common interface that a range-based <span class="literal">for</span> loop uses to interact with a range. Both methods return <em>iterators</em>. An iterator is an object that supports <span class="literal">operator!=</span>, <span class="literal">operator++</span>, and <span class="literal">operator*</span>.</p>&#13;
<p class="indent">Let’s look at how all these pieces fit together. Under the hood, a range-based <span class="literal">for</span> loop looks just like the loop in <a href="ch08.xhtml#ch08ex25">Listing 8-25</a>.</p>&#13;
<pre>const auto e = range.end();<span class="ent">➊</span>&#13;
for(auto b = range.begin()<span class="ent">➋</span>; b != e<span class="ent">➌</span>; ++b<span class="ent">➍</span>) {&#13;
  const auto&amp; element<span class="ent">➎</span> = *b;&#13;
}</pre>&#13;
<p class="listing"><a id="ch08ex25"/><em>Listing 8-25: A <span class="literal">for</span> loop simulating a range-based <span class="literal">for</span> loop</em></p>&#13;
<p class="indent">The initialization expression stores two variables, <span class="literal">b</span> <span class="ent">➋</span> and <span class="literal">e</span> <span class="ent">➊</span>, which you initialize to <span class="literal">range.begin()</span> and <span class="literal">range.end()</span> respectively. The conditional expression checks whether <span class="literal">b</span> equals <span class="literal">e</span>, in which case the loop has completed <span class="ent">➌</span> (this is by convention). The iteration expression increments <span class="literal">b</span> with the prefix operator <span class="ent">➍</span>. Finally, the iterator supports the dereference operator <span class="literal">*</span>, so you can extract the pointed-to element <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The types returned by <span class="literal">begin</span> and <span class="literal">end</span> don’t need to be the same. The requirement is that <span class="literal">operator!=</span> on <span class="literal">begin</span> accepts an <span class="literal">end</span> argument to support the comparison <span class="literal">begin != end</span>.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch08lev3sec13"><strong>A Fibonacci Range</strong></h5>&#13;
<p class="noindent">You can implement a <span class="literal">FibonacciRange</span>, which will generate an arbitrarily long sequence of Fibonacci numbers. From the previous section, you know that this range must offer a <span class="literal">begin</span> and an <span class="literal">end</span> method that returns an iterator. This iterator, which is called <span class="literal">FibonacciIterator</span> in this example, must in turn offer <span class="literal">operator!=</span>, <span class="literal">operator++</span>, and <span class="literal">operator*</span>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex26">Listing 8-26</a> implements a <span class="literal">FibonacciIterator</span> and a <span class="literal">FibonacciRange</span>.</p>&#13;
<pre>struct FibonacciIterator {&#13;
  bool operator!=(int x) const {&#13;
    return x &gt;= current; <span class="ent">➊</span>&#13;
  }&#13;
&#13;
  FibonacciIterator&amp; operator++() {&#13;
    const auto tmp = current; <span class="ent">➋</span>&#13;
    current += last; <span class="ent">➌</span>&#13;
    last = tmp; <span class="ent">➍</span>&#13;
    return *this; <span class="ent">➎</span>&#13;
  }&#13;
&#13;
  int operator*() const {&#13;
    return current; <span class="ent">➏</span>&#13;
<span epub:type="pagebreak" id="page_236"/>  }&#13;
private:&#13;
  int current{ 1 }, last{ 1 };&#13;
};&#13;
&#13;
struct FibonacciRange {&#13;
  explicit FibonacciRange(int max<span class="ent">➐</span>) : max{ max } { }&#13;
  FibonacciIterator begin() const { <span class="ent">➑</span>&#13;
    return FibonacciIterator{};&#13;
  }&#13;
  int end() const { <span class="ent">➒</span>&#13;
    return max;&#13;
  }&#13;
private:&#13;
  const int max;&#13;
};</pre>&#13;
<p class="listing"><a id="ch08ex26"/><em>Listing 8-26: An implementation of <span class="literal">FibonacciIterator</span> and <span class="literal">FibonacciRange</span></em></p>&#13;
<p class="indent">The <span class="literal">FibonacciIterator</span> has two fields, <span class="literal">current</span> and <span class="literal">last</span>, which are initialized to 1. These keep track of two values in the Fibonacci sequence. Its <span class="literal">operator!=</span> checks whether the argument is greater than or equal to <span class="literal">current</span> <span class="ent">➊</span>. Recall that this argument is used within the range-based <span class="literal">for</span> loop in the conditional expression. It should return <span class="literal">true</span> if elements remain in the range; otherwise, it returns <span class="literal">false</span>. The <span class="literal">operator++</span> appears in the iteration expression and is responsible for setting up the iterator for the next iteration. You first save <span class="literal">current</span> value into the temporary variable <span class="literal">tmp</span> <span class="ent">➋</span>. Next, you increment current by <span class="literal">last</span>, yielding the next Fibonacci number <span class="ent">➌</span>. (This follows from the definition of a Fibonacci sequence.) Then you set <span class="literal">last</span> equal to <span class="literal">tmp</span> <span class="ent">➍</span> and return a reference to <span class="literal">this</span> <span class="ent">➎</span>. Finally, you implement <span class="literal">operator*</span>, which returns <span class="literal">current</span> <span class="ent">➏</span> directly.</p>&#13;
<p class="indent"><span class="literal">FibonacciRange</span> is much simpler. Its constructor takes a max argument that defines an upper limit for the range <span class="ent">➐</span>. The <span class="literal">begin</span> method returns a fresh <span class="literal">FibonacciIterator</span> <span class="ent">➑</span>, and the <span class="literal">end</span> method returns <span class="literal">max</span> <span class="ent">➒</span>.</p>&#13;
<p class="indent">It should now be apparent why you need to implement <span class="literal">bool operator!=(int x)</span> on <span class="literal">FibonacciIterator</span> rather than, for example, <span class="literal">bool operator!=(const FibonacciIterator&amp; x)</span>: a <span class="literal">FibonacciRange</span> returns an <span class="literal">int</span> from <span class="literal">end()</span>.</p>&#13;
<p class="indent">You can use the <span class="literal">FibonacciRange</span> in a ranged-based <span class="literal">for</span> loop, as demonstrated in <a href="ch08.xhtml#ch08ex27">Listing 8-27</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct FibonacciIterator {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct FibonacciRange {&#13;
  --<span class="codeitalic1">snip</span>--;&#13;
};&#13;
&#13;
int main() {&#13;
<span epub:type="pagebreak" id="page_237"/>  for (const auto i : FibonacciRange{ 5000 }<span class="ent">➊</span>) {&#13;
    printf("%d ", i); <span class="ent">➋</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch08ex27"/><em>Listing 8-27: Using <span class="literal">FibonacciRange</span> in a program</em></p>&#13;
<p class="indent">It took a little work to implement <span class="literal">FibonacciIterator</span> and <span class="literal">FibonacciRange</span> in <a href="ch08.xhtml#ch08ex26">Listing 8-26</a>, but the payoff is substantial. Within <span class="literal">main</span>, you simply construct a <span class="literal">FibonacciRange</span> with the desired upper limit <span class="ent">➊</span>, and the range-based <span class="literal">for</span> loop takes care of everything else for you. You simply use the resulting elements within the <span class="literal">for</span> loop <span class="ent">➋</span>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex27">Listing 8-27</a> is functionally equivalent to <a href="ch08.xhtml#ch08ex28">Listing 8-28</a>, which converts the range-based <span class="literal">for</span> loop to a traditional <span class="literal">for</span> loop.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct FibonacciIterator {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct FibonacciRange {&#13;
  --<span class="codeitalic1">snip</span>--;&#13;
};&#13;
&#13;
int main() {&#13;
  FibonacciRange range{ 5000 };&#13;
  const auto end = range.end();<span class="ent">➊</span>&#13;
  for (auto x = range.begin()<span class="ent">➋</span>; x != end <span class="ent">➌</span>; ++x <span class="ent">➍</span>) {&#13;
    const auto i = *x;&#13;
    printf("%d ", i);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181</span></pre>&#13;
<p class="listing"><a id="ch08ex28"/><em>Listing 8-28: A refactor of <a href="ch08.xhtml#ch08ex27">Listing 8-27</a> using a traditional <span class="literal">for</span> loop</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex28">Listing 8-28</a> demonstrates how all of the pieces fit together. Calling <span class="literal">range.begin()</span> <span class="ent">➋</span> yields a <span class="literal">FibonacciIterator</span>. When you call <span class="literal">range.end()</span> <span class="ent">➊</span>, it yields an <span class="literal">int</span>. These types come straight from the method definitions of <span class="literal">begin()</span> and <span class="literal">end()</span> on <span class="literal">FibonacciRange</span>. The conditional statement <span class="ent">➌</span> uses <span class="literal">operator!=(int)</span> on <span class="literal">FibonacciIterator</span> to get the following behavior: if the iterator <span class="literal">x</span> has gone past the <span class="literal">int</span> argument to <span class="literal">operator!=</span>, the conditional evaluates to <span class="literal">false</span> and the loop ends. You’ve also implemented <span class="literal">operator++</span> on <span class="literal">FibonacciIterator</span> so <span class="literal">++x</span> <span class="ent">➍</span> increments the Fibonacci number within <span class="literal">FibonacciIterator</span>.</p>&#13;
<p class="indent">When you compare <a href="ch08.xhtml#ch08ex27">Listings 8-27</a> and <a href="ch08.xhtml#ch08ex28">8-28</a>, you can see just how much tedium range-based <span class="literal">for</span> loops hide.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_238"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You might be thinking, “Sure, the range-based <span class="literal">for</span> loop looks a lot cleaner, but implementing <span class="literal">FibonacciIterator</span> and <span class="literal">FibonacciRange</span> is a lot of work.” That’s a great point, and for one-time-use code, you probably wouldn’t refactor code in this way. Ranges are mainly useful if you’re writing library code, writing code that you’ll reuse often, or simply consuming ranges that someone else has written.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev1sec6"><strong>Jump Statements</strong></h3>&#13;
<p class="noindent"><em>Jump statements</em>, including the <span class="literal">break</span>, <span class="literal">continue</span>, and <span class="literal">goto</span> statements, transfer control flow. Unlike selection statements, jump statements are not conditional. You should avoid using them because they can almost always be replaced with higher-level control structures. They’re discussed here because you might see them in older C++ code and they still play a central role in a lot of C code.</p>&#13;
<h4 class="h4" id="ch08lev2sec12"><strong><em>break Statements</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">break</span> statement terminates execution of the enclosing iteration or <span class="literal">switch</span> statement. Once <span class="literal">break</span> completes, execution transfers to the statement immediately following the <span class="literal">for</span>, range-based <span class="literal">for</span>, <span class="literal">while</span>, <span class="literal">do</span>-<span class="literal">while</span>, or <span class="literal">switch</span> statement.</p>&#13;
<p class="indent">You’ve already used <span class="literal">break</span> within <span class="literal">switch</span> statements; once a case completes, the <span class="literal">break</span> statement terminates the <span class="literal">switch</span>. Recall that, without a <span class="literal">break</span> statement, the <span class="literal">switch</span> statement would continue executing all of the following cases.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex29">Listing 8-29</a> refactors <a href="ch08.xhtml#ch08ex27">Listing 8-27</a> to break out of a range-based <span class="literal">for</span> loop if the iterator <span class="literal">i</span> equals 21.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct FibonacciIterator {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct FibonacciRange {&#13;
  --<span class="codeitalic1">snip</span>--;&#13;
};&#13;
&#13;
int main() {&#13;
  for (auto i : FibonacciRange{ 5000 }) {&#13;
    if (i == 21) { <span class="ent">➊</span>&#13;
      printf("*** "); <span class="ent">➋</span>&#13;
      break; <span class="ent">➌</span>&#13;
    }&#13;
    printf("%d ", i);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 2 3 5 8 13 *** <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch08ex29"/><em>Listing 8-29: A refactor of <a href="ch08.xhtml#ch08ex27">Listing 8-27</a> that breaks if the iterator equals 21</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_239"/>An <span class="literal">if</span> statement is added that checks whether <span class="literal">i</span> is 21 <span class="ent">➊</span>. If it is, you print three asterisks <span class="literal">***</span> <span class="ent">➋</span> and <span class="literal">break</span> <span class="ent">➌</span>. Notice the output: rather than printing 21, the program prints three asterisks and the <span class="literal">for</span> loop terminates. Compare this to the output of <a href="ch08.xhtml#ch08ex27">Listing 8-27</a>.</p>&#13;
<h4 class="h4" id="ch08lev2sec13"><strong><em>continue Statements</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">continue</span> statement skips the remainder of an enclosing iteration statement and continues with the next iteration. <a href="ch08.xhtml#ch08ex30">Listing 8-30</a> replaces the <span class="literal">break</span> in <a href="ch08.xhtml#ch08ex29">Listing 8-29</a> with a <span class="literal">continue</span>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct FibonacciIterator {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct FibonacciRange {&#13;
  --<span class="codeitalic1">snip</span>--;&#13;
};&#13;
&#13;
int main() {&#13;
  for (auto i : FibonacciRange{ 5000 }) {&#13;
    if (i == 21) {&#13;
      printf("*** "); <span class="ent">➊</span>&#13;
      continue; <span class="ent">➋</span>&#13;
    }&#13;
    printf("%d ", i);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 2 3 5 8 13 *** <span class="ent">➊</span>34 55 89 144 233 377 610 987 1597 2584 4181</span></pre>&#13;
<p class="listing"><a id="ch08ex30"/><em>Listing 8-30: A refactor of <a href="ch08.xhtml#ch08ex29">Listing 8-29</a> to use <span class="literal">continue</span> instead of <span class="literal">break</span></em></p>&#13;
<p class="indent">You still print three asterisks <span class="ent">➊</span> when <span class="literal">i</span> is 21, but you use <span class="literal">continue</span> instead of <span class="literal">break</span> <span class="ent">➋</span>. This causes 21 not to print, like <a href="ch08.xhtml#ch08ex29">Listing 8-29</a>; however, unlike <a href="ch08.xhtml#ch08ex29">Listing 8-29</a>, <a href="ch08.xhtml#ch08ex30">Listing 8-30</a> continues iterating. (Compare the output.)</p>&#13;
<h4 class="h4" id="ch08lev2sec14"><strong><em>goto Statements</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">goto</span> statement is an unconditional jump. The target of a <span class="literal">goto</span> statement is a label.</p>&#13;
<h5 class="h5" id="ch08lev3sec14"><strong>Labels</strong></h5>&#13;
<p class="noindent"><em>Labels</em> are identifiers you can add to any statement. Labels give statements a name, and they have no direct impact on the program. To assign a label, prepend a statement with the desired name of the label followed by a colon.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08ex31">Listing 8-31</a> adds the labels <span class="literal">luke</span> and <span class="literal">yoda</span> to a simple program.</p>&#13;
<pre><span epub:type="pagebreak" id="page_240"/>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
luke: <span class="ent">➊</span>&#13;
  printf("I'm not afraid.\n");&#13;
yoda: <span class="ent">➋</span>&#13;
  printf("You will be.");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">I'm not afraid.</span>&#13;
<span class="color1">You will be.</span></pre>&#13;
<p class="listing"><a id="ch08ex31"/><em>Listing 8-31: A simple program with labels</em></p>&#13;
<p class="indent">The labels <span class="ent">➊</span><span class="ent">➋</span> do nothing on their own.</p>&#13;
<h5 class="h5" id="ch08lev3sec15"><strong>goto Usage</strong></h5>&#13;
<p class="noindent">The <span class="literal">goto</span> statement’s usage is as follows:</p>&#13;
<pre>goto <span class="codeitalic1">label</span>;</pre>&#13;
<p class="indent">For example, you can employ <span class="literal">goto</span> statements to needlessly obfuscate the simple program in <a href="ch08.xhtml#ch08ex32">Listing 8-32</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  goto silent_bob; <span class="ent">➊</span>&#13;
luke:&#13;
  printf("I'm not afraid.\n");&#13;
  goto yoda; <span class="ent">➌</span>&#13;
silent_bob:&#13;
  goto luke; <span class="ent">➋</span>&#13;
yoda:&#13;
  printf("You will be.");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">I'm not afraid.</span>&#13;
<span class="color1">You will be.</span></pre>&#13;
<p class="listing"><a id="ch08ex32"/><em>Listing 8-32: Spaghetti code showcasing the <span class="literal">goto</span> statement</em></p>&#13;
<p class="indent">Control flow in <a href="ch08.xhtml#ch08ex32">Listing 8-32</a> passes to <span class="literal">silent_bob</span> <span class="ent">➊</span>, then to <span class="literal">luke</span> <span class="ent">➋</span>, and then to <span class="literal">yoda</span> <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch08lev3sec16"><strong>The Role of goto in Modern C++ Programs</strong></h5>&#13;
<p class="noindent">In modern C++, there is no good role for <span class="literal">goto</span> statements. Don’t use them.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_241"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In poorly written C++ (and in most C code), you might see <span class="literal">goto</span> used as a primitive error-handling mechanism. A lot of system programming entails acquiring resources, checking for error conditions, and cleaning up resources. The RAII paradigm neatly abstracts all of these details, but C doesn’t have RAII available. See the Overture to C Programmers on <a href="anoverture.xhtml#page_xxxvii">page  xxxvii</a> for more information.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev1sec7"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you worked through different kinds of statements you can employ in your programs. They included declarations and initializations, selection statements, and iteration statements.</p>&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Keep in mind that <span class="literal">try-catch</span> blocks are also statements, but they were already discussed in great detail in <a href="ch04.xhtml#ch04">Chapter 4</a>.</em></p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>8-1.</strong> Refactor <a href="ch08.xhtml#ch08ex27">Listing 8-27</a> into separate translation units: one for <span class="literal">main</span> and another for <span class="literal">FibonacciRange</span> and <span class="literal">FibonacciIterator</span>. Use a header file to share definitions between the two translation units.</p>&#13;
<p class="noindent"><strong>8-2.</strong> Implement a <span class="literal">PrimeNumberRange</span> class that can be used in a range expression to iterate over all prime numbers less than a given value. Again, use a separate header and source file.</p>&#13;
<p class="noindent"><strong>8-3.</strong> Integrate <span class="literal">PrimeNumberRange</span> into <a href="ch08.xhtml#ch08ex27">Listing 8-27</a>, adding another loop that generates all prime numbers less than 5,000.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland; <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>Random Number Generation and Monte Carlo Methods</em>, 2nd Edition, by James E. Gentle (Springer-Verlag, 2003)</li>&#13;
<li class="noindent"><em>Random Number Generation and Quasi-Monte Carlo Methods</em> by Harald Niederreiter (SIAM Vol. 63, 1992)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>