- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 17 GRAPHS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17 图
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In the previous chapters we discussed several data structures, and in this chapter
    we’ll consider a new topic, how to represent graphs*.* We’ll also look at several
    algorithms related to graphs, such as finding the shortest paths, calculating
    distances, checking software dependencies, and more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了几种数据结构，而在本章中，我们将探讨一个新话题：如何表示图*。*我们还将研究与图相关的几种算法，如寻找最短路径、计算距离、检查软件依赖关系等。
- en: What Are Graphs?
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是图？
- en: 'An abstract definition might be that a graph is a set of objects in which pairs
    of those objects are somehow related. The objects are called *vertices* (plural
    of *vertex*), but they’re also called *points* and *nodes*. The relationships
    between pairs of vertices are graphically represented with lines joining the pairs.
    These lines are called *edges*, *arcs*, *arrows*, or just plain *links*. The number
    of arcs connected to a point is called its *degree*. Points linked in this fashion
    are sometimes called *neighbors* or are considered to be *adjacent* to each other.
    The same word is used in a similar sense: edges are considered to be adjacent
    if they share a common vertex.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个抽象的定义是，图是一个由对象组成的集合，这些对象之间以某种方式相互关联。这些对象叫做*顶点*（*vertex*的复数），也叫做*点*或*节点*。顶点对之间的关系通过连接顶点对的线条来图形化表示，这些线条叫做*边*、*弧*、*箭头*，或仅仅称作*链接*。与一个点连接的弧的数量叫做它的*度*。以这种方式相连的点有时称为*邻居*，或者认为它们是*相邻*的。同样的词在类似的意义下使用：如果两个边共享一个公共的顶点，则认为它们是相邻的。
- en: 'These definitions may sound vague or rather “mathematical” (in fact, a branch
    of mathematics that specifically studies graphs and their properties is called
    *graph theory*), so this chapter will explore some practical examples. (We’ve
    actually already studied graphs. Trees are graphs; indeed, the definition fits
    them.) Some use cases for graphs include the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义可能听起来模糊或相当“数学化”（事实上，专门研究图及其性质的数学分支叫做*图论*），因此本章将通过一些实际示例进行探讨。（实际上，我们已经学习过图。树就是图；实际上，定义也适用于它们。）图的某些使用场景包括以下内容：
- en: Relationships among people, where you can have people (nodes) and friendships
    (arcs), so that if two people are friends, they are linked
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人与人之间的关系，其中你可以将人（节点）和友谊（弧）联系起来，这样如果两个人是朋友，他们就会相互连接
- en: Dependencies in code, with modules (nodes) that import components (arcs) exported
    from other modules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中的依赖关系，包括导入其他模块（节点）中导出的组件（弧）的模块
- en: Projects with tasks (nodes) that can’t be started until some other tasks have
    been finished (arcs)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务之间有依赖关系的项目（节点），这些任务在其他任务完成之前无法开始（弧）
- en: Maps, as in GPS-based applications, with cities (nodes) and roads (arcs)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图，类似于基于GPS的应用程序，包含城市（节点）和道路（弧）
- en: '[Figure 17-1](chapter17.xhtml#fig17-1) shows an example of the latter, using
    a graph to represent a part of a city or a country.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-1](chapter17.xhtml#fig17-1)展示了后一种情况，使用图表示城市或国家的一部分。'
- en: '![](../images/Figure17-1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-1.jpg)'
- en: 'Figure 17-1: A graph representing some cities and roads linking them'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-1：一个表示某些城市和连接它们的道路的图
- en: In this graphical map, vertices represent cities (or street corners, or countries),
    and the edges represent roads (or street blocks, or flights). In [Figure 17-1](chapter17.xhtml#fig17-1),
    the edges are *undirected*, meaning that one may travel any direction—for example,
    from A to E or from E to A.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图形地图中，顶点代表城市（或街角，或国家），边代表道路（或街区，或航班）。在[图17-1](chapter17.xhtml#fig17-1)中，边是*无向*的，意味着可以任意方向行驶——例如，从A到E或从E到A。
- en: In a city map, where streets may be one-way only, we’d need a *directed* graph
    instead, as shown in [Figure 17-2](chapter17.xhtml#fig17-2). In these graphs,
    we can speak of the *outdegree* of a node (how many arcs lead out from it) or
    the *indegree* of a node (how many arcs lead into it).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个城市地图中，街道可能是单行道，那么我们需要一个*有向*图，如[图17-2](chapter17.xhtml#fig17-2)所示。在这些图中，我们可以讨论节点的*出度*（从该节点出发的弧的数量）或*入度*（指向该节点的弧的数量）。
- en: '![](../images/Figure17-2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-2.jpg)'
- en: 'Figure 17-2: A directed graph where you can travel the roads in only one direction'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-2：一个有向图，表示只能单向行驶的道路
- en: Edges usually have values associated with them, like time or cost, making them
    *weighted* graphs. *Unweighted* graphs with no values associated with edges are
    also possible; the association itself is all that matters. Don’t assume that symmetry
    or any other rules apply to directed graphs. For instance, in the graph in [Figure
    17-2](chapter17.xhtml#fig17-2), you can go from B to C directly, but you can’t
    go back from C to B in one step. Also, going from A to B doesn’t cost the same
    as going from B to A. Finally, going from G to D via F could be cheaper than going
    directly from G to F. In some cases weights could be negative, but we’re always
    working here with non-negative values.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 边通常有与之相关的值，如时间或成本，这使得它们成为*加权*图。也可以有*无权*图，边没有与之相关的值；重要的是关联本身。不要假设对有向图适用对称性或其他规则。例如，在[图17-2](chapter17.xhtml#fig17-2)中，你可以直接从B到C，但不能一步到位地从C返回B。此外，从A到B的成本与从B到A的成本不同。最后，从G经F到D的成本可能比直接从G到F更低。在某些情况下，权重可能为负值，但我们在这里始终处理非负值。
- en: NOTE
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注
- en: '*Graphs can also have multiple edges between any pair of vertices, but we’re
    not going to consider those. For all the algorithms in the chapter, it’ll be enough
    to just use the shortest edge and simply ignore the others. Another possibility
    we’ll ignore here is edges from a vertex to itself, which are called loops.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图也可以在任意一对顶点之间有多条边，但我们不考虑这些。在本章的所有算法中，仅使用最短的边，忽略其他边就足够了。我们这里还忽略的一种情况是从顶点到它自身的边，称为环。*'
- en: 'We’ll consider the following kinds of processes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑以下几种类型的过程：
- en: Given two vertices, you may want to know whether there’s a path from the first
    to the second. As an extension to this, you might want to find the path with the
    minimum cost (the *shortest path*) from one vertex to another one or to all other
    vertices.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定两个顶点，你可能想知道是否存在一条从第一个顶点到第二个顶点的路径。作为扩展，你可能想找到从一个顶点到另一个顶点或所有其他顶点的最小成本路径（*最短路径*）。
- en: 'A directed graph may represent a project with tasks and dependencies between
    them: you might want to find an ordering so that no task can start until all previous
    tasks have been finished; this is called a *topological sort*.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有向图可以表示一个项目，其中包含任务和任务之间的依赖关系：你可能希望找到一个排序，使得在所有前置任务完成之前，任何任务都不能开始；这就是所谓的*拓扑排序*。
- en: Building on this example of tasks and dependencies, you may worry that some
    kind of cycle (A before B before C before A) would make sorting impossible. A
    related problem to topological sorting is *cycle detection*.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于任务和依赖关系的这个示例，你可能会担心某种类型的循环（如A在B之前，B在C之前，C又在A之前）会使得排序变得不可能。与拓扑排序相关的问题是*循环检测*。
- en: An undirected graph may represent geographic points with the edges showing the
    cost of joining them with, say, electrical lines or communication cables. A *minimum
    spanning tree* shows how to choose edges so all points are connected to each other
    at the lowest total cost.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个无向图可以表示地理点，边表示将它们连接起来的成本，比如电力线路或通信电缆的成本。*最小生成树*显示了如何选择边，使得所有点都以最低的总成本互相连接。
- en: Along the same lines, given the previous graph, you could ask whether it’s connected
    (meaning that it’s possible to reach every point from any other point) or unconnected.
    In that case, you want to implement *connectivity detection*.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样地，给定前面的图，你可能会问它是否是连通的（意味着可以从任何一个点到达其他所有点）或不连通。在这种情况下，你需要实现*连通性检测*。
- en: This list of procedures isn’t complete, but it covers the most important algorithms.
    Let’s start by considering how to represent graphs and then move on to the necessary
    algorithms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这份程序列表并不完整，但涵盖了最重要的算法。让我们先考虑如何表示图，然后再讨论必要的算法。
- en: 'One final note: when discussing the performance of algorithms, we’ll use *v*
    to stand for the number of vertices and *e* for the number of edges. Take care
    not to confuse this with the mathematical constant *e*, the basis for natural
    logarithms, 2.718281728 ...!'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个说明：在讨论算法性能时，我们将使用*v*表示顶点的数量，*e*表示边的数量。请注意不要将其与数学常数*e*混淆，后者是自然对数的底数，约为2.718281728
    ...！
- en: Representing Graphs
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图的表示
- en: 'There are several ways to represent graphs, and we’ll consider the three most
    used methods: adjacency matrix, adjacency list, and adjacency set.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表示图的方式有几种，我们将考虑三种最常用的方法：邻接矩阵、邻接表和邻接集。
- en: Adjacency Matrix Representation for Graphs
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图的邻接矩阵表示法
- en: 'The *adjacency matrix* representation is the simplest and basically shows which
    nodes are adjacent to each other. This type of graph is represented by a square
    matrix, with a row and column for each vertex. If there’s a link from vertex *i*
    to vertex *j*, the matrix has a value at position [i][j]: this is just a true
    value for unweighted graphs or the associated edge’s cost for weighted graphs.
    If there’s no link between those vertices, the matrix has false or a special value
    (zero or +infinity) at the corresponding position. For undirected graphs, note
    that position [i][j] will always be equal to position [j][i]; the matrix will
    be symmetrical with regard to its main diagonal.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*邻接矩阵*表示法是最简单的，基本上展示了哪些节点是相邻的。这种图通过一个方阵表示，每个顶点都有一行一列。如果存在从顶点*i*到顶点*j*的连接，矩阵中位置[i][j]就有一个值：对于无权图，这是一个布尔值，表示是否有连接；对于带权图，这是连接边的权重。如果两个顶点之间没有连接，则矩阵在相应的位置上为假值或特殊值（零或+无穷大）。对于无向图，请注意位置[i][j]将始终等于位置[j][i]；矩阵相对于主对角线是对称的。'
- en: Consider the directed graph from the previous section again ([Figure 17-2](chapter17.xhtml#fig17-2)).
    The matrix representation for that graph could be as [Figure 17-3](chapter17.xhtml#fig17-3)
    shows.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑前一节中的有向图（[图17-2](chapter17.xhtml#fig17-2)）。该图的矩阵表示可以如[图17-3](chapter17.xhtml#fig17-3)所示。
- en: '![](../images/Figure17-3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-3.jpg)'
- en: 'Figure 17-3: The adjacency matrix representation for the graph in [Figure 17-2](chapter17.xhtml#fig17-2)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-3：[图17-2](chapter17.xhtml#fig17-2)中的图的邻接矩阵表示
- en: We’ve used the option of representing missing edges with zero; an equally valid
    solution is to represent those with +infinity. No matter how you represent missing
    edges, in both cases, the diagonal of the matrix is zero. There’s no cost involved
    in going from a point to itself; you’re already there.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经选择用零表示缺失的边；另一个同样有效的解决方案是用+无穷大表示缺失的边。不管你用哪种方式表示缺失的边，在这两种情况下，矩阵的对角线都会是零。从某个点到达自身不需要成本，因为你已经在那个点上。
- en: This representation is quite easy to work with, but it requires a lot of space
    for large graphs. As to performance, operations like checking whether two vertices
    are adjacent or adding or removing edges are *O*(1), which is as fast as possible.
    On the other hand, processing the list of edges of a vertex is *O*(*v*) no matter
    how many neighbors a node actually has.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示方法相当容易操作，但对于大型图来说，它需要大量空间。在性能方面，检查两个顶点是否相邻，或添加、删除边的操作时间复杂度为*O*(1)，这是最快的。然而，处理一个顶点的边列表的时间复杂度是*O*(*v*)，无论该节点实际上有多少个邻居。
- en: If nodes have only a few neighbors, most of the matrix will be marked as empty
    (making it a *sparse* matrix), which means you’re wasting space. For those cases,
    you can choose adjacency list representations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点只有少数邻居，大部分矩阵会被标记为空（形成*稀疏*矩阵），这意味着你浪费了空间。在这种情况下，你可以选择邻接表表示法。
- en: Adjacency List Representation for Graphs
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图的邻接表表示
- en: The matrix shown in [Figure 17-3](chapter17.xhtml#fig17-3) wastes too much space
    and causes all procedures that need the list of arcs out of a point to be *O*(*v*).
    You can use lists so that for each vertex, you’ll have all the points to which
    it connects and also all of the points that connect to it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-3](chapter17.xhtml#fig17-3)中显示的矩阵浪费了太多空间，并且导致所有需要获取从某个点出发的弧列表的过程时间复杂度为*O*(*v*)。你可以使用邻接表表示，这样每个顶点就能包含所有与之连接的点以及所有连接到它的点。'
- en: For the same directed graph shown in [Figure 17-2](chapter17.xhtml#fig17-2),
    the *adjacency lists* representation is as shown in [Figure 17-4](chapter17.xhtml#fig17-4)
    (compare this with the matrix representation in [Figure 17-3](chapter17.xhtml#fig17-3)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[图17-2](chapter17.xhtml#fig17-2)中显示的同一个有向图，*邻接表*表示如[图17-4](chapter17.xhtml#fig17-4)所示（与[图17-3](chapter17.xhtml#fig17-3)中的矩阵表示进行对比）。
- en: '![](../images/Figure17-4.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-4.jpg)'
- en: 'Figure 17-4: The adjacency list representation is an alternative to the adjacency
    matrix.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-4：邻接表表示是邻接矩阵的另一种选择。
- en: 'For each vertex, you have two lists: one with outgoing edges (shown horizontally,
    as rows) and one with incoming edges (shown vertically, as columns). For example,
    in the first row, you see that from A, one may reach B (at a cost of 4) or E (at
    a cost of 11). Looking at the first column, you see that you can reach A from
    B (at a cost of 3) or D (at a cost of 5). Each element in the structure would
    have a pointer to the next in the same row and another to the next in the same
    column. You could also work with doubly linked lists for easier updates. Nodes
    also have to carry the identities of both endpoints.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个顶点，你有两个列表：一个是输出边列表（水平显示，作为行），另一个是输入边列表（垂直显示，作为列）。例如，在第一行，你可以看到从A出发，可以到达B（代价为4）或E（代价为11）。查看第一列，你会看到从B出发可以到达A（代价为3）或D（代价为5）。结构中的每个元素都将有一个指向同一行下一个元素的指针，以及一个指向同一列下一个元素的指针。你还可以使用双向链表以便更容易进行更新。节点还需要包含两个端点的身份信息。
- en: With this structure, it’s easy to process all edges that start or end at a given
    vertex quickly, and that will speed up several algorithms. However, things become
    slower if you just want to know whether two given points are directly connected;
    with this structure, it would be an *O*(*e*) operation. You may opt for using
    sets instead of lists, as shown later.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，可以快速处理从给定顶点出发或到达的所有边，这将加速多个算法。然而，如果你只是想知道两个给定点是否直接相连，情况就会变得更慢；在这种结构下，它将是一个*O*(*e*)操作。你也可以选择使用集合而非列表，稍后会展示这种方法。
- en: Adjacency Set Representation for Graphs
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图的邻接集合表示
- en: 'The more complex solution we can propose involves using sets (as in [Chapter
    11](chapter11.xhtml)) or trees (as in [Chapter 12](chapter12.xhtml)) instead of
    lists. For instance, when working with balanced search trees, checking whether
    two points are connected is a *O*(log *e*) operation. (You could consider an average
    degree of *e*/*v* edges per node, and then it would be *O*(log *e/v*) instead.)
    With this structure, each vertex is associated with two maps: one for outgoing
    edges and one for incoming edges. The key for both maps would be the “other” point
    in the edge. Adding and removing edges are both *O*(log *e*) operations, so performance
    is better. Processing all arcs out of a node is as fast as with lists.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提出更复杂的解决方案，涉及使用集合（如在[第11章](chapter11.xhtml)中所述）或树（如在[第12章](chapter12.xhtml)中所述），而不是使用列表。例如，在处理平衡搜索树时，检查两个点是否相连是一个*O*(log
    *e*)操作。（你可以考虑每个节点的平均度为*e*/*v*条边，那么操作将是*O*(log *e/v*)）。在这种结构下，每个顶点都与两个映射相关联：一个用于输出边，一个用于输入边。两个映射的关键都是边上的“另一个”点。添加和移除边都是*O*(log
    *e*)操作，因此性能更好。处理从节点出发的所有弧的速度与列表相同。
- en: Finding the Shortest Paths
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 找到最短路径
- en: 'A common problem is as follows: given two points in a graph, find a path from
    the first to the second. A path is a sequence of adjacent edges (each starting
    where the previous ends) that begins at the first point and ends at the second
    one.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题如下：给定图中的两个点，找到从第一个点到第二个点的路径。路径是一个相邻边的序列（每条边开始的地方是上一条边的结束处），它从第一个点开始，到第二个点结束。
- en: 'We already considered this kind of problem when you found a path through a
    maze in [Chapter 5](chapter5.xhtml), so instead solve a more complex problem:
    finding the *shortest* path from a node to another node, or even more generally,
    finding the shortest path for a node to all other nodes. These algorithms will
    not only find whether a path exists, but they’ll also find the best one (cheapest,
    shortest) among all possibilities. If you just want to find a path, any path,
    you can simply stop searching as soon as you reach the destination point.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](chapter5.xhtml)中已经考虑过这种类型的问题，当时你在迷宫中找到了一条路径，因此现在解决一个更复杂的问题：从一个节点到另一个节点的*最短*路径，或者更一般地，找到从一个节点到所有其他节点的最短路径。这些算法不仅会找到路径是否存在，还会找到所有可能路径中最优的（最便宜、最短）。如果你只想找到一条路径，任何路径，只需一旦到达目的地就停止搜索。
- en: Floyd-Warshall’s “All Paths” Algorithm
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Floyd-Warshall的“所有路径”算法
- en: 'This first algorithm is interesting because it applies dynamic programming,
    which you explored in [Chapter 5](chapter5.xhtml). The *Floyd-Warshall algorithm*
    doesn’t have the best possible performance (you’ll see other options for that),
    but it’s definitely the simplest. There’s another difference: here, you’ll find
    the shortest distance between all pairs of nodes, while in other cases you may
    just want to find the distance between a specific pair. This stipulation will
    have an impact on the performance, but in some cases, having the whole table of
    distances may be exactly what’s required.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个算法很有趣，因为它应用了动态规划，这是你在[第 5 章](chapter5.xhtml)中探讨过的内容。*Floyd-Warshall 算法*虽然不是性能最优的（你会看到其他更好的选择），但它绝对是最简单的。还有另一个区别：在这里，你将找到所有节点对之间的最短距离，而在其他情况下，你可能只想找到特定节点对之间的距离。这一要求会对性能产生影响，但在某些情况下，拥有整个距离表可能正是所需的。
- en: Assume the existence of a function *distance*(*i,j,k*) that returns the length
    of the shortest path from point *i* to point *j* using, at most, the first *k*
    nodes in the graph for the path. (In other words, you’re not considering any path
    through the rest of the nodes.) You want to calculate *distance*(*i,j,n*) for
    all values of *i* and *j*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设存在一个函数*distance*(*i,j,k*)，该函数返回从点*i*到点*j*的最短路径长度，最多使用图中前*k*个节点作为路径。（换句话说，你不会考虑经过其他节点的任何路径。）你想计算所有*i*和*j*值的*distance*(*i,j,n*)。
- en: 'The value of *distance*(*i,j,k*) must be either a path that doesn’t include
    the *k*th node or else a path that goes from *i* to *k* and then from *k* to *j*,
    whichever is shortest. In other words, *distance*(*i,j,k*) is the minimum of *distance*(*i,j,k*
    – 1) and *distance*(*i,k,k* – 1) + *distance*(*k,j,k* – 1). This formula is key;
    be sure you totally agree with it. The definition is recursive, but the base case
    is simple: *distance*(*i,i,*0) is 0 for all points, and for *i ≠ j*, *distance*(*i,j,*0)
    is the edge from *i* to *j*, if it exists, or +infinity instead. (What about finding
    the actual paths and not just the distances? See question 17.1.)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*distance*(*i,j,k*)的值必须是一个路径，要么不包含第*k*个节点的路径，要么是从*i*到*k*的路径，再从*k*到*j*的路径，取这两者中较短的路径。换句话说，*distance*(*i,j,k*)是*distance*(*i,j,k*
    – 1)和*distance*(*i,k,k* – 1) + *distance*(*k,j,k* – 1)的最小值。这个公式非常重要；请确保完全理解它。这个定义是递归的，但基本情况很简单：对于所有点，*distance*(*i,i,*0)是0；而对于*i
    ≠ j*，*distance*(*i,j,*0)是从*i*到*j*的边，如果存在的话，否则是+无穷大。（如果不仅仅是求距离，而是要找到实际的路径呢？见问题17.1。）'
- en: As an example, work with the graph in [Figure 17-5](chapter17.xhtml#fig17-5).
    It’s undirected for simplicity, but the algorithm works with directed graphs as
    well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，使用[图 17-5](chapter17.xhtml#fig17-5)中的图形。为了简化起见，它是无向图，但该算法也适用于有向图。
- en: '![](../images/Figure17-5.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-5.jpg)'
- en: 'Figure 17-5: A graph for which you want to find minimum distances between any
    pair of points'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-5：你想在其中找到任意两点之间最短距离的图
- en: '[Figure 17-6](chapter17.xhtml#fig17-6) shows the initial array of distances
    in [Figure 17-5](chapter17.xhtml#fig17-5).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-6](chapter17.xhtml#fig17-6)展示了[图 17-5](chapter17.xhtml#fig17-5)中的初始距离数组。'
- en: '![](../images/Figure17-6.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-6.jpg)'
- en: 'Figure 17-6: The adjacency matrix for the graph in [Figure 17-5](chapter17.xhtml#fig17-5),
    using infinity values for missing edges'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-6：使用无穷大值表示缺失边的[图 17-5](chapter17.xhtml#fig17-5)图的邻接矩阵
- en: The diagonal in [Figure 17-6](chapter17.xhtml#fig17-6) is all zeros, and everything
    is +infinity except for the existing edges. (This is just the adjacency matrix
    using +infinity instead of zero for missing edges, as mentioned earlier in the
    chapter.) In the first iteration, check whether adding the first point (A) as
    an intermediate shortens some distances. In effect, you find that now you can
    go from B to D at a cost of 9, as shown in [Figure 17-7](chapter17.xhtml#fig17-7).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-6](chapter17.xhtml#fig17-6) 中的对角线全是零，除了现有的边，其他都为+无穷大。（这只是使用+无穷大代替零来表示缺失的边，正如本章之前提到的邻接矩阵。）在第一次迭代中，检查将第一个点（A）作为中介是否能缩短某些距离。实际上，你会发现，现在你可以以9的代价从B到D，如[图
    17-7](chapter17.xhtml#fig17-7)所示。'
- en: '![](../images/Figure17-7.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-7.jpg)'
- en: 'Figure 17-7: When you try adding A as an intermediate point, you find a shorter
    distance between B and D.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-7：当你尝试将A作为中介点时，会发现B和D之间的距离变短。
- en: The second iteration checks whether adding B as an intermediate makes for shorter
    routes. You find that you can now go from A to C at a cost of 13 and from C to
    D (C to B and then B to D via A) at a cost of 18, as shown in [Figure 17-8](chapter17.xhtml#fig17-8).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次迭代检查是否将 B 作为中介可以得到更短的路径。你会发现现在从 A 到 C 的成本为 13，从 C 到 D（C 到 B，再从 B 到 D 经过 A）的成本为
    18，如[图 17-8](chapter17.xhtml#fig17-8)所示。
- en: '![](../images/Figure17-8.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-8.jpg)'
- en: 'Figure 17-8: When you try adding B as an intermediate, you find two other shorter
    routes.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-8：当你尝试将 B 作为中介时，你会发现另外两条更短的路径。
- en: In the next iteration you’ll check whether adding C as an intermediate helps;
    then, you’ll try D, E, and so on. You keep iterating until all the nodes have
    been considered and the final result (check it out) provides all the distances
    between nodes (see [Figure 17-9](chapter17.xhtml#fig17-9)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次迭代中，你将检查是否将 C 作为中介有帮助；接着，你会尝试 D、E 等等。你会继续迭代，直到所有节点都被考虑过，最终结果（查看它）提供了所有节点之间的距离（见[图
    17-9](chapter17.xhtml#fig17-9)）。
- en: '![](../images/Figure17-9.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-9.jpg)'
- en: 'Figure 17-9: After trying out all possible intermediate points, you compute
    the final distances matrix.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-9：在尝试了所有可能的中介点之后，你计算出最终的距离矩阵。
- en: 'The code is short:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简短：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The n variable ❶ helps shorten the code; it’s just the number of nodes in the
    graph. The distance array of arrays ❷ includes the distances from every node to
    every other node. Initially, set all distances to +infinity ❸ and then correct
    ❹. The distance from a point to itself is zero ❺, and the distance from a point
    to another, if connected, is the edge’s length ❻. The distance array now has all
    distances with no intermediate points as described previously. The three nested
    loops systematically apply the dynamic programming calculation described earlier
    ❼, and if you find a better (smaller) distance ❽, update the table. In this case,
    you’re keeping only the last table; the values for the *k*th iteration replace
    those of the previous one, because you won’t need them any more. The final result
    ❾ is the table of distances between all pairs of points, as described.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: n 变量 ❶ 有助于缩短代码；它仅仅是图中节点的数量。距离的数组数组 ❷ 包括从每个节点到其他节点的距离。最初，所有的距离都设为 +无穷大 ❸，然后进行修正
    ❹。一个点到自身的距离是零 ❺，而一个点到另一个点的距离，如果连接的话，就是边的长度 ❻。现在，距离数组包含了所有没有中介点的距离，正如前面所描述的那样。三个嵌套的循环系统地应用了前面描述的动态规划计算
    ❼，如果你发现了一个更好的（更小的）距离 ❽，则更新表格。在这种情况下，你只保留最后的表格；第 *k* 次迭代的值会替代前一次的值，因为你再也不需要它们了。最终结果
    ❾ 是描述的所有点对之间的距离表格。
- en: 'What’s the runtime order of this algorithm? The three nested loops, each *O*(*v*),
    provide the answer: *O*(*v*³). This is steep, as mentioned, but it produces all
    distances among all pairs. For just the distance from one node to all the others,
    or even more specifically from one given node to another, you’ll see better algorithms.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的运行时间复杂度是多少？三个嵌套的循环，每个 *O*(*v*)，给出了答案：*O*(*v*³)。正如前面提到的，这是非常陡峭的，但它能计算出所有节点对之间的距离。如果只需要从一个节点到所有其他节点的距离，或者更具体地说，从一个给定节点到另一个节点的距离，你会看到更好的算法。
- en: Bellman-Ford Algorithm
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 贝尔曼-福特算法
- en: 'Now consider a different problem: find the distance from a given node to all
    the others. The idea of the *Bellman-Ford algorithm* is to see whether you can
    find a better path between two nodes by following a given edge, and repeat this
    process until no more alternatives are possible. Start by considering paths that
    are one edge long, and then check whether a shorter path is available when using
    two edges, then three edges, then four, and so on. If a graph has *n* nodes, the
    longest path can have *n* – 1 edges, so that’s a limit for iterating.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个不同的问题：找到一个给定节点到所有其他节点的距离。*贝尔曼-福特算法*的思想是通过遵循一条给定的边，看看是否能找到两个节点之间的更好路径，并重复这个过程，直到没有更多的替代路径。首先考虑一条边长为一的路径，然后检查使用两条边是否有更短的路径，再检查三条边、四条边，依此类推。如果图中有
    *n* 个节点，最长路径可以有 *n* - 1 条边，因此这是迭代的限制。
- en: Let’s work with the same graph and calculate minimum distances from F to all
    the other nodes. (The algorithm works equally well with directed graphs, but you’re
    using an undirected one for simplicity.) The initial situation is shown in [Figure
    17-10](chapter17.xhtml#fig17-10). Without processing any edges (not taking any
    routes), only F can (trivially!) be reached from F, and you cannot reach other
    nodes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的图来计算从 F 到所有其他节点的最短距离。（该算法在有向图中同样有效，但为了简化，使用的是无向图。）初始情况如 [图 17-10](chapter17.xhtml#fig17-10)
    所示。没有处理任何边（没有走任何路线），只有 F 可以（显而易见地！）从 F 到达，你无法到达其他节点。
- en: '![](../images/Figure17-10.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-10.jpg)'
- en: 'Figure 17-10: Apply the Bellman-Ford algorithm to find the minimum distances
    from F to all other points.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-10：应用贝尔曼-福特算法，找到从 F 到所有其他点的最短距离。
- en: Assume that nodes are processed in alphabetical order. When you process the
    edges from A, B, or C, you cannot calculate distances because you don’t know how
    to reach those nodes. When you process the (F,D) edge, you are now able to reach
    node D, and you have the first step in the paths, as shown in [Figure 17-11](chapter17.xhtml#fig17-11).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设节点按照字母顺序处理。当你处理来自 A、B 或 C 的边时，你无法计算距离，因为你还不知道如何到达这些节点。当你处理 (F,D) 边时，你现在能够到达节点
    D，并且你有了路径的第一步，如 [图 17-11](chapter17.xhtml#fig17-11) 所示。
- en: '![](../images/Figure17-11.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-11.jpg)'
- en: 'Figure 17-11: Processing nodes in order, the first other node you can reach
    from F is D.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-11：按顺序处理节点时，从 F 可以到达的第一个其他节点是 D。
- en: You now know that you can reach D with a cost of 3\. Now process the next edge,
    (F,G), and you can reach another node, as shown in [Figure 17-12](chapter17.xhtml#fig17-12).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道可以以 3 的代价到达 D。接下来处理边 (F,G)，你可以到达另一个节点，如 [图 17-12](chapter17.xhtml#fig17-12)
    所示。
- en: '![](../images/Figure17-12.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-12.jpg)'
- en: 'Figure 17-12: The other node you can reach from F is G; you’ll reprocess D
    at a later iteration.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-12：你可以从 F 到达的另一个节点是 G；你将在后续的迭代中重新处理 D。
- en: 'You can then process the edges out of G, because now you know that you can
    reach G. Processing edges (G,C) and (G,E) marks two other nodes as reachable.
    (Don’t forget: any paths or distances you find may change later if better alternatives
    appear.) [Figure 17-13](chapter17.xhtml#fig17-13) shows the new situation.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以处理从 G 出发的边，因为现在你知道可以到达 G。处理边 (G,C) 和 (G,E) 将另外两个节点标记为可达。（别忘了：你找到的任何路径或距离，如果有更好的替代方案出现，可能会改变。）[图
    17-13](chapter17.xhtml#fig17-13) 显示了新的情况。
- en: '![](../images/Figure17-13.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-13.jpg)'
- en: 'Figure 17-13: When processing G, which was reached from F, you can reach C
    and E as well.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-13：处理 G 时，它是从 F 到达的，你也可以到达 C 和 E。
- en: The first pass is done. So far, you know you can reach five of the seven nodes,
    and you have possible (but maybe not optimal) paths for each.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一遍处理完成。到目前为止，你知道可以到达七个节点中的五个，并且你为每个节点找到了可能的（但可能不是最优的）路径。
- en: Now start a new pass. You still can’t do anything with edges out of A or B,
    because you still haven’t gotten to those nodes, but you can process edge (C,B)
    and add a new path, as shown in [Figure 17-14](chapter17.xhtml#fig17-14).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始新的一轮处理。你仍然无法处理 A 或 B 出发的边，因为你还没有到达这些节点，但你可以处理边 (C,B)，并添加一条新路径，如 [图 17-14](chapter17.xhtml#fig17-14)
    所示。
- en: '![](../images/Figure17-14.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-14.jpg)'
- en: 'Figure 17-14: A second iteration now finds that B is reachable from the previously
    reached C.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-14：第二次迭代现在发现 B 可以从之前到达的 C 处到达。
- en: The (C,E) and (C,G) edges don’t represent shorter distances, so you do nothing.
    (For example, you can go from F to E at a cost of 23; going through C would cost
    26, so it’s no good.) When considering the (D,A) and (D,E) edges, things get interesting.
    You can now reach A, and you find a better path to E through D (see [Figure 17-15](chapter17.xhtml#fig17-15)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: (C,E) 和 (C,G) 边并不代表更短的距离，所以你什么也不做。（例如，你可以从 F 到 E，花费 23；而经过 C 的话将花费 26，所以这条路径不行。）考虑
    (D,A) 和 (D,E) 边时，情况变得有趣。你现在可以到达 A，并且通过 D 找到了通往 E 的更好路径（参见 [图 17-15](chapter17.xhtml#fig17-15)）。
- en: '![](../images/Figure17-15.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-15.jpg)'
- en: 'Figure 17-15: A second look at D finds a shorter path to E. The previous way
    was from F to G to E, which was longer than from F to D to E.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-15：第二次查看 D，发现到 E 的路径更短。之前的路径是从 F 到 G，再到 E，长度比从 F 到 D 再到 E 要长。
- en: The previous best path from F to E was through G, at a cost of 23, but now you
    find you can go through D at a cost of 10\. No more changes are possible, so start
    a third pass. One further enhancement is that it’s a shorter route to B by going
    through A than through E (see [Figure 17-16](chapter17.xhtml#fig17-16)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从F到E的先前最佳路径是通过G，花费为23，但现在你发现可以通过D，花费为10。没有更多的变化可以进行，因此开始第三次遍历。一个进一步的改进是，通过A到B的路线比通过E更短（见[图17-16](chapter17.xhtml#fig17-16)）。
- en: '![](../images/Figure17-16.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-16.jpg)'
- en: 'Figure 17-16: A third pass finds a better way from A to B, but no further changes.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-16：第三次遍历找到了一条更好的从A到B的路径，但没有更多的变化。
- en: The third pass doesn’t add any more changes, and further passes won’t either,
    so you’re done. You know the shortest paths from the starting point F to all other
    points, and you know what edges to follow to achieve that cost.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次遍历没有带来更多的变化，进一步的遍历也不会有，因此你完成了。你已经知道从起点F到所有其他点的最短路径，并且知道要遵循哪些边来达到这个成本。
- en: 'You can code this algorithm as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按如下方式编写这个算法：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use a previous array ❶ to learn from which node you arrived at the corresponding
    node; if previous[j] is i, the shortest path from the start to j passed through
    i right before going to j. The distance array ❷ keeps track of the distances from
    the start to every node; initialize all distances to +infinity, except the distance
    from the start to itself ❸, which is obviously zero. In order to process all edges
    without having to go through the whole matrix, create an edges array ❹; iterating
    with this array will be faster. Now iterate n – 1 times ❺: for each edge ❻, see
    whether using it provides a shorter way between its two endpoints ❼; if so, update
    the distance to the second node ❽ and record from which node you came ❾. (Can
    you do better with fewer passes? See question 17.2.) The results of this algorithm
    are an array with distances and an array showing indirectly how to reach the start
    ❿ from any node.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个前驱数组❶来记录你是从哪个节点到达当前节点的；如果previous[j]是i，则从起点到j的最短路径是先通过i再到j。距离数组❷记录了从起点到每个节点的距离；将所有的距离初始化为+infinity，除了从起点到自身❸的距离，显然为零。为了处理所有的边而不必遍历整个矩阵，创建一个边数组❹；用这个数组进行迭代会更快。现在进行n
    - 1次迭代❺：对于每条边❻，查看使用它是否提供了从两个端点之间的更短路径❼；如果是，更新第二个节点的距离❽，并记录你是从哪个节点到达的❾。（你能通过减少遍历次数做得更好吗？见问题17.2。）该算法的结果是一个包含距离的数组和一个显示如何从任何节点间接到达起点❿的数组。
- en: What’s the order of this algorithm? Given that the loop runs *O*(*v*) times
    and each time it goes through all edges, the result is *O*(*ve*). This is better
    than Floyd-Warshall’s algorithm, but it finds all distances from a single origin
    to all the rest. You can do even better, as you’ll see in a final algorithm for
    that problem.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的时间复杂度是多少？鉴于循环运行了*O*(*v*)次，并且每次都会遍历所有边，结果是*O*(*ve*)。这个比Floyd-Warshall算法更好，但它仅找到从单个起点到所有其他点的最短距离。你可以做得更好，正如你将在解决这个问题的最终算法中看到的那样。
- en: Dijkstra’s Algorithm
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Dijkstra算法
- en: 'If you want to find the shortest path from one point to all others (or to a
    specific point in particular), Dijkstra’s algorithm is quite efficient. It proceeds
    by starting at the first point (considered to be *visited*, at distance zero from
    itself), which becomes the initial *current* point. All other points are considered
    to be *unvisited* and at distance +infinity. From then on, it does the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想找到从一个点到所有其他点（或特别是某个特定点）的最短路径，Dijkstra算法非常高效。它通过从第一个点开始（该点被认为是*已访问*的，距离自身为零），成为初始的*当前*点。所有其他点都被认为是*未访问*的，距离为+infinity。从那时起，它会执行以下操作：
- en: 1. Studies all as yet unvisited neighbors of the current node, and if there’s
    a shorter path to the neighbor, it chooses that path and updates the distance
    to the unvisited node.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 遍历所有当前节点的未访问邻居，如果到该邻居有更短的路径，就选择那条路径并更新到未访问节点的距离。
- en: 2. After having processed all the unvisited neighbors of the current node, mark
    that node as visited, and you’re done with it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在处理完当前节点的所有未访问邻居之后，将该节点标记为已访问，并且你就完成了它。
- en: 3. If any unvisited points remain, choose the one with the shortest distance,
    make it the current node, and repeat the process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 如果还有未访问的点，选择距离最短的那个，将其作为当前节点，并重复此过程。
- en: 4. The algorithm ends when no unvisited points remain (if you want the distances
    from the origin to all other points) or when the destination point has been marked
    as visited (if you just want that particular distance).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 当没有未访问的点剩下时，算法结束（如果你想要从起点到所有其他点的距离），或者当目标点被标记为已访问时（如果你只关心该特定距离）。
- en: Consider an example and then the implementation. For simplicity, you’ll work
    with the same undirected graph as before, but Dijkstra’s algorithm works equally
    well with directed graphs. [Figure 17-17](chapter17.xhtml#fig17-17) shows the
    initial configuration, with the origin point marked as visited.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，然后进行实现。为了简便，你将使用之前相同的无向图，但 Dijkstra 算法同样适用于有向图。 [图 17-17](chapter17.xhtml#fig17-17)
    显示了初始配置，起点被标记为已访问。
- en: '![](../images/Figure17-17.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-17.jpg)'
- en: 'Figure 17-17: The initial setup for Dijkstra’s algorithm: the distance from
    A to itself is zero, and distances from A to other nodes are set to +infinity.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-17：Dijkstra 算法的初始设置：从 A 到自身的距离是零，而从 A 到其他节点的距离设置为 +无穷大。
- en: Considering adjacencies from the current point (A), you know you can reach B,
    D, and E (see [Figure 17-18](chapter17.xhtml#fig17-18)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑从当前点（A）到邻居的边，你知道你可以到达 B、D 和 E（见 [图 17-18](chapter17.xhtml#fig17-18)）。
- en: '![](../images/Figure17-18.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-18.jpg)'
- en: 'Figure 17-18: Considering the edges from A to its neighbors, you can tentatively
    update the distances to B, D, and E.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-18：考虑从 A 到其邻居的边，你可以暂时更新到 B、D 和 E 的距离。
- en: You’ve updated the distances to those three nodes, but they’re strictly tentative
    at this point, as you may find better paths later—and you will, as there’s a shorter
    way from A to E, for example.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经更新了到这三个节点的距离，但这些更新目前只是暂时性的，因为你可能会在后续找到更好的路径——比如，从 A 到 E 就有一条更短的路径。
- en: The next step marks B as the current point, because it’s the closest unvisited
    one (see [Figure 17-19](chapter17.xhtml#fig17-19)).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步标记 B 为当前节点，因为它是最近的未访问节点（见 [图 17-19](chapter17.xhtml#fig17-19)）。
- en: '![](../images/Figure17-19.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-19.jpg)'
- en: 'Figure 17-19: Repeat the procedure starting from B, the closest unvisited node,
    and find better distances to C and E.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-19：从 B 开始重复这一过程，B 是最近的未访问节点，并找到到 C 和 E 的更短路径。
- en: You found a way to C with a distance of 13, because B was at a distance of 4,
    and the (B,C) edge costs 9\. You also found a shorter way to E, so update those
    distances. Point B now is marked as visited, and you turn to D as the new current
    node (see [Figure 17-20](chapter17.xhtml#fig17-20)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你找到了一条到 C 的路径，距离为 13，因为 B 距离为 4，而（B,C）边的权重为 9。你还找到了一条更短的到 E 的路径，因此需要更新这些距离。现在，B
    被标记为已访问，并且你转向 D 作为新的当前节点（见 [图 17-20](chapter17.xhtml#fig17-20)）。
- en: '![](../images/Figure17-20.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-20.jpg)'
- en: 'Figure 17-20: You now start from D, the next closest but not yet visited node,
    and find better distances to F and G.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-20：你现在从 D 开始，D 是下一个最近但尚未访问的节点，找到到 F 和 G 的更短路径。
- en: Working from D allows you to update the distances and paths to F and G. The
    distance to E wasn’t modified, because going through D would have required a distance
    of 12, and you already found a shorter path. Now, F becomes the current node,
    and the process will go quickly, because it allows only one path out, as shown
    in [Figure 17-21](chapter17.xhtml#fig17-21).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从 D 开始，你可以更新到 F 和 G 的距离和路径。到 E 的距离没有被修改，因为通过 D 会需要距离 12，而你已经找到了更短的路径。现在，F 成为当前节点，接下来的过程会很快，因为它只允许一条出路，如
    [图 17-21](chapter17.xhtml#fig17-21) 所示。
- en: '![](../images/Figure17-21.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-21.jpg)'
- en: 'Figure 17-21: Processing F finds a better way to G.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-21：处理 F 后，找到一条更好的到 G 的路径。
- en: You’ve updated the best (as of yet) path to G, which now is 21, going from A
    to D to F first. You’re close to finishing, and E is the next node to process
    (see [Figure 17-22](chapter17.xhtml#fig17-22)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经更新了到 G 的最佳路径（截至目前），现在是 21，从 A 到 D，再到 F。你接近完成，E 是下一个需要处理的节点（见 [图 17-22](chapter17.xhtml#fig17-22)）。
- en: '![](../images/Figure17-22.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-22.jpg)'
- en: 'Figure 17-22: E is processed next and allows you to update distances to C and
    G.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-22：接下来处理 E，允许你更新到 C 和 G 的距离。
- en: Going through E makes the distances to C and G shorter, so update them. The
    next steps choose C and then G, and you don’t need any further changes. [Figure
    17-23](chapter17.xhtml#fig17-23) shows the final result with the selected paths
    and calculated distances from A.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 E 可以使到 C 和 G 的距离更短，所以需要更新这些距离。接下来的步骤选择 C 和 G，然后就不需要再做任何更改。 [图 17-23](chapter17.xhtml#fig17-23)
    显示了从 A 出发的最终结果，选定路径和计算的距离。
- en: '![](../images/Figure17-23.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-23.jpg)'
- en: 'Figure 17-23: When you’re done with all nodes, you get optimum distances from
    A to all other nodes.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-23：当你完成所有节点的处理后，你会得到从 A 到所有其他节点的最优距离。
- en: 'To achieve good performance, it’s important to be able to determine the next
    node (the one with shortest distance) to process quickly. A straightforward loop
    would be an *O*(*v*) algorithm, but you’ve already seen an appropriate structure
    for that: a heap. Using that structure allows you to find the next node to process
    in *O*(1) time, and updating the heap is then *O*(log *v*), which is better.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现良好的性能，快速确定下一个要处理的节点（即距离最短的节点）非常重要。一个直接的循环会是一个*O*(*v*)算法，但你已经看到了一种合适的结构：堆。使用这种结构可以让你在*O*(1)时间内找到下一个要处理的节点，而更新堆则是*O*(log
    *v*)，这要更好。
- en: 'The main algorithm is as follows, but you’ll look at a portion of it related
    to the heap later:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 主要算法如下，但稍后你会看到与堆相关的一部分：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The points array ❶ contains the distances from the starting point (from) to
    all others. The i attribute identifies the point; done marks whether you’ve finished
    processing it; dist is the distance, initialized to +infinity for all points except
    the initial; and prev shows from which point you arrived at the current one ❷.
    The index attribute requires explanation. As mentioned, you’ll be keeping the
    distances in a heap and updating them, which may cause them to bubble up. However,
    you need to know where each point is in the heap, and that’s what the index indicates.
    This way, whenever you update the distance for a point p you know that points[p].index
    is the corresponding place in the heap.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: points 数组❶包含从起点（from）到其他所有节点的距离。i 属性标识点；done 标记你是否已经处理完该点；dist 是距离，除了初始点外，所有点的初始值为正无穷；prev
    显示从哪个点到达当前点❷。index 属性需要解释。正如前面提到的，你将把距离保存在堆中并进行更新，这可能导致它们向上浮动。然而，你需要知道每个点在堆中的位置，这就是
    index 的作用。这样，当你更新点 p 的距离时，你知道 points[p].index 就是堆中对应的位置。
- en: Push every point in the heap starting with from ❸ and update all the index values
    ❹. (Because there’s a single zero distance in the points array and all others
    are +infinity, you’ve created a heap without needing any comparisons.) While the
    heap isn’t empty ❺, you remove the top point ❻ and mark it as done and proceed
    to update the distances to all the nodes that it can reach ❼. If a distance gets
    updated with a lower value ❽, check whether it should bubble up in the heap. The
    final result ❾ is the updated points array with distances from the initial node
    to all others.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个点推入堆中，从起点 from ❸ 开始，并更新所有的 index 值 ❹。（由于在 points 数组中只有一个零距离，其他所有的距离都是正无穷，所以你可以创建一个无需任何比较的堆。）当堆不为空
    ❺ 时，你移除堆顶点 ❻，标记其为已处理，并继续更新所有它能到达的节点的距离 ❼。如果某个距离更新为更小的值 ❽，则检查它是否应该在堆中上浮。最终结果 ❾
    是更新后的 points 数组，包含从初始节点到其他所有节点的距离。
- en: 'Now consider the heap code, directly based on what we saw in [Chapter 14](chapter14.xhtml):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑堆的代码，直接基于我们在[第14章](chapter14.xhtml)中看到的内容：
- en: '[PRE3]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The swap(...) function just exchanges two values in the heap ❶ and also updates
    the corresponding index attributes in the points array, so you can keep track
    of where each node is in the heap. The sinkDown(...) function ❷ works as you saw
    in [Chapter 14](chapter14.xhtml). Notice that you don’t compare the heap values
    ❸, but rather compare the distances from the points array using the heap values
    as indices. (In the sorting code in [Chapter 14](chapter14.xhtml), we directly
    compared the heap values.) The same change applies in the bubbleUp(...) function
    ❹ ❺.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: swap(...) 函数只是交换堆中两个值 ❶，并同时更新 points 数组中相应的 index 属性，这样你就可以追踪每个节点在堆中的位置。sinkDown(...)
    函数 ❷ 的工作原理与[第14章](chapter14.xhtml)中看到的一样。注意，你不比较堆的值 ❸，而是使用堆值作为索引，比较 points 数组中的距离。（在[第14章](chapter14.xhtml)中的排序代码中，我们直接比较了堆的值。）同样的改动也适用于
    bubbleUp(...) 函数 ❹ ❺。
- en: What’s the performance of this algorithm? As is, each point is processed once,
    and for each point you check whether you need to update the distances to all the
    others, so it’s *O*(*v*²). You can enhance it by having a list of adjacent points,
    as with the adjacency list representation for graphs, and then the performance
    becomes *O*(*v* log *v*) because of the heap usage.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的性能如何？目前，每个点只处理一次，并且对于每个点，你都检查是否需要更新到其他所有点的距离，所以它的时间复杂度是*O*(*v*²)。你可以通过使用邻接点列表来优化它，类似于图的邻接表表示法，这样性能就变成了*O*(*v*
    log *v*)，因为堆的使用。
- en: Sorting a Graph
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对图进行排序
- en: At the beginning of this chapter we mentioned some real-life applications of
    graphs, like tracking dependencies in code (modules that import from other modules)
    or project management (showing tasks that rely on the completion of other tasks).
    In that situation, we may want to find whether a certain ordering of nodes will
    make everything work out smoothly. Conversely, we may want to check whether code
    has circular dependencies or whether completing a given task will be impossible.
    We want to be able detect such issues with graphs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们提到了一些图的实际应用，例如跟踪代码中的依赖关系（模块间的导入关系）或项目管理（显示依赖于其他任务完成的任务）。在这种情况下，我们可能希望找出某种节点排序是否能使一切顺利进行。相反，我们可能希望检查代码是否存在循环依赖，或是否某个任务无法完成。我们希望能够使用图来检测这些问题。
- en: 'This type of task is called *topological sorting*, and it implies that given
    a graph, we sort its nodes in order so that all links “go forward” and there’s
    never a link from a vertex to a previous node. We’ll consider two algorithms for
    such a sort: Kahn’s algorithm, which is based on a simple procedure involving
    counting, and Tarjan’s algorithm, which applies depth-first searching to produce
    the order we want in a backward fashion where the last vertices are output first.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种任务被称为*拓扑排序*，它意味着给定一个图，我们按照顺序对其节点进行排序，使得所有的链接“向前”连接，并且不会有从一个顶点指向先前节点的链接。我们将考虑两种排序算法：Kahn算法，它基于一个简单的计数程序，以及Tarjan算法，它应用深度优先搜索，以倒序的方式生成我们所需的排序，其中最后的顶点首先输出。
- en: Kahn’s Algorithm
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Kahn算法
- en: 'Consider a basic argument: if a graph has topological ordering, there must
    be at least one node with no incoming edges, and *Kahn’s algorithm* is based on
    that. (This is similar to saying that in any set of numbers, there must be one
    that is less than the rest.) You can select each of these nodes with no problems.
    If you then discard all the edges that start from those nodes, you should be left
    with nodes that have no incoming edges, and you can repeat the procedure. If at
    some point you’ve still got nodes to consider but all have at least one incoming
    edge, no topological sort is possible.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个基本的论点：如果一个图有拓扑顺序，那么必须至少有一个节点没有入边，而*Kahn算法*正是基于这一点。（这类似于说在任何一组数字中，必定有一个数字小于其余的数字。）你可以毫无问题地选择这些没有入边的节点。如果你接着丢弃所有从这些节点开始的边，你应该剩下没有入边的节点，然后你可以重复这个过程。如果在某个时刻你还有节点需要处理，但所有节点都有至少一条入边，那么就无法进行拓扑排序。
- en: '[Figure 17-24](chapter17.xhtml#fig17-24) illustrates the procedure with the
    same directed graph we’ve been using for all the examples in this chapter. After
    first doing a count of incoming edges, the numbers in the nodes are the calculated
    counts.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-24](chapter17.xhtml#fig17-24)展示了该过程，使用的是我们在本章所有示例中使用的相同有向图。首先计算入边的数量，节点中的数字即为计算出的数量。'
- en: '![](../images/Figure17-24.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-24.jpg)'
- en: 'Figure 17-24: A graph is set up for topological sorting where the numbers show
    how many incoming edges are there at each point.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-24：为拓扑排序设置的图，其中的数字显示每个点的入边数量。
- en: Given that you found at least one node with zero incoming edges, you can proceed.
    Points E and F can be output in any order, and you then reduce the counts of the
    nodes that you can reach from those two points (see [Figure 17-25](chapter17.xhtml#fig17-25)).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你找到了至少一个入边为零的节点，你可以继续。E点和F点可以按任意顺序输出，然后你减少从这两个点可以到达的节点的计数（见[图 17-25](chapter17.xhtml#fig17-25)）。
- en: '![](../images/Figure17-25.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-25.jpg)'
- en: 'Figure 17-25: Points E and F can be output because they had no incoming edges,
    and you “forget” the outgoing edges from those two points.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-25：E点和F点可以输出，因为它们没有入边，并且你“忘记”了这两个点的出边。
- en: Points E and F were output, which are in positions 0 and 1 of the output array.
    (The nodes in black show index values.) Again, you find at least one node with
    no incoming edges, so B is at position 2 of the output array, and you decrease
    the counts of nodes A and C (see [Figure 17-26](chapter17.xhtml#fig17-26)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: E点和F点被输出，它们位于输出数组的第0和第1位置。（黑色的节点显示的是索引值。）再次，你找到至少一个没有入边的节点，因此B点位于输出数组的第2位置，并且你减少了A和C节点的计数（见[图
    17-26](chapter17.xhtml#fig17-26)）。
- en: '![](../images/Figure17-26.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-26.jpg)'
- en: 'Figure 17-26: Point B now has no predecessors, so its output and edges are
    removed.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-26：B点现在没有前驱节点，因此其输出和边被移除。
- en: 'Now repeat the process: points A and C are output, reduce the counts, and you
    get to the situation shown in [Figure 17-27](chapter17.xhtml#fig17-27).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重复该过程：A 点和 C 点被输出，减少计数，最终得到了[图 17-27](chapter17.xhtml#fig17-27)所示的状态。
- en: '![](../images/Figure17-27.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-27.jpg)'
- en: 'Figure 17-27: Point A is next, then D, and G will be last.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-27：接下来是 A 点，然后是 D 点，最后是 G 点。
- en: The last two steps output D first and then G. [Figure 17-28](chapter17.xhtml#fig17-28)
    shows the final status, and the topological order you want is E, F, B, A, C, D,
    and G.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两步首先输出 D 点，然后是 G 点。[图 17-28](chapter17.xhtml#fig17-28)展示了最终状态，你希望得到的拓扑顺序是
    E、F、B、A、C、D 和 G。
- en: '![](../images/Figure17-28.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-28.jpg)'
- en: 'Figure 17-28: The final result, where the numbers show in which order the points
    were output.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-28：最终结果，数字表示节点输出的顺序。
- en: 'You can code the algorithm as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按如下方式编写算法：
- en: '[PRE4]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Put nodes to be processed in a queue ❶, and from there place them in the output
    sorted array ❷. The incoming array will count the number of incoming edges for
    every node ❸, adding 1 for every such edge. Every node with no incoming edges
    is pushed into the queue for processing ❹, and then you can start the sort itself.
    While there still are nodes to process ❺, you remove them from the queue ❻ and
    push them into the output list ❼. For every node you output ❽, discard its connections
    to other nodes, decreasing the incoming counts ❾. When there are no more nodes
    to process, if all were sorted, you succeeded ❿; otherwise, you failed. The remaining
    nodes have at least one incoming edge, which means no topological sort is possible.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将待处理的节点放入队列 ❶，然后将它们放入输出排序数组 ❷。传入数组会为每个节点计算进入边的数量 ❸，每当有一条边进入，计数加 1。没有进入边的节点会被推入队列进行处理
    ❹，然后你可以开始排序过程。只要还有节点需要处理 ❺，就从队列中取出它们 ❻，并将它们推入输出列表 ❼。每输出一个节点 ❽，就丢弃它与其他节点的连接，减少进入计数
    ❾。当没有更多节点需要处理时，如果所有节点都已排序，则表示成功 ❿；否则，表示失败。剩余的节点至少有一条进入边，这意味着无法进行拓扑排序。
- en: Tarjan’s Algorithm
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Tarjan 算法
- en: 'We’ll apply a depth-first search algorithm for another way to produce a topological
    sort. The idea is to start *traveling* from a node, marking the way at each node
    you pass (Hansel and Gretel style) and seeing how far you can get before arriving
    at a dead end or returning to a node that you already marked, which means you
    found a cycle and no topological sort is possible. You can mark the nodes from
    which no more movement is possible as *done* and output them and then ignore them
    from then on. In this fashion, you’ll produce the topological sort in reverse
    order: you’ll output the last nodes in the sort first, and the first nodes will
    be last.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用深度优先搜索算法，提供另一种生成拓扑排序的方法。其思路是从一个节点开始*遍历*，标记每个经过的节点（像汉赛尔和格雷特尔那样），并看看在到达死胡同或回到已标记的节点之前能走多远，这意味着你找到了一个循环，因此无法进行拓扑排序。你可以将没有更多可行路径的节点标记为*已完成*并输出它们，然后从此忽略它们。通过这种方式，你将反向生成拓扑排序：你会首先输出排序中的最后节点，而最前面的节点则最后输出。
- en: '[Figure 17-29](chapter17.xhtml#fig17-29) shows an example with the same graph
    we’ve used throughout the chapter. Start at point A, mark it as *in progress*
    (in gray), and consider all the edges out of it. There’s only one. If in future
    steps you get back to node A and it’s gray, you’ll have found a cycle.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-29](chapter17.xhtml#fig17-29)展示了我们在本章中使用的相同图形。首先从 A 点开始，标记它为*进行中*（灰色），并考虑从它出发的所有边。只有一条边。如果在后续步骤中你回到
    A 点，并且它是灰色的，那么就意味着你发现了一个循环。'
- en: '![](../images/Figure17-29.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-29.jpg)'
- en: 'Figure 17-29: The same graph as in the previous section set up for Tarjan’s
    algorithm. You started at A and reached D; A is grayed out.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-29：与上一部分相同的图，用于设置 Tarjan 算法。你从 A 点开始，达到了 D 点；A 点被标记为灰色。
- en: You’re now at point D, which hasn’t been visited. Mark it gray as well and check
    which nodes you can reach from it. In this case, you can reach only G (see [Figure
    17-30](chapter17.xhtml#fig17-30)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你处在 D 点，这个点还没有被访问。也将它标记为灰色，并检查你能从它到达哪些节点。在这种情况下，你只能到达 G（见[图 17-30](chapter17.xhtml#fig17-30)）。
- en: '![](../images/Figure17-30.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-30.jpg)'
- en: 'Figure 17-30: After D, you reach G; D is grayed out.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-30：在 D 点之后，你到达了 G 点；D 点被标记为灰色。
- en: Repeat the process at G, and no edges come out of it, so mark it as *done* and
    output it. The sorted list starts as shown in [Figure 17-31](chapter17.xhtml#fig17-31).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 G 点重复该过程，没有边从 G 点出去，因此将其标记为*已完成*并输出。排序后的列表如下所示，见[图 17-31](chapter17.xhtml#fig17-31)。
- en: '![](../images/Figure17-31.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-31.jpg)'
- en: 'Figure 17-31: From G you can’t reach any other point, so output G to the sorted
    list.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Having dealt with G, you can mark D as *done* (and output it) and then do the
    same with A (see [Figure 17-32](chapter17.xhtml#fig17-32)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-32.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-32: D has no further connections to other nodes, so it may be output,
    and then A is output too.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re done with A, start from B. The link from B to A goes to a node
    marked *done*, so you ignore it. The link from B to C needs processing, though:
    B is marked *in progress*, and you go to C (see [Figure 17-33](chapter17.xhtml#fig17-33)).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-33.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-33: Starting at B, you can reach only one point that has not yet
    been output: C.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Mark C as *in progress*, but its only edge goes to a node marked *done* (G),
    so mark C as *done* and add it to the output. After that, you’re done with B as
    well, which also is output (see [Figure 17-34](chapter17.xhtml#fig17-34)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-34.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-34: C is linked only to an already output point, so you can output
    C and, after that, output B.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The final steps are similar. From E all the links lead to nodes marked as *done*,
    so E becomes marked as *done* and is output; the same happens to F, and you’re
    finished, having visited all nodes and produced a topological sort, as shown in
    [Figure 17-35](chapter17.xhtml#fig17-35).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-35.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-35: When all points have been output, the algorithm ends.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this algorithm follows. The *in-progress* nodes are marked with
    a 1 (a temporary mark) and the *done* nodes are marked with a 2 (a final mark):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The marks array ❶ keeps track of visited and unvisited nodes. A 0 means the
    node hasn’t been visited yet. A 1 means it was visited and you’re going through
    all its reachable nodes, and a 2 means that the node has been dealt with and output
    already. The sorted array ❷ gets the output of the algorithm. You define a recursive
    function ❸ to visit all nodes that a p starting node can reach. If the node was
    marked with a 1 ❹, it means that, when starting from there, you eventually returned
    to it. In other words, there’s a cycle, so no topological sort is possible. If
    the node is marked with a 0 ❺, temporarily mark it with a 1 and visit all the
    unvisited nodes that are reachable from it ❻; skip visiting any nodes marked with
    2 ❼ because those were already analyzed. After all the visiting is finished, change
    the 1 to 2 ❽ and output the current node p ❾; use unshift() to get the right order.
    To produce the topological sort ❿, all you have to do is start from every possible
    node and apply the visiting logic.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: What’s the performance of this algorithm? Each node is visited once, and all
    its links are processed, but for each node, it checks the whole row for possible
    links to traverse, making this implementation *O*(*v*²). The algorithm would benefit
    from an adjacency list representation, because then you would be able to process
    the edges from a node directly, producing *O*(*ve*).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的性能如何？每个节点只被访问一次，且处理它的所有连接，但对于每个节点，它会检查整行是否有可能的连接可以遍历，这使得该实现的时间复杂度为 *O*(*v*²)。该算法如果采用邻接表表示会更加高效，因为那样你就可以直接处理一个节点的边，时间复杂度为
    *O*(*ve*)。
- en: Detecting Cycles
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测循环
- en: Another question to consider is whether a graph includes any cycles. (In other
    words, is the graph a tree or a forest or not?) For example, when programming,
    if there’s a cycle in a list of dependencies among modules, something is seriously
    wrong! A cycle-detection algorithm just needs to check whether it can find at
    least one cycle in a given graph.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是图中是否包含任何循环。（换句话说，图是否是树或森林？）例如，在编程时，如果模块之间的依赖列表中存在循环，那就严重出问题了！一个循环检测算法只需要检查它是否能在给定的图中找到至少一个循环。
- en: 'Fortunately, we’ve already seen an algorithm that does this type of detection:
    Tarjan’s topological sort includes the logic to detect when a cycle is found,
    so we’ve already got what we need. The following code is directly extracted from
    that algorithm:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经看到了一种可以做这种检测的算法：Tarjan的拓扑排序包含了检测循环的逻辑，所以我们已经有了所需的内容。以下代码直接提取自该算法：
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All the code is the same; the only differences here are that you don’t define
    a sorted array for the output ❶. You obviously don’t add anything when marking
    a node as totally visited ❷, and you return a boolean value instead of an array
    or null ❸.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的代码都是一样的；这里唯一的区别在于，你没有为输出定义一个排序数组❶。显然，在标记一个节点为完全访问时，你不会添加任何内容❷，并且你返回的是布尔值，而不是数组或null❸。
- en: Detecting Connectivity
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测连通性
- en: 'Now consider a different problem: How can you determine whether a given graph
    is fully connected? An undirected graph is connected if there’s a path between
    every pair of points in the graph; there’s no point you can’t reach from any other
    point. (A border case is that a graph with only one vertex is also considered
    to be connected.) If a graph doesn’t satisfy this condition, we can split it into
    two or more connected subgraphs.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑另一个问题：如何判断一个图是否是完全连通的？一个无向图是连通的，如果图中每一对点之间都有路径；从任何一点都可以到达其他所有点。（一个极限情况是，只有一个顶点的图也被认为是连通的。）如果图不满足这个条件，我们可以将它拆分为两个或更多的连通子图。
- en: Several algorithms can detect whether a given graph is connected; we’ll consider
    two here. One algorithm introduces another data structure that allows merging
    sets, and the other uses a recursive traversal of the graph.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种算法可以检测给定图是否是连通的；我们这里考虑两种。一种算法引入了另一种数据结构，允许合并集合，另一种使用递归遍历图。
- en: '#### Detecting Connectivity with Sets'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用集合检测连通性'
- en: There’s a rather simple way to find how many connected parts a graph has. Start
    by forming different sets, each with a single vertex. Then, go through all the
    edges in the graph, and if an edge links vertices that appear in different sets,
    join them so that they form a new, larger set. After going through all the edges,
    if you’re left with a single set, the graph was connected; if you’re left with
    several sets, the graph was unconnected.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种相当简单的方法可以找出一个图有多少个连通部分。首先，形成不同的集合，每个集合中只有一个顶点。然后，遍历图中的所有边，如果一条边连接了不同集合中的顶点，就将它们合并，形成一个新的、更大的集合。遍历完所有的边后，如果剩下一个集合，说明图是连通的；如果剩下多个集合，说明图是不连通的。
- en: The question is how to implement these sets. You need to be able to determine
    whether any two points are in the same set and be able to join two sets. There’s
    an efficient way of doing this by working with a forest of trees, as we explored
    in [Chapter 13](chapter13.xhtml).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是如何实现这些集合。你需要能够判断任意两点是否在同一个集合中，并能够将两个集合合并。通过操作一组树的森林，有一种高效的方法可以做到这一点，正如我们在[第13章](chapter13.xhtml)中探索的那样。
- en: Consider how this concept works. Each set is represented by an *upward* tree
    with pointers that go up from the leaves to the root (the opposite of what you
    did in previous chapters). The leaves of the tree are its elements, and intermediate
    nodes are added as needed. To see whether two values are in the same set, follow
    the path up to the root from each leaf. If you reach the same root, the values
    are in the same set. Finally, to join two sets, just add a new root and make the
    roots of the two sets point to it. [Figure 17-36](chapter17.xhtml#fig17-36) shows
    an initial setup with six values, each in a separate set. Note that all pointers
    are implied to go up, which is a big difference from previous chapters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-36.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-36: Start with each node in its individual tree.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: If you want to check whether, say, D and E are in the same set, follow the pointers
    up, and upon arriving at different roots, you can conclude that they aren’t.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: To make them part of a single set, just add a new root, and you get the situation
    shown in [Figure 17-37](chapter17.xhtml#fig17-37).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-37.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-37: Putting D and E in the same set requires adding a new root; now
    D and E are in the same tree.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: If you now check whether D and E are in the same set, the answer is yes, because
    following pointers up, you’d arrive at the same root. If you ask whether F and
    D (or F and E) are in the same set, the answer is no, and joining the sets produces
    the situation shown in [Figure 17-38](chapter17.xhtml#fig17-38).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-38.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-38: Adding F to the previous (D,E) set again adds a new root, and
    now the three original trees are joined.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: You can handle all of this with simple pointer manipulation and end up with
    an upside-down forest. Joining A with C and then A with E produces a new configuration
    (see [Figure 17-39](chapter17.xhtml#fig17-39)).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-39.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-39: In this final scheme, you find that (A,C,D,E,F) are a set and
    (B) is a separate set.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 17-39](chapter17.xhtml#fig17-39), you have only two sets: a singleton
    (with just B) and another set that contains all the other values.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm is short:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Start by defining all groups with just a single element ❶, and the count variable
    tracks how many groups exist at any moment ❷. The findParent(...) auxiliary function
    goes up from each vertex to find the root of its group ❸. The rest is straightforward:
    go through all edges ❹ and check whether both endpoints of edges ❺ are in the
    same group; if not ❻, join the groups by creating a new, common root for both
    trees and decrease the group count by one ❼. After processing all the edges, if
    you’re left with a single group ❽, the graph was connected. If you want to know
    how many subgraphs it has, you could check the count instead.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Connectivity with Searches
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second algorithm we’ll consider is based on starting from any point and
    applying a systematic, recursive search. Check which points you can reach, and
    then which points you can reach from those, and so on, until you’ve considered
    all the edges. Every time you start visiting from a certain point, mark it as
    *visited* to avoid trying it again.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的第二个算法基于从任何点开始并应用系统的递归搜索。检查你可以到达哪些点，然后检查你从那些点可以到达哪些点，以此类推，直到你检查完所有的边。每次从某个点开始访问时，将其标记为*已访问*，以避免再次访问它。
- en: Given the same graph you’ve been using, shown in [Figure 17-40](chapter17.xhtml#fig17-40),
    and arbitrarily starting at A, which would be the first node to visit?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 给定你一直在使用的相同图，见[图17-40](chapter17.xhtml#fig17-40)，并且从A开始，哪个节点会是第一个访问的节点？
- en: '![](../images/Figure17-40.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-40.jpg)'
- en: 'Figure 17-40: To check connectivity, start at any point, in this case A, and
    mark it.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-40：为了检查连通性，从任何一个点开始，本例中从A开始并标记它。
- en: From A, you reach B, D, and E, and none of them have been visited already. Mark
    them and start searching from B, as shown in [Figure 17-41](chapter17.xhtml#fig17-41).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从A出发，你可以到达B、D和E，并且这些点都没有被访问过。将它们标记并从B开始搜索，如[图17-41](chapter17.xhtml#fig17-41)所示。
- en: '![](../images/Figure17-41.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-41.jpg)'
- en: 'Figure 17-41: From A you can reach unmarked points B, D, and E, which you mark.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-41：从A你可以到达未标记的点B、D和E，并将其标记。
- en: From B, you can reach A or E, but those are already marked as visited, so just
    add C to your search (see [Figure 17-42](chapter17.xhtml#fig17-42)).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从B你可以到达A或E，但这两个节点已经被标记为已访问，因此只需将C添加到搜索中（参见[图17-42](chapter17.xhtml#fig17-42)）。
- en: '![](../images/Figure17-42.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-42.jpg)'
- en: 'Figure 17-42: From B you can add the still-unmarked C, and from D you add the
    unmarked F and G.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-42：从B你可以添加尚未标记的C，从D你可以添加尚未标记的F和G。
- en: From D, you can reach A, E, F, and G, but A and E are already marked, so just
    add F and G to the process (see [Figure 17-43](chapter17.xhtml#fig17-43)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从D出发，你可以到达A、E、F和G，但A和E已经被标记，因此只需将F和G添加到流程中（参见[图17-43](chapter17.xhtml#fig17-43)）。
- en: '![](../images/Figure17-43.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-43.jpg)'
- en: 'Figure 17-43: All points have been marked, so the graph is connected.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-43：所有点都已标记，因此图是连通的。
- en: The rest of the algorithm is quick, because no unmarked nodes remain to be reached
    from E, C, F, or G (in the order you checked them), so you’re done, and since
    all vertices ended up marked, the graph was connected. If there had been a separate
    subgraph, you wouldn’t have been able to reach it, so its nodes would have been
    left unmarked and the algorithm would have returned false.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的其余部分很快，因为从E、C、F或G（按照你检查它们的顺序）没有剩余的未标记节点可以到达，因此你已经完成了，并且因为所有顶点都已标记，所以图是连通的。如果存在一个独立的子图，你将无法到达它，因此它的节点将保持未标记，算法将返回false。
- en: 'You can also do the search in depth-first style, which is actually simpler
    to code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以采用深度优先搜索方式进行搜索，这实际上更容易编码：
- en: '[PRE8]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Start by marking all points as unvisited ❶. The auxiliary visit(...) recursive
    function ❷ does the search. Given a point, it goes through all of its outgoing
    edges ❸. If it finds an unvisited point ❹, it marks it ❺ and visits it ❻. To run
    the algorithm, start by marking any point (the first in this case) as visited
    ❼, and call the visit function ❽ to do the search. If you finish the algorithm
    with every point marked as visited ❾, you’ve succeeded.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将所有点标记为未访问❶。辅助访问(...)递归函数❷进行搜索。给定一个点，它会遍历所有出去的边❸。如果它找到一个未访问的点❹，则标记该点❺并访问它❻。要运行算法，首先将任何一个点（本例中为第一个点）标记为已访问❼，然后调用访问函数❽进行搜索。如果你完成算法并且每个点都被标记为已访问❾，则表示成功。
- en: Finding a Minimum Spanning Tree
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找最小生成树
- en: 'This problem applies to weighted undirected graphs. Imagine we want to connect
    people to the electrical grid or some other similar service and we know the cost
    of linking a given pair of points together. We don’t need to build *all* possible
    connections between points; rather, we want to choose a set that, at minimum cost,
    allows all the vertices to connect to each other. Several algorithms solve this
    problem, and we’ll consider the two best known here: *Prim’s algorithm* and *Kruskal’s
    algorithm*. If those algorithms are applied to connected graphs, the output will
    be a tree linking all of its nodes. If a graph is not connected, we’ll find a
    forest of trees instead for each independent group of nodes.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题适用于加权无向图。假设我们想将人们连接到电网或其他类似服务，并且我们知道连接给定一对点的成本。我们不需要构建*所有*可能的点连接；而是要选择一个集合，以最小成本使所有的顶点连接到一起。几种算法可以解决这个问题，我们将在这里讨论两个最著名的算法：*Prim
    算法*和 *Kruskal 算法*。如果这些算法应用于连接图，则输出将是一个连接所有节点的树。如果图不是连通的，我们会为每个独立的节点组找到一片树的森林。
- en: '#### Prim’s Algorithm'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *Prim 算法*'
- en: 'The description for *Prim’s algorithm* is simple: to build the tree, start
    with any node and keep adding the closest node (meaning, minimum link cost) not
    yet connected to the tree until no more nodes are left. It can be proven that
    this will produce the desired minimum tree, but we won’t go into that proof here.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*Prim 算法*的描述很简单：构建树时，从任意节点开始，持续添加尚未连接到树中的最近节点（即，最小连接成本的节点），直到没有节点可选。可以证明，这样会产生所需的最小生成树，但我们不会在这里进行证明。'
- en: Start with the same undirected graph we’ve been using (see [Figure 17-44](chapter17.xhtml#fig17-44))
    and arbitrarily choose A as the starting node.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们一直在使用的相同无向图开始（见[图 17-44](chapter17.xhtml#fig17-44)），并任意选择 A 作为起始节点。
- en: '![](../images/Figure17-44.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-44.jpg)'
- en: 'Figure 17-44: Prim’s algorithm starts by choosing any node. In this case, start
    with A.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-44：*Prim 算法*从选择任意一个节点开始。在这个例子中，从 A 开始。
- en: Now, all of the points still aren’t selected, so choose the closest one, which
    is B in this case (see [Figure 17-45](chapter17.xhtml#fig17-45)).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有的点仍然没有被选择，所以选择离当前节点最近的点，在此例中是 B（见[图 17-45](chapter17.xhtml#fig17-45)）。
- en: '![](../images/Figure17-45.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-45.jpg)'
- en: 'Figure 17-45: Out of all the points adjacent to A, choose the closest, which
    is B.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-45：在所有与 A 相邻的点中，选择最近的，即 B。
- en: 'You’ve got two nodes in the spanning tree. Repeat the selection: the closest
    point to either A or B not yet selected is D, so add that one (see [Figure 17-46](chapter17.xhtml#fig17-46)).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在生成树中选中了两个节点。重复选择：离 A 或 B 最近且尚未选择的点是 D，因此将其添加进去（见[图 17-46](chapter17.xhtml#fig17-46)）。
- en: '![](../images/Figure17-46.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-46.jpg)'
- en: 'Figure 17-46: Out of the points adjacent to A or B, you again choose the closest,
    which is D.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-46：在 A 或 B 相邻的节点中，你再次选择离它们最近的节点，即 D。
- en: 'The upcoming steps are easy to predict: first, add F (which is only three units
    away from the selected nodes), then E, C, and finally G, for a total cost of 30
    units, as shown in [Figure 17-47](chapter17.xhtml#fig17-47).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤很容易预测：首先，添加 F（它距离已选节点仅三单位），然后是 E、C，最后是 G，总成本为 30 单位，如[图 17-47](chapter17.xhtml#fig17-47)所示。
- en: '![](../images/Figure17-47.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure17-47.jpg)'
- en: 'Figure 17-47: After finishing with all nodes, you get a spanning tree.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-47：完成所有节点后，得到一个生成树。
- en: 'Coding this is straightforward. In order to know which is the closest remaining
    unchosen point, you again use a heap. The implementation is a tad different: this
    time, you’ll have objects in the heap with attributes from (a point), to (the
    closest already selected point), and dist (the distance to the closest point,
    which is the length of the edge between those two points). First explore the heap
    algorithms, which were coded iteratively instead of recursively just for variety:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码很简单。为了找出距离当前节点最近的未选择的点，你再次使用堆。实现方式略有不同：这次，你将在堆中使用包含属性的对象，这些属性来自（一个点）、到（离当前选择点最近的点）和
    dist（到最近点的距离，即这两个点之间边的长度）。首先探索堆算法，这些算法是迭代实现的，而不是递归实现，仅仅是为了多样性：
- en: '[PRE9]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When bubbling up a value, check whether you’re not already at the top ❶. If
    not, calculate the position of its parent and compare distances; if the parent
    is lower ❷, you’re done. If not, exchange heap positions ❸ and repeat the procedure
    at the parent’s position ❹. To sink down a value, set up an endless loop ❺ that
    exits when the value cannot sink any lower ❻ because it’s smaller than its children.
    If the value has to sink down, do an exchange ❼ and loop again at the child’s
    position ❽.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for Prim’s algorithm is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Start by setting up the newGraph matrix for the output graph ❶ and the heap
    with all points in it: the from attribute is the point itself, the to attribute
    is the closest already selected point, and the dist attribute is the minimum distance
    from the point to an already selected point of the spanning tree ❷. While the
    heap isn’t empty (implying you haven’t yet considered all vertices), consider
    the top ❸, which is the closest point to the already chosen ones that hasn’t been
    chosen itself yet. The path linking points from ❹ and to ❺ corresponds to the
    shortest pending distance, so add it to newGraph ❻. Then pop the node from the
    heap ❼ and proceed to adjust the distances between the from point and all the
    remaining heap points ❽. Then take each heap element ❾ and consider the distance
    from it to the from point; if there’s a shorter (cheaper) edge ❿, record the edge
    that allows this better path and the corresponding distance and make the node
    bubble up if needed. (So the heap points will always have the shortest distance
    from them to the already chosen points.) When the heap is empty, you’ll have the
    spanning tree in the newGraph matrix.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Kruskal’s Algorithm
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Kruskal’s algorithm* also finds the minimum spanning tree for an undirected
    graph. Instead of adding points one at a time as Prim’s does, this algorithm works
    by adding edges to an initially empty graph. The idea is to sort the edges in
    ascending order and attempt to add each edge unless it would cause a cycle. (We
    won’t give the proof that this algorithm is correct either, but rest assured it
    can be done.) How do we detect cycles? Initially, you have all the points in separate,
    disjointed sets, and every time you add an edge linking two nodes, join the corresponding
    sets (it’s similar to the process in the section “Detecting Connectivity with
    Sets” on [page 454](chapter17.xhtml#pg_454)). Never add an edge whose extremes
    are both in the same set.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Now explore how the algorithm works with the same example graph (see [Figure
    17-48](chapter17.xhtml#fig17-48)).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-48.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-48: The same graph used for Prim’s algorithm'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Add edges one at the time, starting with the lowest, so the first step adds
    the (C,E) edge; now points C and E are in the same set, as shown in [Figure 17-49](chapter17.xhtml#fig17-49).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-49.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-49: Add the smallest edge (C,E) to start.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The next two steps add edges (D,F) and (A,B); no cycles occur anywhere, as shown
    in [Figure 17-50](chapter17.xhtml#fig17-50).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-50.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-50: Keep adding edges, in ascending size, if they do not create cycles.
    First (D,F) was added and then (A,B).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The next steps add (A,D), so A, B, D, and F all end up belonging to the same
    set, and then add (B,E), which makes a big set with all points from A to F (see
    [Figure 17-51](chapter17.xhtml#fig17-51)).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-51.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-51: Repeating the procedure now adds (A,D).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Now things get interesting! The next edge in order is (D,E), but D and E already
    are in the same set, so don’t add that edge. The next step adds (E,G), and you
    get the final tree, as shown in [Figure 17-52](chapter17.xhtml#fig17-52).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-52.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-52: You should add (D,E), but it would create a cycle, so skip it
    and add (E,G) instead.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Future steps won’t add anything, because the edges will always link points that
    are already in the same set, so you’ve got your spanning tree.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Kruskal’s algorithm is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Start by creating an empty matrix for the new tree ❶. Then generate a list
    of all edges in the graph ❷ and sort it ❸ with the simplest method, which is JavaScript’s
    own. (For a better way, check out question 17.8.) You now need to initialize all
    disjointed sets ❹, as you did earlier when detecting connectivity. The groups
    array will have a pointer to the root of each set, all of which will start with
    a single element. You’ll use an iterative version of the earlier recursive findParent(...)
    function ❺ to find to which set a node belongs. The rest of the algorithm is as
    follows: go through the sorted list of edges ❻, and for each one, find the parents
    of both of its extremes ❼. If they don’t match ❽, join both sets by creating a
    new root ❾ and add the edge to the output graph, which you return at the end ❿.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance of the algorithm can be shown to be *O*(*e* log *e*), basically
    because you have to sort all the edges and then go through the list possibly joining
    sets, which also produces the same result. The only disadvantage in this implementation
    is that getting the list of the nodes is *O*(*v*²) due to having to go through
    the whole matrix, but you can enhance it if you adopt another representation for
    the graph using adjacency lists, as we’ve seen.  ### Summary'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced the concept of graphs. We considered representations
    for them and studied many algorithms for common requirements, such as finding
    paths or distances, sorting nodes, detecting cycles, and minimizing costs. These
    algorithms have also benefited from previous algorithms (like sorting and searching)
    and data structures (heaps, bitmaps, trees, forests, and lists), providing a way
    to apply the previous knowledge you’ve gained in various ways.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter of the book, we’ll move on to specific considerations
    for data structures that are meant for a fully functional programming style of
    work, which entails some advantages but also some challenging disadvantages.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**17.1  Where’s the Path?**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Floyd-Warshall’s algorithm finds the shortest distances between every pair
    of points, but what do you do if you also want to know which path to take? Modify
    the algorithm so that finding paths is simple. Hint: whenever you find that going
    from *i* to *j* is better by passing through *k*, make a note so that later, when
    trying to find the actual path, you’ll know to go to *k*.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**17.2  Stop Searching Sooner**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'When considering the Bellman-Ford algorithm, we mentioned that a certain number
    of passes ensured finding the shortest paths, but can you do better? Hint: in
    the example we showed in that section, fewer passes were actually needed.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '**17.3  Just One Will Do**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: How would you modify Dijkstra’s algorithm if you care only about finding the
    shortest path to a single point?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '**17.4  The Wrong Way**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you take a directed graph, reverse all of its edges, and then apply
    Kahn’s topological sort algorithm to it. What will be the output of this algorithm?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**17.5  Joining Sets Faster**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: When joining two distinct sets in the section “Detecting Connectivity with Sets”
    on page 454, you always add a new root, but doing so isn’t necessary, because
    you could just have one root point at the other one. Consider adding a size attribute
    in each root (with the number of nodes in the corresponding subtree) and join
    the smallest tree as a subtree of the largest one. Can you implement these changes?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**17.6  Take a Shortcut**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: When joining sets, doing a little work up-front can save time later. Look again
    at [Figure 17-39](chapter17.xhtml#fig17-39) from the section “Detecting Connectivity
    with Sets” on page 454. Suppose you want to know whether C and D are in the same
    group. You would need to walk from both nodes up to the root before finding the
    answer. However, if you are later asked again about C or D, you’d have to redo
    the path, unless you modify some links, as shown in [Figure 17-53](chapter17.xhtml#fig17-53).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure17-53.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-53: An optimized algorithm for joining sets'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Three links were changed to point to the root directly, so you can get there
    more quickly. (From C or D, it’s just one step to the root, and from E, it’s one
    step shorter than before.) Make a change in the findParent(...) function so it
    creates “shortcut” paths that’ll make future processes faster.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '**17.7  A Spanning Tree for a Tree?**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you apply a spanning tree algorithm to a tree?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '**17.8  A Heap of Edges**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Can you replace JavaScript’s sort with heapsort, quicksort, or any other method
    discussed in the book?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
