<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_163"/><span class="big">6</span><br/>CLIPS</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">Back in the 1980s and 1990s, there was a hot new topic in artificial intelligence: <em>expert systems</em>, that is, programs that attempt to capture the knowledge of human experts in a particular domain in the form of rules, particularly <code>if-then</code> rules. In 1985, NASA developed CLIPS (“C Language Integrated Production System”) to create expert systems. CLIPS has been developed and maintained since then, becoming public domain software in 1996.</p>&#13;
<p class="indent">In this chapter, we’ll use CLIPS to get a feel for what an expert system is and how to create one, at least a primitive one. We’ll introduce CLIPS, and with it, the concepts behind expert systems. Then we’ll explore the language through a series of four examples: a calculator, a second look at the family relationships we explored with Prolog in <a href="ch01.xhtml#ch01">Chapter 1</a>, a simple factory simulation, and a complete expert system for the classification of iris flowers. We’ll end the chapter with a brief discussion of CLIPS as an atypical programming language.</p>&#13;
<h3 class="h3" id="lev1sec47"><span epub:type="pagebreak" id="page_164"/><strong>Installation</strong></h3>&#13;
<p class="noindent">Installing CLIPS is similar to installing SNOBOL. First, we need the tarball, <em>clips_core_source_631.tar.gz</em>, which we download from <em><a href="https://sourceforge.net/projects/clipsrules/files/CLIPS/6.31/">https://sourceforge.net/projects/clipsrules/files/CLIPS/6.31/</a></em>. Example files are in <em>examples_631.tar.gz</em>.</p>&#13;
<p class="indent">Expand the archive and build CLIPS.</p>&#13;
<pre>&gt; <span class="codestrong1">tar xzf clips_core_source_631.tar.gz</span> &#13;
&gt; <span class="codestrong1">cd clips_core_source_631/core/</span>&#13;
&gt; <span class="codestrong1">make</span></pre>&#13;
<p class="indent">Next, run CLIPS to make sure it works.</p>&#13;
<pre>&gt; <span class="codestrong1">./clips</span>&#13;
         CLIPS (6.31 6/12/19)&#13;
CLIPS&gt; <span class="codestrong1">(* (+ 1 2) 3)</span>&#13;
9&#13;
CLIPS&gt; <span class="codestrong1">(exit)</span></pre>&#13;
<p class="noindent">Note that the expression <code>(1+2)*3</code> becomes <code>(* (+ 1 2) 3)</code>. CLIPS, like Lisp, uses <em>S-expressions</em>, which are lists of items surrounded by parentheses. S-expressions are often nested, as in the example here, where the S-expression <code>(+ 1 2)</code> is nested inside the outer expression beginning with <code>*</code>.</p>&#13;
<p class="indent">The main CLIPS site is at <em><a href="http://www.clipsrules.net/">http://www.clipsrules.net/</a></em>. You can download the CLIPS 6.31 documentation from there, though we’ll introduce the essential elements of the system as we use it. If you see a version later than 6.31, go ahead and use it. The probability of CLIPS changing to the point where our examples no longer work is extremely low.</p>&#13;
<h3 class="h3" id="lev1sec48"><strong>Origins and Philosophy</strong></h3>&#13;
<p class="noindent">To understand CLIPS, we must first better understand what an expert system is. Expert systems were popular in the 1980s, and it was hoped then that they would prove helpful as a more general approach to artificial intelligence. We’ll discuss whether this hope was realized later in the chapter, but for now, note that the large-scale application of expert systems never happened.</p>&#13;
<p class="indent">An <em>expert system</em> is a computer program capable of inferring conclusions from a set of rules and facts. The rules are intended to capture the knowledge of a human expert in a specific domain, thereby allowing the software to perform similarly depending on the facts available. This is an abstract definition, and there is certainly room for other nuanced statements related to what an expert system is, but you’ll appreciate what an expert system is as we explore CLIPS.</p>&#13;
<p class="indent">An expert system is a collection of facts, rules (a knowledge base), and an inference engine to use those facts and rules to reach conclusions. Expert systems use facts and rules to determine behavior. For example, an expert system monitoring a building might have a rule like the following:</p>&#13;
<pre><span epub:type="pagebreak" id="page_165"/>if door-is-open and time-is-after-midnight then signal-the-police</pre>&#13;
<p class="noindent">Here, <code>door-is-open</code>, <code>time-is-after-midnight</code>, and <code>signal-the-police</code> are all facts. Note that the last fact is one that the rule puts into the knowledge base when the rule fires. In other words, the rule <em>asserts</em> the fact, which later might cause another rule to fire.</p>&#13;
<p class="indent">In CLIPS this might be written as</p>&#13;
<pre>(defrule intruder&#13;
    ?x &lt;- (door-is-open)&#13;
    ?y &lt;- (after-midnight)&#13;
  =&gt;&#13;
    (retract ?x ?y)&#13;
    (assert (signal-the-police)))</pre>&#13;
<p class="noindent">We’ll get to the exact syntax of a CLIPS rule in a bit, but even now, we can start to see what is going on.</p>&#13;
<p class="indent">Put enough of these rules together and you have a system embodying a tiny knowledge domain. In other words, the system is an expert in that tiny domain. At least, that’s the hope.</p>&#13;
<p class="indent">Viewed this way, an expert system might be thought of as a glorified set of <code>if-then</code> statements. And in a way, it is, but much can happen in the <code>then</code> part, thereby enabling the system to respond in a sophisticated manner, provided the developer captured the essential knowledge of the domain expert and properly arranged that knowledge in the form of rules firing in response to a particular set of facts.</p>&#13;
<p class="indent">Expert systems rely on forward chaining. This is in contrast to a language like Prolog, which uses backward chaining. <em>Forward chaining</em> systems process the data embodied in the facts they know to find valid conclusions. In contrast, <em>backward chaining</em> systems work from the goal to find true statements that support the goal.</p>&#13;
<p class="indent">A forward chaining system explores all known facts to select rules to evaluate, or <em>fire</em>. A system like CLIPS places rules to fire on an <em>agenda</em> and then uses <em>conflict resolution</em> to select which specific rule to fire. Firing a rule may update the set of known facts, causing other rules to fire, in which case, CLIPS continues to run until the agenda is empty or until it is explicitly told to stop.</p>&#13;
<p class="indent">Internally, CLIPS uses the <em>Rete algorithm</em> to perform inference, that is, to find conclusions by applying a set of rules to a collection of facts. Unlike the other programming languages we’ve explored (except Prolog), CLIPS incorporates advanced concepts in its inference engine that are worth digging into if you are curious; however, these concepts are well beyond what we intend to explore here. Our concern is the language and how to think in terms of it.</p>&#13;
<p class="indent">As you saw earlier, syntactically, CLIPS looks like Lisp, using S-expressions, or prefix notation, where <em>f</em> (<em>x</em>, <em>y</em>) becomes (<em>f</em> <em>x</em> <em>y</em>) so the function moves inside the parentheses.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_166"/>CLIPS is a multiparadigm language: it is declarative at its base because of the inference engine and how code normally runs, but it is also procedural, with standard control structures, and object oriented, though we’ll completely ignore that aspect of the language here. CLIPS runs from the command line with its REPL, which is how we’ll use it; however, it’s also possible to embed it in another application.</p>&#13;
<p class="indent">Let’s see CLIPS in action and then walk through some examples to show us how to work with the system. Along the way, we’ll introduce different aspects of the language.</p>&#13;
<h3 class="h3" id="lev1sec49"><strong>The Language</strong></h3>&#13;
<p class="noindent">Let’s run one of the demos that comes with CLIPS. We won’t look at the code—it’s beyond what we want to consider—but it will show us how to work with the system and serves as a nice example of how an expert system works. The example is in <em>wine.clp</em>. The purpose of the expert system is to recommend a wine to go with a dinner we are preparing. The program will ask us questions and, based on our responses, generate a list of recommended wines with probabilities to select a good pairing.</p>&#13;
<h4 class="h4" id="lev2sec47"><strong><em>Working with CLIPS</em></strong></h4>&#13;
<p class="noindent">A typical session with <em>wine.clp</em> looks like this:</p>&#13;
<pre>&gt; <span class="codestrong1">clips</span>&#13;
CLIPS&gt; <span class="codestrong1">(load "wine.clp")</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
Do you generally prefer dry, medium, or sweet wines? <span class="codestrong1">dry</span>&#13;
Do you generally prefer red or white wines? <span class="codestrong1">white</span>&#13;
Do you generally prefer light, medium, or full bodied wines? <span class="codestrong1">light</span>&#13;
Is the flavor of the meal delicate, average, or strong? <span class="codestrong1">average</span>&#13;
Does the meal have a sauce on it? <span class="codestrong1">no</span>&#13;
Is the main component of the meal meat, fish, or poultry? <span class="codestrong1">fish</span>&#13;
&#13;
        SELECTED WINES&#13;
&#13;
 WINE                  CERTAINTY&#13;
 -------------------------------&#13;
 Chardonnay               58%&#13;
 Soave                    40%&#13;
 Sauvignon-Blanc          40%&#13;
 Chablis                  40%&#13;
 Geverztraminer           30%&#13;
&#13;
CLIPS&gt; <span class="codestrong1">(exit)</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_167"/>First, we load <em>wine.clp</em>. Not shown is CLIPS reporting the successful compilation of the various code components in the file. After loading, CLIPS must be reset before running. Resetting is necessary to configure CLIPS because it places a set of initial facts on the facts list. If the <code>(reset)</code> step is skipped, running <em>wine.clp</em> will display the <code>SELECTED WINES</code> banner and nothing more.</p>&#13;
<p class="indent">The wine demo asks the user a series of questions. Based on the user’s response, the demo provides a list of selected wines with a probability of pairing with the indicated meal. Reset and run the demo a second time, enter the same responses, and the list should be the same. CLIPS is working through a set of rules and will arrive at the same conclusion each time the inputs match. There is nothing stochastic, no randomness, to what CLIPS is doing.</p>&#13;
<p class="indent">While the system is running, the set of facts may change and new inputs may be read. The agenda changes in response to rules that can fire. A <code>reset</code> configures CLIPS by defining the initial set of facts. For example:</p>&#13;
<pre>&gt; <span class="codestrong1">clips</span>&#13;
CLIPS&gt; <span class="codestrong1">(load "wine.clp")</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
&#13;
        SELECTED WINES&#13;
&#13;
 WINE                  CERTAINTY&#13;
 -------------------------------&#13;
&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
For a total of 1 fact.&#13;
CLIPS&gt; <span class="codestrong1">(agenda)</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-36    (attribute (name best-color) (value any) (certainty 100.0))&#13;
f-37    (attribute (name best-body) (value any) (certainty 100.0))&#13;
f-38    (attribute (name best-sweetness) (value any) (certainty 100.0))&#13;
For a total of 4 facts.&#13;
CLIPS&gt; <span class="codestrong1">(agenda)</span>&#13;
10000  start: *&#13;
For a total of 1 activation.</pre>&#13;
<p class="indent">Here, we tell CLIPS to run the wine program without issuing a <code>(reset)</code> first. The header is shown, nothing more. Asking for the current set of facts returns only the default initial fact (<code>f-0</code>). Asking for the agenda returns nothing as the agenda is empty. When the agenda is empty, CLIPS stops. We then reset CLIPS and ask for the facts a second time. Now we see the initial set of facts defined by <em>wine.clp</em>. We don’t need to understand the structure <span epub:type="pagebreak" id="page_168"/>right now, only see that the list of facts has been configured. Asking for the agenda now shows one activation, <code>start</code>. An activated rule is one where the conditions have been met. The wine demo is now ready. When we call <code>run</code>, the <code>start</code> rule will become active.</p>&#13;
<h4 class="h4" id="lev2sec48"><strong><em>Implementing Hello World</em></strong></h4>&#13;
<p class="noindent">Let’s implement our old friend, “Hello, world!” We’ll write two versions. The first uses the inference engine by defining a rule that always fires. The second is purely procedural, proving that CLIPS does support imperative programming.</p>&#13;
<p class="indent">The file <em>hello0.clp</em> contains</p>&#13;
<pre>(defrule hello&#13;
  =&gt; (printout t "Hello, world!" crlf))</pre>&#13;
<p class="noindent">We’ll detail the syntax of <code>defrule</code> in the next section. For now, know that it defines a rule named <code>hello</code>. The portion of a rule after the arrow (<code>=&gt;</code>) is the part that runs, which is the <code>then</code> portion. There is nothing to the left of the arrow because this rule always fires or fires if <code>initial-fact</code>, <code>f-0</code> above, is defined, which it is by default.</p>&#13;
<p class="indent">To execute the rule we need only use <code>(run)</code> as there is nothing to configure regarding other facts and the agenda. Running the program looks like the following:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "hello0.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
Hello, world!</pre>&#13;
<p class="indent">Excellent; our rule fired. However, you might have a question. If the rule <code>hello</code> is set to fire when <code>initial-fact</code> is present, which it always is, why doesn’t CLIPS print “Hello, world!” forever? There is nothing removing the initial fact, so it’s still present. Why doesn’t the rule match again and again? This is because CLIPS fires a rule only once for each set of matching conditions. This is known as <em>refraction</em> (this term is borrowed from neuroscience, where it is related to the time delay after a neuron fires before it can fire again).</p>&#13;
<p class="indent">The file <em>hello0.clp</em> defined a rule and used CLIPS’s inference engine to fire it. CLIPS allows imperative programming as well. The file <em>hello1.clp</em> contains the following:</p>&#13;
<pre>(deffunction hello () (printout t "Hello, world!" crlf))&#13;
(hello)&#13;
(exit)</pre>&#13;
<p class="noindent">We can run this from the command line as follows:</p>&#13;
<pre>&gt; <span class="codestrong1">clips -f2 hello1.clp</span>&#13;
Hello, world!</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_169"/>Use <code>-f</code> or <code>-f2</code> to execute a program from the command line. The second option (<code>-f2</code>) disables load messages. Calling <code>(exit)</code> keeps the program from showing the <code>CLIPS&gt;</code> prompt after running. The file <em>hello1.clp</em> uses <code>deffunction</code> to define a function named <code>hello</code> that is then called before exiting to print the message. The <code>t</code> after <code>printout</code> specifies the output file—in this case the terminal. CLIPS’s support for imperative programming covers all the expected control structures like <code>if-then</code> and <code>while</code>. We won’t discuss those elements here, but do consult the CLIPS documentation to learn about them. A good place for control structures is in the action part of a rule.</p>&#13;
<p class="indent">CLIPS manipulates facts with rules and input. The rules, when active, affect the agenda, and it is the agenda that drives a CLIPS program. Let’s learn more about facts and rules.</p>&#13;
<h4 class="h4" id="lev2sec49"><strong><em>Facts and Rules</em></strong></h4>&#13;
<p class="noindent">You’ve already seen a bit about facts and rules, but to understand the examples that follow, we’ll need a more thorough understanding. Let’s dive in.</p>&#13;
<h5 class="h5" id="lev3sec27"><strong>Facts</strong></h5>&#13;
<p class="noindent"><em>Facts</em> are asserted (<code>assert</code>) and retracted (<code>retract</code>) as needed when rules fire. Simple facts are straightforward to add. For example:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(assert (emergency-brake-on))</span>&#13;
&lt;Fact-1&gt;&#13;
CLIPS&gt; <span class="codestrong1">(assert (roses-are red))</span>&#13;
&lt;Fact-2&gt;&#13;
CLIPS&gt; <span class="codestrong1">(assert (violets-are blue))</span>&#13;
&lt;Fact-3&gt;&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-1     (emergency-brake-on)&#13;
f-2     (roses-are red)&#13;
f-3     (violets-are blue)&#13;
For a total of 4 facts.</pre>&#13;
<p class="noindent">Three facts are asserted. The first might indicate to a running system managing a car that the emergency brake is on. The other two are the symbols <code>roses-are</code> and <code>violets-are</code> along with symbols for colors. Equivalent to an atom in Prolog, a <em>symbol</em> in CLIPS is a set of characters that represents itself, unlike a variable, which is a name given to a value. A symbol has no value. A set of facts may be defined at one time with <code>deffacts</code>. Facts defined this way are put on the facts list when <code>(reset)</code> is executed. Consider the following:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
For a total of 1 fact.&#13;
CLIPS&gt; <span class="codestrong1">(deffacts arthropods (insects 6) (spiders 8) (trilobites 48))</span>&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span><span epub:type="pagebreak" id="page_170"/>&#13;
f-0     (initial-fact)&#13;
For a total of 1 fact.&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-1     (insects 6)&#13;
f-2     (spiders 8)&#13;
f-3     (trilobites 48)&#13;
For a total of 4 facts.</pre>&#13;
<p class="indent">In this example, CLIPS has only the initial fact at first. Then, a <code>deffacts</code> statement named <code>arthropods</code> defines a set of facts. There are three facts defined, each a type of arthropod followed by the number of legs. (Of course, some arthropod enthusiasts may object that trilobites vary in the number of legs, but 48 isn’t a bad guess.)</p>&#13;
<p class="indent">The next line uses <code>(facts)</code>, but our newly declared facts are not present. When <code>assert</code> was used above, the facts appeared immediately. However, with <code>deffacts</code>, we must use <code>(reset)</code> first and then the facts appear. Any previously defined facts are lost as well.</p>&#13;
<p class="indent">Complex facts have many parts, some of which may be updated as CLIPS runs. CLIPS provides a mechanism for defining complex facts. For example, the file <em>coin.clp</em> defines a fact template for ancient Roman coins along with facts related to specific Roman coins:</p>&#13;
<pre>(deftemplate roman-coin "Roman coin facts"&#13;
  (slot emperor)&#13;
  (slot denomination)&#13;
  (slot obverse)&#13;
  (slot reverse))&#13;
&#13;
(deffacts coin-facts "ancient Roman coins"&#13;
  (ancient (emperor Otho)&#13;
           (denomination Denarius)&#13;
           (obverse "Emperor hd right")&#13;
           (reverse "Securitas std left"))&#13;
  (ancient (emperor Constantine)&#13;
           (denomination AE3)&#13;
           (obverse "IMP CONSTANTINVS MAX AVG")&#13;
           (reverse "VICTORIAE LAETAE PRINC PERP")) )</pre>&#13;
<p class="noindent">Here, <code>deftemplate</code> defines a fact template named <code>roman-coin</code> with an optional comment string. The fields of a fact are called <em>slots</em>. The template defines four fields: <code>emperor</code>, <code>denomination</code>, <code>obverse</code>, and <code>reverse</code>.</p>&#13;
<p class="indent">With <code>roman-coin</code> defined, we can then assert some facts about specific coins using <code>deffacts</code>. The first relates to a silver denarius of the first-century emperor Otho, one of the “Twelve Caesars” who ruled from January 15 to April 16 in the year 69. A denarius was the usual day’s wage for a Roman <span epub:type="pagebreak" id="page_171"/>soldier. The second coin is a small bronze coin, loose change of the time, minted by Constantine the Great around the year 325.</p>&#13;
<p class="indent">Let’s inform CLIPS about these coins.</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "coin.clp")</span>&#13;
Defining deftemplate: coin&#13;
Defining deffacts: coin-facts&#13;
TRUE&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-1     (coin (emperor Otho) &#13;
              (denomination Denarius) &#13;
              (obverse "Emperor hd right") &#13;
              (reverse "Securitas std left"))&#13;
f-2     (coin (emperor Constantine) &#13;
              (denomination AE3) &#13;
              (obverse "IMP CONSTANTINVS MAX AVG") &#13;
              (reverse "VICTORIAE LAETAE PRINC PERP"))&#13;
For a total of 3 facts.&#13;
CLIPS&gt; <span class="codestrong1">(retract 1)</span>&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-2     (coin (emperor Constantine) &#13;
              (denomination AE3) &#13;
              (obverse "IMP CONSTANTINVS MAX AVG") &#13;
              (reverse "VICTORIAE LAETAE PRINC PERP"))&#13;
For a total of 2 facts.</pre>&#13;
<p class="indent">After loading <em>coin.clp</em>, we reset and look at the known facts. There are the new coins. During execution, CLIPS will often assert and retract facts. Here, we manually retract the first coin fact with <code>retract</code>, and after running <code>(facts)</code> again we see that it is no longer present. Notice that the fact numbers do not change after this. Fact <code>f-2</code> is still fact <code>f-2</code>.</p>&#13;
<h5 class="h5" id="lev3sec28"><strong>Rules</strong></h5>&#13;
<p class="noindent"><em>Rules</em> are <code>if-then</code> constructs. The syntax for a rule is</p>&#13;
<pre>(defrule <span class="codeitalic1">&lt;rule-name&gt;</span> "<span class="codeitalic1">&lt;optional-comment&gt;</span>"&#13;
  (<span class="codeitalic1">&lt;lefthand-side&gt;</span>) =&gt; (<span class="codeitalic1">&lt;righthand-side&gt;</span>))</pre>&#13;
<p class="indent">The <span class="codeitalic">(&lt;lefthand-side&gt;)</span>, or LHS, is a set of zero or more conditions that attempt to match facts. The conditions are ANDed, which means that all must match for the rule to fire. When the rule does fire, everything on the <span class="codeitalic">(&lt;righthand-side&gt;)</span>, or RHS, is executed. These are the rule’s <em>actions</em>. Typically, the actions alter the set of facts in some way to move the program forward. However, the actions may also have side effects, like printing information or requesting information from the user (this is where CLIPS’s <span epub:type="pagebreak" id="page_172"/>imperative coding abilities come into play). Rules with a matching LHS are placed on the agenda to execute their respective RHSs.</p>&#13;
<p class="indent">As rules match, they may also bind variables that are local to the rule. CLIPS variables follow the expected naming convention, but they must be referenced with a leading question mark. For example, <code>?x</code> refers to the variable <code>x</code>. Binding on the LHS of a rule is useful as the bound variables may be used on the RHS. We’ll see examples of this later in the chapter. To bind a variable directly, that is, to assign something to it, use the <code>bind</code> statement.</p>&#13;
<pre>CLIPS&gt; (bind ?x 1)&#13;
CLIPS&gt; (bind ?y 1121)&#13;
CLIPS&gt; (printout t (/ ?x ?y) crlf)&#13;
0.000892060660124889</pre>&#13;
<p class="indent">Here’s a hypothetical rule to react to a security breach.</p>&#13;
<pre>(defrule react-security-breach "React to a security breach"&#13;
    ?r &lt;- (security-breach ?typ)&#13;
  =&gt;&#13;
    (retract ?r)&#13;
    (assert (log-security-breach ?typ))&#13;
    (printout t "!!! security alert !!!" crlf))</pre>&#13;
<p class="indent">The rule name is <code>react-security-breach</code>. The LHS, the part before <code>=&gt;</code>, is the condition that matches a fact of the form <code>security-breach</code> <code>&lt;type&gt;</code>, where the actual type is bound to <code>?typ</code>. For example, <code>(security-breach hacker)</code> would match the rule and bind the symbol <code>hacker</code> to the variable <code>?typ</code>.</p>&#13;
<p class="indent">The LHS has a funny bit of syntax: <code>?r &lt;-</code>. When the <code>security-breach</code> fact matches, it returns the fact number, which is bound to <code>?r</code>. The RHS of the rule, the part after <code>=&gt;</code>, uses <code>?r</code> to <code>retract</code> the matched fact. As we are processing the security breach, we remove the trigger for this rule. Because of refraction, the rule will fire only once for the specific fact <code>(security-breach</code> <code>hacker)</code>. Retracting the fact removes it, so when it is asserted again, the rule will fire once more.</p>&#13;
<p class="indent">The RHS of this rule asserts <code>(log-security-breach ?typ)</code> to add a new fact. Note the use of <code>?typ</code>, which CLIPS extracted from the LHS of the rule. Asserting this fact acts as a trigger for another rule that will write some information to a logfile or perhaps send an alert email to the IT department. The final part of the rule prints the alert so we can see it.</p>&#13;
<p class="indent">If the rule is in <em>security.clp</em>, we load and run it as follows:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "security.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(assert (security-breach hacker))</span>&#13;
&lt;Fact-1&gt;&#13;
CLIPS&gt; <span class="codestrong1">(run)</span><span epub:type="pagebreak" id="page_173"/>&#13;
!!! security alert !!!&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-2     (log-security-breach hacker)&#13;
For a total of 2 facts.</pre>&#13;
<p class="noindent">To trigger the rule after reset, we must assert a security breach, which in this case is a hacker security breach. Running it shows us the security alert message indicating the rule fired. If we examine the known facts, we see a new one, <code>f-2</code>, which is the fact asserted by our rule.</p>&#13;
<p class="indent">CLIPS is large, powerful, and reasonably complex. Let’s spend the remainder of the chapter exploring selected examples to illustrate how CLIPS works, at least at the level we’ll use it.</p>&#13;
<h3 class="h3" id="lev1sec50"><strong>CLIPS in Action</strong></h3>&#13;
<p class="noindent">To build our intuition about CLIPS, in this section we’ll walk through four examples. The first is an elementary calculator, just enough to get our feet wet. Next, we’ll revisit the Greek god family tree from <a href="ch01.xhtml#ch01">Chapter 1</a> to see CLIPS’s take on it. Following that is a basic factory simulation, which illustrates how a CLIPS expert system might operate when monitoring something in the real world. Lastly, we’ll build an expert system for iris flowers to compare a rule-based classifier with the SNOBOL nearest neighbor classifier of <a href="ch05.xhtml#ch05">Chapter 5</a>.</p>&#13;
<h4 class="h4" id="lev2sec50"><strong><em>An Elementary Calculator</em></strong></h4>&#13;
<p class="noindent">This example implements a calculator. For the calculator, we need four rules. The first rule handles the startup message and informs the user. The next rule handles binary operators like plus and multiply. Next, we need a rule for unary operations like sine and cosine. The final rule accepts input from the user and asserts the operation for the binary or unary rule to act upon. The source code is in <em>math.clp</em>.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list1">Listing 6-1</a> contains the set of initial facts and the <code>start</code> rule.</p>&#13;
<pre>(defrule start ""&#13;
  ?r &lt;- (startup)&#13;
  =&gt;&#13;
  (printout t "A simple calculator." crlf)&#13;
  (printout t crlf)&#13;
  (printout t "Enter &lt;number&gt; &lt;op&gt; &lt;number&gt; where" crlf)&#13;
  (printout t "&lt;op&gt; is +, -, *, /, ^, mod" crlf crlf)&#13;
  (printout t "Enter &lt;function&gt; &lt;arg&gt; where" crlf)&#13;
  (printout t "      &lt;function&gt; is: trig, log, exp, or sqrt" crlf crlf)&#13;
  (printout t "Type 'end' to exit and @ to use previous result." crlf)<span epub:type="pagebreak" id="page_174"/>&#13;
  (retract ?r)&#13;
  (assert (get-next-operation)))&#13;
&#13;
(deffacts initial-facts ""&#13;
  (@ 0)&#13;
  (startup))</pre>&#13;
<p class="caption" id="ch06list1"><em>Listing 6-1: Initializing the calculator</em></p>&#13;
<p class="indent">Here, there are two initial facts. The first is <code>(startup)</code>, and the second is <code>@ 0</code>. We’ll use the <code>@</code> fact to keep the result of the last operation.</p>&#13;
<p class="indent">The LHS of the <code>start</code> rule matches <code>(startup)</code>, which is asserted when CLIPS is reset because of <code>deffacts</code>. This rule does three things: first, it prints a set of instructions for the user; second, it retracts <code>(startup)</code> so it is no longer in the facts list; and third, it asserts <code>(get-next-operation)</code>. We’ll use this fact to request input from the user.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list2">Listing 6-2</a> shows the <code>get-operation</code> rule.</p>&#13;
<pre>(defrule get-operation ""&#13;
  ?w &lt;- (get-next-operation)&#13;
  =&gt;&#13;
  (retract ?w)&#13;
  (printout t crlf "      ")&#13;
  (bind ?expr (readline))&#13;
  (if (eq ?expr "end") then (halt))&#13;
  (assert (operation (explode$ ?expr))) )</pre>&#13;
<p class="caption" id="ch06list2"><em>Listing 6-2: Processing user input</em></p>&#13;
<p class="indent">The <code>get-operation</code> rule fires only when <code>(get-next-operation)</code> is in the facts list. As <code>start</code> places this fact on the list after it is done, the <code>get-operation</code> rule will fire immediately after <code>start</code> ends. As CLIPS fires rules only once, when matched, we retract <code>(get-next-operation)</code> so the rule will fire the next time it is asserted.</p>&#13;
<p class="indent">The remainder of <code>get-operation</code> displays a prompt of spaces and then binds <code>?expr</code> to the string typed by the user. After a quick check to see if the user entered <code>end</code>, the operation is asserted. The <code>explode$</code> function takes a string and splits it into a list, the elements of which become the fields of the <code>operation</code> fact. CLIPS refers to lists as <em>multifields</em>.</p>&#13;
<p class="indent">The instructions tell the user to enter expressions carefully. A unary expression is the function name followed by one or more spaces and an argument consisting of either a number or <code>@</code> to use the previous result. A binary expression is the first operand, spaces, operation, spaces, and second operand. When exploded, the <code>operation</code> fact will contain three fields if it’s a binary expression or two if it’s a unary expression.</p>&#13;
<p class="indent">Now consider <a href="ch06.xhtml#ch06list3">Listing 6-3</a>, which processes unary expressions.</p>&#13;
<pre>(defrule unary-math ""&#13;
  ?w &lt;- (operation ?func ?x)&#13;
  ?at &lt;- (@ ?last)<span epub:type="pagebreak" id="page_175"/>&#13;
  =&gt;&#13;
  (retract ?w)&#13;
  (retract ?at)&#13;
  (assert (get-next-operation))&#13;
  (if (eq ?x @) then (bind ?x ?last))&#13;
  (if (eq ?func cos) then (bind ?y (cos ?x)))&#13;
  (if (eq ?func sin) then (bind ?y (sin ?x)))&#13;
  (if (eq ?func tan) then (bind ?y (tan ?x)))&#13;
  (if (eq ?func log) then (bind ?y (log ?x)))&#13;
  (if (eq ?func exp) then (bind ?y (exp ?x)))&#13;
  (if (eq ?func sqrt) then (bind ?y (sqrt ?x)))&#13;
  (printout t ?y)&#13;
  (assert (@ ?y)))</pre>&#13;
<p class="caption" id="ch06list3"><em>Listing 6-3: Processing a unary expression</em></p>&#13;
<p class="indent">The <code>unary-math</code> rule is triggered by an <code>operation</code> fact with two fields. The first is the function (<code>?func</code>) and the second is the argument to the function (<code>?x</code>). The last result is also part of the LHS, so we can pull it from the facts list. Both the operation and last result are retracted, meaning they will be asserted again later.</p>&#13;
<p class="indent">The rule asserts <code>(get-next-operation)</code> to fire <code>get-operation</code> again to acquire the next expression from the user. The remainder of the rule performs the requested operation. If <code>?x</code> is <code>@</code>, <code>?x</code> is updated to be the previous result (<code>?last</code>). The actual operation generates an output value, <code>?y</code>, which is printed and asserted as the new previous result, which is the <code>@</code> fact.</p>&#13;
<p class="indent">Binary expressions are processed by <a href="ch06.xhtml#ch06list4">Listing 6-4</a>.</p>&#13;
<pre>(defrule binary-math ""&#13;
  ?w &lt;- (operation ?a ?op ?b)&#13;
  ?at &lt;- (@ ?last)&#13;
  =&gt;&#13;
  (retract ?w)&#13;
  (retract ?at)&#13;
  (assert (get-next-operation))&#13;
  (if (eq ?a @) then (bind ?a ?last))&#13;
  (if (eq ?b @) then (bind ?b ?last))&#13;
  (if (eq ?op +) then (bind ?y (+ ?a ?b)))&#13;
  (if (eq ?op -) then (bind ?y (- ?a ?b)))&#13;
  (if (eq ?op *) then (bind ?y (* ?a ?b)))&#13;
  (if (eq ?op /) then (bind ?y (/ ?a ?b)))&#13;
  (if (eq ?op ^) then (bind ?y (** ?a ?b)))&#13;
  (if (eq ?op mod) then (bind ?y (mod ?a ?b)))&#13;
  (printout t ?y)&#13;
  (assert (@ ?y)))</pre>&#13;
<p class="caption" id="ch06list4"><em>Listing 6-4: Processing a binary expression</em></p>&#13;
<p class="indent">This rule is substantially the same as the unary expression case, but matches an operation with two arguments instead of one. CLIPS knows <span epub:type="pagebreak" id="page_176"/>which rule to fire, <code>unary-math</code> or <code>binary-math</code>, because of the number of fields in the <code>operation</code> fact.</p>&#13;
<p class="indent">Let’s see <em>math.clp</em> in action.</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "math.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
A simple calculator.&#13;
&#13;
Enter &lt;number&gt; &lt;op&gt; &lt;number&gt; where&#13;
&lt;op&gt; is +, -, *, /, ^, mod&#13;
&#13;
Enter &lt;function&gt; &lt;arg&gt; where&#13;
      &lt;function&gt; is: trig, log, exp, or sqrt&#13;
&#13;
Type 'end' to exit and @ to use the previous result.&#13;
&#13;
      <span class="codestrong1">111 * 123</span>&#13;
13653&#13;
      <span class="codestrong1">@ + 5</span>&#13;
13658&#13;
      <span class="codestrong1">@ / 23456</span>&#13;
0.582281718963165&#13;
      <span class="codestrong1">cos @</span>&#13;
0.835210036979047&#13;
      <span class="codestrong1">exp @</span>&#13;
2.30529819530959&#13;
      <span class="codestrong1">@ ^ @</span>&#13;
6.8579474467406&#13;
      <span class="codestrong1">end</span></pre>&#13;
<p class="noindent">User entries are in bold, demonstrating both binary and unary expressions, most of which use the previous result. Note that spaces are required between operands and operators.</p>&#13;
<p class="indent">This example exposes a general pattern: store information on the facts list and use assertions and retractions to arrange the flow of the program. The calculator begins with the startup message, which then asserts a fact to cause <code>get-operation</code> to fire, thereby acquiring and processing input from the user. In turn, that rule asserts the fact of the desired operation. The inference engine causes the proper binary or unary rule to fire to process the request. Those rules retract and reassert the last result, so the version in the fact list is always correct. They also reassert <code>(get-next-operation)</code> to acquire more input from the user. This keeps the program running until <code>(halt)</code> is executed.</p>&#13;
<h4 class="h4" id="lev2sec51"><span epub:type="pagebreak" id="page_177"/><strong><em>Family Redux</em></strong></h4>&#13;
<p class="noindent">In <a href="ch01.xhtml#ch01">Chapter 1</a>, we used Prolog to explore the sometimes unusual family relationships among the ancient Greek gods. Let’s revisit that example now to understand what CLIPS might do with the same set of facts. This example is in <em>family.clp</em>. Let’s walk through the code, then run it to see what manner of output we get.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list5">Listing 6-5</a> is only partial. See <em>family.clp</em> for the complete set of facts.</p>&#13;
<pre>(deffacts olympians&#13;
    (male uranus)&#13;
    (male cronus)&#13;
<span class="codeitalic1">--snip--</span>&#13;
    (female gaia)&#13;
    (female rhea)&#13;
<span class="codeitalic1">--snip--</span>&#13;
    (parent uranus cronus)&#13;
    (parent gaia cronus)&#13;
<span class="codeitalic1">--snip--</span>&#13;
    (married zeus hera)&#13;
    (married hephaestus aphrodite))</pre>&#13;
<p class="caption" id="ch06list5"><em>Listing 6-5: Some facts about the Olympians</em></p>&#13;
<p class="indent">As with Prolog, we declare some gods as male and other gods as female before listing parent-child relationships in the form <code>(parent x y)</code>, which means <code>X</code> is a parent of <code>Y</code>. If gods were considered married, the facts list captures that as well.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list6">Listing 6-6</a> gives us rules capturing basic family relationships.</p>&#13;
<pre>(defrule father&#13;
    (parent ?x ?y)&#13;
    (male ?x)&#13;
  =&gt;&#13;
    (printout t ?x " is father of " ?y crlf))&#13;
&#13;
(defrule mother&#13;
    (parent ?x ?y) &#13;
    (female ?x)&#13;
  =&gt;&#13;
    (printout t ?x " is mother of " ?y crlf))&#13;
&#13;
(defrule wife&#13;
    (female ?x)&#13;
    (or (married ?x ?y) (married ?y ?x))&#13;
  =&gt;&#13;
    (printout t ?x " is wife of " ?y crlf))<span epub:type="pagebreak" id="page_178"/>&#13;
&#13;
(defrule husband&#13;
    (male ?x)&#13;
    (or (married ?x ?y) (married ?y ?x))&#13;
  =&gt;&#13;
    (printout t ?x " is husband of " ?y crlf))</pre>&#13;
<p class="caption" id="ch06list6"><em>Listing 6-6: Rules capturing basic relationships</em></p>&#13;
<p class="indent">As we can see in the first <code>defrule</code> in <a href="ch06.xhtml#ch06list6">Listing 6-6</a>, <code>x</code> is the father of <code>y</code> if <code>x</code> is a parent of <code>y</code> and <code>x</code> is male. The LHS of the rules captures the relationship from the facts binding variables. For example, the <code>father</code> rule binds both <code>?x</code> and <code>?y</code>, meaning it will fire if there is a set of <code>(parent x y)</code> and <code>(male x)</code> facts in the facts list where the same <code>x</code> is parent of <code>y</code> and also male. Therefore, for a rule’s LHS, variables with the same name must be the same for every part of the condition to be true. When the rule fires, it simply outputs the now proven fact that <code>x</code> is the father of <code>y</code>. Notice that nothing is added to or removed from the facts list by these rules. These rules produce output only. Refraction will prevent the rule from firing more than once for the same set of facts.</p>&#13;
<p class="indent">The rule for <code>mother</code> is almost the same as <code>father</code>. The rules for <code>wife</code> and <code>husband</code> include a logical-OR because <code>married</code> might be specified as <code>(married</code> <code>zeus hera)</code> or <code>(married hera zeus)</code>. Again, the rules make no change to the facts list.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list7">Listing 6-7</a> shows us three more rules from <em>family.clp</em>.</p>&#13;
<pre>(defrule sibling&#13;
    (parent ?p ?x)&#13;
    (parent ?p ?y)&#13;
    (test (neq ?x ?y))&#13;
  =&gt;&#13;
    (assert (siblings ?x ?y)))&#13;
&#13;
(defrule sister&#13;
    (siblings ?x ?y)&#13;
    (female ?x)&#13;
    (test (neq ?x ?y))&#13;
  =&gt;&#13;
    (printout t ?x " is sister to " ?y crlf))&#13;
&#13;
(defrule brother&#13;
    (siblings ?x ?y)&#13;
    (male ?x)&#13;
    (test (neq ?x ?y))&#13;
  =&gt;&#13;
    (printout t ?x " is brother to " ?y crlf))</pre>&#13;
<p class="caption" id="ch06list7"><em>Listing 6-7: Rules capturing sibling relationships</em></p>&#13;
<p class="indent">The first rules capture the idea of siblings and the following two rules embody the ideas of sister and brother.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_179"/>For <code>x</code> to be the brother of Y, <code>x</code> must be male and <code>x</code> and <code>y</code> must be siblings. To be siblings, <code>x</code> and <code>y</code> must have a parent in common. The rules of <a href="ch06.xhtml#ch06list7">Listing 6-7</a> capture siblings and then assert that <code>x</code> and <code>y</code> are siblings. Once asserted, the <code>brother</code> and <code>sister</code> rules can fire because the new fact that <code>x</code> and <code>y</code> are siblings is now part of the fact list.</p>&#13;
<p class="indent">The LHS of the rules includes a <code>test</code> to make sure that <code>x</code> and <code>y</code> are not the same person, as we don’t normally think of ourselves as our own siblings.</p>&#13;
<p class="indent">There is no startup rule in <em>family.clp</em> like we had for <em>math.clp</em>. Instead, the fact list is initialized by <code>(reset)</code>, and <code>(run)</code> immediately begins using the fact list to satisfy the rules, place them on the agenda, and execute the RHS for all possible matches. Therefore, unlike Prolog, which gave us a result and waited patiently for us to request another or stop, CLIPS will run as long as it can match facts to rules and execute them.</p>&#13;
<p class="indent">If you load <em>family.clp</em> and execute <code>(reset)</code> and <code>(run)</code>, you should see a flurry of output—119 lines’ worth, to be exact. The output is all the possible relationships CLIPS was able to pull out of the initial set of facts. For example, the list begins with</p>&#13;
<pre>hephaestus is husband of aphrodite&#13;
aphrodite is wife of hephaestus&#13;
zeus is husband of hera      &#13;
hera is wife of zeus       &#13;
uranus is father of aphrodite&#13;
aphrodite is sister to cronus&#13;
cronus is brother to aphrodite&#13;
semele is mother of dionysus &#13;
zeus is father of dionysus         &#13;
dionysus is brother to artemis&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="noindent">giving us a mix of husbands, wives, fathers, sisters, and so on. It would be nice to organize this list in some way, that is, to programmatically capture the relationships by type instead of dumping line after line. Fortunately, CLIPS is a full-service programming language. One way we can apply some order to the output is to capture instances of different types so we can report them at will.</p>&#13;
<pre>(defglobal ?*brothers* = (create$))&#13;
(defglobal ?*sisters* = (create$))&#13;
&#13;
(defrule sister&#13;
    (siblings ?x ?y)&#13;
    (female ?x)&#13;
    (test (neq ?x ?y))&#13;
  =&gt;&#13;
    (bind ?msg (implode$ (create$ ?x is sister to ?y)))&#13;
    (bind ?*sisters* (create$ ?*sisters* ?msg)))<span epub:type="pagebreak" id="page_180"/>&#13;
&#13;
(defrule brother&#13;
    (siblings ?x ?y)&#13;
    (male ?x)&#13;
    (test (neq ?x ?y))&#13;
  =&gt;&#13;
    (bind ?msg (implode$ (create$ ?x is brother to ?y)))&#13;
    (bind ?*brothers* (create$ ?*brothers* ?msg)))&#13;
&#13;
(deffunction brothers ()&#13;
    (foreach ?bro ?*brothers*&#13;
        (printout t ?bro crlf)))&#13;
&#13;
(deffunction sisters ()&#13;
    (foreach ?sis ?*sisters*&#13;
        (printout t ?sis crlf)))</pre>&#13;
<p class="caption" id="ch06list8"><em>Listing 6-8: Storing relationship output</em></p>&#13;
<p class="indent">The file <em>family2.clp</em> stores brothers and sisters in global lists. Only brothers and sisters are considered in this case, but it would be straightforward to include other family relationships. The essential pieces of <em>family2.clp</em> are in <a href="ch06.xhtml#ch06list8">Listing 6-8</a>. The initial set of facts has been excluded from the listing, as has the rule <code>sibling</code>, which is unchanged from the version in <a href="ch06.xhtml#ch06list7">Listing 6-7</a>.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list8">Listing 6-8</a> begins with two new lines, instances of <code>defglobal</code>, which is CLIPS-speak for defining a global variable. CLIPS uses asterisks around the names of global variables, so we define two empty lists, the output of <code>create$</code> with no arguments, to hold brothers and sisters: <code>?*brothers*</code> and <code>?*sisters*</code>.</p>&#13;
<p class="indent">To accumulate information about brothers and sisters, we modify the <code>brother</code> and <code>sister</code> rules. The LHS of each rule remains the same, but the RHS consists of two calls to <code>bind</code>. The first uses <code>create$</code> to make a list of <code>?x</code>, the symbols <code>is</code>, <code>sister</code> or <code>brother</code>, <code>to</code>, and <code>?y</code>. This list is passed to <code>implode$</code>, which makes a string from a list. Therefore, the output of <code>implode$</code> is a string, such as <code>dionysus is brother to artemis</code>, that we store in <code>?msg</code>. The second <code>bind</code> again uses <code>create$</code> to append the new string to the end of the existing list. In this way, every discovery of a brother or sister relationship is stored in the corresponding string.</p>&#13;
<p class="indent">If we load <em>family2.clp</em> and call <code>(reset)</code> followed by <code>(run)</code>, we get no output. However, CLIPS did its job. To see this we need functions to print the lists. Enter the functions <code>brothers</code> and <code>sisters</code>. Neither function requires arguments and both use CLIPS’s <code>foreach</code> loop to iterate over the lists to print one element per line.</p>&#13;
<p class="indent">Give <em>family2.clp</em> a try. First load, reset, and run as usual, and then list the sisters. For example:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "family2.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
CLIPS&gt; <span class="codestrong1">(sisters)</span>&#13;
aphrodite is sister to cronus<span epub:type="pagebreak" id="page_181"/>&#13;
eris is sister to dionysus&#13;
artemis is sister to dionysus&#13;
artemis is sister to apollo&#13;
artemis is sister to hermes&#13;
artemis is sister to athena&#13;
artemis is sister to eris&#13;
artemis is sister to hephaestus&#13;
artemis is sister to ares&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="noindent">Calling <code>(brothers)</code> produces the other list. The <em>family2.clp</em> example shows how to combine procedural (imperative) programming with CLIPS’s rules engine. Now, let’s look at a factory simulation to see how rules can be ordered to fire in a specified sequence.</p>&#13;
<h4 class="h4" id="lev2sec52"><strong><em>At the Factory</em></strong></h4>&#13;
<p class="noindent">For this example, we’ll simulate the monitoring of a factory. The factory has pumps that must be turned on and then turned off three seconds later. Additionally, from time to time, an emergency must be serviced before turning on the pumps. Our simulation’s true purpose is to demonstrate <em>salience</em>, which determines the firing order for rules if multiple rules are on the agenda. Salience should be used with care, but it is sometimes necessary.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list9">Listing 6-9</a> shows us a few necessary utility functions.</p>&#13;
<pre>(defglobal ?*base* = (time))&#13;
(deffunction ftime ()&#13;
  (- (time) ?*base*))&#13;
&#13;
(deffunction rand ()&#13;
  (/ (mod (random) 1000000) 1000000))&#13;
&#13;
(deffunction pause (?delay)&#13;
  (bind ?start (time))&#13;
  (while (&lt; (time) (+ ?start ?delay)) do))</pre>&#13;
<p class="caption" id="ch06list9"><em>Listing 6-9: Some utility functions</em></p>&#13;
<p class="indent">The first line defines a global variable, <code>?*base*</code>, which holds the current epoch seconds value returned by <code>(time)</code>. It’s set when the program loads. We’re using it with the <code>ftime</code> function to return the number of seconds since the program was loaded.</p>&#13;
<p class="indent">CLIPS has a function called <code>(random)</code> to return a random integer, which is really the return value of the C <code>rand</code> function. To get a floating-point value in [0, 1), we take the remainder of this integer when divided by 1,000,000 and divide that by 1,000,000. This approach is adequate for our purposes.</p>&#13;
<p class="indent">The system pauses before monitoring the state of the factory, hence defining <code>(pause)</code>, which accepts the number of seconds and runs a <code>while</code> loop <span epub:type="pagebreak" id="page_182"/>waiting for the time to elapse. This is very CPU intensive, but, again, it is acceptable for our purposes.</p>&#13;
<p class="indent">The rules responding to events in the factory are in <a href="ch06.xhtml#ch06list10">Listing 6-10</a>.</p>&#13;
<pre>(defrule emergency "there is an emergency"&#13;
    (declare (salience 100))&#13;
    ?x &lt;- (emergency-alert)&#13;
  =&gt;&#13;
    (retract ?x)&#13;
    (printout t "  !!! emergency! !!!" crlf))&#13;
&#13;
(defrule pumps-on "turn the pumps on"&#13;
    (declare (salience 5))&#13;
    ?x &lt;- (pumps-on)&#13;
  =&gt;&#13;
    (retract ?x)&#13;
    (printout t "  pumps on (" (ftime) ")" crlf)&#13;
    (assert (pumps-off-time (+ (ftime) 3))))&#13;
&#13;
(defrule pumps-off "turn off the pumps"&#13;
    (declare (salience 5)) &#13;
    ?x &lt;- (pumps-off-time ?t) &#13;
  =&gt;  &#13;
    (if (&gt;= (ftime) ?t) then &#13;
      (retract ?x) &#13;
      (printout t "  pumps off (" (ftime) ")" crlf)&#13;
    else&#13;
      (refresh pumps-off)))</pre>&#13;
<p class="caption" id="ch06list10"><em>Listing 6-10: The factory rules</em></p>&#13;
<p class="indent">There are three rules: <code>emergency</code>, <code>pumps-on</code>, and <code>pumps-off</code>. As before, the rules have a LHS and a RHS. There is also a new statement, <code>declare</code>, which sets the <code>salience</code> to an integer, which must be in the range [–10,000, 10,000]. Higher salience rules fire before lower salience rules when multiple rules are on the agenda. The default salience value is 0.</p>&#13;
<p class="indent">The first rule in <a href="ch06.xhtml#ch06list10">Listing 6-10</a> uses a salience of <code>100</code>. This is the emergency rule, and we want to ensure it fires immediately after being placed on the agenda; therefore, we give it a salience larger than any other rule. The <code>pumps-on</code> and <code>pumps-off</code> rules each have a salience of <code>5</code>. Salience is for ordering execution on the agenda, and the numeric value has no other meaning. Therefore, the fact that <code>emergency</code> has a salience 20 times greater than that of the other rules doesn’t mean anything other than that it fires first.</p>&#13;
<p class="indent">The <code>emergency</code> rule does nothing more than inform the user that an emergency condition exists, that is, the fact <code>emergency-alert</code> has been asserted. Notice that the fact has been retracted. If not, the rule would not fire again when a new <code>emergency-alert</code> is placed on the facts list.</p>&#13;
<p class="indent">The <code>pumps-on</code> rule displays the pump start time and then asserts <code>pumps-off</code> <code>-time</code> as three seconds beyond the current time. The assertion fires <code>pumps-off</code>. <span epub:type="pagebreak" id="page_183"/>This rule uses <code>if</code> to check whether the current time is beyond the desired stop time. If it is, the <code>pumps-off-time</code> fact is retracted and the off message displayed. If the full three seconds has not yet elapsed, <code>refresh</code> is used to cause <code>pumps-off</code> to fire again even though it already matched the <code>pumps-off-time</code> fact. Using <code>refresh</code> eliminates the need to retract the <code>pumps-off-time</code> fact only to assert it again.</p>&#13;
<p class="indent">The main factory monitor loop is the rule <code>monitor</code> (see <a href="ch06.xhtml#ch06list11">Listing 6-11</a>).</p>&#13;
<pre>(defrule monitor "monitor the factory"&#13;
    (declare (salience 0))&#13;
    (monitor-loop)&#13;
  =&gt;&#13;
    (if (&lt; (rand) 0.2) then (assert (pumps-on)))&#13;
    (if (&lt; (rand) 0.05) then (assert (emergency-alert)))&#13;
    (pause 0.2)&#13;
    (refresh monitor))&#13;
&#13;
(deffacts initial&#13;
  (monitor-loop))</pre>&#13;
<p class="caption" id="ch06list11"><em>Listing 6-11: The <span class="codeitalic1">monitor</span> rule</em></p>&#13;
<p class="indent">The <code>monitor</code> rule uses a salience of <code>0</code>, which is the default value. Doing this means the pump and emergency rules will always fire before this rule. The idea is to monitor the factory until something worthwhile happens and then react to the situation before returning to monitor the factory.</p>&#13;
<p class="indent">This is a simulation, so “monitor the factory” means use <code>(rand)</code> to assert events with random probabilities. For any execution of <code>monitor</code>, there’s a 20 percent chance the pumps will be turned on. Likewise, there is a 5 percent chance an emergency alert will be issued. After a 0.2 second pause, the program refreshes the <code>monitor</code> rule to make it fire again. To prep the system, <code>deffacts</code> places <code>monitor-loop</code> on the facts list when <code>(reset)</code> is executed.</p>&#13;
<p class="indent">Now, let’s run the simulation and see what it tells us.</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "factory.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
  pumps on (2.55227184295654)&#13;
  pumps off (5.55229592323303)&#13;
  pumps on (5.95234894752502)&#13;
  pumps off (8.95237803459167)&#13;
  !!! emergency! !!!&#13;
  pumps on (10.152487039566)&#13;
  pumps off (13.1525239944458)&#13;
  pumps on (14.5526268482208)&#13;
  pumps off (17.5526599884033)&#13;
^\Quit (core dumped)</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_184"/>This run activated the pumps and, as desired, turned them off after three seconds. There was one emergency alert. The factory simulation has no end condition, so use CTRL-<code>\</code> to exit. This is the source of the <code>Quit</code> message in the listing above.</p>&#13;
<h4 class="h4" id="lev2sec53"><strong><em>An Iris Expert System</em></strong></h4>&#13;
<p class="noindent">In <a href="ch05.xhtml#ch05">Chapter 5</a>, we built a nearest neighbor classifier in SNOBOL. The nearest neighbor classifier is an example of machine learning, a statistical approach using training data to build a model that captures something essential about the data and allows for predictions when given new, unknown data.</p>&#13;
<p class="indent">An expert system attempts to encapsulate expert knowledge to capture enough about a particular domain to make informed decisions. This section uses “expert” knowledge of iris flowers to build a simple expert system. The result is a system that asks us questions about an unknown iris flower to decide what type of iris it is.</p>&#13;
<p class="indent">Unfortunately, I’m not an expert in iris flowers. But that isn’t too much of a limitation in this case, as we can cheat a bit. We’ll use machine learning to build a <em>decision tree</em> classifier for irises. A decision tree is a series of yes or no questions that ultimately lead from the tree’s root to a leaf, which identifies the flower. Translating a decision tree into a simple expert system is straightforward, so we’ll use the “expertise” captured by the decision tree to build the expert system. This isn’t all that different from a human interviewing an iris expert to extract essential knowledge then encoded in a series of questions.</p>&#13;
<p class="indent">Therefore, our plan of attack is as follows:</p>&#13;
<ol>&#13;
<li class="noindent">Use the iris training data to build a decision tree classifier.</li>&#13;
<li class="noindent">Use the associated test data to characterize the resulting tree’s  accuracy. Our expert system will use the same sequence of questions,  so we’ll get the same accuracy from CLIPS if we implement things  correctly.</li>&#13;
<li class="noindent">Translate the questions of the decision tree into a set of CLIPS rules.</li>&#13;
<li class="noindent">Test the system with the iris test dataset.</li>&#13;
</ol>&#13;
<p class="indent">First is the decision tree classifier. The code to train the classifier and output a tree representation is in the file <em>make_iris_tree.py</em>. You do not need to run it. The tree we’ll work with is in <em>iris_tree.png</em>. If you want to generate a new tree, perhaps as an exercise in doing the translation to CLIPS yourself, you’ll need to install scikit-learn (<em><a href="https://scikit-learn.org/">https://scikit-learn.org/</a></em>) and Matplotlib (<em><a href="https://matplotlib.org/">https://matplotlib.org/</a></em>). scikit-learn uses some randomization when building the tree; therefore, each run of <em>make_iris_tree.py</em> results in a slightly different level of performance. The particular tree we’re using here is 98 percent accurate on the iris test dataset (<em>iris_test_data.txt</em>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_185"/><a href="ch06.xhtml#ch06fig1">Figure 6-1</a> shows us the decision tree classifier.</p>&#13;
<div class="image"><img id="ch06fig1" src="Images/06fig01.jpg" alt="Image" width="591" height="798"/></div>&#13;
<p class="figcap"><em>Figure 6-1: The iris classifier decision tree</em></p>&#13;
<p class="indent">The root of the tree is at the top, following normal computer science convention for representing a tree data structure. Each box is a node of the tree. If the box isn’t a leaf, the first line of the box is a question asked of the user. If the answer to the question is “yes,” move to the next lower box on the left. If the answer is “no,” move to the lower box on the right. Answer enough questions and you’ll eventually get to a leaf. The class label given there identifies the flower: <em>I. setosa</em>, <em>I. versicolor</em>, or <em>I. virginica</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_186"/>All boxes have additional lines of text. The <em>Gini score</em> is a measure used to generate the decision tree. Samples is a vector of three elements, one for each of the three iris flower types. It shows the split by type at that node when using the training data. The class label is the most correct label to give the flower if one stops at that node. For the leaves, the class label matches a value vector with only one class, meaning the decision tree was able to successfully partition the training data with 100 percent accuracy.</p>&#13;
<p class="indent">How do we use the decision tree? Let’s walk through a test sample. The expert system will ask us about measurements made from an unknown iris flower. There are four measurements: sepal length, sepal width, petal length, and petal width, all in centimeters. See <a href="ch06.xhtml#ch06fig2">Figure 6-2</a> if you need a reminder of basic flower anatomy.</p>&#13;
<div class="image"><img id="ch06fig2" src="Images/06fig02.jpg" alt="Image" width="347" height="276"/></div>&#13;
<p class="figcap"><em>Figure 6-2: Basic flower anatomy</em></p>&#13;
<p class="indent">Our test case has the measurements</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba">sepal length</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba">6.8 cm</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">sepal width</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">2.8 cm</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">petal length</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">4.8 cm</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">petal width</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">1.4 cm</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">and is an instance of <em>I. versicolor</em> (class label 1). The path through the decision tree for this example is in <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>.</p>&#13;
<span epub:type="pagebreak" id="page_187"/>&#13;
<div class="image"><img id="ch06fig3" src="Images/06fig03.jpg" alt="Image" width="590" height="797"/></div>&#13;
<p class="figcap"><em>Figure 6-3: A path through the decision tree</em></p>&#13;
<p class="indent">We can place the questions asked at each node of the decision tree into <a href="ch06.xhtml#ch06tab1">Table 6-1</a>.<span epub:type="pagebreak" id="page_188"/></p>&#13;
<p class="tabcap" id="ch06tab1"><strong>Table 6-1:</strong> The Questions and Responses for the Iris Expert System</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:45%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Question</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Text</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Yes</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>No</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q1</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Is petal width ≤ 0.8?</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">setosa</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q2</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Is petal length ≤ 4.75?</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q3</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q3</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Is petal width ≤ 1.65?</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">versicolor</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">virginica</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q4</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Is petal width ≤ 1.75?</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q5</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q6</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q5</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Is petal length ≤ 5.05?</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">versicolor</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q7</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q6</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Is petal length ≤ 4.85?</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q8</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">virginica</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q7</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Is sepal length ≤ 6.05?</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">versicolor</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">virginica</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Q8</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Is sepal length ≤ 5.95?</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">versicolor</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">virginica</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Each row of the table is a question. If the answer to a question is yes, we move to the indicated question or, if we now know the type, return the label. Notice that if the petal width is ≤ 0.8, the flower is an instance of <em>I. setosa</em> and there is no need to ask any further questions. This means of the three classes in the dataset, one is easily distinguished from the other two, but the remaining two need more work to tell apart. With the table, we now have what we need to implement the expert system. We begin with Q1, as that is the root of the tree, and move to other questions or endpoints based on the user’s response to each question.</p>&#13;
<p class="indent">The full expert system is in <em>irises.clp</em>. We’ll work through the code in sections beginning with the initial facts and helper rules (see <a href="ch06.xhtml#ch06list12">Listing 6-12</a>).</p>&#13;
<pre>(deffacts initial-facts ""&#13;
  (question "Is petal width &lt;= 0.80?")&#13;
  (state 1)&#13;
  (startup))&#13;
&#13;
(defrule start "start the program"&#13;
  ?r &lt;- (startup)&#13;
  =&gt;&#13;
  (printout t crlf)&#13;
  (printout t "Iris classifier.  Please respond 'y' or 'n' to each question." crlf)&#13;
  (printout t crlf)&#13;
  (retract ?r))&#13;
&#13;
(defrule ask-question "ask the user a question"&#13;
  ?p &lt;- (question ?q)&#13;
  =&gt;&#13;
  (retract ?p)&#13;
  (printout t ?q " ")&#13;
  (bind ?resp (readline))&#13;
  (assert (response ?resp)))&#13;
&#13;
<span epub:type="pagebreak" id="page_189"/>(defrule output-result "we have a label"&#13;
  (label ?label)&#13;
  =&gt;&#13;
  (printout t crlf "The sample is an instance of ")&#13;
  (printout t ?label crlf crlf)&#13;
  (halt))</pre>&#13;
<p class="caption" id="ch06list12"><em>Listing 6-12: Facts and helper rules</em></p>&#13;
<p class="indent">The program begins with the <code>start</code> rule, which fires because <code>initial-facts</code> places it on the facts list when <code>(reset)</code> is run. It also defines a <code>state</code> fact, set to <code>1</code> for question Q1, and the text of the question itself. When <code>startup</code> fires, it prints instructions for the user and retracts itself. The presence of the <code>question</code> rule fires <code>ask-question</code>, which displays the question text and asserts the user’s response: <code>y</code> or <code>n</code>. A full system would, naturally, validate the user’s input. Rule <code>output-result</code> reports when we have a valid label and halts.</p>&#13;
<p class="indent">Asserting a <code>response</code> fact causes a question rule to fire. There are 16 of them, two each for Q1 through Q8 in <a href="ch06.xhtml#ch06tab1">Table 6-1</a>, one each for a yes or no response. Let’s look at the first pair of rules. You should review <em>irises.clp</em> yourself to see the entire program.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list13">Listing 6-13</a> shows us the first two rules for Q1, that is, the first row of <a href="ch06.xhtml#ch06tab1">Table 6-1</a>.</p>&#13;
<pre>(defrule q1-yes ""&#13;
  ?q &lt;- (state 1)&#13;
  ?r &lt;- (response "y")&#13;
  =&gt;&#13;
  (retract ?q ?r)&#13;
  (assert (label "setosa (0)")))&#13;
&#13;
(defrule q1-no ""&#13;
  ?q &lt;- (state 1)&#13;
  ?r &lt;- (response "n")&#13;
  =&gt;&#13;
  (retract ?q ?r)&#13;
  (assert (state 2))&#13;
  (assert (question "Is petal length &lt;= 4.75?")))</pre>&#13;
<p class="caption" id="ch06list13"><em>Listing 6-13: Some iris rules</em></p>&#13;
<p class="indent">As you can see, if the user’s response to Q1 is “yes,” rule <code>q1-yes</code> fires. <a href="ch06.xhtml#ch06tab1">Table 6-1</a> says a “yes” response to Q1 means the sample is an instance of <em>I. setosa</em>. Therefore, rule <code>q1-yes</code> asserts <code>label</code>, causing <code>output-result</code> from <a href="ch06.xhtml#ch06list12">Listing 6-12</a> to fire, tell us the iris type, and halt.</p>&#13;
<p class="indent">If the user’s response to Q1 is “no,” rule <code>q1-no</code> fires instead. <a href="ch06.xhtml#ch06tab1">Table 6-1</a> says to move to Q2 in this case, so the RHS of <code>q1-no</code> asserts <code>state 2</code> and the proper <code>question</code>, which <code>ask-question</code> in <a href="ch06.xhtml#ch06list12">Listing 6-12</a> dutifully asks.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_190"/>As the user answers questions, CLIPS moves from state to state until it reaches a rule with a known label. For example, if we run <em>irises.clp</em> for the test sample above we get the output shown in <a href="ch06.xhtml#ch06list14">Listing 6-14</a>:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "irises.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
&#13;
Iris classifier.  Please respond 'y' or 'n' to each question.&#13;
&#13;
Is petal width &lt;= 0.80? <span class="codestrong1">n</span>&#13;
Is petal length &lt;= 4.75? <span class="codestrong1">n</span>&#13;
Is petal width &lt;= 1.75? <span class="codestrong1">y</span>&#13;
Is petal length &lt;= 5.05? <span class="codestrong1">y</span>&#13;
&#13;
The sample is an instance of versicolor (1)</pre>&#13;
<p class="caption" id="ch06list14"><em>Listing 6-14: Using the expert system</em></p>&#13;
<p class="indent">If you are patient enough, you can work through every example in the <em>iris_test_data.txt</em> file in the <em>SNOBOL/datasets</em> directory. Matching the reported labels against the known labels in <em>iris_test_labels.txt</em> will tell you that the iris expert system is 98 percent accurate, meaning it makes one mistake out of every 50 test samples. The SNOBOL nearest neighbor classifier is 96 percent accurate on the same test data using the same training data. Therefore, in this case, the expert system is quite good. Of course, our “expert knowledge” of iris flowers came from the training data in the first place, so we didn’t implement a true expert system. We merely encapsulated knowledge synthesized from a statistical model. I’ll have more to say about this in the discussion up next.</p>&#13;
<p class="indent">The examples in this section give us a good feel for CLIPS, but, as stated earlier, CLIPS is much more than we can explore here. For example, we ignored CLIPS’s object-oriented abilities and the fact that CLIPS is designed to play nicely when integrated into other applications. A quick review of Google Scholar shows that academic papers referencing CLIPS are still being written, to say nothing of industrial uses for CLIPS that are likely never discussed in print.</p>&#13;
<h3 class="h3" id="lev1sec51"><strong>Discussion</strong></h3>&#13;
<p class="noindent">Expert systems are often considered “old-school” or even “failures,” but that isn’t fair. You won’t hear the term <em>expert system</em> too much these days, but they are alive and well under the term <em>business rule management system.</em> For example, DROOLS (<em><a href="https://www.drools.org/">https://www.drools.org/</a></em>) is an open source rules-based system in active development with a large user base and supporting documentation, including multiple books. As a general approach to artificial intelligence, expert systems are passé, replaced by the phenomenal success of deep learning and neural networks, which represent a connectionist view of cognition, not the computational view embodied by an expert system.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_191"/>Expert systems are rigid. Once coded, they are not easily modified. Additionally, the rules often contain gaps, missing elements, or paths that are not specified. If a rule-based system claims to cover a topic, how would we know we’ve tested all the corner cases and all the possible sets of inputs? It becomes difficult, perhaps exponentially difficult, as the rules become more complex and intertwined.</p>&#13;
<p class="indent">The iris expert system shown earlier used “knowledge” extracted from a machine learning model. What if, instead, we needed to extract the rules from an expert gardener? The expert certainly knows how to identify iris flowers, but how do we get that knowledge out of the expert’s head and into a set of rules for CLIPS? The process of mapping an expert’s knowledge to rules is known as <em>knowledge extraction</em>, and it is an Achilles’ heel of sorts for expert systems. The concept of an expert system is seductive, but the realization is difficult at best. To be sure, the iris expert won’t know that a petal width less than 0.8 cm means the flower is almost certainly <em>I. setosa</em>, even if able to identify that species with almost perfect precision. How is that then captured and coded? Careful interviewing, which is highly time consuming, to say nothing of potentially irritating to the interviewee, might generate more general rules, but none would be as specific as those extracted by the decision tree. For example, one rule asks in a particular circumstance if the petal length is less than 4.75 cm, versus less than 4.85 cm in another. I doubt any expert would consider a millimeter difference in petal length of any importance.</p>&#13;
<p class="indent">CLIPS’s use has faded as expert systems have fallen out of favor, but it is still maintained. There are likely many CLIPS-based expert systems out there, quietly running in the background and invisible to the general public.</p>&#13;
<p class="indent">Because of its multiparadigm nature, CLIPS is, of course, a Turing-complete language. Indeed, one could use CLIPS without any reference to the rules engine if desired. As a framework for an expert system, CLIPS has stood the test of time, so if you find yourself in a situation where an expert system seems appropriate, CLIPS is an option. For us, CLIPS is an atypical language, but one we should be familiar with and keep in our back pocket for those times when the appropriate situation arises. In terms of thinking about coding, CLIPS requires a different approach if we want to use the rules engine. That fact alone warrants including CLIPS in our explorations.</p>&#13;
<h3 class="h3" id="lev1sec52"><strong>Summary</strong></h3>&#13;
<p class="noindent">The CLIPS expert system was the focus of this chapter. We introduced the language and the concept of an expert system before exploring the basics: facts and rules. The bulk of the chapter saw us work through four examples illustrating the core of CLIPS. We learned how rules respond to facts by building an elementary calculator. We then re-explored family relationships to illustrate the difference between CLIPS and Prolog when generating inferences from collections of facts. The next example used a factory simulation to demonstrate arranging the firing sequence of rules by manipulating their salience. The final example was our most elaborate. We used a learned <span epub:type="pagebreak" id="page_192"/>decision tree to implement a collection of rules, those that might have been created by an expert to let us categorize different types of iris flowers by answering a few yes or no questions.</p>&#13;
<p class="indent">CLIPS is our last atypical programming language. We move now to the first of our esolangs and into the realm of what I’m calling “eccentric programming languages.” We’ll begin with ABC, a tiny language that will serve us well to introduce the weirdly wonderful world of esolangs.</p>&#13;
</div></body></html>