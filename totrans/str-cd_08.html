<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_163"/><span class="big">6</span><br/>CLIPS</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">Back in the 1980s and 1990s, there was a hot new topic in artificial intelligence: <em>expert systems</em>, that is, programs that attempt to capture the knowledge of human experts in a particular domain in the form of rules, particularly <span class="literal">if-then</span> rules. In 1985, NASA developed CLIPS (“C Language Integrated Production System”) to create expert systems. CLIPS has been developed and maintained since then, becoming public domain software in 1996.</p>&#13;
<p class="indent">In this chapter, we’ll use CLIPS to get a feel for what an expert system is and how to create one, at least a primitive one. We’ll introduce CLIPS, and with it, the concepts behind expert systems. Then we’ll explore the language through a series of four examples: a calculator, a second look at the family relationships we explored with Prolog in <a href="ch01.xhtml#ch01">Chapter 1</a>, a simple factory simulation, and a complete expert system for the classification of iris flowers. We’ll end the chapter with a brief discussion of CLIPS as an atypical programming language.</p>&#13;
<h3 class="h3" id="lev1sec47"><span epub:type="pagebreak" id="page_164"/><strong>Installation</strong></h3>&#13;
<p class="noindent">Installing CLIPS is similar to installing SNOBOL. First, we need the tarball, <em>clips_core_source_631.tar.gz</em>, which we download from <em><a href="https://sourceforge.net/projects/clipsrules/files/CLIPS/6.31/">https://sourceforge.net/projects/clipsrules/files/CLIPS/6.31/</a></em>. Example files are in <em>examples_631.tar.gz</em>.</p>&#13;
<p class="indent">Expand the archive and build CLIPS.</p>&#13;
<pre>&gt; <span class="codestrong1">tar xzf clips_core_source_631.tar.gz</span> &#13;
&gt; <span class="codestrong1">cd clips_core_source_631/core/</span>&#13;
&gt; <span class="codestrong1">make</span></pre>&#13;
<p class="indent">Next, run CLIPS to make sure it works.</p>&#13;
<pre>&gt; <span class="codestrong1">./clips</span>&#13;
         CLIPS (6.31 6/12/19)&#13;
CLIPS&gt; <span class="codestrong1">(* (+ 1 2) 3)</span>&#13;
9&#13;
CLIPS&gt; <span class="codestrong1">(exit)</span></pre>&#13;
<p class="noindent">Note that the expression <span class="literal">(1+2)*3</span> becomes <span class="literal">(* (+ 1 2) 3)</span>. CLIPS, like Lisp, uses <em>S-expressions</em>, which are lists of items surrounded by parentheses. S-expressions are often nested, as in the example here, where the S-expression <span class="literal">(+ 1 2)</span> is nested inside the outer expression beginning with <span class="literal">*</span>.</p>&#13;
<p class="indent">The main CLIPS site is at <em><a href="http://www.clipsrules.net/">http://www.clipsrules.net/</a></em>. You can download the CLIPS 6.31 documentation from there, though we’ll introduce the essential elements of the system as we use it. If you see a version later than 6.31, go ahead and use it. The probability of CLIPS changing to the point where our examples no longer work is extremely low.</p>&#13;
<h3 class="h3" id="lev1sec48"><strong>Origins and Philosophy</strong></h3>&#13;
<p class="noindent">To understand CLIPS, we must first better understand what an expert system is. Expert systems were popular in the 1980s, and it was hoped then that they would prove helpful as a more general approach to artificial intelligence. We’ll discuss whether this hope was realized later in the chapter, but for now, note that the large-scale application of expert systems never happened.</p>&#13;
<p class="indent">An <em>expert system</em> is a computer program capable of inferring conclusions from a set of rules and facts. The rules are intended to capture the knowledge of a human expert in a specific domain, thereby allowing the software to perform similarly depending on the facts available. This is an abstract definition, and there is certainly room for other nuanced statements related to what an expert system is, but you’ll appreciate what an expert system is as we explore CLIPS.</p>&#13;
<p class="indent">An expert system is a collection of facts, rules (a knowledge base), and an inference engine to use those facts and rules to reach conclusions. Expert systems use facts and rules to determine behavior. For example, an expert system monitoring a building might have a rule like the following:</p>&#13;
<pre><span epub:type="pagebreak" id="page_165"/>if door-is-open and time-is-after-midnight then signal-the-police</pre>&#13;
<p class="noindent">Here, <span class="literal">door-is-open</span>, <span class="literal">time-is-after-midnight</span>, and <span class="literal">signal-the-police</span> are all facts. Note that the last fact is one that the rule puts into the knowledge base when the rule fires. In other words, the rule <em>asserts</em> the fact, which later might cause another rule to fire.</p>&#13;
<p class="indent">In CLIPS this might be written as</p>&#13;
<pre>(defrule intruder&#13;
    ?x &lt;- (door-is-open)&#13;
    ?y &lt;- (after-midnight)&#13;
  =&gt;&#13;
    (retract ?x ?y)&#13;
    (assert (signal-the-police)))</pre>&#13;
<p class="noindent">We’ll get to the exact syntax of a CLIPS rule in a bit, but even now, we can start to see what is going on.</p>&#13;
<p class="indent">Put enough of these rules together and you have a system embodying a tiny knowledge domain. In other words, the system is an expert in that tiny domain. At least, that’s the hope.</p>&#13;
<p class="indent">Viewed this way, an expert system might be thought of as a glorified set of <span class="literal">if-then</span> statements. And in a way, it is, but much can happen in the <span class="literal">then</span> part, thereby enabling the system to respond in a sophisticated manner, provided the developer captured the essential knowledge of the domain expert and properly arranged that knowledge in the form of rules firing in response to a particular set of facts.</p>&#13;
<p class="indent">Expert systems rely on forward chaining. This is in contrast to a language like Prolog, which uses backward chaining. <em>Forward chaining</em> systems process the data embodied in the facts they know to find valid conclusions. In contrast, <em>backward chaining</em> systems work from the goal to find true statements that support the goal.</p>&#13;
<p class="indent">A forward chaining system explores all known facts to select rules to evaluate, or <em>fire</em>. A system like CLIPS places rules to fire on an <em>agenda</em> and then uses <em>conflict resolution</em> to select which specific rule to fire. Firing a rule may update the set of known facts, causing other rules to fire, in which case, CLIPS continues to run until the agenda is empty or until it is explicitly told to stop.</p>&#13;
<p class="indent">Internally, CLIPS uses the <em>Rete algorithm</em> to perform inference, that is, to find conclusions by applying a set of rules to a collection of facts. Unlike the other programming languages we’ve explored (except Prolog), CLIPS incorporates advanced concepts in its inference engine that are worth digging into if you are curious; however, these concepts are well beyond what we intend to explore here. Our concern is the language and how to think in terms of it.</p>&#13;
<p class="indent">As you saw earlier, syntactically, CLIPS looks like Lisp, using S-expressions, or prefix notation, where <em>f</em> (<em>x</em>, <em>y</em>) becomes (<em>f</em> <em>x</em> <em>y</em>) so the function moves inside the parentheses.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_166"/>CLIPS is a multiparadigm language: it is declarative at its base because of the inference engine and how code normally runs, but it is also procedural, with standard control structures, and object oriented, though we’ll completely ignore that aspect of the language here. CLIPS runs from the command line with its REPL, which is how we’ll use it; however, it’s also possible to embed it in another application.</p>&#13;
<p class="indent">Let’s see CLIPS in action and then walk through some examples to show us how to work with the system. Along the way, we’ll introduce different aspects of the language.</p>&#13;
<h3 class="h3" id="lev1sec49"><strong>The Language</strong></h3>&#13;
<p class="noindent">Let’s run one of the demos that comes with CLIPS. We won’t look at the code—it’s beyond what we want to consider—but it will show us how to work with the system and serves as a nice example of how an expert system works. The example is in <em>wine.clp</em>. The purpose of the expert system is to recommend a wine to go with a dinner we are preparing. The program will ask us questions and, based on our responses, generate a list of recommended wines with probabilities to select a good pairing.</p>&#13;
<h4 class="h4" id="lev2sec47"><strong><em>Working with CLIPS</em></strong></h4>&#13;
<p class="noindent">A typical session with <em>wine.clp</em> looks like this:</p>&#13;
<pre>&gt; <span class="codestrong1">clips</span>&#13;
CLIPS&gt; <span class="codestrong1">(load "wine.clp")</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
Do you generally prefer dry, medium, or sweet wines? <span class="codestrong1">dry</span>&#13;
Do you generally prefer red or white wines? <span class="codestrong1">white</span>&#13;
Do you generally prefer light, medium, or full bodied wines? <span class="codestrong1">light</span>&#13;
Is the flavor of the meal delicate, average, or strong? <span class="codestrong1">average</span>&#13;
Does the meal have a sauce on it? <span class="codestrong1">no</span>&#13;
Is the main component of the meal meat, fish, or poultry? <span class="codestrong1">fish</span>&#13;
&#13;
        SELECTED WINES&#13;
&#13;
 WINE                  CERTAINTY&#13;
 -------------------------------&#13;
 Chardonnay               58%&#13;
 Soave                    40%&#13;
 Sauvignon-Blanc          40%&#13;
 Chablis                  40%&#13;
 Geverztraminer           30%&#13;
&#13;
CLIPS&gt; <span class="codestrong1">(exit)</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_167"/>First, we load <em>wine.clp</em>. Not shown is CLIPS reporting the successful compilation of the various code components in the file. After loading, CLIPS must be reset before running. Resetting is necessary to configure CLIPS because it places a set of initial facts on the facts list. If the <span class="literal">(reset)</span> step is skipped, running <em>wine.clp</em> will display the <span class="literal">SELECTED WINES</span> banner and nothing more.</p>&#13;
<p class="indent">The wine demo asks the user a series of questions. Based on the user’s response, the demo provides a list of selected wines with a probability of pairing with the indicated meal. Reset and run the demo a second time, enter the same responses, and the list should be the same. CLIPS is working through a set of rules and will arrive at the same conclusion each time the inputs match. There is nothing stochastic, no randomness, to what CLIPS is doing.</p>&#13;
<p class="indent">While the system is running, the set of facts may change and new inputs may be read. The agenda changes in response to rules that can fire. A <span class="literal">reset</span> configures CLIPS by defining the initial set of facts. For example:</p>&#13;
<pre>&gt; <span class="codestrong1">clips</span>&#13;
CLIPS&gt; <span class="codestrong1">(load "wine.clp")</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
&#13;
        SELECTED WINES&#13;
&#13;
 WINE                  CERTAINTY&#13;
 -------------------------------&#13;
&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
For a total of 1 fact.&#13;
CLIPS&gt; <span class="codestrong1">(agenda)</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-36    (attribute (name best-color) (value any) (certainty 100.0))&#13;
f-37    (attribute (name best-body) (value any) (certainty 100.0))&#13;
f-38    (attribute (name best-sweetness) (value any) (certainty 100.0))&#13;
For a total of 4 facts.&#13;
CLIPS&gt; <span class="codestrong1">(agenda)</span>&#13;
10000  start: *&#13;
For a total of 1 activation.</pre>&#13;
<p class="indent">Here, we tell CLIPS to run the wine program without issuing a <span class="literal">(reset)</span> first. The header is shown, nothing more. Asking for the current set of facts returns only the default initial fact (<span class="literal">f-0</span>). Asking for the agenda returns nothing as the agenda is empty. When the agenda is empty, CLIPS stops. We then reset CLIPS and ask for the facts a second time. Now we see the initial set of facts defined by <em>wine.clp</em>. We don’t need to understand the structure <span epub:type="pagebreak" id="page_168"/>right now, only see that the list of facts has been configured. Asking for the agenda now shows one activation, <span class="literal">start</span>. An activated rule is one where the conditions have been met. The wine demo is now ready. When we call <span class="literal">run</span>, the <span class="literal">start</span> rule will become active.</p>&#13;
<h4 class="h4" id="lev2sec48"><strong><em>Implementing Hello World</em></strong></h4>&#13;
<p class="noindent">Let’s implement our old friend, “Hello, world!” We’ll write two versions. The first uses the inference engine by defining a rule that always fires. The second is purely procedural, proving that CLIPS does support imperative programming.</p>&#13;
<p class="indent">The file <em>hello0.clp</em> contains</p>&#13;
<pre>(defrule hello&#13;
  =&gt; (printout t "Hello, world!" crlf))</pre>&#13;
<p class="noindent">We’ll detail the syntax of <span class="literal">defrule</span> in the next section. For now, know that it defines a rule named <span class="literal">hello</span>. The portion of a rule after the arrow (<span class="literal">=&gt;</span>) is the part that runs, which is the <span class="literal">then</span> portion. There is nothing to the left of the arrow because this rule always fires or fires if <span class="literal">initial-fact</span>, <span class="literal">f-0</span> above, is defined, which it is by default.</p>&#13;
<p class="indent">To execute the rule we need only use <span class="literal">(run)</span> as there is nothing to configure regarding other facts and the agenda. Running the program looks like the following:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "hello0.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
Hello, world!</pre>&#13;
<p class="indent">Excellent; our rule fired. However, you might have a question. If the rule <span class="literal">hello</span> is set to fire when <span class="literal">initial-fact</span> is present, which it always is, why doesn’t CLIPS print “Hello, world!” forever? There is nothing removing the initial fact, so it’s still present. Why doesn’t the rule match again and again? This is because CLIPS fires a rule only once for each set of matching conditions. This is known as <em>refraction</em> (this term is borrowed from neuroscience, where it is related to the time delay after a neuron fires before it can fire again).</p>&#13;
<p class="indent">The file <em>hello0.clp</em> defined a rule and used CLIPS’s inference engine to fire it. CLIPS allows imperative programming as well. The file <em>hello1.clp</em> contains the following:</p>&#13;
<pre>(deffunction hello () (printout t "Hello, world!" crlf))&#13;
(hello)&#13;
(exit)</pre>&#13;
<p class="noindent">We can run this from the command line as follows:</p>&#13;
<pre>&gt; <span class="codestrong1">clips -f2 hello1.clp</span>&#13;
Hello, world!</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_169"/>Use <span class="literal">-f</span> or <span class="literal">-f2</span> to execute a program from the command line. The second option (<span class="literal">-f2</span>) disables load messages. Calling <span class="literal">(exit)</span> keeps the program from showing the <span class="literal">CLIPS&gt;</span> prompt after running. The file <em>hello1.clp</em> uses <span class="literal">deffunction</span> to define a function named <span class="literal">hello</span> that is then called before exiting to print the message. The <span class="literal">t</span> after <span class="literal">printout</span> specifies the output file—in this case the terminal. CLIPS’s support for imperative programming covers all the expected control structures like <span class="literal">if-then</span> and <span class="literal">while</span>. We won’t discuss those elements here, but do consult the CLIPS documentation to learn about them. A good place for control structures is in the action part of a rule.</p>&#13;
<p class="indent">CLIPS manipulates facts with rules and input. The rules, when active, affect the agenda, and it is the agenda that drives a CLIPS program. Let’s learn more about facts and rules.</p>&#13;
<h4 class="h4" id="lev2sec49"><strong><em>Facts and Rules</em></strong></h4>&#13;
<p class="noindent">You’ve already seen a bit about facts and rules, but to understand the examples that follow, we’ll need a more thorough understanding. Let’s dive in.</p>&#13;
<h5 class="h5" id="lev3sec27"><strong>Facts</strong></h5>&#13;
<p class="noindent"><em>Facts</em> are asserted (<span class="literal">assert</span>) and retracted (<span class="literal">retract</span>) as needed when rules fire. Simple facts are straightforward to add. For example:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(assert (emergency-brake-on))</span>&#13;
&lt;Fact-1&gt;&#13;
CLIPS&gt; <span class="codestrong1">(assert (roses-are red))</span>&#13;
&lt;Fact-2&gt;&#13;
CLIPS&gt; <span class="codestrong1">(assert (violets-are blue))</span>&#13;
&lt;Fact-3&gt;&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-1     (emergency-brake-on)&#13;
f-2     (roses-are red)&#13;
f-3     (violets-are blue)&#13;
For a total of 4 facts.</pre>&#13;
<p class="noindent">Three facts are asserted. The first might indicate to a running system managing a car that the emergency brake is on. The other two are the symbols <span class="literal">roses-are</span> and <span class="literal">violets-are</span> along with symbols for colors. Equivalent to an atom in Prolog, a <em>symbol</em> in CLIPS is a set of characters that represents itself, unlike a variable, which is a name given to a value. A symbol has no value. A set of facts may be defined at one time with <span class="literal">deffacts</span>. Facts defined this way are put on the facts list when <span class="literal">(reset)</span> is executed. Consider the following:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
For a total of 1 fact.&#13;
CLIPS&gt; <span class="codestrong1">(deffacts arthropods (insects 6) (spiders 8) (trilobites 48))</span>&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span><span epub:type="pagebreak" id="page_170"/>&#13;
f-0     (initial-fact)&#13;
For a total of 1 fact.&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-1     (insects 6)&#13;
f-2     (spiders 8)&#13;
f-3     (trilobites 48)&#13;
For a total of 4 facts.</pre>&#13;
<p class="indent">In this example, CLIPS has only the initial fact at first. Then, a <span class="literal">deffacts</span> statement named <span class="literal">arthropods</span> defines a set of facts. There are three facts defined, each a type of arthropod followed by the number of legs. (Of course, some arthropod enthusiasts may object that trilobites vary in the number of legs, but 48 isn’t a bad guess.)</p>&#13;
<p class="indent">The next line uses <span class="literal">(facts)</span>, but our newly declared facts are not present. When <span class="literal">assert</span> was used above, the facts appeared immediately. However, with <span class="literal">deffacts</span>, we must use <span class="literal">(reset)</span> first and then the facts appear. Any previously defined facts are lost as well.</p>&#13;
<p class="indent">Complex facts have many parts, some of which may be updated as CLIPS runs. CLIPS provides a mechanism for defining complex facts. For example, the file <em>coin.clp</em> defines a fact template for ancient Roman coins along with facts related to specific Roman coins:</p>&#13;
<pre>(deftemplate roman-coin "Roman coin facts"&#13;
  (slot emperor)&#13;
  (slot denomination)&#13;
  (slot obverse)&#13;
  (slot reverse))&#13;
&#13;
(deffacts coin-facts "ancient Roman coins"&#13;
  (ancient (emperor Otho)&#13;
           (denomination Denarius)&#13;
           (obverse "Emperor hd right")&#13;
           (reverse "Securitas std left"))&#13;
  (ancient (emperor Constantine)&#13;
           (denomination AE3)&#13;
           (obverse "IMP CONSTANTINVS MAX AVG")&#13;
           (reverse "VICTORIAE LAETAE PRINC PERP")) )</pre>&#13;
<p class="noindent">Here, <span class="literal">deftemplate</span> defines a fact template named <span class="literal">roman-coin</span> with an optional comment string. The fields of a fact are called <em>slots</em>. The template defines four fields: <span class="literal">emperor</span>, <span class="literal">denomination</span>, <span class="literal">obverse</span>, and <span class="literal">reverse</span>.</p>&#13;
<p class="indent">With <span class="literal">roman-coin</span> defined, we can then assert some facts about specific coins using <span class="literal">deffacts</span>. The first relates to a silver denarius of the first-century emperor Otho, one of the “Twelve Caesars” who ruled from January 15 to April 16 in the year 69. A denarius was the usual day’s wage for a Roman <span epub:type="pagebreak" id="page_171"/>soldier. The second coin is a small bronze coin, loose change of the time, minted by Constantine the Great around the year 325.</p>&#13;
<p class="indent">Let’s inform CLIPS about these coins.</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "coin.clp")</span>&#13;
Defining deftemplate: coin&#13;
Defining deffacts: coin-facts&#13;
TRUE&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-1     (coin (emperor Otho) &#13;
              (denomination Denarius) &#13;
              (obverse "Emperor hd right") &#13;
              (reverse "Securitas std left"))&#13;
f-2     (coin (emperor Constantine) &#13;
              (denomination AE3) &#13;
              (obverse "IMP CONSTANTINVS MAX AVG") &#13;
              (reverse "VICTORIAE LAETAE PRINC PERP"))&#13;
For a total of 3 facts.&#13;
CLIPS&gt; <span class="codestrong1">(retract 1)</span>&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-2     (coin (emperor Constantine) &#13;
              (denomination AE3) &#13;
              (obverse "IMP CONSTANTINVS MAX AVG") &#13;
              (reverse "VICTORIAE LAETAE PRINC PERP"))&#13;
For a total of 2 facts.</pre>&#13;
<p class="indent">After loading <em>coin.clp</em>, we reset and look at the known facts. There are the new coins. During execution, CLIPS will often assert and retract facts. Here, we manually retract the first coin fact with <span class="literal">retract</span>, and after running <span class="literal">(facts)</span> again we see that it is no longer present. Notice that the fact numbers do not change after this. Fact <span class="literal">f-2</span> is still fact <span class="literal">f-2</span>.</p>&#13;
<h5 class="h5" id="lev3sec28"><strong>Rules</strong></h5>&#13;
<p class="noindent"><em>Rules</em> are <span class="literal">if-then</span> constructs. The syntax for a rule is</p>&#13;
<pre>(defrule <span class="codeitalic1">&lt;rule-name&gt;</span> "<span class="codeitalic1">&lt;optional-comment&gt;</span>"&#13;
  (<span class="codeitalic1">&lt;lefthand-side&gt;</span>) =&gt; (<span class="codeitalic1">&lt;righthand-side&gt;</span>))</pre>&#13;
<p class="indent">The <span class="codeitalic">(&lt;lefthand-side&gt;)</span>, or LHS, is a set of zero or more conditions that attempt to match facts. The conditions are ANDed, which means that all must match for the rule to fire. When the rule does fire, everything on the <span class="codeitalic">(&lt;righthand-side&gt;)</span>, or RHS, is executed. These are the rule’s <em>actions</em>. Typically, the actions alter the set of facts in some way to move the program forward. However, the actions may also have side effects, like printing information or requesting information from the user (this is where CLIPS’s <span epub:type="pagebreak" id="page_172"/>imperative coding abilities come into play). Rules with a matching LHS are placed on the agenda to execute their respective RHSs.</p>&#13;
<p class="indent">As rules match, they may also bind variables that are local to the rule. CLIPS variables follow the expected naming convention, but they must be referenced with a leading question mark. For example, <span class="literal">?x</span> refers to the variable <span class="literal">x</span>. Binding on the LHS of a rule is useful as the bound variables may be used on the RHS. We’ll see examples of this later in the chapter. To bind a variable directly, that is, to assign something to it, use the <span class="literal">bind</span> statement.</p>&#13;
<pre>CLIPS&gt; (bind ?x 1)&#13;
CLIPS&gt; (bind ?y 1121)&#13;
CLIPS&gt; (printout t (/ ?x ?y) crlf)&#13;
0.000892060660124889</pre>&#13;
<p class="indent">Here’s a hypothetical rule to react to a security breach.</p>&#13;
<pre>(defrule react-security-breach "React to a security breach"&#13;
    ?r &lt;- (security-breach ?typ)&#13;
  =&gt;&#13;
    (retract ?r)&#13;
    (assert (log-security-breach ?typ))&#13;
    (printout t "!!! security alert !!!" crlf))</pre>&#13;
<p class="indent">The rule name is <span class="literal">react-security-breach</span>. The LHS, the part before <span class="literal">=&gt;</span>, is the condition that matches a fact of the form <span class="literal">security-breach</span> <span class="literal">&lt;type&gt;</span>, where the actual type is bound to <span class="literal">?typ</span>. For example, <span class="literal">(security-breach hacker)</span> would match the rule and bind the symbol <span class="literal">hacker</span> to the variable <span class="literal">?typ</span>.</p>&#13;
<p class="indent">The LHS has a funny bit of syntax: <span class="literal">?r &lt;-</span>. When the <span class="literal">security-breach</span> fact matches, it returns the fact number, which is bound to <span class="literal">?r</span>. The RHS of the rule, the part after <span class="literal">=&gt;</span>, uses <span class="literal">?r</span> to <span class="literal">retract</span> the matched fact. As we are processing the security breach, we remove the trigger for this rule. Because of refraction, the rule will fire only once for the specific fact <span class="literal">(security-breach</span> <span class="literal">hacker)</span>. Retracting the fact removes it, so when it is asserted again, the rule will fire once more.</p>&#13;
<p class="indent">The RHS of this rule asserts <span class="literal">(log-security-breach ?typ)</span> to add a new fact. Note the use of <span class="literal">?typ</span>, which CLIPS extracted from the LHS of the rule. Asserting this fact acts as a trigger for another rule that will write some information to a logfile or perhaps send an alert email to the IT department. The final part of the rule prints the alert so we can see it.</p>&#13;
<p class="indent">If the rule is in <em>security.clp</em>, we load and run it as follows:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "security.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(assert (security-breach hacker))</span>&#13;
&lt;Fact-1&gt;&#13;
CLIPS&gt; <span class="codestrong1">(run)</span><span epub:type="pagebreak" id="page_173"/>&#13;
!!! security alert !!!&#13;
CLIPS&gt; <span class="codestrong1">(facts)</span>&#13;
f-0     (initial-fact)&#13;
f-2     (log-security-breach hacker)&#13;
For a total of 2 facts.</pre>&#13;
<p class="noindent">To trigger the rule after reset, we must assert a security breach, which in this case is a hacker security breach. Running it shows us the security alert message indicating the rule fired. If we examine the known facts, we see a new one, <span class="literal">f-2</span>, which is the fact asserted by our rule.</p>&#13;
<p class="indent">CLIPS is large, powerful, and reasonably complex. Let’s spend the remainder of the chapter exploring selected examples to illustrate how CLIPS works, at least at the level we’ll use it.</p>&#13;
<h3 class="h3" id="lev1sec50"><strong>CLIPS in Action</strong></h3>&#13;
<p class="noindent">To build our intuition about CLIPS, in this section we’ll walk through four examples. The first is an elementary calculator, just enough to get our feet wet. Next, we’ll revisit the Greek god family tree from <a href="ch01.xhtml#ch01">Chapter 1</a> to see CLIPS’s take on it. Following that is a basic factory simulation, which illustrates how a CLIPS expert system might operate when monitoring something in the real world. Lastly, we’ll build an expert system for iris flowers to compare a rule-based classifier with the SNOBOL nearest neighbor classifier of <a href="ch05.xhtml#ch05">Chapter 5</a>.</p>&#13;
<h4 class="h4" id="lev2sec50"><strong><em>An Elementary Calculator</em></strong></h4>&#13;
<p class="noindent">This example implements a calculator. For the calculator, we need four rules. The first rule handles the startup message and informs the user. The next rule handles binary operators like plus and multiply. Next, we need a rule for unary operations like sine and cosine. The final rule accepts input from the user and asserts the operation for the binary or unary rule to act upon. The source code is in <em>math.clp</em>.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list1">Listing 6-1</a> contains the set of initial facts and the <span class="literal">start</span> rule.</p>&#13;
<pre>(defrule start ""&#13;
  ?r &lt;- (startup)&#13;
  =&gt;&#13;
  (printout t "A simple calculator." crlf)&#13;
  (printout t crlf)&#13;
  (printout t "Enter &lt;number&gt; &lt;op&gt; &lt;number&gt; where" crlf)&#13;
  (printout t "&lt;op&gt; is +, -, *, /, ^, mod" crlf crlf)&#13;
  (printout t "Enter &lt;function&gt; &lt;arg&gt; where" crlf)&#13;
  (printout t "      &lt;function&gt; is: trig, log, exp, or sqrt" crlf crlf)&#13;
  (printout t "Type 'end' to exit and @ to use previous result." crlf)<span epub:type="pagebreak" id="page_174"/>&#13;
  (retract ?r)&#13;
  (assert (get-next-operation)))&#13;
&#13;
(deffacts initial-facts ""&#13;
  (@ 0)&#13;
  (startup))</pre>&#13;
<p class="caption" id="ch06list1"><em>Listing 6-1: Initializing the calculator</em></p>&#13;
<p class="indent">Here, there are two initial facts. The first is <span class="literal">(startup)</span>, and the second is <span class="literal">@ 0</span>. We’ll use the <span class="literal">@</span> fact to keep the result of the last operation.</p>&#13;
<p class="indent">The LHS of the <span class="literal">start</span> rule matches <span class="literal">(startup)</span>, which is asserted when CLIPS is reset because of <span class="literal">deffacts</span>. This rule does three things: first, it prints a set of instructions for the user; second, it retracts <span class="literal">(startup)</span> so it is no longer in the facts list; and third, it asserts <span class="literal">(get-next-operation)</span>. We’ll use this fact to request input from the user.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list2">Listing 6-2</a> shows the <span class="literal">get-operation</span> rule.</p>&#13;
<pre>(defrule get-operation ""&#13;
  ?w &lt;- (get-next-operation)&#13;
  =&gt;&#13;
  (retract ?w)&#13;
  (printout t crlf "      ")&#13;
  (bind ?expr (readline))&#13;
  (if (eq ?expr "end") then (halt))&#13;
  (assert (operation (explode$ ?expr))) )</pre>&#13;
<p class="caption" id="ch06list2"><em>Listing 6-2: Processing user input</em></p>&#13;
<p class="indent">The <span class="literal">get-operation</span> rule fires only when <span class="literal">(get-next-operation)</span> is in the facts list. As <span class="literal">start</span> places this fact on the list after it is done, the <span class="literal">get-operation</span> rule will fire immediately after <span class="literal">start</span> ends. As CLIPS fires rules only once, when matched, we retract <span class="literal">(get-next-operation)</span> so the rule will fire the next time it is asserted.</p>&#13;
<p class="indent">The remainder of <span class="literal">get-operation</span> displays a prompt of spaces and then binds <span class="literal">?expr</span> to the string typed by the user. After a quick check to see if the user entered <span class="literal">end</span>, the operation is asserted. The <span class="literal">explode$</span> function takes a string and splits it into a list, the elements of which become the fields of the <span class="literal">operation</span> fact. CLIPS refers to lists as <em>multifields</em>.</p>&#13;
<p class="indent">The instructions tell the user to enter expressions carefully. A unary expression is the function name followed by one or more spaces and an argument consisting of either a number or <span class="literal">@</span> to use the previous result. A binary expression is the first operand, spaces, operation, spaces, and second operand. When exploded, the <span class="literal">operation</span> fact will contain three fields if it’s a binary expression or two if it’s a unary expression.</p>&#13;
<p class="indent">Now consider <a href="ch06.xhtml#ch06list3">Listing 6-3</a>, which processes unary expressions.</p>&#13;
<pre>(defrule unary-math ""&#13;
  ?w &lt;- (operation ?func ?x)&#13;
  ?at &lt;- (@ ?last)<span epub:type="pagebreak" id="page_175"/>&#13;
  =&gt;&#13;
  (retract ?w)&#13;
  (retract ?at)&#13;
  (assert (get-next-operation))&#13;
  (if (eq ?x @) then (bind ?x ?last))&#13;
  (if (eq ?func cos) then (bind ?y (cos ?x)))&#13;
  (if (eq ?func sin) then (bind ?y (sin ?x)))&#13;
  (if (eq ?func tan) then (bind ?y (tan ?x)))&#13;
  (if (eq ?func log) then (bind ?y (log ?x)))&#13;
  (if (eq ?func exp) then (bind ?y (exp ?x)))&#13;
  (if (eq ?func sqrt) then (bind ?y (sqrt ?x)))&#13;
  (printout t ?y)&#13;
  (assert (@ ?y)))</pre>&#13;
<p class="caption" id="ch06list3"><em>Listing 6-3: Processing a unary expression</em></p>&#13;
<p class="indent">The <span class="literal">unary-math</span> rule is triggered by an <span class="literal">operation</span> fact with two fields. The first is the function (<span class="literal">?func</span>) and the second is the argument to the function (<span class="literal">?x</span>). The last result is also part of the LHS, so we can pull it from the facts list. Both the operation and last result are retracted, meaning they will be asserted again later.</p>&#13;
<p class="indent">The rule asserts <span class="literal">(get-next-operation)</span> to fire <span class="literal">get-operation</span> again to acquire the next expression from the user. The remainder of the rule performs the requested operation. If <span class="literal">?x</span> is <span class="literal">@</span>, <span class="literal">?x</span> is updated to be the previous result (<span class="literal">?last</span>). The actual operation generates an output value, <span class="literal">?y</span>, which is printed and asserted as the new previous result, which is the <span class="literal">@</span> fact.</p>&#13;
<p class="indent">Binary expressions are processed by <a href="ch06.xhtml#ch06list4">Listing 6-4</a>.</p>&#13;
<pre>(defrule binary-math ""&#13;
  ?w &lt;- (operation ?a ?op ?b)&#13;
  ?at &lt;- (@ ?last)&#13;
  =&gt;&#13;
  (retract ?w)&#13;
  (retract ?at)&#13;
  (assert (get-next-operation))&#13;
  (if (eq ?a @) then (bind ?a ?last))&#13;
  (if (eq ?b @) then (bind ?b ?last))&#13;
  (if (eq ?op +) then (bind ?y (+ ?a ?b)))&#13;
  (if (eq ?op -) then (bind ?y (- ?a ?b)))&#13;
  (if (eq ?op *) then (bind ?y (* ?a ?b)))&#13;
  (if (eq ?op /) then (bind ?y (/ ?a ?b)))&#13;
  (if (eq ?op ^) then (bind ?y (** ?a ?b)))&#13;
  (if (eq ?op mod) then (bind ?y (mod ?a ?b)))&#13;
  (printout t ?y)&#13;
  (assert (@ ?y)))</pre>&#13;
<p class="caption" id="ch06list4"><em>Listing 6-4: Processing a binary expression</em></p>&#13;
<p class="indent">This rule is substantially the same as the unary expression case, but matches an operation with two arguments instead of one. CLIPS knows <span epub:type="pagebreak" id="page_176"/>which rule to fire, <span class="literal">unary-math</span> or <span class="literal">binary-math</span>, because of the number of fields in the <span class="literal">operation</span> fact.</p>&#13;
<p class="indent">Let’s see <em>math.clp</em> in action.</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "math.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
A simple calculator.&#13;
&#13;
Enter &lt;number&gt; &lt;op&gt; &lt;number&gt; where&#13;
&lt;op&gt; is +, -, *, /, ^, mod&#13;
&#13;
Enter &lt;function&gt; &lt;arg&gt; where&#13;
      &lt;function&gt; is: trig, log, exp, or sqrt&#13;
&#13;
Type 'end' to exit and @ to use the previous result.&#13;
&#13;
      <span class="codestrong1">111 * 123</span>&#13;
13653&#13;
      <span class="codestrong1">@ + 5</span>&#13;
13658&#13;
      <span class="codestrong1">@ / 23456</span>&#13;
0.582281718963165&#13;
      <span class="codestrong1">cos @</span>&#13;
0.835210036979047&#13;
      <span class="codestrong1">exp @</span>&#13;
2.30529819530959&#13;
      <span class="codestrong1">@ ^ @</span>&#13;
6.8579474467406&#13;
      <span class="codestrong1">end</span></pre>&#13;
<p class="noindent">User entries are in bold, demonstrating both binary and unary expressions, most of which use the previous result. Note that spaces are required between operands and operators.</p>&#13;
<p class="indent">This example exposes a general pattern: store information on the facts list and use assertions and retractions to arrange the flow of the program. The calculator begins with the startup message, which then asserts a fact to cause <span class="literal">get-operation</span> to fire, thereby acquiring and processing input from the user. In turn, that rule asserts the fact of the desired operation. The inference engine causes the proper binary or unary rule to fire to process the request. Those rules retract and reassert the last result, so the version in the fact list is always correct. They also reassert <span class="literal">(get-next-operation)</span> to acquire more input from the user. This keeps the program running until <span class="literal">(halt)</span> is executed.</p>&#13;
<h4 class="h4" id="lev2sec51"><span epub:type="pagebreak" id="page_177"/><strong><em>Family Redux</em></strong></h4>&#13;
<p class="noindent">In <a href="ch01.xhtml#ch01">Chapter 1</a>, we used Prolog to explore the sometimes unusual family relationships among the ancient Greek gods. Let’s revisit that example now to understand what CLIPS might do with the same set of facts. This example is in <em>family.clp</em>. Let’s walk through the code, then run it to see what manner of output we get.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list5">Listing 6-5</a> is only partial. See <em>family.clp</em> for the complete set of facts.</p>&#13;
<pre>(deffacts olympians&#13;
    (male uranus)&#13;
    (male cronus)&#13;
<span class="codeitalic1">--snip--</span>&#13;
    (female gaia)&#13;
    (female rhea)&#13;
<span class="codeitalic1">--snip--</span>&#13;
    (parent uranus cronus)&#13;
    (parent gaia cronus)&#13;
<span class="codeitalic1">--snip--</span>&#13;
    (married zeus hera)&#13;
    (married hephaestus aphrodite))</pre>&#13;
<p class="caption" id="ch06list5"><em>Listing 6-5: Some facts about the Olympians</em></p>&#13;
<p class="indent">As with Prolog, we declare some gods as male and other gods as female before listing parent-child relationships in the form <span class="literal">(parent x y)</span>, which means <span class="literal">X</span> is a parent of <span class="literal">Y</span>. If gods were considered married, the facts list captures that as well.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list6">Listing 6-6</a> gives us rules capturing basic family relationships.</p>&#13;
<pre>(defrule father&#13;
    (parent ?x ?y)&#13;
    (male ?x)&#13;
  =&gt;&#13;
    (printout t ?x " is father of " ?y crlf))&#13;
&#13;
(defrule mother&#13;
    (parent ?x ?y) &#13;
    (female ?x)&#13;
  =&gt;&#13;
    (printout t ?x " is mother of " ?y crlf))&#13;
&#13;
(defrule wife&#13;
    (female ?x)&#13;
    (or (married ?x ?y) (married ?y ?x))&#13;
  =&gt;&#13;
    (printout t ?x " is wife of " ?y crlf))<span epub:type="pagebreak" id="page_178"/>&#13;
&#13;
(defrule husband&#13;
    (male ?x)&#13;
    (or (married ?x ?y) (married ?y ?x))&#13;
  =&gt;&#13;
    (printout t ?x " is husband of " ?y crlf))</pre>&#13;
<p class="caption" id="ch06list6"><em>Listing 6-6: Rules capturing basic relationships</em></p>&#13;
<p class="indent">As we can see in the first <span class="literal">defrule</span> in <a href="ch06.xhtml#ch06list6">Listing 6-6</a>, <span class="literal">x</span> is the father of <span class="literal">y</span> if <span class="literal">x</span> is a parent of <span class="literal">y</span> and <span class="literal">x</span> is male. The LHS of the rules captures the relationship from the facts binding variables. For example, the <span class="literal">father</span> rule binds both <span class="literal">?x</span> and <span class="literal">?y</span>, meaning it will fire if there is a set of <span class="literal">(parent x y)</span> and <span class="literal">(male x)</span> facts in the facts list where the same <span class="literal">x</span> is parent of <span class="literal">y</span> and also male. Therefore, for a rule’s LHS, variables with the same name must be the same for every part of the condition to be true. When the rule fires, it simply outputs the now proven fact that <span class="literal">x</span> is the father of <span class="literal">y</span>. Notice that nothing is added to or removed from the facts list by these rules. These rules produce output only. Refraction will prevent the rule from firing more than once for the same set of facts.</p>&#13;
<p class="indent">The rule for <span class="literal">mother</span> is almost the same as <span class="literal">father</span>. The rules for <span class="literal">wife</span> and <span class="literal">husband</span> include a logical-OR because <span class="literal">married</span> might be specified as <span class="literal">(married</span> <span class="literal">zeus hera)</span> or <span class="literal">(married hera zeus)</span>. Again, the rules make no change to the facts list.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list7">Listing 6-7</a> shows us three more rules from <em>family.clp</em>.</p>&#13;
<pre>(defrule sibling&#13;
    (parent ?p ?x)&#13;
    (parent ?p ?y)&#13;
    (test (neq ?x ?y))&#13;
  =&gt;&#13;
    (assert (siblings ?x ?y)))&#13;
&#13;
(defrule sister&#13;
    (siblings ?x ?y)&#13;
    (female ?x)&#13;
    (test (neq ?x ?y))&#13;
  =&gt;&#13;
    (printout t ?x " is sister to " ?y crlf))&#13;
&#13;
(defrule brother&#13;
    (siblings ?x ?y)&#13;
    (male ?x)&#13;
    (test (neq ?x ?y))&#13;
  =&gt;&#13;
    (printout t ?x " is brother to " ?y crlf))</pre>&#13;
<p class="caption" id="ch06list7"><em>Listing 6-7: Rules capturing sibling relationships</em></p>&#13;
<p class="indent">The first rules capture the idea of siblings and the following two rules embody the ideas of sister and brother.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_179"/>For <span class="literal">x</span> to be the brother of Y, <span class="literal">x</span> must be male and <span class="literal">x</span> and <span class="literal">y</span> must be siblings. To be siblings, <span class="literal">x</span> and <span class="literal">y</span> must have a parent in common. The rules of <a href="ch06.xhtml#ch06list7">Listing 6-7</a> capture siblings and then assert that <span class="literal">x</span> and <span class="literal">y</span> are siblings. Once asserted, the <span class="literal">brother</span> and <span class="literal">sister</span> rules can fire because the new fact that <span class="literal">x</span> and <span class="literal">y</span> are siblings is now part of the fact list.</p>&#13;
<p class="indent">The LHS of the rules includes a <span class="literal">test</span> to make sure that <span class="literal">x</span> and <span class="literal">y</span> are not the same person, as we don’t normally think of ourselves as our own siblings.</p>&#13;
<p class="indent">There is no startup rule in <em>family.clp</em> like we had for <em>math.clp</em>. Instead, the fact list is initialized by <span class="literal">(reset)</span>, and <span class="literal">(run)</span> immediately begins using the fact list to satisfy the rules, place them on the agenda, and execute the RHS for all possible matches. Therefore, unlike Prolog, which gave us a result and waited patiently for us to request another or stop, CLIPS will run as long as it can match facts to rules and execute them.</p>&#13;
<p class="indent">If you load <em>family.clp</em> and execute <span class="literal">(reset)</span> and <span class="literal">(run)</span>, you should see a flurry of output—119 lines’ worth, to be exact. The output is all the possible relationships CLIPS was able to pull out of the initial set of facts. For example, the list begins with</p>&#13;
<pre>hephaestus is husband of aphrodite&#13;
aphrodite is wife of hephaestus&#13;
zeus is husband of hera      &#13;
hera is wife of zeus       &#13;
uranus is father of aphrodite&#13;
aphrodite is sister to cronus&#13;
cronus is brother to aphrodite&#13;
semele is mother of dionysus &#13;
zeus is father of dionysus         &#13;
dionysus is brother to artemis&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="noindent">giving us a mix of husbands, wives, fathers, sisters, and so on. It would be nice to organize this list in some way, that is, to programmatically capture the relationships by type instead of dumping line after line. Fortunately, CLIPS is a full-service programming language. One way we can apply some order to the output is to capture instances of different types so we can report them at will.</p>&#13;
<pre>(defglobal ?*brothers* = (create$))&#13;
(defglobal ?*sisters* = (create$))&#13;
&#13;
(defrule sister&#13;
    (siblings ?x ?y)&#13;
    (female ?x)&#13;
    (test (neq ?x ?y))&#13;
  =&gt;&#13;
    (bind ?msg (implode$ (create$ ?x is sister to ?y)))&#13;
    (bind ?*sisters* (create$ ?*sisters* ?msg)))<span epub:type="pagebreak" id="page_180"/>&#13;
&#13;
(defrule brother&#13;
    (siblings ?x ?y)&#13;
    (male ?x)&#13;
    (test (neq ?x ?y))&#13;
  =&gt;&#13;
    (bind ?msg (implode$ (create$ ?x is brother to ?y)))&#13;
    (bind ?*brothers* (create$ ?*brothers* ?msg)))&#13;
&#13;
(deffunction brothers ()&#13;
    (foreach ?bro ?*brothers*&#13;
        (printout t ?bro crlf)))&#13;
&#13;
(deffunction sisters ()&#13;
    (foreach ?sis ?*sisters*&#13;
        (printout t ?sis crlf)))</pre>&#13;
<p class="caption" id="ch06list8"><em>Listing 6-8: Storing relationship output</em></p>&#13;
<p class="indent">The file <em>family2.clp</em> stores brothers and sisters in global lists. Only brothers and sisters are considered in this case, but it would be straightforward to include other family relationships. The essential pieces of <em>family2.clp</em> are in <a href="ch06.xhtml#ch06list8">Listing 6-8</a>. The initial set of facts has been excluded from the listing, as has the rule <span class="literal">sibling</span>, which is unchanged from the version in <a href="ch06.xhtml#ch06list7">Listing 6-7</a>.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list8">Listing 6-8</a> begins with two new lines, instances of <span class="literal">defglobal</span>, which is CLIPS-speak for defining a global variable. CLIPS uses asterisks around the names of global variables, so we define two empty lists, the output of <span class="literal">create$</span> with no arguments, to hold brothers and sisters: <span class="literal">?*brothers*</span> and <span class="literal">?*sisters*</span>.</p>&#13;
<p class="indent">To accumulate information about brothers and sisters, we modify the <span class="literal">brother</span> and <span class="literal">sister</span> rules. The LHS of each rule remains the same, but the RHS consists of two calls to <span class="literal">bind</span>. The first uses <span class="literal">create$</span> to make a list of <span class="literal">?x</span>, the symbols <span class="literal">is</span>, <span class="literal">sister</span> or <span class="literal">brother</span>, <span class="literal">to</span>, and <span class="literal">?y</span>. This list is passed to <span class="literal">implode$</span>, which makes a string from a list. Therefore, the output of <span class="literal">implode$</span> is a string, such as <span class="literal">dionysus is brother to artemis</span>, that we store in <span class="literal">?msg</span>. The second <span class="literal">bind</span> again uses <span class="literal">create$</span> to append the new string to the end of the existing list. In this way, every discovery of a brother or sister relationship is stored in the corresponding string.</p>&#13;
<p class="indent">If we load <em>family2.clp</em> and call <span class="literal">(reset)</span> followed by <span class="literal">(run)</span>, we get no output. However, CLIPS did its job. To see this we need functions to print the lists. Enter the functions <span class="literal">brothers</span> and <span class="literal">sisters</span>. Neither function requires arguments and both use CLIPS’s <span class="literal">foreach</span> loop to iterate over the lists to print one element per line.</p>&#13;
<p class="indent">Give <em>family2.clp</em> a try. First load, reset, and run as usual, and then list the sisters. For example:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "family2.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
CLIPS&gt; <span class="codestrong1">(sisters)</span>&#13;
aphrodite is sister to cronus<span epub:type="pagebreak" id="page_181"/>&#13;
eris is sister to dionysus&#13;
artemis is sister to dionysus&#13;
artemis is sister to apollo&#13;
artemis is sister to hermes&#13;
artemis is sister to athena&#13;
artemis is sister to eris&#13;
artemis is sister to hephaestus&#13;
artemis is sister to ares&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="noindent">Calling <span class="literal">(brothers)</span> produces the other list. The <em>family2.clp</em> example shows how to combine procedural (imperative) programming with CLIPS’s rules engine. Now, let’s look at a factory simulation to see how rules can be ordered to fire in a specified sequence.</p>&#13;
<h4 class="h4" id="lev2sec52"><strong><em>At the Factory</em></strong></h4>&#13;
<p class="noindent">For this example, we’ll simulate the monitoring of a factory. The factory has pumps that must be turned on and then turned off three seconds later. Additionally, from time to time, an emergency must be serviced before turning on the pumps. Our simulation’s true purpose is to demonstrate <em>salience</em>, which determines the firing order for rules if multiple rules are on the agenda. Salience should be used with care, but it is sometimes necessary.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list9">Listing 6-9</a> shows us a few necessary utility functions.</p>&#13;
<pre>(defglobal ?*base* = (time))&#13;
(deffunction ftime ()&#13;
  (- (time) ?*base*))&#13;
&#13;
(deffunction rand ()&#13;
  (/ (mod (random) 1000000) 1000000))&#13;
&#13;
(deffunction pause (?delay)&#13;
  (bind ?start (time))&#13;
  (while (&lt; (time) (+ ?start ?delay)) do))</pre>&#13;
<p class="caption" id="ch06list9"><em>Listing 6-9: Some utility functions</em></p>&#13;
<p class="indent">The first line defines a global variable, <span class="literal">?*base*</span>, which holds the current epoch seconds value returned by <span class="literal">(time)</span>. It’s set when the program loads. We’re using it with the <span class="literal">ftime</span> function to return the number of seconds since the program was loaded.</p>&#13;
<p class="indent">CLIPS has a function called <span class="literal">(random)</span> to return a random integer, which is really the return value of the C <span class="literal">rand</span> function. To get a floating-point value in [0, 1), we take the remainder of this integer when divided by 1,000,000 and divide that by 1,000,000. This approach is adequate for our purposes.</p>&#13;
<p class="indent">The system pauses before monitoring the state of the factory, hence defining <span class="literal">(pause)</span>, which accepts the number of seconds and runs a <span class="literal">while</span> loop <span epub:type="pagebreak" id="page_182"/>waiting for the time to elapse. This is very CPU intensive, but, again, it is acceptable for our purposes.</p>&#13;
<p class="indent">The rules responding to events in the factory are in <a href="ch06.xhtml#ch06list10">Listing 6-10</a>.</p>&#13;
<pre>(defrule emergency "there is an emergency"&#13;
    (declare (salience 100))&#13;
    ?x &lt;- (emergency-alert)&#13;
  =&gt;&#13;
    (retract ?x)&#13;
    (printout t "  !!! emergency! !!!" crlf))&#13;
&#13;
(defrule pumps-on "turn the pumps on"&#13;
    (declare (salience 5))&#13;
    ?x &lt;- (pumps-on)&#13;
  =&gt;&#13;
    (retract ?x)&#13;
    (printout t "  pumps on (" (ftime) ")" crlf)&#13;
    (assert (pumps-off-time (+ (ftime) 3))))&#13;
&#13;
(defrule pumps-off "turn off the pumps"&#13;
    (declare (salience 5)) &#13;
    ?x &lt;- (pumps-off-time ?t) &#13;
  =&gt;  &#13;
    (if (&gt;= (ftime) ?t) then &#13;
      (retract ?x) &#13;
      (printout t "  pumps off (" (ftime) ")" crlf)&#13;
    else&#13;
      (refresh pumps-off)))</pre>&#13;
<p class="caption" id="ch06list10"><em>Listing 6-10: The factory rules</em></p>&#13;
<p class="indent">There are three rules: <span class="literal">emergency</span>, <span class="literal">pumps-on</span>, and <span class="literal">pumps-off</span>. As before, the rules have a LHS and a RHS. There is also a new statement, <span class="literal">declare</span>, which sets the <span class="literal">salience</span> to an integer, which must be in the range [–10,000, 10,000]. Higher salience rules fire before lower salience rules when multiple rules are on the agenda. The default salience value is 0.</p>&#13;
<p class="indent">The first rule in <a href="ch06.xhtml#ch06list10">Listing 6-10</a> uses a salience of <span class="literal">100</span>. This is the emergency rule, and we want to ensure it fires immediately after being placed on the agenda; therefore, we give it a salience larger than any other rule. The <span class="literal">pumps-on</span> and <span class="literal">pumps-off</span> rules each have a salience of <span class="literal">5</span>. Salience is for ordering execution on the agenda, and the numeric value has no other meaning. Therefore, the fact that <span class="literal">emergency</span> has a salience 20 times greater than that of the other rules doesn’t mean anything other than that it fires first.</p>&#13;
<p class="indent">The <span class="literal">emergency</span> rule does nothing more than inform the user that an emergency condition exists, that is, the fact <span class="literal">emergency-alert</span> has been asserted. Notice that the fact has been retracted. If not, the rule would not fire again when a new <span class="literal">emergency-alert</span> is placed on the facts list.</p>&#13;
<p class="indent">The <span class="literal">pumps-on</span> rule displays the pump start time and then asserts <span class="literal">pumps-off</span> <span class="literal">-time</span> as three seconds beyond the current time. The assertion fires <span class="literal">pumps-off</span>. <span epub:type="pagebreak" id="page_183"/>This rule uses <span class="literal">if</span> to check whether the current time is beyond the desired stop time. If it is, the <span class="literal">pumps-off-time</span> fact is retracted and the off message displayed. If the full three seconds has not yet elapsed, <span class="literal">refresh</span> is used to cause <span class="literal">pumps-off</span> to fire again even though it already matched the <span class="literal">pumps-off-time</span> fact. Using <span class="literal">refresh</span> eliminates the need to retract the <span class="literal">pumps-off-time</span> fact only to assert it again.</p>&#13;
<p class="indent">The main factory monitor loop is the rule <span class="literal">monitor</span> (see <a href="ch06.xhtml#ch06list11">Listing 6-11</a>).</p>&#13;
<pre>(defrule monitor "monitor the factory"&#13;
    (declare (salience 0))&#13;
    (monitor-loop)&#13;
  =&gt;&#13;
    (if (&lt; (rand) 0.2) then (assert (pumps-on)))&#13;
    (if (&lt; (rand) 0.05) then (assert (emergency-alert)))&#13;
    (pause 0.2)&#13;
    (refresh monitor))&#13;
&#13;
(deffacts initial&#13;
  (monitor-loop))</pre>&#13;
<p class="caption" id="ch06list11"><em>Listing 6-11: The <span class="codeitalic1">monitor</span> rule</em></p>&#13;
<p class="indent">The <span class="literal">monitor</span> rule uses a salience of <span class="literal">0</span>, which is the default value. Doing this means the pump and emergency rules will always fire before this rule. The idea is to monitor the factory until something worthwhile happens and then react to the situation before returning to monitor the factory.</p>&#13;
<p class="indent">This is a simulation, so “monitor the factory” means use <span class="literal">(rand)</span> to assert events with random probabilities. For any execution of <span class="literal">monitor</span>, there’s a 20 percent chance the pumps will be turned on. Likewise, there is a 5 percent chance an emergency alert will be issued. After a 0.2 second pause, the program refreshes the <span class="literal">monitor</span> rule to make it fire again. To prep the system, <span class="literal">deffacts</span> places <span class="literal">monitor-loop</span> on the facts list when <span class="literal">(reset)</span> is executed.</p>&#13;
<p class="indent">Now, let’s run the simulation and see what it tells us.</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "factory.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
  pumps on (2.55227184295654)&#13;
  pumps off (5.55229592323303)&#13;
  pumps on (5.95234894752502)&#13;
  pumps off (8.95237803459167)&#13;
  !!! emergency! !!!&#13;
  pumps on (10.152487039566)&#13;
  pumps off (13.1525239944458)&#13;
  pumps on (14.5526268482208)&#13;
  pumps off (17.5526599884033)&#13;
^\Quit (core dumped)</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_184"/>This run activated the pumps and, as desired, turned them off after three seconds. There was one emergency alert. The factory simulation has no end condition, so use CTRL-<span class="literal">\</span> to exit. This is the source of the <span class="literal">Quit</span> message in the listing above.</p>&#13;
<h4 class="h4" id="lev2sec53"><strong><em>An Iris Expert System</em></strong></h4>&#13;
<p class="noindent">In <a href="ch05.xhtml#ch05">Chapter 5</a>, we built a nearest neighbor classifier in SNOBOL. The nearest neighbor classifier is an example of machine learning, a statistical approach using training data to build a model that captures something essential about the data and allows for predictions when given new, unknown data.</p>&#13;
<p class="indent">An expert system attempts to encapsulate expert knowledge to capture enough about a particular domain to make informed decisions. This section uses “expert” knowledge of iris flowers to build a simple expert system. The result is a system that asks us questions about an unknown iris flower to decide what type of iris it is.</p>&#13;
<p class="indent">Unfortunately, I’m not an expert in iris flowers. But that isn’t too much of a limitation in this case, as we can cheat a bit. We’ll use machine learning to build a <em>decision tree</em> classifier for irises. A decision tree is a series of yes or no questions that ultimately lead from the tree’s root to a leaf, which identifies the flower. Translating a decision tree into a simple expert system is straightforward, so we’ll use the “expertise” captured by the decision tree to build the expert system. This isn’t all that different from a human interviewing an iris expert to extract essential knowledge then encoded in a series of questions.</p>&#13;
<p class="indent">Therefore, our plan of attack is as follows:</p>&#13;
<ol>&#13;
<li class="noindent">Use the iris training data to build a decision tree classifier.</li>&#13;
<li class="noindent">Use the associated test data to characterize the resulting tree’s  accuracy. Our expert system will use the same sequence of questions,  so we’ll get the same accuracy from CLIPS if we implement things  correctly.</li>&#13;
<li class="noindent">Translate the questions of the decision tree into a set of CLIPS rules.</li>&#13;
<li class="noindent">Test the system with the iris test dataset.</li>&#13;
</ol>&#13;
<p class="indent">First is the decision tree classifier. The code to train the classifier and output a tree representation is in the file <em>make_iris_tree.py</em>. You do not need to run it. The tree we’ll work with is in <em>iris_tree.png</em>. If you want to generate a new tree, perhaps as an exercise in doing the translation to CLIPS yourself, you’ll need to install scikit-learn (<em><a href="https://scikit-learn.org/">https://scikit-learn.org/</a></em>) and Matplotlib (<em><a href="https://matplotlib.org/">https://matplotlib.org/</a></em>). scikit-learn uses some randomization when building the tree; therefore, each run of <em>make_iris_tree.py</em> results in a slightly different level of performance. The particular tree we’re using here is 98 percent accurate on the iris test dataset (<em>iris_test_data.txt</em>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_185"/><a href="ch06.xhtml#ch06fig1">Figure 6-1</a> shows us the decision tree classifier.</p>&#13;
<div class="image"><img id="ch06fig1" src="Images/06fig01.jpg" alt="Image" width="591" height="798"/></div>&#13;
<p class="figcap"><em>Figure 6-1: The iris classifier decision tree</em></p>&#13;
<p class="indent">The root of the tree is at the top, following normal computer science convention for representing a tree data structure. Each box is a node of the tree. If the box isn’t a leaf, the first line of the box is a question asked of the user. If the answer to the question is “yes,” move to the next lower box on the left. If the answer is “no,” move to the lower box on the right. Answer enough questions and you’ll eventually get to a leaf. The class label given there identifies the flower: <em>I. setosa</em>, <em>I. versicolor</em>, or <em>I. virginica</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_186"/>All boxes have additional lines of text. The <em>Gini score</em> is a measure used to generate the decision tree. Samples is a vector of three elements, one for each of the three iris flower types. It shows the split by type at that node when using the training data. The class label is the most correct label to give the flower if one stops at that node. For the leaves, the class label matches a value vector with only one class, meaning the decision tree was able to successfully partition the training data with 100 percent accuracy.</p>&#13;
<p class="indent">How do we use the decision tree? Let’s walk through a test sample. The expert system will ask us about measurements made from an unknown iris flower. There are four measurements: sepal length, sepal width, petal length, and petal width, all in centimeters. See <a href="ch06.xhtml#ch06fig2">Figure 6-2</a> if you need a reminder of basic flower anatomy.</p>&#13;
<div class="image"><img id="ch06fig2" src="Images/06fig02.jpg" alt="Image" width="347" height="276"/></div>&#13;
<p class="figcap"><em>Figure 6-2: Basic flower anatomy</em></p>&#13;
<p class="indent">Our test case has the measurements</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba">sepal length</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba">6.8 cm</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">sepal width</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">2.8 cm</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">petal length</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">4.8 cm</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">petal width</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">1.4 cm</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">and is an instance of <em>I. versicolor</em> (class label 1). The path through the decision tree for this example is in <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>.</p>&#13;
<span epub:type="pagebreak" id="page_187"/>&#13;
<div class="image"><img id="ch06fig3" src="Images/06fig03.jpg" alt="Image" width="590" height="797"/></div>&#13;
<p class="figcap"><em>Figure 6-3: A path through the decision tree</em></p>&#13;
<p class="indent">We can place the questions asked at each node of the decision tree into <a href="ch06.xhtml#ch06tab1">Table 6-1</a>.<span epub:type="pagebreak" id="page_188"/></p>&#13;
<p class="tabcap" id="ch06tab1"><strong>Table 6-1:</strong> The Questions and Responses for the Iris Expert System</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:45%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Question</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Text</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Yes</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>No</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q1</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Is petal width ≤ 0.8?</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">setosa</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q2</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Is petal length ≤ 4.75?</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q3</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q3</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Is petal width ≤ 1.65?</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">versicolor</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">virginica</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q4</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Is petal width ≤ 1.75?</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q5</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q6</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q5</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Is petal length ≤ 5.05?</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">versicolor</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q7</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q6</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Is petal length ≤ 4.85?</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Q8</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">virginica</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Q7</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Is sepal length ≤ 6.05?</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">versicolor</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">virginica</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Q8</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Is sepal length ≤ 5.95?</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">versicolor</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">virginica</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Each row of the table is a question. If the answer to a question is yes, we move to the indicated question or, if we now know the type, return the label. Notice that if the petal width is ≤ 0.8, the flower is an instance of <em>I. setosa</em> and there is no need to ask any further questions. This means of the three classes in the dataset, one is easily distinguished from the other two, but the remaining two need more work to tell apart. With the table, we now have what we need to implement the expert system. We begin with Q1, as that is the root of the tree, and move to other questions or endpoints based on the user’s response to each question.</p>&#13;
<p class="indent">The full expert system is in <em>irises.clp</em>. We’ll work through the code in sections beginning with the initial facts and helper rules (see <a href="ch06.xhtml#ch06list12">Listing 6-12</a>).</p>&#13;
<pre>(deffacts initial-facts ""&#13;
  (question "Is petal width &lt;= 0.80?")&#13;
  (state 1)&#13;
  (startup))&#13;
&#13;
(defrule start "start the program"&#13;
  ?r &lt;- (startup)&#13;
  =&gt;&#13;
  (printout t crlf)&#13;
  (printout t "Iris classifier.  Please respond 'y' or 'n' to each question." crlf)&#13;
  (printout t crlf)&#13;
  (retract ?r))&#13;
&#13;
(defrule ask-question "ask the user a question"&#13;
  ?p &lt;- (question ?q)&#13;
  =&gt;&#13;
  (retract ?p)&#13;
  (printout t ?q " ")&#13;
  (bind ?resp (readline))&#13;
  (assert (response ?resp)))&#13;
&#13;
<span epub:type="pagebreak" id="page_189"/>(defrule output-result "we have a label"&#13;
  (label ?label)&#13;
  =&gt;&#13;
  (printout t crlf "The sample is an instance of ")&#13;
  (printout t ?label crlf crlf)&#13;
  (halt))</pre>&#13;
<p class="caption" id="ch06list12"><em>Listing 6-12: Facts and helper rules</em></p>&#13;
<p class="indent">The program begins with the <span class="literal">start</span> rule, which fires because <span class="literal">initial-facts</span> places it on the facts list when <span class="literal">(reset)</span> is run. It also defines a <span class="literal">state</span> fact, set to <span class="literal">1</span> for question Q1, and the text of the question itself. When <span class="literal">startup</span> fires, it prints instructions for the user and retracts itself. The presence of the <span class="literal">question</span> rule fires <span class="literal">ask-question</span>, which displays the question text and asserts the user’s response: <span class="literal">y</span> or <span class="literal">n</span>. A full system would, naturally, validate the user’s input. Rule <span class="literal">output-result</span> reports when we have a valid label and halts.</p>&#13;
<p class="indent">Asserting a <span class="literal">response</span> fact causes a question rule to fire. There are 16 of them, two each for Q1 through Q8 in <a href="ch06.xhtml#ch06tab1">Table 6-1</a>, one each for a yes or no response. Let’s look at the first pair of rules. You should review <em>irises.clp</em> yourself to see the entire program.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list13">Listing 6-13</a> shows us the first two rules for Q1, that is, the first row of <a href="ch06.xhtml#ch06tab1">Table 6-1</a>.</p>&#13;
<pre>(defrule q1-yes ""&#13;
  ?q &lt;- (state 1)&#13;
  ?r &lt;- (response "y")&#13;
  =&gt;&#13;
  (retract ?q ?r)&#13;
  (assert (label "setosa (0)")))&#13;
&#13;
(defrule q1-no ""&#13;
  ?q &lt;- (state 1)&#13;
  ?r &lt;- (response "n")&#13;
  =&gt;&#13;
  (retract ?q ?r)&#13;
  (assert (state 2))&#13;
  (assert (question "Is petal length &lt;= 4.75?")))</pre>&#13;
<p class="caption" id="ch06list13"><em>Listing 6-13: Some iris rules</em></p>&#13;
<p class="indent">As you can see, if the user’s response to Q1 is “yes,” rule <span class="literal">q1-yes</span> fires. <a href="ch06.xhtml#ch06tab1">Table 6-1</a> says a “yes” response to Q1 means the sample is an instance of <em>I. setosa</em>. Therefore, rule <span class="literal">q1-yes</span> asserts <span class="literal">label</span>, causing <span class="literal">output-result</span> from <a href="ch06.xhtml#ch06list12">Listing 6-12</a> to fire, tell us the iris type, and halt.</p>&#13;
<p class="indent">If the user’s response to Q1 is “no,” rule <span class="literal">q1-no</span> fires instead. <a href="ch06.xhtml#ch06tab1">Table 6-1</a> says to move to Q2 in this case, so the RHS of <span class="literal">q1-no</span> asserts <span class="literal">state 2</span> and the proper <span class="literal">question</span>, which <span class="literal">ask-question</span> in <a href="ch06.xhtml#ch06list12">Listing 6-12</a> dutifully asks.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_190"/>As the user answers questions, CLIPS moves from state to state until it reaches a rule with a known label. For example, if we run <em>irises.clp</em> for the test sample above we get the output shown in <a href="ch06.xhtml#ch06list14">Listing 6-14</a>:</p>&#13;
<pre>CLIPS&gt; <span class="codestrong1">(load "irises.clp")</span>&#13;
CLIPS&gt; <span class="codestrong1">(reset)</span>&#13;
CLIPS&gt; <span class="codestrong1">(run)</span>&#13;
&#13;
Iris classifier.  Please respond 'y' or 'n' to each question.&#13;
&#13;
Is petal width &lt;= 0.80? <span class="codestrong1">n</span>&#13;
Is petal length &lt;= 4.75? <span class="codestrong1">n</span>&#13;
Is petal width &lt;= 1.75? <span class="codestrong1">y</span>&#13;
Is petal length &lt;= 5.05? <span class="codestrong1">y</span>&#13;
&#13;
The sample is an instance of versicolor (1)</pre>&#13;
<p class="caption" id="ch06list14"><em>Listing 6-14: Using the expert system</em></p>&#13;
<p class="indent">If you are patient enough, you can work through every example in the <em>iris_test_data.txt</em> file in the <em>SNOBOL/datasets</em> directory. Matching the reported labels against the known labels in <em>iris_test_labels.txt</em> will tell you that the iris expert system is 98 percent accurate, meaning it makes one mistake out of every 50 test samples. The SNOBOL nearest neighbor classifier is 96 percent accurate on the same test data using the same training data. Therefore, in this case, the expert system is quite good. Of course, our “expert knowledge” of iris flowers came from the training data in the first place, so we didn’t implement a true expert system. We merely encapsulated knowledge synthesized from a statistical model. I’ll have more to say about this in the discussion up next.</p>&#13;
<p class="indent">The examples in this section give us a good feel for CLIPS, but, as stated earlier, CLIPS is much more than we can explore here. For example, we ignored CLIPS’s object-oriented abilities and the fact that CLIPS is designed to play nicely when integrated into other applications. A quick review of Google Scholar shows that academic papers referencing CLIPS are still being written, to say nothing of industrial uses for CLIPS that are likely never discussed in print.</p>&#13;
<h3 class="h3" id="lev1sec51"><strong>Discussion</strong></h3>&#13;
<p class="noindent">Expert systems are often considered “old-school” or even “failures,” but that isn’t fair. You won’t hear the term <em>expert system</em> too much these days, but they are alive and well under the term <em>business rule management system.</em> For example, DROOLS (<em><a href="https://www.drools.org/">https://www.drools.org/</a></em>) is an open source rules-based system in active development with a large user base and supporting documentation, including multiple books. As a general approach to artificial intelligence, expert systems are passé, replaced by the phenomenal success of deep learning and neural networks, which represent a connectionist view of cognition, not the computational view embodied by an expert system.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_191"/>Expert systems are rigid. Once coded, they are not easily modified. Additionally, the rules often contain gaps, missing elements, or paths that are not specified. If a rule-based system claims to cover a topic, how would we know we’ve tested all the corner cases and all the possible sets of inputs? It becomes difficult, perhaps exponentially difficult, as the rules become more complex and intertwined.</p>&#13;
<p class="indent">The iris expert system shown earlier used “knowledge” extracted from a machine learning model. What if, instead, we needed to extract the rules from an expert gardener? The expert certainly knows how to identify iris flowers, but how do we get that knowledge out of the expert’s head and into a set of rules for CLIPS? The process of mapping an expert’s knowledge to rules is known as <em>knowledge extraction</em>, and it is an Achilles’ heel of sorts for expert systems. The concept of an expert system is seductive, but the realization is difficult at best. To be sure, the iris expert won’t know that a petal width less than 0.8 cm means the flower is almost certainly <em>I. setosa</em>, even if able to identify that species with almost perfect precision. How is that then captured and coded? Careful interviewing, which is highly time consuming, to say nothing of potentially irritating to the interviewee, might generate more general rules, but none would be as specific as those extracted by the decision tree. For example, one rule asks in a particular circumstance if the petal length is less than 4.75 cm, versus less than 4.85 cm in another. I doubt any expert would consider a millimeter difference in petal length of any importance.</p>&#13;
<p class="indent">CLIPS’s use has faded as expert systems have fallen out of favor, but it is still maintained. There are likely many CLIPS-based expert systems out there, quietly running in the background and invisible to the general public.</p>&#13;
<p class="indent">Because of its multiparadigm nature, CLIPS is, of course, a Turing-complete language. Indeed, one could use CLIPS without any reference to the rules engine if desired. As a framework for an expert system, CLIPS has stood the test of time, so if you find yourself in a situation where an expert system seems appropriate, CLIPS is an option. For us, CLIPS is an atypical language, but one we should be familiar with and keep in our back pocket for those times when the appropriate situation arises. In terms of thinking about coding, CLIPS requires a different approach if we want to use the rules engine. That fact alone warrants including CLIPS in our explorations.</p>&#13;
<h3 class="h3" id="lev1sec52"><strong>Summary</strong></h3>&#13;
<p class="noindent">The CLIPS expert system was the focus of this chapter. We introduced the language and the concept of an expert system before exploring the basics: facts and rules. The bulk of the chapter saw us work through four examples illustrating the core of CLIPS. We learned how rules respond to facts by building an elementary calculator. We then re-explored family relationships to illustrate the difference between CLIPS and Prolog when generating inferences from collections of facts. The next example used a factory simulation to demonstrate arranging the firing sequence of rules by manipulating their salience. The final example was our most elaborate. We used a learned <span epub:type="pagebreak" id="page_192"/>decision tree to implement a collection of rules, those that might have been created by an expert to let us categorize different types of iris flowers by answering a few yes or no questions.</p>&#13;
<p class="indent">CLIPS is our last atypical programming language. We move now to the first of our esolangs and into the realm of what I’m calling “eccentric programming languages.” We’ll begin with ABC, a tiny language that will serve us well to introduce the weirdly wonderful world of esolangs.</p>&#13;
</div></body></html>