<html><head></head><body>
<h2 class="h2" id="ch03"><a id="page_21"/><strong>3</strong></h2>
<p class="h2a"><strong>SELECTORS</strong></p>
<div class="image"><img alt="Image" src="graphics/common-01.jpg"/></div>
<p class="noindentt">Selectors are the heart of CSS, and although the original CSS1 specification had only 5 or 6, CSS2 expanded the range with 12 more. CSS3 goes further still, roughly doubling the number of available selectors.</p>
<p class="indent">Selectors can be broadly separated into two categories. The first are those that act directly on elements defined in the document tree (<code>p</code> elements and <code>href</code> attributes, for example); this category contains <em>class</em>, <em>type</em>, and <em>attribute</em> selectors. For the sake of expediency, I’ll group these together under the banner of <em>DOM selectors</em>. The second category contains <em>pseudo-selectors</em> that act on elements or information that sits outside of the document tree (such as the first letter of a paragraph or the last child of a parent element). I cover pseudo-selectors in <a href="ch04.html#ch04">Chapter 4</a>—here I discuss DOM selectors.</p>
<p class="indent">CSS3 provides three new attribute selectors and one new <em>combinator</em>—that is, a selector that joins other selectors together, such as the child combinator (<code>&gt;</code>) from CSS2. These are defined in the Selectors Level 3 Module (<em><a href="http://www.w3.org/TR/css3-selectors/">http://www.w3.org/TR/css3-selectors/</a></em>), which is a <em>W3C Recommendation</em> and <a id="page_22"/>has widespread and stable implementation across browsers. Unless you specifically need to support IE6, you can start using these CSS3 selectors right away—many sites already do.</p>
<h3 class="h3" id="ch03leve1sec25"><strong>Attribute Selectors</strong></h3>
<p class="noindent">Attribute selectors were introduced in CSS2, and, as you may expect from the name, they allow you to specify rules that match elements based on their attributes—such as <code>href</code> or <code>title</code>—and the values of those attributes. The four selectors defined in CSS2 are:</p>
<pre class="programs">E[<span class="codeitalic">attr</span>] {…} /* Simple Attribute Selector */<br/>E[<span class="codeitalic">attr</span>='<span class="codeitalic">value</span>'] {…} /* Exact Attribute Value Selector */<br/>E[<span class="codeitalic">attr</span>~='<span class="codeitalic">value</span>'] {…} /* Partial Attribute Value Selector */<br/>E[<span class="codeitalic">attr</span>|='<span class="codeitalic">value</span>'] {…} /* Language Attribute Selector */</pre>
<p class="indent">Before moving on to the new selectors in CSS3, a quick recap of how each selector is utilized is worthwhile. For this, I’ll use the following markup, which is a (very short) contact list:</p>
<pre class="programs1">  &lt;ul&gt;<br/><span class="ent">➊</span> &lt;li&gt;&lt;a href="" lang="en-GB" rel="friend met"&gt;Peter&lt;/a&gt;&lt;/li&gt;<br/><span class="ent">➋</span> &lt;li&gt;&lt;a href="" lang="es-ES" rel="friend"&gt;Pedro&lt;/a&gt;&lt;/li&gt;<br/><span class="ent">➌</span> &lt;li&gt;&lt;a href="" lang="es-MX" rel="contact"&gt;Pancho&lt;/a&gt;&lt;/li&gt;<br/>  &lt;/ul&gt;</pre>
<p class="indent">The <em>Simple Attribute Selector</em> applies rules to elements that have the specified attribute defined, regardless of that attribute’s value. So given the following code:</p>
<pre class="programs">a[rel] { color: red; }</pre>
<p class="noindent">all of the <code>a</code> elements in my markup have a <code>rel</code> attribute, despite their having different values. In this case, therefore, all elements have the rule applied. If you want to be more specific, you can use the <em>Exact Attribute Value Selector</em> to define a value:</p>
<pre class="programs">a[rel='friend'] { color: red; }</pre>
<p class="indent">This code applies the rule only to the second <code>a</code> element in the markup (<span class="ent">➋</span>) because it selects only elements that have the exact value of <code>friend</code>. If you want to select both of the elements that have this value, you would use the <em>Partial Attribute Value Selector</em>:</p>
<pre class="programs">a[rel~='friend'] { color: red; }</pre>
<p class="indent">This code looks for the value of <code>friend</code> as part of a space-separated list (in most cases, a word) in any <code>rel</code> attribute and so applies the rule to elements <span class="ent">➊</span> and <span class="ent">➋</span>.</p>
<p class="indent"><a id="page_23"/>The final selector, the <em>Language Attribute Selector</em>, applies rules to elements that have an attribute matching the first argument in the selector, the value of which is the second argument in the selector followed immediately by a hyphen. If that sounds weirdly specific, it’s because this selector is really only intended to match language subcodes. The example markup has two Spanish names, each of which has a <code>lang</code> attribute beginning with <code>es-</code> although one is for Spain (<code>es-ES</code>) and the other is for Mexico (<code>es-MX</code>). To select both of these, you use this code:</p>
<pre class="programs">a[lang|='es'] { color: red; }</pre>
<p class="indent">This selects all elements with <code>lang</code> attributes whose value begins with <em>es</em>, regardless of their country values—that is, elements <span class="ent">➋</span> and <span class="ent">➌</span>. You could use this selector for any attributes with hyphen-separated values, but in the great majority of cases, those will be language codes.</p>
<p class="note"><strong><small>NOTE</small></strong><br/><em>The attribute names used here aren’t taken from the spec but from Eric Meyer’s book</em> CSS Pocket Reference <em>(O’Reilly Media, 2011).</em></p>
<h3 class="h3" id="ch03leve1sec26"><strong>New Attribute Selectors in CSS3</strong></h3>
<p class="noindent">You’ve seen how useful attribute selectors can be for finding exact or partial values, but what if you want even more flexibility? CSS3’s new selectors provide flexibility with the power to match substrings within an attribute value. This feature makes them especially great for applying rules to XML documents, which can often have more varied attribute values than HTML—though they are still quite useful for HTML developers as well.</p>
<h4 class="h4" id="ch03leve1sec27"><strong><em>Beginning Substring Attribute Value Selector</em></strong></h4>
<p class="noindent">The first new attribute selector—which, to avoid having to repeat that mouthful of a title, I’ll refer to as the <em>Beginning Selector</em>—finds elements whose chosen attribute begins with the string supplied to it as an argument. It uses the caret (<code>^</code>) symbol to modify the equals sign in the selector. Here’s the full syntax:</p>
<pre class="programs">E[<span class="codeitalic">attr</span>^='<span class="codeitalic">value</span>'] {…}</pre>
<p class="indent">This code looks for the supplied value at the beginning of the specified attribute. To illustrate, consider the following example markup, showing a list of three items, each of which contains a hyperlink with different (albeit similar) values for the <code>title</code> attribute:</p>
<pre class="programs">&lt;li&gt;&lt;a href="http://example.com/" title="Image Library"&gt;Example&lt;/a&gt;&lt;/li&gt;<br/>&lt;li&gt;&lt;a href="http://example.com/" title="Free Image Library"&gt;Example&lt;/a&gt;&lt;/li&gt;<br/>&lt;li&gt;&lt;a href="http://example.com/" title="Free Sound Library"&gt;Example&lt;/a&gt;&lt;/li&gt;</pre>
<p class="indent"><a id="page_24"/>I’ll apply this selector to the example markup:</p>
<pre class="programs">a[title^='image'] {…}</pre>
<p class="indent">In this case, the rule will be applied to the <code>a</code> element in the first list item because the <code>title</code> attribute string begins with the word <em>image</em>. The rule will not be applied to the <code>a</code> element in the second item, however, because, although its <code>title</code> attribute contains that string, it doesn’t begin with it. Nor will it be applied to the third string, as that string doesn’t match.</p>
<p class="note"><strong><small>NOTE</small></strong><br/><em>In HTML documents, the attribute selector value is case insensitive; for XML documents, however, the value is case sensitive.</em></p>
<p class="indent">The Beginning Selector is especially handy when you want to add visual information to hyperlinks. Here’s an example of a typical hyperlink to an external website:</p>
<pre class="programs">&lt;p&gt;This is a &lt;a href="http://example.com/"&gt;hyperlink&lt;/a&gt;.&lt;/p&gt;</pre>
<p class="indent">When you see this link in your browser, you can’t immediately tell whether it’s a link to a page on the same website or to an external URI. With this new attribute, however, you can pass the protocol (<em>http</em>) as the argument and add an icon to signify external links clearly:</p>
<pre class="programs">a[href^='http'] {<br/>    background: url('link.svg') no-repeat left center;<br/>    display: inline-block;<br/>    padding-left: 20px;<br/>}</pre>
<p class="indent">The result is shown in <a href="ch03.html#ch03fig1">Figure 3-1</a>.</p>
<div class="image"><img alt="Image" src="graphics/f03-01.jpg"/></div>
<p class="figuret"><a id="ch03fig1"/><em>Figure 3-1: An icon applied with the Beginning Selector</em></p>
<p class="indent">You can extend this to cover many other web protocols, some of which—<em>mailto</em>, <em>ftp</em>, and <em>https</em>—are shown in the following example and illustrated in <a href="ch03.html#ch03fig2">Figure 3-2</a>.</p>
<pre class="programs">a[href^='mailto'] { background-image: url('email.svg'); }<br/>a[href^='ftp'] { background-image: url('folder.svg'); }<br/>a[href^='https'] { background-image: url('lock.svg'); }</pre>
<div class="image"><a id="page_25"/><img alt="Image" src="graphics/f03-02.jpg"/></div>
<p class="figuret"><a id="ch03fig2"/><em>Figure 3-2: More examples of link icons with the Beginning Selector</em></p>
<p class="indent">Of course, the Beginning Selector also has many applications with attributes—such as <code>alt</code>, <code>cite</code>, and <code>title</code>—that accept more verbose values. And with the introduction of HTML5 and a whole range of new form elements and attributes, this selector and its soon-to-be-introduced siblings will become even more useful.</p>
<p class="indent">Consider, for example, the proposed <code>datetime</code> attribute, which accepts date-string values such as <code>2015-03-14</code>:</p>
<pre class="programs">&lt;time datetime="2015-03-14"&gt;March 14/time&gt;</pre>
<p class="indent">This means that you could use the Beginning Selector to apply styles to all elements meeting a supplied year value, which is quite handy for calendar or archiving applications:</p>
<pre class="programs">[datetime^='2015'] {…}</pre>
<h4 class="h4" id="ch03leve1sec28"><strong><em>Ending Substring Attribute Value Selector</em></strong></h4>
<p class="noindent">The <em>Ending Selector</em>, as I call it, works exactly like the Beginning Selector—just the other way around! That is, you use it to select attributes that <em>end</em> with the supplied value. The syntax differs by just one character: This time you use the dollar sign character (<code>$</code>) to modify the equal sign (<code>=</code>). Here’s the full syntax:</p>
<pre class="programs">E[<span class="codeitalic">attr</span>$='<span class="codeitalic">value</span>'] {…}</pre>
<p class="indent">Let’s look at the markup example from the previous section again, only this time apply the Ending Selector along with a new value:</p>
<pre class="programs">a[title$='library'] {…}</pre>
<p class="indent">This time the rule applies to all of the list items, as all of their <code>title</code> attribute values end with the string <code>library</code>.</p>
<p class="indent"><a id="page_26"/>Just like the Beginning Selector, you can use this selector to provide visual clarity to hyperlinks. But this time, instead of using the protocols at the beginning of the <code>href</code> attribute, you use the file types at the end. The code here shows rules for many popular file-type extensions:</p>
<pre class="programs">a[href$='.pdf'] { background-image: url('pdf.svg'); }<br/>a[href$='.doc'] { background-image: url('word.svg'); }<br/>a[href$='.rss'] { background-image: url('feed.svg'); }</pre>
<p class="indent"><a href="ch03.html#ch03fig3">Figure 3-3</a> shows examples of these rules applied.</p>
<div class="image"><img alt="Image" src="graphics/f03-03.jpg"/></div>
<p class="figuret"><a id="ch03fig3"/><em>Figure 3-3: Link icons applied with the Ending Selector</em></p>
<p class="indent">To achieve this effect using CSS2, you would have to apply set <code>class</code> values to the markup (<code>class="pdf"</code>, for example). The advantage of using the Ending Selector is that links to files can be detected automatically, without requiring you to apply a particular class. The disadvantage is that sometimes the file-type suffix is not at the end of the URI. But the next new selector helps get around that situation.</p>
<h4 class="h4" id="ch03leve1sec29"><strong><em>Arbitrary Substring Attribute Value Selector</em></strong></h4>
<p class="noindent">The final new attribute selector—which I call the <em>Arbitrary Selector</em>—works in the same way as the previous two, but it searches for the provided substring value <em>anywhere</em> inside the specified attribute string. This selector uses the asterisk (<code>*</code>) character. Here’s the new syntax:</p>
<pre class="programs">E[<span class="codeitalic">attr</span>*='<span class="codeitalic">value</span>'] {…}</pre>
<p class="indent">To demonstrate this selector, I’ll once again use the same markup that I used for the Beginning and Ending Selectors, only this time applying the Arbitrary Selector:</p>
<pre class="programs">a[title*='image'] {…}</pre>
<p class="indent">This rule is applied to the first and second list items because they both contain the text string <code>image</code> in their <code>title</code> attributes, even though the string appears in a different position in each example.</p>
<p class="indent"><a id="page_27"/>You may notice that this selector is somewhat similar to the Partial Attribute Value Selector from CSS2, and, indeed, in this example, they are interchangeable:</p>
<pre class="programs">a[title~='image'] {…}</pre>
<p class="indent">But the two selectors differ in a major way. In the example markup, with CSS3, you could match this element using just a substring:</p>
<pre class="programs">a[title*='im'] {…}</pre>
<p class="indent">The Partial Attribute Value Selector, however, requires that you enter a value that matches a full item in a space-separated list—in the example that would be either <code>free</code>, <code>image</code>, or <code>library</code>—so the <code>im</code> value would not be matched anywhere in the markup when using the CSS2 selector.</p>
<p class="indent">To continue with the examples provided for the first two attribute selectors, the Arbitrary Selector is also handy for adding file-type icons to URIs that have parameters at the end. Consider this fairly typical URI:</p>
<pre class="programs">&lt;a href="http://example.com/example.pdf?foo=bar"&gt;Example&lt;/a&gt;</pre>
<p class="indent">If you use the Ending Selector with a value of <code>pdf</code>, this element would not be recognized as a valid target, even though the file type is a PDF, because the value does not appear at the very end of the string. Providing the same value using the Arbitrary Selector does the trick, however; the <code>.pdf</code> substring value occurs within the specified attribute, so the icon is applied.</p>
<pre class="programs">a[href*='.pdf'] { background-image: url('pdf.svg'); }</pre>
<p class="indent">This selector is the most flexible of the three new attribute selectors as it can match substrings no matter where they appear within strings. But this extra flexibility means you must take more care when defining the values provided to the selector; simple combinations of letters are far more likely to occur when you can match anywhere within a string—which is the reason I used it to search for <code>.pdf</code> (the file extension) rather than <code>pdf</code> (the common abbreviation).</p>
<h4 class="h4" id="ch03leve1sec30"><strong><em>Multiple Attribute Selectors</em></strong></h4>
<p class="noindent">You can also chain multiple selectors together, which allows you to be really specific. Using multiple selectors, you can create rules to apply to attributes with values defined for the start, end, and anywhere in between. Imagine, for example, that you had links to two files with identical names but that were located in different folders:</p>
<pre class="programs">&lt;p&gt;&lt;a href="http://example.com/folder1/file.pdf"&gt;Example&lt;/a&gt;&lt;/p&gt;<br/>&lt;p&gt;&lt;a href="http://example.com/folder2/file.pdf"&gt;Example&lt;/a&gt;&lt;/p&gt;</pre>
<p class="indent"><a id="page_28"/>If you want to specify a rule to apply to only the second <code>p</code> element, you can chain some selectors together:</p>
<pre class="programs">a[href^='http://'][href*='/folder2/'][href$='.pdf'] {…}</pre>
<p class="indent">This code looks for <code>a</code> elements that have an <code>href</code> attribute beginning with <code>http://</code>, ending with <code>.pdf</code>, and with <code>/folder2/</code> contained within it. That’s specific!</p>
<h3 class="h3" id="ch03leve1sec31"><strong>The General Sibling Combinator</strong></h3>
<p class="noindent">Our final new DOM selector in CSS3 is a combinator, which you’ll recall means that it joins together more than one selector. The General Sibling Combinator is an extension of the Adjacent Sibling Combinator, which was introduced in CSS2. The syntaxes differ by just a single character:</p>
<pre class="programs"><span class="codeitalic">E</span> + <span class="codeitalic">F</span> {…} /* Adjacent Sibling Combinator */<br/><span class="codeitalic">E</span> ~ <span class="codeitalic">F</span> {…} /* General Sibling Combinator */</pre>
<p class="indent">The difference between the two is subtle but important: Adjacent Sibling selects any element (<code><em>F</em></code>) that is immediately preceded by element (<code><em>E</em></code>) on the same level of the document tree, but General Sibling selects any element (<code><em>F</em></code>) that is preceded by element (<code><em>E</em></code>) on the same level of the tree, regardless of whether it is immediately adjacent.</p>
<p class="indent">If that still sounds confusing, I’ll explain with an example. Let’s start with this CSS:</p>
<pre class="programs">h2 + p { font-weight: bolder; } /* Adjacent Sibling */<br/>h2 ~ p { font-style: italic; } /* General Sibling */</pre>
<p class="indent">And apply it to the following markup (truncated for clarity):</p>
<pre class="programs1"><span class="ent">➊</span> &lt;p&gt;Next we're going to discuss…&lt;/p&gt;<br/>  &lt;h2&gt;Ren&amp;eacute; Descartes&lt;/h2&gt;<br/><span class="ent">➋</span> &lt;p&gt;A highly influential French philosopher…&lt;/p&gt;<br/><span class="ent">➌</span> &lt;p&gt;He once famously declared:&lt;/p&gt;<br/>  &lt;blockquote&gt;<br/><span class="ent">➍</span>    &lt;p&gt;I think, therefore I am.&lt;/p&gt;<br/>  &lt;/blockquote&gt;<br/><span class="ent">➎</span> &lt;p&gt;However, this presumes the existence of the thinker.&lt;/p&gt;</pre>
<p class="indent">You can see the outcome in <a href="ch03.html#ch03fig4">Figure 3-4</a>. In the CSS, I’m using the Adjacent Sibling Combinator to bold the <code>p</code> element immediately adjacent to the <code>h2</code> element—that is, element <span class="ent">➋</span>. I’m also using the General Sibling Combinator to italicize all the <code>p</code> elements following the <code>h2</code> element, which applies to elements <span class="ent">➋</span>, <span class="ent">➌</span>, and <span class="ent">➎</span>.</p>
<div class="image"><a id="page_29"/><img alt="Image" src="graphics/f03-04.jpg"/></div>
<p class="figuret"><a id="ch03fig4"/><em>Figure 3-4: The difference between the Adjacent Sibling and General Sibling Combinators</em></p>
<p class="indent">The paragraph elements <span class="ent">➊</span> and <span class="ent">➍</span> have neither bold nor italic rules applied to them. Why not? Because element <span class="ent">➊</span> precedes the <code>h2</code>, and element <span class="ent">➍</span> is inside a <code>blockquote</code> and, therefore, on a different level (the level below) in the document tree, so neither is affected by the rules.</p>
<p class="indent">To achieve the desired effect of only italicizing the paragraphs on the same level as the <code>h2</code> element in CSS2, without the General Sibling Combinator, you would need to set all <code>p</code> elements to display in italic and then add an extra rule for the <code>p</code> inside the <code>blockquote</code> to overrule the inheritance:</p>
<pre class="programs">p { font-style: italic; }<br/>blockquote p { font-style: normal; }</pre>
<p class="indent">You probably won’t need to use the General Sibling Combinator often because much of its function overlaps with the basic DOM selectors. That said, you will still discover plenty of occasions where this combinator can save you a little bit of code (and time).</p>
<h3 class="h3" id="ch03leve1sec32"><strong>Summary</strong></h3>
<p class="noindent">Although attributes are a key feature of HTML4, most of them accept only a limited range of values, so many of them do not really require the attribute selectors I’ve introduced in this chapter. Aside from the <code>href</code> attribute, only a handful of attributes accept more verbose values (<code>alt</code>, <code>class</code>, <code>id</code>, <code>rel</code>, and <code>title</code> are the ones that spring to mind). But, as I mentioned before, HTML5 introduces attributes like <code>datetime</code> and <code>pubdate</code> that allow you to be more creative with selectors.</p>
<p class="indent">The new selectors introduced in this chapter, along with those from previous versions of CSS, provide ways to apply style rules based on defined <a id="page_30"/>elements and attributes. Of course, on occasion, styling elements and attributes only isn’t sufficient for your purposes. That’s when you need to add classes or nonsemantic elements to act as hooks to hang your styles on. In <a href="ch04.html#ch04">Chapter 4</a>, you’ll discover how CSS3 removes that need.</p>
<h3 class="h3" id="ch03leve1sec33"><strong>Selectors: Browser Support</strong></h3>
<table border="0" cellpadding="0" cellspacing="0" class="all" width="100%">
<tr>
<td class="table2" valign="top"><p class="table"/></td>
<td class="table2" valign="top"><p class="table"><strong>Chrome</strong></p></td>
<td class="table2" valign="top"><p class="table"><strong>Firefox</strong></p></td>
<td class="table2" valign="top"><p class="table"><strong>Safari</strong></p></td>
<td class="table2" valign="top"><p class="table"><strong>IE</strong></p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">New attribute selectors</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">General sibling combinator</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
</tr>
</table>
</body></html>