- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SELECTORS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selectors are the heart of CSS, and although the original CSS1 specification
    had only 5 or 6, CSS2 expanded the range with 12 more. CSS3 goes further still,
    roughly doubling the number of available selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Selectors can be broadly separated into two categories. The first are those
    that act directly on elements defined in the document tree (`p` elements and `href`
    attributes, for example); this category contains *class*, *type*, and *attribute*
    selectors. For the sake of expediency, I’ll group these together under the banner
    of *DOM selectors*. The second category contains *pseudo-selectors* that act on
    elements or information that sits outside of the document tree (such as the first
    letter of a paragraph or the last child of a parent element). I cover pseudo-selectors
    in [Chapter 4](ch04.html#ch04)—here I discuss DOM selectors.
  prefs: []
  type: TYPE_NORMAL
- en: CSS3 provides three new attribute selectors and one new *combinator*—that is,
    a selector that joins other selectors together, such as the child combinator (`>`)
    from CSS2\. These are defined in the Selectors Level 3 Module (*[http://www.w3.org/TR/css3-selectors/](http://www.w3.org/TR/css3-selectors/)*),
    which is a *W3C Recommendation* and has widespread and stable implementation across
    browsers. Unless you specifically need to support IE6, you can start using these
    CSS3 selectors right away—many sites already do.
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute Selectors**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Attribute selectors were introduced in CSS2, and, as you may expect from the
    name, they allow you to specify rules that match elements based on their attributes—such
    as `href` or `title`—and the values of those attributes. The four selectors defined
    in CSS2 are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Before moving on to the new selectors in CSS3, a quick recap of how each selector
    is utilized is worthwhile. For this, I’ll use the following markup, which is a
    (very short) contact list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The *Simple Attribute Selector* applies rules to elements that have the specified
    attribute defined, regardless of that attribute’s value. So given the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'all of the `a` elements in my markup have a `rel` attribute, despite their
    having different values. In this case, therefore, all elements have the rule applied.
    If you want to be more specific, you can use the *Exact Attribute Value Selector*
    to define a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code applies the rule only to the second `a` element in the markup (➋)
    because it selects only elements that have the exact value of `friend`. If you
    want to select both of the elements that have this value, you would use the *Partial
    Attribute Value Selector*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code looks for the value of `friend` as part of a space-separated list
    (in most cases, a word) in any `rel` attribute and so applies the rule to elements
    ➊ and ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final selector, the *Language Attribute Selector*, applies rules to elements
    that have an attribute matching the first argument in the selector, the value
    of which is the second argument in the selector followed immediately by a hyphen.
    If that sounds weirdly specific, it’s because this selector is really only intended
    to match language subcodes. The example markup has two Spanish names, each of
    which has a `lang` attribute beginning with `es-` although one is for Spain (`es-ES`)
    and the other is for Mexico (`es-MX`). To select both of these, you use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This selects all elements with `lang` attributes whose value begins with *es*,
    regardless of their country values—that is, elements ➋ and ➌. You could use this
    selector for any attributes with hyphen-separated values, but in the great majority
    of cases, those will be language codes.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The attribute names used here aren’t taken from the spec but from Eric Meyer’s
    book* CSS Pocket Reference *(O’Reilly Media, 2011).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Attribute Selectors in CSS3**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve seen how useful attribute selectors can be for finding exact or partial
    values, but what if you want even more flexibility? CSS3’s new selectors provide
    flexibility with the power to match substrings within an attribute value. This
    feature makes them especially great for applying rules to XML documents, which
    can often have more varied attribute values than HTML—though they are still quite
    useful for HTML developers as well.
  prefs: []
  type: TYPE_NORMAL
- en: '***Beginning Substring Attribute Value Selector***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first new attribute selector—which, to avoid having to repeat that mouthful
    of a title, I’ll refer to as the *Beginning Selector*—finds elements whose chosen
    attribute begins with the string supplied to it as an argument. It uses the caret
    (`^`) symbol to modify the equals sign in the selector. Here’s the full syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code looks for the supplied value at the beginning of the specified attribute.
    To illustrate, consider the following example markup, showing a list of three
    items, each of which contains a hyperlink with different (albeit similar) values
    for the `title` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ll apply this selector to the example markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the rule will be applied to the `a` element in the first list
    item because the `title` attribute string begins with the word *image*. The rule
    will not be applied to the `a` element in the second item, however, because, although
    its `title` attribute contains that string, it doesn’t begin with it. Nor will
    it be applied to the third string, as that string doesn’t match.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In HTML documents, the attribute selector value is case insensitive; for XML
    documents, however, the value is case sensitive.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Beginning Selector is especially handy when you want to add visual information
    to hyperlinks. Here’s an example of a typical hyperlink to an external website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you see this link in your browser, you can’t immediately tell whether
    it’s a link to a page on the same website or to an external URI. With this new
    attribute, however, you can pass the protocol (*http*) as the argument and add
    an icon to signify external links clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The result is shown in [Figure 3-1](ch03.html#ch03fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f03-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: An icon applied with the Beginning Selector*'
  prefs: []
  type: TYPE_NORMAL
- en: You can extend this to cover many other web protocols, some of which—*mailto*,
    *ftp*, and *https*—are shown in the following example and illustrated in [Figure
    3-2](ch03.html#ch03fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](graphics/f03-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: More examples of link icons with the Beginning Selector*'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the Beginning Selector also has many applications with attributes—such
    as `alt`, `cite`, and `title`—that accept more verbose values. And with the introduction
    of HTML5 and a whole range of new form elements and attributes, this selector
    and its soon-to-be-introduced siblings will become even more useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for example, the proposed `datetime` attribute, which accepts date-string
    values such as `2015-03-14`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that you could use the Beginning Selector to apply styles to all
    elements meeting a supplied year value, which is quite handy for calendar or archiving
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '***Ending Substring Attribute Value Selector***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *Ending Selector*, as I call it, works exactly like the Beginning Selector—just
    the other way around! That is, you use it to select attributes that *end* with
    the supplied value. The syntax differs by just one character: This time you use
    the dollar sign character (`$`) to modify the equal sign (`=`). Here’s the full
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the markup example from the previous section again, only this
    time apply the Ending Selector along with a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This time the rule applies to all of the list items, as all of their `title`
    attribute values end with the string `library`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the Beginning Selector, you can use this selector to provide visual
    clarity to hyperlinks. But this time, instead of using the protocols at the beginning
    of the `href` attribute, you use the file types at the end. The code here shows
    rules for many popular file-type extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 3-3](ch03.html#ch03fig3) shows examples of these rules applied.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f03-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: Link icons applied with the Ending Selector*'
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this effect using CSS2, you would have to apply set `class` values
    to the markup (`class="pdf"`, for example). The advantage of using the Ending
    Selector is that links to files can be detected automatically, without requiring
    you to apply a particular class. The disadvantage is that sometimes the file-type
    suffix is not at the end of the URI. But the next new selector helps get around
    that situation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Arbitrary Substring Attribute Value Selector***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The final new attribute selector—which I call the *Arbitrary Selector*—works
    in the same way as the previous two, but it searches for the provided substring
    value *anywhere* inside the specified attribute string. This selector uses the
    asterisk (`*`) character. Here’s the new syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate this selector, I’ll once again use the same markup that I used
    for the Beginning and Ending Selectors, only this time applying the Arbitrary
    Selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This rule is applied to the first and second list items because they both contain
    the text string `image` in their `title` attributes, even though the string appears
    in a different position in each example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice that this selector is somewhat similar to the Partial Attribute
    Value Selector from CSS2, and, indeed, in this example, they are interchangeable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'But the two selectors differ in a major way. In the example markup, with CSS3,
    you could match this element using just a substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The Partial Attribute Value Selector, however, requires that you enter a value
    that matches a full item in a space-separated list—in the example that would be
    either `free`, `image`, or `library`—so the `im` value would not be matched anywhere
    in the markup when using the CSS2 selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue with the examples provided for the first two attribute selectors,
    the Arbitrary Selector is also handy for adding file-type icons to URIs that have
    parameters at the end. Consider this fairly typical URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you use the Ending Selector with a value of `pdf`, this element would not
    be recognized as a valid target, even though the file type is a PDF, because the
    value does not appear at the very end of the string. Providing the same value
    using the Arbitrary Selector does the trick, however; the `.pdf` substring value
    occurs within the specified attribute, so the icon is applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This selector is the most flexible of the three new attribute selectors as it
    can match substrings no matter where they appear within strings. But this extra
    flexibility means you must take more care when defining the values provided to
    the selector; simple combinations of letters are far more likely to occur when
    you can match anywhere within a string—which is the reason I used it to search
    for `.pdf` (the file extension) rather than `pdf` (the common abbreviation).
  prefs: []
  type: TYPE_NORMAL
- en: '***Multiple Attribute Selectors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also chain multiple selectors together, which allows you to be really
    specific. Using multiple selectors, you can create rules to apply to attributes
    with values defined for the start, end, and anywhere in between. Imagine, for
    example, that you had links to two files with identical names but that were located
    in different folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to specify a rule to apply to only the second `p` element, you
    can chain some selectors together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code looks for `a` elements that have an `href` attribute beginning with
    `http://`, ending with `.pdf`, and with `/folder2/` contained within it. That’s
    specific!
  prefs: []
  type: TYPE_NORMAL
- en: '**The General Sibling Combinator**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our final new DOM selector in CSS3 is a combinator, which you’ll recall means
    that it joins together more than one selector. The General Sibling Combinator
    is an extension of the Adjacent Sibling Combinator, which was introduced in CSS2\.
    The syntaxes differ by just a single character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between the two is subtle but important: Adjacent Sibling selects
    any element (`*F*`) that is immediately preceded by element (`*E*`) on the same
    level of the document tree, but General Sibling selects any element (`*F*`) that
    is preceded by element (`*E*`) on the same level of the tree, regardless of whether
    it is immediately adjacent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If that still sounds confusing, I’ll explain with an example. Let’s start with
    this CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And apply it to the following markup (truncated for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can see the outcome in [Figure 3-4](ch03.html#ch03fig4). In the CSS, I’m
    using the Adjacent Sibling Combinator to bold the `p` element immediately adjacent
    to the `h2` element—that is, element ➋. I’m also using the General Sibling Combinator
    to italicize all the `p` elements following the `h2` element, which applies to
    elements ➋, ➌, and ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f03-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: The difference between the Adjacent Sibling and General Sibling
    Combinators*'
  prefs: []
  type: TYPE_NORMAL
- en: The paragraph elements ➊ and ➍ have neither bold nor italic rules applied to
    them. Why not? Because element ➊ precedes the `h2`, and element ➍ is inside a
    `blockquote` and, therefore, on a different level (the level below) in the document
    tree, so neither is affected by the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the desired effect of only italicizing the paragraphs on the same
    level as the `h2` element in CSS2, without the General Sibling Combinator, you
    would need to set all `p` elements to display in italic and then add an extra
    rule for the `p` inside the `blockquote` to overrule the inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You probably won’t need to use the General Sibling Combinator often because
    much of its function overlaps with the basic DOM selectors. That said, you will
    still discover plenty of occasions where this combinator can save you a little
    bit of code (and time).
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although attributes are a key feature of HTML4, most of them accept only a limited
    range of values, so many of them do not really require the attribute selectors
    I’ve introduced in this chapter. Aside from the `href` attribute, only a handful
    of attributes accept more verbose values (`alt`, `class`, `id`, `rel`, and `title`
    are the ones that spring to mind). But, as I mentioned before, HTML5 introduces
    attributes like `datetime` and `pubdate` that allow you to be more creative with
    selectors.
  prefs: []
  type: TYPE_NORMAL
- en: The new selectors introduced in this chapter, along with those from previous
    versions of CSS, provide ways to apply style rules based on defined elements and
    attributes. Of course, on occasion, styling elements and attributes only isn’t
    sufficient for your purposes. That’s when you need to add classes or nonsemantic
    elements to act as hooks to hang your styles on. In [Chapter 4](ch04.html#ch04),
    you’ll discover how CSS3 removes that need.
  prefs: []
  type: TYPE_NORMAL
- en: '**Selectors: Browser Support**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
  prefs: []
  type: TYPE_TB
- en: '| New attribute selectors | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| General sibling combinator | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
