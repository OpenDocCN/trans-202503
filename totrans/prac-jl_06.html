<html><head></head><body>
<h2 class="h" id="ch05"><span epub:type="pagebreak" id="page_123" class="calibre1"/><strong class="calibre2"><span class="big">5</span><br class="calibre3"/>COLLECTIONS</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">I don’t want to belong to any club that would accept me as one of its members.</em></p>
<p class="center1">—Attributed to Groucho Marx</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">A <em class="calibre11">collection</em> is a data structure that functions as a container. The values that it holds are its <em class="calibre11">elements</em>. Julia’s collections are distinguished from each other by what they can contain, whether or not they are mutable, how their elements are accessed, whether their contents are ordered, and several other characteristics.</p>
<p class="indent">We’ve already worked with arrays, strings, and other kinds of Julia containers. In this chapter, we’ll learn more about those collections and meet some new ones.</p>
<h3 class="h2" id="ch05lev1"><strong class="calibre2">Controlling Loop Execution</strong></h3>
<p class="noindent">There is an intimate relationship between loops and collections in Julia. The <code>for</code> loop, for example, depends on a collection or an iterable object whose elements are visited in turn.</p>
<p class="indent">We already know how to write loops using <code>while</code> and <code>for</code> blocks. In this section, we’ll explore how to further control loop execution with the <code>break</code> <span epub:type="pagebreak" id="page_124"/>and <code>continue</code> statements, and how to write compact loops with <em class="calibre11">comprehensions</em>, a concise way to create collections.</p>
<h4 class="h3" id="ch05lev1sec1"><strong class="calibre2"><em class="calibre4">The break Statement</em></strong></h4>
<p class="noindent">Sometimes we need to end a loop based on some condition and prevent it from reaching its “normal” termination. This is the purpose of the <code>break</code> command, which terminates both <code>while</code> and <code>for</code> loops.</p>
<p class="indent">For example, the following loop repeatedly asks the user for a number and prints its square root:</p>
<pre class="calibre13">while true
    println("Enter a number, or 0 to quit.")
    x = readline()
    x = parse(Float64, x)
    if x ≤ 0
     <span class="ent">➊</span> break
    end
 <span class="ent">➋</span> println("The square root is ", sqrt(x))
end</pre>
<p class="noindent">The <code>while</code> condition is <code>true</code>, which never changes, so the loop would run forever were it not for the <code>break</code> statement <span class="ent">➊</span>, which terminates the loop if the user enters <code>0</code> (or a negative number). This is a common pattern when intending a loop to run forever until halted by a condition arising with the loop.</p>
<p class="indent">The <code>readline()</code> statement reads a line of input from the terminal, terminated when the user presses <small class="calibre5">ENTER</small>, and puts the result into a string variable. We need to interpret this string as a number, which is what the <code>parse()</code> function does for us. The first argument to <code>parse()</code> specifies what data type to convert the string to. The multi-argument version of the <code>println()</code> function concatenates its arguments, converting numbers to strings as needed <span class="ent">➋</span>.</p>
<p class="indent">The <code>break</code> statement also terminates <code>for</code> loops. In the following example, we loop through the numbers in a vector and stop if we get to one that’s a perfect square:</p>
<pre class="calibre13">n = [12, 53, 19, 64, 16, 8]

for x in n
    if round( √x ) == √x
        println("Found a perfect square in the list: ", x)
        break
    end
end</pre>
<p class="indent">When this is run, it prints this:</p>
<pre class="calibre13">Found a perfect square in the list: 64</pre>
<p class="indent">A number is a perfect square if its square root is an integer. The code tests for that by comparing the number’s square root with the same quantity <span epub:type="pagebreak" id="page_125"/>rounded by the <code>round()</code> function. Since <code>round()</code> rounds a number to the nearest integer, the two will have the same value if the number is already an integer. The <code>break</code> statement terminates the loop when the first perfect square is found, so we never hear about 16.</p>
<h4 class="h3" id="ch05lev1sec2"><strong class="calibre2"><em class="calibre4">The continue Statement</em></strong></h4>
<p class="noindent">The <code>continue</code> statement skips further processing in the current loop iteration and proceeds to the next one. This program prints out the first 100 prime numbers (we’ll skip the output):</p>
<pre class="calibre13">for n in 1:100
    possibly_prime = true
    x = 2
    while x ≤ √n
     <span class="ent">➊</span> if n % x == 0
            possibly_prime = false
            break
        end
        x += 1
    end
    if !possibly_prime
     <span class="ent">➋</span> continue
    else
        println(n)
    end
end</pre>
<p class="noindent">The program tests the first 100 integers by checking for integer divisors up to the square root of the integer. If <em class="calibre11">x</em> is a divisor of <em class="calibre11">n</em>, there is no remainder when we calculate <em class="calibre11">n</em>/<em class="calibre11">x</em>; this is what <code>n % x == 0</code> checks for <span class="ent">➊</span>. If we find a divisor, <code>n</code> is not prime, so we set a flag indicating that and <code>break</code> out of the <code>while</code> loop over <code>x</code>. In the outer <code>for</code> loop, we want to <code>continue</code> <span class="ent">➋</span> to the next <code>n</code> if the current one is not prime, but print it if it is.</p>
<h3 class="h2" id="ch05lev2"><strong class="calibre2">Comprehensions and Generators</strong></h3>
<p class="noindent">We often can write <code>for</code> loops that create arrays more concisely as <em class="calibre11">array comprehensions</em>. As a simple example, suppose we wanted a <code>Vector</code> containing the first five perfect squares. We can construct this with a <code>for</code> loop, as in the following REPL session listing, but first we have to initialize an empty <code>Vector</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">xs = [];</span>

julia&gt; <span class="codestrong">for x in 1:5</span>
           <span class="codestrong">push!(xs, x^2)</span>
       <span class="codestrong">end</span>

julia&gt; <span class="codestrong">xs</span>
5-element Vector{Any}:
  1
  4
  9
 16
 25</pre>
<p class="indent"><span epub:type="pagebreak" id="page_126"/>We can accomplish the same thing with an array comprehension:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">xs = [x^2 for x in 1:5]</span>
5-element Vector{Int64}:
  1
  4
  9
 16
 25</pre>
<p class="noindent">We don’t need to initialize the <code>xs</code> vector, as the comprehension creates and populates it in one step. The types of the results in these examples are different, a subject that we’ll examine in <a href="ch08.xhtml" class="calibre10">Chapter 8</a>.</p>
<p class="indent">Array comprehensions typically contain two main parts, separated by the keyword <code>for</code>. The first part is an expression involving a dummy variable, in this case <code>x</code>. The second part, beginning with <code>for</code>, has the same form as the first line of the familiar <code>for</code> loop and uses the dummy variable from the first part. The first part becomes the body of the implied loop, adding a new element to the resulting array at each iteration.</p>
<p class="indent">The array that the comprehension creates will have the same shape as the container in its second part. Consider the following:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[2x for x in [1 2</span>
                     <span class="codestrong">3 4]]</span>
2×2 Matrix{Int64}:
 2  4
 6  8</pre>
<p class="noindent">Here, since the container iterates over a 2×2 matrix, that is the shape of the result as well.</p>
<p class="indent">An array comprehension can contain any number of implied loops. The shape of the result depends on whether the loops are separated by <code>for</code> or by a comma. The following examples illustrate the two possibilities:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[x * y for x in 1:3 for y in 1:3]</span>
9-element Vector{Int64}:
 1
 2
 3
 2
 4
 6
 3
 6
 9

julia&gt; <span class="codestrong">[x * y for x in 1:3, y in 1:3]</span>
3×3 Matrix{Int64}:
 1  2  3
 2  4  6
 3  6  9</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_127"/>In the first case, the result is a <code>Vector</code>, as we might expect from two nested <code>for</code> loops. The second case, using a comma to separate the implied loops, produces a <code>Matrix</code>. We can add more comma-separated loop clauses to extend this to any number of dimensions.</p>
<p class="indent">Consider the following example that determines which even numbers in the multiplication table are divisible by 7:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[x * y for x in 1:9, y in 1:9</span>
       <span class="codestrong">if x * y % 2 == 0 &amp;&amp;</span>
       <span class="codestrong">x * y % 7 == 0] |&gt; unique</span>
4-element Vector{Int64}:
 14
 28
 42
 56</pre>
<p class="noindent">An <code>if</code> statement at the end of a comprehension filters the results; the final result of the comprehension is a <code>Vector</code>. This example depends on the order of operations to avoid unnecessary parentheses: multiplication comes before (binds more tightly) than the modulus operator <code>%</code>. We pass the result of the comprehension to the <code>unique()</code> function, which removes duplicate entries from a collection.</p>
<p class="indent">A <em class="calibre11">generator expression</em> has the same form as an array comprehension, but without the enclosing square brackets. It creates an iterator, rather than a populated array. We can loop, or iterate, over this object to use its members one at a time, but it occupies almost no memory. In this way it should recall range expressions and their relationship to vectors.</p>
<p class="indent">In practice, we sometimes need to enclose the generator expression in parentheses to avoid ambiguity, as with any other expression. This is the case in the following example, where we create a generator version of our multiplication table:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">multiplication_generator = (x * y for x in 1:9, y in 1:9)</span></pre>
<p class="noindent">We need the parentheses because of the double <code>for</code> loop. Julia will not recognize this as a generator expression without them.</p>
<p class="indent"><span epub:type="pagebreak" id="page_128"/>Now we can extract, as before, the even numbers in the table that are divisible by 7:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[n for n in multiplication_generator</span>
       <span class="codestrong">if n % 2 == 0 &amp;&amp; n % 7 == 0]</span>
       <span class="codestrong">|&gt; unique</span>
4-element Vector{Int64}:
 14
 28
 42
 56</pre>
<p class="noindent">If the table were large, rather than merely 9×9, using a generator rather than populating an array would provide significant memory savings. We can always use <code>collect()</code> to produce the realized table from the iterator.</p>
<p class="indent"><a id="more-ways-to-join-strings" class="calibre10"/></p>
<h3 class="h2" id="ch05lev3"><strong class="calibre2">More Ways to Join Strings</strong></h3>
<p class="noindent">A string in Julia is a collection. Its elements are characters. We first met the <code>String</code> type in “Strings and Characters” on <a href="ch02.xhtml#ch02lev4" class="calibre10">page 44</a>, and here we’ll explore the most important operations you can perform on strings.</p>
<p class="indent">We’ve seen how we can join strings using the <code>*</code> operator or using <code>join()</code> to form a string from a vector of strings. We can also use the <code>string()</code> function, which joins any number of literal strings and string-valued variables into a larger <code>String</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">comma_space = ", ";</span>

julia&gt; <span class="codestrong">string("Hello", comma_space, "François")</span>
"Hello, François"</pre>
<p class="noindent">Since <code>comma_space</code> is a string, the <code>string()</code> function simply glues it to the other strings we supplied. If it were some other type of object, such as a number, the call would still work if the object had a string representation. In that case, the function first converts it to a string and then performs the join.</p>
<p class="indent">The <code>repeat()</code> function joins a string to itself a specified number of times:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">repeat("ABC ", 5)</span>
"ABC ABC ABC ABC ABC "</pre>
<p class="noindent">In this example, the new string is formed from “ABC” repeated five times, as specified in the second argument.</p>
<p class="indent">We can also use this function to create arrays, as we’ll see in “The repeat() Function” on <a href="ch05.xhtml#ch05lev1sec10" class="calibre10">page 139</a>.</p>
<h3 class="h2" id="ch05lev4"><strong class="calibre2">Nonstandard String Literals</strong></h3>
<p class="noindent">A <em class="calibre11">string literal</em> is an expression such as <code>"abc"</code> that represents a <code>String</code> directly. Julia supports a variety of <em class="calibre11">nonstandard</em> string literals, represented by placing a keyword in front of the string literal with the prefix specifying what kind <span epub:type="pagebreak" id="page_129"/>of special-purpose string the expression represents. Such objects carry a significance beyond their existence as strings.</p>
<p class="indent">We’ve already met an example of one of these objects. In “LaTeX Titles and Label Positioning by Data” on <a href="ch04.xhtml#ch04lev1sec12" class="calibre10">page 103</a>, we described how to use LaTeX strings as graph labels. These are prefixed with an uppercase <code>L</code>, as in <code>L"e^{i</code>π<code>} + 1 = 0"</code>. When the graphing programs see an ordinary string used as a label, the string is printed on the graph verbatim, but if the label is a LaTeX string, the programs know to print its LaTeX-processed form. LaTeX strings are defined in the <code>LaTeXStrings</code> package. Some nonstandard string literals are defined in their own packages, which need to be imported before you can use them, while others are built in.</p>
<p class="indent">Under the hood, nonstandard string literals are implemented as macros (see “Macros” on <a href="ch06.xhtml#ch06lev4" class="calibre10">page 170</a>). The name of the macro is the tag of the string literal followed by <code>_str</code>. In other words, the name of the macro implementing LaTeX strings is <code>@L_str</code>. To see the documentation for a nonstandard string literal in the REPL, we enter either <code>?@L_str</code> or <code>?L""</code> (for LaTeX strings).</p>
<h4 class="h3" id="ch05lev1sec3"><strong class="calibre2"><em class="calibre4">Raw Strings</em></strong></h4>
<p class="noindent">One useful built-in nonstandard string literal is the <em class="calibre11">raw string</em>, written by prepending <code>raw</code>. Most keywords for nonstandard strings are single letters, but <code>raw</code> is an exception. Raw strings are used to represent certain character sequences literally, where in standard strings they would have an interpretation as control characters or something else. For example, ordinarily the sequence <code>\t</code> is converted into a <small class="calibre5">TAB</small> character when printing a string, but in a raw string it’s interpreted literally:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">print(raw"a\tb")</span>
a\tb
julia&gt; <span class="codestrong">print("a\tb")</span>
a       b</pre>
<p class="noindent">In the second print command, the non-escaped <small class="calibre5">TAB</small> character is rendered as a horizontal space.</p>
<p class="indent">Within raw strings, therefore, backslashes are interpreted literally, with one exception—they are still needed to escape double quotation marks:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">print("I said, \"No\".")</span>
I said, "No".
julia&gt; <span class="codestrong">print(raw"I said, \"No\".")</span>
I said, "No".</pre>
<p class="indent">If a backslash appears anywhere in a raw string aside from directly before a double quotation mark, it’s interpreted literally.</p>
<h4 class="h3" id="ch05lev1sec4"><strong class="calibre2"><em class="calibre4">Semantic Version Strings</em></strong></h4>
<p class="noindent">Versions of software releases are identified with tags such as v1.7.1. Different projects use different systems for version tags; one such system is called <span epub:type="pagebreak" id="page_130"/><em class="calibre11">semantic versioning</em>. The fields in the string refer to major and minor versions and, optionally, other versioning information. See “Further Reading” on <a href="ch05.xhtml#fur5" class="calibre10">page 151</a> for a link to the detailed specification.</p>
<p class="indent">Prepend a <code>v</code> to create a semantic version string. We can compare versions and extract the numerical value of fields, which are returned as hexadecimal numbers, indicated by a leading <code>0x</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">v"1.6.1" &lt; v"1.6.2"</span>
true

julia&gt; <span class="codestrong">version = v"1.7.2"</span>
v"1.7.2"

julia&gt; <span class="codestrong">version.major, version.minor, version.patch</span>
(0x00000001, 0x00000007, 0x00000002)</pre>
<p class="indent">The Julia project itself uses an extended version of this scheme for numbering language and package releases, so semantic version strings are built into the language.</p>
<h4 class="h3" id="ch05lev1sec5"><strong class="calibre2"><em class="calibre4">Byte Array Literals</em></strong></h4>
<p class="noindent">Prepending a string with <code>b</code> creates a <em class="calibre11">byte array literal</em>: a sequence of unsigned, 8-bit integers representing the sequence of characters in the string in UTF-8 encoding. As described in “Strings and Characters” on <a href="ch02.xhtml#ch02lev4" class="calibre10">page 44</a>, characters can take up one to four bytes. Here’s an example of turning a three-character string into a byte array:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">b"a2∑"</span>
4-element Base.CodeUnits{UInt8, String}:
 0x61
 0x32
 0xce
 0xa3</pre>
<p class="noindent">The characters <code>a</code> and <code>2</code> are each represented by a single byte, but the character <code>∑</code> occupies two bytes.</p>
<p class="indent">We can enter the uppercase sigma as a character in the REPL to learn more about it:</p>
<pre class="calibre13">julia&gt; '∑'
'∑': Unicode U+03A3 (category Lu: Letter, uppercase)</pre>
<p class="noindent">The response informs us that <code>03A3</code> is the Unicode <em class="calibre11">code point</em> for the character. The code point is a single, possibly large, hexadecimal integer that uniquely identifies the Unicode character.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">A Unicode character may not correspond to a single character when printed. Some of them combine with one or more neighboring characters to create accents or ligatures.</em><span epub:type="pagebreak" id="page_131"/></p>
</div>
<p class="indent">We can use code points directly in strings with the escape code <code>\u</code>, where they’ll be converted into the characters they represent:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">"a2\u03a3"</span>
"a2∑"</pre>
<p class="indent">To avoid the conversion, we can escape the backslash or use a raw string.</p>
<h3 class="h2" id="ch05lev5"><strong class="calibre2">String Searching and Replacing</strong></h3>
<p class="noindent">The <code>replace()</code> function replaces a substring with a different one. It can take any number of replacements, which are applied left to right, with the proviso that no character undergoes more than one substitution. The following example demonstrates the syntax as well as the consequence of the proviso:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">s = "abc"</span>
"abc"

julia&gt; <span class="codestrong">replace(s, "b" =&gt; "XX", "c" =&gt; "Z")</span>
"aXXZ"

julia&gt; <span class="codestrong">replace(s, "c" =&gt; "Z", "Z" =&gt; "WWW")</span>
"abZ"</pre>
<p class="noindent">The proviso means that the <code>"Z"</code> in the first replacement in the last example is not replaced by <code>"WWW"</code>.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">Multiple replacements in the string</em> <span class="codeitalic1">replace()</span> <em class="calibre11">function first appeared in Julia v1.7. If you are using an earlier version, you can use the</em> <span class="codeitalic1">replace()</span> <em class="calibre11">function as described here, but with only one replacement.</em></p>
</div>
<p class="indent">The <code>occursin()</code> function tests for the presence of a substring in a string:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">occursin("abc", "abcdef")</span>
true

julia&gt; <span class="codestrong">occursin("abc", "abCdef")</span>
false</pre>
<p class="noindent">This tests for the existence, in the second argument, of the string given in the first argument, and it’s case-sensitive.</p>
<p class="indent">The <code>occursin()</code> function follows the tradition of other functions, such as <code>iseven()</code>, that test a condition and return <code>true</code> or <code>false</code> (see “The filter() Operator” on <a href="ch06.xhtml#ch06sec1sec4" class="calibre10">page 163</a>).</p>
<p class="indent">The <code>findfirst()</code> and <code>findlast()</code> functions each search for the location of a character or string in another string. If we ask for the location of a character, the functions return the index of its first or last occurence:<span epub:type="pagebreak" id="page_132"/></p>
<pre class="calibre13">julia&gt; <span class="codestrong">findfirst('a', "abcabc")</span>
1

julia&gt; <span class="codestrong">findlast('a', "abcabc")</span>
4</pre>
<p class="indent">If, instead of a character, we supply a string in the first argument, the functions return a range giving the location of the string in the second string:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">findfirst("abc", "abcabc")</span>
1:3

julia&gt; <span class="codestrong">findlast("abc", "abcabc")</span>
4:6</pre>
<p class="indent">These functions return <code>nothing</code> if the character or string we’re searching for does not exist in the second string.</p>
<p class="indent">The <code>findnext()</code> function behaves similarly, but it accepts a third argument giving the location to begin the search:</p>
<pre class="calibre13">   q = "To be or not to be, that is the question"
   i = 0
   locations = []

<span class="ent">➊</span> while i != nothing
       i = findnext('e', q, i + 1)
       push!(locations, i)
   end

print("""The letter "e" was found at locations """,
             join(locations[1:end-1], ", ", " and "), ".")</pre>
<p class="indent">This demonstrates a third optional positional argument for <code>join()</code>, which is inserted in place of the delimiter (given in the second argument) between the final two elements.</p>
<p class="indent">When we run this program, it prints:</p>
<pre class="calibre13">The letter "e" was found at locations 5, 18, 31 and 35.</pre>
<p class="indent">If <code>findnext()</code> or the other string search functions don’t find what they’re looking for, they return nothing, or, more specifically, a particular value called <code>nothing</code>. We take advantage of this in the <code>while</code> condition <span class="ent">➊</span> to end the loop when there are no further <code>e</code> characters to be found.</p>
<p class="indent">All of the searching and replacing functions described in this section work with regular expressions as well. Julia uses Perl-compatible regular expressions; consult “Further Reading” on <a href="ch05.xhtml#fur5" class="calibre10">page 151</a> for a link to the syntax.</p>
<p class="indent">To define a regular expression, we use a nonstandard string literal with the <code>r</code> keyword. For example, <code>r"A.*B"</code> is a regular expression matching <code>A</code> followed by any number of characters ending with <code>B</code>.</p>
<p class="indent">Here’s a simple use of a regular expression to delete everything between a particular pair of characters:<span epub:type="pagebreak" id="page_133"/></p>
<pre class="calibre13">julia&gt; <span class="codestrong">s = "abc&lt;ABC&gt;def"</span>
"abc&lt;ABC&gt;def"

julia&gt; <span class="codestrong">replace(s, r"&lt;.*&gt;" =&gt; "")</span>
"abcdef"</pre>
<p class="indent">Parenthesized fragments in the regular expression become targets that we can refer to, in the replacement text, using escaped integers. These integers follow the order of the parenthesized fragments, so the first one is referenced by <code>\1</code>, and so on. In a normal string such escaped integers are interpreted as control characters; therefore, Julia has another nonstandard string literal for this purpose, using the <code>s</code> keyword:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">replace(s, r"(.*)&lt;(.*)&gt;(.*)" =&gt; s"\1\3, \2")</span>
"abcdef, ABC"</pre>
<p class="noindent">This replacement moves the delimited string to the end, preceded by some punctuation, instead of deleting the string between the angle brackets.</p>
<h3 class="h2" id="ch05lev6"><strong class="calibre2">String Interpolation</strong></h3>
<p class="noindent">Julia happily borrows good ideas from other languages. Perl not only has powerful regular expressions, it also has a convenient syntax for <em class="calibre11">string interpolation</em>, which you can use in Julia.</p>
<p class="indent">We use string interpolation when we want to insert the values of variables or expressions into a string. The interpolation syntax tells Julia to create the string representations of these values and place them within a larger string. Interpolation lets us avoid messy sequences of string concatenations in favor of neater code:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function name_length()</span>
           <span class="codestrong">println("Hi. What's your name?")</span>
        <span class="ent">➊</span> <span class="codestrong">name = readline()</span>
        <span class="ent">➋</span> <span class="codestrong">println("Hello, $name. Your name has $(length(name)) letters.")</span>
       <span class="codestrong">end</span>
name_length (generic function with 1 method)

julia&gt; <span class="codestrong">name_length()</span>
Hi. What's your name?
<span class="codestrong">Emily</span>
Hello, Emily. Your name has 5 letters.</pre>
<p class="indent">This example demonstrates the two kinds of string interpolation, both in the argument to the <code>println()</code> call <span class="ent">➋</span>. After the name entered by the user is stored in the variable <code>name</code> <span class="ent">➊</span>, we can access its value using string interpolation. To interpolate the value of the variable, just use its name after a dollar <span epub:type="pagebreak" id="page_134"/>sign (<code>$</code>). To interpolate another type of expression, put it inside parentheses after the <code>$</code>. We did this in order to interpolate the length of the user’s name <span class="ent">➋</span>.</p>
<p class="indent">We can interpolate any expression into a string. If we want to exclude spaces (because they are not letters) from the length of the name, we could use the following:</p>
<pre class="calibre13">println("Hello, $name. Your name has $(length(replace(name, " " =&gt; ""))) letters.")</pre>
<p class="indent">If you need an actual dollar sign, escape it with a backslash: <code>\$</code>. Naturally, <code>raw</code> strings do not partake of the interpolation process.</p>
<h3 class="h2" id="ch05lev7"><strong class="calibre2">Additional Collection Types</strong></h3>
<p class="noindent">This section describes additional types of collections that are all part of routine Julia programming: dictionaries, sets, structs, and named tuples.</p>
<h4 class="h3" id="ch05lev1sec6"><strong class="calibre2"><em class="calibre4">Dictionaries</em></strong></h4>
<p class="noindent">Julia’s <code>Dict</code> type is similar to dictionaries in Python or associative arrays in Bash. It’s a one-dimensional collection like a vector that’s indexed by <em class="calibre11">key</em> rather than position. <a href="ch05.xhtml#ch5lis1" class="calibre10">Listing 5-1</a> shows one of two ways to initialize a dictionary.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">bd = Dict("one"=&gt;1, "two"=&gt;2)</span>
Dict{String, Int64} with 2 entries:
  "two" =&gt; 2
  "one" =&gt; 1</pre>
<p class="list" id="ch5lis1"><em class="calibre11">Listing 5-1: Creating a dictionary from key-value pairs</em></p>
<p class="indent">After this initialization, the new dictionary contains two key-value pairs. Each key in this dictionary happens to be the name of the number that it indexes.</p>
<p class="indent">In addition to supplying the key-value pairs as separate arguments, we can supply any iterable object that yields key-value pairs when iterated over. We can initialize the dictionary from <a href="ch05.xhtml#ch5lis1" class="calibre10">Listing 5-1</a>, for example, with <code>Dict(["one"=&gt;1;</code> <code>"two"=&gt;2])</code>.</p>
<p class="indent">The keys and values in a dictionary can be of any type. In <code>bd</code> both of the keys are strings, and the values they point to are integers.</p>
<p class="indent">The syntax for indexing dictionaries is the same as for indexing vectors, but the indices are the keys, not the positions:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">bd["one"]</span>
1

julia&gt; <span class="codestrong">bd[2]</span>
ERROR: KeyError: key 2 not found</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_135"/>We initialize the <code>bd</code> dictionary with two key-value pairs; as 2 is not one of the keys, our attempt to index it with 2 produces an error.</p>
<p class="indent">The <code>keys(bd)</code> function returns a list of the keys in <code>bd</code>; a corresponding <code>values()</code> function returns a list of values.</p>
<p class="indent">The keys in a <code>Dict</code> must be unique. If we define an entry with a key that already exists, the later definition replaces the existing one:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">bd["one"] = 9;</span>

julia&gt; <span class="codestrong">bd</span>
Dict{String, Int64} with 2 entries:
  "two" =&gt; 2
  "one" =&gt; 9</pre>
<p class="noindent">In the first line we reuse the <code>"one"</code> key. Displaying the dictionary shows that the new value has replaced the earlier one.</p>
<p class="indent">The other way to initialize dictionaries is to pass a single argument to <code>Dict()</code>. The argument can be any iterable that yields tuples; each tuple generates a key-value pair:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">Dict([("one", 1) ("two", 2)])</span>
Dict{String, Int64} with 2 entries:
  "two" =&gt; 2
  "one" =&gt; 1</pre>
<p class="noindent">Notice that the dictionary is printed in what appears to be a random order. This is normal, as dictionaries are <em class="calibre11">unordered</em> collections, unlike vectors.</p>
<h4 class="h3" id="ch05lev1sec7"><strong class="calibre2"><em class="calibre4">Sets</em></strong></h4>
<p class="noindent">Julia’s <code>Set</code> data type implements many of the properties of mathematical sets. A set in Julia is a collection defined by what elements are contained within it. The elements have no order, and the set can’t be indexed. If you add an element that’s already there, the set doesn’t change because it already contains the element, which can appear only once.</p>
<p class="indent">Let’s define two simple sets that we’ll use to illustrate some of the operations we can perform on them:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">s1 = Set(1:5)</span>
Set{Int64} with 5 elements:
  5
  4
  2
  3
  1

julia&gt; <span class="codestrong">s2 = Set(4:8)</span>
Set{Int64} with 5 elements:
  5
  4
  6
  7
  8</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_136"/>The <code>Set()</code> function, which takes any iterable object, initializes sets. The sets’ members are listed in the REPL in an arbitrary order, as order is meaningless within a set.</p>
<p class="indent">Let’s ask for the intersection and union of the two sets we just created:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">intersect(s1, s2)</span>
Set{Int64} with 2 elements:
  5
  4

julia&gt; <span class="codestrong">union(s1, s2)</span>
Set{Int64} with 8 elements:
  5
  4
  6
  7
  2
  8
  3
  1</pre>
<p class="noindent">The results in both examples are also sets. The intersection is the set of elements common to both sets, while the union is the set of elements existing in either set.</p>
<p class="indent">We can test for a subset relationship between sets with the <code>issubset()</code> function, which has a Unicode synonym that we also can use as a binary operator:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">issubset(4:7, s2)</span>
   true

   julia&gt; <span class="codestrong">4:7</span> ⊆ <span class="codestrong">s2</span>
   true

<span class="ent">➊</span> julia&gt; <span class="codestrong">4:7</span> ⊇ <span class="codestrong">s2</span>
   false</pre>
<p class="indent">To create the subset or superset <span class="ent">➊</span> characters, we enter <span class="codestrong1">\subseteq</span> or <span class="codestrong1">\supseteq</span>, respectively, followed by <small class="calibre5">TAB</small>. The functions converted the range <code>4:7</code> into a set automatically and told us that <code>Set(4:7)</code> is a subset of <code>s2</code>, because every member of the former is a member of the latter.</p>
<p class="indent">We can find the <em class="calibre11">difference</em> between two sets, which are the elements of one set that are not in another set, using the <code>setdiff()</code> function:<span epub:type="pagebreak" id="page_137"/></p>
<pre class="calibre13">julia&gt; <span class="codestrong">s1</span>
Set{Int64} with 5 elements:
  5
  4
  2
  3
  1

julia&gt; <span class="codestrong">setdiff(s1, 3:5)</span>
Set{Int64} with 2 elements:
  2
  1</pre>
<p class="noindent">The result shows us what remains after removing 3, 4, and 5 from <code>s1</code>.</p>
<p class="indent">The mutating form of this function removes the members of the second set from the first. To add new elements to a set, use <code>push!()</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">push!(s1, 999);</span>

julia&gt; <span class="codestrong">setdiff!(s1, 1:3)</span>
Set{Int64} with 3 elements:
  5
  4
  999</pre>
<p class="noindent">In this example, first we enlarge <code>s1</code> with the member 999, and then we remove the elements in <code>Set(1:3)</code>.</p>
<h4 class="h3" id="ch05lev1sec8"><strong class="calibre2"><em class="calibre4">Structs</em></strong></h4>
<p class="noindent">A <code>struct</code> is a collection of named values packaged together under one identifier. For an example, <a href="ch05.xhtml#ch5lis2" class="calibre10">Listing 5-2</a> creates a struct to hold two pieces of information identifying a web page.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">struct Website</span>
           <span class="codestrong">url</span>
           <span class="codestrong">title</span>
       <span class="codestrong">end</span>

julia&gt; <span class="codestrong">google = Website("https://google.com", "google")</span>
Website("https://google.com", "google")</pre>
<p class="list" id="ch5lis2"><em class="calibre11">Listing 5-2: Defining a struct</em></p>
<p class="noindent">First we define a new struct called <code>Website</code>, and then we create a variable, <code>google</code>, that holds a particular instance of <code>Website</code> with specific values for <code>url</code> and <code>title</code>.</p>
<p class="indent">Conventional style is to capitalize the names of structs. A struct’s name is used as a <em class="calibre11">constructor</em> that creates <em class="calibre11">composite objects</em> with the struct’s type. Therefore, making a struct extends Julia by adding a new type to the language. Asking Julia for the type of <code>google</code> with <code>typeof(google)</code> returns <code>Website</code>. See “User-Defined Types” on <a href="ch08.xhtml#ch08lev3" class="calibre10">page 234</a> for more about the utility and power of user-defined types.</p>
<p class="indent"><span epub:type="pagebreak" id="page_138"/>We can reference the fields of composite objects such as structs and the named tuples (described next) using <em class="calibre11">property notation</em>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">google.title</span>
"google"

julia&gt; <span class="codestrong">google.title = "Google"</span>
ERROR: setfield!: immutable struct of type Website cannot be changed</pre>
<p class="noindent">After noticing that we forgot to capitalize the title of the website, we try to correct it, but Julia doesn’t allow the change because, by default, structs are immutable.</p>
<p class="indent">We can fix our error by defining <code>google</code> anew, but if we plan to mutate <code>Website</code> objects routinely, we can define them as <em class="calibre11">mutable structs</em>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">mutable struct MutableWebsite</span>
           <span class="codestrong">url</span>
           <span class="codestrong">title</span>
       <span class="codestrong">end</span>

julia&gt; <span class="codestrong">google = MutableWebsite("https://google.com", "google")</span>
MutableWebsite("https://google.com", "google")

julia&gt; <span class="codestrong">google.title = "Google"</span>
"Google"</pre>
<p class="noindent">Now we can change the values of <code>google</code>’s fields whenever we want.</p>
<h4 class="h3" id="ch05lev1sec9"><strong class="calibre2"><em class="calibre4">Named Tuples</em></strong></h4>
<p class="noindent">A named tuple is just like Julia’s ordinary <code>Tuple</code>, except we can give names to its values:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">nt = (a=1, b=2, c=3);</span>

julia&gt; <span class="codestrong">nt.c</span>
3</pre>
<p class="noindent">Now we have a new named tuple called <code>nt</code>, with three fields called <code>a</code>, <code>b</code>, and <code>c</code>. As this example shows, we extract values from a named tuple using property notation, just as with structs.</p>
<p class="indent">Named tuples are immutable, just as (immutable) structs and ordinary tuples:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">nt.a = 17</span>
ERROR: setfield!: immutable struct of type NamedTuple cannot be changed</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_139"/>The attempt to assign to a field of an immutable data type is not allowed.</p>
<p class="indent">Tuples and named tuples are intimately related to function argument lists, as we’ll explore in “Functions and Their Arguments” on <a href="ch06.xhtml#ch06lev1" class="calibre10">page 154</a>.</p>
<h3 class="h2" id="ch05lev8"><strong class="calibre2">Initializing Arrays with Functions</strong></h3>
<p class="noindent">Julia provides a handful of functions to initialize arrays. Using one of these is often more convenient and concise than the literal array definitions that we’ve been using up to now.</p>
<h4 class="h3" id="ch05lev1sec10"><strong class="calibre2"><em class="calibre4">The repeat() Function</em></strong></h4>
<p class="noindent">The <code>repeat()</code> function repeats an array a given number of times along each dimension corresponding to the arguments you supply:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">repeat(['a' 'b' '|'], 4, 3)</span>
4×9 Matrix{Char}:
 'a'  'b'  '|'  'a'  'b'  '|'  'a'  'b'  '|'
 'a'  'b'  '|'  'a'  'b'  '|'  'a'  'b'  '|'
 'a'  'b'  '|'  'a'  'b'  '|'  'a'  'b'  '|'
 'a'  'b'  '|'  'a'  'b'  '|'  'a'  'b'  '|'</pre>
<p class="noindent">In this example, the elements of the one-row array <code>[</code>'a' 'b' '|'] are replicated four times in the first (column) direction and three times in the second (row) direction.</p>
<p class="indent">We’ve already met <code>repeat()</code>, as a function that replicates a string, in “More Ways to Join Strings” on <a href="ch05.xhtml#ch05lev3" class="calibre10">page 128</a>.</p>
<h4 class="h3" id="ch05lev1sec11"><strong class="calibre2"><em class="calibre4">The fill() Function</em></strong></h4>
<p class="noindent">The <code>fill()</code> function takes the value supplied in its first argument and creates an array with a shape given by its subsequent arguments, filling it with the value. <a href="ch05.xhtml#ch5lis3" class="calibre10">Listing 5-3</a> shows how it works.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">XY = fill(['X' 'Y'], 3, 4)</span>
3×4 Matrix{Matrix{Char}}:
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']</pre>
<p class="list" id="ch5lis3"><em class="calibre11">Listing 5-3: Filling an array</em></p>
<p class="noindent">Here the value <code>['X' 'Y']</code> is used to fill a 3×4 array. Unlike <code>repeat()</code>, <code>fill()</code> can accept the dimensions as a tuple as well as separate arguments, so we can write the above as <code>fill(['X' 'Y'], (3, 4))</code>.</p>
<p class="indent">The most important difference beteen <code>repeat()</code> and <code>fill()</code> is that the former concatenates the elements of the array supplied in the first argument into the requested shape, whereas the latter concatenates the array itself. This can be seen in the results of the two examples just shown.<span epub:type="pagebreak" id="page_140"/></p>
<h4 class="h3" id="ch05lev1sec12"><strong class="calibre2"><em class="calibre4">Mutability with the fill() and repeat() Functions</em></strong></h4>
<p class="noindent">Let’s try to change one of the elements of the matrix <code>XY</code> defined in <a href="ch05.xhtml#ch5lis3" class="calibre10">Listing 5-3</a>. We’ll try to change the <code>'X'</code> to an <code>'O'</code> in the top-right element:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">XY[1, 4][1] = 'O';</span>

julia&gt; <span class="codestrong">XY</span>
3×4 Matrix{Matrix{Char}}:
 ['O' 'Y']  ['O' 'Y']  ['O' 'Y']  ['O' 'Y']
 ['O' 'Y']  ['O' 'Y']  ['O' 'Y']  ['O' 'Y']
 ['O' 'Y']  ['O' 'Y']  ['O' 'Y']  ['O' 'Y']</pre>
<p class="noindent">The result is surprising to many who encounter it for the first time. In altering one of the elements of <code>XY</code>, we’ve altered them all. This happens because <code>fill()</code> doesn’t <em class="calibre11">copy</em> its first argument into multiple locations in the result. Each element of <code>XY</code> is the identical one-row matrix; the output here shows the result of mutating this matrix.</p>
<p class="indent">If, instead of mutating the element, we <em class="calibre11">replace</em> it, something different happens:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">XY = fill(['X' 'Y'], 3, 4);</span>

julia&gt; <span class="codestrong">XY[1, 4] = ['O' 'Y'];</span>

julia&gt; <span class="codestrong">XY</span>
3×4 Matrix{Matrix{Char}}:
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['O' 'Y']
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']</pre>
<p class="noindent">Now <code>XY</code> contains two different matrices, one of them appearing 11 times.</p>
<p class="indent">We would observe exactly the same behavior using <code>repeat()</code> if we placed the first argument within an extra set of square brackets:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">XY = repeat([['X' 'Y']], 3, 4);</span></pre>
<p class="noindent">In this way, after <code>repeat()</code> extracts the contents of the first argument and concatenates them, we still have an array of arrays.</p>
<p class="indent">To get an array of <em class="calibre11">different</em> arrays, rather than the array of references to a single array that <code>fill()</code> constructs, we can use a comprehension:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">xy = [['X' 'Y'] for i in 1:3, j in 1:4]</span>
3×4 Matrix{Matrix{Char}}:
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']

julia&gt; <span class="codestrong">xy[1, 4][1] = 'O';</span>

julia&gt; <span class="codestrong">xy</span>
3×4 Matrix{Matrix{Char}}:
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['O' 'Y']
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']
 ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_141"/>Now altering one of the arrays has no effect on the other elements of <code>xy</code> because each element is a separate array.</p>
<h4 class="h3" id="ch05lev1sec13"><strong class="calibre2"><em class="calibre4">The zeros() and ones() Functions</em></strong></h4>
<p class="noindent">The <code>zeros()</code> and <code>ones()</code> functions act as special cases of <code>fill()</code> with 0.0 or 1.0 as a first argument. Like <code>fill()</code>, they accept either tuples or separate numbers for dimensions:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">zeros(4, 5)</span>
4×5 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0</pre>
<p class="noindent">The <code>zeros()</code> function creates a 4×5 matrix and fills it with 0.0.</p>
<p class="indent">Using <code>zeros()</code> or <code>ones()</code> is common when we need to initialize an array of floating-point numbers that’s going to be populated by direct indexing. This method is faster than using <code>push!()</code> to enlarge the array as it’s populated because the compiler knows the size of the array at the start, so reallocating memory isn’t needed. However, <code>push!()</code> may be a better choice if you don’t know the size of the array ahead of time and prefer not to allocate memory that the array won’t need.</p>
<h4 class="h3" id="ch05lev1sec14"><strong class="calibre2"><em class="calibre4">The reshape() Function</em></strong></h4>
<p class="noindent">You can transform an array into a new shape with <code>reshape()</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a1 = collect(1:6);</span>

julia&gt; <span class="codestrong">a2  = reshape(a1, (3, 2))</span>
3×2 Matrix{Int64}:
 1  4
 2  5
 3  6

julia&gt; <span class="codestrong">reshape(a1, 2, 2)</span>
ERROR: DimensionMismatch("new dimensions (2, 2) must
       be consistent with array size 6")</pre>
<p class="noindent">The first two examples show how to use <code>reshape()</code>: give the array as a first argument and its new dimensions either in a tuple or as a series of individual <span epub:type="pagebreak" id="page_142"/>arguments. The last example produces an error because <code>reshape()</code> will not change the total number of elements.</p>
<p class="indent">The <code>reshape()</code> function does not create a new array, but returns the original array molded into a different shape. You can see the consequence of that when mutating either incarnation of the array:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a1[5] = 0;</span>

julia&gt; <span class="codestrong">a2</span>
3×2 Matrix{Int64}:
 1  4
 2  0
 3  6</pre>
<p class="noindent">Changing the fifth element of <code>a1</code> also changes the fifth element of <code>a2</code>, where, as always, the elements are in column-major order.</p>
<p class="indent">The behavior of <code>reshape()</code> should call to mind the remarks in “Scalar Indexing” on <a href="ch02.xhtml#ch02sec1sec9" class="calibre10">page 38</a>: arrays are stored contiguously in the computer’s one-dimensional memory, which is reflected in their scalar indexing. The multidimensional forms of arrays that we use in our programs are abstractions, without which algorithms would be far more cumbersome to express in code.</p>
<h3 class="h2" id="ch05lev9"><strong class="calibre2">Array Manipulations Useful in Numerical Algorithms</strong></h3>
<p class="noindent">Arrays are the most important data type, aside from numbers, in scientific and numerical computing. Our algorithms often take the form of a series of transformations and operations upon vectors, matrices, and higher-dimensional arrays. Julia’s powerful array handling helps us to express these computations in terms of high-level operations on entire arrays, rather than verbose loops over their elements. This style of programming, when we can use it, is conceptually clearer and less prone to error. This section surveys several array operations that arise repeatedly in scientific code.</p>
<p class="indent"><a id="general-concatenation" class="calibre10"/></p>
<h4 class="h3" id="ch05lev1sec15"><strong class="calibre2"><em class="calibre4">General Concatenation</em></strong></h4>
<p class="noindent">We’ve discussed the semicolon as a concatenation operator along the first dimension, as in this example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m = [[1 2]; [3 4]]</span>
2×2 Matrix{Int64}:
 1  2
 3  4</pre>
<p class="indent">As an alternative, we can replace the single semicolon with a newline, making the input resemble the way Julia prints the matrix in the REPL.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">The use of repeated semicolons described in this section arrived with Julia v1.7. In earlier versions, repeated semicolons were treated as a single semicolon.</em></p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_143"/>A series of <em class="calibre11">n</em> semicolons concatenates along the <em class="calibre11">n</em>th dimension, adding new dimensions as needed, so two semicolons concatenate along the second dimension, which is also how a space concatenates:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m = [[1 2];; [3 4]]</span>
1×4 Matrix{Int64}:
 1  2  3  4

julia&gt; <span class="codestrong">m = [[1 2] [3 4]]</span>
1×4 Matrix{Int64}:
 1  2  3  4</pre>
<p class="noindent">Both examples perform the same operation: <code>[1 2]</code> is concatenated with <code>[3 4]</code> along the second, or column, dimension, increasing the number of columns.</p>
<p class="indent">Using three semicolons creates a new third dimension and joins along it:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m = [[1 2];;; [3 4]]</span>
1×2×2 Array{Int64, 3}:
[:, :, 1] =
 1  2

[:, :, 2] =
 3  4</pre>
<p class="noindent">In this example, the <code>[3 4]</code> array is put “on top” of the <code>[1 2]</code> array, in what is sometimes called a new <em class="calibre11">plane</em>.</p>
<h4 class="h3" id="ch05lev1sec16"><strong class="calibre2"><em class="calibre4">Logical Indexing</em></strong></h4>
<p class="noindent">Julia can store an array of Boolean values in a space-efficient manner with its <code>BitArray</code> data type. In a <code>BitArray</code>, or the subtypes <code>BitVector</code> and <code>BitMatrix</code>, <code>true</code> and <code>false</code> are represented by 1 and 0. These logical arrays are used for indexing, where they act as filters, selecting elements corresponding in position to the 1 values and rejecting the ones corresponding to the 0 values. When used for indexing, the array being indexed and the <code>BitArray</code> must have the same number of elements.</p>
<p class="indent">We create a <code>BitArray</code> with a logical condition broadcast into an array. For example, the following creates a <code>BitArray</code> that picks out which elements of <code>1:9</code> are divisible by 3:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">s3 = (1:9) .% 3 .== 0</span>
9-element BitVector:
 0
 0
 1
 0
 0
 1
 0
 0
 1</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_144"/>In order to return the result, Julia instantiates the range expression into an array. Each location that gives a zero remainder when divided by 3 is indicated by a <code>1</code>, and the others by a <code>0</code>.</p>
<p class="indent">We assigned the <code>BitArray</code> to a variable so we can use it in other expressions. We can use it on the <code>1:9</code> range itself:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">(1:9)[s3]</span>
3-element Vector{Int64}:
 3
 6
 9</pre>
<p class="noindent">The 1s in <code>s3</code> pick out the elements in <code>1:9</code> that are divisible by 3.</p>
<p class="indent">We can also use it to select every third element from any collection with nine elements:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">('a':'i')[s3]</span>
3-element Vector{Char}:
 'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
 'f': ASCII/Unicode U+0066 (category Ll: Letter, lowercase)
 'i': ASCII/Unicode U+0069 (category Ll: Letter, lowercase)</pre>
<p class="indent">Although the collection we’re indexing and the <code>BitArray</code> must have the same number of elements, the collection can have any shape if the <code>BitArray</code> is a <code>BitVector</code>; otherwise, the array and the <code>BitArray</code> must have the same shape.</p>
<p class="indent">Here’s an example of using <code>BitArray</code> indexing, also called logical indexing, as a concise way to print out all the integers in [1, 100] that are divisible by 17:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">(1:100)[(1:100) .% 17 .== 0]</span>
5-element Vector{Int64}:
 17
 34
 51
 68
 85</pre>
<p class="noindent">The only difference here is that we create the bit index and use it in an indexing expression in one step, rather than storing it in a variable for later use.</p>
<h4 class="h3" id="ch05lev1sec17"><strong class="calibre2"><em class="calibre4">Adjoints and Transposes</em></strong></h4>
<p class="noindent">The transpose of a matrix is the matrix formed by flipping it across its diagonal, so that <img alt="Image" src="../images/math144.jpg" class="calibre6"/> when <em class="calibre11">M<sup class="calibre23">'</sup></em> is the transpose of <em class="calibre11">M</em>. The adjoint of a matrix is formed by taking its transpose and replacing each of its elements by its <span epub:type="pagebreak" id="page_145"/>complex conjugate (the terminology is consistent with the concept of the adjoint of a linear operator, if matrices are regarded as linear transformations applied to vectors through conventional matrix multiplication).</p>
<p class="indent">To flip a matrix <code>MR</code> containing real numbers across its diagonal, we can use three notations: <code>MR', adjoint(MR)</code>, or <code>permutedims(MR)</code>. <a href="ch05.xhtml#ch5lis4" class="calibre10">Listing 5-4</a> shows that they all give the same results.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">MR = [[1 2]; [3 4]]</span>
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; <span class="codestrong">MR'</span>
2×2 adjoint(::Matrix{Int64}) with eltype Int64:
 1  3
 2  4

julia&gt; <span class="codestrong">MR' == adjoint(MR) == permutedims(MR)</span>
true</pre>
<p class="list" id="ch5lis4"><em class="calibre11">Listing 5-4: Matrix adjoint notations</em></p>
<p class="noindent">Since the elements of <code>MR</code> are their own complex conjugates, its adjoint is just its transpose.</p>
<p class="indent">However, if the matrix’s elements are almost anything else, <code>adjoint()</code> and <code>permutedims()</code> generally give different results; the <code>'</code> operator is a synonym for <code>adjoint()</code>. The <code>permutedims()</code> function flips the matrix around the diagonal and does nothing else, as shown here, and <code>adjoint()</code> does the same flip, called a <em class="calibre11">transpose</em>, but also takes the complex conjugate of each element. This operation is also known as the <em class="calibre11">Hermitian adjoint</em>. Consider this example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">M = [[1+im 2+2im]; [3+3im 4+4im]]</span>
2×2 Matrix{Complex{Int64}}:
 1+1im  2+2im
 3+3im  4+4im

julia&gt; <span class="codestrong">M'</span>
2×2 adjoint(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:
 1-1im  3-3im
 2-2im  4-4im</pre>
<p class="noindent">The matrix is flipped, as before, but now with each element replaced by its complex conjugate. Note that we can’t use the <code>adjoint()</code> function on non-numerical matrices, where the complex conjugate of the elements has no meaning.</p>
<p class="indent">In addition to <code>adjoint()</code> and <code>permutedims()</code>, we have the <code>transpose()</code> function:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">Mt = transpose(M)</span>
2×2 transpose(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:
 1+1im  3+3im
 2+2im  4+4im</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_146"/>The result looks like the simple transposition of <code>M</code>, with no complex conjugates taken, but this is what <code>permutedims()</code> is supposed to do. Why do we have two functions that seem to do the same thing?</p>
<p class="indent">The <code>adjoint()</code> and <code>transpose()</code> functions, on the one hand, and <code>permutedims()</code>, on the other, behave quite differently. The first two functions mentioned act recursively: if the elements of <code>M</code> are themselves matrices, <code>adjoint()</code> and <code>transpose()</code> will first act on <code>M</code>, then on the elements of <code>M</code>, and so on, all the way down. In contrast, <code>permutedims()</code> just flips <code>M</code> and stops.</p>
<p class="indent">The second difference is that, like <code>reshape()</code>, <code>adjoint()</code> and <code>transpose()</code> return the same array in a different form, so mutating the result mutates the original, unlike <code>permutedims()</code>, which returns a new array.</p>
<p class="indent">In general, to flip around tables of numbers, we turn to the <code>permutedims()</code> function. The other two functions are intended for more specialized linear algebra applications.</p>
<p class="indent">The <code>conj()</code> function, which takes the complete conjugate of a number, can of course be broadcast to work on each element of an array by using the dot operator. However, unlike most other math functions, it acts elementwise on arrays without broadcasting:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">conj(M)</span>
2×2 Matrix{Complex{Int64}}:
 1-1im  2-2im
 3-3im  4-4im</pre>
<p class="noindent">Here we’ve taken the complex conjugate of each element to transform the matrix.</p>
<h4 class="h3" id="ch05lev1sec18"><strong class="calibre2"><em class="calibre4">Matrix Multiplication</em></strong></h4>
<p class="noindent">The multiplication operator (<code>*</code>) performs matrix multiplication when supplied with a pair of matrices or a matrix and a vector. As an example, we’ll make a rotation matrix and matrix-multiply to rotate a vector:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a = π/2</span>
1.5707963267948966

julia&gt; <span class="codestrong">RM = [[cos(a) -sin(a)]; [sin(a) cos(a)]];</span>

julia&gt; <span class="codestrong">RM * [1, 0]</span>
2-element Vector{Float64}:
 6.123233995736766e-17
 1.0</pre>
<p class="noindent">The exact result should be <code>[0, 1]</code>: the rotation of a unit vector pointing “to the right” when rotated π/2 radians counterclockwise. The answer we get is the result of roundoff in floating-point arithmetic.</p>
<p class="indent"><span epub:type="pagebreak" id="page_147"/>For serious work with matrices, systems of linear equations, and related fields, you should import the <code>LinearAlgebra</code> package, which we’ll visit in “The LinearAlgebra Package” on <a href="ch12.xhtml#ch12lev1sec5" class="calibre10">page 399</a>. That package has a function for calculating the <em class="calibre11">inverse</em> of a matrix, but we can calculate matrix inverses without importing the package with an intuitive notation:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">MR^-1</span>
2×2 Matrix{Float64}:
 -2.0   1.0
  1.5  -0.5

julia&gt; <span class="codestrong">MR^-1 * MR</span>
2×2 Matrix{Float64}:
 1.0          0.0
 2.22045e-16  1.0</pre>
<p class="noindent">In this example we use the matrix <code>MR</code> defined in <a href="ch05.xhtml#ch5lis4" class="calibre10">Listing 5-4</a>. The result of multiplying a matrix by its inverse (with matrix multiplication) should be the identity matrix (1s along the diagonal and 0s elsewhere), which, within floating-point roundoff, is what we get.</p>
<h3 class="h2" id="ch05lev10"><strong class="calibre2">Enumeration and Zipping</strong></h3>
<p class="noindent">Julia comes with several functions, common in modern high-level languages, for enumerating and zipping arrays. The former refers to the association of indices with the elements of a collection, while the latter refers to the joining, element by element, of two collections. All the functions in this section return iterators, either over a collection of tuples or over a collection of key-value pairs.</p>
<h4 class="h3" id="ch05lev1sec19"><strong class="calibre2"><em class="calibre4">The enumerate() Function</em></strong></h4>
<p class="noindent">The <code>enumerate()</code> function takes a collection and returns an iterator into a collection of tuples that contains the number of the iteration as their first elements and the member of the collection retrieved as their second elements. <a href="ch05.xhtml#ch5lis5" class="calibre10">Listing 5-5</a> shows that the collection of tuples has the same shape as the original collection.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">collect(enumerate([10 20; 30 40]))</span>
2×2 Matrix{Tuple{Int64, Int64}}:
 (1, 10)  (3, 20)
 (2, 30)  (4, 40)</pre>
<p class="list" id="ch5lis5"><em class="calibre11">Listing 5-5: Using <span class="codeitalic">enumerate()</span></em></p>
<p class="noindent">Since <code>enumerate()</code> returns an iterator, we need to <code>collect()</code> it to see it. These iterators, like ranges and other iterators, such as the ones created by generators (see “Comprehensions and Generators” on <a href="ch05.xhtml#ch05lev2" class="calibre10">page 125</a>), take up almost <span epub:type="pagebreak" id="page_148"/>no space until we use them to loop over a collection or turn them into an actual array with the <code>collect()</code> function.</p>
<p class="indent">The array that <code>collect()</code> returns in <a href="ch05.xhtml#ch5lis5" class="calibre10">Listing 5-5</a> is laid out as specified in the argument to <code>enumerate()</code>, and the iteration numbers, the first elements of the tuples, reflect the column-major order in which the array was traversed.</p>
<p class="indent">The iteration numbers that <code>enumerate()</code> returns aren’t guaranteed to be legal indices of the array. Even when they are, they don’t necessarily return the element that they index. In other words, if one of the tuples <code>enumerate(A)</code> returns is <code>(i, e)</code>, <code>A[i]</code> may be an error. If it’s not an error, it may be the case that <code>A[i]</code> does not equal <code>e</code>.</p>
<p class="indent">In the case of a numerical array, such as in <a href="ch05.xhtml#ch5lis5" class="calibre10">Listing 5-5</a>, the first elements of the tuples <em class="calibre11">can</em> be used as scalar indices into the array, and <code>enumerate()</code> is sometimes used for this purpose.</p>
<p class="indent">An example of where the iteration number <em class="calibre11">cannot</em> be used as an index involves our old friend François:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">for letter in enumerate("François")</span>
           <span class="codestrong">println("Letter number $(letter[1]) is $(letter[2]).")</span>
       <span class="codestrong">end</span>
Letter number 1 is F.
Letter number 2 is r.
Letter number 3 is a.
Letter number 4 is n.
Letter number 5 is ç.
Letter number 6 is o.
Letter number 7 is i.
Letter number 8 is s.</pre>
<p class="indent">The iteration number tells us where each character appears in the string, but, as we saw in “Strings and Characters” on <a href="ch02.xhtml#ch02lev4" class="calibre10">page 44</a>, not all of these character positions are legal indices:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">"François"[5]</span>
'ç': Unicode U+00E7 (category Ll: Letter, lowercase)

julia&gt; <span class="codestrong">"François"[6]</span>
ERROR: StringIndexError: invalid index [6], valid nearby indices [5]=&gt;'ç', [7]=&gt;'o'</pre>
<p class="indent">In summary, don’t confuse iteration numbers with indexing.</p>
<h4 class="h3" id="ch05lev1sec20"><strong class="calibre2"><em class="calibre4">The pairs() Function</em></strong></h4>
<p class="noindent">The <code>pairs()</code> function is similar to <code>enumerate()</code>, except it creates an iterator over key-value pairs rather than over tuples:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">collect(pairs("François"))</span>
8-element Vector{Pair{Int64, Char}}:
 1 =&gt; 'F'
 2 =&gt; 'r'
 3 =&gt; 'a'
 4 =&gt; 'n'
 5 =&gt; 'ç'
 7 =&gt; 'o'
 8 =&gt; 'i'
 9 =&gt; 's'</pre>
<p class="indent"><span epub:type="pagebreak" id="page_149"/>The indices returned by <code>pairs()</code> are legal indices into the collection rather than iteration numbers as with <code>enumerate()</code>.</p>
<p class="indent">The objects in the iterator returned by <code>enumerate()</code> are tuples; those in the iterator returned by <code>pairs()</code> are key-value pairs. Such pairs have their own data type: <code>Pair</code>. If <code>p</code> is a <code>Pair</code>, we can access its key with <code>p.first</code> and its value with <code>p.second</code>. Therefore, if we need a vector of indices into the name of our French friend, we can get it this way:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[p.first for p in pairs("François")]</span>
8-element Vector{Int64}:
 1
 2
 3
 4
 5
 7
 8
 9</pre>
<p class="indent">We can create a <code>Pair</code> with a constructor like <code>Pair(9, 's')</code>, or by using the <code>=&gt;</code> operator—for example, <code>9 =&gt; 's'</code>.</p>
<p class="indent">In <a href="ch05.xhtml#ch5lis1" class="calibre10">Listing 5-1</a>, we created a dictionary from a series of key-value pairs entered directly. Each of those literal key-value pairs is a <code>Pair</code>; here’s another way to construct the dictionary:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">p1 = "one" =&gt; 1</span>
"one" =&gt; 1

julia&gt; <span class="codestrong">p2 = Pair("two", 2)</span>
"two" =&gt; 2

julia&gt; <span class="codestrong">Dict([p1, p2]) == Dict("one"=&gt;1, "two"=&gt;2)</span>
true</pre>
<p class="noindent">We make the pair <code>p1</code> using the <code>=&gt;</code> operator and <code>p2</code> using the <code>Pair()</code> constructor. Passing them to the <code>Dict()</code> function creates the same dictionary as in <a href="ch05.xhtml#ch5lis1" class="calibre10">Listing 5-1</a>.</p>
<p class="indent">A dictionary is an unordered collection of <code>Pair</code>s. Iterating through a dictionary produces each <code>Pair</code> in turn, but in an unpredictable order:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">Dict(pairs("François"))</span>
Dict{Int64, Char} with 8 entries:
  5 =&gt; 'ç'
  4 =&gt; 'n'
  7 =&gt; 'o'
  2 =&gt; 'r'
  9 =&gt; 's'
  8 =&gt; 'i'
  3 =&gt; 'a'
  1 =&gt; 'F'</pre>
<h4 class="h3" id="ch05lev1sec21"><strong class="calibre2"><em class="calibre4">The zip() Function</em></strong></h4>
<p class="noindent"><span epub:type="pagebreak" id="page_150"/>The <code>zip()</code> function takes any number of collections and returns an iterator into a collection of tuples that combines the elements of the collections.</p>
<p class="indent">When the collections passed in have the same shape, the returned iterator will have that shape as well:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">zip([1 2; 3 4], ['a' 'b'; 'c' 'd']) |&gt; collect</span>
2×2 Matrix{Tuple{Int64, Char}}:
 (1, 'a')  (2, 'b')
 (3, 'c')  (4, 'd')</pre>
<p class="noindent">The first elements of each collection are paired together, followed by the second, and so on. In this use of <code>zip()</code>, the shapes of the arguments must match.</p>
<p class="indent">If one of the collections is a list, the other can have any shape. The elements of the list are paired with the elements of the other collection in column-major order:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">zip([1, 2, 3, 4], ['a' 'b'; 'c' 'd']) |&gt; collect</span>
4-element Vector{Tuple{Int64, Char}}:
 (1, 'a')
 (2, 'c')
 (3, 'b')
 (4, 'd')</pre>
<p class="noindent">Here a one-dimensional list is zipped with a 2×2 matrix; each has four elements.</p>
<p class="indent">When using a vector, the numbers of elements need not match; <code>zip()</code> will continue until it runs out of elements:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">zip(1:3, ['a' 'b'; 'c' 'd']) |&gt; collect</span>
3-element Vector{Tuple{Int64, Char}}:
 (1, 'a')
 (2, 'c')
 (3, 'b')

julia&gt; <span class="codestrong">zip(1:5, ['a' 'b'; 'c' 'd']) |&gt; collect</span>
4-element Vector{Tuple{Int64, Char}}:
 (1, 'a')
 (2, 'c')
 (3, 'b')
 (4, 'd')</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_151"/>In the first example, the three-element vector is exhausted before we run out of elements in the 2×2 matrix. In the second example, the second argument is exhausted before we use up all the elements in <code>1:5</code>.</p>
<h3 class="h2" id="ch05lev11"><strong class="calibre2">Conclusion</strong></h3>
<p class="noindent">Julia is a somewhat “big” language: it has a lot of syntax and a large stable of data types. These features have a purpose, and they contribute to Julia’s power and convenience. Fortunately, you don’t have to use everything in the language in every program. In this chapter, we’ve encountered some new syntax that makes working with collections more concise and intuitive. In the next chapter, we’ll explore some new concepts that afford the Julia programmer higher levels of flexibility and control.</p>
<div class="box">
<p class="boxtitle-d" id="fur5"><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">The specification for semantic versioning is available at  <a href="https://semver.org" class="calibre10"><em class="calibre11">https://semver.org</em></a>.</li>
<li class="noindent1">For more information on Perl-compatible regular expressions,  visit  <a href="http://www.pcre.org" class="calibre10"><em class="calibre11">http://www.pcre.org</em></a>.<span epub:type="pagebreak" id="page_152"/></li></ul>
</div>
</body></html>