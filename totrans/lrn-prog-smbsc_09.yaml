- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**USING DECISIONS TO MAKE GAMES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用决策来制作游戏**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: Sometimes decisions are complicated. Let’s say a boy and a girl want to see
    a movie. She wants to see an action movie, but he wants to see a comedy. She’s
    willing to see a comedy if it has action, if it has good reviews, and if it stars
    an actress she likes. But the movie has to start before 10 PM and must be within
    a 10-mile radius of the restaurant where the couple is having dinner. Imagine
    what the code would look like to make a decision like that!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候决策是复杂的。假设一个男孩和一个女孩想去看电影。她想看一部动作片，但他想看一部喜剧片。如果这部喜剧片有动作元素，且评价很好，并且有她喜欢的女演员，她愿意去看。但这部电影必须在晚上10点之前开始，并且必须在距离他们正在用餐的餐厅10英里的范围内。想象一下，要做出这样的决策，代码会是什么样子的！
- en: In this chapter, we’ll continue the topic of decision-making and look at some
    new statements. We’ll first introduce the `If/ElseIf` statement and show how it
    makes writing nested `If` statements easier. Then, you’ll explore the logical
    operators `And` and `Or`, which let you do even more with your `If` statements.
    We’ll also introduce the `Shapes` object so you get more comfortable working with
    graphics. And you’ll put all this new information into action by building a game
    called Guess My Coordinates!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探讨决策相关的话题，并介绍一些新的语句。我们将首先介绍`If/ElseIf`语句，并展示它如何简化编写嵌套`If`语句的过程。接着，你将学习逻辑运算符`And`和`Or`，它们可以让你在`If`语句中做更多的操作。我们还将介绍`Shapes`对象，让你更加熟悉图形的操作。最后，你将通过构建一个叫做“猜我的坐标！”的游戏，将所有这些新知识付诸实践！
- en: '**The If/ElseIf Ladder**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**If/ElseIf 阶梯**'
- en: It’s all over the news! Franko, the alien monster, has escaped from custody.
    Luckily, you have your laser gun with you when you spot him attacking people in
    your neighborhood. You aim and shoot. Run the program in [Listing 9-1](ch09.html#ch9ex1)
    to see what happens next!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息已经在新闻中报道了！外星怪物弗兰科已经逃脱了看守。幸运的是，当你看到他在邻里攻击人们时，你正好带着激光枪。你瞄准并开火。运行[清单 9-1](ch09.html#ch9ex1)中的程序，看看接下来会发生什么！
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: Climbing the* `If/ElseIf` *ladder*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-1：攀登* `If/ElseIf` *阶梯*'
- en: The program picks a random number between 1 and 5 (line 6) and then checks that
    number to decide the alien’s fate. Lines 7–19 are called the `If/ElseIf` ladder,
    which is commonly used to build a chain of `If` statements. Its general form is
    illustrated in [Figure 9-1](ch09.html#ch9fig1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从1到5之间随机选择一个数字（第6行），然后检查该数字来决定外星人的命运。第7到第19行构成了`If/ElseIf`阶梯，这是用来构建一连串`If`语句的常见方法。它的一般形式在[图
    9-1](ch09.html#ch9fig1)中有所展示。
- en: Starting from the first statement, the program runs through each test condition.
    As soon as it finds a true condition, it runs the statement(s) associated with
    that condition and moves down to the statement after the `EndIf`, skipping the
    rest of the ladder. If none of the conditions is true, the program runs the statements
    inside the `Else` clause at the end of the ladder, and then the program moves
    to the statement after the `EndIf`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个语句开始，程序会依次检查每个测试条件。一旦找到一个条件为真的语句，它会执行该语句，并跳到`EndIf`之后的语句，跳过阶梯中的其他部分。如果没有任何条件为真，程序会执行`Else`子句中的语句，然后继续执行`EndIf`之后的语句。
- en: That’s why the final `Else` statement is often called the *default case*. If
    you don’t include the final `Else` statement in the ladder and all the test conditions
    are false, the `If/ElseIf` ladder does nothing, and the program continues after
    the `EndIf` keyword.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么最终的`Else`语句通常被称为*默认情况*。如果你在阶梯中不包括最后的`Else`语句，且所有测试条件都为假，`If/ElseIf`阶梯将不会执行任何操作，程序将继续执行`EndIf`关键字之后的语句。
- en: '![image](graphics/f09-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-01.jpg)'
- en: '*Figure 9-1: The structure of the* `If/ElseIf` *ladder*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：* `If/ElseIf` *阶梯的结构*'
- en: Let’s look at another way to use the `If/ElseIf` ladder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一种使用`If/ElseIf`阶梯的方法。
- en: '***Letter Grades***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字母成绩***'
- en: In this example, you’ll create a program that reads a test score between 0 and
    100, and displays a letter grade from [Table 9-1](ch09.html#ch9table1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将创建一个程序，读取一个0到100之间的测试分数，并从[表 9-1](ch09.html#ch9table1)中显示相应的字母成绩。
- en: '**Table 9-1:** Letter-Grade Scores'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** 字母成绩评分'
- en: '| **Score** | **Letter grade** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **分数** | **字母成绩** |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| score ≥ 90 | A |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 分数 ≥ 90 | A |'
- en: '| 80 ≤ score < 90 | B |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 80 ≤ 分数 < 90 | B |'
- en: '| 70 ≤ score < 80 | C |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 70 ≤ 分数 < 80 | C |'
- en: '| 60 ≤ score < 70 | D |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 60 ≤ 分数 < 70 | D |'
- en: '| score < 60 | F |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 分数 < 60 | F |'
- en: The complete program is shown in [Listing 9-2](ch09.html#ch9ex2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的程序可以在[清单 9-2](ch09.html#ch9ex2)中查看。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-2: Grading papers*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-2：评分作业*'
- en: 'Try running the program and inputting some numbers to see the results. Here
    are some output examples:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行程序并输入一些数字查看结果。以下是一些输出示例：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This program uses an `If/ElseIf` ladder to run tests on the entered score. Let’s
    walk through how this program works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序使用`If/ElseIf`阶梯来测试输入的成绩。让我们一步步地走过这个程序的工作原理。
- en: The program tests whether the first condition, `score >= 90`, is true (line
    4). If it is true, `grade` is set to `A` and the program jumps to line 15.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 程序测试第一个条件`score >= 90`是否为真（第4行）。如果为真，`grade`设置为`A`，程序跳转到第15行。
- en: If it’s not true, `score` must be less than 90, so the program checks the next
    condition, `score >= 80`, on line 6\. If this condition is true (which means that
    `score` is greater than or equal to 80 but less than 90), `grade` is set to `B`
    and the program jumps to line 15.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不成立，`score`一定小于90，程序会检查下一个条件`score >= 80`，即第6行的条件。如果这个条件为真（意味着`score`大于或等于80但小于90），`grade`将被设置为`B`，程序跳转到第15行。
- en: If that’s not true, then `score` must be less than 80, so the program checks
    the condition `score >= 70` on line 8\. If this condition’s true (which means
    that `score` is greater than or equal to 70 but less than 80), `grade` is set
    to `C` and the program jumps to line 15.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件不成立，那么`score`一定小于80，程序会检查第8行的条件`score >= 70`。如果这个条件成立（意味着`score`大于或等于70但小于80），`grade`将被设置为`C`，程序跳转到第15行。
- en: If that’s not true either, then `score` must be less than 70\. In this case,
    the program checks the condition `score >= 60` on line 10\. If this condition
    is true (which means that `score` is greater than or equal to 60 but less than
    70), `grade` is set to `D` and the program jumps to line 15.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个条件也不成立，那么`score`一定小于70。此时，程序会检查第10行的条件`score >= 60`。如果此条件为真（意味着`score`大于或等于60但小于70），`grade`会被设置为`D`，程序跳转到第15行。
- en: Finally, if that last condition is still not true, `score` must be less than
    60\. In this case, no conditions are checked, `grade` is set to `F`, and the program
    jumps to line 15.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果最后一个条件仍然不成立，`score`一定小于60。在这种情况下，程序不检查任何条件，`grade`被设置为`F`，程序跳转到第15行。
- en: '***The Bug on the Ladder***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***阶梯上的错误***'
- en: 'When you’re writing `If/ElseIf` ladders, the order of the conditional statements
    is very important. Be very careful with the order when testing your conditions.
    For example, go back to [Listing 9-2](ch09.html#ch9ex2) and replace lines 4–7
    with the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写`If/ElseIf`阶梯时，条件语句的顺序非常重要。在测试条件时，务必小心顺序。例如，回到[列表 9-2](ch09.html#ch9ex2)，并将第4到第7行替换为以下代码：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This change to the program means that you check the condition `score >= 80`
    first instead of `score >= 90`. Now, if the user enters 95, the program just tests
    the first condition, sees that `score >= 80` is true, and sets the `grade` to
    `B`. In this code, `grade` never gets set to `A`, no matter how high the value
    of `score` is. Nobody gets an `A`! When the program finds a true condition in
    this `If/ElseIf` ladder, it skips all the other statements and goes directly to
    `EndIf`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的更改意味着你首先检查条件`score >= 80`，而不是`score >= 90`。现在，如果用户输入95，程序首先测试第一个条件，看到`score
    >= 80`为真，并将`grade`设置为`B`。在这段代码中，`grade`永远不会被设置为`A`，无论`score`的值有多高。没有人能得`A`！当程序在这个`If/ElseIf`阶梯中找到一个为真的条件时，它会跳过所有其他语句，直接跳到`EndIf`。
- en: To avoid this problem, make sure the conditions in the `If/ElseIf` ladder are
    in the correct order. You’ll probably never want to check a middle value first.
    Also, be sure to run your program a few times to test the values and catch any
    problems before your users do.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，确保`If/ElseIf`阶梯中的条件顺序正确。你可能永远不想先检查中间值。此外，在用户之前一定要多次运行程序，测试值并发现任何问题。
- en: '**TRY IT OUT 9-1**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试 9-1**'
- en: In [Listing 9-2](ch09.html#ch9ex2), you started by checking the condition `score
    >= 90`. You can also start by checking the last condition, `score < 60`, then
    `60 <= score < 70`, then `70 <= score < 80`, and so on. Rewrite the program using
    this reverse order of checking the grade.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 9-2](ch09.html#ch9ex2)中，你从检查条件`score >= 90`开始。你也可以从检查最后一个条件`score < 60`开始，然后是`60
    <= score < 70`，接着是`70 <= score < 80`，依此类推。使用这种反向检查顺序重写程序。
- en: '**Let’s Get Logical**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**让我们来看看逻辑**'
- en: Sometimes you might want to check multiple conditions to see whether to run
    a statement. For example, you might adopt a dog only if the dog is big, is potty
    trained, and has three heads. One way to test multiple conditions is to nest `If`
    and `If/Else` statements like you have been doing in previous chapters. Another
    way is to use *logical operators* (also called *Boolean operators*). With logical
    operators, you can write test conditions that combine two or more logical expressions.
    Let’s see how.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要检查多个条件来决定是否执行某个语句。例如，你可能只有在狗既大又经过厕所训练且有三只头时，才会收养它。测试多个条件的一种方法是像在前几章中那样嵌套`If`和`If/Else`语句。另一种方法是使用*逻辑运算符*（也叫*布尔运算符*）。使用逻辑运算符，你可以编写结合两个或更多逻辑表达式的测试条件。让我们看看怎么做。
- en: Do you remember something like 5 < *x* < 10 when you learned about *inequalities*
    in your elementary math class? This expression describes a number, *x*, that is
    greater than 5 and less than 10\. [Figure 9-2](ch09.html#ch9fig2) shows you how
    to write this expression in Small Basic.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在小学数学课上学过的像 5 < *x* < 10 这样的*不等式*吗？这个表达式描述了一个数字 *x*，它大于 5 且小于 10。[图 9-2](ch09.html#ch9fig2)向你展示了如何在
    Small Basic 中写出这个表达式。
- en: '![image](graphics/f09-02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-02.jpg)'
- en: '*Figure 9-2: A compound condition in Small Basic*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：Small Basic中的复合条件*'
- en: This is a *compound condition* that’s made up of two logical expressions, *x*
    > 5 and *x* < 10, that you combine using the logical operator `And`. In order
    for this compound condition to be true, both of the expressions must be true.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由两个逻辑表达式 *x* > 5 和 *x* < 10 组成的*复合条件*，你使用逻辑运算符 `And` 将它们结合起来。为了使这个复合条件为真，两个表达式必须都为真。
- en: 'Small Basic supports two logical operators: `And` and `Or`. [Figure 9-3](ch09.html#ch9fig3)
    describes how they work.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Small Basic 支持两个逻辑运算符：`And` 和 `Or`。[图 9-3](ch09.html#ch9fig3)描述了它们的工作原理。
- en: '![image](graphics/f09-03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-03.jpg)'
- en: '*Figure 9-3: Explaining the logical operators* `And` *and* `Or`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：解释逻辑运算符* `And` *和* `Or`'
- en: Next, we’ll explain these operators a bit more.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更详细地解释这些运算符。
- en: '***Logical Operators in the Zoo***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***动物园中的逻辑运算符***'
- en: 'Look at [Figure 9-4](ch09.html#ch9fig4) and answer this question: how would
    the monkey reach the banana? That’s right: Door 1 `And` Door 2 `And` Door 3 must
    be open. If any one of the three doors is closed, the poor monkey won’t get the
    banana!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[图 9-4](ch09.html#ch9fig4)，并回答这个问题：猴子该如何得到香蕉？没错：门 1 `和` 门 2 `和` 门 3 必须都打开。如果三扇门中有任何一扇关着，可怜的猴子就无法得到香蕉了！
- en: '![image](graphics/f09-04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-04.jpg)'
- en: '*Figure 9-4: Performing logic with the* `And` *operator*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：使用* `And` *运算符进行逻辑运算*'
- en: 'Now look at [Figure 9-5](ch09.html#ch9fig5). In this case, the monkey just
    needs one door to be open: Door 1 `Or` Door 2 `Or` Door 3\. This monkey likes
    its chances!'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看一下[图 9-5](ch09.html#ch9fig5)。在这个例子中，猴子只需要一扇门打开：门 1 `或` 门 2 `或` 门 3。这个猴子对它的机会很有信心！
- en: '![image](graphics/f09-05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-05.jpg)'
- en: '*Figure 9-5: Performing logic with the* `Or` *operator*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：使用* `Or` *运算符进行逻辑运算*'
- en: In [Figure 9-6](ch09.html#ch9fig6), the monkey has two options.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 9-6](ch09.html#ch9fig6)中，猴子有两个选择。
- en: '![image](graphics/f09-06.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-06.jpg)'
- en: '*Figure 9-6: Performing logic with* `And` *and* `Or`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：使用* `And` *和* `Or` *运算符进行逻辑运算*'
- en: 'If it takes the upper path, it needs both doors (Door 1 `And` Door 2) to be
    open. If it takes the lower path, it needs just Door 3 to be open. If you were
    programming this condition, you’d describe it like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它走上上面的小路，它需要两扇门（门 1 `和` 门 2）都打开。如果它走下下面的小路，只需要门 3 打开。如果你在编程这个条件，你会这样描述：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Are you ready to practice using `And` and `Or`?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好练习使用 `And` 和 `Or` 运算符了吗？
- en: '***The And Operator***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***And 运算符***'
- en: The `And` operator takes two logical expressions as operands. *Operand* refers
    to the term that an operator acts on. [Table 9-2](ch09.html#ch9table2) (called
    a truth table) lists the output of the `And` operator for all possible combinations
    of its two operands, `X` and `Y`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`And` 运算符将两个逻辑表达式作为操作数。*操作数*是指运算符作用的对象。[表 9-2](ch09.html#ch9table2)（称为真值表）列出了
    `And` 运算符对其两个操作数 `X` 和 `Y` 的所有可能组合的输出。'
- en: '**Table 9-2:** Truth Table for the `And` Operator'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-2：** `And` 运算符的真值表'
- en: '| **If** `X` **is** | **If** `Y` **is** | **Then** `(X And Y)` **is** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **如果** `X` **是** | **如果** `Y` **是** | **那么** `(X 和 Y)` **是** |'
- en: '| --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `"True"` | `"True"` | `"True"` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `"真"` | `"真"` | `"真"` |'
- en: '| `"True"` | `"False"` | `"False"` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `"真"` | `"假"` | `"假"` |'
- en: '| `"False"` | `"True"` | `"False"` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `"假"` | `"真"` | `"假"` |'
- en: '| `"False"` | `"False"` | `"False"` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `"假"` | `"假"` | `"假"` |'
- en: If both `X` and `Y` are true, then `X And Y` is true too. But if one of the
    operands is false, then `X And Y` is also false.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `X` 和 `Y` 都为真，则 `X And Y` 也为真。但如果其中一个操作数为假，则 `X And Y` 也为假。
- en: '[Listing 9-3](ch09.html#ch9ex3) shows two conditions (`gameLevel = 1` and `score
    > 100`) combined using the `And` operator. The message `You get 200 bonus points!`
    is displayed when both conditions are true.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-3](ch09.html#ch9ex3) 显示了使用 `And` 运算符结合的两个条件（`gameLevel = 1` 和 `score
    > 100`）。当这两个条件都为真时，会显示消息 `You get 200 bonus points!`。'
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 9-3: The* `And` *operator*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-3：* `And` *运算符*'
- en: The statement inside the `If` block (line 9) is run only if `gameLevel` equals
    1 and `score` is greater than 100\. If either of these two conditions is false,
    the entire condition is found false and Small Basic won’t run the `WriteLine()`
    method on line 9.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 `gameLevel` 等于 1 且 `score` 大于 100 时，`If` 块中的语句（第 9 行）才会执行。如果这两个条件中有一个为假，那么整个条件就是假的，Small
    Basic 将不会在第 9 行执行 `WriteLine()` 方法。
- en: 'You can perform the same check by replacing lines 8–10 with the following nested
    `If` statements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将第 8 到第 10 行替换为以下嵌套的 `If` 语句来执行相同的检查：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Do you see how the `And` operator is a more concise way to test multiple conditions?
    The nested `If` statements require five lines of code, but using `And`, you can
    do the same thing in only three lines of code!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到 `And` 运算符是如何更简洁地测试多个条件的吗？嵌套的 `If` 语句需要五行代码，但使用 `And`，你只需三行代码就能做到同样的事情！
- en: '***The Or Operator***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Or 运算符***'
- en: How do you like your pizza? You might want to eat pizza only if it has four
    kinds of meat or if the crust is gooey. When you have multiple conditions but
    only one condition needs to be true, the `Or` operator comes into play. Take a
    look at the truth table for the `Or` operator in [Table 9-3](ch09.html#ch9table3).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你喜欢你的比萨吗？你可能只想吃有四种肉或者外皮是黏糊糊的比萨。当你有多个条件时，如果只有一个条件需要为真，`Or` 运算符就派上用场了。请查看 [表 9-3](ch09.html#ch9table3)
    中 `Or` 运算符的真值表。
- en: '**Table 9-3:** Truth Table for the `Or` Operator'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-3：** `Or` 运算符的真值表'
- en: '| **If** `X` **is** | **If** `Y` **is** | **Then** `(X Or Y)` **is** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **如果** `X` **为** | **如果** `Y` **为** | **那么** `(X Or Y)` **为** |'
- en: '| --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `"True"` | `"True"` | `"True"` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `"True"` | `"True"` | `"True"` |'
- en: '| `"True"` | `"False"` | `"True"` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `"True"` | `"False"` | `"True"` |'
- en: '| `"False"` | `"True"` | `"True"` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `"False"` | `"True"` | `"True"` |'
- en: '| `"False"` | `"False"` | `"False"` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `"False"` | `"False"` | `"False"` |'
- en: If either of the two operands is true, or if they’re both true, the combined
    logical expression is true. The logical expression is false only when both operands
    are false.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个操作数中有一个为真，或者它们都为真，那么组合的逻辑表达式为真。只有当两个操作数都为假时，逻辑表达式才为假。
- en: '[Listing 9-4](ch09.html#ch9ex4) shows an example of using the `Or` operator.
    The goal is to end the game if there’s no more time to play (`timeLeft = 0`) or
    if the player has lost all their energy (`energyLevel = 0`).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-4](ch09.html#ch9ex4) 显示了使用 `Or` 运算符的一个例子。目标是在没有时间继续游戏时（`timeLeft = 0`）或者玩家失去所有能量时（`energyLevel
    = 0`），结束游戏。'
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 9-4: The* `Or` *operator*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-4：* `Or` *运算符*'
- en: If `timeLeft` is 0 or `energyLevel` is 0, Small Basic runs the command inside
    the `If` block (line 9). Run this program several times using different inputs
    to make sure you understand how the `Or` operator works.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `timeLeft` 为 0 或 `energyLevel` 为 0，Small Basic 会执行 `If` 块中的命令（第 9 行）。多次运行此程序，使用不同的输入来确保你理解
    `Or` 运算符的工作原理。
- en: 'You could use nested `If` statements to do the same thing. For example, you
    could replace lines 8–10 with the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用嵌套的 `If` 语句来做同样的事情。例如，你可以将第 8 到第 10 行替换为以下代码：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, as you can see, using nested `If` statements takes up seven lines of
    code, but using `Or` took only three! Using the `Or` operator is a more concise
    way to test multiple conditions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你所看到的，使用嵌套的 `If` 语句需要七行代码，而使用 `Or` 只需要三行！使用 `Or` 运算符是一种更简洁的方式来测试多个条件。
- en: '***The Cosmic Order of Evaluation***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***评估的宇宙顺序***'
- en: Look at the following condition. How does Small Basic evaluate this expression?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的条件。Small Basic 如何评估这个表达式？
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As it turns out, Small Basic gives `And` a higher priority than `Or`. This
    means it finds `B = 1 And C = 1` first, and then the result is used as the right
    operand for the `Or` expression. To change the order, you can use parentheses,
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，Small Basic 给 `And` 运算符的优先级高于 `Or`。这意味着它首先会找到 `B = 1 And C = 1`，然后将结果作为
    `Or` 表达式的右操作数。要改变运算顺序，可以使用括号，例如：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code finds `A = 1 Or B = 1` first and uses the result as the left operand
    for the `And` expression. We recommend you use parentheses to avoid any confusion!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先计算 `A = 1 Or B = 1`，然后将结果作为 `And` 表达式的左操作数。我们建议你使用括号，以避免任何混淆！
- en: '**NOTE**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Logical operators like* `And` *and* `Or` *are evaluated* after *any arithmetic
    operators (*`+`, `–`, `*`, `/`*) and relational operators (*`=`, `<`, `<=`, `>`,
    `>=`, `<>`*) in combined expressions. Among the logical operators*, `And` *takes
    priority over* `Or`*; use parentheses to change the order and make your code easier
    to read.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑运算符，如* `And` *和* `Or` *会在* *任何算术运算符（*`+`、`-`、`*`、`/`*）和关系运算符（*`=`、`<`、`<=`、`>`、`>=`、`<>`*）的组合表达式之后进行计算。在逻辑运算符中，*
    `And` *优先于* `Or` *；使用括号可以改变顺序，使代码更易读。*'
- en: It’s almost time to apply all the decision-making information you’ve learned
    and build some exciting applications. But first we need to introduce a new Small
    Basic object, the `Shapes` object, which lets you build your applications using
    rich graphics. Let’s make some pretty pictures!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候应用你所学的所有决策信息，并构建一些令人兴奋的应用程序了。但在此之前，我们需要介绍一个新的 Small Basic 对象——`Shapes` 对象，它允许你使用丰富的图形来构建应用程序。让我们制作一些漂亮的图形吧！
- en: '**TRY IT OUT 9-2**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手试一试 9-2**'
- en: Open the file *DiceGame_Incomplete.sb* from this chapter’s folder, and write
    the missing code to complete this game. The player enters their bet (from $1 to
    $10) and then throws a pair of dice. If the sum of the dice is 2 or 12, the player
    wins three times their bet. If the sum is 4 or 10, the player wins two times their
    bet. If the sum is 7 or 11, the player loses their bet. Otherwise, the player’s
    balance doesn’t change, and the player rolls the dice again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的 *DiceGame_Incomplete.sb* 文件，并编写缺失的代码来完成这个游戏。玩家输入他们的赌注（从 $1 到 $10），然后掷一对骰子。如果骰子的点数和为
    2 或 12，玩家赢得赌注的三倍。如果点数和为 4 或 10，玩家赢得赌注的两倍。如果点数和为 7 或 11，玩家输掉赌注。否则，玩家的余额不变，玩家继续掷骰子。
- en: '**The Shapes Object**'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Shapes 对象**'
- en: 'In [Chapter 3](ch03.html#ch03), you learned how to draw all sorts of shapes
    and images in the graphics window. But those shapes were *fixed*: once you drew
    a shape at a location, the only way to move it to a different spot was to clear
    the entire window and redraw that shape in the new place. If you need to move
    some shapes around in a program (like moving a character when the player presses
    a key), it’s best to use the `Shapes` object.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html#ch03) 中，你学会了如何在图形窗口中绘制各种形状和图像。但那些形状是*固定的*：一旦你在某个位置绘制了形状，唯一移动它到另一个位置的方法就是清空整个窗口并重新绘制该形状。如果你需要在程序中移动一些形状（比如当玩家按下一个键时移动一个角色），最好使用
    `Shapes` 对象。
- en: 'The `Shapes` object lets you add, move, and rotate shapes in the graphics window.
    Run this code to draw a rectangle:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shapes` 对象让你在图形窗口中添加、移动和旋转图形。运行这段代码来绘制一个矩形：'
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The program calls `AddRectangle()` to add a 100×50 rectangle and saves the identifier
    of the created shape in `rectID`. The created rectangle appears by default in
    the upper-left corner of the graphics window. The second statement pauses the
    program for 1 second so you can see the rectangle’s initial position. The third
    statement calls `Move()` to move this rectangle so its upper-left corner is at
    (400, 200). Note how `rectID` is passed as the first argument to `Move()` to let
    it know the identity of the shape to move.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 程序调用 `AddRectangle()` 来添加一个 100×50 的矩形，并将创建的图形标识符保存到 `rectID` 中。创建的矩形默认出现在图形窗口的左上角。第二条语句使程序暂停
    1 秒，以便你查看矩形的初始位置。第三条语句调用 `Move()` 来移动该矩形，使其左上角位于 (400, 200) 处。请注意，`rectID` 被作为
    `Move()` 的第一个参数传入，以便它知道要移动的是哪个图形。
- en: Think of the `Shapes` object as a “shape factory”—a factory that manufactures
    lines, triangles, rectangles, ellipses, and other shapes. When you ask it to create
    a new shape, it’ll make the shape and return an identifier. Every time you want
    to do something with the shape you created, you’ll pass this identifier to the
    `Shapes` object (as an argument to the method you call).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 把 `Shapes` 对象当作一个“形状工厂”——一个制造线条、三角形、矩形、椭圆以及其他形状的工厂。当你请求它创建一个新的形状时，它会制造该形状并返回一个标识符。每当你想对已创建的形状进行操作时，你都需要将这个标识符传递给
    `Shapes` 对象（作为你调用的方法的参数）。
- en: We won’t cover all the methods of the `Shapes` object here. Instead, we’ll discuss
    the ones you’ll use in the next program. You’ll learn the other methods as you
    progress through this book.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里涵盖 `Shapes` 对象的所有方法。相反，我们会讨论你在下一个程序中将使用到的方法。随着你阅读本书，你会学习到其他方法。
- en: The two methods we’ll use now are `AddImage()` and `Move()`. To understand how
    these methods work, open the file *ImageDemo.sb* from this chapter’s folder. You’ll
    see the code shown in [Listing 9-5](ch09.html#ch9ex5), which moves an image.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要使用的两个方法是`AddImage()`和`Move()`。要了解这些方法是如何工作的，请打开本章文件夹中的*ImageDemo.sb*文件。你将看到[清单
    9-5](ch09.html#ch9ex5)中展示的代码，该代码用于移动图像。
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-5: Moving an image using the* `Shapes` *object*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-5：使用`Shapes`对象移动图像*'
- en: Click the **Run** button. The output of this program is illustrated in [Figure
    9-7](ch09.html#ch9fig7) (we added the gridlines and the numbers to show how the
    code works).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**运行**按钮。该程序的输出如[图 9-7](ch09.html#ch9fig7)所示（我们添加了网格线和数字，以展示代码的工作原理）。
- en: '![image](graphics/f09-07.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-07.jpg)'
- en: '*Figure 9-7: Moving the flower image*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：移动花朵图像*'
- en: 'Let’s assume that this program is saved to *C:\Book\Ch09\ImageDemo*. The *imageDemo*
    folder also contains the *Flower.png* image file. The `Program.Directory` property
    (line 2) points to the directory *C:\Book\Ch09\ImageDemo*, which contains the
    executable program (the *.exe* file). Line 2 uses the `+` symbol to append two
    things to the directory: a slash (\) and the image filename (*Flower.png*). When
    the program runs line 2, the `path` variable’s given the full file path (*C:\Book\Ch09\ImageDemo\Flower.png*).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个程序被保存到*C:\Book\Ch09\ImageDemo*。*imageDemo*文件夹中还包含*Flower.png*图像文件。`Program.Directory`属性（第2行）指向目录*C:\Book\Ch09\ImageDemo*，该目录包含可执行程序（*.exe*文件）。第2行使用`+`符号将两件事附加到目录中：一个斜杠（\）和图像文件名（*Flower.png*）。当程序运行第2行时，`path`变量会被赋予完整的文件路径（*C:\Book\Ch09\ImageDemo\Flower.png*）。
- en: Line 3 calls the `AddImage()` method and passes the `path` variable as an argument.
    This method loads the image from the file and returns an identifier of the loaded
    image; this identifier is saved in a variable named `imgID`. An identifier is
    like a tag that the `Shapes` object uses to keep track of the shapes it creates
    (for example, `"Image1"`, `"Rectangle3"`, `"Line100"`, and so on). The loaded
    image is displayed in the upper-left corner of the graphics window.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第3行调用了`AddImage()`方法，并将`path`变量作为参数传递。该方法从文件加载图像并返回加载图像的标识符；该标识符保存在名为`imgID`的变量中。标识符就像是`Shapes`对象用来跟踪它创建的形状的标签（例如，`"Image1"`、`"Rectangle3"`、`"Line100"`等）。加载的图像显示在图形窗口的左上角。
- en: Line 4 calls the `Move()` method to move the image. The first argument is the
    shape’s identifier, which the program got from `AddImage()` and was saved into
    `imgID` (line 3). The other two arguments are the upper-left coordinates of the
    new position. [Figure 9-7](ch09.html#ch9fig7) shows the flower image with its
    upper-left corner at (60, 20).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行调用了`Move()`方法来移动图像。第一个参数是形状的标识符，它是程序从`AddImage()`获取并保存在`imgID`（第3行）中的。其他两个参数是新位置的左上角坐标。[图
    9-7](ch09.html#ch9fig7)显示了花朵图像，其左上角位于(60, 20)。
- en: 'The *Flower.png* image’s width is 100 pixels, and its height is 140 pixels.
    If you want to move the image so its center’s at (100, 100), you’d write this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flower.png*图像的宽度为100像素，高度为140像素。如果你想将图像移动到其中心位于(100, 100)，你可以这样写：'
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because you want the image’s center to be at (100, 100), you need to subtract
    half the image’s width (50) to center it horizontally and subtract half the image’s
    height (70) to center it vertically.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你想让图像的中心位于(100, 100)，你需要减去图像宽度的一半（50）来水平居中，减去图像高度的一半（70）来垂直居中。
- en: This is all the information you need to learn about the `Shapes` object for
    you to build the application in the next section. Time to make a guessing game!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在下一节构建应用程序时需要学习的有关`Shapes`对象的所有信息。现在是时候制作一个猜谜游戏了！
- en: '**TRY IT OUT 9-3**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手练习 9-3**'
- en: 'Use code like the following to point to a small image on your computer and
    display it in the graphics window:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似以下的代码，在你的计算机上指向一张小图像，并在图形窗口中显示它：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update the path with the correct path for your image. Change the second statement
    to move your image to each of these positions: (100, 40), (10, 10), (27, 78),
    and then center it in the middle of the graphics window.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更新路径为你图像的正确路径。更改第二条语句，将图像移动到以下位置：(100, 40)、(10, 10)、(27, 78)，然后将其居中于图形窗口。
- en: '**Create a Game: Guess My Coordinates**'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建一个游戏：猜我的坐标**'
- en: It’s game time! In this section, you’ll develop an interactive game called Guess
    My Coordinates that tests people’s knowledge of the Cartesian coordinate system,
    or how well they can read an x, y graph. The game displays a star that represents
    a point on the Cartesian grid; [Figure 9-8](ch09.html#ch9fig8) shows what the
    interface looks like. During each round of the game, the star moves to a random
    location and asks the player to guess its x- and y-coordinates. The game checks
    the player’s answers and displays a feedback message. It’s like *Battleship* but
    more fun for math geeks!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始了！在本节中，你将开发一个互动游戏，叫做“猜我的坐标”，它测试玩家对笛卡尔坐标系统的知识，或者说是他们读取x、y坐标图的能力。游戏展示一个代表笛卡尔网格上某一点的星星；[图
    9-8](ch09.html#ch9fig8)展示了界面的样子。在每一轮游戏中，星星会移动到一个随机位置，并要求玩家猜测它的x和y坐标。游戏会检查玩家的答案，并显示反馈信息。它像是*战舰*游戏，但对于数学迷来说更有趣！
- en: The game uses the graphics window and the text window at the same time. The
    graphics window shows the grid and the star, and the text window reads the player’s
    answers and shows the program’s feedback. Now we’ll walk you through the steps
    to create this game.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该游戏同时使用图形窗口和文本窗口。图形窗口显示网格和星星，文本窗口读取玩家的答案并显示程序的反馈信息。现在，我们将一步步带你完成创建这个游戏的过程。
- en: '![image](graphics/f09-08.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-08.jpg)'
- en: '*Figure 9-8: The user interface for the Guess My Coordinates game*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8：猜测我的坐标游戏的用户界面*'
- en: '***Step 1: Open the Startup File***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 1：打开启动文件***'
- en: Start by opening the *GuessMyCoordinate_Incomplete.sb* file from this chapter’s
    folder. This file contains only comments. You’ll add all the code one step at
    a time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章文件夹中打开*GuessMyCoordinate_Incomplete.sb*文件开始。该文件仅包含注释，你将一步一步地添加代码。
- en: The chapter’s folder also contains the two images you’ll use (*Grid.png* and
    *Star.png*). *Grid.png* is a 480×360 image of the Cartesian grid, and *Star.png*
    is a 24×24 image of a star.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章文件夹中还包含你将使用的两张图片（*Grid.png*和*Star.png*）。*Grid.png*是一个480×360的笛卡尔网格图像，而*Star.png*是一个24×24的星星图像。
- en: '**NOTE**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you run into any problems, check out the finished program* (GuessMyCoordinates.sb)
    *included in the chapter folder to see what you did wrong.*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你遇到任何问题，可以查看本章文件夹中包含的完成版程序*（GuessMyCoordinates.sb），*看看你做错了什么。*'
- en: '***Step 2: Set Up the Game***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 2：设置游戏***'
- en: Enter the code in [Listing 9-6](ch09.html#ch9ex6) to set up the game’s user
    interface. This goes at the beginning of the file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 9-6](ch09.html#ch9ex6)中输入代码以设置游戏的用户界面。该代码应放在文件的开头。
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-6: Setting up the game*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-6：设置游戏*'
- en: 'Lines 1–6 set the title, size, and position of the graphics window. The window’s
    size is set to be equal to the size of the grid image (lines 3–4). Lines 7–9 set
    the title of the text window and position it to the right of the graphics window
    (see [Figure 9-8](ch09.html#ch9fig8)). The program then saves the program’s directory
    (line 11) into `path`, which you’ll use to make the full path for both images
    so you can draw them on the screen. Next, the program loads the two images and
    saves their identifiers (which are returned by the `Shapes` object) in these two
    variables: `bkgnd` and `star` (lines 12–13).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第1行到第6行设置图形窗口的标题、大小和位置。窗口的大小设置为与网格图像的大小相同（第3–4行）。第7行到第9行设置文本窗口的标题，并将其位置设置在图形窗口的右侧（见[图
    9-8](ch09.html#ch9fig8)）。程序接着将程序的目录保存到`path`中（第11行），你将使用它来为两张图片生成完整路径，以便在屏幕上绘制它们。接下来，程序加载这两张图片，并将它们的标识符（由`Shapes`对象返回）保存在这两个变量中：`bkgnd`和`star`（第12–13行）。
- en: The `While`/`EndWhile` keywords on lines 15 and 17 are explained in detail in
    [Chapter 14](ch14.html#ch14). For now, you just need to know that this code creates
    an *infinite loop* (a loop that repeats forever, like the Pete and Repeat program,
    *GotoDemo.sb*, you wrote in the [Chapter 8](ch08.html#ch08)). You’ll add the remaining
    code for the application between these `While`/`EndWhile` keywords.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 行 15 和行 17 中的`While`/`EndWhile`关键字将在[第14章](ch14.html#ch14)中详细解释。现在，你只需要知道这些代码创建了一个*无限循环*（一个会永远重复的循环，像你在[第8章](ch08.html#ch08)中写的Pete
    and Repeat程序，*GotoDemo.sb*）。你将在这些`While`/`EndWhile`关键字之间添加应用程序的其余代码。
- en: Test what you’ve written so far. You should see the two windows side by side,
    just like in [Figure 9-8](ch09.html#ch9fig8). The star image appears in the upper-left
    corner of the graphics window but doesn’t do anything because you didn’t write
    any code to move it yet.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 测试到目前为止写的代码。你应该能看到两个并排的窗口，就像在[图 9-8](ch09.html#ch9fig8)中一样。星星图像出现在图形窗口的左上角，但暂时没有任何动作，因为你还没有编写代码来移动它。
- en: Now close either the graphics window or the text window so you can add the remaining
    code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关闭图形窗口或文本窗口，以便你可以添加剩余的代码。
- en: '***Step 3: Hide the Star***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 3：隐藏星星***'
- en: During each round of the game, you’ll move the star to a random position on
    the grid and then ask the player to guess its coordinates. Let’s add the code
    to move the star.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏的每一轮中，你将把星星移动到网格上的一个随机位置，然后让玩家猜测其坐标。现在我们来添加代码来移动星星。
- en: Add the code in [Listing 9-7](ch09.html#ch9ex7) inside the `While` loop (line
    16 back in [Listing 9-6](ch09.html#ch9ex6)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表 9-7](ch09.html#ch9ex7)中的代码添加到 `While` 循环中（位于[列表 9-6](ch09.html#ch9ex6)的第
    16 行）。
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 9-7: Placing the star*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-7：放置星星*'
- en: In [Figure 9-8](ch09.html#ch9fig8), you see that the grid goes from –12 to 12
    in the x-direction and from –9 to 9 in the y-direction. If you place the star
    at any point on the grid’s boundaries, the player sees only part of it; the part
    of the star outside the grid gets clipped. That’s why you’ll restrict the star’s
    x-coordinate to the range [–11, 11] and its y-coordinate to the range [–8, 8].
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 9-8](ch09.html#ch9fig8)中，你可以看到网格在 x 方向上从 –12 到 12，在 y 方向上从 –9 到 9。如果你将星星放置在网格边界的任何一点，玩家只能看到星星的一部分；网格外部的部分会被裁剪掉。这就是为什么你需要将星星的
    x 坐标限制在 [–11, 11] 范围内，y 坐标限制在 [–8, 8] 范围内。
- en: But how do you create a random number between –11 and 11? That’s easy! From
    –11 to 11 there are 23 integers (–11, –10, ..., 10, 11). If you call `GetRandomNumber(23)`,
    you’ll get a random integer between 1 and 23\. If you subtract 12 from this integer,
    the result will be an integer between –11 (1 – 12) and 11 (23 – 12), which is
    what you need. Next, we’ll explain the code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但如何生成一个在 –11 到 11 之间的随机数呢？这很简单！从 –11 到 11 共包含 23 个整数（–11, –10, ..., 10, 11）。如果你调用
    `GetRandomNumber(23)`，你会得到一个介于 1 和 23 之间的随机整数。如果你从这个整数中减去 12，结果将是一个介于 –11（1 –
    12）和 11（23 – 12）之间的整数，这正是你需要的。接下来，我们将解释代码。
- en: You use two variables, `X0` and `Y0`, to hold the random coordinates of the
    star. In line 2, the `X0` variable is given a random value between –11 and 11,
    as explained earlier. In line 3, the `Y0` variable is given a random number between
    –8 and 8\. These random values for `X0` and `Y0` tell you which grid intersection
    point the star lands on. Next, the program builds a string named `pt` (short for
    point) in the form `(X0, Y0)`. This string shows the correct coordinates to the
    player if they enter the wrong answer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用两个变量，`X0` 和 `Y0`，来存储星星的随机坐标。在第 2 行，`X0` 变量被赋予一个在 –11 到 11 之间的随机值，如前所述。在第
    3 行，`Y0` 变量被赋予一个在 –8 到 8 之间的随机数。这些 `X0` 和 `Y0` 的随机值告诉你星星落在哪个网格交点上。接下来，程序构建一个名为
    `pt`（表示点的缩写）的字符串，格式为 `(X0, Y0)`。如果玩家输入错误的答案，这个字符串会显示正确的坐标给玩家。
- en: Now you need to move the star to this new coordinate that you just created,
    `(X0, Y0)`. [Figure 9-9](ch09.html#ch9fig9) shows part of the grid and an example
    of where the star might be set. As you can see in the figure, each unit on the
    grid maps to 20 pixels in the graphics window; compare this with [Figure 9-8](ch09.html#ch9fig8)
    to understand the full scaling of the grid.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要将星星移动到你刚刚创建的这个新坐标 `(X0, Y0)`。[图 9-9](ch09.html#ch9fig9)展示了网格的一部分，以及星星可能被设置的位置示例。如图所示，网格上的每个单位映射到图形窗口中的
    20 像素；你可以将其与[图 9-8](ch09.html#ch9fig8)进行对比，以了解网格的整体缩放比例。
- en: '![image](graphics/f09-09.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-09.jpg)'
- en: '*Figure 9-9: Grid coordinates for pixel positions in the graphics window*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：图形窗口中的像素位置的网格坐标*'
- en: To move the star to a random position, you’ll first need to translate the `(X0,
    Y0)` grid units (what your user sees on the grid image) into `(xPos, yPos)` pixel
    units (what Small Basic sees). Let’s do that now.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将星星移动到一个随机位置，你首先需要将 `(X0, Y0)` 网格单位（用户在网格图像上看到的内容）转换为 `(xPos, yPos)` 像素单位（Small
    Basic 中的坐标）。我们现在就来做这个转换。
- en: If the star’s x-coordinate is –11, you need to draw the star at horizontal position
    20 in the graphics window. If the star’s x-coordinate is –10, you need to draw
    it at horizontal position 40, and so on. So you need a formula to map the star’s
    x-coordinates, `X0` = {–11, –10, –9, ..., 0}, to their corresponding horizontal
    positions, `xPos` = {20, 40, 60, ..., 240}, in the graphics window. To do this,
    you add 12 to `X0` to get {1, 2, 3, ..., 12} and multiply the result by 20\. Test
    it out! When `X0` = –11, (–11 + 12) × 20 = 20\. When `X0` = –10, (–10 + 12) ×
    20 = 40, and so on. This is exactly what you want.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果星星的x坐标是–11，你需要在图形窗口的水平位置20绘制星星。如果星星的x坐标是–10，你需要在水平位置40绘制它，依此类推。所以你需要一个公式将星星的x坐标`X0`
    = {–11, –10, –9, ..., 0}，映射到图形窗口中对应的水平位置`xPos` = {20, 40, 60, ..., 240}。为此，你需要将12加到`X0`上，得到{1,
    2, 3, ..., 12}，然后将结果乘以20。测试一下！当`X0` = –11时，（–11 + 12）× 20 = 20。当`X0` = –10时，（–10
    + 12）× 20 = 40，依此类推。这正是你想要的。
- en: Mapping for the y-coordinate works the same way. If 8 is the star’s y-coordinate,
    you need to draw it at vertical position 20 in the graphics window. If 7 is the
    star’s y-coordinate, you need to draw it at vertical position 40, and so on. So
    you need a formula to map the star’s y-coordinates, `Y0` = {8, 7, 6, ..., 0},
    to their corresponding vertical positions, `yPos` = {20, 40, 60, ..., 180}, in
    the graphics window. You do this by subtracting `Y0` from 9 and multiplying the
    result by 20\. Let’s test this out! When `Y0` = 8, (9 – 8) × 20 = 20\. When `Y0`
    = 7, (9 – 7) × 20 = 40, and so on, which is what you need.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于y坐标的映射方式是相同的。如果星星的y坐标是8，你需要在图形窗口的垂直位置20绘制它。如果星星的y坐标是7，你需要在垂直位置40绘制它，依此类推。所以你需要一个公式将星星的y坐标`Y0`
    = {8, 7, 6, ..., 0}，映射到图形窗口中对应的垂直位置`yPos` = {20, 40, 60, ..., 180}。你通过从9中减去`Y0`并将结果乘以20来实现这一点。来测试一下吧！当`Y0`
    = 8时，（9 – 8）× 20 = 20。当`Y0` = 7时，（9 – 7）× 20 = 40，依此类推，这正是你需要的。
- en: You still have one minor detail to consider. Let’s say the star’s `(X0, Y0)`
    coordinates are (–10, 2), as shown in [Figure 9-9](ch09.html#ch9fig9). You map
    these coordinates to pixels and find that you need to show the star at point `(xPos,
    yPos)` = (40, 140) in the graphics window. But you need that star’s center to
    be at (40, 140). Because the star image is 24×24 pixels, the star’s left position
    must be 28 (40 – 12), and the star’s top position must be 128 (140 – 12). These
    are the numbers you need to pass to the `Move()` method. In other words, to align
    the star’s center with the intersection of the grid lines, you have to subtract
    the star’s width (12 pixels) from `xPos` and the star’s height (12 pixels) from
    `yPos`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有一个小细节需要考虑。假设星星的`(X0, Y0)`坐标是(–10, 2)，如[图 9-9](ch09.html#ch9fig9)所示。你将这些坐标映射到像素，并发现需要在图形窗口中将星星显示在点`(xPos,
    yPos)` = (40, 140)的位置。但你需要使星星的中心位于(40, 140)。由于星星图像是24×24像素，星星的左边位置必须是28（40 – 12），星星的顶部位置必须是128（140
    – 12）。这些数字是你需要传递给`Move()`方法的。换句话说，为了让星星的中心与网格线的交点对齐，你必须从`xPos`中减去星星的宽度（12像素），从`yPos`中减去星星的高度（12像素）。
- en: In [Listing 9-7](ch09.html#ch9ex7), line 7 finds the star’s `xPos` and line
    8 finds the star’s `yPos` in the graphics window. Line 9 then calls the `Move()`
    method to place the star at the desired position on the grid.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 9-7](ch09.html#ch9ex7)中，第7行找到星星的`xPos`，第8行找到星星在图形窗口中的`yPos`。然后第9行调用`Move()`方法，将星星放置在网格上的目标位置。
- en: '***Step 4: Let the User Guess***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 4：让用户猜测***'
- en: Now that the star is displayed on the grid, you need to ask the player to guess
    its coordinates. Add the code in [Listing 9-8](ch09.html#ch9ex8) right after the
    code you added from [Listing 9-7](ch09.html#ch9ex7), still inside the `While`
    loop.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在星星已经显示在网格上，你需要让玩家猜测它的坐标。在你从[清单 9-7](ch09.html#ch9ex7)中添加的代码之后，仍然在`While`循环内，加入[清单
    9-8](ch09.html#ch9ex8)中的代码。
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 9-8: Guessing the coordinates*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-8：猜测坐标*'
- en: This code asks the player to enter the x-coordinate of the star, and it waits
    for an answer (lines 1–2). Then it checks whether the x-coordinate guess is correct
    (line 3). If the answer is incorrect, the program moves to line 12 to display
    the correct coordinates of the star (see the box labeled *2nd Round* in [Figure
    9-8](ch09.html#ch9fig8)). But if the x-coordinate guess is correct, the code asks
    the player to enter the y-coordinate of the star and waits for an answer (lines
    4–5). If the player answers correctly (line 7), the program displays `Good Job!
    You're a star!`. If not, the program moves to line 9 to display the correct coordinates.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码要求玩家输入星星的 x 坐标，并等待答案（第 1–2 行）。然后它检查 x 坐标的猜测是否正确（第 3 行）。如果答案不正确，程序将跳转到第 12
    行显示星星的正确坐标（见 [Figure 9-8](ch09.html#ch9fig8) 中标记为 *2nd Round* 的框）。但如果 x 坐标猜测正确，代码会要求玩家输入星星的
    y 坐标并等待答案（第 4–5 行）。如果玩家答对了（第 7 行），程序会显示 `Good Job! You're a star!`。如果没有，程序将跳转到第
    9 行显示正确的坐标。
- en: In all these cases, the program ends up at line 15 to display an empty line,
    and the `While` loop repeats for another round of the game. The game never ends!
    (This is exactly how your parents feel when you’re playing video games.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，程序都会最终到达第 15 行，显示一个空行，然后 `While` 循环会重复进行下一轮游戏。游戏永远不会结束！（这正是你父母在你玩电子游戏时的感受。）
- en: The game is now complete. Try playing it now!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在完成了。现在试着玩一玩吧！
- en: '**TRY IT OUT 9-4**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 9-4**'
- en: Change [Listing 9-8](ch09.html#ch9ex8) to ask the player to enter the x- and
    y-coordinates, and then use the `And` operator to check `xAns` and `yAns` in a
    single `If` statement.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 [Listing 9-8](ch09.html#ch9ex8)，要求玩家输入 x 和 y 坐标，然后使用 `And` 运算符在单个 `If` 语句中检查
    `xAns` 和 `yAns`。
- en: '**Programming Challenges**'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: If you get stuck, check out *[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*
    for the solutions and for more resources and review questions for teachers and
    students.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你卡住了，可以查看 *[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*
    获取解决方案以及更多教师和学生资源和复习问题。
- en: 'A love meter gives a number from 1 to 5 that indicates the warmth of your heart
    (a lower number is warmer). Write a program that asks the user to input their
    love indicator number and then displays one of these messages:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 爱情计量器给出一个从 1 到 5 的数字，表示你心中的温暖程度（数字越低表示越温暖）。编写一个程序，要求用户输入他们的爱情指数数字，然后显示以下消息之一：
- en: '[PRE18]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Write a program to simulate a mouse’s search for food (see the following figure).
    The mouse starts at room 1\. From there, have the mouse go to either room 2 or
    room 4 (decide randomly). Pause to display this movement to the user. If the mouse
    goes to room 4, then for the next step it can move to room 1, room 2, or room
    5 (decide randomly and then display the move). Make your simulation end when the
    mouse goes to room 3 (and finds the cheese) or goes to room 5, where the cat is
    patiently waiting for its snack. Open the file *HungryMouse_Incomplete.sb* from
    this chapter’s folder, and follow the instructions to complete the simulation.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来模拟老鼠寻找食物的过程（见下图）。老鼠从房间 1 开始。从那里，随机让老鼠进入房间 2 或房间 4（随机决定）。暂停并向用户显示这一动作。如果老鼠进入房间
    4，那么下一步它可以进入房间 1、房间 2 或房间 5（随机决定，然后显示移动）。当老鼠进入房间 3（并找到奶酪）或进入房间 5，猫正在那里耐心地等待它的零食时，结束模拟。打开本章文件夹中的
    *HungryMouse_Incomplete.sb* 文件，按照指示完成模拟。
- en: '![image](graphics/f0128-01.jpg)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f0128-01.jpg)'
- en: Obi-Wan Kenobi needs to know the day of the week. But R2-D2 just beeps at him.
    Obi-Wan counts the beeps, but he needs your help to translate that number into
    the day of the week. Write an `If/ElseIf` ladder that compares the value of the
    variable `dayNum` with 1, 2, 3, ..., 7 and sets the value of the variable `dayName`
    to `"Sunday"`, `"Monday"`, `"Tuesday"`, ..., `"Saturday"` (so 1 is Sunday and
    7 is Saturday). Help Obi Wan Kenobi. You’re his only hope!
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 欧比·旺·肯诺比需要知道星期几。但 R2-D2 只是对着他发出嗡嗡声。欧比·旺数了数嗡嗡声，但他需要你的帮助，将这个数字转换成星期几。编写一个 `If/ElseIf`
    梯形结构，比较变量 `dayNum` 的值与 1、2、3、...、7，然后将变量 `dayName` 设置为 `"Sunday"`、`"Monday"`、`"Tuesday"`、...、`"Saturday"`（所以
    1 是星期天，7 是星期六）。帮助欧比·旺·肯诺比。你是他的唯一希望！
