["```\n\n\t\t\tmove the constant 5 into the variable i\nmove a copy of i into j\nmove a copy of j into k\nadd k to m\n```", "```\n\n\t\t\tmove the constant 5 into k\nadd k to m\n```", "```\n\n\t\t\t    path := 5;\n    if( i = 2 ) then begin\n\n        writeln( 'Path = ', path );\n\n    end;\n    i := path + 1;\n    if( i < 20 ) then begin\n\n        path := path + 1;\n        i := 0;\n\n    end;\n```", "```\n\n\t\t\t    if( i = 2 ) then begin\n\n        (* Because the compiler knows that path = 5 *)\n\n        writeln( 'path = ', 5 );\n\n    end;\n    i := 0;     (* Because the compiler knows that path < 20 *)\n    path := 6;  (* Because the compiler knows that path < 20 *)\n```", "```\n\n\t\t\t    x = 2;              // Basic block 1\n    j = 5;\n    i = f( &x, j );     // End of basic block 1\n    j = i * 2 + j;      // Basic block 2\n    if( j < 10 )        // End of basic block 2\n    {\n        j = 0;          // Basic block 3\n        i = i + 10;\n        x = x + i;      // End of basic block 3\n    }\n    else\n    {\n        temp = i;       // Basic block 4\n        i = j;\n        j = j + x;\n        x = temp;       // End of basic block 4\n    }\n    x = x * 2;          // Basic block 5\n    ++i;\n    --j;\n\n    printf( \"i=%d, j=%d, x=%d\\n\", i, j, x ); // End basic block 5\n\n    // Basic block 6 begins here\n```", "```\n\n\t\t\t    write( 'Input a value for i:' );\n    readln( i );\n    j := 0;\n    while( ( j < i ) and ( i > 0 ) ) do begin\n\n        a[j] := i;\n        b[i] := 0;\n        j := j + 1;\n        i := i - 1;\n    end; (* while *)\n    k := i + j;\n    writeln( 'i = ', i, 'j = ', j, 'k = ', k );\n```", "```\n\n\t\t\t                              -OPTIMIZATION-\n\n/O1 minimize space\n/O2 maximize speed\n/Ob<n> inline expansion (default n=0)\n/Od disable optimizations (default)\n/Og enable global optimization\n/Oi[-] enable intrinsic functions\n/Os favor code space\n/Ot favor code speed\n/Ox maximum optimizations\n/favor:<blend|AMD64|INTEL64|ATOM> select processor to optimize for, one of:\n    blend - a combination of optimizations for several different x64 processors\n    AMD64 - 64-bit AMD processors\n    INTEL64 - Intel(R)64 architecture processors\n    ATOM - Intel(R) Atom(TM) processors\n\n                             -CODE GENERATION-\n\n/Gw[-] separate global variables for linker\n/GF enable read-only string pooling\n/Gm[-] enable minimal rebuild\n/Gy[-] separate functions for linker\n/GS[-] enable security checks\n/GR[-] enable C++ RTTI\n/GX[-] enable C++ EH (same as /EHsc)\n/guard:cf[-] enable CFG (control flow guard)\n/EHs enable C++ EH (no SEH exceptions)\n/EHa enable C++ EH (w/ SEH exceptions)\n/EHc extern \"C\" defaults to nothrow\n/EHr always generate noexcept runtime termination checks\n/fp:<except[-]|fast|precise|strict> choose floating-point model:\n    except[-] - consider floating-point exceptions when generating code\n    fast - \"fast\" floating-point model; results are less predictable\n    precise - \"precise\" floating-point model; results are predictable\n    strict - \"strict\" floating-point model (implies /fp:except)\n/Qfast_transcendentals generate inline FP intrinsics even with /fp:except\n/Qspectre[-] enable mitigations for CVE 2017-5753\n/Qpar[-] enable parallel code generation\n/Qpar-report:1 auto-parallelizer diagnostic; indicate parallelized loops\n/Qpar-report:2 auto-parallelizer diagnostic; indicate loops not parallelized\n/Qvec-report:1 auto-vectorizer diagnostic; indicate vectorized loops\n/Qvec-report:2 auto-vectorizer diagnostic; indicate loops not vectorized\n/GL[-] enable link-time code generation\n/volatile:<iso|ms> choose volatile model:\n    iso - Acquire/release semantics not guaranteed on volatile accesses\n    ms  - Acquire/release semantics guaranteed on volatile accesses\n/GA optimize for Windows Application\n/Ge force stack checking for all funcs\n/Gs[num] control stack checking calls\n/Gh enable _penter function call\n/GH enable _pexit function call\n/GT generate fiber-safe TLS accesses\n/RTC1 Enable fast checks (/RTCsu)\n/RTCc Convert to smaller type checks\n/RTCs Stack Frame runtime checking\n/RTCu Uninitialized local usage checks\n/clr[:option] compile for common language runtime, where option is:\n    pure - produce IL-only output file (no native executable code)\n    safe - produce IL-only verifiable output file\n    initialAppDomain - enable initial AppDomain behavior of Visual C++ 2002\n    noAssembly - do not produce an assembly\n    nostdlib - ignore the default \\clr directory\n/homeparams Force parameters passed in registers to be written to the stack\n/GZ Enable stack checks (/RTCs)\n/arch:AVX enable use of instructions available with AVX-enabled CPUs\n/arch:AVX2 enable use of instructions available with AVX2-enabled CPUs\n/Gv __vectorcall calling convention\n```", "```\n\n\t\t\tmov( 5, eax ); // move the constant 5 into the EAX register.\nmov( eax, k ); // Store the value in EAX (5) into k.\nadd( eax, m ); // Add the value in EAX to variable m.\n```", "```\n\n\t\t\t// Microsoft Windows winnt.h version:\n\ntypedef struct _IMAGE_FILE_HEADER {\n    WORD    Machine;\n    WORD    NumberOfSections;\n    DWORD   TimeDateStamp;\n    DWORD   PointerToSymbolTable;\n    DWORD   NumberOfSymbols;\n    WORD    SizeOfOptionalHeader;\n    WORD    Characteristics;\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n\n// Linux coff.h version:\n\nstruct COFF_filehdr {\n        char f_magic[2];        /* magic number */\n        char f_nscns[2];        /* number of sections */\n        char f_timdat[4];       /* time & date stamp */\n        char f_symptr[4];       /* file pointer to symtab */\n        char f_nsyms[4];        /* number of symtab entries */\n        char f_opthdr[2];       /* sizeof(optional hdr) */\n        char f_flags[2];        /* flags */\n};\n```", "```\n// Microsoft PE/COFF Optional Header (from winnt.h)\n\ntypedef struct _IMAGE_OPTIONAL_HEADER {\n    //\n    // Standard fields.\n    //\n\n    WORD    Magic;\n    BYTE    MajorLinkerVersion;\n    BYTE    MinorLinkerVersion;\n    DWORD   SizeOfCode;\n    DWORD   SizeOfInitializedData;\n    DWORD   SizeOfUninitializedData;\n    DWORD   AddressOfEntryPoint;\n    DWORD   BaseOfCode;\n    DWORD   BaseOfData;\n\n    //\n    // NT additional fields.\n    //\n\n    DWORD   ImageBase;\n    DWORD   SectionAlignment;\n    DWORD   FileAlignment;\n    WORD    MajorOperatingSystemVersion;\n    WORD    MinorOperatingSystemVersion;\n    WORD    MajorImageVersion;\n    WORD    MinorImageVersion;\n    WORD    MajorSubsystemVersion;\n    WORD    MinorSubsystemVersion;\n    DWORD   Win32VersionValue;\n    DWORD   SizeOfImage;\n    DWORD   SizeOfHeaders;\n    DWORD   CheckSum;\n    WORD    Subsystem;\n    WORD    DllCharacteristics;\n    DWORD   SizeOfStackReserve;\n    DWORD   SizeOfStackCommit;\n    DWORD   SizeOfHeapReserve;\n    DWORD   SizeOfHeapCommit;\n    DWORD   LoaderFlags;\n    DWORD   NumberOfRvaAndSizes;\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n\n// Linux/COFF Optional Header format (from coff.h)\n\ntypedef struct\n{\n  char  magic[2];  /* type of file */\n  char  vstamp[2]; /* version stamp */\n  char  tsize[4];  /* text size in bytes, padded to\n                      FW bdry */\n  char  dsize[4]; /* initialized   data \"   \" */\n  char  bsize[4]; /* uninitialized data \"   \" */\n  char  entry[4]; /* entry pt. */\n  char  text_start[4]; /* base of text used for this file */\n  char  data_start[4]; /* base of data used for this file */\n} COFF_AOUTHDR;\n```", "```\n\n\t\t\t// Windows section header structure (from winnt.h)\n\ntypedef struct _IMAGE_SECTION_HEADER {\n    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];\n    union {\n            DWORD   PhysicalAddress;\n            DWORD   VirtualSize;\n    } Misc;\n    DWORD   VirtualAddress;\n    DWORD   SizeOfRawData;\n    DWORD   PointerToRawData;\n    DWORD   PointerToRelocations;\n    DWORD   PointerToLinenumbers;\n    WORD    NumberOfRelocations;\n    WORD    NumberOfLinenumbers;\n    DWORD   Characteristics;\n} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;\n\n// Linux section header definition (from coff.h)\n\nstruct COFF_scnhdr\n{\n  char s_name[8]; /* section name */\n  char s_paddr[4]; /* physical address, aliased s_nlib */\n  char s_vaddr[4]; /* virtual address */\n  char s_size[4]; /* section size */\n  char s_scnptr[4]; /* file ptr to raw data */\n  char s_relptr[4]; /* file ptr to relocation */\n  char s_lnnoptr[4]; /* file ptr to line numbers */\n  char s_nreloc[2]; /* number of relocation entries */\n  char s_nlnno[2]; /* number of line number entries */\n  char s_flags[4]; /* flags */\n};\n```", "```\n\n\t\t\tprogram t;\n#include( \"bits.hhf\" )\n\nbegin t;\n\nbits.cnt( 5 );\nbits.reverse32( 10 );\n\nend t;\n\nHere is the source code to the bits.cnt library module:\n\nunit bitsUnit;\n\n#includeonce( \"bits.hhf\" );\n\n    // bitCount-\n    //\n    //  Counts the number of \"1\" bits in a dword value.\n    //  This function returns the dword count value in EAX.\n\n    procedure bits.cnt( BitsToCnt:dword ); @nodisplay;\n\n    const\n        EveryOtherBit       := $5555_5555;\n        EveryAlternatePair  := $3333_3333;\n        EvenNibbles         := $0f0f_0f0f;\n\n    begin cnt;\n\n        push( edx );\n        mov( BitsToCnt, eax );\n        mov( eax, edx );\n\n        // Compute sum of each pair of bits\n        // in EAX. The algorithm treats\n        // each pair of bits in EAX as a\n        // 2-bit number and calculates the\n        // number of bits as follows (description\n        // is for bits 0 and 1, but it generalizes\n        // to each pair):\n        //\n        //  EDX =   BIT1  BIT0\n        //  EAX =      0  BIT1\n        //\n        //  EDX-EAX =   00 if both bits were 0.\n        //              01 if Bit0 = 1 and Bit1 = 0.\n        //              01 if Bit0 = 0 and Bit1 = 1.\n        //              10 if Bit0 = 1 and Bit1 = 1.\n        //\n        // Note that the result is left in EDX.\n\n        shr( 1, eax );\n        and( EveryOtherBit, eax );\n        sub( eax, edx );\n\n        // Now sum up the groups of 2 bits to\n        // produces sums of 4 bits. This works\n        // as follows:\n        //\n        //  EDX = bits 2,3, 6,7, 10,11, 14,15, ..., 30,31\n        //        in bit positions 0,1, 4,5, ..., 28,29 with\n        //        0s in the other positions.\n        //\n        //  EAX = bits 0,1, 4,5, 8,9, ... 28,29 with 0s\n        //        in the other positions.\n        //\n        //  EDX + EAX produces the sums of these pairs of bits.\n        //  The sums consume bits 0,1,2, 4,5,6, 8,9,10, ...\n        //                                            28,29,30\n        //  in EAX with the remaining bits all containing 0.\n        mov( edx, eax );\n        shr( 2, edx );\n        and( EveryAlternatePair, eax );\n        and( EveryAlternatePair, edx );\n        add( edx, eax );\n\n        // Now compute the sums of the even and odd nibbles in\n        // the number. Since bits 3, 7, 11, etc. in EAX all\n        // contain 0 from the above calculation, we don't need\n        // to AND anything first, just shift and add the two\n        // values.\n        // This computes the sum of the bits in the 4 bytes\n        // as four separate values in EAX (AL contains number of\n        // bits in original AL, AH contains number of bits in\n        // original AH, etc.)\n\n        mov( eax, edx );\n        shr( 4, eax );\n        add( edx, eax );\n        and( EvenNibbles, eax );\n\n        // Now for the tricky part.\n        // We want to compute the sum of the 4 bytes\n        // and return the result in EAX. The following\n        // multiplication achieves this. It works\n        // as follows:\n        //  (1) the $01 component leaves bits 24..31\n        //      in bits 24..31.\n        //\n        //  (2) the $100 component adds bits 17..23\n        //      into bits 24..31.\n        //\n        //  (3) the $1_0000 component adds bits 8..15\n        //      into bits 24..31.\n        //\n        //  (4) the $1000_0000 component adds bits 0..7\n        //      into bits 24..31.\n        //\n        //  Bits 0..23 are filled with garbage, but bits\n        //  24..31 contain the actual sum of the bits\n        //  in EAX's original value. The SHR instruction\n        //  moves this value into bits 0..7 and zeros\n        //  out the HO bits of EAX.\n\n        intmul( $0101_0101, eax );\n        shr( 24, eax );\n\n        pop( edx );\n\n    end cnt;\n\nend bitsUnit;\n```", "```\n\n\t\t\tunit bitsUnit;\n\n#include( \"bits.hhf\" );\n\n    procedure bits.reverse32( BitsToReverse:dword ); @nodisplay; @noframe;\n    begin reverse32;\n\n        push( ebx );\n        mov( [esp+8], eax );\n\n        // Swap the bytes in the numbers:\n\n        bswap( eax );\n\n        // Swap the nibbles in the numbers\n\n        mov( $f0f0_f0f0, ebx );\n        and( eax, ebx );\n        and( $0f0f_0f0f, eax );\n        shr( 4, ebx );\n        shl( 4, eax );\n        or( ebx, eax );\n\n        // Swap each pair of 2 bits in the numbers:\n\n        mov( eax, ebx );\n        shr( 2, eax );\n        shl( 2, ebx );\n        and( $3333_3333, eax );\n        and( $cccc_cccc, ebx );\n        or( ebx, eax );\n\n        // Swap every other bit in the number:\n\n        lea( ebx, [eax + eax] );\n        shr( 1, eax );\n        and( $5555_5555, eax );\n        and( $aaaa_aaaa, ebx );\n        or( ebx, eax );\n        pop( ebx );\n        ret( 4 );\n    end reverse32;\n\n    procedure bits.reverse16( BitsToReverse:word );\n        @nodisplay; @noframe;\n    begin reverse16;\n\n        // Uninteresting code that is very similar to\n        // that appearing in reverse32 has been snipped...\n\n    end reverse16;\n\n    procedure bits.reverse8( BitsToReverse:byte );\n        @nodisplay; @noframe;\n    begin reverse8;\n\n        // Uninteresting code snipped...\n\n    end reverse8;\n\nend bitsUnit;\n```", "```\n\n\t\t\t  Address   opcodes            Assembly Instructions\n  --------- ------------------ -----------------------------\n  04001000: E9 EB 00 00 00     jmp         040010F0\n  04001005: E9 57 01 00 00     jmp         04001161\n  0400100A: E8 F1 00 00 00     call        04001100\n\n; Here's where the main program starts.\n\n  0400100F: 6A 00              push        0\n  04001011: 8B EC              mov         ebp,esp\n  04001013: 55                 push        ebp\n  04001014: 6A 05              push        5\n  04001016: E8 65 01 00 00     call        04001180\n  0400101B: 6A 0A              push        0Ah\n  0400101D: E8 0E 00 00 00     call        04001030\n  04001022: 6A 00              push        0\n  04001024: FF 15 00 20 00 04  call        dword ptr ds:[04002000h]\n\n;The following INT3 instructions are used as padding in order\n;to align the bits.reverse32 function (which immediately follows)\n;to a 16-byte boundary:\n\n  0400102A: CC                 int         3\n  0400102B: CC                 int         3\n  0400102C: CC                 int         3\n  0400102D: CC                 int         3\n  0400102E: CC                 int         3\n  0400102F: CC                 int         3\n\n; Here's where bits.reverse32 starts. Note that this address\n; is rounded up to a 16-byte boundary.\n\n  04001030: 53                 push        ebx\n  04001031: 8B 44 24 08        mov         eax,dword ptr [esp+8]\n  04001035: 0F C8              bswap       eax\n  04001037: BB F0 F0 F0 F0     mov         ebx,0F0F0F0F0h\n  0400103C: 23 D8              and         ebx,eax\n  0400103E: 25 0F 0F 0F 0F     and         eax,0F0F0F0Fh\n  04001043: C1 EB 04           shr         ebx,4\n  04001046: C1 E0 04           shl         eax,4\n  04001049: 0B C3              or          eax,ebx\n  0400104B: 8B D8              mov         ebx,eax\n  0400104D: C1 E8 02           shr         eax,2\n  04001050: C1 E3 02           shl         ebx,2\n  04001053: 25 33 33 33 33     and         eax,33333333h\n  04001058: 81 E3 CC CC CC CC  and         ebx,0CCCCCCCCh\n  0400105E: 0B C3              or          eax,ebx\n  04001060: 8D 1C 00           lea         ebx,[eax+eax]\n  04001063: D1 E8              shr         eax,1\n  04001065: 25 55 55 55 55     and         eax,55555555h\n  0400106A: 81 E3 AA AA AA AA  and         ebx,0AAAAAAAAh\n  04001070: 0B C3              or          eax,ebx\n  04001072: 5B                 pop         ebx\n  04001073: C2 04 00           ret         4\n\n; Here's where bits.reverse16 begins. As this function appeared\n; in the same file as bits.reverse32, and no alignment option\n; was specified in the source file, HLA and the linker won't\n; bother aligning this to any particular boundary. Instead, the\n; code immediately follows the bits.reverse32 function\n; in memory.\n\n  04001076: 53                 push        ebx\n  04001077: 50                 push        eax\n  04001078: 8B 44 24 0C        mov         eax,dword ptr [esp+0Ch]\n\n        .\n        .    ; uninteresting code for bits.reverse16 and\n        .    ; bits.reverse8 was snipped\n; end of bits.reverse8 code\n\n  040010E6: 88 04 24           mov         byte ptr [esp],al\n  040010E9: 58                 pop         eax\n  040010EA: C2 04 00           ret         4\n\n; More padding bytes to align the following function (used by\n; HLA exception handling) to a 16-byte boundary:\n\n  040010ED: CC                 int         3\n  040010EE: CC                 int         3\n  040010EF: CC                 int         3\n\n; Default exception return function (automatically generated\n; by HLA):\n\n  040010F0: B8 01 00 00 00     mov         eax,1\n  040010F5: C3                 ret\n\n; More padding bytes to align the internal HLA BuildExcepts\n; function to a 16-byte boundary:\n\n  040010F6: CC                 int         3\n  040010F7: CC                 int         3\n  040010F8: CC                 int         3\n  040010F9: CC                 int         3\n  040010FA: CC                 int         3\n  040010FB: CC                 int         3\n  040010FC: CC                 int         3\n  040010FD: CC                 int         3\n  040010FE: CC                 int         3\n  040010FF: CC                 int         3\n\n; HLA BuildExcepts code (automatically generated by the\n; compiler):\n\n  04001100: 58                 pop         eax\n  04001101: 68 05 10 00 04     push        4001005h\n  04001106: 55                 push        ebp\n\n        .\n        .    ; Remainder of BuildExcepts code goes here\n        .    ; along with some other code and data\n        .\n\n; Padding bytes to ensure that bits.cnt is aligned\n; on a 16-byte boundary:\n\n  0400117D: CC                 int         3\n  0400117E: CC                 int         3\n  0400117F: CC                 int         3\n\n; Here's the low-level machine code for the bits.cnt function:\n\n  04001180: 55                 push        ebp\n  04001181: 8B EC              mov         ebp,esp\n  04001183: 83 E4 FC           and         esp,0FFFFFFFCh\n  04001186: 52                 push        edx\n  04001187: 8B 45 08           mov         eax,dword ptr [ebp+8]\n  0400118A: 8B D0              mov         edx,eax\n  0400118C: D1 E8              shr         eax,1\n  0400118E: 25 55 55 55 55     and         eax,55555555h\n  04001193: 2B D0              sub         edx,eax\n  04001195: 8B C2              mov         eax,edx\n  04001197: C1 EA 02           shr         edx,2\n  0400119A: 25 33 33 33 33     and         eax,33333333h\n  0400119F: 81 E2 33 33 33 33  and         edx,33333333h\n  040011A5: 03 C2              add         eax,edx\n  040011A7: 8B D0              mov         edx,eax\n  040011A9: C1 E8 04           shr         eax,4\n  040011AC: 03 C2              add         eax,edx\n  040011AE: 25 0F 0F 0F 0F     and         eax,0F0F0F0Fh\n  040011B3: 69 C0 01 01 01 01  imul        eax,eax,1010101h\n  040011B9: C1 E8 18           shr         eax,18h\n  040011BC: 5A                 pop         edx\n  040011BD: 8B E5              mov         esp,ebp\n  040011BF: 5D                 pop         ebp\n  040011C0: C2 04 00           ret         4\n```", "```\n\n\t\t\t#include <stdio.h>\nint main( int argc )\n{\n      .\n      .\n      .\n    printf\n    (\n        \"%d %d %d %d %d \",\n        .\n        .\n        .\n    );\n    return( 0 );\n}\n\n; PowerPC assembly output from GCC:\n\n            .\n            .\n            .\n        ;The following sets up the\n        ; call to printf and calls printf:\n\n        addis r3,r31,ha16(LC0-L1$pb)\n        la r3,lo16(LC0-L1$pb)(r3)\n        lwz r4,64(r30)\n        lwz r5,80(r30)\n        lwz r6,1104(r30)\n        lwz r7,1120(r30)\n        lis r0,0x400\n        ori r0,r0,1120\n        lwzx r8,r30,r0\n        bl L_printf$stub ; Call to printf \"stub\" routine.\n\n        ;Return from main program:\n\n        li r0,0\n        mr r3,r0\n        lwz r1,0(r1)\n        lwz r0,8(r1)\n        mtlr r0\n        lmw r30,-8(r1)\n        blr\n\n; Stub, to call the external printf function.\n; This code does an indirect jump to the printf\n; function using the 32-bit L_printf$lazy_ptr\n; pointer that the linker can modify.\n\n        .data\n        .picsymbol_stub\nL_printf$stub:\n        .indirect_symbol _printf\n        mflr r0\n        bcl 20,31,L0$_printf\nL0$_printf:\n        mflr r11\n        addis r11,r11,ha16(L_printf$lazy_ptr-L0$_printf)\n        mtlr r0\n        lwz r12,lo16(L_printf$lazy_ptr-L0$_printf)(r11)\n        mtctr r12\n        addi r11,r11,lo16(L_printf$lazy_ptr-L0$_printf)\n        bctr\n.data\n.lazy_symbol_pointer\nL_printf$lazy_ptr:\n        .indirect_symbol _printf\n\n; The following is where the compiler places a 32-bit\n; pointer that the linker can fill in with the address\n; of the actual printf function:\n\n        .long dyld_stub_binding_helper\n```"]