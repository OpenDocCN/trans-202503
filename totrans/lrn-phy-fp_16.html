<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_205"/><span class="big">14</span><br/>NEWTON’S SECOND LAW AND DIFFERENTIAL EQUATIONS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">Isaac Newton accomplished a lot. Among the numerous physical and mathematical insights he left us are three numbered laws that bear his name. Newton’s second law is the most important of these; it provides a method for understanding the motion of an object if we know the forces that act on it. Newton’s third law is almost as significant; it’s a rule about how two objects interact. Newton’s first law, from a mathematical standpoint, is a corollary to Newton’s second law, so it seems the smallest of the three. But since Newton’s second law is sufficiently intuition shattering, it’s helpful to get our minds around something simpler before trying to grasp it. Newton’s first law serves well in this capacity; it makes a bold claim that seems obviously false.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_206"/>In this chapter, we’ll discuss Newton’s first law and then turn our attention to Newton’s second law in one linear dimension, such as a horizontal line or a vertical line. We’ll show how to think about Newton’s second law in a sequence of settings of increasing complexity, organized by what the forces depend on. We’ll start with constant forces, the simplest situation, before moving on to forces that depend only on time. Then we’ll turn to forces that depend on the velocity of the particle they act on, followed by forces that depend on both time and velocity. The techniques for solving Newton’s second law change as the forces involved depend on different physical quantities. We’ll introduce the Euler method for solving a differential equation and explore a number of situations in which Newton’s second law is the central principle that allows us some traction in understanding the motion of an object.</p>&#13;
<h3 class="h3" id="ch14lev1">Newton’s First Law</h3>&#13;
<p class="noindent">Let’s return to the air track of <a href="ch04.xhtml">Chapter 4</a>. If you give the car a little push on the air track and then let it go, it will travel at a constant speed until it hits the end of the track. After we stop pushing the car, it continues to move at some speed even with no force applied in the direction of motion. This tendency for moving objects to keep moving is called <em>inertia</em>. The idea of inertia is relevant in the one-dimensional spatial setting of the air track, and it’s also relevant in the unconstrained three-dimensional spatial setting of the world in which we live. The idea is important enough to be enshrined in a principle of physics called <em>Newton’s first law</em>. Here are three versions:</p>&#13;
<div class="quote">&#13;
<p class="noindent"><strong>Newton’s first law, Newton’s words [<a href="bib.xhtml#bib15"><span class="green">15</span></a>]</strong><br/><em>Every body perseveres in its state of being at rest or of moving uniformly straight forward, except insofar as it is compelled to change its state by forces impressed.</em></p>&#13;
</div>&#13;
<div class="quote">&#13;
<p class="noindent"><strong>Newton’s first law, poetic version</strong><br/> <em>A body in motion stays in motion. A body at rest stays at rest.</em></p>&#13;
</div>&#13;
<div class="quote">&#13;
<p class="noindent"><strong>Newton’s first law, modern version</strong><br/> <em>In the absence of applied forces, an object maintains the same velocity.</em></p>&#13;
</div>&#13;
<p class="indent">Recall that velocity is a vector, so maintaining the same velocity means keeping the same speed as well as the same direction. Since acceleration is change in velocity per unit of time, an equivalent way of expressing Newton’s first law is that in the absence of forces, an object experiences no acceleration.</p>&#13;
<p class="indent">Notice that Newton’s first law makes no mention of forces that were applied <em>in the past</em>. The point is that if there are no forces acting <em>now</em>, the velocity will stay constant now. Any time there are no forces present, the velocity will stay constant.</p>&#13;
<p class="indent">Why does Newton’s first law seem obviously false? Because we’re stuck on the surface of the earth, a place that is rife with forces we might fail to consider, friction and air resistance not least among them. Things are a bit simpler out in space. We can imagine one astronaut tossing a small wrench <span epub:type="pagebreak" id="page_207"/>to another at slow speed. The wrench just glides straight across the ship, perhaps rotating slowly about its center. That wrench is a great example of Newton’s first law.</p>&#13;
<p class="indent">Perhaps you’ve been in a car when the driver slams on the brakes so that books, papers, and toys go flying forward (with respect to the car’s seats). In my family, we celebrate these moments by shouting “Newton’s first law!” From a perspective outside the (decelerating) car, the books, papers, and toys are doing their best to travel in a straight line, at least for the short period of time before gravity and other objects put an end to their line-like motion.</p>&#13;
<p class="indent">Newton’s first law tells us that objects naturally go steady and straight. In practice, though, they don’t. Newton’s second law explains how and why.</p>&#13;
<h3 class="h3" id="ch14lev2">Newton’s Second Law in One Dimension</h3>&#13;
<p class="noindent">Newton’s first law tells us that when no forces are present, an object does not accelerate. Newton’s second law claims that acceleration is caused by forces.</p>&#13;
<div class="quote">&#13;
<p class="noindent"><strong>Newton’s second law, Newton’s words [<a href="bib.xhtml#bib15"><span class="green">15</span></a>]</strong><br/> <em>A change in motion is proportional to the motive force impressed and takes place along the straight line in which that force is impressed.</em></p>&#13;
</div>&#13;
<div class="quote">&#13;
<p class="noindent"><strong>Newton’s second law, poetic version</strong><br/> <em>An object’s acceleration is directly proportional to the net force acting on the object and inversely proportional to its mass.</em></p>&#13;
</div>&#13;
<p class="indent">Modern versions of Newton’s second law are expressed by Equation 14.1 for Newton’s second law in one dimension, and Equation 16.1 for Newton’s second law in three dimensions. In the remainder of this chapter, we’ll treat Newton’s second law in one dimension, which allows us to keep things simple by using numbers rather than vectors for velocity, acceleration, and force. In <a href="ch16.xhtml">Chapter 16</a>, we’ll treat Newton’s second law in full generality with vectors.</p>&#13;
<p class="indent">To discuss force and mass in a quantitative way, we need units of measure. In the SI system, force is measured in Newtons (N). A 100-N force has a different effect on a golf ball than it has on a bowling ball. According to Newton, each object has a <em>mass</em>, which determines the readiness of an object to accelerate in response to a force. A large-mass object experiences small acceleration compared to a small-mass object exposed to the same force. The SI unit of mass is the kilogram (kg).</p>&#13;
<p class="indent">Newton’s second law expresses a relationship between the following three quantities:</p>&#13;
<ul class="bull">&#13;
<li class="noindent">The forces that act on an object</li>&#13;
<li class="noindent">The mass of the object</li>&#13;
<li class="noindent">The acceleration of the object</li>&#13;
</ul>&#13;
<p class="indentt"><span epub:type="pagebreak" id="page_208"/>Newton’s second law says that the acceleration of an object can be found by dividing the net force acting on the object by the mass of the object. The <em>net force</em> acting on an object is the sum of all the forces acting on the object. In one dimension, some forces may be negative and some may be positive.</p>&#13;
<p class="indent">Newton’s second law is usually written as <em>F</em><sub>net</sub> = <em>ma</em>. Unlike the one-dimensional equations for velocity and acceleration (Equations 4.5 and 4.12), this equation is not an equality of functions. The acceleration of the object is only a function of time, but the net force generally depends on the time, the position of the object, and the velocity of the object. The net force at time <em>t</em> is <em>F</em><sub>net</sub> (<em>t</em>, <em>x</em>(<em>t</em>), <em>v</em>(<em>t</em>)). A better way to write Newton’s second law is:</p>&#13;
<div class="imagec"><img src="Images/208equ01.jpg" alt="Image" width="526" height="50"/></div>&#13;
<p class="indent">There is a chicken-and-egg issue going on with Newton’s second law. We know from Equations 4.5 and 4.12 that <em>v</em> = <em>Dx</em> and <em>a</em> = <em>Dv</em>. If we know the function <em>a</em> (meaning we know its value at all times), we can find the function <em>v</em> given an initial velocity. (See Equation 6.1 and the corresponding function <span class="literal">velFromAcc</span>.) We can then go on and find the function <em>x</em> given an initial position. (See Equation 6.5 and the corresponding function <span class="literal">posFromVel</span>.) But Newton’s second law is telling us that acceleration depends on the forces, which depend on the position and the velocity. To find the position of my object, it seems that I need to find the velocity, and for that I need the acceleration. However, the acceleration depends on both the position and the velocity.</p>&#13;
<p class="indent">There is a name for this particular kind of chicken-and-egg problem. Newton’s second law is an example of a <em>differential equation</em>. A differential equation is a relationship between derivatives of an unknown function, with the unknown function itself often regarded as the zeroth derivative. The unknown function in the case of Newton’s second law is usually either the position <em>x</em> or the velocity <em>v</em>. Velocity can be written as the first derivative of position (<em>v</em> = <em>Dx</em>), and acceleration can be written as the second derivative of position (<em>a</em> = <em>Dv</em> = <em>D</em><sup>2</sup><em>x</em>).</p>&#13;
<p class="indent">Newton’s second law looks more like a differential equation if we write it in terms of an unknown position function.</p>&#13;
<div class="imagec"><img src="Images/208equ02.jpg" alt="Image" width="465" height="25"/></div>&#13;
<p class="indent">This is a second-order differential equation because it is a relationship between the position function <em>x</em>, its first derivative <em>Dx</em>, and its second derivative <em>D</em><sup>2</sup><em>x</em>. The relationship for a particular physical object depends on the function <em>F</em><sub>net</sub>, which depends on the nature of the forces acting on the object.</p>&#13;
<p class="indent">In simple situations, the net force on an object may not depend on time, position, and velocity, but rather only on zero, one, or two of these physical quantities. In these simple situations, Newton’s second law may appear as something simpler than a second-order differential equation. <a href="ch14.xhtml#ch14tab1">Table 14-1</a> lists situations by the physical quantities that the forces depend on and gives the mathematical technique needed to solve Newton’s second law.</p>&#13;
<p class="tabcap" id="ch14tab1"><strong>Table 14-1:</strong> The Technique for Solving Newton’s Second Law, Based on Which Physical Quantities the Forces Depend On</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Forces depend only on</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Solution technique</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Nothing</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Algebra</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Time</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Integration</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Velocity</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">First-order differential equation</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Time and velocity</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">First-order differential equation</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">Time, position, and velocity</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">Second-order differential equation</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_209"/>A net force that depends on nothing is a constant net force. Its value remains constant over time, independent of time, position, or velocity. In the next several sections, we’ll look at constant forces, forces that depend only on time, forces that depend only on velocity, and forces that depend on both time and velocity. This restriction allows us to limit our attention in this chapter to first-order differential equations. In <a href="ch15.xhtml">Chapter 15</a>, we’ll look at the more general case of one-dimensional motion in which the net force can depend on time, position, <em>and</em> velocity.</p>&#13;
<h3 class="h3" id="ch14lev3">Second Law with Constant Forces</h3>&#13;
<p class="noindent">The simplest situation for Newton’s second law is when the net force is constant, independent of time, position, and velocity. Most problems in an introductory physics course are like this because they can be solved without differential equations and without a computer.</p>&#13;
<p class="indent">Let’s consider an example problem with constant forces.</p>&#13;
<p class="noindentt"><strong>Example 14.1.</strong> Suppose we have a car with mass 0.1 kg on an air track. The car is initially moving east at a speed of 0.6 m/s. Starting at time <em>t</em> = 0, we apply to this car a constant force of 0.04 N to the east. At the same time, our friend applies to the same car a constant force of 0.08 N to the west. What will the subsequent motion of the car look like? In particular, how will the velocity and the position of the car change in time?</p>&#13;
<p class="indentt"><a href="ch14.xhtml#ch14fig1">Figure 14-1</a> shows the schematic diagram.</p>&#13;
<div class="imagel" id="ch14fig1"><img src="Images/209fig01.jpg" alt="Image" width="477" height="273"/></div>&#13;
<p class="figcap"><em>Figure 14-1: Schematic diagram for Newton’s second law with constant forces</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_210"/>The constant net force <img class="inline" src="Images/210equ01.jpg" alt="Image" width="39" height="19"/> (superscript <em>c</em> for constant) acting on the object needs to be divided by the mass of the object to obtain the acceleration of the object. Because the net force is constant, the acceleration is also constant.</p>&#13;
<div class="imagec"><img src="Images/210equ02.jpg" alt="Image" width="394" height="44"/></div>&#13;
<p class="indent">We write <em>a</em>(<em>t</em>) rather than <em>a</em> for acceleration, not because acceleration changes with time, but because <em>a</em> is the acceleration function (type <span class="literal">R -&gt; R</span>) and <em>a</em>(<em>t</em>) is the acceleration (type <span class="literal">R</span>). We then integrate acceleration to obtain the velocity.</p>&#13;
<div class="imagec"><img src="Images/210equ03.jpg" alt="Image" width="424" height="44"/></div>&#13;
<p class="indent">The integrator that produces velocity contains a real number (type <span class="literal">R</span>) as state. This type is shown below the integrator in <a href="ch14.xhtml#ch14fig1">Figure 14-1</a>. This integrator remembers the current velocity so that it can be updated using the acceleration.</p>&#13;
<p class="indent">We then integrate the velocity to obtain the position.</p>&#13;
<div class="imagec"><img src="Images/210equ04.jpg" alt="Image" width="459" height="49"/></div>&#13;
<p class="indent">The wires of the diagram represent quantities that are continuously changing in time. Each wire in the diagram is labeled with a name and a type. For this diagram, all of the wire types are real numbers.</p>&#13;
<p class="indent">Rectangular boxes represent purely functional constants and functions. In other words, they are constants and functions that do not contain any state, so that the output is a function only of the input. The circular integrators contain states that must be combined with the input to produce the output. The integrators are labeled with the type of state they contain, which is the same as the type of the output from the integrator.</p>&#13;
<p class="indent">Before we write Haskell code to solve Newton’s second law for constant forces, we are going to write a few lines of code that need to be at the top of the source code file we build throughout this chapter. The first line turns on warnings, which I recommend doing because the compiler will warn you of things that are legal but unusual enough that they may not be what you intended. The second line gives the code in this chapter the module name <span class="literal">Newton2</span>. If we want to use functions we write here in later chapters, we’ll refer to the current code using its module name. A module name is optional, but if you use one, it must match the filename; in this case, the filename should be <em>Newton2.hs</em>. The third line loads the <span class="literal">gnuplot</span> graphics library so that we can make a graph. Imports like this must occur before any function definitions or type signatures.</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
module Newton2 where&#13;
&#13;
import Graphics.Gnuplot.Simple</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_211"/>Example 14.1 is typical of situations in which Newton’s second law applies. Given a mass, an initial velocity, and some forces, we are asked to produce velocity as a function of time. In the Haskell language, a solution to this example situation would be a (higher-order) function <span class="literal">velocityCF</span> (<span class="literal">CF</span> for constant forces) with the following type:</p>&#13;
<pre>velocityCF :: Mass&#13;
           -&gt; Velocity          -- initial velocity&#13;
           -&gt; [Force]           -- list of forces&#13;
           -&gt; Time -&gt; Velocity  -- velocity function</pre>&#13;
<p class="indent">Recall that there are (at least) two ways to read this type signature. On one reading, <span class="literal">velocityCF</span> takes four inputs—mass, initial velocity, a list of forces, and a time—and produces as output a real number representing velocity. An alternative reading is that <span class="literal">velocityCF</span> takes three inputs—mass, initial velocity, and a list of forces—and produces as output a <em>function</em> for how velocity changes with time. If we wanted to emphasize the latter viewpoint, we could write</p>&#13;
<pre>velocityCF :: Mass -&gt; Velocity -&gt; [Force] -&gt; (Time -&gt; Velocity)</pre>&#13;
<p class="noindent">but it means the same thing as the original type signature.</p>&#13;
<p class="indent">We used the types <span class="literal">Time</span>, <span class="literal">Mass</span>, <span class="literal">Velocity</span>, and <span class="literal">Force</span>. These are not built-in types in Haskell, so we’d better define what they mean. In one-dimensional mechanics, all of these quantities can be represented with real numbers, so we can write some type synonyms to define these types. Using a type synonym in which <span class="literal">R</span> stands for <span class="literal">Double</span>,</p>&#13;
<pre>type R = Double</pre>&#13;
<p class="noindent">we can write type synonyms for all of the other types:</p>&#13;
<pre>type Mass     = R&#13;
type Time     = R&#13;
type Position = R&#13;
type Velocity = R&#13;
type Force    = R</pre>&#13;
<p class="indent">The definitions for types <span class="literal">Mass</span>, <span class="literal">Time</span>, and so on, need not appear before their use in a type signature. Haskell allows definitions of constants, functions, and types before or after their use.</p>&#13;
<p class="indent">If we can write a function <span class="literal">velocityCF</span> with the type signature above, we will have solved not just Example 14.1, but all others like it. Our strategy in writing such a function is:</p>&#13;
<ul class="bull">&#13;
<li class="noindent">Find the net force by adding all of the forces</li>&#13;
<li class="noindent">Find the acceleration using Newton’s second law (Equation 14.3)</li>&#13;
<li class="noindent">Find the velocity from the acceleration (Equation 4.14 or 14.4)</li>&#13;
</ul>&#13;
<p class="indentt">Here’s a definition for <span class="literal">velocityCF</span> that expresses these three steps and has the type we claimed earlier.</p>&#13;
<span epub:type="pagebreak" id="page_212"/>&#13;
<pre>velocityCF m v0 fs&#13;
    = let fNet = sum fs       -- net force&#13;
          a0   = fNet / m     -- Newton's second law&#13;
          v t  = v0 + a0 * t  -- constant acceleration eqn&#13;
      in v</pre>&#13;
<p class="indent">To write the function <span class="literal">velocityCF</span>, we begin by naming the three inputs: mass <span class="literal">m</span>, initial velocity <span class="literal">v0</span>, and list of forces <span class="literal">fs</span>. We then use a <span class="literal">let</span> construction to define three local names for net force, acceleration, and velocity. To find the net force, we sum up the forces in the list using the built-in <span class="literal">sum</span> function. To find the acceleration, we divide the net force on the object by the mass of the object, as Newton’s second law prescribes.</p>&#13;
<p class="indent">The third equation in the <span class="literal">let</span> construction defines a local function <span class="literal">v</span> to represent the velocity function. We use Equation 4.14, one of the constant acceleration equations introduced in standard introductory physics textbooks, but we could just as easily have used Equation 14.4 in place of the second and third lines of the <span class="literal">let</span> construction. Notice that we have written the definition of <span class="literal">velocityCF</span> using the “three-input thinking” mentioned earlier. Exercise 14.1 asks you to rewrite the function using four-input thinking.</p>&#13;
<p class="indent">We can write a function <span class="literal">positionCF</span> that produces a position function given mass, initial position, initial velocity, and a list of constant forces.</p>&#13;
<pre>positionCF :: Mass&#13;
           -&gt; Position          -- initial position&#13;
           -&gt; Velocity          -- initial velocity&#13;
           -&gt; [Force]           -- list of forces&#13;
           -&gt; Time -&gt; Position  -- position function&#13;
positionCF m x0 v0 fs&#13;
    = let fNet = sum fs&#13;
          a0   = fNet / m&#13;
          x t  = x0 + v0 * t + a0*t**2 / 2&#13;
      in x</pre>&#13;
<p class="indent">Here, we have used Equation 4.15 or 14.5. Returning to Example 14.1, the velocity of the car as a function of time is</p>&#13;
<pre>velocityCF 0.1 0.6 [0.04, -0.08]</pre>&#13;
<p class="noindent">because 0.1 kg is the mass of the car, 0.6 m/s is its initial velocity, and the square-bracketed list contains the forces in Newtons. We can ask for the type of this function in GHCi, and we can ask for values of the velocity at specific times.</p>&#13;
<pre>Prelude&gt;  <span class="codestrong1">:l Newton2</span>&#13;
[1 of 1] Compiling Newton2         ( Newton2.hs, interpreted )&#13;
Ok, one module loaded.&#13;
*Newton2&gt;  <span class="codestrong1">:t velocityCF 0.1 0.6 [0.04, -0.08]</span>&#13;
velocityCF 0.1 0.6 [0.04, -0.08] :: Time -&gt; Velocity&#13;
*Newton2&gt; <span class="codestrong1">velocityCF 0.1 0.6 [0.04, -0.08] 0</span>&#13;
0.6&#13;
*Newton2&gt; <span class="codestrong1">velocityCF 0.1 0.6 [0.04, -0.08] 1</span>&#13;
0.2</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_213"/>Since we have the velocity function in hand, we can graph it. Let’s write the code to do so first. Most of the code below is for setting up a title, axis labels, and the name of the file we want produced. The interesting stuff is at the end, where we give a list of times at which to evaluate the function and the function itself.</p>&#13;
<pre>carGraph :: IO ()&#13;
carGraph&#13;
    = plotFunc [Title "Car on an air track"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Velocity of Car (m/s)"&#13;
               ,PNG "CarVelocity.png"&#13;
               ,Key Nothing&#13;
               ] [0..4 :: Time] (velocityCF 0.1 0.6 [0.04, -0.08])</pre>&#13;
<p class="indent">This code produces the graph in <a href="ch14.xhtml#ch14fig2">Figure 14-2</a>.</p>&#13;
<div class="imagel" id="ch14fig2"><img src="Images/213fig01.jpg" alt="Image" width="527" height="394"/></div>&#13;
<p class="figcap"><em>Figure 14-2: Car velocity as a function of time in Example 14.1</em></p>&#13;
<p class="indent">If you load this chapter’s module, <span class="literal">Newton2</span>, into GHCi and enter <span class="literal">carGraph</span>,</p>&#13;
<pre>*Newton2&gt; <span class="codestrong1">carGraph</span></pre>&#13;
<p class="noindent">you will not get any return value, but the function will produce a Portable Network Graphics (PNG) file named <em>CarVelocity.png</em> on your hard drive. Without the <span class="literal">PNG "CarVelocity.png"</span> option, the <span class="literal">carGraph</span> function would produce a graph on the screen.</p>&#13;
<p class="indent">Note that the negative acceleration in the graph in <a href="ch14.xhtml#ch14fig2">Figure 14-2</a> (which exists over the entire time interval from <em>t</em> = 0 to <em>t</em> = 4 s) does not mean that <span epub:type="pagebreak" id="page_214"/>the car is always slowing down. Rather, a negative acceleration means an acceleration to the west. The car slows down during the first 1.5 s as it is moving east but then begins to speed up as it moves west. When the acceleration and velocity of an object point in the same direction, the object speeds up. When the acceleration and velocity of an object point in opposite directions, the object slows down.</p>&#13;
<p class="indent">With the functions <span class="literal">velocityCF</span> and <span class="literal">positionCF</span>, we have general-purpose ways of solving any Newton’s second law type problem in one spatial dimension with constant forces. Next we’ll consider forces that change in time.</p>&#13;
<h3 class="h3" id="ch14lev4">Second Law with Forces That Depend Only on Time</h3>&#13;
<p class="noindent">The next situation for Newton’s second law is when the net force depends on time but not on position or velocity. <a href="ch14.xhtml#ch14fig3">Figure 14-3</a> shows a schematic diagram for Newton’s second law with forces that depend only on time.</p>&#13;
<div class="imagel" id="ch14fig3"><img src="Images/214fig01.jpg" alt="Image" width="533" height="435"/></div>&#13;
<p class="figcap"><em>Figure 14-3: Schematic diagram for Newton’s second law with forces that depend only on time</em></p>&#13;
<p class="indent">The constant number 1 is fed into an integrator to produce a value for time. (The time changes at a rate of 1 second per second.) As usual, wires are labeled with names and types. Integrators are labeled with the type of state they hold. Time is fed into the net force function <img class="inline" src="Images/e0214-01.jpg" alt="Image" width="39" height="21"/> (superscript <em>t</em> for time-dependent), which produces net force as output. To obtain the acceleration of the object, we need to divide the net force acting on the object by the object’s mass.</p>&#13;
<div class="imagec"><img src="Images/214equ01.jpg" alt="Image" width="406" height="46"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_215"/>We then integrate the acceleration to obtain the velocity,</p>&#13;
<div class="imagec"><img src="Images/215equ01.jpg" alt="Image" width="555" height="51"/></div>&#13;
<p class="noindent">and we integrate the velocity to obtain the position:</p>&#13;
<div class="imagec"><img src="Images/215equ02.jpg" alt="Image" width="403" height="192"/></div>&#13;
<p class="noindent">The wires of the diagram represent quantities that are continuously changing in time. Rectangular boxes represent pure functions, whereas circular elements contain state.</p>&#13;
<p class="indent">To solve Newton’s second law problems with forces that depend on time, we’d like a higher-order function that produces a velocity function, similar to <span class="literal">velocityCF</span> in the previous section. One difference is that now we need to provide a list of force <em>functions</em> rather than a list of numerical forces. We want a function <span class="literal">velocityFt</span> (the <span class="literal">Ft</span> suffix denotes that forces depend only on time) with the following type signature:</p>&#13;
<pre>velocityFt :: Mass -&gt; Velocity -&gt; [Time -&gt; Force] -&gt; Time -&gt; Velocity</pre>&#13;
<p class="indent">Given the mass of our object, its initial velocity, and a list of force functions, we want to produce a velocity function.</p>&#13;
<p class="indent">Because we’re going to do numerical integration to get the velocity function, we’ll add one additional parameter to this type signature, namely the time step for numerical integration. Thus, we arrive at the following definition for <span class="literal">velocityFt</span>:</p>&#13;
<pre>velocityFt :: R                 -- dt for integral&#13;
           -&gt; Mass&#13;
           -&gt; Velocity          -- initial velocity&#13;
           -&gt; [Time -&gt; Force]   -- list of force functions&#13;
           -&gt; Time -&gt; Velocity  -- velocity function&#13;
velocityFt dt m v0 fs&#13;
    = let fNet t = sum [f t | f &lt;- fs]&#13;
          a t = fNet t / m&#13;
      in antiDerivative dt v0 a</pre>&#13;
<p class="indent">In this definition, we begin by naming the inputs: <span class="literal">dt</span> for an integration time step, <span class="literal">m</span> for the mass of the object we are attending to, <span class="literal">v0</span> for the initial velocity of this object, and <span class="literal">fs</span> for a list of force functions. Note that the local variable for forces, <span class="literal">fs</span>, had type <span class="literal">[Force]</span> (or <span class="literal">[R]</span>) when used in <span class="literal">velocityCF</span> and <span class="literal">positionCF</span> for situations with constant forces, but it now has type <span class="literal">[Time -&gt;</span> <span class="literal">Force]</span> (or <span class="literal">[R -&gt; R]</span>) for situations with forces that depend on time.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_216"/>We again use a <span class="literal">let</span> construction to define local functions, a net force function, and an acceleration function. The net force function adds together the forces provided in the list <span class="literal">fs</span>. We might have hoped we could use the same line of code we used in <span class="literal">velocityCF</span>, namely <span class="literal">fNet = sum fs</span>, to sum the forces. After all, <span class="literal">fs</span> is still a list. The trouble is that <span class="literal">sum</span> works only with types that are instances of <span class="literal">Num</span>, as you can see if you look at the type of <span class="literal">sum</span>. So while it is happy to add numbers (type <span class="literal">R</span>), it is not happy to add functions (type <span class="literal">R -&gt; R</span>). Fortunately, we can evaluate the force functions at a time <span class="literal">t</span> introduced as an argument to <span class="literal">fNet</span> and then add the resulting numbers.</p>&#13;
<p class="indent">The acceleration function comes from Newton’s second law. Here, we might have hoped that we could divide the net force function by the mass to obtain the acceleration function, perhaps writing <span class="literal">a = fNet / m</span>. But recall that the division operator insists that it work with two values that have the same type and that this type be an instance of <span class="literal">Fractional</span>. The division operator does not want to work with functions. Again, we address this by evaluating the <span class="literal">fNet</span> function at the time <span class="literal">t</span> introduced as the argument to the acceleration function <span class="literal">a</span>.</p>&#13;
<p class="indent">Finally, the velocity comes from taking an antiderivative of the acceleration function. We defined the functions <span class="literal">antiDerivative</span> and <span class="literal">integral</span> in <a href="ch06.xhtml">Chapter 6</a>, but we’ll repeat their definitions here:</p>&#13;
<pre>antiDerivative :: R -&gt; R -&gt; (R -&gt; R) -&gt; (R -&gt; R)&#13;
antiDerivative dt v0 a t = v0 + integral dt a 0 t&#13;
&#13;
integral :: R -&gt; (R -&gt; R) -&gt; R -&gt; R -&gt; R&#13;
integral dt f a b&#13;
    = sum [f t * dt | t &lt;- [a+dt/2, a+3*dt/2 .. b - dt/2]]</pre>&#13;
<p class="indent">Note that <span class="literal">velocityFt dt m v0 fs</span> has type <span class="literal">R -&gt; R</span> and is the velocity function for an object with mass <span class="literal">m</span>, initial velocity <span class="literal">v0</span>, and list of force functions <span class="literal">fs</span>. This velocity function is part of the solution to the mechanics problem. Another part of the solution is a position function. We can write a function <span class="literal">positionFt</span> that produces a position function given mass, initial position, initial velocity, and a list of force functions.</p>&#13;
<pre>positionFt :: R                 -- dt for integral&#13;
           -&gt; Mass&#13;
           -&gt; Position          -- initial position&#13;
           -&gt; Velocity          -- initial velocity&#13;
           -&gt; [Time -&gt; Force]   -- list of force functions&#13;
           -&gt; Time -&gt; Position  -- position function&#13;
positionFt dt m x0 v0 fs&#13;
     = antiDerivative dt x0 (velocityFt dt m v0 fs)</pre>&#13;
<p class="indent">This function works by taking an antiderivative of the velocity function, which we find using <span class="literal">velocityFt</span>.</p>&#13;
<p class="indent">As an example of solving Newton’s second law with a time-dependent force, consider a child riding a bike. By working the pedals, the child arranges for the ground to apply a constant forward force of 10 N on the bike <span epub:type="pagebreak" id="page_217"/>for 10 seconds, after which the child coasts for the next 10 seconds. Following the coasting, the child returns to the 10-N force for another 10 seconds, and so on, as illustrated in <a href="ch14.xhtml#ch14fig4">Figure 14-4</a>.</p>&#13;
<div class="imagel" id="ch14fig4"><img src="Images/217fig01.jpg" alt="Image" width="476" height="375"/></div>&#13;
<p class="figcap"><em>Figure 14-4: Force as a function of time for a child on a bike</em></p>&#13;
<p class="indent">In this example, we’ll assume that air resistance is not important and that there is only one force on the bike.</p>&#13;
<p class="indent">Here is the equation for the time-dependent force of pedaling and coasting:</p>&#13;
<div class="imagec"><img src="Images/217equ01.jpg" alt="Image" width="682" height="50"/></div>&#13;
<p class="indent">The force is either 0 N or 10 N, depending on where the time falls in a 20-second cycle. If the time falls in the first 10 seconds of the cycle, the force is 10 N. If, on the other hand, the time falls in the last 10 seconds of the cycle, the force is 0 N.</p>&#13;
<p class="indent">Here is the time-dependent force of Equation 14.8 in Haskell:</p>&#13;
<pre>pedalCoast :: Time -&gt; Force&#13;
pedalCoast t&#13;
    = let tCycle = 20&#13;
          nComplete :: Int&#13;
          nComplete = truncate (t / tCycle)&#13;
          remainder = t - fromIntegral nComplete * tCycle&#13;
      in if remainder &lt; 10&#13;
         then 10&#13;
         else 0</pre>&#13;
<p class="indent">The local variable <span class="literal">tCycle</span> is the number of seconds for a full cycle. The variable <span class="literal">nComplete</span> uses the Prelude function <span class="literal">truncate</span> to calculate the number of complete cycles from the time <span class="literal">t</span>. The <span class="literal">truncate</span> function produces a type <span epub:type="pagebreak" id="page_218"/>with type class <span class="literal">Integral</span> (recall <span class="literal">Integer</span> and <span class="literal">Int</span> are instances of <span class="literal">Integral</span>). We provide a local type signature to say that we want <span class="literal">nComplete</span> to have type <span class="literal">Int</span>. The local type signature is optional, but the compiler will give us a warning that it chose a default type if we don’t specify something. Remove the local type signature to see what the warning looks like. This is a mild warning. We don’t mind that the compiler chooses <span class="literal">Integer</span> instead of <span class="literal">Int</span>. You can feel free to ignore this warning and use the code without the type signature if you wish.</p>&#13;
<p class="indent">The <span class="literal">remainder</span> is the number of seconds, between 0 and 20, that have elapsed since the beginning of the most recent cycle. We want <span class="literal">remainder</span> to be a real number, so we must use <span class="literal">fromIntegral</span> to convert <span class="literal">nComplete :: Int</span> into a real number.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14fig5">Figure 14-5</a> shows the position of the child as a function of time.</p>&#13;
<div class="imagel" id="ch14fig5"><img src="Images/218fig01.jpg" alt="Image" width="530" height="393"/></div>&#13;
<p class="figcap"><em>Figure 14-5: Position as a function of time for the child on a bike</em></p>&#13;
<p class="indent">Here is the Haskell code that produced <a href="ch14.xhtml#ch14fig5">Figure 14-5</a>:</p>&#13;
<pre>childGraph :: IO ()&#13;
childGraph&#13;
    = plotFunc [Title "Child pedaling then coasting"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Position of Bike (m)"&#13;
               ,PNG "ChildPosition.png"&#13;
               ,Key Nothing&#13;
               ] [0..40 :: R] (positionFt 0.1 20 0 0 [pedalCoast])</pre>&#13;
<p class="indent">The most interesting part of the code is the last line, where we specify the function we want plotted. This function, <span class="literal">positionFt 0.1 20 0 0 [pedalCoast]</span>, uses the <span class="literal">positionFt</span> function we developed earlier in the chapter with a time step of 0.1 s, a mass of 20 kg, 0s for initial position and initial velocity, and a list of forces that includes only the force of pedaling and coasting. All of the <span epub:type="pagebreak" id="page_219"/>relevant physical information is included in the “name” of the function we are plotting.</p>&#13;
<p class="indent">You can see from the graph in <a href="ch14.xhtml#ch14fig5">Figure 14-5</a> that during the first 10 seconds, the child’s position curve is parabolic, as we’d expect from constant acceleration. From 10 to 20 seconds, the position shows constant velocity while the child is coasting. From 20 to 30 seconds, there is another period of acceleration in which the position curve is parabolic, followed by a second period of coasting.</p>&#13;
<p class="indent">With the functions <span class="literal">velocityFt</span> and <span class="literal">positionFt</span>, we have general-purpose ways of solving any Newton’s second law type problem in one spatial dimension with forces that depend only on time. We’re now ready to look at forces that depend on velocity, the most common of which is air resistance.</p>&#13;
<h3 class="h3" id="ch14lev5">Air Resistance</h3>&#13;
<p class="noindent">In this section, we’ll make a short diversion from our path of considering Newton’s second law in the presence of forces that depend on time, velocity, neither, or both to develop an expression for the force of air resistance on an object in one-dimensional motion. Air resistance is a force that depends only on velocity, and we’ll use it in the next several sections as we develop ways to solve Newton’s second law with forces that depend on velocity.</p>&#13;
<p class="indent">Introductory physics classes typically ignore air resistance or treat it very lightly, because the presence of air resistance turns Newton’s second law into a differential equation, which is considered beyond the scope of an introductory physics course. In this chapter and the next, we’ll develop numerical methods for solving differential equations, meaning that air resistance is not something we want to avoid; in fact, it showcases the power of our tools.</p>&#13;
<p class="indent">To develop a model of air resistance, let’s think of the interaction between an object and the air around it as a collision. Suppose the object is moving with velocity <em>v</em>. In this section, <em>v</em> represents the real-valued, one-dimensional velocity of the object (a quantity with type <span class="literal">R</span>) and not the velocity function or the speed.</p>&#13;
<p class="indent">Let the cross-sectional area of the object be <em>A</em> and the density of air be <em>ρ</em>. We analyze the motion of the object over a small time interval <em>dt</em>. We assume that the initial velocity of the air is 0, and that the final velocity of the air is <em>v</em> (in other words, after the collision, the air is traveling at the same speed as the object).</p>&#13;
<p class="indent">The distance the object travels in time <em>dt</em> is <em>v dt</em>. The volume of air swept out by the object in time <em>dt</em> is <em>Av dt</em>. The mass of air disturbed by the object in time <em>dt</em> is <em>ρAv dt</em>. The momentum imparted to the air by the object in time <em>dt</em> is the product of the mass of the air, <em>ρAv dt</em>, and the change in velocity of the air, which is <em>v</em>, as we assume that the air starts from rest and ends the short time interval with velocity <em>v</em>. The momentum imparted to the air is <em>ρAv</em><sup>2</sup><em>dt</em>. The force felt by the air is this change in momentum per unit time, or <em>ρAv</em><sup>2</sup>. The force felt by the object from the air is equal and opposite to this following Newton’s third law, which we will discuss in <a href="ch19.xhtml">Chapter 19</a>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_220"/>Our derivation was really quite approximate because we don’t know that the air molecules really end up with velocity <em>v</em>, and we haven’t even tried to account for the forces of air molecules on each other as the air compresses. Nevertheless, the form of our result is quite useful and approximately correct. Objects with different shapes respond a bit differently though, so it is useful to introduce a <em>drag coefficient C</em> to account for these differences. The drag coefficient is a dimensionless constant that is a property of the object that is flying through the air. It is also conventional to include a factor of 1/2 so that the magnitude of the force of air resistance on the object is <em>CρA v</em><sup>2</sup>/2. This expression is never negative. We would prefer an expression in which the force is negative when the velocity is positive and positive when the velocity is negative. Our final expression for the one-dimensional force of air resistance is</p>&#13;
<div class="imagec"><img src="Images/220equ01.jpg" alt="Image" width="437" height="44"/></div>&#13;
<p class="noindent">where the minus sign and the absolute value ensure that the force acts in a direction opposite the velocity. Air resistance is acting to slow the object. In Haskell, we’ll write Equation 14.9 for air resistance as follows:</p>&#13;
<pre>fAir :: R  -- drag coefficient&#13;
     -&gt; R  -- air density&#13;
     -&gt; R  -- cross-sectional area of object&#13;
     -&gt; Velocity&#13;
     -&gt; Force&#13;
fAir drag rho area v = -drag * rho * area * abs v * v / 2</pre>&#13;
<p class="indent">In the mathematical notation of Equation 14.9, we’re treating <em>F</em><sub>air</sub> as a function of one variable. The parameters <em>C</em>, <em>ρ</em>, and <em>A</em> are not listed explicitly as variables that <em>F</em><sub>air</sub> depends on. Eliding parameters like this is standard practice in physics, but in some sense it’s an abuse of notation. In the Haskell notation, we must include all of the variables that the force of air resistance depends on. We list the three parameters first, before the <span class="literal">Velocity</span>, so that an expression like <span class="literal">fAir 1 1.225 0.6</span> is a fully legitimate function that takes only velocity as input. The function <span class="literal">fAir 1 1.225 0.6</span> has already chosen drag = 1, rho = 1.225, and area = 0.6.</p>&#13;
<p class="indent">With this brief foray into air resistance, and particularly the development of Equation 14.9, we’re now ready to look at Newton’s second law in the case where forces on our object depend only on its velocity.</p>&#13;
<h3 class="h3" id="ch14lev6">Second Law with Forces That Depend Only on Velocity</h3>&#13;
<p class="noindent">The next situation for Newton’s second law is when the net force depends on velocity but not on time or position. What we really mean here is that the forces do not depend <em>explicitly</em> on time. Velocity is a function that depends on time, and forces are allowed to depend on the velocity in this section, so there is a sense in which the forces depend on time. The constraint in this section is that the forces can depend on time <em>only through the velocity</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_221"/>The force functions may depend only on one variable, the velocity. We use <img class="inline" src="Images/e0221-01.jpg" alt="Image" width="23" height="25"/> to denote the <em>j</em>th force function of one variable that gives force when supplied with velocity and we use <img class="inline" src="Images/e0221-02.jpg" alt="Image" width="42" height="19"/> to denote the function of one variable that gives net force when supplied with velocity.</p>&#13;
<div class="imagec"><img src="Images/221equ01.jpg" alt="Image" width="186" height="51"/></div>&#13;
<p class="indent">We use <em>v</em><sub>0</sub> as a local variable for velocity (type <span class="literal">R</span>) rather than <em>v</em> in this section because we want <em>v</em> to stand for the velocity function of our object (type <span class="literal">R -&gt; R</span>).</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14fig6">Figure 14-6</a> shows a schematic diagram for Newton’s second law with forces that depend only on velocity.</p>&#13;
<div class="imagel" id="ch14fig6"><img src="Images/221fig01.jpg" alt="Image" width="589" height="376"/></div>&#13;
<p class="figcap"><em>Figure 14-6: Newton’s second law with forces that depend only on velocity</em></p>&#13;
<p class="indent">This diagram, unlike previous diagrams, contains a loop. The velocity produced by the integrator of acceleration serves as the input to the net force function. The loop in the diagram indicates that Newton’s second law produces a differential equation. Because the loop contains one integrator, we get a first-order differential equation. A differential equation is a more difficult mathematical problem than a mere integral or antiderivative, as we had when forces depended only on time.</p>&#13;
<p class="indent">Newton’s second law is given by the following equation:</p>&#13;
<div class="imagec"><img src="Images/221equ02.jpg" alt="Image" width="453" height="60"/></div>&#13;
<p class="indent">The information this equation represents is the same as the information in the schematic diagram of <a href="ch14.xhtml#ch14fig6">Figure 14-6</a>. The equation describes how the rate of change of velocity depends on velocity itself through the forces that act on the object. The function <span class="literal">newtonSecondV</span>, presented next, is yet a third way to express Newton’s second law; this function returns the rate of change <span epub:type="pagebreak" id="page_222"/>of velocity when given the current value of velocity along with the forces that act on the object.</p>&#13;
<pre>newtonSecondV :: Mass&#13;
              -&gt; [Velocity -&gt; Force]  -- list of force functions&#13;
              -&gt; Velocity             -- current velocity&#13;
              -&gt; R                    -- derivative of velocity&#13;
newtonSecondV m fs v0 = sum [f v0 | f &lt;- fs] / m</pre>&#13;
<p class="indent">We can integrate the acceleration to obtain the velocity.</p>&#13;
<div class="imagec"><img src="Images/222equ01.jpg" alt="Image" width="444" height="51"/></div>&#13;
<p class="indent">Unlike the case with time-dependent forces, we cannot simply perform the integral here because the velocity function we are trying to find appears under the integral. How to proceed?</p>&#13;
<p class="indent">To solve the differential equation, Equation 14.10, we will discretize time, which is something we have been doing with our numerical derivatives and integrals when we chose a time step. As long as our time step <em>Δt</em> is smaller than any important time scales in the situation we are addressing, the slope of the line connecting points (<em>t</em>, <em>v</em>(<em>t</em>)) and (<em>t</em> + Δ<em>t</em>, <em>v</em>(<em>t</em> + <em>Δt</em>)) will be approximately equal to the derivative of velocity at time <em>t</em>.</p>&#13;
<div class="imagec"><img src="Images/222equ02.jpg" alt="Image" width="196" height="44"/></div>&#13;
<p class="indent">Rearranging this equation leads to the <em>Euler method</em> for solving a first-order differential equation.</p>&#13;
<div class="imagec"><img src="Images/222equ03.jpg" alt="Image" width="455" height="44"/></div>&#13;
<p class="indent">The Euler method approximates the velocity at <em>t</em> + <em>Δ t</em> by the sum of the velocity at <em>t</em> and the product of the derivative at <em>t</em> with the time step <em>Δt</em>. The Euler method gives a way to find velocity at a later time from velocity at an earlier time if we know the derivative of velocity at the earlier time.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14fig7">Figure 14-7</a> pictorially describes the Euler method for solving Newton’s second law.</p>&#13;
<div class="imagel" id="ch14fig7"><img src="Images/223fig01.jpg" alt="Image" width="635" height="324"/></div>&#13;
<p class="figcap"><em>Figure 14-7: Euler method for Newton’s second law in one dimension, for the special case in which net force depends only on velocity</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_223"/>The diagram shows how data is acted on by pure functions to compute the velocity of the object at different times. Because the diagram employs only pure functions (functions that do nothing but return an output from inputs and unchanging global values), we refer to this as a <em>functional diagram</em>. Whereas the schematic diagram in <a href="ch14.xhtml#ch14fig6">Figure 14-6</a> presents time as continuous, this diagram shows time as discrete. And whereas the schematic diagram has wires with values that are continuously changing in time, the functional diagram has wires with values that do not change. Different points in time have different wires in the functional diagram. While a schematic diagram may contain the stateful integrator from <a href="ch06.xhtml#ch6fig5">Figure 6-5</a>, a functional diagram uncoils and replaces the integrator with a discrete, functional model like the one in <a href="ch06.xhtml#ch6fig7">Figure 6-7</a>. We can see from <a href="ch14.xhtml#ch14fig7">Figure 14-7</a> that the same set of computations occurs at each time step to produce a new velocity from an old velocity. We call the set of computations that occurs at each time step the <em>velocity-update function</em>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14fig8">Figure 14-8</a> shows the velocity-update function, which is based on the application of the Euler method to one small time step.</p>&#13;
<div class="imagel" id="ch14fig8"><img src="Images/224fig01.jpg" alt="Image" width="237" height="324"/></div>&#13;
<p class="figcap"><em>Figure 14-8: Velocity-update function used in the Euler method for solving Newton’s second law with forces that depend only on velocity</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_224"/><a href="ch14.xhtml#ch14fig8">Figure 14-8</a> shows a functional diagram for velocity update, visually describing how velocity at <em>t</em> + Δ<em>t</em> is computed from velocity at <em>t</em> and the forces.</p>&#13;
<p class="indent">Here is the velocity-update equation showing how a new velocity is obtained from an old velocity:</p>&#13;
<div class="imagec"><img src="Images/224equ01.jpg" alt="Image" width="473" height="44"/></div>&#13;
<p class="indent">Lastly, we have the Haskell function <span class="literal">updateVelocity</span>, which advances the value of the velocity by one time step.</p>&#13;
<pre>updateVelocity :: R                    -- time interval dt&#13;
               -&gt; Mass&#13;
               -&gt; [Velocity -&gt; Force]  -- list of force functions&#13;
               -&gt; Velocity             -- current velocity&#13;
               -&gt; Velocity             -- new velocity&#13;
updateVelocity dt m fs v0&#13;
   = v0 + (newtonSecondV m fs v0) * dt</pre>&#13;
<p class="indent">The functional diagram in <a href="ch14.xhtml#ch14fig8">Figure 14-8</a>, the velocity-update equation (Equation 14.12), and the function <span class="literal">updateVelocity</span> express the same information in different forms, namely how to take one step in time with the Euler method.</p>&#13;
<p class="indent">Now we want to write a function <span class="literal">velocityFv</span>, similar to <span class="literal">velocityCF</span> and <span class="literal">velocityFt</span>, but for the case of forces that depend on velocity. To think of <span class="literal">updateVelocity</span> as a function that takes <span class="literal">Velocity</span> as input and gives <span class="literal">Velocity</span> as output, we want to think of the time step, mass, and list of force functions as parameters. The function <span class="literal">updateVelocity dt m fs</span> has type <span class="literal">Velocity -&gt; Velocity</span> and plays the role of the iterable function <span class="literal">f</span> in <a href="ch06.xhtml#ch6fig4">Figure 6-4</a> on <a href="part02.xhtml#page_203">page 203</a>.</p>&#13;
<pre>velocityFv :: R                    -- time step&#13;
           -&gt; Mass&#13;
           -&gt; Velocity             -- initial velocity v(0)&#13;
           -&gt; [Velocity -&gt; Force]  -- list of force functions&#13;
           -&gt; Time -&gt; Velocity     -- velocity function&#13;
velocityFv dt m v0 fs t&#13;
    = let numSteps = abs $ round (t / dt)&#13;
      in iterate (updateVelocity dt m fs) v0 !! numSteps</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_225"/>We define a local variable <span class="literal">numSteps</span> to be the number of time steps we need to take to get as close as possible to the desired time <span class="literal">t</span>. We iterate the function <span class="literal">updateVelocity dt m fs</span>, starting at the initial velocity <span class="literal">v0</span>, and then select the single value of velocity from this infinite list that is closest to the desired time.</p>&#13;
<p class="indent">As an example of a situation with forces that depend only on velocity, let’s consider a bicycle rider heading north on a flat, level road. We’ll consider two forces in this situation. First, there is the northward force that the road exerts on the tires of the bicycle because the rider is working the pedals. Let us call this force <em>F</em><sub>rider</sub> (it is directly produced by the road on the bike, but it is indirectly produced by the rider), and assume that this force is a constant 100 N. Second, there is the southward force of air resistance that impedes the northward progress of the rider, especially when she is traveling quickly. We’ll use the expression for air resistance that we developed in the previous section with Equation 14.9. The net force is</p>&#13;
<div class="imagec"><img src="Images/225equ01.jpg" alt="Image" width="274" height="76"/></div>&#13;
<p class="indent">Let’s take the mass of the bike plus rider to be <em>m</em> = 70 kg. We’ll choose a drag coefficient of <em>C</em> = 2, take the density of air to be <em>ρ</em> = 1.225 kg/m<sup>3</sup>, and approximate the cross-sectional area of bike and rider to be 0.6 m<sup>2</sup>. Starting from rest, our mission is to find the velocity of the bike as a function of time.</p>&#13;
<p class="indent">Before we use our Haskell functions to investigate the motion of the bike, we’re going to show how to use the Euler method by hand.</p>&#13;
<h4 class="h4" id="ch14lev7">Euler Method by Hand</h4>&#13;
<p class="noindent">Let’s use the Euler method by hand to compute the first several values of velocity for the bike. The purpose in doing this is to get a clear understanding of what is happening in the Euler method, so the code we write will be meaningful and not just a formal representation of some abstract vague process. We choose a time step of 0.5 s. Our mission is to complete the following table. We can fill in all of the time values because they are simply spaced at 0.5 s intervals. The initial velocity is 0, so we fill that in as well.</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>t (s)</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>v(t) (m/s)</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0.5</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">1.0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">1.5</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"> </p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_226"/>We will complete the table by using Equation 14.12 to update the velocity over and over again. To compute the velocity at 0.5 s, we choose <em>t</em> = 0 in Equation 14.12.</p>&#13;
<div class="imagec"><img src="Images/226equ01.jpg" alt="Image" width="427" height="194"/></div>&#13;
<p class="indent">We update the table with</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>t (s)</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>v(t) (m/s)</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0.5</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0.7143</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">1.0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">1.5</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"> </p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">and then we calculate <em>v</em>(1.0 s) using Equation 14.12 with <em>t</em> = 0.5 s:</p>&#13;
<div class="imagec"><img src="Images/226equ02.jpg" alt="Image" width="618" height="232"/></div>&#13;
<p class="indent">We add this to the appropriate row of the table and continue.</p>&#13;
<div class="imagec"><img src="Images/226equ03.jpg" alt="Image" width="618" height="231"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_227"/>The completed table looks like this:</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>t (s)</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>v(t) (m/s)</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0.5</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0.7143</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">1.0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">1.4259</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">1.5</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">2.1295</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch14lev8">Euler Method in Haskell</h4>&#13;
<p class="noindent">Now we’ll use the <span class="literal">velocityFv</span> function to calculate velocity for the bike. Here is a velocity function for the bike with a time step of 1 s:</p>&#13;
<pre>bikeVelocity :: Time -&gt; Velocity&#13;
bikeVelocity = velocityFv 1 70 0 [const 100,fAir 2 1.225 0.6]</pre>&#13;
<p class="indent">The higher-order function <span class="literal">const</span> can be used to make a constant function. The function <span class="literal">const 100</span> takes one input, ignores it, and returns 100 as output. It is equivalent to the anonymous function <span class="literal">\_ -&gt; 100</span>. We’re using it here to represent the constant force of 100 N.</p>&#13;
<p class="indent">Notice the data that must be supplied to solve the bike problem. We provide the 70-kg mass, the 0 m/s initial velocity of the bike, and the two forces: <span class="literal">const 100</span>, a constant force of 100 N, and <span class="literal">fAir 2 1.225 0.6</span>, which is the force of air resistance with a drag coefficient of 2, an air density of 1.225 kg/m<sup>3</sup>, and a cross-sectional area of 0.6 m<sup>2</sup>.</p>&#13;
<p class="indent">Here is the code to produce a graph of velocity versus time:</p>&#13;
<pre>bikeGraph :: IO ()&#13;
bikeGraph = plotFunc [Title "Bike velocity"&#13;
                     ,XLabel "Time (s)"&#13;
                     ,YLabel "Velocity of Bike (m/s)"&#13;
                     ,PNG "BikeVelocity1.png"&#13;
                     ,Key Nothing&#13;
                     ] [0,0.5..60] bikeVelocity</pre>&#13;
<p class="indent">The code plots the <span class="literal">bikeVelocity</span> function, including a title and axis labels, and makes a PNG file that can be included in another document. <a href="ch14.xhtml#ch14fig9">Figure 14-9</a> contains the graph itself.</p>&#13;
<div class="imagel" id="ch14fig9"><img src="Images/228fig01.jpg" alt="Image" width="530" height="393"/></div>&#13;
<p class="figcap"><em>Figure 14-9: Bike velocity as a function of time. The stair-stepping look can be fixed and is discussed in the text.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_228"/>A phenomenon occurs in <a href="ch14.xhtml#ch14fig9">Figure 14-9</a> that does not occur in constant acceleration situations: the establishment of a terminal velocity. After 20 seconds or so, the forward force of the road (from the pedaling) matches the backward force of the air. At this point we have no net force (or a very small net force), and the velocity stays at the terminal velocity.</p>&#13;
<p class="indent">Why the stair-stepping look to <a href="ch14.xhtml#ch14fig9">Figure 14-9</a>? We used a time step of one second to do the calculation of the velocity function <span class="literal">bikeVelocity</span>, but then we asked the <span class="literal">plotFunc</span> function to give us a plot of that function every half a second. If we want a smooth plot, we have a couple of options. The simplest would be to ask for a plot with time values spaced at least one second apart. Alternatively, we could calculate the <span class="literal">bikeVelocity</span> function using a smaller time step. In any case, we shouldn’t ask for more resolution in the graph than we asked for in the function we are graphing.</p>&#13;
<p class="indent">With the functions <span class="literal">velocityFv</span> and <span class="literal">positionFv</span>, the latter of which you are asked to write in Exercise 14.4, we have general-purpose tools for solving any Newton’s second law type problem in one spatial dimension with forces that depend only on velocity. Before we turn to the case in which forces depend on both time and velocity, let’s take a moment to view what we’ve just done from a broader perspective.</p>&#13;
<h3 class="h3" id="ch14lev9">The State of a Physical System</h3>&#13;
<p class="noindent">A fruitful way to structure our thinking about Newton’s second law, and also later about the Maxwell equations, revolves around the concept of the <em>state</em> of a physical system, which is the collection of information needed to say precisely what is going on with the system <em>at a particular instant of time</em>.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_229"/>The state represents the current “state of affairs” of the system, containing enough information that future prediction can be based on the current state instead of past information about the system. The state evolves in time, changing according to some rule.</p>&#13;
<p class="indent">Given a physical system that we wish to understand, the state-based paradigm suggests the following conceptual division:</p>&#13;
<ol>&#13;
<li class="noindent">What information is required to specify the state of the system?</li>&#13;
<li class="noindent">What is the state at some initial time?</li>&#13;
<li class="noindent">By what rule does the state change with time?</li>&#13;
</ol>&#13;
<p class="indent">When we treated Newton’s second law with constant forces and forces that depend only on time, we did not use a state-based method because we did not need one. In those cases, we could use algebra or integration to find how the position and velocity of our object changed in time. When we looked at forces that depend on velocity, we had a schematic diagram with a loop that corresponded to a differential equation, shown in <a href="ch14.xhtml#ch14fig6">Figure 14-6</a>. The state-based method is particularly useful for differential equations.</p>&#13;
<p class="indent">There are three things to notice about <a href="ch14.xhtml#ch14fig6">Figure 14-6</a> that relate to the state-based method. First, notice that there is one integrator in the loop and that this integrator holds the value of velocity as state. Second, notice that the differential equation, Equation 14.10, gives an expression for the rate of change of velocity. Lastly, notice that the forces depend on velocity. For these three reasons, in the case where forces depend only on velocity, the state of the object consists of the velocity of the object.</p>&#13;
<p class="indent">In general, the answer to question 1 is a data type. The state of an object experiencing forces that depend only on the object’s velocity is a value of the data type <span class="literal">Velocity</span>. In the next section, where forces depend on time and velocity, the data type we will use for state is the pair <span class="literal">(Time,Velocity)</span>. As we consider more complex physical situations, the data type we use to hold the state of our physical system will contain more information.</p>&#13;
<p class="indent">Question 2 above is, in some sense, the smallest question. It may even be possible to do some analysis without an answer to question 2. But if we wish to know properties of a system at a later time, then we wish to know the state at a later time, and this typically requires knowing the state at some earlier time. The answer to question 2 is a value of the data type from question 1.</p>&#13;
<p class="indent">Question 3 requires a physical theory to answer. In the case of mechanics, Newton’s second law gives the rule by which the state changes in time.</p>&#13;
<p class="indent">Let’s see how the state-based method applies in the case where the forces on an object depend only on time and the velocity of the object.</p>&#13;
<h3 class="h3" id="ch14lev10">Second Law with Forces That Depend on Time and Velocity</h3>&#13;
<p class="noindent">The next situation for Newton’s second law is when the forces depend on both time and velocity but not on position. The force functions depend on <span epub:type="pagebreak" id="page_230"/>two variables, time and velocity. We use <img class="inline" src="Images/e0230-01.jpg" alt="Image" width="31" height="27"/> to denote the <em>j</em>th function of two variables that gives a force when supplied with time and velocity, and we use <img class="inline" src="Images/e0230-02.jpg" alt="Image" width="50" height="21"/> to denote the function of two variables that gives net force when supplied with time and velocity.</p>&#13;
<div class="imagec"><img src="Images/230equ01.jpg" alt="Image" width="225" height="51"/></div>&#13;
<p class="indent"><a href="ch14.xhtml#ch14fig10">Figure 14-10</a> shows a schematic diagram for Newton’s second law with forces that depend on time and velocity.</p>&#13;
<div class="imagel" id="ch14fig10"><img src="Images/230fig01.jpg" alt="Image" width="607" height="464"/></div>&#13;
<p class="figcap"><em>Figure 14-10: Newton’s second law with forces that depend on time and velocity</em></p>&#13;
<p class="indent">The schematic diagram contains a loop, so Newton’s second law is a differential equation, given in Equation 14.14.</p>&#13;
<div class="imagec"><img src="Images/230equ02.jpg" alt="Image" width="466" height="111"/></div>&#13;
<p class="indent">Notice that there is one integrator in the loop in <a href="ch14.xhtml#ch14fig10">Figure 14-10</a>, which holds the value of velocity as state. There is a way to solve this differential equation using only velocity as the state of the object. However, since the rate of change of velocity in Equation 14.14 depends on both time and velocity (because the forces depend on time and velocity), the state-based method <span epub:type="pagebreak" id="page_231"/>is simpler to apply if we allow both time and velocity to be <em>state variables</em>. This is to say that the data type we will use for state is <span class="literal">(Time,Velocity)</span>. The difference between Equation 14.10, which expresses Newton’s second law with forces that depend only on velocity, and Equation 14.14, which expresses Newton’s second law with forces that depend on time and/or velocity, is simply that we need to know the current value of time in the latter case but not in the former. Including time in the state <span class="literal">(Time,Velocity)</span> is a simple way to gain convenient access to the current time.</p>&#13;
<p class="indent">Which quantities deserve to be called state variables? Say I have a particle in space acted on by a known (time-independent) force law. The state variables are the position and velocity because we can calculate the position and velocity at the next time instant from them. Why is acceleration not a state variable? To use the terminology of earlier sections in this chapter, state variables are numbers that identify a particular solution to the differential equation—they are the initial values that convert integrals into antiderivatives. Time is usually not considered a state variable, but taking it as one makes it easier to think about time-dependent forces. Readers interested in a more in-depth discussion of state variables and their uses are encouraged to see [<strong><a href="bib.xhtml#bib16"><span class="green">16</span></a></strong>] and [<strong><a href="bib.xhtml#bib17"><span class="green">17</span></a></strong> ].</p>&#13;
<p class="indent">The Haskell function <span class="literal">newtonSecondTV</span>, shown below, expresses Newton’s second law in the case where forces depend on time and velocity.</p>&#13;
<pre>newtonSecondTV :: Mass&#13;
               -&gt; [(Time,Velocity) -&gt; Force]  -- force funcs&#13;
               -&gt; (Time,Velocity)             -- current state&#13;
               -&gt; (R,R)                       -- deriv of state&#13;
newtonSecondTV m fs (t,v0)&#13;
    = let fNet = sum [f (t,v0) | f &lt;- fs]&#13;
          acc = fNet / m&#13;
      in (1,acc)</pre>&#13;
<p class="indent">Given the mass of an object and a list of forces that act on the object, now expressed as functions of the state <span class="literal">(Time,Velocity)</span>, <span class="literal">newtonSecondTV</span> gives instructions for computing the time derivatives of the state variables from the state variables themselves. The return type <span class="literal">(R,R)</span> is meant to stand for time derivative of time, which is always the dimensionless number 1, and time derivative of velocity, which is acceleration. The acceleration is computed from Newton’s second law by finding the net force and dividing by the mass.</p>&#13;
<p class="indent">To solve Equation 14.14, we will discretize time and use the Euler method. We’ll continue to use Equation 14.11 for the Euler method. <a href="ch14.xhtml#ch14fig11">Figure 14-11</a> pictorially describes the Euler method for solving Newton’s second law when forces depend on time and/or velocity.</p>&#13;
<div class="imagel" id="ch14fig11"><img src="Images/232fig01.jpg" alt="Image" width="589" height="403"/></div>&#13;
<p class="figcap"><em>Figure 14-11: Euler method for Newton’s second law in one dimension, for the special case in which net force depends only on time and/or velocity</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_232"/>The diagram shows how functions act on the state variables at one point in time to compute the state variables at the next point in time. The same set of computations reoccurs at each time step to produce a new state from an old state. We call the set of computations that occurs at each time step the <em>state-update function</em>.</p>&#13;
<p class="indent">The state-update function is shown pictorially in <a href="ch14.xhtml#ch14fig12">Figure 14-12</a>. The figure shows a functional diagram for state update, visually describing how time and velocity at <em>t</em> + Δ<em>t</em> are computed from time and velocity at <em>t</em>, given the force functions.</p>&#13;
<div class="imagel" id="ch14fig12"><img src="Images/232fig02.jpg" alt="Image" width="290" height="391"/></div>&#13;
<p class="figcap"><em>Figure 14-12: Euler method update for Newton’s second law with forces that depend only on time and velocity</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_233"/>Here are the state-update equations showing how the new state variables are obtained from the old state variables:</p>&#13;
<div class="imagec"><img src="Images/233equ01.jpg" alt="Image" width="480" height="77"/></div>&#13;
<p class="indent">Equations 14.15 and 14.16 are state-update equations for an object exposed to forces that depend on time and velocity. The state-update equations tell us how the state variables time and velocity must be updated to advance to the next time step. The time update in Equation 14.15 is easy: we just add <em>Δt</em> to the old time to get the new time. To update the velocity in Equation 14.16, we compute an acceleration, multiply by a time step to get a change in velocity, and add that change to the old velocity. Applying these state-update equations is how we carry out the Euler method for solving a differential equation. This state-update procedure is the main tool we will use to solve problems in Newtonian mechanics.</p>&#13;
<p class="indent">The following Haskell function <span class="literal">updateTV</span>, named because it updates both time and velocity, advances the value of the state by one time step.</p>&#13;
<pre>updateTV :: R                           -- time interval dt&#13;
         -&gt; Mass&#13;
         -&gt; [(Time,Velocity) -&gt; Force]  -- list of force funcs&#13;
         -&gt; (Time,Velocity)             -- current state&#13;
         -&gt; (Time,Velocity)             -- new state&#13;
updateTV dt m fs (t,v0)&#13;
    = let (dtdt, dvdt) = newtonSecondTV m fs (t,v0)&#13;
      in (t  + dtdt * dt&#13;
         ,v0 + dvdt * dt)</pre>&#13;
<p class="indent">The function <span class="literal">updateTV</span> takes a few parameters and produces a function with type <span class="literal">(Time,Velocity) -&gt; (Time,Velocity)</span>. The third input of <span class="literal">updateTV</span>, named <span class="literal">fs</span> with type <span class="literal">[(Time,Velocity) -&gt; Force]</span>, could have been an input with type <span class="literal">[Time -&gt; Velocity -&gt; Force]</span>; it’s a matter of style, and either choice will work just fine. Here I chose the former, as time and velocity are already paired in the function output.</p>&#13;
<p class="indent">The time-velocity pair we are passing around in this function represents the state of the object to which we are applying Newton’s second law. The function <span class="literal">updateTV</span> is then an example of a state-update function. In an earlier section, when forces depended only on velocity, the velocity alone acted as state, and the function <span class="literal">updateVelocity</span> was the appropriate state-update function.</p>&#13;
<p class="indent">The functional diagram in <a href="ch14.xhtml#ch14fig12">Figure 14-12</a>, Equations 14.15 and 14.16, and the function <span class="literal">updateTV</span> express the same information in different forms, namely how to take one step in time with the Euler method.</p>&#13;
<p class="indent">Depending on what we want to calculate, there are two things we might do with the <span class="literal">updateTV</span> function, corresponding to two types of representation of the time-velocity data. First, we may wish to produce a list of time-velocity <span epub:type="pagebreak" id="page_234"/>pairs. Second, we may wish to produce velocity as a function of time. We’ll develop functions for these two purposes in the next two subsections.</p>&#13;
<h4 class="h4" id="ch14lev11">Method 1: Produce a List of States</h4>&#13;
<p class="noindent">A list of time-velocity pairs can be regarded as a solution to a Newton’s second law problem with forces that depend on time and velocity because a time-velocity pair gives the state. The list of states contains a time-velocity pair for each time that has been probed by the Euler method in <a href="ch14.xhtml#ch14fig11">Figure 14-11</a>. The function <span class="literal">statesTV</span> produces a list of time-velocity pairs when given a time step, a mass, an initial state, and a list of force functions.</p>&#13;
<pre>statesTV :: R                           -- time step&#13;
         -&gt; Mass&#13;
         -&gt; (Time,Velocity)             -- initial state&#13;
         -&gt; [(Time,Velocity) -&gt; Force]  -- list of force funcs&#13;
         -&gt; [(Time,Velocity)]           -- infinite list of states&#13;
statesTV dt m tv0 fs&#13;
    = iterate (updateTV dt m fs) tv0</pre>&#13;
<p class="indent">We use <span class="literal">iterate</span> to achieve the repeated composition in <a href="ch14.xhtml#ch14fig11">Figure 14-11</a>. But which function do we want to iterate? It’s not simply <span class="literal">updateTV</span> because <span class="literal">updateTV</span> takes three parameters as input before the time-velocity pair. The function we iterate must have type <span class="literal">a -&gt; a</span>, or in this case <span class="literal">(Time,Velocity) -&gt; (Time,Velocity)</span>. The solution is to give <span class="literal">updateTV</span> its first three parameters to form the function we send to <span class="literal">iterate</span>. The function we want to iterate is <span class="literal">updateTV dt m fs</span>, starting with the initial time-velocity pair <span class="literal">tv0</span>.</p>&#13;
<p class="indent">The function <span class="literal">statesTV</span> gives a general-purpose way of solving any Newton’s second law type problem in one spatial dimension with forces that depend only on time and velocity. By a solution, we mean an infinite list of states (time-velocity pairs) of the object, spaced one time step apart from each other.</p>&#13;
<h4 class="h4" id="ch14lev12">Method 2: Produce a Velocity Function</h4>&#13;
<p class="noindent">Now we want to write a function, <span class="literal">velocityFtv</span>, that is similar to <span class="literal">velocityCF</span>, <span class="literal">velocityFt</span>, and <span class="literal">velocityFv</span>, but for the case of forces that depend on time and velocity. We’ll use the infinite list produced by <span class="literal">statesTV</span>, picking out the particular time-velocity pair that comes closest to our desired time and using the Prelude function <span class="literal">snd</span> to return the velocity, unpaired from the time.</p>&#13;
<pre>velocityFtv :: R                          -- time step&#13;
           -&gt; Mass&#13;
           -&gt; (Time,Velocity)             -- initial state&#13;
           -&gt; [(Time,Velocity) -&gt; Force]  -- list of force funcs&#13;
           -&gt; Time -&gt; Velocity            -- velocity function&#13;
velocityFtv dt m tv0 fs t&#13;
   = let numSteps = abs $ round (t / dt)&#13;
     in snd $ statesTV dt m tv0 fs !! numSteps</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_235"/>With the functions <span class="literal">velocityFtv</span> and <span class="literal">positionFtv</span>, the latter of which you will be asked to write in Exercise 14.9, we have general-purpose ways of solving any Newton’s second law type problem in one spatial dimension with forces that depend only on time and velocity. Let’s now take a look at a situation that involves just such forces.</p>&#13;
<h3 class="h3" id="ch14lev13">Example: Pedaling and Coasting with Air Resistance</h3>&#13;
<p class="noindent">As an example of a situation with forces that depend on time and velocity, let’s reconsider our child bicycle rider who is pedaling and coasting, but now in the presence of air resistance. We’ll consider two forces in this situation. First, there’s the time-dependent force <em>F</em><sub>pc</sub>(<em>t</em>) of pedaling from Equation 14.8. Second, there’s the force of air resistance <em>F</em><sub>air</sub>(<em>v</em><sub>0</sub>) that impedes the motion of the child, for which we’ll use Equation 14.9. The net force is</p>&#13;
<div class="imagec"><img src="Images/e0235-01.jpg" alt="Image" width="241" height="26"/></div>&#13;
<p class="indent">The mass of the bike plus child is <em>m</em> = 20 kg. We’ll choose a drag coefficient of <em>C</em> = 2, take the density of air to be <em>ρ</em> = 1.225 kg/m<sup>3</sup>, and approximate the cross-sectional area of bike and rider to be 0.5 m<sup>2</sup>. Starting from rest, our mission is to find the velocity of the bike as a function of time.</p>&#13;
<p class="indent">We update the velocity with Equation 14.16. Before we use our Haskell functions to investigate the motion of the bike, we’ll show how to use the Euler method by hand.</p>&#13;
<h4 class="h4" id="ch14lev14">Euler Method by Hand</h4>&#13;
<p class="noindent">Let’s use the Euler method by hand to compute several values of velocity for the bike. Again, the purpose in doing the Euler method by hand is simply to get a clear picture of how the state variables get updated in the Euler method. We’ll pick a time step of 6 s, even though this is too big to get accurate results, as it is not small compared to relevant time scales, such as the 20-second cycle time. We choose a time step of 6 s so we can sample both pedaling and coasting over the first few time steps. Our mission is to complete the following table. We can fill in all of the time values because they are simply spaced at six-second intervals. The initial velocity is 0, so we’ll fill that in as well.</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>t (s)</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>v(t) (m/s)</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">    0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">    6</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">  12</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">  18</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"> </p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The force of pedaling is either 10 N or 0 N, depending on the value of the time.</p>&#13;
<div class="equationc"><em>F</em><sub>pc</sub>(0 s) = <em>F</em><sub>pc</sub>(6 s) = 10 N<br/><em>F</em><sub>pc</sub>(12 s) = <em>F</em><sub>pc</sub>(18 s) = 0 N</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_236"/>Repeatedly applying Equation 14.16, we obtain the following:</p>&#13;
<div class="imagec"><img src="Images/236equ01.jpg" alt="Image" width="696" height="447"/></div>&#13;
<p class="indent">The completed table looks like this:</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>t (s)</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>v(t) (m/s)</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">6</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">3.0000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">12</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">4.3463</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">18</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">0.8752</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let’s turn now to Haskell, using each of the two methods we discussed earlier.</p>&#13;
<h4 class="h4" id="ch14lev15">Method 1: Produce a List of States</h4>&#13;
<p class="noindent">Here we’ll use the function <span class="literal">statesTV</span> to produce an infinite list of velocity-time pairs called <span class="literal">pedalCoastAir</span> for the child on the bike.</p>&#13;
<pre>pedalCoastAir :: [(Time,Velocity)]&#13;
pedalCoastAir = statesTV 0.1 20 (0,0)&#13;
                [\(t,_) -&gt; pedalCoast t&#13;
                ,\(_,v) -&gt; fAir 2 1.225 0.5 v]</pre>&#13;
<p class="indent">Notice the data that must be supplied to solve this problem. We provide a 0.1-s time step, the 20-kg mass, an initial state consisting of 0 for the time and 0 for the velocity, and the two forces, expressed here as anonymous functions. The function <span class="literal">pedalCoast</span> is a function only of time, so it cannot be listed directly as a force function because a force function for <span class="literal">statesTV</span> takes <span epub:type="pagebreak" id="page_237"/>a time-velocity pair as input. The underscores are present because the pedaling function does not depend on the second item in the state, which happens to be velocity, and because air resistance does not depend on the first item in the state, which happens to be time.</p>&#13;
<p class="indent">A list of pairs is something we can plot with the <span class="literal">plotPath</span> function from the <span class="literal">gnuplot</span> library, but we need to truncate the list to a finite list before plotting, or <span class="literal">plotPath</span> will hang while trying to finish calculating an infinite list. In <span class="literal">pedalCoastAirGraph</span> below, we use the <span class="literal">takeWhile</span> function to extract the states with times less than or equal to 100 seconds.</p>&#13;
<pre>pedalCoastAirGraph :: IO ()&#13;
pedalCoastAirGraph&#13;
    = plotPath [Title "Pedaling and coasting with air"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Velocity of Bike (m/s)"&#13;
               ,PNG "pedalCoastAirGraph.png"&#13;
               ,Key Nothing&#13;
               ] (takeWhile (\(t,_) -&gt; t &lt;= 100)&#13;
                  pedalCoastAir)</pre>&#13;
<p class="indent">This code produces <a href="ch14.xhtml#ch14fig13">Figure 14-13</a>, which shows the velocity as a function of time for the child pedaling and coasting in the presence of air resistance.</p>&#13;
<div class="imagel" id="ch14fig13"><img src="Images/237fig01.jpg" alt="Image" width="535" height="393"/></div>&#13;
<p class="figcap"><em>Figure 14-13: Pedaling and coasting with air resistance</em></p>&#13;
<p class="indent">As expected, the child’s speed increases during the pedaling intervals and decreases during the coasting intervals.</p>&#13;
<h4 class="h4" id="ch14lev16">Method 2: Produce a Velocity Function</h4>&#13;
<p class="noindent">Now let’s use the function <span class="literal">velocityFtv</span> to produce a velocity function for the child on the bike.</p>&#13;
<span epub:type="pagebreak" id="page_238"/>&#13;
<pre>pedalCoastAir2 :: Time -&gt; Velocity&#13;
pedalCoastAir2 = velocityFtv 0.1 20 (0,0)&#13;
                 [\( t,_v) -&gt; pedalCoast t&#13;
                 ,\(_t, v) -&gt; fAir 1 1.225 0.5 v]</pre>&#13;
<p class="indent">The data we give to <span class="literal">pedalCoastAir2</span> is the same data we gave to <span class="literal">pedalCoastAir</span>. Because <span class="literal">pedalCoastAir2</span> is a function <span class="literal">R -&gt; R</span>, it can be plotted with the <span class="literal">plotFunc</span> function from the <span class="literal">gnuplot</span> package. It would produce the same graph as that in <a href="ch14.xhtml#ch14fig13">Figure 14-13</a>.</p>&#13;
<h3 class="h3" id="ch14lev17">Summary</h3>&#13;
<p class="noindent">This chapter discussed Newton’s first law and introduced Newton’s second law in the context of one-dimensional motion. The chapter presented a sequence of increasingly sophisticated settings for Newton’s second law. Easiest among them is when the forces on an object are constant, that is, unchanging in time. Next is when the forces on an object depend only on time, in which case we can apply integration to find the velocity and the position of the object. Forces that depend on velocity, such as the air resistance introduced in this chapter, require that we solve a differential equation, which is a more complex task than integration. The chapter also introduced the Euler method for solving a first-order differential equation. The Euler method, along with Newton’s second law, provides a rule for updating the state of the object we are tracking, allowing us to predict its future motion. The choice of state variables, or physical quantities contained in the state, is determined by what the forces depend on. If forces depend only on velocity, then velocity alone can serve as the particle state. If forces depend on time and velocity, we use time and velocity as state variables.</p>&#13;
<p class="indent">In the next chapter, we allow the forces to depend on position as well as time and velocity. This produces a second-order differential equation and requires that time, position, and velocity all be state variables.</p>&#13;
<h3 class="h3" id="ch14lev18">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 14.1.</strong> Write a function <span class="literal">velocityCF'</span> that does the same thing and has the same type signature as <span class="literal">velocityCF</span>, but in which the time <span class="literal">t :: Time</span> is listed explicitly on the left of the equal sign in the definition.</p>&#13;
<pre>velocityCF' :: Mass&#13;
            -&gt; Velocity          -- initial velocity&#13;
            -&gt; [Force]           -- list of forces&#13;
            -&gt; Time -&gt; Velocity  -- velocity function&#13;
velocityCF' m v0 fs t = undefined m v0 fs t</pre>&#13;
<p class="noindentts"><strong>Exercise 14.2.</strong> Using the <span class="literal">positionCF</span> function, make a graph for the position of the car on the air track in Example 14.1 as a function of time. Assume the initial position of the car is – 1 m.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_239"/><strong>Exercise 14.3.</strong> Write a function</p>&#13;
<pre>sumF :: [R -&gt; R] -&gt; R -&gt; R&#13;
sumF = undefined</pre>&#13;
<p class="noindentts">that adds a list of functions to produce a function that represents the sum. Replace <span class="literal">undefined</span> with your code, and feel free to include one or two variables to the left of the equal sign in the definition. Using <span class="literal">sumF</span>, we could write the first line in the <span class="literal">let</span> construction of <span class="literal">velocityFt</span> as <span class="literal">fNet = sumF fs</span>.</p>&#13;
<p class="noindentts"><strong>Exercise 14.4.</strong> Write a Haskell function</p>&#13;
<pre>positionFv :: R                   -- time step&#13;
           -&gt; Mass&#13;
           -&gt; Position            -- initial position x(0)&#13;
           -&gt; Velocity            -- initial velocity v(0)&#13;
           -&gt; [Velocity -&gt; Force] -- list of force functions&#13;
           -&gt; Time -&gt; Position    -- position function&#13;
positionFv = undefined</pre>&#13;
<p class="noindentts">that returns a position function for a Newton’s second law situation in which the forces depend only on the velocity. Replace the <span class="literal">undefined</span> with your code, and feel free to include variables to the left of the equal sign in the definition.</p>&#13;
<p class="noindentts"><strong>Exercise 14.5.</strong> Any Newton’s second law problem that can be solved with <span class="literal">velocityFv</span> can also be solved with <span class="literal">velocityFtv</span>. Rewrite the <span class="literal">bikeVelocity</span> function so that it uses <span class="literal">velocityFtv</span> instead of <span class="literal">velocityFv</span>.</p>&#13;
<p class="noindentts"><strong>Exercise 14.6.</strong> Doing the Euler method by hand on <a href="ch14.xhtml#page_225">page 225</a>, we found the velocity after 1.5 s to be <em>v</em>(1.5 s) = 2.1295 m/s. Use the <span class="literal">velocityFv</span> function to calculate this same number.</p>&#13;
<p class="noindentts"><strong>Exercise 14.7.</strong> Doing the Euler method by hand on <a href="ch14.xhtml#page_235">page 235</a>, we found the velocity after 18 s to be <em>v</em>(18 s) = 0.8752 m/s. Use <span class="literal">statesTV</span> or <span class="literal">velocityFtv</span> to calculate this same number.</p>&#13;
<p class="noindentts"><strong>Exercise 14.8.</strong> Fix the stair-stepping issue in <a href="ch14.xhtml#ch14fig9">Figure 14-9</a> so that a smooth plot appears.</p>&#13;
<p class="noindentts"><strong>Exercise 14.9.</strong> Write a Haskell function</p>&#13;
<pre>positionFtv :: R                    -- time step&#13;
            -&gt; Mass&#13;
            -&gt; Position             -- initial position x(0)&#13;
            -&gt; Velocity             -- initial velocity v(0)&#13;
            -&gt; [(Time,Velocity) -&gt; Force]  -- force functions&#13;
            -&gt; Time -&gt; Position     -- position function&#13;
positionFtv = undefined</pre>&#13;
<p class="noindentts">that returns a position function for a Newton’s second law situation in which the forces depend only on time and velocity. Replace the <span class="literal">undefined</span> with your code, and feel free to include variables to the left of the equal sign in the definition.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_240"/><strong>Exercise 14.10.</strong> Produce a graph of position versus time for the situation in <a href="ch14.xhtml#ch14fig13">Figure 14-13</a>.</p>&#13;
<p class="noindentts"><strong>Exercise 14.11.</strong> To deepen our understanding of the Euler method, we’ll do a calculation by hand (using only a calculator and not the computer).</p>&#13;
<p class="indent">Consider a 1-kg mass exposed to two forces. The first force is an oscillatory force, pushing first one way and then the other. With <em>t</em> in seconds, the force in Newtons is given by</p>&#13;
<div class="equationc"><em>F</em><sub>1</sub>(<em>t</em>) = 4 cos 2<em>t</em></div>&#13;
<p class="indent">The second force is an air resistance force in Newtons, given by</p>&#13;
<div class="equationc"><em>F</em><sub>2</sub>(<em>v</em><sub>0</sub>) = –3<em>v</em><sub>0</sub></div>&#13;
<p class="noindentts">where <em>v</em><sub>0</sub> is the current velocity of the mass in meters per second.</p>&#13;
<p class="indent">The net force is</p>&#13;
<div class="imagec"><img src="Images/e0240-01.jpg" alt="Image" width="360" height="23"/></div>&#13;
<p class="indent">Suppose the mass is initially moving 2 m/s so that</p>&#13;
<div class="equationc"><em>v</em>(0 s) = 2 m/s</div>&#13;
<p class="indent">Use the Euler method with a time step of Δ<em>t</em> = 0.1 s to approximate the value of <em>v</em>(0.3s). Keep at least four figures after the decimal point in your calculations. Show your calculations in a small table.</p>&#13;
<p class="noindentts"><strong>Exercise 14.12.</strong> Write a Haskell function</p>&#13;
<pre>updateExample :: (Time,Velocity)  -- starting state&#13;
              -&gt; (Time,Velocity)  -- ending state&#13;
updateExample = undefined</pre>&#13;
<p class="noindentts">that takes a time-velocity pair (<em>t</em><sub>0</sub>, <em>v</em><sub>0</sub>) and returns an updated time-velocity pair (<em>t</em><sub>1</sub>, <em>v</em><sub>1</sub>) for a single step of the Euler method for a 1-kg object experiencing a net force of</p>&#13;
<div class="imagec"><img src="Images/e0240-02.jpg" alt="Image" width="360" height="23"/></div>&#13;
<p class="indent">Use a time step of Δ<em>t</em> = 0.1 s. Show how to use the function updateExample to calculate the value <em>v</em>(0.3 s) that you calculated by hand in Exercise 14.11.</p>&#13;
<p class="noindentts"><strong>Exercise 14.13.</strong> Consider a 1-kg object experiencing a net force</p>&#13;
<div class="imagec"><img src="Images/e0240-03.jpg" alt="Image" width="156" height="23"/></div>&#13;
<p class="noindentts">where <em>α</em> = 1 N s/m, subject to the initial condition <em>v</em>(0 s) = 8 m/s. Use the Euler method to find the velocity of the object over the time interval 0 s ≤<em>t</em> ≤ 10 s. Plot velocity as a function of time to see what it looks like. Compare your results to the exact solution:</p>&#13;
<div class="imagec"><img src="Images/e0240-04.jpg" alt="Image" width="153" height="23"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_241"/>Try out different time steps to see what happens when the time step gets too big.</p>&#13;
<p class="indent">Find a time step that is small enough that the Euler solution and the exact solution nicely overlap on a plot. Find another time step that is big enough that you can see the difference between the Euler solution and the exact solution on a plot.</p>&#13;
<p class="indent">Make a nice plot (with title, axis labels, and so on) with these three solutions on a single graph (bad Euler, good Euler, and exact). Label the Euler results with the time step you used and label the exact result “Exact.”</p>&#13;
<p class="noindentts"><strong>Exercise 14.14.</strong> Consider the differential equation</p>&#13;
<div class="imagec"><img src="Images/241equ01.jpg" alt="Image" width="164" height="44"/></div>&#13;
<p class="noindentts">subject to the initial condition <em>v</em>(0) = 0. This differential equation has no exact solution. Use the Euler method with a step size of Δ<em>t</em> = 0.01 to find <em>v</em>(<em>t</em>) over the interval 0 ≤<em>t</em> ≤ 3. Make a nice plot of the resulting function and include the value <em>v</em>(3) to five significant figures.</p>&#13;
<p class="noindentts"><strong>Exercise 14.15.</strong> Each wire in a functional diagram can be labeled with a type. Label each wire in <a href="ch14.xhtml#ch14fig11">Figure 14-11</a> with a type.<span epub:type="pagebreak" id="page_242"/></p>&#13;
</div></body></html>