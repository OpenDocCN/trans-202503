- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**Experiments in Counting**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**计数实验**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: '*Combinatorics* is a branch of mathematics that’s often called *the art of
    counting*. The “art” is in coming up with a way to organize a counting problem
    so that the objects being counted can be generated elegantly.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*组合学*是数学的一个分支，通常被称为*计数的艺术*。这种“艺术”在于想出一种方法来组织计数问题，使得被计数的对象能够优雅地生成。'
- en: Combinatorics has many important applications. In computer science, for example,
    combinatorial algorithms are good for tasks such as sorting and searching through
    data. In telecommunications, combinatorics provides error-correcting codes and
    network protocols for efficient data transmission. In genetics, it’s used to analyze
    and model genes to understand heredity and genetic variation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 组合学有许多重要的应用。例如，在计算机科学中，组合算法适用于排序和数据查找等任务。在电信领域，组合学提供了用于高效数据传输的错误更正代码和网络协议。在遗传学中，它被用来分析和建模基因，以理解遗传和基因变异。
- en: 'This chapter explores two classic examples from the world of combinatorics:
    Catalan numbers and partitions. For each example, we’ll develop a strategy for
    listing every instance of a pattern that satisfies a certain set of rules. Then,
    we’ll look for a recurrence formula to count all the instances without having
    to actually list them all.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了组合学领域的两个经典例子：卡塔兰数和分割数。对于每个例子，我们将制定一个策略，列出符合某一规则的所有模式实例。然后，我们将寻找一个递推公式来计算所有实例，而无需实际列出它们。
- en: What Are Counting Problems?
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是计数问题？
- en: 'In some counting problems, there’s a parameter indicating a measure of size
    or quantity: say, the counting number *n*. We want to know how many ways there
    are to use *n* to generate distinct objects. A classic example is figuring out
    how many ways there are to arrange *n* items. Each unique ordering of items is
    considered to be a different object. (The answer is *n* factorial, as we saw in
    [Chapter 5](ch05.xhtml#ch05).)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些计数问题中，有一个参数表示某种大小或数量的度量：比如计数数值*n*。我们想知道有多少种方法可以使用*n*来生成不同的对象。一个经典的例子是计算有多少种方法可以排列*n*个物品。每一个独特的排列方式都被视为一个不同的对象。（答案是*n*的阶乘，正如我们在[第5章](ch05.xhtml#ch05)中看到的。）
- en: In other counting problems, there’s a single object determined by the parameter
    *n*, and we want to measure some aspect of that object. For example, we considered
    square numbers when we discussed sequences in [Chapter 4](ch04.xhtml#ch04). There,
    the object associated with *n* was a square of side length *n*, which can be built
    with *n*² 1×1 subsquares. The sequence of squares is determined by considering
    how many points there are for *n* = 1, 2, 3, and so on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他计数问题中，有一个由参数*n*确定的单一对象，我们想要测量该对象的某个方面。例如，在讨论[第4章](ch04.xhtml#ch04)中的序列时，我们考虑了平方数。在那里，与*n*相关的对象是边长为*n*的正方形，它可以由*n*²个1×1的小方格构成。平方数的序列是通过考虑*n*
    = 1, 2, 3，依此类推时，所包含的点数来确定的。
- en: I like to think of the parameter in a counting problem as a knob you can turn
    to get different results. The Fibonacci numbers in [Chapter 4](ch04.xhtml#ch04),
    for instance, started out as an answer to a counting problem about how many rabbits
    there will be after *n* generations, given some constraints about how the rabbits
    reproduce. Turn the knob to *n* = 6 generations and you get 8, the answer for
    the sixth generation. Turn the knob to *n* = 7 generations and you get 13.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢把计数问题中的参数想象成一个旋钮，你可以通过旋转它来获得不同的结果。例如，[第4章](ch04.xhtml#ch04)中的斐波那契数列，最初是作为一个计数问题的答案，问题是：在某些关于兔子繁殖的限制下，*n*代之后兔子会有多少只。把旋钮转到*n*
    = 6代，你会得到8，这是第六代的答案。把旋钮转到*n* = 7代，你会得到13。
- en: 'Many counting problems are solved with a sequence, and once we have a sequence,
    we can look for patterns. We might be interested in the rate of growth of the
    sequence, divisibility properties, or connections with other sequences. There’s
    a famous project that collects information about integer sequences and puts them
    in order, like a dictionary: the On-Line Encyclopedia of Integer Sequences^® (OEIS^®).
    It started off in the 1960s as a database stored on punched cards and maintained
    by Neil Sloane of AT&T Bell Labs. It’s grown considerably over the years and now
    lives at *[https://oeis.org](https://oeis.org)*. The OEIS welcomes contributions
    of new sequences from the public, so if you come up with an interesting sequence
    that nobody’s thought of before, you can submit it!'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计数问题可以通过一个序列来解决，一旦我们得到了一个序列，就可以寻找其中的规律。我们可能对序列的增长速度、可除性性质或与其他序列的联系感兴趣。有一个著名的项目收集了整数序列的信息并将它们按顺序排列，就像字典一样：在线整数序列百科全书^®（OEIS^®）。它最初在1960年代作为一个存储在打孔卡片上的数据库，由AT&T贝尔实验室的Neil
    Sloane维护。经过多年的发展，它已经大大扩大，现在可以在* [https://oeis.org](https://oeis.org) *上找到。OEIS欢迎公众贡献新的序列，如果你想出了一个以前没人想到过的有趣序列，你可以提交它！
- en: Climbing Mountains with Catalan Numbers
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用卡塔兰数爬山
- en: The *Catalan numbers* are a sequence of numbers that arise in various counting
    problems, including the one we’ll look at here. Suppose you want to build a jagged
    path of up and down steps, like charting a path over the mountains in a mountain
    range. You start at ground level and move one step forward at a time, stepping
    either up or down. At the end, you finish back at ground level. The only restriction
    is that the mountain range must not dip below ground level at any point. How many
    different patterns of up and down steps—that is, how many unique mountain ranges—can
    you create?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*卡塔兰数*是一组出现在各种计数问题中的数列，包括我们这里要讨论的那个问题。假设你想要建造一条上下起伏的阶梯路径，就像在山脉中标记一条路径一样。你从地面开始，每次迈一步，要么向上走，要么向下走。最后，你回到地面水平。唯一的限制是，山脉路径在任何时刻都不能低于地面。你能创建多少种不同的上下步模式，也就是多少种独特的山脉形态呢？'
- en: 'More and more mountain ranges are possible as the number of steps grows, but
    there are some important limits that stem from the central constraint. Because
    you have to stay above ground level, the very first step you take has to be up,
    not down. What’s more, there always have to be at least as many up steps as down
    steps that have been taken so far. Otherwise, if you go down more than up, you’ll
    end up below ground level. For example, if we write an up step as ↗ and a down
    step as ↘, then something like ↗↘↘↗↗↘ wouldn’t work. Spread it out in two dimensions
    to see why not:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着步数的增加，可能的山脉形态越来越多，但仍然有一些重要的限制，源于中央约束。因为你必须保持在地面之上，你迈出的第一步必须是向上而不是向下。更重要的是，到目前为止，向上的步数必须始终至少与向下的步数相等。否则，如果你向下走得多于向上，你将会低于地面。例如，如果我们将向上一步表示为↗，向下一步表示为↘，那么像↗↘↘↗↗↘这样的步序就不行。将它展开为二维来看为什么不行：
- en: '![Image](../images/pg150_Image_179.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg150_Image_179.jpg)'
- en: 'The mountain range dips below the starting position after the first up-down,
    so it isn’t allowed. On the other hand, the step sequence ↗↗↘↘↗↘ is allowed. It
    spreads out as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 山脉在第一次上下之后会下降到起始位置以下，因此不允许这样做。另一方面，步序列↗↗↘↘↗↘是允许的。它展现如下：
- en: '![Image](../images/pg151_Image_180.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg151_Image_180.jpg)'
- en: 'Essentially, to end up back at ground level, the steps have to occur in pairs:
    for every up, there eventually has to be a corresponding down. So we can use *n*
    to represent just the number of up steps, and we can say that the Catalan number
    *C*(*n*) is the total number of acceptable paths that can be made with *n* up
    steps. The same *n* also represents the number of down steps, for a total of 2*n*
    steps in each path.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，为了回到地面，步伐必须成对出现：每一次向上，总会有相应的向下。因此，我们可以用*n*来表示向上的步数，并且我们可以说卡塔兰数*C*(*n*)是由*n*个向上步构成的可接受路径的总数。这个*n*同样代表向下步的数量，每条路径总共有2*n*步。
- en: In all, there are five acceptable paths that can be built with *n* = 3 up steps
    and *n* = 3 down steps. In other words, *C*(3) = 5\. One of those paths is the
    ↗↗↘↘↗↘ pattern I just showed. Can you find the others? It isn’t too hard to think
    through all the possible combinations with a low *n* value like 3, but as *n*
    increases, it becomes more important to have a systematic method for keeping track
    of all the paths. The beauty of finding the right method is what makes combinatorics
    the *art* of counting.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，使用*n* = 3个上箭头和*n* = 3个下箭头，可以构建五条可接受的路径。换句话说，*C*(3) = 5。其中一条路径就是我刚刚展示的↗↗↘↘↗↘模式。你能找到其他的路径吗？对于像3这样的低*n*值，想出所有可能的组合并不难，但随着*n*的增大，拥有一种系统化的方法来追踪所有路径就变得尤为重要。找到正确的方法是组合学成为*计数的艺术*的美妙之处。
- en: Something that worked for the Fibonacci numbers in [Chapter 4](ch04.xhtml#ch04)
    was finding a *recurrence*, a formula that let us build new numbers in the sequence
    from old ones. In that case, all we had to do was add the two previous numbers
    together to get the next number. With Catalan numbers, we might try fitting together
    old paths that we’ve already generated to form new, longer paths, but we’ll need
    to go back further than two terms in the sequence to find them all. In fact, we’ll
    have to look at every shorter path we’ve already generated.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml#ch04)中，斐波那契数列的一个有效方法是寻找*递推式*，一种公式，允许我们从已有的数生成新数。在那个情况下，我们只需要将前两个数字相加，得到下一个数字。对于卡塔兰数，我们可能会尝试将已经生成的旧路径拼接起来形成新的、更长的路径，但我们需要回溯到序列中的更早的项，以便找到所有的路径。事实上，我们必须查看每一条已经生成的较短路径。
- en: 'We can build a new path with *n* up arrows by first picking any two numbers
    that add up to *n* – 1\. Let’s call them *a* and *b*. If *n* were 3, for example,
    we could choose *a* = 1 and *b* = 1, or *a* = 0 and *b* = 2, or *a* = 2 and *b*
    = 0, since those all add up to 3 – 1 = 2\. For the old paths, we know there’s
    only one path for *a* or *b* = 0\. It’s an empty path with zero up steps and zero
    down steps, where we don’t go anywhere. Likewise, there’s just one path with one
    up arrow (for *a* or *b* = 1): ↗↘. There are two paths with two up arrows (for
    *a* or *b* = 2): ↗↗↘↘ and ↗↘↗↘.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过首先选择任意两个数字，它们的和为*n* - 1，来构建一个由*n*个上箭头组成的新路径。我们称这两个数字为*a*和*b*。例如，如果*n*是3，我们可以选择*a*
    = 1和*b* = 1，或者*a* = 0和*b* = 2，或者*a* = 2和*b* = 0，因为它们的和是3 - 1 = 2。对于旧路径，我们知道，当*a*或*b*
    = 0时，只有一条路径。这是一条没有上箭头和下箭头的空路径，我们不会走任何地方。同样，当*a*或*b* = 1时，也只有一条路径：↗↘。当*a*或*b* =
    2时，有两条路径：↗↗↘↘和↗↘↗↘。
- en: 'The recipe for building new paths is to start with an up arrow (↗), followed
    by any previously created path with *a* up arrows. Then, we add a down arrow (↘),
    followed by any previously created path with *b* up arrows. That gives us a total
    of *n* up arrows: the first up arrow followed by the *n* – 1 up arrows in the
    two paths with *a* and *b* up arrows. The first up arrow and the constraints on
    the previously generated paths guarantee that the number of down arrows never
    exceeds the number of up arrows, which would put us below ground level.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 构建新路径的方法是从一个上箭头（↗）开始，接着是任何一个之前创建的具有*a*个上箭头的路径。然后，我们加一个下箭头（↘），再接一个任何之前创建的具有*b*个上箭头的路径。这样我们就得到了总共*n*个上箭头：第一个上箭头加上两个路径中的*a*和*b*个上箭头。第一个上箭头和对先前生成路径的约束保证了下箭头的数量永远不会超过上箭头的数量，否则我们就会跌入地下。
- en: 'Let’s use this recipe to create every possible path for *n* = 3\. For *a* =
    1 and *b* = 1, we build just one path: ↗ ↗↘ ↘ ↗ ↘. For *a* = 0 and *b* = 2, there
    are two cases: ↗↘↗↗↘↘ and ↗↘↗↘↗↘. For *a* = 2 and *b* = 0, there are also two
    cases: ↗↗↗↘↘↘ and ↗↗↘↗↘↘. And that’s it. Those are the five possible paths with
    *n* = 3 up steps.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这个方法来创建所有可能的路径，当*n* = 3时。对于*a* = 1和*b* = 1，我们只生成一条路径：↗ ↗↘ ↘ ↗ ↘。对于*a* =
    0和*b* = 2，生成两种情况：↗↘↗↗↘↘和↗↘↗↘↗↘。对于*a* = 2和*b* = 0，同样生成两种情况：↗↗↗↘↘↘和↗↗↘↗↘↘。就这样，这就是*n*
    = 3上箭头的五条可能路径。
- en: Notice how when *a* = 0, each newly generated path is just ↗↘ followed by an
    older path with *b* up steps. Meanwhile, when *b* = 0, the new path is just an
    old path with *a* up steps jacked up so there’s an extra ↗ at the beginning and
    an extra ↘ at the end.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当*a* = 0时，每条新生成的路径仅仅是↗↘后接一个具有*b*个上箭头的旧路径。与此同时，当*b* = 0时，新路径仅仅是一个旧路径，它有*a*个上箭头，并且通过在开始时添加一个额外的↗，在结束时添加一个额外的↘，使得路径变得更加"上升"。
- en: 'Every acceptable path with *n* up steps can be generated using this simple
    recipe, as long as we consider every possible combination of values for *a* and
    *b*. For *n* = 4, for example, we would need all the values of *a* and *b* that
    add up to 3: 0 + 3, 1 + 2, 2 + 1, and 3 + 0.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个接受的路径，具有*n*个上升步长，都可以使用这个简单的公式生成，只要我们考虑每一对可能的*a*和*b*值。例如，对于*n* = 4，我们需要所有相加为3的*a*和*b*值：0
    + 3，1 + 2，2 + 1，和3 + 0。
- en: 'Project 28: Navigating Catalan Paths'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 28：导航卡塔兰路径
- en: In this project we’ll write a Scratch program to build new Catalan paths using
    the approach we just discussed. First, we need to classify paths by how many up
    steps they have, so we define a block (shown in [Figure 7-1](ch07.xhtml#ch7fig1))
    that counts all the up steps in a sequence.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将编写一个Scratch程序，使用我们刚才讨论的方法来构建新的卡塔兰路径。首先，我们需要根据路径的上升步数来分类路径，因此我们定义了一个模块（如[图
    7-1](ch07.xhtml#ch7fig1)所示），它会计算序列中的所有上升步数。
- en: '![Image](../images/pg152_Image_181.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg152_Image_181.jpg)'
- en: '*Figure 7-1: How many up steps?*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：多少个上升步长？*'
- en: '![Image](../images/pg152_Image_182.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg152_Image_182.jpg)'
- en: '*Figure 7-2: Listing all the paths*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：列出所有路径*'
- en: This block assumes that each path is expressed as a string, with a forward slash
    character (`/`) to represent a step up and a backslash character (`\`) to represent
    a step down. The block scans the string character by character. Each time it finds
    a forward slash ❶, it increases the `upcount` variable by `1`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块假设每条路径都以字符串的形式表示，其中斜杠字符(`/`)表示上升一步，反斜杠字符(`\`)表示下降一步。该模块逐个字符扫描字符串。每当它找到一个斜杠
    ❶ 时，它就将`upcount`变量增加`1`。
- en: We can now build a list called `Catalan` containing all the acceptable paths
    up to a desired number of up steps. We start with a path of length 0 and then
    repeatedly apply the recurrence to get longer and longer new paths. The main program
    in [Figure 7-2](ch07.xhtml#ch7fig2) just asks the user how far to go and then
    calls the custom `Iterate` block ❶ the right number of times.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建一个名为`Catalan`的列表，包含所有接受的路径，直到达到期望的上升步数。我们从长度为0的路径开始，然后反复应用递归，生成越来越长的新路径。[图
    7-2](ch07.xhtml#ch7fig2)中的主程序只需询问用户要走多远，然后调用自定义的`Iterate`模块 ❶ 合适的次数。
- en: The real work is in the `Iterate` block, shown in [Figure 7-3](ch07.xhtml#ch7fig3),
    which performs the recurrence.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的工作在`Iterate`模块中完成，如[图 7-3](ch07.xhtml#ch7fig3)所示，它执行递归操作。
- en: '![Image](../images/pg153_Image_183.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg153_Image_183.jpg)'
- en: '*Figure 7-3: Making new paths from old paths*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：从旧路径生成新路径*'
- en: We use two nested loops to look at all pairs of paths that have been generated
    so far. Each path in the pair is classified by its number of up steps. For example,
    `Upcount item loop1 of Catalan` gives us the `upcount` of the first path in the
    pair ❶. Every time we find two paths that together have the correct number of
    up steps ➋, we combine them with an extra up and down step ➌ (notice the extra
    space after the `/` and `\` characters, which makes the spacing of the output
    nicer) and add the resulting new path to `Catalan`. The code is written so the
    condition for building a new Catalan path is `a + b = desired size - 1`. That
    way, when we add the extra up step and down step, we get a path with `desired
    size` up steps.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个嵌套循环来查看到目前为止生成的所有路径对。路径对中的每一条路径根据其上升步数进行分类。例如，`Upcount item loop1 of Catalan`为我们提供了路径对中第一条路径的`upcount`
    ❶。每当我们找到两条路径，它们的上升步数总和等于正确的值 ➋时，我们就用一个额外的上升和下降步长 ➌（注意 `/` 和 `\` 字符后面的额外空格，使输出的间距更美观）将它们结合在一起，并将生成的新路径添加到`Catalan`中。代码的编写方式是，构建新的卡塔兰路径的条件是`a
    + b = desired size - 1`。这样，当我们添加额外的上升和下降步长时，就能得到一个上升步数为`desired size`的路径。
- en: The Results
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: As usual, the output is constrained by the Scratch stage, but you can scroll
    to see more output or export the `Catalan` list as a text file to see the complete
    contents. [Figure 7-4](ch07.xhtml#ch7fig4) shows the top of the list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，输出受限于Scratch舞台，但你可以滚动以查看更多输出，或将`Catalan`列表导出为文本文件以查看完整内容。[图 7-4](ch07.xhtml#ch7fig4)展示了列表的顶部。
- en: '![Image](../images/pg154_Image_184.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg154_Image_184.jpg)'
- en: '*Figure 7-4: Catalan paths for* n *= 0, 1, 2, and 3*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：卡塔兰路径，适用于* n *= 0, 1, 2 和 3*'
- en: The first item shows the initial empty path, which grows into a path of ↗↘ when
    the recurrence is applied the first time. The figure includes the output through
    *n* = 3, showing the five acceptable paths with three up steps (list items 5 through
    9). [Figure 7-5](ch07.xhtml#ch7fig5) shows the next few paths in exported text
    format, corresponding to *n* = 4.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目显示了最初的空路径，在第一次应用递归时它变成了 ↗↘ 的路径。图中展示了 *n* = 3 的输出，显示了五条具有三个上升步骤的可接受路径（列表项
    5 到 9）。[图 7-5](ch07.xhtml#ch7fig5) 显示了接下来几条路径的导出文本格式，适用于 *n* = 4。
- en: '![Image](../images/pg154_Image_185.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg154_Image_185.jpg)'
- en: '*Figure 7-5: Catalan paths for* n *= 4*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：* n *= 4* 的卡塔兰路径'
- en: Scratch’s list length limit of 200,000 means that this program works only up
    to *n* = 11, when 58,786 new paths are generated and added to the list containing
    the 23,714 shorter paths for values of *n* from 0 to 10\. There are too many paths
    for *n* = 12 to complete the list any further. Worse, the double loop in the `Iterate`
    block takes a long time to complete. Since every pair of paths is screened to
    see if they join to satisfy the Catalan condition, there are as many pairs of
    paths to test as the square of the length of the list so far. There’s a definite
    lag by the time we get to *n* = 10 or 11.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch 的列表长度限制为 200,000，意味着这个程序最多只能工作到 *n* = 11，在此时会生成并添加 58,786 条新路径到包含从 *n*
    = 0 到 10 的 23,714 条较短路径的列表中。对于 *n* = 12 来说，路径数量过多，无法继续完成列表。更糟糕的是，`Iterate` 块中的双重循环需要很长时间才能完成。由于每一对路径都要检查是否能够结合以满足卡塔兰条件，测试路径对的数量是当前列表长度的平方。因此，当我们到达
    *n* = 10 或 11 时，程序明显变慢。
- en: Still, by counting up the items in the list with a given number of steps, we
    can begin to see the sequence of Catalan numbers using this program. Starting
    with *C*(0) = *C*(1) = 1, the next several values in the sequence are 2, 5, 14,
    42, 132, 429, 1,430, 4,862, 16,796, and 58,786.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过计算列表中具有给定步数的项，我们可以开始通过这个程序看到卡塔兰数列。以 *C*(0) = *C*(1) = 1 为起点，接下来的几个数值是 2、5、14、42、132、429、1,430、4,862、16,796
    和 58,786。
- en: Hacking the Code
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: 'If we want to know only the Catalan numbers themselves—that is, how many unique
    paths there are for each value of *n*—we don’t have to go through the trouble
    of actually constructing all the paths. Instead, we can calculate the numbers
    directly using a recurrence based on the same combinatorial insight that helped
    us generate new paths. To find *C*(*n*), we first need to find all the pairs of
    values *a* and *b* such that *a* + *b* = *n* – 1\. Then, for each pair, we can
    look up the corresponding Catalan numbers and multiply them together: *C*(*a*)
    ⋅ *C*(*b*). Finally, we add all those products up to get *C*(*n*).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想知道卡塔兰数本身——即每个 *n* 值的唯一路径数量——我们不必实际构建所有路径。相反，我们可以通过一个递归公式直接计算这些数字，基于相同的组合学见解，这帮助我们生成新路径。要找到
    *C*(*n*)，我们首先需要找到所有满足 *a* + *b* = *n* – 1 的数对 *a* 和 *b*。然后，对于每一对，我们可以查找相应的卡塔兰数并将它们相乘：*C*(*a*)
    ⋅ *C*(*b*)。最后，我们将所有这些乘积加起来得到 *C*(*n*)。
- en: 'For example, say we want to find *C*(5). Since 5 – 1 = 4, we first need to
    find all the pairs of numbers that add up to 4\. They are 0 + 4, 1 + 3, 2 + 2,
    3 + 1, and 4 + 0\. Notice how the first value in each pair is counting up from
    0 to *n* – 1, while the second value is counting down. Next, we need the Catalan
    numbers corresponding to the values in these pairs. Assuming we’ve been using
    this recurrence to calculate all the Catalan numbers starting from *C*(0), we
    should know them already: *C*(0) = 1, *C*(1) = 1, *C*(2) = 2, *C*(3) = 5, and
    *C*(4) = 14\. We can then multiply each pair of Catalan numbers and add the results
    together to get *C*(5):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要找到 *C*(5)。由于 5 – 1 = 4，我们首先需要找到所有相加为 4 的数字对。它们是 0 + 4、1 + 3、2 + 2、3
    + 1 和 4 + 0。注意，每对中的第一个值是从 0 到 *n* – 1 递增的，而第二个值则在递减。接下来，我们需要找到这些对中对应的卡塔兰数。假设我们已经使用这个递归公式计算出了所有从
    *C*(0) 开始的卡塔兰数，我们应该已经知道它们：*C*(0) = 1，*C*(1) = 1，*C*(2) = 2，*C*(3) = 5 和 *C*(4)
    = 14。然后，我们可以将每一对卡塔兰数相乘，并将结果相加来得到 *C*(5)：
- en: '![Image](../images/pg155_Image_186.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg155_Image_186.jpg)'
- en: 'A short way to write this recurrence formula is to use summation notation,
    where a *Σ* symbol (the uppercase Greek letter sigma) indicates an addition of
    one term for each value of the index *i* from the smallest value of *i* = 0 (indicated
    below the *Σ*) to the largest value of *i* = *n* – 1 (indicated above the *Σ*):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 写这个递归公式的简短方法是使用求和符号，其中 *Σ* 符号（大写希腊字母 Sigma）表示对于每个索引 *i* 从最小值 *i* = 0（位于 *Σ*
    下方）到最大值 *i* = *n* – 1（位于 *Σ* 上方）每增加一个值进行求和：
- en: '![Image](../images/pg155_Image_187.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg155_Image_187.jpg)'
- en: Here, *i* is equivalent to *a*, and *n* – 1 – *i* is equivalent to *b*. This
    makes sense; if *a* + *b* = *n* – 1, then *b* = *n* – 1 – *a*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*i* 相当于 *a*，而 *n* – 1 – *i* 相当于 *b*。这是有道理的；如果 *a* + *b* = *n* – 1，那么 *b*
    = *n* – 1 – *a*。
- en: '[Figure 7-6](ch07.xhtml#ch7fig6) shows some code to have Scratch calculate
    and list as many Catalan numbers as we want.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-6](ch07.xhtml#ch7fig6) 显示了一些代码，帮助 Scratch 计算并列出我们想要的卡塔兰数。'
- en: '![Image](../images/pg156_Image_188.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg156_Image_188.jpg)'
- en: '*Figure 7-6: Making a list of Catalan numbers*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：列出卡塔兰数*'
- en: We name the list `C(n)` and start by adding `1` to it for *C*(0) = 1\. It would
    be much better, though, if the list indices matched the indices of the sequence
    entries, with index `1` holding *C*(1), index `2` holding *C*(2), and so on. To
    make this happen, we delete the first item from the list at the end of the program
    ❶.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将列表命名为 `C(n)`，并从为 *C*(0) = 1 添加 `1` 开始。不过，如果列表的索引与序列条目的索引匹配会更好，索引 `1` 存放 *C*(1)，索引
    `2` 存放 *C*(2)，以此类推。为了实现这一点，我们在程序结束时删除列表中的第一个项目 ❶。
- en: As in the original Catalan program, the actual work is done in an `Iterate`
    block, which we can call as many times as we want. [Figure 7-7](ch07.xhtml#ch7fig7)
    shows the block definition.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 和原始卡塔兰程序一样，实际的工作是在 `Iterate` 块中完成的，我们可以根据需要调用多次。[图7-7](ch07.xhtml#ch7fig7) 显示了块的定义。
- en: '![Image](../images/pg156_Image_189.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg156_Image_189.jpg)'
- en: '*Figure 7-7: Applying the recurrence*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：应用递推公式*'
- en: Inside a `repeat` loop, we look up pairs of Catalan numbers, with the value
    of the variable `a` starting at `i(1)` and increasing up to `size` while the value
    of the variable `b` starts at `size` and decreases, to account for all pairs in
    the recurrence. Notice how the definition of `b` makes it count backward ❶. We
    multiply each pair of values and add them to the running total being kept in the
    `sum` variable, which is added to the list at the end of the block.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `repeat` 循环内，我们查找一对对的卡塔兰数，变量 `a` 的值从 `i(1)` 开始，逐渐增加至 `size`，而变量 `b` 的值从 `size`
    开始递减，以涵盖递推公式中的所有对。注意 `b` 的定义如何使其倒计数 ❶。我们将每对数值相乘，并将结果加到保存在 `sum` 变量中的运行总数中，最后将其添加到列表的末尾。
- en: With the recurrence, Scratch is able to calculate the values of *C*(*n*) quite
    quickly, and the limiting value of the program is determined by flintmax instead
    of the maximum list length. The results are accurate until flintmax is exceeded,
    which happens after *n* = 30\. The value Scratch calculates for *C*(31) is off
    by 1\. We don’t exceed Scratch’s floating-point maximum and start getting answers
    of `Infinity`, however, until we hit *n* = 520.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递推公式，Scratch 能够相当快速地计算 *C*(*n*) 的值，并且程序的限制值由 flintmax 决定，而不是最大列表长度。直到 flintmax
    被超越，结果都是准确的，这通常发生在 *n* = 30 后。Scratch 计算出的 *C*(31) 的值会偏差 1，但直到 *n* = 520 时，我们才会遇到
    `Infinity` 的问题，这时才会超出 Scratch 的浮动点最大值。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**7.1**Here’s another recurrence for Catalan numbers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.1**这是另一个卡塔兰数的递推公式：'
- en: '![Image](../images/pg157_Image_190.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg157_Image_190.jpg)'
- en: After starting with *C*(0) = 1, this formula applies to all values of *n* greater
    than 0\. Program this alternative Catalan recurrence in Scratch.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *C*(0) = 1 开始，这个公式适用于所有大于 0 的 *n* 值。在 Scratch 中编写这个替代的卡塔兰数递推公式。
- en: '**7.2**Write a program to make Scratch draw the up-down mountains when you
    provide a path from a row of the `Catalan` list.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.2**编写一个程序，当你提供一条来自 `Catalan` 列表的路径时，让 Scratch 绘制上下山脉。'
- en: '**7.3**There’s a relationship between the Catalan numbers and the central binomial
    coefficients in Pascal’s triangle, which are entries of the form *C*(2*n*, *n*).
    Calculate some central binomial coefficients using the program from [Project 19](ch05.xhtml#ch05lev7)
    ([Figure 5-7](ch05.xhtml#ch5fig7)), and see if you can find another formula for
    calculating Catalan numbers.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.3**卡塔兰数与帕斯卡三角形中的中心二项式系数存在关系，后者的条目形式为 *C*(2*n*, *n*)。使用 [项目19](ch05.xhtml#ch05lev7)（[图5-7](ch05.xhtml#ch5fig7)）中的程序计算一些中心二项式系数，看看你能否找到另一种计算卡塔兰数的公式。'
- en: '**7.4**Another counting problem where Catalan numbers arise involves specifying
    the order of multiplication by nesting parentheses. Think about how you might
    multiply four numbers *a, b, c*, and *d* by changing how they’re grouped via parentheses,
    instead of changing the order of the factors. For example, ((*ab*)*c*)*d* would
    first multiply *a* and *b*, then multiply the result of that calculation (the
    *partial product*) by *c*, and finally multiply that by *d*. On the other hand,
    (*ab*)(*cd*) first multiplies *a* and *b*, then multiplies *c* and *d*, and finally
    multiplies together the two partial products. There are three more ways to group
    four numbers. Find them. Then, change the program for generating Catalan paths
    so it shows all the ways the parentheses could be grouped.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.4**另一个涉及卡塔兰数的计数问题是通过嵌套括号来指定乘法的顺序。考虑如何通过改变括号的分组方式，而不是改变因子的顺序，来相乘四个数*a, b,
    c*和*d*。例如，((*ab*)*c*)*d*首先会先将*a*和*b*相乘，然后将该计算结果（*部分积*）与*c*相乘，最后将结果与*d*相乘。另一方面，(*ab*)(*cd*)会先将*a*和*b*相乘，再将*c*和*d*相乘，最后将两个部分积相乘。还有三种不同的方式来分组四个数。找到它们。然后，修改生成卡塔兰路径的程序，使其显示所有可能的括号分组方式。'
- en: Breaking Down Numbers with Addition
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用加法分解数字
- en: Many of the questions we’ve explored about numbers in earlier chapters have
    been about multiplication. For example, the prime numbers are multiplicative building
    blocks of the positive integers, and the fundamental theorem of arithmetic says
    there’s only one way to write a number as a product of primes (ignoring the order
    of the factors, that is). But what about addition? What are some ways we can write
    a number as the sum of other numbers?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章探讨的许多关于数字的问题都涉及到乘法。例如，质数是正整数的乘法基本单元，算术基本定理说一个数字只能以一种方式写成质数的乘积（忽略因子的顺序）。但是加法呢？我们可以以什么方式将一个数字写成其他数字的和？
- en: 'For starters, we might focus on the number 1 and note that every positive integer
    can be written uniquely as a sum of 1s: 2 = 1 + 1, 3 = 1 + 1 + 1, and so on. We
    could also impose a different restriction and require that each *summand* (a number
    being added) be used at most once. Then, there’s a unique representation for every
    positive integer if we think in base 2\. That is, every positive integer can be
    uniquely expressed as a sum of distinct powers of 2\. (We explored binary representations
    in [Chapter 1](ch01.xhtml#ch01).) For example, the only way to get 5 without reusing
    the same power of 2 is 2² + 2⁰, or 4 + 1\. As soon as we allow a larger set of
    possible summands than the powers of 2, however, we lose uniqueness. If we permit
    3 as a summand along with the powers of 2, for instance, we can get 5 using 1
    + 4 or 2 + 3.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以专注于数字1，并注意到每个正整数都可以唯一地写成1的和：2 = 1 + 1，3 = 1 + 1 + 1，依此类推。我们还可以施加不同的限制，要求每个*加数*（被加的数字）最多只使用一次。然后，如果我们考虑以2为基数，那么每个正整数都有唯一的表示。也就是说，每个正整数可以唯一地表示为不同2的幂的和。（我们在[第1章](ch01.xhtml#ch01)中探讨了二进制表示法。）例如，得到5的唯一方法是不重复使用相同的2的幂，就是2²
    + 2⁰，或者4 + 1。然而，一旦我们允许比2的幂更大的加数集合，我们就失去了唯一性。如果我们允许3作为加数与2的幂一起使用，例如，我们就可以通过1 +
    4或2 + 3得到5。
- en: 'Compositions: Order Does Matter'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组合：顺序很重要
- en: 'Another decision to make is whether order should matter. Do we count 1 + 2
    and 2 + 1 as different representations of 3? If we decide they should be considered
    different, then there’s an easy way to find the number of possible representations
    of a given number *n* as a sum (also called the *compositions* of *n*). First,
    write *n* = 1 + 1 + . . . + 1\. Then, look at each plus sign and make a choice:
    either keep it or omit it and combine the numbers on each side of it. For example,
    say *n* = 3\. We could take 3 = 1 + 1 + 1 and decide to get rid of either the
    first plus sign, making 3 = 1 1 + 1 → 2 + 1, or the second plus sign, making 3
    = 1 + 1 1 → 1 + 2\. We can also keep both plus signs and get 1 + 1 + 1, or get
    rid of both and get the single summand 3.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要做出的决定是顺序是否重要。我们是否将1 + 2和2 + 1视为表示3的不同方式？如果我们决定它们应该被视为不同，那么就有一种简单的方法来找出给定数字*n*作为和的所有可能表示（也叫做*n*的*组合*）。首先，将*n*写成1
    + 1 + . . . + 1。然后，查看每个加号并做出选择：要么保留它，要么省略它并将它两边的数字合并。例如，假设*n* = 3。我们可以将3 = 1 +
    1 + 1，并决定去掉第一个加号，使得3 = 1 1 + 1 → 2 + 1，或者去掉第二个加号，使得3 = 1 + 1 1 → 1 + 2。我们也可以保留两个加号得到1
    + 1 + 1，或者去掉两个加号，得到单一的加数3。
- en: 'We’ve found four compositions of 3, and that’s all there are. To see why, and
    to develop a general formula for the number of compositions of *n*, think about
    the process of going from 1 + 1 + 1 + . . . + 1 to a composition of *n*. A string
    of *n* 1s have *n* – 1 plus signs between them. For each plus sign, we have a
    binary choice to make: keep it or drop it. That means there are *n* – 1 independent
    binary decisions, which works out to 2^(*n*– 1) ways to combine the decisions
    and make a composition of *n*. The four compositions of 3 that we identified are
    “drop, keep,” “keep, drop,” “keep, keep,” and “drop, drop.”'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了3的四个组成方式，而且就是这四个。为了理解为什么是这样，并且推导出*n*的组成方式数量的一般公式，可以想一想从1 + 1 + 1 + ...
    + 1到*n*的组成方式的过程。由*n*个1组成的字符串中，*n* – 1个加号分隔它们。对于每一个加号，我们有两个选择：保留它或去掉它。这意味着有*n*
    – 1个独立的二进制决策，这就导致有2^(*n* – 1)种方式来组合这些决策，形成一个*n*的组成方式。我们识别出的3的四个组成方式是“去掉，保留”，“保留，去掉”，“保留，保留”和“去掉，去掉”。
- en: 'Partitions: Order Doesn’t Matter'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分区：顺序无关
- en: A more interesting situation, and one that doesn’t have an answer with such
    an easy formula, is if we decide that the order of summands *doesn’t* matter—for
    example, that 1 + 2 and 2 + 1 should be treated as the same representation of
    3\. Such a representation, where we ignore the order, is called a *partition*
    of *n* rather than a composition.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有趣的情况，并且没有那么简单的公式答案的是，如果我们决定加法项的顺序*不*重要——例如，1 + 2和2 + 1应被视为相同的3的表示方式。这样的表示方式，忽略顺序，被称为*n*的*分区*，而不是组成。
- en: If the order of summands doesn’t matter, we might as well put the summands in
    increasing (or rather, nondecreasing) order so we can keep track of all the partitions
    in a more systematic way. We can then think of a partition as a special kind of
    composition whose terms are nondecreasing. For example, the three partitions of
    3 are 1 + 1 + 1, 1 + 2, and 3.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加法项的顺序无关，那么我们不如将加法项按升序（或更确切地说，按非降序）排列，这样我们可以更系统地跟踪所有的分区。然后，我们可以将一个分区看作是一个特殊的组成方式，其项是非降序的。例如，3的三个分区是1
    + 1 + 1，1 + 2和3。
- en: '**NOTE**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I say* nondecreasing *rather than* increasing *because it wouldn’t really
    be fair to think of the 1s in 1 + 1 + 1 as being in increasing order. The important
    thing is that the value of each summand isn’t less than the previous one.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*我说*非降序*而不是*升序*，*因为将1 + 1 + 1中的1看作是升序的并不完全公平。重要的是每个加法项的值不会小于前一个项的值。*'
- en: 'Let’s call *P*(*n*) the function that counts the number of partitions of *n*.
    Make sure you agree that *P*(1) = 1 (there’s only one partition of 1: 1 = 1) and
    that *P*(2) = 2 (2 = 1 + 1, 2 = 2). We’ve already determined that there are three
    partitions of 3, so *P*(3) = 3\. You might think you see a pattern, but the number
    of partitions of *n* starts to grow more quickly from here on: *P*(4) = 5, *P*(5)
    = 7, and by the time we get to 12 we have *P*(12) = 77.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称*P*(*n*)为计算*n*的分区数量的函数。确保你同意*P*(1) = 1（1只有一个分区：1 = 1），以及*P*(2) = 2（2 = 1
    + 1，2 = 2）。我们已经确定3有三个分区，因此*P*(3) = 3。你可能觉得看到了一个规律，但从这里开始，*n*的分区数量增长得更快：*P*(4)
    = 5，*P*(5) = 7，当我们到达12时，*P*(12) = 77。
- en: 'Project 29: A Partition Expedition'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目29：一个分区探险
- en: Let’s develop a Scratch program to find all the partitions for a given value
    of *n*. We’ll store the results in a `partitions` list, with each partition represented
    as a string of numbers separated by plus signs without any spaces in between,
    such as `1+1+2`. Our strategy will be to start at *n* = 1 and work our way up
    to the desired value of *n*, replacing the contents of `partitions` with the current
    *n*’s partitions every step of the way. This means we need a way to use a list
    of all the partitions of *n* to find all the partitions of *n* + 1.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发一个Scratch程序来查找给定值*n*的所有分区。我们将把结果存储在一个`partitions`列表中，每个分区表示为由加号连接的数字字符串，中间不留空格，例如`1+1+2`。我们的策略是从*n*
    = 1开始，一步步增加到所需的*n*值，每一步都用当前*n*的分区替换`partitions`的内容。这意味着我们需要一种方法，利用所有*n*的分区列表来找到所有*n*
    + 1的分区。
- en: Some partitions of *n* + 1 are available by adding a summand of 1 to the start
    of each partition of *n*. This is just a matter of joining `1+` to each item in
    the `partitions` list. [Figure 7-8](ch07.xhtml#ch7fig8) shows a custom block to
    do that.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在每个*n*的分区前加上一个加法项1，就可以获得一些*n* + 1的分区。这只不过是将`1+`连接到`partitions`列表中的每个项目上。[图7-8](ch07.xhtml#ch7fig8)显示了一个自定义块来实现这一点。
- en: '![Image](../images/pg159_Image_191.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg159_Image_191.jpg)'
- en: '*Figure 7-8: Building new partitions from old partitions*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-8：从旧的分区构建新的分区*'
- en: This block simply cycles through the `partitions` list, taking one item at a
    time, adding `1+` to the beginning of it, and storing the result back in the same
    position in the list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码块简单地循环遍历`partitions`列表，一次取出一个项，将`1+`添加到它的开头，然后将结果存回列表中的相同位置。
- en: The remaining partitions of *n* + 1 can be built by looking back at the partitions
    of *n* – 1 and adding a new first term of 2, looking back at the partitions of
    *n* – 2 and adding a new first term of 3, and so on. This step is a little trickier
    since, because of the nondecreasing order rule, not every newly created partition
    will be acceptable. For example, the only partitions of *n* – 1 that can have
    a 2 added to them are the ones that had a smallest term of at least 2 to begin
    with. If there’s a 1 in the partition, putting a 2 in front breaks the order.
    Similarly, when adding a 3 to a partition of *n* – 2, the original partition can’t
    begin with a 1 or a 2.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* + 1的其余分区可以通过回顾*n* – 1的分区并添加新的首项2，回顾*n* – 2的分区并添加新的首项3，依此类推。这一步稍微复杂一些，因为由于非递减顺序规则，并不是每个新创建的分区都能接受。例如，*n*
    – 1的分区中只有那些最小项至少为2的分区才能加上2。如果分区中有1，放一个2在前面就破坏了顺序。同样，当向*n* – 2的分区添加3时，原始分区不能以1或2开头。'
- en: 'Another complication is that the `partitions` list in our program holds only
    the partitions of *n*, which are modified to become the partitions of *n* + 1\.
    We don’t actually have a record of the earlier partitions of *n* – 1, *n* – 2,
    and so on to look back at. There’s a workaround, though: once we’ve taken all
    the partitions of *n* and added a 1 at the beginning to make partitions of *n*
    + 1, we can look at each new partition and combine all the 1s. If there are two
    1s, this will have the same effect as adding a 2 to the partitions of *n* – 1\.
    Similarly, if there are three, it will be equivalent to adding a 3 to partitions
    of *n* – 2, and so on.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个复杂点是，程序中的`partitions`列表只保存*n*的分区，这些分区被修改为*n* + 1的分区。我们实际上没有记录早期的*n* – 1、*n*
    – 2等分区来回顾。不过有一个解决方法：一旦我们将所有的*n*分区取出并在前面添加1来生成*n* + 1的分区后，我们可以查看每个新分区并合并所有的1。如果有两个1，这将与向*n*
    – 1的分区中添加2效果相同。同样，如果有三个1，这就相当于向*n* – 2的分区添加3，依此类推。
- en: To see why this works, consider the case of going from *n* = 5 to *n* + 1 =
    6\. One partition of 5 is 1 + 2 + 2, and adding an extra 1 to it gives us 1 +
    1 + 2 + 2, a partition of 6\. If we combine those 1s into a 2, we get 2 + 2 +
    2, another partition of 6\. This is the equivalent of looking back at the partitions
    of *n* – 1 = 4, finding the partition 2 + 2, and adding a 2 in front of it. Likewise,
    another partition of 5 is 1 + 1 + 3\. Adding an extra 1 gives us 1 + 1 + 1 + 3
    = 6\. If we combine those 1s into a 3, we get 3 + 3, the same as if we’d looked
    back at the partitions of *n* – 2 = 3, found the partition 3 (any number is a
    valid partition of itself), and added a 3 in front of it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么这样做有效，考虑从*n* = 5到*n* + 1 = 6的情况。5的一个分区是1 + 2 + 2，向它添加一个额外的1后，我们得到1 +
    1 + 2 + 2，这是6的一个分区。如果我们把这两个1合并成一个2，我们得到2 + 2 + 2，这是6的另一个分区。这相当于回顾*n* – 1 = 4的分区，找到分区2
    + 2，并在它前面加一个2。同样，5的另一个分区是1 + 1 + 3。添加一个额外的1后，我们得到1 + 1 + 1 + 3 = 6。如果我们将这些1合并成一个3，我们得到3
    + 3，这与回顾*n* – 2 = 3的分区，找到分区3（任何数字都是它自己的有效分区），并在它前面加一个3的效果相同。
- en: Implementing this process in code takes a few steps. First, we need to copy
    the contents of `partitions` (the partitions of *n* + 1 that we got by adding
    an initial term of 1 to the old partitions of *n*) into a new list so we don’t
    overwrite them. The block in [Figure 7-9](ch07.xhtml#ch7fig9) does this, placing
    the copy in a list called `dup`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个过程的代码需要几个步骤。首先，我们需要将`partitions`（我们通过向* n *的旧分区添加一个初始项1得到的*n*+1的分区）中的内容复制到一个新的列表中，以免覆盖它们。图[7-9](ch07.xhtml#ch7fig9)中的代码完成了这个任务，将复制的内容放入一个名为`dup`的列表中。
- en: '![Image](../images/pg160_Image_192.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg160_Image_192.jpg)'
- en: '*Figure 7-9: Copying the list of partitions to a duplicate list*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：将分区列表复制到一个副本列表中*'
- en: Next, we need a way to count how many 1s there are at the start of a given partition.
    The block in [Figure 7-10](ch07.xhtml#ch7fig10) handles this task.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法来计算给定分区开头有多少个1。图[7-10](ch07.xhtml#ch7fig10)中的代码块处理了这个任务。
- en: '![Image](../images/pg161_Image_193.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg161_Image_193.jpg)'
- en: '*Figure 7-10: Counting the number of 1s in a partition*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：计算分区中1的数量*'
- en: Remember, we’re assuming that each partition is a string of numbers separated
    by plus signs, but we don’t know how many digits each number contains. So this
    `How many 1s` block looks at the string two characters at a time and checks if
    the first character (`m`) is a 1 and the second (`n`) is a plus sign. The `repeat
    until` loop keeps incrementing `1count` until this is no longer the case. Checking
    for the plus sign as well as the 1 prevents a string like `1+10` from being counted
    as two 1s. Notice also that we temporarily add an extra plus sign to the end of
    the string at the start of the block. Without this, the final 1 in a string of
    all 1s (like `1+1+1`) wouldn’t be counted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们假设每个分区都是由加号分隔的数字串，但我们不知道每个数字包含多少位。所以这个`How many 1s`代码块每次查看字符串中的两个字符，检查第一个字符（`m`）是否是
    1，第二个字符（`n`）是否是加号。`repeat until` 循环会不断增加 `1count`，直到情况不再成立。检查加号和 1 可以防止像 `1+10`
    这样的字符串被误算为两个 1。还要注意，在代码块开始时，我们会暂时在字符串的末尾添加一个额外的加号。如果没有这一点，像 `1+1+1` 这样的全 1 字符串中的最后一个
    1 就不会被计算在内。
- en: '![Image](../images/pg161_Image_194.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg161_Image_194.jpg)'
- en: '*Figure 7-11: Combining the 1s into a larger number*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-11：将 1 合并为更大的数字*'
- en: Once we have the number of 1s in the `1count` variable, we can replace all those
    1s with the value in `1count`. The block in [Figure 7-11](ch07.xhtml#ch7fig11)
    makes the replacement. This block also makes the initial call to the `How many
    1s` block.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`1count`变量中得到了 1 的数量，我们就可以用`1count`的值替换所有这些 1。图 [7-11](ch07.xhtml#ch7fig11)
    中的代码块完成了这个替换操作。这个代码块还会初次调用`How many 1s`代码块。
- en: In this block, we build up the new partition in the `temp` variable. We start
    by setting `temp` to `1count`. Then, we use the index variable `k` to copy the
    rest of the original partition string into `temp`, starting from character `2
    * 1count`, which is the plus sign after the last 1\. If the original partition
    consisted entirely of 1s, the `k > length of partition` test for the `repeat until`
    loop will fail immediately, so the new partition will just be the value of `1count`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们将新的分区构建在 `temp` 变量中。我们从将 `temp` 设置为 `1count` 开始。然后，我们使用索引变量 `k` 将原始分区字符串的其余部分复制到
    `temp` 中，从字符 `2 * 1count` 开始，也就是最后一个 1 后面的加号。如果原始分区完全由 1 组成，`repeat until` 循环中的
    `k > partition 的长度` 检查会立即失败，因此新的分区将只是 `1count` 的值。
- en: 'Now comes the real work: we need to decide if the string we’ve created by replacing
    some initial 1s with a single larger number qualifies as a proper partition and
    should be added to the `partitions` list. There are two things that matter here.
    First, the first term can’t be a 1\. If it is, it’s already been counted. (This
    will be the case if the original partition had only a single 1, in which case
    the `Replace 1s` block will have left it unchanged.) Second, the string of numbers
    must be in nondecreasing order. We know the original partition was in nondecreasing
    order, and all we’ve done is combine all the 1s into a larger number, so the only
    way this condition can fail is if the new first term is bigger than the second
    term. There’s also the possibility that the partition consists of a single term.
    This should be considered proper as well. The block in [Figure 7-12](ch07.xhtml#ch7fig12)
    tests for all of these cases.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是实际的工作：我们需要决定，通过将一些初始的 1 替换为一个更大的数字，我们创建的字符串是否符合有效分区的条件，应该被加入到 `partitions`
    列表中。这里有两个重要的方面。首先，第一个项不能是 1。如果它是 1，那么它已经被计数过了。（如果原始分区只有一个 1，那么 `Replace 1s` 代码块就会保持它不变。）第二，数字串必须是非递减的。我们知道原始的分区是非递减的，而我们所做的只是将所有的
    1 合并成一个更大的数字，所以唯一可能违反这个条件的情况是，如果新的第一个项大于第二个项。还有一种可能性是分区只包含一个项。这种情况也应该被认为是有效的。图
    [7-12](ch07.xhtml#ch7fig12) 中的代码块检查了所有这些情况。
- en: This block is designed to set the `proper` variable to a Boolean value, `true`
    or `false`, depending on whether the string `p` represents a proper partition.
    We start with a `repeat until` loop that extracts the first number into the `first`
    variable ❶. The loop continues until the index variable `i` encounters a plus
    sign or goes beyond the length of the string. We need this loop because the number
    may have multiple digits. At this point, if `i` has exceeded the length of the
    whole string ➋, we know the partition contains a single term, so we set `proper`
    to `true`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块旨在根据字符串`p`是否表示一个有效的分区，将`proper`变量设置为布尔值`true`或`false`。我们从一个`repeat until`循环开始，将第一个数字提取到`first`变量中❶。该循环持续进行，直到索引变量`i`遇到加号或超出字符串的长度。我们需要这个循环，因为数字可能有多个数字位。此时，如果`i`超过了整个字符串的长度➋，我们就知道这个分区包含单一项，因此将`proper`设置为`true`。
- en: 'If we haven’t reached the end of the string, we use another `repeat until`
    loop to extract the second number into the `second` variable ➌. (Again, it could
    have multiple digits.) We then perform our two main checks again: if `first` is
    greater than `second` or if `first` is `1` ➍, we set `proper` to `false`. Otherwise,
    we have a valid partition, so we set `proper` to `true`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有到达字符串的末尾，我们使用另一个`repeat until`循环将第二个数字提取到`second`变量中➌。（同样，它也可能有多个数字。）然后，我们再次进行两个主要检查：如果`first`大于`second`，或者`first`为`1`
    ➍，我们将`proper`设置为`false`。否则，我们有一个有效的分区，因此将`proper`设置为`true`。
- en: '![Image](../images/pg163_Image_195.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg163_Image_195.jpg)'
- en: '*Figure 7-12: Verifying whether the new string still qualifies as a partition*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-12：验证新的字符串是否仍然符合分区条件*'
- en: With all the blocks we’ve defined so far, we can now define a main `Iterate`
    block that coordinates the process of building the next batch of partitions from
    the previous batch. [Figure 7-13](ch07.xhtml#ch7fig13) shows how.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们目前定义的所有模块，现在可以定义一个主要的`Iterate`模块，它协调从上一批次构建下一批分区的过程。[图7-13](ch07.xhtml#ch7fig13)展示了如何操作。
- en: '![Image](../images/pg164_Image_196.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg164_Image_196.jpg)'
- en: '*Figure 7-13: Growing the list of partitions from* n *to* n *+ 1*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-13：将分区列表从* n *扩展到* n *+ 1*'
- en: This block almost reads like a verbal description of the algorithm. First, we
    add 1 to every existing partition and make a copy of the `partitions` list. Next,
    we take each partition in the copy and combine all its 1s into a single summand.
    We then evaluate the results, adding only the proper ones to the `partitions`
    list.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块几乎可以看作是算法的口头描述。首先，我们将1加到每个现有的分区，并复制`partitions`列表。接下来，我们将复制中的每个分区，合并其中所有的1为一个单独的加数。然后，我们评估结果，只将有效的分区添加到`partitions`列表中。
- en: During the evaluation phase, notice that we use the counter `j` to move backward
    through the `dup` list ❶. A quirk of the algorithm is that because of the way
    partitions are added to this list, the results end up being generated from highest
    number first to lowest number first. For example, 1 + 1 + 1 + 1 = 4 initially
    comes before 1 + 1 + 2 = 4, but after these are transformed into 4 and 2 + 2,
    the 4 is listed first. Evaluating the list in reverse puts the results back into
    ascending order.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估阶段，请注意我们使用计数器`j`向后遍历`dup`列表❶。算法的一个特殊之处在于，由于分区是以特定的方式添加到该列表中的，结果会从最大数到最小数生成。例如，1
    + 1 + 1 + 1 = 4 最初排在 1 + 1 + 2 = 4 之前，但在这些被转化为 4 和 2 + 2 后，4 会排在前面。逆向评估列表将结果重新排列为升序。
- en: Now that we have all the pieces in place, we just need the green flag code in
    [Figure 7-14](ch07.xhtml#ch7fig14) to set the program in motion.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了所有的模块，只需要在[图7-14](ch07.xhtml#ch7fig14)中使用绿色标志代码来启动程序。
- en: '![Image](../images/pg165_Image_197.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg165_Image_197.jpg)'
- en: '*Figure 7-14: Generating a list of partitions*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-14：生成分区列表*'
- en: This stack prompts for a number and iterates enough times to get the partitions
    of that number. We start off the `partitions` list with just a `1`, the only viable
    partition of 1 itself.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个栈会提示输入一个数字，并迭代足够的次数来获取该数字的分区。我们从仅包含`1`的`partitions`列表开始，1是1本身唯一有效的分区。
- en: The Results
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 7-15](ch07.xhtml#ch7fig15) shows the output of a sample run of the
    program: a list of all 11 partitions of the number 6.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-15](ch07.xhtml#ch7fig15)展示了程序示例运行的输出：数字6的所有11个分区的列表。'
- en: '![Image](../images/pg165_Image_198.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg165_Image_198.jpg)'
- en: '*Figure 7-15: Partitions of 6*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-15：6的分区*'
- en: As usual, to see the whole list for larger values of *n*, you’ll need to either
    scroll down or export the list to a text file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，要查看更大值的*n*的完整列表，你需要滚动或将列表导出到文本文件中。
- en: Hacking the Code
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: 'We can calculate *P*(*n*), the number of partitions of *n*, by having Scratch
    list them all and then seeing how long the list is. This works as long as the
    list can hold all of the partitions. Scratch’s limit on list length means this
    program works for values of *n* up to 49, which has 173,525 partitions. (On my
    nine-year-old computer, it takes less than two minutes to find them all.) For
    higher values of *n*, we can use a recurrence formula to calculate *P*(*n*) directly,
    without having to list all the partitions. It turns out that the recurrence represents
    *P*(*n*) as a combination of earlier terms that are spaced out in an interesting
    way. The relation is:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg166_Image_199.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'The sequence 1, 5, 12, 22, . . . , running down the left column, is the sequence
    of pentagonal numbers from [Chapter 4](ch04.xhtml#ch04), given as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg166_Image_200.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'The related sequence 2, 7, 15, 26, . . . , running down the right column, is
    calculated like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg166_Image_201.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'The second sequence could also be written as follows to see a different kind
    of symmetry:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg166_Image_202.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: Take a look back at [Figure 4-14](ch04.xhtml#ch4fig14) in [Project 16](ch04.xhtml#ch04lev9)
    on [page 71](ch04.xhtml#page_71) to see both of these sequences highlighted in
    the visualization of the pentagonal numbers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: We can program this recurrence in Scratch to take the calculation of values
    of *P*(*n*) much further. First, we need the custom blocks in [Figure 7-16](ch07.xhtml#ch7fig16)
    to calculate values for the two sequences just described, given a certain value
    of *k*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg166_Image_203.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-16: Formulas for calculating pentagonal numbers*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Next, [Figure 7-17](ch07.xhtml#ch7fig17) shows an `Initialize` block that sets
    up `Partitions`, a list for storing the results.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg167_Image_204.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-17: Initializing the recurrence*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: We ask how many values of *P*(*n*) to calculate and seed the list with the first
    two values, *P*(0) = 1 and *P*(1) = 1\. We then set `n` to `3` to start calculating
    at the third term of the sequence, the value for *P*(2).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The main program stack, shown in [Figure 7-18](ch07.xhtml#ch7fig18), calls `Initialize`
    and then uses a `repeat` loop to calculate the desired number of values of *P*(*n*).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg167_Image_205.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-18: Implementing the recurrence for the partition function*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We start each new *P*(*n*) value at `0` and use two custom blocks, `loop1` and
    `loop2`, to calculate the actual value using the recurrence formula, starting
    from *k* = 1\. Once the `repeat` loop is over, we remove the first item, representing
    *P*(0), from the `Partitions` list so the index numbers match the values of *n*
    ❶.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-19](ch07.xhtml#ch7fig19) shows the definitions of `loop1` and `loop2`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg168_Image_206.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-19: Loops to calculate pentagonal numbers*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In `loop1`, we look up earlier values from the `Partitions` list according to
    the left column of the recurrence rule—that is, *P*(*n* – 1), *P*(*n* – 5), *P*(*n*
    – 12), and so on—using the `p1` block to calculate the necessary pentagonal numbers.
    Each value is stored in the variable `i` and then added to the latest value in
    `Partitions`. Since the terms in the recurrence alternate between addition and
    subtraction, we use the `sign` variable ➋ to keep track of which operation is
    needed. It started as `1` (addition) before `loop1` was called in [Figure 7-18](ch07.xhtml#ch7fig18),
    and for each new term we multiply it by `-1` to switch from addition to subtraction
    or vice versa ➌. We continue looking up terms until the next pentagonal number
    (`p1`) is greater than the current value of `n` ❶.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loop1` 中，我们根据递归规则的左列查找 `Partitions` 列表中的早期值——即 *P*(*n* – 1)、*P*(*n* – 5)、*P*(*n*
    – 12) 等——使用 `p1` 块计算所需的五边形数。每个值被存储在变量 `i` 中，然后加到 `Partitions` 中的最新值。由于递归中的项交替进行加法和减法，我们使用
    `sign` 变量 ➋ 来跟踪所需的操作。在调用 [图 7-18](ch07.xhtml#ch7fig18) 中的 `loop1` 之前，它的初始值是 `1`（加法），对于每个新项，我们将其乘以
    `-1` 来切换加法与减法，或反之 ➌。我们继续查找项，直到下一个五边形数（`p1`）大于当前的 *n* ❶。
- en: 'The `loop2` block follows the same logic, but it uses `p2` to calculate terms
    from the right column of the recurrence rule: *P*(*n* – 2), *P*(*n* – 7), *P*(*n*
    – 15), and so on.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop2` 块遵循相同的逻辑，但它使用 `p2` 来计算递归规则右列的项：*P*(*n* – 2)、*P*(*n* – 7)、*P*(*n* –
    15) 等。'
- en: '[Figure 7-20](ch07.xhtml#ch7fig20) shows some sample output from this program.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-20](ch07.xhtml#ch7fig20) 显示了该程序的一些示例输出。'
- en: '![Image](../images/pg169_Image_207.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg169_Image_207.jpg)'
- en: '*Figure 7-20: The first few values of* P*(*n*), and some later ones*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-20：* P*(*n*) 的前几个值，以及一些后续值*'
- en: This approach rapidly produces correct values for *P*(*n*) through *n* = 298,
    until the numbers being combined in the recurrence exceed flintmax. As *n* continues
    to grow, the limitations of floating-point arithmetic make the calculated values
    of *P*(*n*) unreliable, oscillating wildly through incorrect values and even some
    negative numbers before the floating-point limit is reached and we get `Infinity`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法迅速生成正确的 *P*(*n*) 值，直到 *n* = 298，当递归中结合的数字超出了 flintmax。随着 *n* 的继续增大，浮点数算术的局限性使得计算出的
    *P*(*n*) 值变得不可靠，值在错误的值和一些负数之间剧烈波动，直到达到浮点数限制并得到 `Infinity`。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**7.5**We can come up with interesting counting problems for partitions by
    putting extra conditions on the summands. Write a Boolean block that screens partitions
    and returns `true` if every summand is an odd number. Apply the block to the list
    of partitions generated for a given value of *n* using the code in [Figure 7-14](ch07.xhtml#ch7fig14)
    and see how many have this property. For example, the partitions of 5 with all
    odd summands would be 1 + 1 + 1 + 1 + 1, 1 + 1 + 3, and 5 itself.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.5**我们可以通过对分割的加法项设置额外的条件，提出有趣的计数问题。编写一个布尔块，筛选分割并返回 `true`，如果每个加法项都是奇数。将该块应用于通过
    [图 7-14](ch07.xhtml#ch7fig14) 中的代码为给定值 *n* 生成的分割列表，并查看有多少个符合此条件。例如，所有加法项为奇数的 5
    的分割将是 1 + 1 + 1 + 1 + 1、1 + 1 + 3 和 5 本身。'
- en: '**7.6**Write another Boolean block to check if all the parts of a partition
    are distinct. For example, the partitions of 5 with all distinct parts would be
    1 + 4, 2 + 3, and 5 itself. The partition 1 + 2 + 2, among others, wouldn’t count,
    since it has a repeated part. Compare the number of partitions of *n* with distinct
    parts with the number of partitions of *n* with all odd parts.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.6**编写另一个布尔块，检查分割的所有部分是否都不同。例如，所有部分不同的 5 的分割将是 1 + 4、2 + 3 和 5 本身。分割 1 +
    2 + 2 等将不算，因为它有重复的部分。将 *n* 的所有不同部分的分割数与 *n* 的所有奇数部分的分割数进行比较。'
- en: '**7.7**The Indian mathematician Srinivasa Ramanujan noticed that *P*(*n*) is
    divisible by 5 whenever *n* ends in 4 or 9\. Verify that fact from a list of *P*(*n*)
    values. Remember that you can export a Scratch list as a text file to view it
    more easily. See if you can find other patterns for values of *P*(*n*) that are
    divisible by 7 and 11.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.7**印度数学家斯里尼瓦萨·拉马努金注意到，*P*(*n*) 在 *n* 以 4 或 9 结尾时能被 5 整除。通过查看 *P*(*n*) 值的列表来验证这一事实。记住，你可以将
    Scratch 列表导出为文本文件，以便更轻松查看。看看你是否能找到其他能被 7 和 11 整除的 *P*(*n*) 值的模式。'
- en: Conclusion
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: We’ve seen in earlier chapters that Scratch is good for calculating numbers
    and processing text. Now we know it’s also good for making patterns. Sometimes
    the first step in counting how many ways a pattern can occur is just making a
    list of what’s possible—one more job for Scratch Cat! Then, with the right formula
    or recurrence, we can count the occurrences of a pattern without actually having
    to list them all.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中已经看到，Scratch适合用来计算数字和处理文本。现在我们知道，它同样适合用来制作模式。有时，计算一个模式出现的方式有多少种的第一步，就是列出所有可能的情况——这又是Scratch
    Cat的工作！然后，通过正确的公式或递推关系，我们就能在不需要列出所有情况的前提下，计算模式的出现次数。
