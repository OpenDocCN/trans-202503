- en: '**7**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Experiments in Counting**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Combinatorics* is a branch of mathematics that’s often called *the art of
    counting*. The “art” is in coming up with a way to organize a counting problem
    so that the objects being counted can be generated elegantly.'
  prefs: []
  type: TYPE_NORMAL
- en: Combinatorics has many important applications. In computer science, for example,
    combinatorial algorithms are good for tasks such as sorting and searching through
    data. In telecommunications, combinatorics provides error-correcting codes and
    network protocols for efficient data transmission. In genetics, it’s used to analyze
    and model genes to understand heredity and genetic variation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter explores two classic examples from the world of combinatorics:
    Catalan numbers and partitions. For each example, we’ll develop a strategy for
    listing every instance of a pattern that satisfies a certain set of rules. Then,
    we’ll look for a recurrence formula to count all the instances without having
    to actually list them all.'
  prefs: []
  type: TYPE_NORMAL
- en: What Are Counting Problems?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some counting problems, there’s a parameter indicating a measure of size
    or quantity: say, the counting number *n*. We want to know how many ways there
    are to use *n* to generate distinct objects. A classic example is figuring out
    how many ways there are to arrange *n* items. Each unique ordering of items is
    considered to be a different object. (The answer is *n* factorial, as we saw in
    [Chapter 5](ch05.xhtml#ch05).)'
  prefs: []
  type: TYPE_NORMAL
- en: In other counting problems, there’s a single object determined by the parameter
    *n*, and we want to measure some aspect of that object. For example, we considered
    square numbers when we discussed sequences in [Chapter 4](ch04.xhtml#ch04). There,
    the object associated with *n* was a square of side length *n*, which can be built
    with *n*² 1×1 subsquares. The sequence of squares is determined by considering
    how many points there are for *n* = 1, 2, 3, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: I like to think of the parameter in a counting problem as a knob you can turn
    to get different results. The Fibonacci numbers in [Chapter 4](ch04.xhtml#ch04),
    for instance, started out as an answer to a counting problem about how many rabbits
    there will be after *n* generations, given some constraints about how the rabbits
    reproduce. Turn the knob to *n* = 6 generations and you get 8, the answer for
    the sixth generation. Turn the knob to *n* = 7 generations and you get 13.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many counting problems are solved with a sequence, and once we have a sequence,
    we can look for patterns. We might be interested in the rate of growth of the
    sequence, divisibility properties, or connections with other sequences. There’s
    a famous project that collects information about integer sequences and puts them
    in order, like a dictionary: the On-Line Encyclopedia of Integer Sequences^® (OEIS^®).
    It started off in the 1960s as a database stored on punched cards and maintained
    by Neil Sloane of AT&T Bell Labs. It’s grown considerably over the years and now
    lives at *[https://oeis.org](https://oeis.org)*. The OEIS welcomes contributions
    of new sequences from the public, so if you come up with an interesting sequence
    that nobody’s thought of before, you can submit it!'
  prefs: []
  type: TYPE_NORMAL
- en: Climbing Mountains with Catalan Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Catalan numbers* are a sequence of numbers that arise in various counting
    problems, including the one we’ll look at here. Suppose you want to build a jagged
    path of up and down steps, like charting a path over the mountains in a mountain
    range. You start at ground level and move one step forward at a time, stepping
    either up or down. At the end, you finish back at ground level. The only restriction
    is that the mountain range must not dip below ground level at any point. How many
    different patterns of up and down steps—that is, how many unique mountain ranges—can
    you create?
  prefs: []
  type: TYPE_NORMAL
- en: 'More and more mountain ranges are possible as the number of steps grows, but
    there are some important limits that stem from the central constraint. Because
    you have to stay above ground level, the very first step you take has to be up,
    not down. What’s more, there always have to be at least as many up steps as down
    steps that have been taken so far. Otherwise, if you go down more than up, you’ll
    end up below ground level. For example, if we write an up step as ↗ and a down
    step as ↘, then something like ↗↘↘↗↗↘ wouldn’t work. Spread it out in two dimensions
    to see why not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg150_Image_179.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The mountain range dips below the starting position after the first up-down,
    so it isn’t allowed. On the other hand, the step sequence ↗↗↘↘↗↘ is allowed. It
    spreads out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg151_Image_180.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Essentially, to end up back at ground level, the steps have to occur in pairs:
    for every up, there eventually has to be a corresponding down. So we can use *n*
    to represent just the number of up steps, and we can say that the Catalan number
    *C*(*n*) is the total number of acceptable paths that can be made with *n* up
    steps. The same *n* also represents the number of down steps, for a total of 2*n*
    steps in each path.'
  prefs: []
  type: TYPE_NORMAL
- en: In all, there are five acceptable paths that can be built with *n* = 3 up steps
    and *n* = 3 down steps. In other words, *C*(3) = 5\. One of those paths is the
    ↗↗↘↘↗↘ pattern I just showed. Can you find the others? It isn’t too hard to think
    through all the possible combinations with a low *n* value like 3, but as *n*
    increases, it becomes more important to have a systematic method for keeping track
    of all the paths. The beauty of finding the right method is what makes combinatorics
    the *art* of counting.
  prefs: []
  type: TYPE_NORMAL
- en: Something that worked for the Fibonacci numbers in [Chapter 4](ch04.xhtml#ch04)
    was finding a *recurrence*, a formula that let us build new numbers in the sequence
    from old ones. In that case, all we had to do was add the two previous numbers
    together to get the next number. With Catalan numbers, we might try fitting together
    old paths that we’ve already generated to form new, longer paths, but we’ll need
    to go back further than two terms in the sequence to find them all. In fact, we’ll
    have to look at every shorter path we’ve already generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build a new path with *n* up arrows by first picking any two numbers
    that add up to *n* – 1\. Let’s call them *a* and *b*. If *n* were 3, for example,
    we could choose *a* = 1 and *b* = 1, or *a* = 0 and *b* = 2, or *a* = 2 and *b*
    = 0, since those all add up to 3 – 1 = 2\. For the old paths, we know there’s
    only one path for *a* or *b* = 0\. It’s an empty path with zero up steps and zero
    down steps, where we don’t go anywhere. Likewise, there’s just one path with one
    up arrow (for *a* or *b* = 1): ↗↘. There are two paths with two up arrows (for
    *a* or *b* = 2): ↗↗↘↘ and ↗↘↗↘.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipe for building new paths is to start with an up arrow (↗), followed
    by any previously created path with *a* up arrows. Then, we add a down arrow (↘),
    followed by any previously created path with *b* up arrows. That gives us a total
    of *n* up arrows: the first up arrow followed by the *n* – 1 up arrows in the
    two paths with *a* and *b* up arrows. The first up arrow and the constraints on
    the previously generated paths guarantee that the number of down arrows never
    exceeds the number of up arrows, which would put us below ground level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use this recipe to create every possible path for *n* = 3\. For *a* =
    1 and *b* = 1, we build just one path: ↗ ↗↘ ↘ ↗ ↘. For *a* = 0 and *b* = 2, there
    are two cases: ↗↘↗↗↘↘ and ↗↘↗↘↗↘. For *a* = 2 and *b* = 0, there are also two
    cases: ↗↗↗↘↘↘ and ↗↗↘↗↘↘. And that’s it. Those are the five possible paths with
    *n* = 3 up steps.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how when *a* = 0, each newly generated path is just ↗↘ followed by an
    older path with *b* up steps. Meanwhile, when *b* = 0, the new path is just an
    old path with *a* up steps jacked up so there’s an extra ↗ at the beginning and
    an extra ↘ at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every acceptable path with *n* up steps can be generated using this simple
    recipe, as long as we consider every possible combination of values for *a* and
    *b*. For *n* = 4, for example, we would need all the values of *a* and *b* that
    add up to 3: 0 + 3, 1 + 2, 2 + 1, and 3 + 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 28: Navigating Catalan Paths'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this project we’ll write a Scratch program to build new Catalan paths using
    the approach we just discussed. First, we need to classify paths by how many up
    steps they have, so we define a block (shown in [Figure 7-1](ch07.xhtml#ch7fig1))
    that counts all the up steps in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg152_Image_181.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: How many up steps?*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg152_Image_182.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Listing all the paths*'
  prefs: []
  type: TYPE_NORMAL
- en: This block assumes that each path is expressed as a string, with a forward slash
    character (`/`) to represent a step up and a backslash character (`\`) to represent
    a step down. The block scans the string character by character. Each time it finds
    a forward slash ❶, it increases the `upcount` variable by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: We can now build a list called `Catalan` containing all the acceptable paths
    up to a desired number of up steps. We start with a path of length 0 and then
    repeatedly apply the recurrence to get longer and longer new paths. The main program
    in [Figure 7-2](ch07.xhtml#ch7fig2) just asks the user how far to go and then
    calls the custom `Iterate` block ❶ the right number of times.
  prefs: []
  type: TYPE_NORMAL
- en: The real work is in the `Iterate` block, shown in [Figure 7-3](ch07.xhtml#ch7fig3),
    which performs the recurrence.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg153_Image_183.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Making new paths from old paths*'
  prefs: []
  type: TYPE_NORMAL
- en: We use two nested loops to look at all pairs of paths that have been generated
    so far. Each path in the pair is classified by its number of up steps. For example,
    `Upcount item loop1 of Catalan` gives us the `upcount` of the first path in the
    pair ❶. Every time we find two paths that together have the correct number of
    up steps ➋, we combine them with an extra up and down step ➌ (notice the extra
    space after the `/` and `\` characters, which makes the spacing of the output
    nicer) and add the resulting new path to `Catalan`. The code is written so the
    condition for building a new Catalan path is `a + b = desired size - 1`. That
    way, when we add the extra up step and down step, we get a path with `desired
    size` up steps.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As usual, the output is constrained by the Scratch stage, but you can scroll
    to see more output or export the `Catalan` list as a text file to see the complete
    contents. [Figure 7-4](ch07.xhtml#ch7fig4) shows the top of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg154_Image_184.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: Catalan paths for* n *= 0, 1, 2, and 3*'
  prefs: []
  type: TYPE_NORMAL
- en: The first item shows the initial empty path, which grows into a path of ↗↘ when
    the recurrence is applied the first time. The figure includes the output through
    *n* = 3, showing the five acceptable paths with three up steps (list items 5 through
    9). [Figure 7-5](ch07.xhtml#ch7fig5) shows the next few paths in exported text
    format, corresponding to *n* = 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg154_Image_185.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Catalan paths for* n *= 4*'
  prefs: []
  type: TYPE_NORMAL
- en: Scratch’s list length limit of 200,000 means that this program works only up
    to *n* = 11, when 58,786 new paths are generated and added to the list containing
    the 23,714 shorter paths for values of *n* from 0 to 10\. There are too many paths
    for *n* = 12 to complete the list any further. Worse, the double loop in the `Iterate`
    block takes a long time to complete. Since every pair of paths is screened to
    see if they join to satisfy the Catalan condition, there are as many pairs of
    paths to test as the square of the length of the list so far. There’s a definite
    lag by the time we get to *n* = 10 or 11.
  prefs: []
  type: TYPE_NORMAL
- en: Still, by counting up the items in the list with a given number of steps, we
    can begin to see the sequence of Catalan numbers using this program. Starting
    with *C*(0) = *C*(1) = 1, the next several values in the sequence are 2, 5, 14,
    42, 132, 429, 1,430, 4,862, 16,796, and 58,786.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we want to know only the Catalan numbers themselves—that is, how many unique
    paths there are for each value of *n*—we don’t have to go through the trouble
    of actually constructing all the paths. Instead, we can calculate the numbers
    directly using a recurrence based on the same combinatorial insight that helped
    us generate new paths. To find *C*(*n*), we first need to find all the pairs of
    values *a* and *b* such that *a* + *b* = *n* – 1\. Then, for each pair, we can
    look up the corresponding Catalan numbers and multiply them together: *C*(*a*)
    ⋅ *C*(*b*). Finally, we add all those products up to get *C*(*n*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we want to find *C*(5). Since 5 – 1 = 4, we first need to
    find all the pairs of numbers that add up to 4\. They are 0 + 4, 1 + 3, 2 + 2,
    3 + 1, and 4 + 0\. Notice how the first value in each pair is counting up from
    0 to *n* – 1, while the second value is counting down. Next, we need the Catalan
    numbers corresponding to the values in these pairs. Assuming we’ve been using
    this recurrence to calculate all the Catalan numbers starting from *C*(0), we
    should know them already: *C*(0) = 1, *C*(1) = 1, *C*(2) = 2, *C*(3) = 5, and
    *C*(4) = 14\. We can then multiply each pair of Catalan numbers and add the results
    together to get *C*(5):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg155_Image_186.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A short way to write this recurrence formula is to use summation notation,
    where a *Σ* symbol (the uppercase Greek letter sigma) indicates an addition of
    one term for each value of the index *i* from the smallest value of *i* = 0 (indicated
    below the *Σ*) to the largest value of *i* = *n* – 1 (indicated above the *Σ*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg155_Image_187.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *i* is equivalent to *a*, and *n* – 1 – *i* is equivalent to *b*. This
    makes sense; if *a* + *b* = *n* – 1, then *b* = *n* – 1 – *a*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-6](ch07.xhtml#ch7fig6) shows some code to have Scratch calculate
    and list as many Catalan numbers as we want.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg156_Image_188.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: Making a list of Catalan numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: We name the list `C(n)` and start by adding `1` to it for *C*(0) = 1\. It would
    be much better, though, if the list indices matched the indices of the sequence
    entries, with index `1` holding *C*(1), index `2` holding *C*(2), and so on. To
    make this happen, we delete the first item from the list at the end of the program
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: As in the original Catalan program, the actual work is done in an `Iterate`
    block, which we can call as many times as we want. [Figure 7-7](ch07.xhtml#ch7fig7)
    shows the block definition.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg156_Image_189.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Applying the recurrence*'
  prefs: []
  type: TYPE_NORMAL
- en: Inside a `repeat` loop, we look up pairs of Catalan numbers, with the value
    of the variable `a` starting at `i(1)` and increasing up to `size` while the value
    of the variable `b` starts at `size` and decreases, to account for all pairs in
    the recurrence. Notice how the definition of `b` makes it count backward ❶. We
    multiply each pair of values and add them to the running total being kept in the
    `sum` variable, which is added to the list at the end of the block.
  prefs: []
  type: TYPE_NORMAL
- en: With the recurrence, Scratch is able to calculate the values of *C*(*n*) quite
    quickly, and the limiting value of the program is determined by flintmax instead
    of the maximum list length. The results are accurate until flintmax is exceeded,
    which happens after *n* = 30\. The value Scratch calculates for *C*(31) is off
    by 1\. We don’t exceed Scratch’s floating-point maximum and start getting answers
    of `Infinity`, however, until we hit *n* = 520.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.1**Here’s another recurrence for Catalan numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg157_Image_190.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After starting with *C*(0) = 1, this formula applies to all values of *n* greater
    than 0\. Program this alternative Catalan recurrence in Scratch.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.2**Write a program to make Scratch draw the up-down mountains when you
    provide a path from a row of the `Catalan` list.'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.3**There’s a relationship between the Catalan numbers and the central binomial
    coefficients in Pascal’s triangle, which are entries of the form *C*(2*n*, *n*).
    Calculate some central binomial coefficients using the program from [Project 19](ch05.xhtml#ch05lev7)
    ([Figure 5-7](ch05.xhtml#ch5fig7)), and see if you can find another formula for
    calculating Catalan numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.4**Another counting problem where Catalan numbers arise involves specifying
    the order of multiplication by nesting parentheses. Think about how you might
    multiply four numbers *a, b, c*, and *d* by changing how they’re grouped via parentheses,
    instead of changing the order of the factors. For example, ((*ab*)*c*)*d* would
    first multiply *a* and *b*, then multiply the result of that calculation (the
    *partial product*) by *c*, and finally multiply that by *d*. On the other hand,
    (*ab*)(*cd*) first multiplies *a* and *b*, then multiplies *c* and *d*, and finally
    multiplies together the two partial products. There are three more ways to group
    four numbers. Find them. Then, change the program for generating Catalan paths
    so it shows all the ways the parentheses could be grouped.'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking Down Numbers with Addition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the questions we’ve explored about numbers in earlier chapters have
    been about multiplication. For example, the prime numbers are multiplicative building
    blocks of the positive integers, and the fundamental theorem of arithmetic says
    there’s only one way to write a number as a product of primes (ignoring the order
    of the factors, that is). But what about addition? What are some ways we can write
    a number as the sum of other numbers?
  prefs: []
  type: TYPE_NORMAL
- en: 'For starters, we might focus on the number 1 and note that every positive integer
    can be written uniquely as a sum of 1s: 2 = 1 + 1, 3 = 1 + 1 + 1, and so on. We
    could also impose a different restriction and require that each *summand* (a number
    being added) be used at most once. Then, there’s a unique representation for every
    positive integer if we think in base 2\. That is, every positive integer can be
    uniquely expressed as a sum of distinct powers of 2\. (We explored binary representations
    in [Chapter 1](ch01.xhtml#ch01).) For example, the only way to get 5 without reusing
    the same power of 2 is 2² + 2⁰, or 4 + 1\. As soon as we allow a larger set of
    possible summands than the powers of 2, however, we lose uniqueness. If we permit
    3 as a summand along with the powers of 2, for instance, we can get 5 using 1
    + 4 or 2 + 3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compositions: Order Does Matter'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another decision to make is whether order should matter. Do we count 1 + 2
    and 2 + 1 as different representations of 3? If we decide they should be considered
    different, then there’s an easy way to find the number of possible representations
    of a given number *n* as a sum (also called the *compositions* of *n*). First,
    write *n* = 1 + 1 + . . . + 1\. Then, look at each plus sign and make a choice:
    either keep it or omit it and combine the numbers on each side of it. For example,
    say *n* = 3\. We could take 3 = 1 + 1 + 1 and decide to get rid of either the
    first plus sign, making 3 = 1 1 + 1 → 2 + 1, or the second plus sign, making 3
    = 1 + 1 1 → 1 + 2\. We can also keep both plus signs and get 1 + 1 + 1, or get
    rid of both and get the single summand 3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve found four compositions of 3, and that’s all there are. To see why, and
    to develop a general formula for the number of compositions of *n*, think about
    the process of going from 1 + 1 + 1 + . . . + 1 to a composition of *n*. A string
    of *n* 1s have *n* – 1 plus signs between them. For each plus sign, we have a
    binary choice to make: keep it or drop it. That means there are *n* – 1 independent
    binary decisions, which works out to 2^(*n*– 1) ways to combine the decisions
    and make a composition of *n*. The four compositions of 3 that we identified are
    “drop, keep,” “keep, drop,” “keep, keep,” and “drop, drop.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Partitions: Order Doesn’t Matter'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A more interesting situation, and one that doesn’t have an answer with such
    an easy formula, is if we decide that the order of summands *doesn’t* matter—for
    example, that 1 + 2 and 2 + 1 should be treated as the same representation of
    3\. Such a representation, where we ignore the order, is called a *partition*
    of *n* rather than a composition.
  prefs: []
  type: TYPE_NORMAL
- en: If the order of summands doesn’t matter, we might as well put the summands in
    increasing (or rather, nondecreasing) order so we can keep track of all the partitions
    in a more systematic way. We can then think of a partition as a special kind of
    composition whose terms are nondecreasing. For example, the three partitions of
    3 are 1 + 1 + 1, 1 + 2, and 3.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I say* nondecreasing *rather than* increasing *because it wouldn’t really
    be fair to think of the 1s in 1 + 1 + 1 as being in increasing order. The important
    thing is that the value of each summand isn’t less than the previous one.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s call *P*(*n*) the function that counts the number of partitions of *n*.
    Make sure you agree that *P*(1) = 1 (there’s only one partition of 1: 1 = 1) and
    that *P*(2) = 2 (2 = 1 + 1, 2 = 2). We’ve already determined that there are three
    partitions of 3, so *P*(3) = 3\. You might think you see a pattern, but the number
    of partitions of *n* starts to grow more quickly from here on: *P*(4) = 5, *P*(5)
    = 7, and by the time we get to 12 we have *P*(12) = 77.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 29: A Partition Expedition'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s develop a Scratch program to find all the partitions for a given value
    of *n*. We’ll store the results in a `partitions` list, with each partition represented
    as a string of numbers separated by plus signs without any spaces in between,
    such as `1+1+2`. Our strategy will be to start at *n* = 1 and work our way up
    to the desired value of *n*, replacing the contents of `partitions` with the current
    *n*’s partitions every step of the way. This means we need a way to use a list
    of all the partitions of *n* to find all the partitions of *n* + 1.
  prefs: []
  type: TYPE_NORMAL
- en: Some partitions of *n* + 1 are available by adding a summand of 1 to the start
    of each partition of *n*. This is just a matter of joining `1+` to each item in
    the `partitions` list. [Figure 7-8](ch07.xhtml#ch7fig8) shows a custom block to
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg159_Image_191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: Building new partitions from old partitions*'
  prefs: []
  type: TYPE_NORMAL
- en: This block simply cycles through the `partitions` list, taking one item at a
    time, adding `1+` to the beginning of it, and storing the result back in the same
    position in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining partitions of *n* + 1 can be built by looking back at the partitions
    of *n* – 1 and adding a new first term of 2, looking back at the partitions of
    *n* – 2 and adding a new first term of 3, and so on. This step is a little trickier
    since, because of the nondecreasing order rule, not every newly created partition
    will be acceptable. For example, the only partitions of *n* – 1 that can have
    a 2 added to them are the ones that had a smallest term of at least 2 to begin
    with. If there’s a 1 in the partition, putting a 2 in front breaks the order.
    Similarly, when adding a 3 to a partition of *n* – 2, the original partition can’t
    begin with a 1 or a 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another complication is that the `partitions` list in our program holds only
    the partitions of *n*, which are modified to become the partitions of *n* + 1\.
    We don’t actually have a record of the earlier partitions of *n* – 1, *n* – 2,
    and so on to look back at. There’s a workaround, though: once we’ve taken all
    the partitions of *n* and added a 1 at the beginning to make partitions of *n*
    + 1, we can look at each new partition and combine all the 1s. If there are two
    1s, this will have the same effect as adding a 2 to the partitions of *n* – 1\.
    Similarly, if there are three, it will be equivalent to adding a 3 to partitions
    of *n* – 2, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: To see why this works, consider the case of going from *n* = 5 to *n* + 1 =
    6\. One partition of 5 is 1 + 2 + 2, and adding an extra 1 to it gives us 1 +
    1 + 2 + 2, a partition of 6\. If we combine those 1s into a 2, we get 2 + 2 +
    2, another partition of 6\. This is the equivalent of looking back at the partitions
    of *n* – 1 = 4, finding the partition 2 + 2, and adding a 2 in front of it. Likewise,
    another partition of 5 is 1 + 1 + 3\. Adding an extra 1 gives us 1 + 1 + 1 + 3
    = 6\. If we combine those 1s into a 3, we get 3 + 3, the same as if we’d looked
    back at the partitions of *n* – 2 = 3, found the partition 3 (any number is a
    valid partition of itself), and added a 3 in front of it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing this process in code takes a few steps. First, we need to copy
    the contents of `partitions` (the partitions of *n* + 1 that we got by adding
    an initial term of 1 to the old partitions of *n*) into a new list so we don’t
    overwrite them. The block in [Figure 7-9](ch07.xhtml#ch7fig9) does this, placing
    the copy in a list called `dup`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg160_Image_192.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: Copying the list of partitions to a duplicate list*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a way to count how many 1s there are at the start of a given partition.
    The block in [Figure 7-10](ch07.xhtml#ch7fig10) handles this task.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg161_Image_193.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: Counting the number of 1s in a partition*'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we’re assuming that each partition is a string of numbers separated
    by plus signs, but we don’t know how many digits each number contains. So this
    `How many 1s` block looks at the string two characters at a time and checks if
    the first character (`m`) is a 1 and the second (`n`) is a plus sign. The `repeat
    until` loop keeps incrementing `1count` until this is no longer the case. Checking
    for the plus sign as well as the 1 prevents a string like `1+10` from being counted
    as two 1s. Notice also that we temporarily add an extra plus sign to the end of
    the string at the start of the block. Without this, the final 1 in a string of
    all 1s (like `1+1+1`) wouldn’t be counted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg161_Image_194.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Combining the 1s into a larger number*'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the number of 1s in the `1count` variable, we can replace all those
    1s with the value in `1count`. The block in [Figure 7-11](ch07.xhtml#ch7fig11)
    makes the replacement. This block also makes the initial call to the `How many
    1s` block.
  prefs: []
  type: TYPE_NORMAL
- en: In this block, we build up the new partition in the `temp` variable. We start
    by setting `temp` to `1count`. Then, we use the index variable `k` to copy the
    rest of the original partition string into `temp`, starting from character `2
    * 1count`, which is the plus sign after the last 1\. If the original partition
    consisted entirely of 1s, the `k > length of partition` test for the `repeat until`
    loop will fail immediately, so the new partition will just be the value of `1count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the real work: we need to decide if the string we’ve created by replacing
    some initial 1s with a single larger number qualifies as a proper partition and
    should be added to the `partitions` list. There are two things that matter here.
    First, the first term can’t be a 1\. If it is, it’s already been counted. (This
    will be the case if the original partition had only a single 1, in which case
    the `Replace 1s` block will have left it unchanged.) Second, the string of numbers
    must be in nondecreasing order. We know the original partition was in nondecreasing
    order, and all we’ve done is combine all the 1s into a larger number, so the only
    way this condition can fail is if the new first term is bigger than the second
    term. There’s also the possibility that the partition consists of a single term.
    This should be considered proper as well. The block in [Figure 7-12](ch07.xhtml#ch7fig12)
    tests for all of these cases.'
  prefs: []
  type: TYPE_NORMAL
- en: This block is designed to set the `proper` variable to a Boolean value, `true`
    or `false`, depending on whether the string `p` represents a proper partition.
    We start with a `repeat until` loop that extracts the first number into the `first`
    variable ❶. The loop continues until the index variable `i` encounters a plus
    sign or goes beyond the length of the string. We need this loop because the number
    may have multiple digits. At this point, if `i` has exceeded the length of the
    whole string ➋, we know the partition contains a single term, so we set `proper`
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we haven’t reached the end of the string, we use another `repeat until`
    loop to extract the second number into the `second` variable ➌. (Again, it could
    have multiple digits.) We then perform our two main checks again: if `first` is
    greater than `second` or if `first` is `1` ➍, we set `proper` to `false`. Otherwise,
    we have a valid partition, so we set `proper` to `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg163_Image_195.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Verifying whether the new string still qualifies as a partition*'
  prefs: []
  type: TYPE_NORMAL
- en: With all the blocks we’ve defined so far, we can now define a main `Iterate`
    block that coordinates the process of building the next batch of partitions from
    the previous batch. [Figure 7-13](ch07.xhtml#ch7fig13) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg164_Image_196.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: Growing the list of partitions from* n *to* n *+ 1*'
  prefs: []
  type: TYPE_NORMAL
- en: This block almost reads like a verbal description of the algorithm. First, we
    add 1 to every existing partition and make a copy of the `partitions` list. Next,
    we take each partition in the copy and combine all its 1s into a single summand.
    We then evaluate the results, adding only the proper ones to the `partitions`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: During the evaluation phase, notice that we use the counter `j` to move backward
    through the `dup` list ❶. A quirk of the algorithm is that because of the way
    partitions are added to this list, the results end up being generated from highest
    number first to lowest number first. For example, 1 + 1 + 1 + 1 = 4 initially
    comes before 1 + 1 + 2 = 4, but after these are transformed into 4 and 2 + 2,
    the 4 is listed first. Evaluating the list in reverse puts the results back into
    ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the pieces in place, we just need the green flag code in
    [Figure 7-14](ch07.xhtml#ch7fig14) to set the program in motion.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg165_Image_197.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: Generating a list of partitions*'
  prefs: []
  type: TYPE_NORMAL
- en: This stack prompts for a number and iterates enough times to get the partitions
    of that number. We start off the `partitions` list with just a `1`, the only viable
    partition of 1 itself.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 7-15](ch07.xhtml#ch7fig15) shows the output of a sample run of the
    program: a list of all 11 partitions of the number 6.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg165_Image_198.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-15: Partitions of 6*'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, to see the whole list for larger values of *n*, you’ll need to either
    scroll down or export the list to a text file.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can calculate *P*(*n*), the number of partitions of *n*, by having Scratch
    list them all and then seeing how long the list is. This works as long as the
    list can hold all of the partitions. Scratch’s limit on list length means this
    program works for values of *n* up to 49, which has 173,525 partitions. (On my
    nine-year-old computer, it takes less than two minutes to find them all.) For
    higher values of *n*, we can use a recurrence formula to calculate *P*(*n*) directly,
    without having to list all the partitions. It turns out that the recurrence represents
    *P*(*n*) as a combination of earlier terms that are spaced out in an interesting
    way. The relation is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg166_Image_199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The sequence 1, 5, 12, 22, . . . , running down the left column, is the sequence
    of pentagonal numbers from [Chapter 4](ch04.xhtml#ch04), given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg166_Image_200.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The related sequence 2, 7, 15, 26, . . . , running down the right column, is
    calculated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg166_Image_201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second sequence could also be written as follows to see a different kind
    of symmetry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg166_Image_202.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Take a look back at [Figure 4-14](ch04.xhtml#ch4fig14) in [Project 16](ch04.xhtml#ch04lev9)
    on [page 71](ch04.xhtml#page_71) to see both of these sequences highlighted in
    the visualization of the pentagonal numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We can program this recurrence in Scratch to take the calculation of values
    of *P*(*n*) much further. First, we need the custom blocks in [Figure 7-16](ch07.xhtml#ch7fig16)
    to calculate values for the two sequences just described, given a certain value
    of *k*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg166_Image_203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-16: Formulas for calculating pentagonal numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, [Figure 7-17](ch07.xhtml#ch7fig17) shows an `Initialize` block that sets
    up `Partitions`, a list for storing the results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg167_Image_204.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-17: Initializing the recurrence*'
  prefs: []
  type: TYPE_NORMAL
- en: We ask how many values of *P*(*n*) to calculate and seed the list with the first
    two values, *P*(0) = 1 and *P*(1) = 1\. We then set `n` to `3` to start calculating
    at the third term of the sequence, the value for *P*(2).
  prefs: []
  type: TYPE_NORMAL
- en: The main program stack, shown in [Figure 7-18](ch07.xhtml#ch7fig18), calls `Initialize`
    and then uses a `repeat` loop to calculate the desired number of values of *P*(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg167_Image_205.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-18: Implementing the recurrence for the partition function*'
  prefs: []
  type: TYPE_NORMAL
- en: We start each new *P*(*n*) value at `0` and use two custom blocks, `loop1` and
    `loop2`, to calculate the actual value using the recurrence formula, starting
    from *k* = 1\. Once the `repeat` loop is over, we remove the first item, representing
    *P*(0), from the `Partitions` list so the index numbers match the values of *n*
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-19](ch07.xhtml#ch7fig19) shows the definitions of `loop1` and `loop2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg168_Image_206.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-19: Loops to calculate pentagonal numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: In `loop1`, we look up earlier values from the `Partitions` list according to
    the left column of the recurrence rule—that is, *P*(*n* – 1), *P*(*n* – 5), *P*(*n*
    – 12), and so on—using the `p1` block to calculate the necessary pentagonal numbers.
    Each value is stored in the variable `i` and then added to the latest value in
    `Partitions`. Since the terms in the recurrence alternate between addition and
    subtraction, we use the `sign` variable ➋ to keep track of which operation is
    needed. It started as `1` (addition) before `loop1` was called in [Figure 7-18](ch07.xhtml#ch7fig18),
    and for each new term we multiply it by `-1` to switch from addition to subtraction
    or vice versa ➌. We continue looking up terms until the next pentagonal number
    (`p1`) is greater than the current value of `n` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loop2` block follows the same logic, but it uses `p2` to calculate terms
    from the right column of the recurrence rule: *P*(*n* – 2), *P*(*n* – 7), *P*(*n*
    – 15), and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-20](ch07.xhtml#ch7fig20) shows some sample output from this program.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg169_Image_207.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-20: The first few values of* P*(*n*), and some later ones*'
  prefs: []
  type: TYPE_NORMAL
- en: This approach rapidly produces correct values for *P*(*n*) through *n* = 298,
    until the numbers being combined in the recurrence exceed flintmax. As *n* continues
    to grow, the limitations of floating-point arithmetic make the calculated values
    of *P*(*n*) unreliable, oscillating wildly through incorrect values and even some
    negative numbers before the floating-point limit is reached and we get `Infinity`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.5**We can come up with interesting counting problems for partitions by
    putting extra conditions on the summands. Write a Boolean block that screens partitions
    and returns `true` if every summand is an odd number. Apply the block to the list
    of partitions generated for a given value of *n* using the code in [Figure 7-14](ch07.xhtml#ch7fig14)
    and see how many have this property. For example, the partitions of 5 with all
    odd summands would be 1 + 1 + 1 + 1 + 1, 1 + 1 + 3, and 5 itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.6**Write another Boolean block to check if all the parts of a partition
    are distinct. For example, the partitions of 5 with all distinct parts would be
    1 + 4, 2 + 3, and 5 itself. The partition 1 + 2 + 2, among others, wouldn’t count,
    since it has a repeated part. Compare the number of partitions of *n* with distinct
    parts with the number of partitions of *n* with all odd parts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.7**The Indian mathematician Srinivasa Ramanujan noticed that *P*(*n*) is
    divisible by 5 whenever *n* ends in 4 or 9\. Verify that fact from a list of *P*(*n*)
    values. Remember that you can export a Scratch list as a text file to view it
    more easily. See if you can find other patterns for values of *P*(*n*) that are
    divisible by 7 and 11.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve seen in earlier chapters that Scratch is good for calculating numbers
    and processing text. Now we know it’s also good for making patterns. Sometimes
    the first step in counting how many ways a pattern can occur is just making a
    list of what’s possible—one more job for Scratch Cat! Then, with the right formula
    or recurrence, we can count the occurrences of a pattern without actually having
    to list them all.
  prefs: []
  type: TYPE_NORMAL
