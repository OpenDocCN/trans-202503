["```\nand eax, 1111111111111000000000000b \n```", "```\nand eax, 1111111111111000000000000b \ncmp eax, 1001011110011000000000000b \n```", "```\nand eax, 1111111111111000000000000b\ncmp eax, 12F3h shl 12\n```", "```\nand eax, 1111111111111000000000000b\nshr eax, 12\ncmp eax, 12F3h\n `Other operations that require the bit string at bit #0` \n```", "```\nand eax, 1FFFh      ; Strip all but bits 0 to 12 from EAX\nand ebx, 0FE000FFFh ; Clear bits 12 to 24 in EBX\nshl eax, 12         ; Move bits 0 to 12 to 12 to 24 in EAX\nor ebx,eax          ; Merge the bits into EBX\n```", "```\nStartPosn = 12 \nBitMask   = 1FFFh shl StartPosn ; Mask occupies bits 12 to 24\n        . \n        .\n        . \n   shl eax, StartPosn   ; Move into position\n   and eax, BitMask     ; Strip all but bits 12 to 24 from EAX\n   and ebx, not BitMask ; Clear bits 12 to 24 in EBX\n   or  ebx, eax         ; Merge the bits into EBX\n```", "```\n test eax, 10000b  ; Check bit #4 to see if it is 0 or 1\n     jnz  bitIsSet\n\n    `Do this if the bit is clear`\n        .\n        .\n        .\nbitIsSet:   ; Branch here if the bit is set\n```", "```\n test eax, 10010110b \n     jz   noBitsSet\n\n    `Do whatever needs to be done if one of the bits is set`\n\nnoBitsSet: \n```", "```\n and eax, bitMask \n     cmp eax, bitMask \n     jne allBitsArentSet \n\n; All the bit positions in EAX corresponding to the set \n; bits in bitMask are equal to 1 if we get here.\n\n    `Do whatever needs to be done if the bits match`\n\nallBitsArentSet: \n```", "```\nnot  eax \ntest eax, bitMask \njnz  NotAllOnes\n\n; At this point, EAX contained all 1s in the bit positions \n; occupied by 1s in the bitMask constant. \n\n    `Do whatever needs to be done at this point`\n\nNotAllOnes: \n```", "```\nbt`x`  `bits_to_test`, `bit_number`\nbt`x`  `reg`[16], `reg`[16]\nbt`x`  `reg`[32], `reg`[32]\nbt`x`  `reg`[64], `reg`[64]\nbt`x`  `reg`[16], `constant`\nbt`x`  `reg`[32], `constant`\nbt`x`  `reg`[64], `constant`\nbt`x`  `mem`[16], `reg`[16]\nbt`x`  `mem`[32], `reg`[32]\nbt`x`  `mem`[64], `reg`[64]\nbt`x`  `mem`[16], `constant`\nbt`x`  `mem`[32], `constant`\nbt`x`  `mem`[64], `constant`\n```", "```\nshr  al, 1\njc   LOBitWasSet\n```", "```\nshl  bx, 5 \nand  ax, 1111111000011111b \nor   ax, bx \n```", "```\n; Listing 12-1\n\n; Demonstrate inserting bit strings into a register.\n\n; Note that this program must be assembled and linked\n; with the \"LARGEADDRESSAWARE:NO\" option.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 12-1\", 0\n\n; The index into the following table specifies the length \n; of the bit string at each position. There are 65 entries\n; in this table (one for each bit length from 0 to 64). \n\n            .const\nMaskByLen   equ     this qword\n    qword   0\n    qword   1,           3,           7,           0fh\n    qword   1fh,         3fh,         7fh,         0ffh\n    qword   1ffh,        3ffh,        7ffh,        0fffh\n    qword   1fffh,       3fffh,       7fffh,       0ffffh\n    qword   1ffffh,      3ffffh,      7ffffh,      0fffffh\n    qword   1fffffh,     3fffffh,     7fffffh,     0ffffffh \n    qword   1ffffffh,    3ffffffh,    7ffffffh,    0fffffffh \n    qword   1fffffffh,   3fffffffh,   7fffffffh,   0ffffffffh\n\n    qword   1ffffffffh,         03ffffffffh\n    qword   7ffffffffh,         0fffffffffh\n\n    qword   1fffffffffh,        03fffffffffh\n    qword   7fffffffffh,        0ffffffffffh\n\n    qword   1ffffffffffh,       03ffffffffffh\n    qword   7ffffffffffh,       0fffffffffffh\n\n    qword   1fffffffffffh,      03fffffffffffh\n    qword   7fffffffffffh,      0ffffffffffffh\n\n    qword   1ffffffffffffh,     03ffffffffffffh\n    qword   7ffffffffffffh,     0fffffffffffffh\n\n    qword   1fffffffffffffh,    03fffffffffffffh\n    qword   7fffffffffffffh,    0ffffffffffffffh\n\n    qword   1ffffffffffffffh,   03ffffffffffffffh\n    qword   7ffffffffffffffh,   0fffffffffffffffh\n\n    qword   1fffffffffffffffh,  03fffffffffffffffh\n    qword   7fffffffffffffffh,  0ffffffffffffffffh\n\nVal2Merge   qword   12h, 1eh, 5555h, 1200h, 120h\nLenInBits   byte    5,     9,    16,    16,   12\nStartPosn   byte    7,     4,     4,    12,   18\n\nMergeInto   qword   0ffffffffh, 0, 12345678h\n            qword   11111111h, 0f0f0f0fh\n\n            include getTitle.inc\n            include print.inc\n\n            .code\n\n; mergeBits(Val2Merge, MergeWith, Start, Length):\n; Length (LenInBits[i]) value is passed in DL.\n; Start (StartPosn[i]) is passed in CL.\n; Val2Merge (Val2Merge[i]) and MergeWith (MergeInto[i])\n; are passed in RBX and RAX.\n\n; mergeBits result is returned in RAX.\n\nmergeBits   proc\n            push    rbx\n            push    rcx\n            push    rdx\n            push    r8\n            movzx   edx, dl         ; Zero-extends to RDX\n            mov     rdx, MaskByLen[rdx * 8]\n            shl     rdx, cl\n            not     rdx\n            shl     rbx, cl\n            and     rax, rdx\n            or      rax, rbx\n            pop     r8\n            pop     rdx\n            pop     rcx\n            pop     rbx\n            ret\nmergeBits   endp \n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rsi\n            push    rdi\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56         ; Shadow storage\n\n; The following loop calls mergeBits as\n; follows:\n\n;  mergeBits(Val2Merge[i], MergeInto[i], \n;            StartPosn[i], LenInBits[i]);\n\n; Where \"i\" runs from 4 down to 0.\n\n; Index of the last element in the arrays:\n\n            mov     r10, (sizeof LenInBits) - 1\ntestLoop:   \n\n; Fetch the Val2Merge element and write\n; its value to the display while it is handy.\n\n            mov     rdx, Val2Merge[r10 * 8]\n            call    print\n            byte    \"merge( %x, \", 0\n            mov     rbx, rdx\n\n; Fetch the MergeInto element and write\n; its value to the display.\n\n            mov     rdx, MergeInto[r10 * 8]\n            call    print\n            byte    \"%x, \", 0\n            mov     rax, rdx\n\n; Fetch the StartPosn element and write\n; its value to the display.\n\n            movzx   edx, StartPosn[r10 * 1] ; Zero-extends to RDX\n            call    print\n            byte    \"%d, \", 0\n            mov     rcx, rdx\n\n; Fetch the LenInBits element and write\n; its value to the display.\n\n            movzx   edx, LenInBits[r10 * 1] ; Zero-extends to RDX\n            call    print\n            byte    \"%d ) = \", 0\n\n; Call mergeBits(Val2Merge, MergeInto,\n;                StartPosn, LenInBits)\n\n            call    mergeBits\n\n; Display the function result (returned\n; in RAX). For this program, the results\n; are always 32 bits, so it prints only\n; the LO 32 bits of RAX:\n\n            mov     edx, eax\n            call    print\n            byte    \"%x\", nl, 0\n\n; Repeat for each element of the array.\n\n            dec     r10\n jns     testLoop\n\nallDone:    leave\n            pop     rdi\n            pop     rsi\n            pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**sbuild listing12-1**\n\nC:\\>**echo off**\n Assembling: listing12-1.asm\nc.cpp\n\nC:\\>**listing12-1**\nCalling Listing 12-1:\nmerge(120, f0f0f0f, 18, 12) = 4830f0f\nmerge(1200, 11111111, 12, 16) = 11200111\nmerge(5555, 12345678, 4, 16) = 12355558\nmerge(1e, 0, 4, 9) = 1e0\nmerge(12, ffffffff, 7, 5) = fffff97f\nListing 12-1 terminated\n```", "```\nmov eax, ebx        ; Copy data to destination\nand eax, 111100000b ; Strip unwanted bits\nshr eax, 5          ; Right-justify to bit position 0\n```", "```\nmovzx edx, Length\nlea   r8, MaskByLen      ; Table from Listing 12-1\nmov   rdx, [r8][rdx * 8]\nmov   cl, StartingPosition\nmov   rax, rbx\nshr   rax, cl\nand   rax, rdx\n```", "```\nbextr `reg`[dest], `reg`[src], `reg`[ctrl]\nbextr `reg`[dest], `mem`[src], `reg`[ctrl]\n```", "```\n; Listing 12-2\n\n; Demonstrate extracting bit strings from a register.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 12-2\", 0\n\n            include getTitle.inc\n            include print.inc\n\n; Here is the \"asmMain\" function.\n\n            .code\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rsi\n            push    rdi\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56         ; Shadow storage\n\n; >>>> Unique code for various listings:\n\n            mov     rax, 123456788abcdefh\n            mov     bl, 4\n            mov     bh, 16\n\n            bextr   rdx, rax, rbx\n\n            call    print\n            byte    \"Extracted bits: %x\", nl, 0\n\n; <<<< End of unique code.\n\nallDone:    leave\n            pop     rdi\n            pop     rsi\n pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing12-2**\n\nC:\\>**echo off**\n Assembling: listing12-2.asm\nc.cpp\n\nC:\\>**listing12-2**\nCalling Listing 12-2:\nExtracted bits: bcde\nListing 12-2 terminated\n```", "```\nblsi `reg`[dest], `reg`[src]\nblsi `reg`[dest], `mem`[src]\n```", "```\n; >>>> Unique code for various listings.\n\nmov     r8, 12340000h\nblsi    edx, r8\n\ncall    print\nbyte    \"Extracted bit: %x\", nl, 0\n\n; <<<< End of unique code.\n```", "```\nExtracted bit: 40000\n```", "```\nandn `reg`[dest], `reg`[src1], `reg`[src2]\nandn `reg`[dest], `reg`[src1], `mem`[src2]\n```", "```\n; >>>> Unique code for various listings.\n\nmov     r8, 12340000h\nblsi    edx, r8\nandn    r8, rdx, r8\n\n; Output value 1 is in RDX (extracted bit),\n; output value 2 in R8 (value with deleted bit).\n\ncall    print\nbyte    \"Extracted bit: %x, result: %x\", nl, 0\n\n; <<<< End of unique code.\n```", "```\nExtracted bit: 40000, result: 12300000\n```", "```\nblsr `reg`[dest], `reg`[src]\nblsr `reg`[dest], `mem`[src]\n```", "```\n; >>>> Unique code for various listings.\n\nmov     r8, 12340000h\nblsr    edx, r8\n\n; Output value 1 is in RDX (extracted bit), resulting value.\n\ncall    print\nbyte    \"Value with extracted bit: %x\", nl, 0\n\n; <<<< End of unique code.\n```", "```\nValue with extracted bit: 12300000\n```", "```\nblsmsk `reg`[dest], `reg`[src]\nblsmsk `reg`[dest], `mem`[src]\n```", "```\n; >>>> Unique code for various listings.\n\nmov     r8, 12340000h\nblsmsk  edx, r8\n\n; Output value 1 is in RDX (mask).\n\ncall    print\nbyte    \"Mask: %x\", nl, 0\n\n; <<<< End of unique code.\n```", "```\nMask: 7ffff\n```", "```\n; >>>> Unique code for various listings.\n\nmov     r8, 12340000h\nblsi    rdx, r8\ndec     rdx\n\n; Output value 1 is in RDX (mask).\n\ncall    print\nbyte    \"Mask: %x\", nl, 0\n\n; <<<< End of unique code.\n```", "```\nMask: 3ffff\n```", "```\ntzcnt `reg`[dest], `reg`[src]\ntzcnt `reg`[dest], `mem`[src]\n```", "```\nand ebx, not 11110001000000000000b ; Mask out destination bits\nshl eax, 12                        ; Move source bits into position\nor  ebx, eax                       ; Merge the bit set into EBX\n```", "```\nand ebx, not 11110001000000000000b\nand eax, 11110001000000000000b  ; Mask out destination bits\nshl eax, 2    ; Spread out bits: 1 to 4 goes to 3 to 6 and 0 goes to 2\nbtr eax, 2    ; Bit 2 -> carry and then clear bit 2\nrcl eax, 13   ; Shift in carry and put bits into final position\nor  ebx, eax  ; Merge the bit set into EBX\n```", "```\nmov eax, ebx \nand eax, 11110001000000000000b  ; Strip unwanted bits\nshr eax, 5                      ; Put bit 12 into bit 7, and so on\nshr ah, 3                       ; Move bits 11 to 14 to 8 to 11\nshr eax, 7                      ; Move down to bit 0\n```", "```\n; EAX - Originally contains a value into which we \n;       insert bits from EBX.\n; EBX - LO bits contain the values to insert into EAX.\n; EDX - Bitmap with 1s indicating the bit positions in \n;       EAX to insert.\n; CL -  Scratchpad register.\n\n          mov cl, 32      ; Count number of bits we rotate\n          jmp DistLoop\n\nCopyToEAX:\n          rcr ebx, 1      ; Don't use SHR, must preserve Z-flag\n          rcr eax, 1 \n          jz  Done \nDistLoop: dec cl \n          shr edx, 1 \n          jc  CopyToEAX \n          ror eax, 1      ; Keep current bit in EAX\n          jnz DistLoop \n\nDone:     ror eax, cl     ; Reposition remaining bits \n```", "```\n; EAX - Destination register.\n; EBX - Source register.\n; EDX - Bitmap with 1s representing bits to copy to EAX.\n; EBX and EDX are not preserved.\n\n     xor eax, eax    ; Clear destination register \n     jmp ShiftLoop\n\nShiftInEAX:  \n     rcl ebx, 1      ; EBX to EAX\n     rcl eax, 1\nShiftLoop:   \n     shl edx, 1      ; Check to see if we need to copy a bit\n     jc  ShiftInEAX  ; If carry set, go copy the bit\n     rcl ebx, 1      ; Current bit is uninteresting, skip it\n     jnz ShiftLoop   ; Repeat as long as there are bits in EDX\n```", "```\npdep `reg`[dest], `reg`[src], `reg`[mask]\npdep `reg`[dest], `reg`[src], `mem`[mask]\npext `reg`[dest], `reg`[src], `reg`[mask]\npext `reg`[dest], `reg`[src], `mem`[mask]\n```", "```\n; >>>> Unique code for various listings.\n\nmov     r8d, 12340000h\nmov     r9d, 0F0f000Fh\npext    edx, r8d, r9d\n\n; Output value 1 is in RDX (mask).\n\ncall    print\nbyte    \"Extracted: %x\", nl, 0\n\n; <<<< End of unique code.\n------------------------------------------------------------------------------\nExtracted: 240\n```", "```\nmov     r8d, 1234h\nmov     r9d, 0F0FF00Fh \npdep    edx, r8d, r9d\n\n; Output value 1 is in RDX (mask).\n\ncall    print\nbyte    \"Distributed: %x\", nl, 0\n------------------------------------------------------------------------------\nDistributed: 1023004\n```", "```\n`element_address_in_bits` = \n `base_address_in_bits` + `index` * `element_size_in_bits` \n```", "```\n`yte_of_1st_bit` = \n    `base_address` + (`index` * `element_size_in_bits`) / 8\n\n`offset_to_1st_bit` = \n    (`index` * `element_size_in_bits`) % 8\n```", "```\n .data\nAO3Bobjects  byte (200 * 3)/8 + 2 dup (?)  ; \"+2\" handles truncation\n```", "```\n; Extract the `i`th group of 3 bits in AO3Bobjects \n; and leave this value in EAX.\n\nxor  ecx, ecx             ; Put `i` / 8 remainder here\nmov  eax, i               ; Get the index into the array\nlea  rax, [rax + rax * 2] ; RAX := RAX * 3 (3 bits/element)\nshrd rcx, rax, 3          ; RAX / 8 -> RAX and RAX mod 8 -> RCX \n                          ; (HO bits)\nshr  rax, 3               ; Remember, shrd doesn't modify EAX\nrol  rcx, 3               ; Put remainder into LO 3 bits of RCX\n\n; Okay, fetch the word containing the 3 bits we want to \n; extract. We have to fetch a word because the last bit or two \n; could wind up crossing the byte boundary (that is, bit offset 6 \n; and 7 in the byte).\n\nlea r8, AO3Bobjects\nmov ax, [r8][rax * 1]\nshr ax, cl                ; Move bits down to bit 0\nand eax, 111b             ; Remove the other bits (incl HO RAX)\n```", "```\n; Listing 12-10\n\n; Creating a bit mask with blsi and dec.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 12-10\", 0\n\nMasks       equ     this word\n            word    not 0111b,            not 00111000b\n            word    not 000111000000b,    not 1110b\n            word    not 01110000b,        not 001110000000b\n            word    not 00011100b,        not 11100000b\n\n            .data\ni           dword   5\nAO3Bobjects byte    (200*3)/8 + 2 dup (?)   ; \"+2\" handles truncation\n\n include getTitle.inc\n            include print.inc\n\n            .code\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rsi\n            push    rdi\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56           ; Shadow storage\n\n            mov     eax, 7            ; Value to store\n\n            mov     ebx, i            ; Get the index into the array\n            mov     ecx, ebx          ; Use LO 3 bits as index\n            and     ecx, 111b         ; into Masks table\n            lea     r8, Masks\n            mov     dx, [r8][rcx * 2] ; Get bit mask\n\n; Convert index into the array into a bit index.\n; To do this, multiply the index by 3:\n\n            lea     rbx, [rbx + rbx * 2]\n\n; Divide by 8 to get the byte index into EBX\n; and the bit index (the remainder) into ECX:\n\n            shrd    ecx, ebx, 3\n            shr     ebx, 3\n            rol     ecx, 3\n\n; Grab the bits and clear those we're inserting.\n\n            lea     r8, AO3Bobjects\n            and     dx, [r8][rbx * 1]\n\n; Put our 3 bits in their proper location.\n\n            shl     ax, cl\n\n; Merge bits into destination.\n\n            or      dx, ax\n\n; Store back into memory.\n\n            mov     [r8][rbx * 1], dx\n\n mov     edx, dword ptr AO3Bobjects\n            call    print\n            byte    \"value:%x\", nl, 0\n\nallDone:    leave\n            pop     rdi\n            pop     rsi\n            pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nvalue:38000\n```", "```\n000 000 000 000 000 111 000 000 000 000 00 ...\n```", "```\n0000 0000 0000 0011 1000 0000 0000 0000\n```", "```\n mov ecx, -32  ; Count off the bit positions in ECX\nTstLp:    shr eax, 1    ; Check to see if current bit\n                        ; position contains a 1\n          jc  Done      ; Exit loop if it does \n          inc ecx       ; Bump up our bit counter by 1\n          jnz TstLp     ; Exit if we execute this loop 32 times\n\nDone:     add cl, 32    ; Adjust loop counter so it holds \n                        ; the bit position\n\n; At this point, CL contains the bit position of the \n; first set bit. CL contains 32 if EAX originally \n; contained 0 (no set bits). \n```", "```\nbsr `dest`[reg], `reg`[src] \nbsr `dest`[reg], `mem`[src] \nbsf `dest`[reg], `reg`[src] \nbsf `dest`[reg], `mem`[src] \n```", "```\nmov ebx, SomeValue  ; Value whose bits we want to check\nbsf eax, ebx        ; Put position of first set bit in EAX\njz  NoBitsSet       ; Branch if SomeValue contains 0\nmov FirstBit, eax   ; Save location of first set bit\n    .\n    .\n    .\n```", "```\n bsf ecx, eax       ; Locate first set bit in EAX\n          jz  noBitFound     ; If we found a bit, clear it\n\n          btr eax, ecx       ; Clear the bit we just found\n\nnoBitFound: \n```", "```\n; BitCount1:\n\n; Counts the bits in the EAX register, \n; returning the count in EBX.\n\n          mov cl, 32    ; Count the 32 bits in EAX\n          xor ebx, ebx  ; Accumulate the count here\nCntLoop:  shr eax, 1    ; Shift bit out of EAX and into carry\n          adc bl, 0     ; Add the carry into the EBX register\n          dec cl        ; Repeat 32 times\n          jnz CntLoop \n```", "```\npopcnt `reg`[dest], `reg`[src]\npopcnt `reg`[dest], `mem`[src]\n```", "```\n; Reverse the 32 bits in EAX, leaving the result in EBX: \n\n               mov cl, 32     ; Move current bit in EAX to \nRvsLoop:       shr eax, 1     ; the carry flag\n\n rcl ebx, 1    ; Shift the bit back into \n                             ; EBX, backward\n               dec cl  \n               jnz RvsLoop \n```", "```\nmov edx, eax        ; Make a copy of the odd bits\nshr eax, 1          ; Move the even bits to the odd positions\nand edx, 55555555h  ; Isolate the odd bits\nand eax, 55555555h  ; Isolate the even bits\nshl edx, 1          ; Move the odd bits to even positions\nor  eax, edx        ; Merge the bits and complete the swap\n```", "```\nmov edx, eax        ; Make a copy of the odd-numbered bit pairs\nshr eax, 2          ; Move the even bit pairs to the odd position\nand edx, 33333333h  ; Isolate the odd pairs\nand eax, 33333333h  ; Isolate the even pairs\nshl edx, 2          ; Move the odd pairs to the even positions\nor  eax, edx        ; Merge the bits and complete the swap\n```", "```\nmov edx, eax        ; Make a copy of the odd-numbered nibbles\nshr eax, 4          ; Move the even nibbles to the odd position\nand edx, 0f0f0f0fh  ; Isolate the odd nibbles\nand eax, 0f0f0f0fh  ; Isolate the even nibbles\nshl edx, 4          ; Move the odd pairs to the even positions\nor  eax, edx        ; Merge the bits and complete the swap\n```", "```\nbswap `reg`[32] \n```", "```\nmov   edx, eax       ; Make a copy of the odd bits in the data\nshr   eax, 1         ; Move the even bits to the odd positions\nand   edx, 55555555h ; Isolate the odd bits\nand   eax, 55555555h ; Isolate the even bits\nshl   edx, 1         ; Move the odd bits to the even positions\nor    eax, edx       ; Merge the bits and complete the swap\n\nmov   edx, eax       ; Make a copy of the odd-numbered bit pairs\nshr   eax, 2         ; Move the even bit pairs to the odd position\nand   edx, 33333333h ; Isolate the odd pairs\nand   eax, 33333333h ; Isolate the even pairs\nshl   edx, 2         ; Move the odd pairs to the even positions\nor    eax, edx       ; Merge the bits and complete the swap\n\nmov   edx, eax       ; Make a copy of the odd-numbered nibbles\nshr   eax, 4         ; Move the even nibbles to the odd position\nand   edx, 0f0f0f0fh ; Isolate the odd nibbles\nand   eax, 0f0f0f0fh ; Isolate the even nibbles\nshl   edx, 4         ; Move the odd pairs to the even positions\nor    eax,edx        ; Merge the bits and complete the swap\n\nbswap eax            ; Swap the bytes and words\n```", "```\n; Merge two 16-bit strings into a single 32-bit string.\n; AX - Source for even-numbered bits.\n; BX - Source for odd-numbered bits.\n; CL  - Scratch register.\n; EDX - Destination register.\n\n          mov  cl, 16 \nMergeLp:  shrd edx, eax, 1     ; Shift a bit from EAX into EDX\n          shrd edx, ebx, 1     ; Shift a bit from EBX into EDX\n          dec  cl \n          jne  MergeLp; \n```", "```\nshrd edx, eax, 6\nshrd edx, ebx, 5\nshrd edx, eax, 6\nshrd edx, ebx, 11\nshrd edx, eax, 4\n```", "```\n mov cl, 16   ; Count the loop iterations\nExtractLp: shr eax, 1   ; Extract even bits to (E)BX\n           rcr ebx, 1 \n           shr eax, 1   ; Extract odd bits to (E)DX\n           rcr edx, 1 \n           dec cl       ; Repeat 16 times\n           jnz ExtractLp\n           shr ebx, 16  ; Need to move the results from the HO\n           shr edx, 16  ; bytes of EBX and EDX to the LO bytes\n```", "```\nmov  ecx, 55555555h  ; Odd bit positions\npext edx, eax, ecx   ; Put odd bits into EDX\nmov  ecx, 0aaaaaaaah ; Even bit positions\npext ebx, eax, ecx   ; Put even bits into EBX\n```", "```\n mov cl, 28       ; 28 attempts because 32 - 4 = 28\n                           ; (len(src) - len(pat))\n          mov ch, 1111b    ; Mask for the comparison\n          mov al, `pattern`  ; Pattern to search for\n          and al, ch       ; Mask unnecessary bits in AL\n          mov ebx, `source`  ; Get the source value\nScanLp:   mov dl, bl       ; Copy the LO 4 bits of EBX\n          and dl, ch       ; Mask unwanted bits\n          cmp al, dl       ; See if we match the pattern\n          jz  Matched\n          dec cl           ; Repeat specified number of times\n          shr ebx, 1 \n          jnz ScanLp \n\n; Do whatever needs to be done if we failed to \n; match the bit string. \n\n jmp Done\n\nMatched: \n\n; If we get to this point, we matched the bit string. \n; We can compute the position in the original source as 28 - CL.\n\nDone: \n```"]