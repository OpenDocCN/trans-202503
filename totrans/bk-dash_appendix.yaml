- en: <samp class="SANS_Dogma_OT_Bold_B_11">APPENDIX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PYTHON BASICS</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The focus of this appendix is to give you a quick refresher on the basics of
    Python. A full crash course in Python would be beyond the scope of a Dash book,
    so we’ll just go over basics like keywords, data structures, control flow, and
    functions. There are plenty of excellent resources in the wild that you can use
    to master Python more fully, including our free email academy: [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/email<wbr>-academy*](https://blog.finxter.com/email-academy).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*The introductory section uses code examples and text snippets from* Python
    One-Liners *(No Starch Press, 2020), written by one of the authors of this book.
    We encourage you to read the book to obtain a thorough understanding of single
    lines of Python code.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Installation and Getting Started</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t already have Python installed, you need to set Python up on your
    computer. Because Python is continuously evolving, we’ll keep this information
    generalized.
  prefs: []
  type: TYPE_NORMAL
- en: 1.  First, visit the official Python website at [*https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads*](https://www.python.org/downloads)
    and download the latest version of Python for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Run the installer on your computer. You should see a dialog that looks something
    like the one shown in [Figure A-1](appendix.xhtml#figA-1), depending on the version
    and operating system. Make sure to click the box to add Python to PATH to allow
    you to access any directory on your computer via Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureA-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-1: The Install Python
    pop-up window</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '3.  Check that your Python installation works correctly by running the following
    command in your command line (Windows), terminal (macOS), or shell (Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">python—version</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Python 3.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x.x</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*The dollar sign ($) is just a prompt that signals you to run the following
    code in a terminal or code shell. The text that follows in bold is the command
    you should enter.*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have installed Python on your computer. You can start writing
    your own programs with the IDLE editor that’s built into your system. Just search
    for the word *IDLE* on your operating system and open the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first program, enter the following command into your shell:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">print('hello world!')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Python will interpret your command and print the desired words to your shell
    (see [Figure A-2](appendix.xhtml#figA-2)):'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hello world!</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureA-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-2: The hello world
    program in Python</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This mode of communicating back and forth with your Python interpreter is called
    *interactive mode*. It has the advantage of immediate feedback. However, the most
    exciting consequence of programming computers is automation: writing a program
    once and running it again and again.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a simple program that greets you by name each time you run
    it. You can save the program and run it later at any point in time. These kinds
    of programs are called *scripts*, and you save them with the suffix *.py*, as
    in *my_first_program.py*, to save them as Python files.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a script via the menu of your IDLE shell, as shown in [Figure
    A-3](appendix.xhtml#figA-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureA-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-3: Creating your own
    module</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **File** ►**New File** and copy-paste the following code into your new
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">name = input("What's your name?")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('hello' + name)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Save your file as *hello.py* on your desktop or in any other location. Your
    current script should look like [Figure A-4](appendix.xhtml#figA-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureA-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-4: A program that
    takes user input and prints the response to the standard output</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s get some action going: click **Run** ►**Run Module**. The Python
    program starts executing in the interactive shell, without you needing to type
    in each line. It runs through the code file line by line. The first line asks
    you to put in your name and waits until you enter some input. The second line
    then takes your name and prints it to the shell. [Figure A-5](appendix.xhtml#figA-5)
    shows the program in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/FigureA-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-5: Example execution
    of the program in [Figure A-4](appendix.xhtml#figA-4)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Data Types</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve seen a Python program in action, we’ll review some basic data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Booleans</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'A Boolean data type represents just the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. In Python, Boolean
    and integer data types are closely related, because a Boolean type internally
    uses integer values: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    is represented by integer 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    is represented by integer 1\. Booleans are generally used for assertions or as
    outcomes for comparisons. The following code snippet gives you an example of these
    two Boolean keywords in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">X = 1 > 2</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># False</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 2 > 1</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(y)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  prefs: []
  type: TYPE_NORMAL
- en: After evaluating the given expressions, variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    refers to the value <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    and variable <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> refers to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Booleans allow us to
    create conditional execution of code, so they are important for working with data
    because they allow us to do things like check if a certain value is above a threshold
    before we use that value (see the SVM Explorer app in [Chapter 7](chapter7.xhtml)
    for threshold-based data classification).
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean values have a few major operators that represent basic logical operators:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>. The keyword <samp
    class="SANS_TheSansMonoCd_W5Regular_11">and</samp> evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x and y</samp>
    if both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    If just one of those is <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    the overall expression becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> evaluates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> in the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x or y</samp> if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> *or* <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> *or* both are <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. If just one is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the overall expression becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> evaluates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> in the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">not x</samp> when <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Consider the following
    Python code example, which uses each Boolean operator:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x, y = True, False</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x or y)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x and y)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(not y)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  prefs: []
  type: TYPE_NORMAL
- en: By using these three operations—<samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>—you
    can express all the logical expressions you’ll ever need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean operators are ordered by priority. The operator <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>
    has the highest priority, followed by the operator <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>,
    followed by the operator <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>.
    Consider these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x, y = True, False</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x and not y)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(not x and y or x)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  prefs: []
  type: TYPE_NORMAL
- en: We set the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. When calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">not x and y or x</samp>, Python interprets
    this as <samp class="SANS_TheSansMonoCd_W5Regular_11">((not x) and y) or x)</samp>,
    which is different from, say, <samp class="SANS_TheSansMonoCd_W5Regular_11">(not
    x) and (y or x)</samp>. As an exercise, figure out *why*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Numerical Types</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The two most crucial numerical data types are integer and float. An *integer*
    is a positive or negative number without floating-point precision (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>). A *float* is a positive
    or negative number with floating-point precision (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">3.14159265359</samp>).
    Python offers a wide variety of built-in numerical operations, as well as functionality
    to convert between numerical data types. Here’s an example of a few arithmetic
    operations. First we’ll create an <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    variable with the value 3 and a <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variable with the value 2:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x,
    y</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">3,
    2</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">y</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">—</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">y</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    * y</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    / y</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1.5</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    // y</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    % y</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-x</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">-3</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">abs(-x)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">int(3.9)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">float(3)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">3.0</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    ** y</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The first four operations are addition, subtraction, multiplication, and division,
    respectively. The <samp class="SANS_TheSansMonoCd_W5Regular_11">//</samp> operator
    performs integer division. The result is an integer value that is rounded toward
    the smaller integer number (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">3
    // 2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> operation is a *modulo
    operation*, which gives you just the remainder of a division. The minus operator
    <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp> turns the value into a
    negative number. <samp class="SANS_TheSansMonoCd_W5Regular_11">abs()</samp> gives
    the absolute value (simply the value as a non-negative). <samp class="SANS_TheSansMonoCd_W5Regular_11">int()</samp>
    turns the value into an integer, discarding any numbers after the decimal point.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp> turns the given value
    into a floating point. The double asterisk <samp class="SANS_TheSansMonoCd_W5Regular_11">**</samp>
    means to multiply to the power of. Operator precedence is just as you learned
    in school: parentheses before exponent before multiplication before addition,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Strings</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Python strings are sequences of characters. Strings are immutable, so they
    cannot be changed once they are created; you must create a new string if you want
    an altered string. Strings are typically just text (including numbers) inside
    quotes: <samp class="SANS_TheSansMonoCd_W5Regular_11">"this is a string"</samp>.
    Here are the five most common ways to create strings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Single quotes: <samp class="SANS_TheSansMonoCd_W5Regular_11">''Yes''</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double quotes: <samp class="SANS_TheSansMonoCd_W5Regular_11">"Yes"</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Triple quotes (for multiline strings): <samp class="SANS_TheSansMonoCd_W5Regular_11">''''''</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">Yes''''''</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">"
    ""Yes" ""</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The string method: <samp class="SANS_TheSansMonoCd_W5Regular_11">str(yes)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">''yes''</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Concatenation: <samp class="SANS_TheSansMonoCd_W5Regular_11">''Py''</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">''thon''</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">''Python''</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To use whitespace characters in strings you need to specify them explicitly.
    To start text on a new line within the string, use the newline character <samp
    class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp>. To add a tab’s worth of space,
    use the tab character <samp class="SANS_TheSansMonoCd_W5Regular_11">'\t'</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings also have their own set of methods. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strip()</samp>
    method removes the leading and trailing whitespaces, including empty spaces, tabular
    characters, and newline characters:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = " This is lazy\t\n "</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(y.strip())</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is much neater:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">'This is lazy'</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> method lowercases
    the whole string:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("DrDre".lower())</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'We get:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">'drdre'</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">upper()</samp> method uppercases
    the whole string:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("attention".upper())</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">'ATTENTION'</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">startswith()</samp> method
    checks whether the argument you supply can be found at the start of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("smartphone".startswith("smart"))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'It returns a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp> method
    checks whether the argument you supply can be found at the end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("smartphone".endswith("phone"))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This also returns a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">find()</samp> method returns
    the index of the first occurrence of the substring in the original string:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("another".find("other"))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Match index: 2</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp> method replaces
    the characters in the first argument with the characters in the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("cheat".replace("ch", "m"))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">cheat</samp> becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">meat</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">join()</samp> method combines
    all values in an iterable argument, using the string with which it is called as
    a separator between the elements in the iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(','.join(["F", "B", "I"]))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'We get:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">F,B,I</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp> method returns
    the number of characters in a string, including whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(len("Rumpelstiltskin"))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">String length: 15</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword when used
    with string operands checks whether a string appears in another string:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("ear" in "earth")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This too returns a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Contains: True</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This nonexclusive list of string methods shows that Python’s string data type
    is flexible and powerful, and you can solve many common string problems with built-in
    Python functionality.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Control Flow</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s dive into some programming logic that allows our code to make decisions.
    An algorithm is like a cooking recipe: if that recipe consists of only a sequential
    list of commands—fill a pot with water, add the salt, add the rice, get rid of
    the water, and serve the rice—you might complete the steps in a matter of seconds
    and end up with a bowl of uncooked rice. We need to respond differently to different
    circumstances: remove the water from the pot only *if* the rice is soft, and put
    the rice in the pot *if* the water is boiling. Code that responds differently
    under different conditions is known as *conditional execution* code. In Python
    the conditional execution keywords are <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a basic example that compares two figures:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">half_truth = 21</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if 2 * half_truth == 42:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Truth!')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Lie!')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This will print:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Truth!</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> condition <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2 * half_truth</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp> generates a result that
    evaluates to either <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If the expression
    evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, we enter
    the first branch and print <samp class="SANS_TheSansMonoCd_W5Regular_11">Truth!</samp>.
    If the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    we enter the second branch and print <samp class="SANS_TheSansMonoCd_W5Regular_11">Lie!</samp>.
    As the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the first branch is entered, and the shell output is <samp class="SANS_TheSansMonoCd_W5Regular_11">Truth!</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Python object, like a variable or a list, has an implicitly associated
    Boolean value, meaning we can use Python objects as conditions. For example, an
    empty list evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    and a non-empty list evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = []</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if lst:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Full!')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Empty!')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This prints:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Empty!</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t need an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    branch, you can simply skip it, and Python will skip the whole block if the condition
    evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if 2 + 2 == 4:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('FOUR')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This prints:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">FOUR</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The output is printed only if the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    condition evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    Otherwise, nothing happens. The code has no side effects because it’s simply skipped
    by the execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also have code with more than two conditions. In this case, you can
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">x = input(''Your Number: '')</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if x ==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">'1':</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('ONE')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">elif x == '2':</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('TWO')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">elif x == '3':</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('THREE')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('MANY')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The code takes your input and compares it against strings <samp class="SANS_TheSansMonoCd_W5Regular_11">'1'</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'2'</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">'3'</samp>.
    In each case, a different output is printed. If the input doesn’t match any string,
    the final branch is entered and the output is <samp class="SANS_TheSansMonoCd_W5Regular_11">'MANY'</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet takes user input, converts it into an integer, and
    stores it in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    It then tests whether the variable is larger than, equal to, or smaller than the
    value 3, and prints a different message depending on the evaluation. In other
    words, the code responds to real-world input that is unpredictable in a differentiated
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">x = int(input(''your value: ''))</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if x > 3:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Big')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">elif x ==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Medium')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Small')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'We give the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    followed by the condition that determines which path the execution follows. If
    the condition evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the execution path follows the first branch given in the indented block that follows
    immediately. If the condition evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    the execution flow looks further, doing one of three things:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Evaluates additional conditions as given by an arbitrary number of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> branches
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Moves into the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    branch if neither an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> nor
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> condition is fulfilled
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Skips the whole construct when no <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    branch is given and no <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>
    branch holds or exists
  prefs: []
  type: TYPE_NORMAL
- en: The rule is that the execution path starts at the top and moves down until either
    any condition matches—in which case the respective code branch is executed—or
    all conditions are explored but none matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you see that it is possible to pass objects into an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    condition and use them like Booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if None or 0 or 0.0 or ' ' or
    [] or {} or set():</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   print(''Dead code'') # Not
    reached</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> condition evaluations
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp>
    statement is never reached. This is because the following values evaluate to the
    Boolean value <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>: the
    keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>, the integer
    value <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the float value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>, empty strings, and empty
    container types. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">None
    or 0 or 0.0 or '' '' or [] or {} or set()</samp> evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    if Python can implicitly convert any of the operands to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    but here it doesn’t because all of them are converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Repeated Execution</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow for repeated execution of similar code snippets, Python has two types
    of loops: <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loops. We’ll create a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop and a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop to achieve the same thing in different ways: print the integers 0, 1, and
    2 to the Python shell.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">for i in [0, 1, 2]:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(i)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This will print:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop repeatedly
    executes the loop body by declaring a loop variable <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    that iteratively takes on all values in the list <samp class="SANS_TheSansMonoCd_W5Regular_11">[0,
    1, 2]</samp>. It then prints the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    until it runs out of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop
    version with similar semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">i = 0</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">while i < 3:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(i)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   i = i + 1</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This will also print:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop executes
    the loop body as long as a condition is met—in our case, as long as <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
    The choice of which you use depends on your situation. Generally, you’ll use a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop when iterating over
    a fixed number of elements, such as when iterating over all elements in a list,
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop when you
    want to repeat a certain action until you accomplish a certain result, such as
    guessing a password until you’re in.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two fundamental ways to terminate a loop: define a loop condition
    that evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    as used in the previous example, or use the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    at the exact position in the loop body where you want it to stop. Here we use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> to exit what would
    otherwise be an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">while True:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   break # No infinite loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('hello world')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'From this we get:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hello world</samp>
  prefs: []
  type: TYPE_NORMAL
- en: We create a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop
    with a loop condition that will always evaluate to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    because the loop condition <samp class="SANS_TheSansMonoCd_W5Regular_11">while
    True</samp> already is inherently <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    The loop ends prematurely at <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>,
    so the code moves on and executes <samp class="SANS_TheSansMonoCd_W5Regular_11">print('hello
    world')</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why we would want to create an infinite loop in the first place
    if we don’t want it to run forever. This is a common practice, for example, when
    developing web servers that must use an infinite loop to wait for a new web request
    and serve the request. However, you’d still want to be able to terminate the loop
    prematurely. In the web server example, you might want to stop serving files if
    your server detects that it’s under attack. In these cases, you can use the keyword
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> to stop the loop if
    a certain condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to force the Python interpreter to skip certain areas in
    the loop without ending it prematurely. In our web server example, you may want
    to skip execution of malicious web requests instead of halting the server completely.
    You can achieve this with the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    keyword, which finishes the current loop iteration and brings the execution flow
    back to the loop condition at the start:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">while True:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   continue</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   print(''43'') # Dead code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will execute forever without executing the <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp>
    statement once, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement finishes the current loop iteration and takes it back to the start before
    it reaches the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> line.
    That <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> line is now
    considered *dead code*: code that will never be executed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement and <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> are commonly
    only used with additional conditions using <samp class="SANS_TheSansMonoCd_W5Regular_11">if-else</samp>,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">while True:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   user_input = input(''your
    password: '')</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   if user_input == '42':</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      break</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   print(''wrong!'') # Dead code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('Congratulations, you found
    the secret password!')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This code requests a password and runs forever or until the user figures out
    the password. If they enter the correct password <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>,
    the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> is reached
    and the loop terminates, sending execution to the successful <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp>
    statement at the end. In all other cases, the loop breaks, execution returns to
    the start, and the user will have to try again. Here’s a sample usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">your password: 41</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">wrong!</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">your password: 21</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">wrong!</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">your password: 42</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Congratulations, you found the
    secret password!</samp>
  prefs: []
  type: TYPE_NORMAL
- en: These are the most important keywords for controlling the execution flow of
    your programs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Other Useful Keywords</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s have a look at some additional useful keywords. The <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    keyword checks whether a certain element exists in a given sequence or container
    type. Here we check if 42 is in the list that follows, then whether 21 can be
    found as a string in the set:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(42 in [2, 39, 42])</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('21' in {'2', '39', '42'})</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># False</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword returns
    a Boolean, so the first statement will return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    and the second <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp> checks
    if two variables refer to the same object in memory. Beginners in Python are often
    confused about the exact meaning of the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp>,
    but it’s worth taking the time to understand it properly. Here we see the difference
    between two variables pointing to the same object in memory, and two lists that
    look similar but point to different objects:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x is y)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([3] is [3])</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># False</samp>
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the latter example, if you create two lists—even if they contain
    the same elements—they still refer to two different list objects in memory. If
    you later decided to modify one list object, this would not affect the other list
    object. If you check whether one list refers to the same object in memory, the
    result is <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Here, when
    we check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, we get <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    because we explicitly set <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    to refer to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. When we check
    the list <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp> against <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>, however, we get <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    because the lists refer to different objects in memory. If you change one, you
    don’t change the other!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Functions</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Functions* are reusable code snippets that accomplish a specific task. Programmers
    can and often do share functions with other programmers to deal with specific
    tasks, saving people the time and effort of writing the code themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You define a function using the <samp class="SANS_TheSansMonoCd_W5Regular_11">def</samp>
    keyword. Here we define two simple functions that each print a string:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hi():</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('hi!')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hello():</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('hello!')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: A function consists of the function name with parentheses, prefixed with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">def</samp> keyword, and the function
    body, which is an indented code block. This block can contain other indented blocks,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements, and even
    further function definitions. As with any block definition in Python, you must
    indent the function’s body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a function that prints two strings on new lines:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_bye():</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Time to go…')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Bye! ')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Run all three functions in your Python shell like so:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Say_hi()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Say_hello()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Say_bye()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hi!</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hello!</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Time to go…</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Bye!</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The functions are executed in order.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Arguments</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can also take arguments within the parentheses. An *argument* allows
    you to tailor the output. Consider this function, which takes a name as its only
    argument and prints a customized string to the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hi(name):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('hi ' +</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Alice')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Bob')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the function and then run it twice with different arguments: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">''Alice''</samp> then <samp class="SANS_TheSansMonoCd_W5Regular_11">''Bob''</samp>.
    Thus, the output of the function executions is different:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hi Alice</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hi Bob</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions can also take multiple arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hi(a, b):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(a + ' says hi to ' +
    b)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Alice', 'Bob')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Bob', 'Alice')</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Alice says hi to Bob</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Bob says hi to Alice</samp>
  prefs: []
  type: TYPE_NORMAL
- en: In the first function execution, the argument variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    takes on the string value <samp class="SANS_TheSansMonoCd_W5Regular_11">'Alice'</samp>
    and the argument variable <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    takes on the string value <samp class="SANS_TheSansMonoCd_W5Regular_11">'Bob'</samp>.
    The second function execution reverses this assignment, giving us different output.
  prefs: []
  type: TYPE_NORMAL
- en: Functions can also have return values, so you can pass a value into the function
    and get back a value that you can then use later in the code, as shown in [Listing
    A-1](appendix.xhtml#ListA-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def f(a, b):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return a + b</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">f(2,
    2)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = f(40, 2)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(y)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-1: Using the return
    keyword</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The return value is the expression right after the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>,
    which also terminates the function. Python checks the return value right after
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword and ends
    the function, immediately giving this value back to the caller of the function.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t explicitly provide a return expression, Python will implicitly
    add the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">return None</samp>
    to the end of the function. The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    means *the absence of a value*. Other programming languages, such as Java, use
    the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, which often
    leads to confusion when beginners assume it’s equal to the integer value 0\. Instead,
    Python uses the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    to indicate it’s an empty object, like an empty list or string, and not a numerical
    0.
  prefs: []
  type: TYPE_NORMAL
- en: When a function finishes executing, the execution is always passed to the caller
    of the function; the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    keyword just gives you more control about *when* to terminate the function and
    *what* to give back.
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass <samp class="SANS_TheSansMonoCd_W5Regular_11">a=2</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b=2</samp> into the function in [Listing
    A-1](appendix.xhtml#ListA-1), and get the result <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.
    We then pass <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=40</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b=2</samp> and get the (one
    and only) answer <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>. Here’s
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost every dashboard app contains at least one function that adds some interactivity.
    Commonly, you may have a function that updates a graph based on some user input,
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def update_graph(value):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   if value == 2:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      return 'something'</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll look at a more advanced and highly relevant feature of Python:
    *default function arguments*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Default Function Arguments</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Default arguments allow you to define a function with optional arguments in
    Python. If a user opts not to provide an argument when they call the function,
    the default argument is used. You set the default argument by using the equal
    sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) after the argument
    name and appending the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing A-2](appendix.xhtml#ListA-2) shows a more interesting example. Here
    we define a function <samp class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>
    that returns the sum of the function arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. So, <samp class="SANS_TheSansMonoCd_W5Regular_11">add(1,2)</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">add(41,1)</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>. We specify
    default values for the function arguments: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. If no value is passed
    for one or both of these arguments in the function call, it will be set to its
    default value. So, <samp class="SANS_TheSansMonoCd_W5Regular_11">add(1)</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">add(-1)</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add()</samp> will return <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    because the default arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> are used for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def add(a=0, b=1):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return a + b</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(add(add(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">add()</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-2: Defining a function
    with default arguments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will print:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
  prefs: []
  type: TYPE_NORMAL
- en: In the innermost function call we highlighted in <samp class="SANS_TheSansMonoCd_W5Regular_11">print(add(add(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">add()</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)))</samp>,
    we call the function <samp class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>
    with no arguments, so it uses the default values for <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> (0 and 1, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: For the remaining two calls, you only pass one argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>,
    and that’s the return value of the previous function call. This argument will
    receive <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, taking the position
    of the arguments to figure out which argument to pass to which variable, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> will have its default value 1\.
    The first, innermost call of <samp class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>
    returns 1\. This is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>
    in the second call and so is incremented by 1, and then that value is again incremented
    by 1 in the third call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what happens behind the scenes when we execute [Listing A-2](appendix.xhtml#ListA-2),
    step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">add(add(add()))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   = add(add(1))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   = add(2)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   = 3</samp>
  prefs: []
  type: TYPE_NORMAL
- en: You can see that default arguments can help you make functions more flexible
    in regard to their inputs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Python Resources and Further Reading</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Feel free to check out the *Python One-Liners* introductory Python videos available
    for free at [*https://<wbr>pythononeliners<wbr>.com*](https://pythononeliners.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official Python website with the newest Python version for download can
    be found at [*https://<wbr>www<wbr>.python<wbr>.org*](https://www.python.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find a full tutorial on Python lists with detailed video content on
    the Finxter blog at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/python<wbr>-lists*](https://blog.finxter.com/python-lists).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a full tutorial with video on Python slicing, visit [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/introduction<wbr>-to<wbr>-slicing<wbr>-in<wbr>-python*](https://blog.finxter.com/introduction-to-slicing-in-python).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find a complete guide on Python dictionaries at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/python<wbr>-dictionary*](https://blog.finxter.com/python-dictionary).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A guide on list comprehension with video is available at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/list<wbr>-comprehension*](https://blog.finxter.com/list-comprehension).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object-oriented programming (OOP) cheat sheet can be downloaded as a PDF
    at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/object<wbr>-oriented<wbr>-programming<wbr>-terminology<wbr>-cheat<wbr>-sheet<wbr>*](https://blog.finxter.com/object-oriented-programming-terminology-cheat-sheet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find more cheat sheets and a free Python crash course at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/python<wbr>-crash<wbr>-course*](https://blog.finxter.com/python-crash-course).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
