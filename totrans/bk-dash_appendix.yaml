- en: <samp class="SANS_Dogma_OT_Bold_B_11">APPENDIX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_11">附录
- en: PYTHON BASICS</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PYTHON 基础
- en: '![](../images/opener-img.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: 'The focus of this appendix is to give you a quick refresher on the basics of
    Python. A full crash course in Python would be beyond the scope of a Dash book,
    so we’ll just go over basics like keywords, data structures, control flow, and
    functions. There are plenty of excellent resources in the wild that you can use
    to master Python more fully, including our free email academy: [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/email<wbr>-academy*](https://blog.finxter.com/email-academy).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录的重点是快速回顾 Python 的基础知识。要全面了解 Python 的快速课程超出了 Dash 书籍的范围，因此我们将仅介绍如关键词、数据结构、控制流和函数等基础内容。网络上有许多优秀的资源可以帮助您更全面地掌握
    Python，包括我们的免费电子邮件学堂：[*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/email<wbr>-academy*](https://blog.finxter.com/email-academy)。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The introductory section uses code examples and text snippets from* Python
    One-Liners *(No Starch Press, 2020), written by one of the authors of this book.
    We encourage you to read the book to obtain a thorough understanding of single
    lines of Python code.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本介绍部分使用了来自《Python One-Liners》（No Starch Press，2020）中的代码示例和文本片段，这本书由本书的其中一位作者撰写。我们鼓励您阅读本书，以全面理解单行
    Python 代码。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Installation and Getting Started</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">安装与入门</samp>
- en: If you don’t already have Python installed, you need to set Python up on your
    computer. Because Python is continuously evolving, we’ll keep this information
    generalized.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装 Python，您需要在计算机上安装 Python。由于 Python 不断发展，我们将保持此信息的一般性。
- en: 1.  First, visit the official Python website at [*https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads*](https://www.python.org/downloads)
    and download the latest version of Python for your operating system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  首先，访问官方 Python 网站 [*https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads*](https://www.python.org/downloads)，下载适用于您的操作系统的最新版本的
    Python。
- en: 2.  Run the installer on your computer. You should see a dialog that looks something
    like the one shown in [Figure A-1](appendix.xhtml#figA-1), depending on the version
    and operating system. Make sure to click the box to add Python to PATH to allow
    you to access any directory on your computer via Python.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  在计算机上运行安装程序。根据版本和操作系统的不同，您应该会看到类似 [图 A-1](appendix.xhtml#figA-1) 的对话框。请确保勾选将
    Python 添加到 PATH 选项，以便您能够通过 Python 访问计算机上的任何目录。
- en: '![](../images/FigureA-1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureA-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-1: The Install Python
    pop-up window</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 A-1：安装 Python 的弹出窗口</samp>
- en: '3.  Check that your Python installation works correctly by running the following
    command in your command line (Windows), terminal (macOS), or shell (Linux):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  通过在命令行（Windows）、终端（macOS）或 shell（Linux）中运行以下命令，检查您的 Python 安装是否正常工作：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">python—version</samp>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">python—version</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Python 3.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x.x</samp>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Python 3.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x.x</samp>
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The dollar sign ($) is just a prompt that signals you to run the following
    code in a terminal or code shell. The text that follows in bold is the command
    you should enter.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*美元符号（$）只是一个提示符，表示您需要在终端或代码 shell 中运行接下来的代码。加粗的文本是您应该输入的命令。*'
- en: Congratulations! You have installed Python on your computer. You can start writing
    your own programs with the IDLE editor that’s built into your system. Just search
    for the word *IDLE* on your operating system and open the program.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已在计算机上安装了 Python。您可以开始使用系统内置的 IDLE 编辑器编写自己的程序。只需在操作系统中搜索 *IDLE* 并打开该程序。
- en: 'As a first program, enter the following command into your shell:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个程序，在您的 shell 中输入以下命令：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">print('hello world!')</samp>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">print('hello world!')</samp>
- en: 'Python will interpret your command and print the desired words to your shell
    (see [Figure A-2](appendix.xhtml#figA-2)):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会解析您的命令，并将期望的文字打印到您的 shell 中（请参见 [图 A-2](appendix.xhtml#figA-2)）：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hello world!</samp>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">hello world!</samp>
- en: '![](../images/FigureA-2.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureA-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-2: The hello world
    program in Python</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 A-2：Python 中的 hello world
    程序</samp>
- en: 'This mode of communicating back and forth with your Python interpreter is called
    *interactive mode*. It has the advantage of immediate feedback. However, the most
    exciting consequence of programming computers is automation: writing a program
    once and running it again and again.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种与 Python 解释器进行来回交流的方式被称为 *交互模式*。它的优点是可以即时得到反馈。然而，编程的最令人兴奋的后果是自动化：编写一次程序并多次运行它。
- en: Let’s start with a simple program that greets you by name each time you run
    it. You can save the program and run it later at any point in time. These kinds
    of programs are called *scripts*, and you save them with the suffix *.py*, as
    in *my_first_program.py*, to save them as Python files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的程序开始，每次运行时它会按名字向你问好。你可以保存程序并在任何时候再次运行它。这类程序叫做 *脚本*，你保存它们时会使用 *.py*
    后缀，例如 *my_first_program.py*，来保存为 Python 文件。
- en: You can create a script via the menu of your IDLE shell, as shown in [Figure
    A-3](appendix.xhtml#figA-3).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 IDLE shell 的菜单创建脚本，如 [图 A-3](appendix.xhtml#figA-3) 所示。
- en: '![](../images/FigureA-3.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureA-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-3: Creating your own
    module</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 A-3：创建你自己的模块</samp>
- en: 'Click **File** ►**New File** and copy-paste the following code into your new
    file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **文件** ► **新建文件**，然后将以下代码复制并粘贴到你的新文件中：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">name = input("What's your name?")</samp>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">name = input("你的名字是什么？")</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('hello' + name)</samp>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('hello' + name)</samp>
- en: Save your file as *hello.py* on your desktop or in any other location. Your
    current script should look like [Figure A-4](appendix.xhtml#figA-4).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的文件保存为 *hello.py*，保存在桌面或其他任何位置。你当前的脚本应该像 [图 A-4](appendix.xhtml#figA-4) 所示。
- en: '![](../images/FigureA-4.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureA-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-4: A program that
    takes user input and prints the response to the standard output</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 A-4：一个接受用户输入并将响应打印到标准输出的程序</samp>
- en: 'Now, let’s get some action going: click **Run** ►**Run Module**. The Python
    program starts executing in the interactive shell, without you needing to type
    in each line. It runs through the code file line by line. The first line asks
    you to put in your name and waits until you enter some input. The second line
    then takes your name and prints it to the shell. [Figure A-5](appendix.xhtml#figA-5)
    shows the program in action.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始一些操作：点击 **运行** ► **运行模块**。Python 程序会在交互式 shell 中开始执行，你无需逐行输入。它会逐行运行代码文件。第一行要求你输入名字，并等待你输入内容。第二行会接收你的名字并将其打印到
    shell 中。[图 A-5](appendix.xhtml#figA-5)展示了程序的实际运行。
- en: '![](../images/FigureA-5.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/FigureA-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-5: Example execution
    of the program in [Figure A-4](appendix.xhtml#figA-4)</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 A-5：[图 A-4](appendix.xhtml#figA-4)
    中程序执行的示例</samp>
- en: <samp class="SANS_Futura_Std_Bold_B_11">Data Types</samp>
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">数据类型</samp>
- en: Now that you’ve seen a Python program in action, we’ll review some basic data
    types.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到一个 Python 程序的运行，我们将回顾一些基本的数据类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Booleans</samp>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">布尔值</samp>
- en: 'A Boolean data type represents just the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. In Python, Boolean
    and integer data types are closely related, because a Boolean type internally
    uses integer values: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    is represented by integer 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    is represented by integer 1\. Booleans are generally used for assertions or as
    outcomes for comparisons. The following code snippet gives you an example of these
    two Boolean keywords in action:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型仅表示关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。在 Python 中，布尔类型与整数数据类型密切相关，因为布尔类型内部使用整数值：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp> 用整数 0 表示，<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    用整数 1 表示。布尔值通常用于断言或作为比较的结果。以下代码片段展示了这两个布尔关键字的实际应用：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">X = 1 > 2</samp>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">X = 1 > 2</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x)</samp>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># False</samp>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"># False</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 2 > 1</samp>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 2 > 1</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(y)</samp>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(y)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
- en: After evaluating the given expressions, variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    refers to the value <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    and variable <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> refers to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Booleans allow us to
    create conditional execution of code, so they are important for working with data
    because they allow us to do things like check if a certain value is above a threshold
    before we use that value (see the SVM Explorer app in [Chapter 7](chapter7.xhtml)
    for threshold-based data classification).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估给定的表达式后，变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的值为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。布尔值使我们能够创建条件执行代码，因此它们在处理数据时非常重要，因为它们允许我们在使用某个值之前先检查该值是否超过某个阈值（有关基于阈值的数据分类，请参见[第7章](chapter7.xhtml)中的SVM
    Explorer应用）。
- en: 'Boolean values have a few major operators that represent basic logical operators:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>. The keyword <samp
    class="SANS_TheSansMonoCd_W5Regular_11">and</samp> evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x and y</samp>
    if both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    If just one of those is <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    the overall expression becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值有几个主要的运算符，代表基本的逻辑运算符：<samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">or</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>。关键字
    <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> 在表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    and y</samp> 中，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 都为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，则结果为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。如果其中任何一个是 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，整个表达式的结果为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> evaluates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> in the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x or y</samp> if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> *or* <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> *or* both are <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. If just one is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the overall expression becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> 在表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    or y</samp> 中，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp> *或* <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> *或* 两者都为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，则结果为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。如果其中有一个为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，整个表达式的结果为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: 'The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> evaluates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> in the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">not x</samp> when <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Consider the following
    Python code example, which uses each Boolean operator:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> 在表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">not
    x</samp> 中，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，则结果为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。以下是一个使用每个布尔运算符的Python代码示例：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x, y = True, False</samp>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x, y = True, False</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x or y)</samp>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x or y)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x and y)</samp>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x and y)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(not y)</samp>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(not y)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
- en: By using these three operations—<samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>—you
    can express all the logical expressions you’ll ever need.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这三个运算符——<samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>——你可以表达所有你可能需要的逻辑表达式。
- en: 'Boolean operators are ordered by priority. The operator <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>
    has the highest priority, followed by the operator <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>,
    followed by the operator <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>.
    Consider these examples:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符是有优先级顺序的。运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> 拥有最高的优先级，其次是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>，最后是 <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>。请看以下示例：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x, y = True, False</samp>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x, y = True, False</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x and not y)</samp>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x and not y)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(not x and y or x)</samp>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(not x and y or x)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
- en: We set the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. When calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">not x and y or x</samp>, Python interprets
    this as <samp class="SANS_TheSansMonoCd_W5Regular_11">((not x) and y) or x)</samp>,
    which is different from, say, <samp class="SANS_TheSansMonoCd_W5Regular_11">(not
    x) and (y or x)</samp>. As an exercise, figure out *why*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">not x and y or x</samp> 时，Python
    会将其解释为 <samp class="SANS_TheSansMonoCd_W5Regular_11">((not x) and y) or x</samp>，这与例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(not x) and (y or x)</samp> 是不同的。作为练习，试着找出*为什么*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Numerical Types</samp>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">数值类型</samp>
- en: 'The two most crucial numerical data types are integer and float. An *integer*
    is a positive or negative number without floating-point precision (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>). A *float* is a positive
    or negative number with floating-point precision (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">3.14159265359</samp>).
    Python offers a wide variety of built-in numerical operations, as well as functionality
    to convert between numerical data types. Here’s an example of a few arithmetic
    operations. First we’ll create an <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    variable with the value 3 and a <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    variable with the value 2:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的两种数值数据类型是整数和浮点数。*整数*是没有浮动小数点精度的正数或负数（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>）。*浮点数*是具有浮动小数点精度的正数或负数（例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">3.14159265359</samp>）。Python 提供了各种内置的数值运算功能，还支持在数值数据类型之间进行转换。以下是几个算术运算的示例。首先，我们创建一个值为
    3 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 变量和一个值为 2 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    变量：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x,
    y</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">3,
    2</samp>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x,
    y</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">3,
    2</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">y</samp>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">y</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">—</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">y</samp>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">—</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">y</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    * y</samp>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    * y</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    / y</samp>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    / y</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1.5</samp>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">1.5</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    // y</samp>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    // y</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    % y</samp>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    % y</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-x</samp>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-x</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">-3</samp>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-3</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">abs(-x)</samp>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">abs(-x)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">int(3.9)</samp>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">int(3.9)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">float(3)</samp>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">float(3)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">3.0</samp>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">3.0</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    ** y</samp>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">x
    ** y</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>
- en: 'The first four operations are addition, subtraction, multiplication, and division,
    respectively. The <samp class="SANS_TheSansMonoCd_W5Regular_11">//</samp> operator
    performs integer division. The result is an integer value that is rounded toward
    the smaller integer number (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">3
    // 2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> operation is a *modulo
    operation*, which gives you just the remainder of a division. The minus operator
    <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp> turns the value into a
    negative number. <samp class="SANS_TheSansMonoCd_W5Regular_11">abs()</samp> gives
    the absolute value (simply the value as a non-negative). <samp class="SANS_TheSansMonoCd_W5Regular_11">int()</samp>
    turns the value into an integer, discarding any numbers after the decimal point.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp> turns the given value
    into a floating point. The double asterisk <samp class="SANS_TheSansMonoCd_W5Regular_11">**</samp>
    means to multiply to the power of. Operator precedence is just as you learned
    in school: parentheses before exponent before multiplication before addition,
    and so on.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前四种运算分别是加法、减法、乘法和除法。<samp class="SANS_TheSansMonoCd_W5Regular_11">//</samp>
    运算符执行整数除法。结果是一个整数值，向下舍入到较小的整数（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">3
    // 2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>）。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">%</samp> 操作是 *取模操作*，它给你除法的余数。减号操作符 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp> 会将值变为负数。<samp class="SANS_TheSansMonoCd_W5Regular_11">abs()</samp>
    给出绝对值（即非负值）。<samp class="SANS_TheSansMonoCd_W5Regular_11">int()</samp> 会将值转换为整数，舍弃小数点后的数字。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">float()</samp> 会将给定的值转换为浮动小数。双星号 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">**</samp> 表示求幂。运算符优先级和你在学校学到的一样：括号优先于指数，指数优先于乘法，乘法优先于加法，依此类推。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Strings</samp>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">字符串</samp>
- en: 'Python strings are sequences of characters. Strings are immutable, so they
    cannot be changed once they are created; you must create a new string if you want
    an altered string. Strings are typically just text (including numbers) inside
    quotes: <samp class="SANS_TheSansMonoCd_W5Regular_11">"this is a string"</samp>.
    Here are the five most common ways to create strings:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Python 字符串是字符的序列。字符串是不可变的，因此一旦创建，不能更改；如果你想要一个修改过的字符串，你必须创建一个新的字符串。字符串通常只是放在引号中的文本（包括数字）：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"this is a string"</samp>。以下是创建字符串的五种最常见方法：
- en: 'Single quotes: <samp class="SANS_TheSansMonoCd_W5Regular_11">''Yes''</samp>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号：<samp class="SANS_TheSansMonoCd_W5Regular_11">'Yes'</samp>
- en: 'Double quotes: <samp class="SANS_TheSansMonoCd_W5Regular_11">"Yes"</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号：<samp class="SANS_TheSansMonoCd_W5Regular_11">"Yes"</samp>
- en: 'Triple quotes (for multiline strings): <samp class="SANS_TheSansMonoCd_W5Regular_11">''''''</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">Yes''''''</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">"
    ""Yes" ""</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 三引号（用于多行字符串）：<samp class="SANS_TheSansMonoCd_W5Regular_11">'''</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">Yes'''</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">" ""Yes" ""</samp>
- en: 'The string method: <samp class="SANS_TheSansMonoCd_W5Regular_11">str(yes)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">''yes''</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串方法：<samp class="SANS_TheSansMonoCd_W5Regular_11">str(yes)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'yes'</samp> 是 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
- en: 'Concatenation: <samp class="SANS_TheSansMonoCd_W5Regular_11">''Py''</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">''thon''</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">''Python''</samp>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 拼接：<samp class="SANS_TheSansMonoCd_W5Regular_11">'Py'</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'thon'</samp> 变成 <samp class="SANS_TheSansMonoCd_W5Regular_11">'Python'</samp>
- en: To use whitespace characters in strings you need to specify them explicitly.
    To start text on a new line within the string, use the newline character <samp
    class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp>. To add a tab’s worth of space,
    use the tab character <samp class="SANS_TheSansMonoCd_W5Regular_11">'\t'</samp>.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字符串中使用空白字符，你需要显式地指定它们。要在字符串中开始新的一行，使用换行符 <samp class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp>。要添加一个制表符的空格，使用制表符字符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'\t'</samp>。
- en: 'Strings also have their own set of methods. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strip()</samp>
    method removes the leading and trailing whitespaces, including empty spaces, tabular
    characters, and newline characters:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也有自己的方法集。<samp class="SANS_TheSansMonoCd_W5Regular_11">strip()</samp> 方法移除前后空白字符，包括空格、制表符和换行符：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = " This is lazy\t\n "</samp>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = " This is lazy\t\n "</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(y.strip())</samp>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(y.strip())</samp>
- en: 'The result is much neater:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结果更加整洁：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">'This is lazy'</samp>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">'This is lazy'</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> method lowercases
    the whole string:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> 方法将整个字符串转为小写：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("DrDre".lower())</samp>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("DrDre".lower())</samp>
- en: 'We get:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">'drdre'</samp>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">'drdre'</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">upper()</samp> method uppercases
    the whole string:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">upper()</samp> 方法将整个字符串转为大写：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("attention".upper())</samp>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("attention".upper())</samp>
- en: 'This gives us:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给我们：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">'ATTENTION'</samp>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">'ATTENTION'</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">startswith()</samp> method
    checks whether the argument you supply can be found at the start of the string:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">startswith()</samp> 方法检查您提供的参数是否可以在字符串的开头找到：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("smartphone".startswith("smart"))</samp>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("smartphone".startswith("smart"))</samp>
- en: 'It returns a Boolean:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个布尔值：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp> method
    checks whether the argument you supply can be found at the end of the string:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp> 方法检查您提供的参数是否可以在字符串的末尾找到：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("smartphone".endswith("phone"))</samp>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("smartphone".endswith("phone"))</samp>
- en: 'This also returns a Boolean:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这也返回一个布尔值：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">find()</samp> method returns
    the index of the first occurrence of the substring in the original string:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">find()</samp> 方法返回子字符串在原字符串中第一次出现的位置索引：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("another".find("other"))</samp>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("another".find("other"))</samp>
- en: 'Like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样：
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Match index: 2</samp>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">匹配索引：2</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp> method replaces
    the characters in the first argument with the characters in the second argument:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp> 方法将第一个参数中的字符替换为第二个参数中的字符：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("cheat".replace("ch", "m"))</samp>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("cheat".replace("ch", "m"))</samp>
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">cheat</samp> becomes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">cheat</samp> 变成了：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">meat</samp>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">meat</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">join()</samp> method combines
    all values in an iterable argument, using the string with which it is called as
    a separator between the elements in the iterable:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">join()</samp> 方法将可迭代对象中的所有值连接起来，使用调用该方法的字符串作为元素之间的分隔符：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(','.join(["F", "B", "I"]))</samp>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(','.join(["F", "B", "I"]))</samp>
- en: 'We get:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">F,B,I</samp>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">F,B,I</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp> method returns
    the number of characters in a string, including whitespace:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp> 方法返回字符串的字符数，包括空白字符：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(len("Rumpelstiltskin"))</samp>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(len("Rumpelstiltskin"))</samp>
- en: 'This gives us:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给我们：
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">String length: 15</samp>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">字符串长度：15</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword when used
    with string operands checks whether a string appears in another string:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 关键词在与字符串操作数一起使用时，用于检查一个字符串是否出现在另一个字符串中：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("ear" in "earth")</samp>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print("ear" in "earth")</samp>
- en: 'This too returns a Boolean:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这也返回一个布尔值：
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Contains: True</samp>'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">包含：True</samp>
- en: This nonexclusive list of string methods shows that Python’s string data type
    is flexible and powerful, and you can solve many common string problems with built-in
    Python functionality.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非排他性的字符串方法列表展示了 Python 的字符串数据类型既灵活又强大，你可以利用 Python 内建的功能解决许多常见的字符串问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Control Flow</samp>
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">控制流</samp>
- en: 'Let’s dive into some programming logic that allows our code to make decisions.
    An algorithm is like a cooking recipe: if that recipe consists of only a sequential
    list of commands—fill a pot with water, add the salt, add the rice, get rid of
    the water, and serve the rice—you might complete the steps in a matter of seconds
    and end up with a bowl of uncooked rice. We need to respond differently to different
    circumstances: remove the water from the pot only *if* the rice is soft, and put
    the rice in the pot *if* the water is boiling. Code that responds differently
    under different conditions is known as *conditional execution* code. In Python
    the conditional execution keywords are <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一些编程逻辑，使得我们的代码可以做出决策。算法就像一道烹饪食谱：如果食谱只是一个顺序命令的列表——把水倒进锅里，加入盐，加入米，去掉水，最后端上米饭——你可能几秒钟内完成这些步骤，最后得到的却是一碗未煮熟的米。我们需要根据不同的情况做出不同的反应：只有*当*米变软时，才从锅中去掉水；*当*水开了时，才把米放入锅中。根据不同情况做出响应的代码叫做*条件执行*代码。在
    Python 中，条件执行的关键词有 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>。
- en: 'Here’s a basic example that compares two figures:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本示例，用于比较两个数字：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">half_truth = 21</samp>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">half_truth = 21</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if 2 * half_truth == 42:</samp>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">if 2 * half_truth == 42:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Truth!')</samp>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Truth!')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Lie!')</samp>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Lie!')</samp>
- en: 'This will print:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Truth!</samp>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Truth!</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> condition <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2 * half_truth</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp> generates a result that
    evaluates to either <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If the expression
    evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, we enter
    the first branch and print <samp class="SANS_TheSansMonoCd_W5Regular_11">Truth!</samp>.
    If the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    we enter the second branch and print <samp class="SANS_TheSansMonoCd_W5Regular_11">Lie!</samp>.
    As the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the first branch is entered, and the shell output is <samp class="SANS_TheSansMonoCd_W5Regular_11">Truth!</samp>.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 条件 <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * half_truth</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">42</samp> 生成的结果要么是 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，要么是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。如果表达式的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，我们进入第一个分支并打印
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Truth!</samp>。如果表达式的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，我们进入第二个分支并打印
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Lie!</samp>。由于表达式的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，因此进入第一个分支，Shell
    输出为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Truth!</samp>。
- en: 'Each Python object, like a variable or a list, has an implicitly associated
    Boolean value, meaning we can use Python objects as conditions. For example, an
    empty list evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    and a non-empty list evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Python对象，如变量或列表，都有一个隐式的布尔值，这意味着我们可以将Python对象用作条件。例如，一个空列表的值为<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，而一个非空列表的值为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = []</samp>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = []</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if lst:</samp>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">if lst:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Full!')</samp>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('满！')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Empty!')</samp>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('空！')</samp>
- en: 'This prints:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Empty!</samp>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">空！</samp>
- en: 'If you don’t need an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    branch, you can simply skip it, and Python will skip the whole block if the condition
    evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要<samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>分支，你可以直接跳过它，Python会在条件评估为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>时跳过整个代码块：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if 2 + 2 == 4:</samp>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">如果 2 + 2 == 4:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('FOUR')</samp>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('四')</samp>
- en: 'This prints:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">FOUR</samp>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">四</samp>
- en: The output is printed only if the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    condition evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    Otherwise, nothing happens. The code has no side effects because it’s simply skipped
    by the execution flow.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>条件评估为<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>时，输出才会被打印。否则，什么也不会发生。代码没有副作用，因为它会被执行流跳过。
- en: 'You can also have code with more than two conditions. In this case, you can
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> statement:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以有多个条件的代码。在这种情况下，你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>语句：
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">x = input(''Your Number: '')</samp>'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x = input('你的数字：')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if x ==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">'1':</samp>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">if x ==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">'1':</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('ONE')</samp>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('一个')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">elif x == '2':</samp>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">elif x == '2':</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('TWO')</samp>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('两个')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">elif x == '3':</samp>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">elif x == '3':</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('THREE')</samp>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('三个')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('MANY')</samp>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('多个')</samp>
- en: The code takes your input and compares it against strings <samp class="SANS_TheSansMonoCd_W5Regular_11">'1'</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'2'</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">'3'</samp>.
    In each case, a different output is printed. If the input doesn’t match any string,
    the final branch is entered and the output is <samp class="SANS_TheSansMonoCd_W5Regular_11">'MANY'</samp>.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码接受你的输入，并将其与字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">'1'</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'2'</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">'3'</samp>进行比较。在每种情况下，都会打印不同的输出。如果输入与任何字符串都不匹配，则进入最终分支，输出为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'MANY'</samp>。
- en: 'The following code snippet takes user input, converts it into an integer, and
    stores it in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    It then tests whether the variable is larger than, equal to, or smaller than the
    value 3, and prints a different message depending on the evaluation. In other
    words, the code responds to real-world input that is unpredictable in a differentiated
    manner:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段接受用户输入，将其转换为整数，并存储在变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    中。然后测试变量是否大于、等于或小于 3，并根据评估结果打印不同的消息。换句话说，代码以区分的方式响应不可预测的现实世界输入：
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">x = int(input(''your value: ''))</samp>'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x = int(input('请输入你的值：'))</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if x > 3:</samp>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">if x > 3:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Big')</samp>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('大')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">elif x ==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3:</samp>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">elif x ==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Medium')</samp>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('中')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">else:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Small')</samp>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('小')</samp>
- en: 'We give the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    followed by the condition that determines which path the execution follows. If
    the condition evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the execution path follows the first branch given in the indented block that follows
    immediately. If the condition evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    the execution flow looks further, doing one of three things:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 后跟一个条件来决定执行路径。如果条件评估为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，执行路径将跟随紧接着的缩进块中的第一个分支。如果条件评估为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，则执行流会继续查找，并执行以下三种情况之一：
- en: 1.  Evaluates additional conditions as given by an arbitrary number of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> branches
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  评估额外的条件，条件由任意数量的 <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>
    分支给出
- en: 2.  Moves into the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    branch if neither an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> nor
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> condition is fulfilled
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  如果既没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 条件也没有 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> 条件满足，则进入 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    分支
- en: 3.  Skips the whole construct when no <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    branch is given and no <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>
    branch holds or exists
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  如果没有给出 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 分支，且没有符合的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> 分支，则跳过整个结构
- en: The rule is that the execution path starts at the top and moves down until either
    any condition matches—in which case the respective code branch is executed—or
    all conditions are explored but none matches.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是执行路径从顶部开始，逐行向下执行，直到某个条件匹配——此时执行对应的代码分支——或者所有条件都被检查过，但没有匹配。
- en: 'Here you see that it is possible to pass objects into an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    condition and use them like Booleans:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，可以将对象传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 条件，并像布尔值一样使用它们：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if None or 0 or 0.0 or ' ' or
    [] or {} or set():</samp>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">如果是 None、0、0.0、' '、[]、{} 或 set():</samp>
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   print(''Dead code'') # Not
    reached</samp>'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   print(''死代码'') # 不会执行</samp>'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> condition evaluations
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp>
    statement is never reached. This is because the following values evaluate to the
    Boolean value <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>: the
    keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>, the integer
    value <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the float value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>, empty strings, and empty
    container types. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">None
    or 0 or 0.0 or '' '' or [] or {} or set()</samp> evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    if Python can implicitly convert any of the operands to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    but here it doesn’t because all of them are converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 条件的评估结果是 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，因此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp> 语句永远不会被执行。因为以下值会被评估为布尔值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>：关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>、整数值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>、浮动值 <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>、空字符串和空容器类型。表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None or 0 or 0.0 or ' ' or [] or
    {} or set()</samp> 的评估结果为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，如果
    Python 能够隐式将任意操作数转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，但在此情况下，由于所有操作数都被转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，因此不成立。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Repeated Execution</samp>
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">重复执行</samp>
- en: 'To allow for repeated execution of similar code snippets, Python has two types
    of loops: <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loops. We’ll create a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop and a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop to achieve the same thing in different ways: print the integers 0, 1, and
    2 to the Python shell.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许类似代码片段的重复执行，Python 提供了两种类型的循环：<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环和 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环。我们将分别创建一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环和一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环，以不同的方式实现相同的功能：将整数 0、1 和 2 打印到 Python shell 中。
- en: 'Here’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">for i in [0, 1, 2]:</samp>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">for i in [0, 1, 2]:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(i)</samp>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(i)</samp>
- en: 'This will print:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop repeatedly
    executes the loop body by declaring a loop variable <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    that iteratively takes on all values in the list <samp class="SANS_TheSansMonoCd_W5Regular_11">[0,
    1, 2]</samp>. It then prints the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    until it runs out of values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环通过声明一个循环变量 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 来反复执行循环体，该变量会依次取列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">[0,
    1, 2]</samp> 中的所有值。然后它会打印变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>，直到所有值都用完。
- en: 'Here’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop
    version with similar semantics:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是具有相似语义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环版本：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">i = 0</samp>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">i = 0</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">while i < 3:</samp>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">while i < 3:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(i)</samp>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(i)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   i = i + 1</samp>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   i = i + 1</samp>
- en: 'This will also print:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会打印：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop executes
    the loop body as long as a condition is met—in our case, as long as <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
    The choice of which you use depends on your situation. Generally, you’ll use a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop when iterating over
    a fixed number of elements, such as when iterating over all elements in a list,
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop when you
    want to repeat a certain action until you accomplish a certain result, such as
    guessing a password until you’re in.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环在满足条件时执行循环体——在我们的例子中，条件是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>。你选择使用哪种循环取决于你的情况。一般来说，当你需要遍历固定数量的元素时，例如遍历列表中的所有元素，就会使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环；而当你想要重复某个动作直到达到某个结果时，例如猜测密码直到成功登录时，就会使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环。
- en: 'There are two fundamental ways to terminate a loop: define a loop condition
    that evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    as used in the previous example, or use the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    at the exact position in the loop body where you want it to stop. Here we use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> to exit what would
    otherwise be an infinite loop:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 终止循环有两种基本方法：一种是定义一个循环条件，使其在某一时刻返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，就像前面的例子那样；另一种方法是在循环体内的特定位置使用关键字
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 来停止循环。这里我们使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 来退出一个本来会是无限循环的情况：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">while True:</samp>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">while True:</samp>
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   break # No infinite loop</samp>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   break # 无无限循环</samp>'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('hello world')</samp>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('hello world')</samp>
- en: 'From this we get:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们得到：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hello world</samp>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">hello world</samp>
- en: We create a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop
    with a loop condition that will always evaluate to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    because the loop condition <samp class="SANS_TheSansMonoCd_W5Regular_11">while
    True</samp> already is inherently <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    The loop ends prematurely at <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>,
    so the code moves on and executes <samp class="SANS_TheSansMonoCd_W5Regular_11">print('hello
    world')</samp>.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环，其循环条件始终会被评估为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，因为循环条件 <samp class="SANS_TheSansMonoCd_W5Regular_11">while
    True</samp> 本身就是 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。当执行到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 时，循环提前结束，代码继续执行 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">print('hello world')</samp>。
- en: You may wonder why we would want to create an infinite loop in the first place
    if we don’t want it to run forever. This is a common practice, for example, when
    developing web servers that must use an infinite loop to wait for a new web request
    and serve the request. However, you’d still want to be able to terminate the loop
    prematurely. In the web server example, you might want to stop serving files if
    your server detects that it’s under attack. In these cases, you can use the keyword
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> to stop the loop if
    a certain condition is met.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会疑惑，如果我们不想让循环一直运行，为什么要创建一个无限循环？这其实是一种常见的做法，例如，在开发 Web 服务器时，服务器必须使用无限循环来等待新的
    Web 请求并处理请求。然而，你仍然希望能够在适当时终止循环。在 Web 服务器的例子中，你可能希望在服务器检测到被攻击时停止服务文件。在这些情况下，你可以使用关键字
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 来在满足某个条件时停止循环。
- en: 'It is also possible to force the Python interpreter to skip certain areas in
    the loop without ending it prematurely. In our web server example, you may want
    to skip execution of malicious web requests instead of halting the server completely.
    You can achieve this with the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    keyword, which finishes the current loop iteration and brings the execution flow
    back to the loop condition at the start:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以强制 Python 解释器跳过循环中的某些区域，而不是提前结束循环。在我们的 Web 服务器示例中，你可能希望跳过恶意的 Web 请求，而不是完全停止服务器。你可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 关键词来实现，它会结束当前的循环迭代并将执行流返回到开始处的循环条件：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">while True:</samp>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">while True:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   continue</samp>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   continue</samp>
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   print(''43'') # Dead code</samp>'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   print(''43'') # Dead code</samp>'
- en: 'This code will execute forever without executing the <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp>
    statement once, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement finishes the current loop iteration and takes it back to the start before
    it reaches the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> line.
    That <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> line is now
    considered *dead code*: code that will never be executed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement and <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> are commonly
    only used with additional conditions using <samp class="SANS_TheSansMonoCd_W5Regular_11">if-else</samp>,
    like so:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会永远执行下去，并且不会执行一次 <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp>
    语句，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句结束了当前的循环迭代，并在到达
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 行之前将执行流带回了开始的地方。那行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 现在被视为 *死代码*：即永远不会执行的代码。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句和 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    通常仅与使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">if-else</samp> 的附加条件一起使用，如下所示：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">while True:</samp>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">while True:</samp>
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   user_input = input(''your
    password: '')</samp>'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   user_input = input(''your
    password: '')</samp>'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   if user_input == '42':</samp>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   if user_input == '42':</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      break</samp>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      break</samp>
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   print(''wrong!'') # Dead code</samp>'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   print(''wrong!'') # Dead code</samp>'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('Congratulations, you found
    the secret password!')</samp>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('恭喜，你找到了秘密密码！')</samp>
- en: 'This code requests a password and runs forever or until the user figures out
    the password. If they enter the correct password <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>,
    the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> is reached
    and the loop terminates, sending execution to the successful <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp>
    statement at the end. In all other cases, the loop breaks, execution returns to
    the start, and the user will have to try again. Here’s a sample usage:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码请求一个密码并一直执行，直到用户猜出密码为止。如果用户输入正确的密码 <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>，会到达
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句，循环终止，执行流跳到成功的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">print</samp> 语句那里。否则，循环会中断，执行流返回到开始，用户需要重新尝试。以下是一个示例用法：
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">your password: 41</samp>'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">your password: 41</samp>'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">wrong!</samp>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">wrong!</samp>
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">your password: 21</samp>'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">your password: 21</samp>'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">wrong!</samp>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">wrong!</samp>
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">your password: 42</samp>'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">your password: 42</samp>'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Congratulations, you found the
    secret password!</samp>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">恭喜，你找到了秘密密码！</samp>
- en: These are the most important keywords for controlling the execution flow of
    your programs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是控制程序执行流程的最重要关键词。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Other Useful Keywords</samp>
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">其他有用的关键字</samp>
- en: 'Let’s have a look at some additional useful keywords. The <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    keyword checks whether a certain element exists in a given sequence or container
    type. Here we check if 42 is in the list that follows, then whether 21 can be
    found as a string in the set:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些其他有用的关键字。<samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 关键字用于检查某个元素是否存在于给定的序列或容器类型中。这里我们检查
    42 是否在下面的列表中，然后检查 21 是否可以作为字符串在集合中找到：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(42 in [2, 39, 42])</samp>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(42 in [2, 39, 42])</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('21' in {'2', '39', '42'})</samp>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('21' in {'2', '39', '42'})</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># False</samp>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"># False</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword returns
    a Boolean, so the first statement will return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    and the second <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 关键字返回布尔值，因此第一个语句会返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，第二个返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: 'The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp> checks
    if two variables refer to the same object in memory. Beginners in Python are often
    confused about the exact meaning of the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp>,
    but it’s worth taking the time to understand it properly. Here we see the difference
    between two variables pointing to the same object in memory, and two lists that
    look similar but point to different objects:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp> 关键字用于检查两个变量是否指向内存中的同一个对象。Python
    初学者经常对 <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp> 关键字的确切含义感到困惑，但值得花时间彻底理解它。这里我们看到两个变量指向内存中同一个对象的区别，以及两个看起来相似但指向不同对象的列表：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x is y)</samp>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x is y)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"># True</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([3] is [3])</samp>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([3] is [3])</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># False</samp>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"># False</samp>
- en: As you can see in the latter example, if you create two lists—even if they contain
    the same elements—they still refer to two different list objects in memory. If
    you later decided to modify one list object, this would not affect the other list
    object. If you check whether one list refers to the same object in memory, the
    result is <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Here, when
    we check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, we get <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    because we explicitly set <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    to refer to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. When we check
    the list <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp> against <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>, however, we get <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    because the lists refer to different objects in memory. If you change one, you
    don’t change the other!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在后面的示例中看到的，如果你创建两个列表——即使它们包含相同的元素——它们仍然在内存中指向两个不同的列表对象。如果你稍后决定修改其中一个列表对象，这不会影响另一个列表对象。如果你检查一个列表是否指向内存中的相同对象，结果会是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。在这里，当我们检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    是否为 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 时，返回的是 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，因为我们显式地将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 设置为指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。然而，当我们检查列表
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp> 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>
    是否相等时，我们得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，因为这两个列表指向内存中的不同对象。如果你修改一个，它不会改变另一个！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Functions</samp>
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">函数</samp>
- en: '*Functions* are reusable code snippets that accomplish a specific task. Programmers
    can and often do share functions with other programmers to deal with specific
    tasks, saving people the time and effort of writing the code themselves.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是可重用的代码片段，完成特定任务。程序员通常会与其他程序员共享函数来处理特定任务，从而节省编写代码的时间和精力。'
- en: 'You define a function using the <samp class="SANS_TheSansMonoCd_W5Regular_11">def</samp>
    keyword. Here we define two simple functions that each print a string:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用<samp class="SANS_TheSansMonoCd_W5Regular_11">def</samp>关键字来定义一个函数。这里我们定义了两个简单的函数，每个函数都打印一个字符串：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hi():</samp>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hi():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('hi!')</samp>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('hi!')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hello():</samp>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hello():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('hello!')</samp>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('hello!')</samp>
- en: A function consists of the function name with parentheses, prefixed with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">def</samp> keyword, and the function
    body, which is an indented code block. This block can contain other indented blocks,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements, and even
    further function definitions. As with any block definition in Python, you must
    indent the function’s body.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 函数由函数名和括号组成，前面加上<samp class="SANS_TheSansMonoCd_W5Regular_11">def</samp>关键字，以及函数体，它是一个缩进的代码块。这个代码块可以包含其他缩进的块，比如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句，甚至是进一步的函数定义。和Python中的任何块定义一样，你必须缩进函数的主体。
- en: 'Here’s a function that prints two strings on new lines:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数，它在新行上打印两个字符串：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_bye():</samp>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_bye():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Time to go…')</samp>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Time to go…')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Bye! ')</samp>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('Bye! ')</samp>
- en: 'Run all three functions in your Python shell like so:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这样在Python终端中运行这三个函数：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Say_hi()</samp>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Say_hi()</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Say_hello()</samp>
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Say_hello()</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Say_bye()</samp>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Say_bye()</samp>
- en: 'Here’s the output:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hi!</samp>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">hi!</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hello!</samp>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">hello!</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Time to go…</samp>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Time to go…</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Bye!</samp>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Bye!</samp>
- en: The functions are executed in order.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数按顺序执行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Arguments</samp>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">参数</samp>
- en: 'A function can also take arguments within the parentheses. An *argument* allows
    you to tailor the output. Consider this function, which takes a name as its only
    argument and prints a customized string to the shell:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以在括号内接受参数。一个*参数*允许你定制输出。考虑这个函数，它将名字作为唯一的参数，并将自定义字符串输出到终端：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hi(name):</samp>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hi(name):</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('hi ' +</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name)</samp>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print('hi ' +</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Alice')</samp>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Alice')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Bob')</samp>
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Bob')</samp>
- en: 'We define the function and then run it twice with different arguments: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">''Alice''</samp> then <samp class="SANS_TheSansMonoCd_W5Regular_11">''Bob''</samp>.
    Thus, the output of the function executions is different:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了函数，然后用不同的参数运行它两次：<samp class="SANS_TheSansMonoCd_W5Regular_11">'Alice'</samp>然后<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'Bob'</samp>。因此，函数执行的输出是不同的：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hi Alice</samp>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">hi Alice</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">hi Bob</samp>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">hi Bob</samp>
- en: 'Functions can also take multiple arguments:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以接受多个参数：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hi(a, b):</samp>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def say_hi(a, b):</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(a + ' says hi to ' +
    b)</samp>
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(a + ' says hi to ' +
    b)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Alice', 'Bob')</samp>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Alice', 'Bob')</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Bob', 'Alice')</samp>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">say_hi('Bob', 'Alice')</samp>
- en: 'The output is the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Alice says hi to Bob</samp>
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Alice 向 Bob 打招呼</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Bob says hi to Alice</samp>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Bob 向 Alice 打招呼</samp>
- en: In the first function execution, the argument variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    takes on the string value <samp class="SANS_TheSansMonoCd_W5Regular_11">'Alice'</samp>
    and the argument variable <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    takes on the string value <samp class="SANS_TheSansMonoCd_W5Regular_11">'Bob'</samp>.
    The second function execution reverses this assignment, giving us different output.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次执行函数时，参数变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 取值为字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'Alice'</samp>，而参数变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    取值为字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">'Bob'</samp>。第二次执行函数时，这两个参数的值会交换，从而得到不同的输出。
- en: Functions can also have return values, so you can pass a value into the function
    and get back a value that you can then use later in the code, as shown in [Listing
    A-1](appendix.xhtml#ListA-1).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以有返回值，因此你可以将一个值传递给函数，并获得一个返回值，然后可以在代码中稍后使用该值，如[列表 A-1](appendix.xhtml#ListA-1)所示。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def f(a, b):</samp>
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def f(a, b):</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return a + b</samp>
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return a + b</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">f(2,
    2)</samp>
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">f(2,
    2)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = f(40, 2)</samp>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = f(40, 2)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x)</samp>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(y)</samp>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(y)</samp>
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-1: Using the return
    keyword</samp>'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 A-1：使用 return 关键字</samp>
- en: The return value is the expression right after the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>,
    which also terminates the function. Python checks the return value right after
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword and ends
    the function, immediately giving this value back to the caller of the function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是紧跟在`return`关键字后的表达式，它也会终止函数。Python会在`return`关键字之后检查返回值，并结束函数，立即将这个值返回给函数的调用者。
- en: If you don’t explicitly provide a return expression, Python will implicitly
    add the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">return None</samp>
    to the end of the function. The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    means *the absence of a value*. Other programming languages, such as Java, use
    the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, which often
    leads to confusion when beginners assume it’s equal to the integer value 0\. Instead,
    Python uses the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    to indicate it’s an empty object, like an empty list or string, and not a numerical
    0.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有显式提供返回表达式，Python会隐式地在函数末尾添加表达式 `return None`。`None`关键字表示*没有值*。其他编程语言，如Java，使用`null`关键字，这通常会让初学者误以为它等同于整数值0。而Python使用`None`来表示它是一个空对象，如空列表或空字符串，而不是数值0。
- en: When a function finishes executing, the execution is always passed to the caller
    of the function; the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    keyword just gives you more control about *when* to terminate the function and
    *what* to give back.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数执行完成时，执行流程总是会传递给调用该函数的地方；`return`关键字只是让你更好地控制*何时*终止函数以及*返回什么*值。
- en: 'We pass <samp class="SANS_TheSansMonoCd_W5Regular_11">a=2</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b=2</samp> into the function in [Listing
    A-1](appendix.xhtml#ListA-1), and get the result <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.
    We then pass <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=40</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b=2</samp> and get the (one
    and only) answer <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>. Here’s
    the output:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">a=2</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b=2</samp>
    传递给 [示例 A-1](appendix.xhtml#ListA-1) 中的函数，得到结果 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>。然后我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a=40</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b=2</samp>
    传递进去，得到（唯一的）答案 <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>。以下是输出：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>
- en: 'Almost every dashboard app contains at least one function that adds some interactivity.
    Commonly, you may have a function that updates a graph based on some user input,
    something like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个仪表盘应用程序都至少包含一个添加交互性的函数。通常，你可能有一个根据用户输入更新图表的函数，类似这样的：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def update_graph(value):</samp>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def update_graph(value):</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   if value == 2:</samp>
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   if value == 2:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      return 'something'</samp>
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      return 'something'</samp>
- en: 'Next, we’ll look at a more advanced and highly relevant feature of Python:
    *default function arguments*.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍 Python 中一个更高级且高度相关的特性：*默认函数参数*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Default Function Arguments</samp>
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">默认函数参数</samp>
- en: Default arguments allow you to define a function with optional arguments in
    Python. If a user opts not to provide an argument when they call the function,
    the default argument is used. You set the default argument by using the equal
    sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) after the argument
    name and appending the default value.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数允许你在 Python 中定义具有可选参数的函数。如果用户在调用函数时没有提供参数，就会使用默认参数。你通过在参数名后使用等号（<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>）并附加默认值来设置默认参数。
- en: '[Listing A-2](appendix.xhtml#ListA-2) shows a more interesting example. Here
    we define a function <samp class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>
    that returns the sum of the function arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. So, <samp class="SANS_TheSansMonoCd_W5Regular_11">add(1,2)</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">add(41,1)</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>. We specify
    default values for the function arguments: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. If no value is passed
    for one or both of these arguments in the function call, it will be set to its
    default value. So, <samp class="SANS_TheSansMonoCd_W5Regular_11">add(1)</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">add(-1)</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add()</samp> will return <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    because the default arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> are used for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表A-2](appendix.xhtml#ListA-2)展示了一个更有趣的例子。这里我们定义了一个函数<scode class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>，它返回函数参数<scode
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>和<scode class="SANS_TheSansMonoCd_W5Regular_11">b</samp>的和。因此，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">add(1,2)</samp>将返回<samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">add(41,1)</samp>将返回<samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>。我们为函数参数指定了默认值：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>为<scode class="SANS_TheSansMonoCd_W5Regular_11">a</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>为<scode class="SANS_TheSansMonoCd_W5Regular_11">b</samp>。如果在函数调用中没有传递其中一个或两个参数的值，则会使用默认值。因此，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">add(1)</samp>将返回<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">add(-1)</samp>将返回<samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>将返回<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，因为默认参数<code
    class="SANS_TheSansMonoCd_W5Regular_11">0</code>和<code class="SANS_TheSansMonoCd_W5Regular_11">1</code>将用于a和b。'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def add(a=0, b=1):</samp>
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def add(a=0, b=1):</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return a + b</samp>
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return a + b</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(add(add(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">add()</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)))</samp>
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(add(add(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">add()</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)))</samp>
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-2: Defining a function
    with default arguments</samp>'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表A-2：定义带默认参数的函数</samp>
- en: 'This will print:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
- en: In the innermost function call we highlighted in <samp class="SANS_TheSansMonoCd_W5Regular_11">print(add(add(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">add()</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)))</samp>,
    we call the function <samp class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>
    with no arguments, so it uses the default values for <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> (0 and 1, respectively).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们突出显示的最内层函数调用中，<samp class="SANS_TheSansMonoCd_W5Regular_11">print(add(add(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">add()</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)))</samp>，我们调用了没有参数的函数<scode
    class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>，因此它使用了<a>和<b>的默认值（分别为0和1）。
- en: For the remaining two calls, you only pass one argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>,
    and that’s the return value of the previous function call. This argument will
    receive <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, taking the position
    of the arguments to figure out which argument to pass to which variable, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> will have its default value 1\.
    The first, innermost call of <samp class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>
    returns 1\. This is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>
    in the second call and so is incremented by 1, and then that value is again incremented
    by 1 in the third call.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩下的两个调用，你只需要向 <samp class="SANS_TheSansMonoCd_W5Regular_11">add()</samp> 传递一个参数，该参数是上一个函数调用的返回值。这个参数将接收
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>，通过参数的位置来决定该传递哪个参数给哪个变量，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 将使用其默认值 1。最内层的第一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add()</samp> 调用返回 1。这个值会传递给第二个调用的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add()</samp>，并增加 1，然后这个值再在第三个调用中增加 1。
- en: 'Here is what happens behind the scenes when we execute [Listing A-2](appendix.xhtml#ListA-2),
    step by step:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们执行 [Listing A-2](appendix.xhtml#ListA-2) 时的背后步骤：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">add(add(add()))</samp>
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">add(add(add()))</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   = add(add(1))</samp>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   = add(add(1))</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   = add(2)</samp>
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   = add(2)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   = 3</samp>
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   = 3</samp>
- en: You can see that default arguments can help you make functions more flexible
    in regard to their inputs.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，默认参数可以帮助你使函数在处理输入时更加灵活。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Python Resources and Further Reading</samp>
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Python 资源与进一步阅读</samp>
- en: Feel free to check out the *Python One-Liners* introductory Python videos available
    for free at [*https://<wbr>pythononeliners<wbr>.com*](https://pythononeliners.com).
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随时查看 *Python 一行代码* 入门视频，这些视频可以在 [*https://<wbr>pythononeliners<wbr>.com*](https://pythononeliners.com)
    免费获取。
- en: The official Python website with the newest Python version for download can
    be found at [*https://<wbr>www<wbr>.python<wbr>.org*](https://www.python.org).
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方的 Python 网站，包含最新的 Python 版本下载，可以在 [*https://<wbr>www<wbr>.python<wbr>.org*](https://www.python.org)
    找到。
- en: You can find a full tutorial on Python lists with detailed video content on
    the Finxter blog at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/python<wbr>-lists*](https://blog.finxter.com/python-lists).
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 Finxter 博客上找到有关 Python 列表的完整教程和详细的视频内容，链接为 [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/python<wbr>-lists*](https://blog.finxter.com/python-lists)。
- en: For a full tutorial with video on Python slicing, visit [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/introduction<wbr>-to<wbr>-slicing<wbr>-in<wbr>-python*](https://blog.finxter.com/introduction-to-slicing-in-python).
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Python 切片的完整教程和视频，请访问 [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/introduction<wbr>-to<wbr>-slicing<wbr>-in<wbr>-python*](https://blog.finxter.com/introduction-to-slicing-in-python)。
- en: You can find a complete guide on Python dictionaries at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/python<wbr>-dictionary*](https://blog.finxter.com/python-dictionary).
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/python<wbr>-dictionary*](https://blog.finxter.com/python-dictionary)
    找到有关 Python 字典的完整指南。
- en: A guide on list comprehension with video is available at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/list<wbr>-comprehension*](https://blog.finxter.com/list-comprehension).
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关列表推导的指南和视频可以在 [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/list<wbr>-comprehension*](https://blog.finxter.com/list-comprehension)
    查看。
- en: An object-oriented programming (OOP) cheat sheet can be downloaded as a PDF
    at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/object<wbr>-oriented<wbr>-programming<wbr>-terminology<wbr>-cheat<wbr>-sheet<wbr>*](https://blog.finxter.com/object-oriented-programming-terminology-cheat-sheet).
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面向面向对象编程（OOP）的备忘单可以作为 PDF 下载，链接为 [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/object<wbr>-oriented<wbr>-programming<wbr>-terminology<wbr>-cheat<wbr>-sheet<wbr>*](https://blog.finxter.com/object-oriented-programming-terminology-cheat-sheet)。
- en: Find more cheat sheets and a free Python crash course at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/python<wbr>-crash<wbr>-course*](https://blog.finxter.com/python-crash-course).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/python<wbr>-crash<wbr>-course*](https://blog.finxter.com/python-crash-course)
    查找更多备忘单和免费的 Python 入门课程。
