- en: '## **20'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **20'
- en: INPUT/OUTPUT**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: The *I/O subsystem* is what programs use to communicate with the outside world,
    meaning devices other than the CPU and memory. Most programs read data from one
    or more input devices, process the data, and then write the results to one or
    more output devices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*I/O子系统*是程序用来与外部世界（即CPU和内存之外的设备）进行通信的部分。大多数程序从一个或多个输入设备读取数据，处理数据，然后将结果写入一个或多个输出设备。'
- en: Keyboards and mice are typical input devices; display screens and printers are
    typical output devices. Although most people don’t think of them this way, devices
    such as magnetic disks, solid-state drives (SSDs), USB sticks, and so forth are
    also I/O devices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘和鼠标是典型的输入设备；显示屏和打印机是典型的输出设备。虽然大多数人不会这样看待它们，但像磁盘、固态硬盘（SSD）、USB闪存等设备也是I/O设备。
- en: I’ll start this chapter by discussing some of the timing characteristics of
    I/O devices compared to memory, then I’ll cover how this affects the interface
    between the CPU and I/O devices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从讨论I/O设备与内存的时序特性开始，然后介绍这如何影响CPU与I/O设备之间的接口。
- en: '**Timing Considerations**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**时序考虑**'
- en: Since the CPU accesses memory and I/O devices over the same buses (see [Figure
    1-1](ch01.xhtml#ch1fig1) in [Chapter 1](ch01.xhtml)), it might seem that a program
    could access I/O devices in the same way as it accesses memory. That is, you might
    expect that I/O can be performed by using the `ldr` and `str` instructions to
    transfer bytes of data between the CPU and a specific I/O device. This can be
    done with many devices, but some particularities must be taken into account to
    make it work correctly. One of the main issues lies in the timing differences
    between memory and I/O. Before tackling I/O timing, let’s consider memory timing
    characteristics.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CPU通过相同的总线访问内存和I/O设备（见[图1-1](ch01.xhtml#ch1fig1)在[第1章](ch01.xhtml)中），这可能会让人认为程序可以像访问内存一样访问I/O设备。也就是说，你可能会期望通过使用`ldr`和`str`指令在CPU和特定的I/O设备之间传输字节数据来执行I/O操作。这对于许多设备是可以实现的，但为了正确工作，必须考虑一些特殊情况。一个主要的问题是内存和I/O之间的时序差异。在处理I/O时序之前，让我们先考虑一下内存的时序特性。
- en: '**NOTE**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As I’ve pointed out, the three-bus description given in this book shows the
    logical interaction between the CPU and I/O devices. Most modern computers employ
    several types of buses. The way the CPU connects to the various buses is handled
    in hardware. A programmer generally deals only with the logical view.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如我指出的，本书中给出的三总线描述显示了CPU和I/O设备之间的逻辑交互。大多数现代计算机使用多种总线。CPU如何连接到各种总线由硬件处理。程序员通常只处理逻辑视图。*'
- en: '***Memory Timing***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存时序***'
- en: An important characteristic of memory is that its timing is relatively uniform
    and not dependent on external events. This means memory timing can be handled
    by the hardware, so programmers don’t need to be concerned about it; we can simply
    move data to and from memory using CPU instructions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内存的一个重要特性是它的时序相对均匀，并且不依赖于外部事件。这意味着内存时序可以由硬件处理，程序员无需担心；我们可以简单地通过CPU指令将数据从内存中移入或移出。
- en: 'Two types of RAM are commonly used in computers:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机中常用的两种RAM类型：
- en: '**SRAM**   Holds its values as long as the power is on. It requires more components
    to do this, so it is more expensive and physically larger, but access times are
    very fast.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**SRAM**   只要电源开启，它就能保持其值。为了做到这一点，它需要更多的组件，因此成本较高且体积较大，但访问速度非常快。'
- en: '**DRAM**   Uses passive components that hold data values for only a few fractions
    of a second. DRAM includes circuitry that automatically refreshes the data values
    before the values are completely lost. It is less expensive than SRAM, but also
    5 to 10 times slower.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**DRAM**   使用被动组件，数据值只能保持几分之一秒。DRAM包括自动刷新数据值的电路，防止值完全丢失。它比SRAM便宜，但速度慢5到10倍。'
- en: Most of the memory on the Raspberry Pi is DRAM, because it is much less expensive
    and smaller than SRAM. As each instruction must be fetched from memory, slow memory
    access limits program execution speed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派的大部分内存是DRAM，因为它比SRAM便宜且体积更小。由于每条指令都必须从内存中提取，慢速的内存访问限制了程序的执行速度。
- en: Program execution speed is improved by using cache memory systems made from
    SRAM. The combination of SRAM cache with DRAM main memory works well to ensure
    minimal time delays when the CPU accesses memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用由SRAM组成的缓存内存系统，可以提高程序执行速度。将SRAM缓存与DRAM主内存结合使用，有助于确保CPU访问内存时最小化时间延迟。
- en: It’s worth noting here that CPU speeds are still faster than memory speeds (even
    SRAM). Accessing memory—fetching an instruction, loading data, storing data—is
    typically the most important factor that slows program execution. There are techniques
    for improving cache performance, which improves memory access times, but employing
    such techniques requires a thorough understanding of the CPU and memory configuration
    of the system you’re using, which is beyond the scope of this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，CPU的速度仍然比内存速度快（即使是SRAM）。访问内存——获取指令、加载数据、存储数据——通常是减慢程序执行的最重要因素。有一些技术可以提高缓存性能，从而改善内存访问时间，但采用这些技术需要对你所使用的系统的CPU和内存配置有透彻的理解，这超出了本书的范围。
- en: '***I/O Device Timing***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***I/O设备时序***'
- en: Almost all I/O devices are much slower than memory. Consider a common input
    device, the keyboard. Typing at 120 words per minute is equivalent to entering
    approximately 10 characters per second, or a delay of ∼100 ms between each character.
    A CPU running at 2 GHz can execute approximately 200 million instructions during
    that time. This is to say nothing of the fact that the time intervals between
    keystrokes are very inconsistent. Many will be much longer than this.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的I/O设备都比内存慢得多。考虑一下常见的输入设备——键盘。以每分钟120个字的速度打字，相当于每秒输入大约10个字符，或者每个字符之间的延迟大约为∼100毫秒。在这段时间内，一颗以2
    GHz运行的CPU可以执行约2亿条指令。更不用说，按键之间的时间间隔非常不一致，许多按键间隔会远比这个时间长。
- en: Even an SSD is slow compared to memory. For example, data can be transferred
    to and from a typical SSD at about 500MBps. The transfer rate for DDR4 memory
    (which is commonly used for main memory) is around 20GBps, some 40 times faster.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是SSD，相对于内存来说也很慢。例如，典型的SSD的传输速度大约是500MB每秒。而DDR4内存（常用于主内存）的传输速度大约是20GB每秒，快了约40倍。
- en: In addition to being much slower, I/O devices exhibit much more variance in
    their timing. Some people type very quickly on a keyboard, some very slowly. The
    required data on a magnetic disk might be just coming up to the read/write head,
    or it may have just passed by, in which case you’ll have to wait for nearly a
    full revolution of the disk for it to come under the head again.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了速度远低于内存外，I/O设备在时序上还表现出更大的波动性。有些人打字很快，有些人打字很慢。磁盘上的数据可能刚好经过读写头，或者可能已经过去，在这种情况下，你将不得不等待磁盘几乎转一圈才能让数据再次出现在读写头下。
- en: As pointed out at the beginning of [Chapter 9](ch09.xhtml), the Raspberry Pi
    uses a System on a Chip (SoC), which includes one or more processor cores and
    many of the controllers for other parts of the computer. Most SoCs based on the
    ARM architecture use the Advanced Microcontroller Bus Architecture (AMBA), first
    introduced by Arm in 1997\. This architecture specifies several protocols, which
    are used to select the appropriate speeds for the communications between the CPU
    and other functional parts in the SoC. The details are beyond the scope of this
    book, but if you’re interested in learning more about AMBA, a good starting point
    is the free online training videos at *[https://www.arm.com/architecture/system-architectures/amba](https://www.arm.com/architecture/system-architectures/amba)*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第9章](ch09.xhtml)开头所指出的，树莓派使用的是一个系统芯片（SoC），它包括一个或多个处理器核心以及许多控制器，用于管理计算机的其他部分。大多数基于ARM架构的SoC使用的是由Arm在1997年首次推出的高级微控制器总线架构（AMBA）。该架构定义了几种协议，用于选择适当的速度，以便在CPU和SoC中其他功能部件之间进行通信。具体细节超出了本书的范围，但如果你有兴趣了解更多关于AMBA的内容，可以从*
    [https://www.arm.com/architecture/system-architectures/amba](https://www.arm.com/architecture/system-architectures/amba)
    *上的免费在线培训视频入手。
- en: The SoC includes controllers for most of the external I/O interfaces. All Raspberry
    Pis, except the Raspberry Pi Zero, have a second chip that provides additional
    external I/O interfaces. The I/O chip on a Raspberry Pi 1, 1+, 2, 3, or 3+ provides
    Ethernet and USB 2.0 ports, and it communicates with the SoC via USB 2.0\. The
    I/O chip on a Raspberry Pi 4 provides USB 2.0 and USB 3.0 ports, and it communicates
    with the SoC via a PCI Express (PCI-E) bus.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SoC包含大多数外部I/O接口的控制器。除了树莓派Zero外，所有树莓派都配备了第二个芯片，提供额外的外部I/O接口。树莓派1、1+、2、3或3+上的I/O芯片提供以太网和USB
    2.0端口，并通过USB 2.0与SoC进行通信。树莓派4上的I/O芯片提供USB 2.0和USB 3.0端口，并通过PCI Express（PCI-E）总线与SoC进行通信。
- en: The Raspberry Pi 5 uses a new I/O controller chip named *RP1* that incorporates
    most of the controllers for the external I/O interfaces that were previously on
    the SoC, including USB, MIPI camera and display, Ethernet, and general-purpose
    input/output (GPIO). Such a device is often called a *southbridge*. The RP1 communicates
    with the SoC via a PCI-E bus. Moving the slower I/O functionality to a separate
    chip simplifies the SoC, allowing it to run faster and to focus on computation-intensive
    tasks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派 5 使用了一款新的 I/O 控制器芯片，名为 *RP1*，它整合了之前 SoC 上的大多数外部 I/O 接口控制器，包括 USB、MIPI 摄像头和显示器、以太网和通用输入输出
    (GPIO)。这样的设备通常被称为 *南桥*。RP1 通过 PCI-E 总线与 SoC 进行通信。将较慢的 I/O 功能移至独立的芯片有助于简化 SoC，使其能够更快速地运行，并专注于计算密集型任务。
- en: Next, I’ll show you how we access the registers of an I/O device.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向你展示如何访问 I/O 设备的寄存器。
- en: '**Accessing I/O Devices**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**访问 I/O 设备**'
- en: The CPU works with an I/O device through a *device controller*, the hardware
    that does the actual work of controlling the I/O device. For example, a keyboard
    controller detects which key is pressed and converts this to a bit pattern that
    represents the key. It also detects whether modifier keys, such as SHIFT or CTRL,
    are pressed and sets the bit pattern accordingly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 通过 *设备控制器* 与 I/O 设备进行工作，设备控制器是执行实际控制 I/O 设备工作的硬件。例如，键盘控制器检测按下的是哪个键，并将其转换为代表该键的位模式。它还会检测修饰键，如
    SHIFT 或 CTRL 是否被按下，并相应地设置位模式。
- en: 'The device controller interfaces with the CPU through a set of registers. In
    general, a device controller provides the following types of I/O registers:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 设备控制器通过一组寄存器与 CPU 进行接口。通常，设备控制器提供以下类型的 I/O 寄存器：
- en: '**Data**   Used to send data to an output device or to read data from an input
    device'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据** 用于将数据发送到输出设备或从输入设备读取数据'
- en: '**Status**   Provides information about the current state of the device, including
    the controller itself'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态** 提供关于设备当前状态的信息，包括控制器本身'
- en: '**Control**   Allows a program to send commands to the controller to change
    the settings of the device and the controller'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制** 允许程序向控制器发送命令以更改设备和控制器的设置'
- en: It’s common for a device controller interface to have more than one register
    of the same type, especially control registers and status registers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 设备控制器接口通常会有多个相同类型的寄存器，特别是控制寄存器和状态寄存器。
- en: 'Sending data to an output device is very much like storing data in memory:
    you store the data in a data register on the device controller. Where the output
    device differs from memory is the timing. As I’ve already said, a programmer doesn’t
    need to be concerned about the timing when storing data in memory. However, an
    output device may not be ready to accept new data—it may be working on previously
    sent data. This is where the status register comes into play. The program needs
    to check the status register to see if the device controller is ready to accept
    new data.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据发送到输出设备很像将数据存储在内存中：你将数据存储在设备控制器的数据寄存器中。输出设备与内存的不同之处在于时机。如我之前所说，程序员在将数据存储到内存时不需要关心时机。然而，输出设备可能未准备好接收新数据——它可能正在处理先前发送的数据。这时，状态寄存器就发挥了作用。程序需要检查状态寄存器，看看设备控制器是否准备好接受新数据。
- en: 'Reading data from an input device is like loading data from memory into the
    CPU: you load the data from a data register on the device controller. Again, the
    difference from memory is that an input device may not have new data, so the program
    needs to check the status register of the input device controller to see if it
    does.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入设备读取数据就像将数据从内存加载到 CPU 中一样：你从设备控制器的数据寄存器中加载数据。与内存的区别在于，输入设备可能没有新数据，因此程序需要检查输入设备控制器的状态寄存器，以查看是否有新数据。
- en: Most I/O devices also need to be told what to do by a control register. For
    example, after waiting for an output device controller to become ready for new
    data and then moving the data to a data register, some device controllers require
    that you tell them to output the data to the actual device. Or, if you want to
    get data from an input device, some device controllers require that you request
    them to get an input. You can send commands like these to a control register.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 I/O 设备还需要通过控制寄存器告诉它们该做什么。例如，在等待输出设备控制器准备好接受新数据并将数据移到数据寄存器之后，一些设备控制器要求你告诉它们将数据输出到实际设备。或者，如果你想从输入设备获取数据，一些设备控制器要求你请求它们获取输入。你可以将这些命令发送到控制寄存器。
- en: 'The CPU can access the I/O registers on a device controller in two ways: via
    memory-mapped I/O and port-mapped I/O. With *memory-mapped I/O*, a range of memory
    addresses is dedicated to the I/O ports, and each I/O register is mapped to one
    of the memory addresses in that range. Then, the load and store instructions are
    used to read from or write to the I/O registers on a device controller.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: CPU可以通过两种方式访问设备控制器上的I/O寄存器：通过内存映射I/O和端口映射I/O。使用*内存映射I/O*时，一段内存地址范围专用于I/O端口，每个I/O寄存器被映射到该范围内的一个内存地址。然后，使用加载和存储指令来读取或写入设备控制器上的I/O寄存器。
- en: With *port-mapped I/O*, the I/O device controller registers are assigned addresses
    in a separate addressing space. The CPU uses special I/O instructions to communicate
    with the I/O registers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*端口映射I/O*时，I/O设备控制器的寄存器被分配到一个独立的寻址空间。CPU通过特殊的I/O指令与I/O寄存器进行通信。
- en: The AArch64 architecture supports only memory-mapped I/O. The x86 architecture
    is an example of one that supports both types of I/O.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: AArch64架构仅支持内存映射I/O。x86架构则是支持两种I/O类型的示例。
- en: It’ll be easier to understand memory-mapped I/O if we first look at how memory
    is managed by Linux and most other operating systems when executing a program.
    Programs run in a *virtual memory* address space, a technique that simulates a
    large memory with contiguous addressing from 0 to some maximum value. These are
    the addresses you see when using `gdb`—for example, the addresses in the `sp`
    and `pc` registers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先了解Linux和大多数其他操作系统在执行程序时如何管理内存，理解内存映射I/O会更容易。程序在*虚拟内存*地址空间中运行，这是一种通过从0到最大值的连续寻址模拟大内存的技术。这些就是你在使用`gdb`时看到的地址——例如，`sp`和`pc`寄存器中的地址。
- en: Although the AArch64 architecture allows 64-bit addressing, current CPU hardware
    implementations use only 52 bits for the address. This allows a maximum address
    of 2^(52) bytes (4 pebibytes) to execute programs in this virtual address space.
    But a Raspberry Pi has only 1 to 8GiB (or gibibytes) of *physical memory*, the
    actual RAM installed in the computer, and a program needs to be in physical memory
    to be executed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管AArch64架构允许64位寻址，但当前的CPU硬件实现仅使用52位地址。这使得可以在这个虚拟地址空间中执行程序的最大地址为2^(52)字节（4 pebibytes）。但是，Raspberry
    Pi只有1到8GiB（或吉二进制字节）的*物理内存*，即计算机中安装的实际RAM，程序需要在物理内存中才能执行。
- en: '**NOTE**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We commonly use the metric naming convention for specifying multiple-byte
    quantities that is based on powers of 10: kilobyte, megabyte, gigabyte, and so
    forth. The International Electrotechnical Commission (IEC) has also defined a
    naming convention that is based on powers of two: kibibyte, mebibyte, gibibyte,
    and so forth. For example, a kilobyte is 1,000 bytes, and a kibibyte is 1,024
    bytes. You can read more about the naming conventions at* [https://en.wikipedia.org/wiki/Byte](https://en.wikipedia.org/wiki/Byte).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们通常使用基于10的幂次方的度量命名约定来指定多字节量：千字节、兆字节、千兆字节等。国际电工委员会（IEC）还定义了一种基于2的幂次方的命名约定：千二进制字节、兆二进制字节、吉二进制字节等。例如，千字节是1,000字节，而千二进制字节是1,024字节。你可以在*
    [https://en.wikipedia.org/wiki/Byte](https://en.wikipedia.org/wiki/Byte) 阅读更多关于命名约定的信息。*'
- en: The operating system manages the placement of programs in physical memory by
    dividing each program into *pages*. Raspberry Pi OS uses a 4KiB (or kibibyte)
    page size on most models and a 16KiB page size on the model 5\. Physical memory
    is divided into the same size *page frames*. The page of the program that contains
    the code currently being executed by the CPU is loaded from the place where it’s
    stored (for example, disk, DVD, USB stick) into a page frame of physical memory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通过将每个程序划分为*页面*，来管理程序在物理内存中的放置。Raspberry Pi OS在大多数型号上使用4KiB（或千二进制字节）页面大小，在Model
    5上使用16KiB页面大小。物理内存被划分为相同大小的*页面框架*。包含当前由CPU执行的代码的程序页面会从存储位置（例如磁盘、DVD、USB闪存驱动器）加载到物理内存的页面框架中。
- en: The operating system maintains a *page table* that shows where the page of the
    program is currently loaded in physical memory. [Figure 20-1](ch20.xhtml#ch20fig1)
    shows the relationship between virtual memory and physical memory using the page
    table.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统维护一个*页表*，显示程序的页面当前在物理内存中的加载位置。[图 20-1](ch20.xhtml#ch20fig1)使用页表展示了虚拟内存和物理内存之间的关系。
- en: '![Image](../images/pg469_Image_318.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg469_Image_318.jpg)'
- en: '*Figure 20-1: The relationship between virtual memory and physical memory*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 20-1：虚拟内存和物理内存之间的关系*'
- en: The SoC used on a Raspberry Pi includes a *memory management unit (MMU)*. When
    the CPU needs to access an item in memory, it uses the virtual address of the
    item. The MMU uses the virtual address as an index into the page table to locate
    the page in physical memory and, from there, the item. If the requested page is
    not currently loaded into physical memory, the MMU generates a *page fault exception*,
    which calls a function in the operating system to load the page into physical
    memory and enter its location in the page table. (You’ll learn about exceptions
    in [Chapter 21](ch21.xhtml).)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi上使用的SoC包括一个*内存管理单元（MMU）*。当CPU需要访问内存中的某个项时，它使用该项的虚拟地址。MMU将虚拟地址作为索引，查找页表中对应的页面，并从中定位到该项。如果请求的页面当前未加载到物理内存中，MMU会生成一个*页故障异常*，触发操作系统中的一个函数，将该页面加载到物理内存中，并在页表中记录其位置。（你将在[第21章](ch21.xhtml)中学习关于异常的内容。）
- en: 'The page table is stored in main memory, so using it requires two memory accesses:
    one to retrieve the frame number from the page table and another to access the
    location in main memory. To speed things up, the MMU includes a *translation lookaside
    buffer (TLB)* in its hardware. The TLB is a small amount of fast memory that contains
    the most recently used entries from the page table. Like the memory cache you
    learned about in [Chapter 8](ch08.xhtml), the TLB uses the tendency of a program
    to reference nearby memory addresses over a short period of time to speed up memory
    accesses. The MMU first looks in the TLB. If the page table entry is there, then
    only one access of main memory is required.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 页表存储在主内存中，因此使用它需要两次内存访问：一次是从页表中检索框架号，另一次是访问主内存中的位置。为了加速这一过程，MMU在硬件中包含了*转换后备缓冲区（TLB）*。TLB是一小部分快速内存，包含了页表中最近使用的条目。就像你在[第8章](ch08.xhtml)中学到的内存缓存一样，TLB利用程序在短时间内访问邻近内存地址的趋势来加速内存访问。MMU首先查看TLB。如果页表项在其中，那么只需要一次访问主内存。
- en: Similar to how virtual memory is mapped to physical memory, virtual memory addresses
    can be mapped to the I/O device controller register address space. Having the
    controller registers associated with virtual memory addresses allows us to use
    the CPU instructions that access memory to access the I/O device controller registers.
    One advantage of memory-mapped I/O is that you can usually write the I/O functions
    in a higher-level language such as C without using inline assembly language.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚拟内存映射到物理内存的方式类似，虚拟内存地址也可以映射到I/O设备控制器寄存器地址空间。将控制器寄存器与虚拟内存地址关联，使得我们可以使用访问内存的CPU指令来访问I/O设备控制器寄存器。内存映射I/O的一个优点是，通常可以在不使用内联汇编语言的情况下，用更高级的语言如C语言编写I/O函数。
- en: '**I/O Programming**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**I/O编程**'
- en: Depending on the amount of data they process and the speed with which they process
    it, I/O devices use different techniques for communicating with the CPU. These
    differences are reflected in the way a device controller is programmed to perform
    its functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们处理的数据量以及处理数据的速度，I/O设备使用不同的技术与CPU进行通信。这些差异反映在设备控制器编程的方式上，用以执行其功能。
- en: When timing is not important, we can simply use instructions to send a data
    item to an output device or read a data item from an input device at the point
    in our program where we wish to output or input it. This works for I/O devices
    that don’t need time to process the binary data being transferred. You’ll see
    an example of this technique later in this chapter, when we program an I/O device
    to output one of two voltage levels on a single output pin.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当时序不重要时，我们可以简单地使用指令将数据项发送到输出设备，或者在程序中希望输出或输入数据的位置从输入设备读取数据项。这种方式适用于那些不需要时间来处理传输的二进制数据的I/O设备。稍后在本章中，你将看到一个使用这种技术的例子，我们将编程一个I/O设备，使其在一个输出引脚上输出两个电压水平之一。
- en: Most I/O device controllers require significant time to process input and output
    data. For example, when we press a key on the keyboard, the keyboard device controller
    needs to detect which key was pressed and then convert that knowledge into an
    8-bit pattern that represents the character we pressed. If our program needs that
    character, we have to first check the status register of the keyboard device controller
    to determine if it has completed this process. If the device controller is in
    a ready state, then we can read data from the device controller.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 I/O 设备控制器需要相当长的时间来处理输入和输出数据。例如，当我们按下键盘上的某个键时，键盘设备控制器需要检测按下了哪个键，然后将这一信息转换为一个
    8 位模式，表示我们按下的字符。如果我们的程序需要这个字符，我们必须首先检查键盘设备控制器的状态寄存器，以确定它是否已经完成了这个过程。如果设备控制器处于就绪状态，我们就可以从设备控制器读取数据。
- en: We do this in our program using a *polling* algorithm. Polling typically involves
    a loop that iterates, checking the device’s status register in each iteration
    of the loop, until the device is in a ready state. When the device controller
    is ready, we load the data into a general-purpose CPU register. When programmed
    I/O uses a polling algorithm, it’s often called *polled I/O*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序中使用*轮询*算法来实现这一点。轮询通常包括一个循环，在每次循环迭代中检查设备的状态寄存器，直到设备处于就绪状态。当设备控制器准备好时，我们将数据加载到一个通用
    CPU 寄存器中。当程序化 I/O 使用轮询算法时，通常称为*轮询 I/O*。
- en: Similarly, an output device controller might be busy outputting a previous data
    item. Our program needs to poll the device controller and wait until it’s ready
    to accept new output data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，输出设备控制器可能正在忙于输出前一个数据项。我们的程序需要轮询设备控制器，直到它准备好接受新的输出数据。
- en: The downside of polled I/O is that the CPU can be tied up for a long time waiting
    for the device to become ready. This would probably be acceptable if the CPU were
    dedicated to running only one program on the system (for example, controlling
    a microwave oven), but it’s not acceptable in the multiprogram environments of
    modern computing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询 I/O 的缺点是 CPU 可能需要长时间等待设备准备好。这种情况如果 CPU 专门运行一个系统中的程序（例如控制微波炉），可能是可以接受的，但在现代计算的多任务环境中则不可接受。
- en: 'We could get more work out of the CPU if we could tell an I/O device to let
    us know when it was ready for data input or output and use the CPU for something
    else in the meantime. Many I/O devices include an *interrupt controller* for just
    this purpose: it can send an interrupt signal to the CPU when the device has completed
    an operation or is ready to take on another operation.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能告诉 I/O 设备在准备好进行数据输入或输出时通知我们，并在此期间将 CPU 用于其他任务，我们就能让 CPU 做更多的工作。许多 I/O 设备包括一个*中断控制器*，就是为了这个目的：当设备完成操作或准备好进行另一个操作时，它可以向
    CPU 发送一个中断信号。
- en: An interrupt from an external device causes the CPU to call an *interrupt handler*,
    a function within the operating system that deals with the input or output from
    the interrupting device. This is usually called *interrupt-driven I/O*. I’ll discuss
    the features of a CPU that allow it to call interrupt handlers in [Chapter 21](ch21.xhtml).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 来自外部设备的中断会导致 CPU 调用*中断处理程序*，即操作系统中处理来自中断设备的输入或输出的函数。这通常被称为*中断驱动 I/O*。我将在[第 21
    章](ch21.xhtml)讨论允许 CPU 调用中断处理程序的特性。
- en: In all of these techniques, the CPU initiates the transfer of data to or from
    the I/O device controller. We call this *programmed I/O*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些技术中，CPU 都是发起数据传输到 I/O 设备控制器或从 I/O 设备控制器传输数据的。我们称之为*程序化 I/O*。
- en: I/O devices that transfer large amounts of data at high speed often have the
    capability of *direct memory access (DMA)*. They have a *DMA controller* that
    can access main memory directly without the CPU. For example, when reading from
    a disk, the DMA controller accepts a memory address and a command to read data
    from the disk. When the DMA controller has read the data from the disk into its
    own buffer memory, it writes that data directly to main memory. When the DMA data
    transfer has completed, the controller sends an interrupt to the CPU, thus invoking
    the disk interrupt handler that notifies the operating system that the data is
    now available in memory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 进行高速大数据传输的 I/O 设备通常具备*直接内存访问（DMA）*的能力。它们有一个*DMA 控制器*，可以直接访问主内存而不需要 CPU。例如，在从磁盘读取数据时，DMA
    控制器接受一个内存地址和一个读取磁盘数据的命令。当 DMA 控制器将数据从磁盘读取到其自身的缓冲区内存时，它会将数据直接写入主内存。当 DMA 数据传输完成时，控制器向
    CPU 发送一个中断，从而调用磁盘中断处理程序，通知操作系统数据已经在内存中可用。
- en: 'Next, we’ll look at an output that doesn’t even need to be polled: a single
    pin that we can place at one of two voltages.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一个不需要轮询的输出：一个可以放置为两个电压之一的单个引脚。
- en: '**Programming a General-Purpose I/O Device**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程通用 I/O 设备**'
- en: A *general-purpose I/O (GPIO)* is a signal line that can be configured to either
    input or output 1 bit. They were originally implemented in groups on an integrated
    circuit chip, with each I/O line of the GPIO circuitry connected to a pin on the
    chip. These days, GPIO circuits are typically included in SoC designs, where they
    can be used for lighting an LED, reading a switch, and so forth.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用输入输出（GPIO）* 是一种信号线，可以配置为输入或输出 1 位数据。它们最初是在集成电路芯片上按组实现的，每条 GPIO 电路的 I/O 线路都连接到芯片上的一个引脚。如今，GPIO
    电路通常包含在 SoC 设计中，可以用于点亮 LED、读取开关等。'
- en: All Raspberry Pi models include GPIOs arranged in groups, still called chips.
    One of the chips has 28 lines that are connected to pins on a 40-pin *GPIO header*
    located on the top edge of the Raspberry Pi board that we can use to control external
    I/O devices. (The original Raspberry Pi 1 has a 26-pin GPIO header connected to
    17 GPIO lines.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Raspberry Pi 型号都包括以组方式排列的 GPIO，仍然称为芯片。一个芯片有 28 条线路，连接到位于 Raspberry Pi 主板顶部边缘的
    40 引脚的*GPIO 排针*，我们可以使用这些引脚来控制外部 I/O 设备。（原始的 Raspberry Pi 1 配备有一个 26 引脚的 GPIO 排针，连接到
    17 条 GPIO 线路。）
- en: In this section, I’ll show you how to program a GPIO line to output a single
    bit that causes its corresponding GPIO header pin to alternate between 0.0 V and
    +3.3 V. We don’t need to poll the GPIO line to see if it’s ready for this 1-bit
    output, because it’s always ready. We’ll use these voltage alternations to blink
    an LED.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你展示如何编程一个 GPIO 线路，输出一个单一的比特，使其对应的 GPIO 排针引脚在 0.0 V 和 +3.3 V 之间交替。我们不需要轮询
    GPIO 线路来查看它是否准备好进行这个 1 位输出，因为它总是准备好的。我们将利用这些电压交替来闪烁一个 LED。
- en: The correspondences between the 28 GPIO lines and the GPIO header pins for a
    40-pin header are shown in [Table 20-1](ch20.xhtml#ch20tab1).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 28 条 GPIO 线路与 40 引脚排针的对应关系显示在 [表 20-1](ch20.xhtml#ch20tab1) 中。
- en: '**Table 20-1:** Correspondences Between GPIO Lines and Raspberry Pi Header
    Pins'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 20-1：** GPIO 线路与 Raspberry Pi 排针引脚的对应关系'
- en: '| Signal | Header | pins | Signal |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 信号 | 排针 | 引脚 | 信号 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| +3.3 V power | 1 | 2 | +5 V power |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| +3.3 V 电源 | 1 | 2 | +5 V 电源 |'
- en: '| GPIO2 | 3 | 4 | +5 V power |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| GPIO2 | 3 | 4 | +5 V 电源 |'
- en: '| GPIO3 | 5 | 6 | Ground |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| GPIO3 | 5 | 6 | 地线 |'
- en: '| GPIO4 | 7 | 8 | GPIO14 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| GPIO4 | 7 | 8 | GPIO14 |'
- en: '| Ground | 9 | 10 | GPIO15 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 地线 | 9 | 10 | GPIO15 |'
- en: '| GPIO17 | 11 | 12 | GPIO18 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| GPIO17 | 11 | 12 | GPIO18 |'
- en: '| GPIO27 | 13 | 14 | Ground |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| GPIO27 | 13 | 14 | 地线 |'
- en: '| GPIO22 | 15 | 16 | GPIO23 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| GPIO22 | 15 | 16 | GPIO23 |'
- en: '| +3.3 V power | 17 | 18 | GPIO24 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| +3.3 V 电源 | 17 | 18 | GPIO24 |'
- en: '| GPIO10 | 19 | 20 | Ground |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| GPIO10 | 19 | 20 | 地线 |'
- en: '| GPIO9 | 21 | 22 | GPIO25 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| GPIO9 | 21 | 22 | GPIO25 |'
- en: '| GPIO11 | 23 | 24 | GPIO8 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| GPIO11 | 23 | 24 | GPIO8 |'
- en: '| Ground | 25 | 26 | GPIO7 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 地线 | 25 | 26 | GPIO7 |'
- en: '| GPIO0 | 27 | 28 | GPIO1 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| GPIO0 | 27 | 28 | GPIO1 |'
- en: '| GPIO5 | 29 | 30 | Ground |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| GPIO5 | 29 | 30 | 地线 |'
- en: '| GPIO6 | 31 | 32 | GPIO12 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| GPIO6 | 31 | 32 | GPIO12 |'
- en: '| GPIO13 | 33 | 34 | Ground |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| GPIO13 | 33 | 34 | 地线 |'
- en: '| GPIO19 | 35 | 36 | GPIO16 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| GPIO19 | 35 | 36 | GPIO16 |'
- en: '| GPIO26 | 37 | 38 | GPIO20 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| GPIO26 | 37 | 38 | GPIO20 |'
- en: '| Ground | 39 | 40 | GPIO21 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 地线 | 39 | 40 | GPIO21 |'
- en: The pin numbering of the GPIO header assumes we are looking down at the top
    of the Raspberry Pi, with the header on the right. There are two rows of header
    pins, with the odd-numbered pins on the left and the even-numbered pins on the
    right. Notice that the GPIO lines are not in the same numerical order as the GPIO
    header pins.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO 排针的引脚编号假设我们正在向下看 Raspberry Pi 的顶部，排针位于右侧。排针有两排，引脚编号为奇数的在左侧，偶数的在右侧。注意，GPIO
    线路的编号与 GPIO 排针的引脚编号并不完全一致。
- en: You can also see this information online at *[https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header](https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header)*,
    and on the Raspberry Pi the `pinout` command will give you the pin correspondence
    information.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在网上查看此信息，访问 *[https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header](https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header)*，而在
    Raspberry Pi 上使用 `pinout` 命令会显示引脚对应信息。
- en: Much of the Raspberry Pi documentation calls the signal from the GPIO device
    a GPIO pin. To avoid confusion, I’ll use the names *GPIO line* for the signals
    and *GPIO header pin* for the physical connectors on the GPIO header. As you’ll
    see later in this chapter, this naming convention is consistent with the `gpiod`
    library, which we’ll use for programming the GPIO lines in C. We’ll start by connecting
    our hardware circuit for blinking an LED.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 很多 Raspberry Pi 文档将 GPIO 设备的信号称为 GPIO 引脚。为了避免混淆，我将使用*GPIO 线路*来表示信号，使用*GPIO 头引脚*来表示
    GPIO 头上的物理连接器。正如你稍后在本章中看到的，这种命名约定与我们将用于编程 GPIO 线路的 `gpiod` 库一致。我们将从连接用于闪烁 LED
    的硬件电路开始。
- en: '#### ***Connecting the Blinking LED Circuit***'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***连接闪烁 LED 电路***'
- en: To follow along with this project, you’ll need an LED, a 220 Ω resistor, and
    several connecting jumper wires. Building the circuit on a breadboard is easier
    than just putting the components on a desktop or a workbench.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随这个项目，你需要一个 LED，一个 220 Ω 的电阻，以及几根连接跳线。将电路搭建在面包板上比直接将元件放在桌面或工作台上要简单得多。
- en: Before you connect anything to the GPIO header pins on your Raspberry Pi, you
    should shut it down and turn off the power. The pins are close together, and it’s
    easy to accidentally short two of them together, which may damage your Raspberry
    Pi.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在将任何东西连接到 Raspberry Pi 的 GPIO 引脚之前，你应该先关闭设备并切断电源。这些引脚彼此靠得很近，容易不小心将两个引脚短接在一起，这可能会损坏你的
    Raspberry Pi。
- en: We’ll use the circuit shown in [Figure 20-2](ch20.xhtml#ch20fig2).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[图 20-2](ch20.xhtml#ch20fig2)中显示的电路。
- en: '![Image](../images/pg473_Image_319.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg473_Image_319.jpg)'
- en: '*Figure 20-2: The circuit for a blinking LED*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 20-2：闪烁 LED 的电路*'
- en: You saw the circuit symbol for a resistor in [Figure 5-3](ch05.xhtml#ch5fig3)
    in [Chapter 5](ch05.xhtml). The triangle with two arrows above it is the circuit
    symbol for an LED, and the triangular-shaped group of three horizontal lines is
    the symbol for ground (0.0 V). Using the information in [Table 20-1](ch20.xhtml#ch20tab1),
    we’ll connect to GPIO17 using pin 11 on the GPIO header and connect to ground
    using header pin 9.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第 5 章](ch05.xhtml)的[图 5-3](ch05.xhtml#ch5fig3)中看到了电阻的电路符号。上面有两个箭头的三角形是 LED
    的电路符号，三个水平线组成的三角形是地（0.0 V）的符号。根据[表 20-1](ch20.xhtml#ch20tab1)中的信息，我们将通过 GPIO 头的引脚
    11 连接到 GPIO17，并通过引脚 9 连接到地。
- en: Make sure you connect the LED correctly. The left-hand side of the LED in this
    figure is the *anode* and the right-hand side is the *cathode*. The manufacturer
    of your LED should provide documentation showing which lead is which on the LED.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 确保正确连接 LED。图中 LED 的左侧是*阳极*，右侧是*阴极*。LED 的制造商应该提供文档，说明每个引脚的作用。
- en: We’ll write a program that alternates the voltage on the GPIO17 pin between
    +3.3 V and 0.0 V. At +3.3 V, current flows through the resistor and LED, causing
    the LED to turn on. The 220 Ω resistor is necessary to limit the amount of current
    flowing through it, as excessive current could destroy the LED. When our program
    switches the GPIO17 pin to 0.0 V, current no longer flows through the LED, turning
    it off.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个程序，使 GPIO17 引脚的电压在 +3.3 V 和 0.0 V 之间交替。在 +3.3 V 时，电流通过电阻和 LED，导致 LED
    点亮。220 Ω 的电阻是必须的，它能限制流过的电流量，因为过多的电流可能会损坏 LED。当我们的程序将 GPIO17 引脚切换到 0.0 V 时，电流不再流过
    LED，LED 熄灭。
- en: Let’s start with a C program to make sure our circuit is connected correctly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先写一个 C 程序，确保电路连接正确。
- en: '***Blinking an LED in C, All Models***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用 C 语言让 LED 闪烁，适用于所有型号***'
- en: Raspberry Pi OS comes with two libraries of functions that allow us to work
    with the GPIO in high-level languages. The `pigpio` library provides C and Python
    functions, and `gpiozero` provides a simple Python programming interface. You
    can read about them at *[https://abyz.me.uk/rpi/pigpio/](https://abyz.me.uk/rpi/pigpio/)*
    and *[https://gpiozero.readthedocs.io/en/stable/](https://gpiozero.readthedocs.io/en/stable/)*,
    respectively.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi OS 提供了两个函数库，允许我们在高级语言中操作 GPIO。`pigpio` 库提供了 C 和 Python 函数，而 `gpiozero`
    提供了一个简单的 Python 编程接口。你可以分别在*[https://abyz.me.uk/rpi/pigpio/](https://abyz.me.uk/rpi/pigpio/)*和*[https://gpiozero.readthedocs.io/en/stable/](https://gpiozero.readthedocs.io/en/stable/)*中了解它们。
- en: 'As of this writing, the `pigpio` library does not work on the Raspberry Pi
    5\. I installed the `gpiod` package, which includes some useful command line tools
    for working with the GPIO. It also installs the `libgpiod` library, which is the
    officially supported interface to the GPIO. I have tested this library with C
    and Python programs on both my Raspberry Pi 3 and my Raspberry Pi 5\. I installed
    the command line and development tools with the following three commands:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，`pigpio` 库在树莓派 5 型上无法使用。我安装了 `gpiod` 包，其中包括一些用于操作 GPIO 的有用命令行工具。它还安装了 `libgpiod`
    库，这是官方支持的 GPIO 接口。我已经在我的树莓派 3 型和树莓派 5 型上用 C 和 Python 程序测试了这个库。我使用以下三个命令安装了命令行和开发工具：
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**NOTE**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*At the time of writing, this installs version 1.6.3 of the library and tools.
    The developers have released version 2.1.1, but it’s not yet in the Raspberry
    Pi OS repository. When the repository is updated, I expect additional utilities
    to be added, and some of the function names in the library may change. The source
    code for all versions is available at* [https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git](https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*在写作时，这将安装库和工具的 1.6.3 版本。开发者已经发布了 2.1.1 版本，但它还未出现在树莓派操作系统的仓库中。当仓库更新时，我预计将添加额外的实用工具，并且库中的某些函数名称可能会发生变化。所有版本的源代码可在*
    [https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git](https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git)
    *找到。*'
- en: 'The `gpiod` package installs six utility programs for working with the GPIO
    device: `gpiodetect`, `gpiofind`, `gpioget`, `gpioinfo`, `gpiomon`, and `gpioset`.
    The `libgpiod-doc` package installs the man pages for each of these utilities,
    and the `libgpiod-dev` package installs the interface to the functions in the
    `libgpiod` library we’ll use to program the GPIO in C.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpiod` 包安装了六个用于操作 GPIO 设备的实用程序：`gpiodetect`、`gpiofind`、`gpioget`、`gpioinfo`、`gpiomon`
    和 `gpioset`。`libgpiod-doc` 包安装了这些实用工具的手册页面，而 `libgpiod-dev` 包安装了我们将在 C 程序中使用的
    `libgpiod` 库的接口。'
- en: Other useful tools included with Raspberry Pi OS are `pinout` and `pinctrl`.
    The `pinout` program has a man page that describes its use. The `pinctrl help`
    command shows how to use `pinctrl`. I used `pinctrl` to help debug the programs
    to blink an LED that you’ll see here.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派操作系统还包含了其他有用的工具，如 `pinout` 和 `pinctrl`。`pinout` 程序有一个手册页面，描述了它的使用方法。`pinctrl
    help` 命令展示了如何使用 `pinctrl`。我使用 `pinctrl` 来调试用于闪烁 LED 的程序，你将在这里看到它们。
- en: We will use functions from the `libgpiod` library to write a program in C, which
    is shown in [Listing 20-1](ch20.xhtml#ch20list1), to blink an LED for testing
    the circuit in [Figure 20-2](ch20.xhtml#ch20fig2). The documentation for our version
    of the library can be found at *[https://www.lane-fu.com/linuxmirror/libgpiod/doc/html/index.html](https://www.lane-fu.com/linuxmirror/libgpiod/doc/html/index.html)*.
    If you prefer to use Python, see “Your Turn” [exercise 20.2](ch20.xhtml#ch20exe2)
    on [page 460](ch20.xhtml#ch20you1).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `libgpiod` 库中的函数编写一个 C 程序，该程序展示在 [Listing 20-1](ch20.xhtml#ch20list1)
    中，用于测试电路 [Figure 20-2](ch20.xhtml#ch20fig2) 中的 LED 闪烁。我们版本的库文档可以在 *[https://www.lane-fu.com/linuxmirror/libgpiod/doc/html/index.html](https://www.lane-fu.com/linuxmirror/libgpiod/doc/html/index.html)*
    找到。如果你更喜欢使用 Python，请参阅“你的回合” [练习 20.2](ch20.xhtml#ch20exe2)，它位于 [第 460 页](ch20.xhtml#ch20you1)。
- en: '*blink_led.c*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*blink_led.c*'
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 20-1: A C program to blink an LED using the GPIO*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 20-1: 使用 GPIO 闪烁 LED 的 C 程序*'
- en: 'When compiling this file, we need to explicitly specify the `libgpiod` library
    at the end of the command, as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译这个文件时，我们需要在命令的末尾显式指定 `libgpiod` 库，如下所示：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Both `struct gpiod_chip` and `struct gpiod_line` are declared in the *gpiod.h*
    header file ❶ as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct gpiod_chip` 和 `struct gpiod_line` 都在 *gpiod.h* 头文件 ❶ 中声明，如下所示：'
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This C syntax is a way to define the `chip` and `line` pointer variables as
    holding addresses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 C 语法是一种定义 `chip` 和 `line` 指针变量为存储地址的方式。
- en: The Raspberry Pi has several GPIO chips. GPIO chip 0 is connected to the GPIO
    header pins on models 3 and 4; GPIO chip 4 is connected to the GPIO header pins
    on the Raspberry Pi 5, so you if you’re using that model you’ll need to change
    `gpiochip0` to `gpiochip4` ❷.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派有多个 GPIO 芯片。GPIO 芯片 0 连接到 3 型和 4 型模型的 GPIO 头引脚；GPIO 芯片 4 连接到树莓派 5 型的 GPIO
    头引脚，所以如果你使用的是该模型，需要将 `gpiochip0` 改为 `gpiochip4` ❷。
- en: Once the GPIO line is configured to be an output, we turn the bit on and off
    to blink the LED ❸.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 GPIO 行被配置为输出，我们就可以开关该位以闪烁 LED ❸。
- en: Next, let’s look at how we can use assembly language to blink the LED.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用汇编语言来闪烁 LED。
- en: '**NOTE**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The assembly language code we’ll be using is not robust. It’s intended to
    provide an overview of how I/O devices are programmed. If you want to use the
    GPIO to control external devices, I recommend using the functions in the* libgpiod
    *library. It’s integrated with the operating system to provide robust functioning
    of the GPIO.*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将使用的汇编语言代码并不完善。它旨在提供一个关于如何编程 I/O 设备的概述。如果你想使用 GPIO 控制外部设备，我建议使用* libgpiod
    *库中的函数。它与操作系统集成，提供 GPIO 的稳健功能。*'
- en: '***Blinking an LED in Assembly Language, Models 3 and 4***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用汇编语言闪烁 LED，适用于 3 型板和 4 型板***'
- en: The function of each GPIO device line is selected through six 32-bit registers,
    named GPFSEL0 through GPFSEL5\. Three bits are used to select the function of
    a GPIO device line. Registers GPFSEL0 through GPFSEL4 each select the function
    of 10 lines, with 2 unused bits. The GPFSEL5 register on model 3 selects the functions
    of 4 lines, leaving 20 unused bits, and on model 4 the GPFSEL5 register selects
    the functions of 8 lines, leaving 8 unused bits.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 GPIO 设备线路的功能是通过六个 32 位寄存器来选择的，这些寄存器命名为 GPFSEL0 到 GPFSEL5。三个位用于选择 GPIO 设备线路的功能。寄存器
    GPFSEL0 到 GPFSEL4 每个选择 10 条线路的功能，剩下 2 个未使用的位。对于 3 型板，GPFSEL5 寄存器选择 4 条线路的功能，留下
    20 个未使用的位；而在 4 型板上，GPFSEL5 寄存器选择 8 条线路的功能，留下 8 个未使用的位。
- en: I recommend downloading the datasheet for your Raspberry Pi—the Broadcom BCM2835
    SoC datasheet at *[https://datasheets.raspberrypi.com/bcm2835/bcm2835-peripherals.pdf](https://datasheets.raspberrypi.com/bcm2835/bcm2835-peripherals.pdf)*
    for the model 3 or the Broadcom BCM-2711 SoC datasheet at *[https://datasheets.raspberrypi.com/bcm2711/bcm2711-peripherals.pdf](https://datasheets.raspberrypi.com/bcm2711/bcm2711-peripherals.pdf)*
    for the model 4—for reference while reading this section. It’s not easy to read
    the datasheets, but going back and forth between the explanation here and the
    datasheet for your model should help you learn how to read it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议下载你的 Raspberry Pi 数据手册——对于 3 型板，请参考 Broadcom BCM2835 SoC 数据手册，地址为* [https://datasheets.raspberrypi.com/bcm2835/bcm2835-peripherals.pdf](https://datasheets.raspberrypi.com/bcm2835/bcm2835-peripherals.pdf)
    *，而对于 4 型板，请参考 Broadcom BCM-2711 SoC 数据手册，地址为* [https://datasheets.raspberrypi.com/bcm2711/bcm2711-peripherals.pdf](https://datasheets.raspberrypi.com/bcm2711/bcm2711-peripherals.pdf)
    *，以便在阅读本节时作为参考。阅读数据手册并不容易，但在此处的解释与适用型号的数据手册之间来回查阅，应该有助于你学会如何阅读它。
- en: Note that I only tested this program on my Raspberry Pi 3\. The datasheet for
    the Raspberry Pi 4 shows that the GPIO registers are the same as on the model
    3, so this code should also work on a model 4.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我只在我的 Raspberry Pi 3 上测试了此程序。Raspberry Pi 4 的数据手册显示 GPIO 寄存器与 3 型板相同，因此此代码也应该适用于
    4 型板。
- en: '[Listing 20-2](ch20.xhtml#ch20list2) shows our assembly language program to
    blink an LED.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 20-2](ch20.xhtml#ch20list2) 显示了我们的汇编语言程序来闪烁 LED。'
- en: '*blink_led.s*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*blink_led.s*'
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 20-2: An assembly language program to blink an LED using the GPIO*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 20-2：一个使用 GPIO 闪烁 LED 的汇编语言程序*'
- en: 'The C program in [Listing 20-1](ch20.xhtml#ch20list1) uses library functions
    provided by the operating system to control the GPIO line. Our assembly language
    program in [Listing 20-2](ch20.xhtml#ch20list2) accesses the GPIO registers directly.
    The operating system only allows a user with root privileges to do that, so we
    need to run the program with `sudo`, like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 20-1](ch20.xhtml#ch20list1) 中的 C 程序使用了操作系统提供的库函数来控制 GPIO 线路。我们在 [清单 20-2](ch20.xhtml#ch20list2)
    中的汇编语言程序直接访问 GPIO 寄存器。操作系统仅允许拥有 root 权限的用户执行此操作，因此我们需要使用 `sudo` 来运行该程序，如下所示：'
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Linux treats I/O devices as files. They are listed by name in the */dev* directory.
    The */dev/mem* file is an image of main memory. Addresses in this file represent
    physical memory addresses. Opening the file with the `open` system call function
    gives us access to the I/O device’s physical memory ❹. Its man page gives us the
    prototype for the `open` function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 将 I/O 设备视为文件。它们按名称列出在 */dev* 目录中。*/dev/mem* 文件是主内存的映像。该文件中的地址表示物理内存地址。使用
    `open` 系统调用函数打开文件将允许我们访问 I/O 设备的物理内存 ❹。它的手册页为我们提供了 `open` 函数的原型：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The pathname is the full path and name of the file or device to be opened. The
    man page lists the names of the flags that must be passed to the `open` function
    to specify how it can be accessed by the calling function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 路径名是要打开的文件或设备的完整路径和名称。手册页列出了必须传递给 `open` 函数的标志名称，以指定调用函数如何访问它。
- en: The numerical value of each flag can be found in the header file at */usr/include/asm-generic/fcntl.h*.
    The header file is written in C, so we can’t use the `.include` directive to add
    it into our assembly language source code. I’ve used the `.equ` directive to define
    the flags we need in the `open` function. The assembler supports arithmetic and
    logic operations on literal values. We use the OR operator (`|`) to combine the
    different flags we need into a single 32-bit integer for the flags argument ❸.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标志的数值可以在头文件*/usr/include/asm-generic/fcntl.h*中找到。头文件是用C语言编写的，因此我们不能使用`.include`指令将其添加到我们的汇编语言源代码中。我使用了`.equ`指令来定义`open`函数中所需的标志。汇编器支持对文字值进行算术和逻辑运算。我们使用OR运算符（`|`）将所需的不同标志组合成一个单一的32位整数，作为flags参数❸。
- en: The operating system prevents application programs from directly accessing the
    I/O memory address space. We need to tell the operating system to map the GPIO
    memory address space into the application memory address space so we can access
    the GPIO registers in our application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统阻止应用程序直接访问I/O内存地址空间。我们需要告诉操作系统将GPIO内存地址空间映射到应用程序内存地址空间，这样我们就可以在应用程序中访问GPIO寄存器。
- en: The I/O peripheral address space begins at different places, depending on the
    Raspberry Pi model. The GNU assembler has directives that allow us to select which
    lines of code to include in the assembly. We use the `.if` directive together
    with a series of `.elseif` directives to select the value of `PERIPHS` according
    to the model we’re using ❷. Using a `.if` directive with a `.else` directive selects
    the correct offset of the GPIO registers from the beginning address of the I/O
    peripherals. A single `.equ` directive sets `RPI_MODEL` to control these *conditional
    assembly* directives ❶. Don’t forget to end each `.if` construct with a `.endif`
    directive.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: I/O外设地址空间的起始位置取决于Raspberry Pi型号。GNU汇编器有一些指令，可以让我们选择要在汇编中包含哪些代码行。我们使用`.if`指令以及一系列`.elseif`指令，根据我们使用的型号选择`PERIPHS`的值❷。使用`.if`指令和`.else`指令可以选择GPIO寄存器相对于I/O外设起始地址的正确偏移量。一个单独的`.equ`指令设置`RPI_MODEL`，以控制这些*条件汇编*指令❶。不要忘记在每个`.if`构造后用`.endif`指令结束。
- en: 'We use the `mmap` system call function, specified in the POSIX standard, to
    map the GPIO registers into application memory ❺. Its man page gives us the prototype
    for the function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用POSIX标准中指定的`mmap`系统调用函数，将GPIO寄存器映射到应用程序内存中❺。它的手册页为该函数提供了原型：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If addr is `0`, the operating system chooses the application memory address
    for the mapping. The length is the number of bytes we’ll need for all the registers
    on the device. The mapping will use an integral number of pages. I’ve chosen 4MB
    to ensure we include all the I/O registers used for programming the GPIO in all
    the Raspberry Pi models.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`addr`是`0`，操作系统将为映射选择应用程序的内存地址。长度是我们需要的字节数，用于设备上的所有寄存器。该映射将使用整页的数量。我选择了4MB，以确保我们包含所有用于编程GPIO的I/O寄存器，适用于所有Raspberry
    Pi型号。
- en: The man page for `mmap` lists the prot values that must be passed to the function
    to specify how it can be accessed by the calling function. The man page also lists
    values for the flags, which specify how access is treated by the operating system.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmap`的手册页列出了必须传递给函数的prot值，用于指定调用函数如何访问它。手册页还列出了flags的值，指定操作系统如何处理访问。'
- en: The numerical value of each prot and flag can be found in the header file */usr/include/asm-generic/mman-common.h*.
    The header file is also written in C, so I have used `.equ` directives to define
    the prot and flags we need in this function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个prot和flag的数值可以在头文件*/usr/include/asm-generic/mman-common.h*中找到。头文件也是用C语言编写的，因此我使用了`.equ`指令来定义该函数中所需的prot和flags。
- en: After calling the `open` and `mmap` functions to make the GPIO registers accessible
    through application memory, we use the `close` function to release the file descriptor.
    The GPIO registers remain accessible to our application program.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`open`和`mmap`函数以通过应用程序内存使GPIO寄存器可访问之后，我们使用`close`函数释放文件描述符。GPIO寄存器仍然对我们的应用程序可访问。
- en: Now that we can access the I/O registers on the GPIO through application memory
    addressing, we program our GPIO line to be an output. As you’ll see in the next
    section, the method for doing this is different for the Raspberry Pi 5 ❻. After
    setting up the GPIO as an output, we enter a loop where we alternately turn the
    LED on and off. Again, a different method is used for the Raspberry Pi 5 ❼ ❽.
    We leave the LED in its on or off state for a few seconds using the `sleep` function
    from the `unistd` library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过应用内存寻址访问 GPIO 上的 I/O 寄存器，我们将 GPIO 引脚配置为输出。如下一节所示，执行此操作的方法对于 Raspberry
    Pi 5 是不同的 ❻。设置 GPIO 为输出后，我们进入一个循环，其中交替打开和关闭 LED。对于 Raspberry Pi 5，使用的是不同的方法 ❼
    ❽。我们使用 `unistd` 库中的 `sleep` 函数将 LED 保持在开或关状态几秒钟。
- en: Although the program will release the application memory we used for the GPIO
    registers when it ends, it’s good practice to call the `munmap` function to release
    the memory in your program when it’s no longer needed ❾.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管程序在结束时会释放我们用于 GPIO 寄存器的应用内存，但在程序不再需要时调用 `munmap` 函数释放内存仍然是一个好习惯 ❾。
- en: Specifying a GPIO line as an output is done with the function shown in [Listing
    20-3](ch20.xhtml#ch20list3).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将 GPIO 引脚指定为输出可以使用 [Listing 20-3](ch20.xhtml#ch20list3) 中显示的函数。
- en: '*gpio_line_to_output.s*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*gpio_line_to_output.s*'
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 20-3: Making a GPIO line an output in most Raspberry Pi models*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 20-3: 在大多数 Raspberry Pi 型号中将 GPIO 引脚设置为输出*'
- en: The GPIO has six 32-bit function-select registers, GPFSEL0 through GPFSEL5\.
    Each of these registers is divided into 10 3-bit fields, named FSEL*n*, where
    *n* = 0, 1, . . . , 57\. Bits 2 through 0 in GPFSEL0 are the FSEL0 field, bits
    5 through 3 are the FSEL1 field, and so forth up to bits 23 through 21 in GPFSEL5
    for the FSEL57 field. Bits 31 and 30 in GPFSEL0 through GPFSEL4 and bits 31 through
    24 in GPFSEL5 are unused. All the lines can be configured as an input, `000`,
    or an output, `001`. Some lines can be configured to have other functionalities;
    FSEL*n* specifies the functionality of GPIO line *n*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO 有六个 32 位的功能选择寄存器，分别为 GPFSEL0 到 GPFSEL5。每个寄存器被划分为 10 个 3 位字段，命名为 FSEL*n*，其中
    *n* = 0、1、...、57。GPFSEL0 中的第 2 到第 0 位为 FSEL0 字段，第 5 到第 3 位为 FSEL1 字段，以此类推，直到 GPFSEL5
    中的第 23 到第 21 位为 FSEL57 字段。GPFSEL0 到 GPFSEL4 中的第 31 和第 30 位，以及 GPFSEL5 中的第 31 到第
    24 位未使用。所有引脚都可以配置为输入 `000`，或输出 `001`。某些引脚可以配置为其他功能；FSEL*n* 指定了 GPIO 引脚 *n* 的功能。
- en: Dividing the GPIO line number by 10 gives us the number of the GPFSEL register
    ❶. The remainder from this division gives us the number of the FSEL field in the
    register ❷. For example, our program uses GPIO line 17, and its function is controlled
    by the seventh FSEL field in the GPFSEL1 register.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将 GPIO 引脚编号除以 10 可以得到 GPFSEL 寄存器的编号 ❶。除法的余数给出了寄存器中 FSEL 字段的编号 ❷。例如，我们的程序使用 GPIO
    引脚 17，并且其功能由 GPFSEL1 寄存器中的第七个 FSEL 字段控制。
- en: The GPFSEL registers are located at the beginning of the GPIO memory, so multiplying
    the GPFSEL register number by 4 gives us the memory address offset of the register
    ❸. Each FSEL field is 3 bits, so we multiply the FSEL number by 3 to get the relative
    bit position in the GPFSEL register ❹.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: GPFSEL 寄存器位于 GPIO 内存的开始位置，因此将 GPFSEL 寄存器编号乘以 4 可以得到该寄存器的内存地址偏移量 ❸。每个 FSEL 字段为
    3 位，因此我们将 FSEL 编号乘以 3 来得到 GPFSEL 寄存器中的相对位位置 ❹。
- en: 'We need to make sure we don’t change any of the other FSEL fields in the GPFSEL
    register. After loading a copy of the GPFSEL register into a CPU register, we
    use a 3-bit mask to clear our FSEL field with the `bic` instruction ❺:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保不更改 GPFSEL 寄存器中的其他 FSEL 字段。在将 GPFSEL 寄存器的副本加载到 CPU 寄存器中后，我们使用一个 3 位掩码，通过
    `bic` 指令清除我们的 FSEL 字段 ❺：
- en: '`bic`—Bit clear'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`bic` — 位清除'
- en: '`bic w`d`, w`s1`, w`s2`{,`shft amnt`}` performs a bitwise AND between `w`s1
    and `w`s2, optionally shifted amnt bits before the AND, storing the result in
    `w`d. The shft can be `lsl`, `lsr`, `0` to `31`. The default is no shift.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`bic w`d`, w`s1`, w`s2`{,`shft amnt`}` 对 `w`s1` 和 `w`s2` 进行按位与运算，操作前可以选用偏移量
    amnt 位，结果存储在 `w`d 中。shft 可以是 `lsl`、`lsr`，偏移量范围是 `0` 到 `31`。默认情况下没有偏移。'
- en: '`bic x`d`, x`s1`, x`s2`{,`shft amnt`}` performs a bitwise AND between `x`s1
    and `x`s2, optionally shifted amnt bits before the AND, storing the result in
    `x`d. The shft can be `lsl`, `lsr`, `asr`, or `ror`. The amnt can be `0` to `63`.
    The default is no shift.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`bic x`d`, x`s1`, x`s2`{,`shft amnt`}` 对 `x`s1` 和 `x`s2` 进行按位与运算，操作前可以选用偏移量
    amnt 位，结果存储在 `x`d 中。shft 可以是 `lsl`、`lsr`、`asr` 或 `ror`。amnt 可以是 `0` 到 `63`。默认情况下没有偏移。'
- en: Next, we shift our function code to the FSEL field position in the GPFSEL register,
    use the `orr` instruction to insert the function code, and update the mapped GPIO
    memory ❻.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将功能代码移至GPFSEL寄存器中的FSEL字段位置，使用`orr`指令插入功能代码，并更新映射的GPIO内存❻。
- en: '**NOTE**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although we have mapped the GPIO registers into application memory addresses,
    we can’t directly examine the contents of these registers with* gdb *because it
    uses a different technique for accessing memory addresses than the* mmap *function.
    I’ll show you another way to examine the register contents in* gdb *in “Your Turn”
    [exercise 20.3](ch20.xhtml#ch20exe3) on [page 460](ch20.xhtml#ch20you1).*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然我们已将GPIO寄存器映射到应用程序内存地址中，但我们无法直接通过* gdb *检查这些寄存器的内容，因为它使用与*mmap*函数不同的技术来访问内存地址。在[第460页](ch20.xhtml#ch20you1)的“Your
    Turn”[练习 20.3](ch20.xhtml#ch20exe3)中，我会向你展示另一种在*gdb*中检查寄存器内容的方法。*'
- en: Now that we have set up the GPIO line as a 1-bit output device, we can control
    the voltage it outputs. The line is always ready for us to change the voltage,
    so we don’t need to check its status. We’ll use the `gpio_line_set` function in
    [Listing 20-4](ch20.xhtml#ch20list4) to set the line, which places it at +3.3
    V.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将GPIO线路设置为1位输出设备，可以控制它输出的电压。该线路始终准备好接受我们更改电压的操作，因此我们不需要检查其状态。我们将使用`gpio_line_set`函数在[示例
    20-4](ch20.xhtml#ch20list4)中设置该线路，将其设为+3.3 V。
- en: '*gpio_line_set.s*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*gpio_line_set.s*'
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 20-4: Setting a GPIO line in most Raspberry Pi models*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 20-4：在大多数树莓派模型中设置GPIO线路*'
- en: The GPIO has two 32-bit output-set registers, GPSET0 and GPSET1\. The GPSET0
    register is located `0x1c` bytes from the beginning of GPIO memory ❶. The GPSET1
    register immediately follows at `0x20`. Bits 31 through 0 in GPSET0 control lines
    31 through 0, and bits 21 through 0 in GPSET1 control lines 53 through 32\. The
    GPIO header pins are connected only to GPIO lines 27 through 0, so this function
    only works with GPSET0.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO有两个32位输出设置寄存器，GPSET0和GPSET1。GPSET0寄存器位于GPIO内存开始的`0x1c`字节处❶。紧接着是GPSET1寄存器，位于`0x20`。GPSET0中的31至0位控制31至0号线路，GPSET1中的21至0位控制53至32号线路。GPIO头针仅连接到27至0号GPIO线路，因此此功能仅适用于GPSET0。
- en: The GPSET registers are write-only. Unlike the GPFSEL registers, we don’t load
    the contents of a GPSET register; we simply shift a `1` to the bit position corresponding
    to the line we’re using as an output and set the line with a `str` instruction,
    placing +3.3 V on the line ❷. Writing a `0` to a bit position has no effect.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: GPSET寄存器是只写的。与GPFSEL寄存器不同，我们不会加载GPSET寄存器的内容；我们只需将`1`移至与我们用作输出的线路相对应的位位置，并通过`str`指令设置该线路，将+3.3
    V放置在线路上❷。将`0`写入位位置没有效果。
- en: When we want to change the output of the line to 0.0 V, we clear the line, as
    shown in [Listing 20-5](ch20.xhtml#ch20list5).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想将线路的输出更改为0.0 V时，我们会清除该线路，如[示例 20-5](ch20.xhtml#ch20list5)所示。
- en: '*gpio_line_clr.s*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*gpio_line_clr.s*'
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 20-5: Clearing a GPIO line in most Raspberry Pi models*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 20-5：在大多数树莓派模型中清除GPIO线路*'
- en: Like the set registers, the GPIO has two 32-bit output-clear registers, GPCLR0
    and GPCLR1\. GPCLR0 is located 12 bytes beyond GPSET0 ❶. They are programmed the
    same way as the GPSET registers, except that storing a `1` in a bit position corresponding
    to a line that is selected as an output clears the line, placing 0.0 V on the
    line.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与设置寄存器类似，GPIO还有两个32位输出清除寄存器，GPCLR0和GPCLR1。GPCLR0位于GPSET0之后12字节❶。它们的编程方式与GPSET寄存器相同，不同之处在于，将`1`存储到与所选输出线路对应的位位置会清除该线路，将线路置为0.0
    V。
- en: Next, we’ll look at blinking an LED on a Raspberry Pi 5, which uses a very different
    programming interface to the GPIO.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何在树莓派5上闪烁LED，它使用与GPIO的编程接口非常不同的方式。
- en: '***Blinking an LED in Assembly Language, Model 5***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在汇编语言中闪烁LED，树莓派5模型***'
- en: The `main` function in [Listing 20-2](ch20.xhtml#ch20list2) is designed to work
    for the Raspberry Pi 5 if you simply change the `RPI_MODEL` to `5`. The conditional
    assembly directives will then select the appropriate values and function calls.
    But the methods for controlling the GPIO are different. Let’s see how it’s done
    on the Raspberry Pi 5.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20-2](ch20.xhtml#ch20list2)中的`main`函数设计用于树莓派5，只需将`RPI_MODEL`更改为`5`。条件汇编指令将选择适当的值和函数调用。但控制GPIO的方法不同。让我们看看在树莓派5上是如何实现的。'
- en: The GPIO circuitry on the Raspberry Pi 5 is on the RP1 chip. The documentation
    is incomplete as of this writing, but a preliminary draft of *RP1 Peripherals*
    (November 2023) is available at *[https://datasheets.raspberrypi.com/rp1/rp1-peripherals.pdf](https://datasheets.raspberrypi.com/rp1/rp1-peripherals.pdf)*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 5 上的 GPIO 电路位于 RP1 芯片上。截止目前文档还不完整，但可以找到初步草案《RP1 外设》（2023 年 11 月）在
    *[https://datasheets.raspberrypi.com/rp1/rp1-peripherals.pdf](https://datasheets.raspberrypi.com/rp1/rp1-peripherals.pdf)*。
- en: Setting a GPIO line to be an output on a Raspberry Pi 5 is different from on
    the other models. [Listing 20-6](ch20.xhtml#ch20list6) shows our function to do
    this.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Raspberry Pi 5 上将 GPIO 引脚设置为输出与其他型号不同。 [列表 20-6](ch20.xhtml#ch20list6) 显示了我们执行此操作的函数。
- en: '*gpio_5_line _to_output.s*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*gpio_5_line_to_output.s*'
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 20-6: A function to make a GPIO line an output on the Raspberry Pi
    5*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 20-6：在 Raspberry Pi 5 上将 GPIO 引脚设置为输出的函数*'
- en: The Raspberry Pi 5 GPIO device has 28 pairs of registers, which are called GPIO0_STATUS,
    GPIO0_CTRL, GPIO1_STATUS, GPIO1_CTRL through GPIO27_STATUS, and GPIO27_CTRL. The
    address offset of the GPIO*n*_CTRL register corresponding to GPIO line *n* is
    8 × *n* ❶. Bits 4 through 0 set the function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 5 GPIO 设备有 28 对寄存器，分别称为 GPIO0_STATUS、GPIO0_CTRL、GPIO1_STATUS、GPIO1_CTRL
    直到 GPIO27_STATUS 和 GPIO27_CTRL。与 GPIO 引脚 *n* 对应的 GPIO*n*_CTRL 寄存器的地址偏移量为 8 × *n*
    ❶。位 4 到 0 设置功能。
- en: RP1 provides a set of *registered I/O (RIO)* registers to control the GPIO lines.
    To use the RIO interface, we store the `SYS_RIO` function in the GPIO control
    register ❷.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: RP1 提供了一组*注册 I/O (RIO)* 寄存器，用于控制 GPIO 引脚。要使用 RIO 接口，我们将 `SYS_RIO` 函数存储到 GPIO
    控制寄存器中 ❷。
- en: The output circuit of a GPIO line is called a *pad*. We can set the characteristics
    of the output pad in several ways—for example, to either 2, 4, 8, or 12 mA. We
    set it to 4 mA for blinking an LED ❸. We complete our setup of the GPIO line by
    making it an output device ❹.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO 引脚的输出电路称为*垫片*。我们可以通过几种方式设置输出垫片的特性——例如，设置为 2、4、8 或 12 毫安。我们将其设置为 4 毫安，以使
    LED 闪烁 ❸。我们通过将其配置为输出设备来完成 GPIO 引脚的设置 ❹。
- en: Now that we have set up the GPIO line as a 1-bit output device, we can control
    the voltage that it outputs. The RIO interface to the GPIO has four registers
    for controlling the lines. [Table 20-2](ch20.xhtml#ch20tab2) shows the offset
    of each register from the RIO base.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将 GPIO 引脚设置为 1 位输出设备，可以控制它输出的电压。GPIO 的 RIO 接口有四个寄存器用于控制引脚。[表 20-2](ch20.xhtml#ch20tab2)
    显示了每个寄存器与 RIO 基址的偏移量。
- en: '**Table 20-2:** RIO Register Offsets'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 20-2：** RIO 寄存器偏移量'
- en: '| Offset | Action |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 偏移量 | 操作 |'
- en: '| --- | --- |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0x0000` | Normal read/write |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `0x0000` | 正常读/写 |'
- en: '| `0x1000` | XOR on write |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `0x1000` | 写入时执行 XOR |'
- en: '| `0x2000` | Bitmask set on write |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `0x2000` | 写入时设置位掩码 |'
- en: '| `0x3000` | Bitmask clear on write |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `0x3000` | 写入时清除位掩码 |'
- en: Bit *n* in each register corresponds to the GPIO*n* line. Storing a word to
    one of these registers causes the action to be taken on the GPIO line(s). Bit-mask
    set or clear means that only the bits that are `1` act on the corresponding GPIO
    lines. A `0` in a bit position has no effect on the corresponding GPIO line. The
    separate set and clear registers mean that we don’t need to read the contents
    of a register, make our changes, and write the result back.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每个寄存器中的位 *n* 对应于 GPIO*n* 引脚。将一个字存储到这些寄存器中的一个会导致对 GPIO 引脚进行相应操作。位掩码设置或清除意味着只有位为
    `1` 的部分作用于对应的 GPIO 引脚。位位置上的 `0` 对应的 GPIO 引脚没有影响。分开的设置和清除寄存器意味着我们不需要读取寄存器内容，进行更改后再写回结果。
- en: A GPIO line configured for output is always ready for us to change the voltage,
    so we don’t need to check its status. We’ll use the `gpio_5_line_set` function
    in [Listing 20-7](ch20.xhtml#ch20list7) to set the line, which places it at +3.3
    V.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 配置为输出的 GPIO 引脚始终准备好让我们更改电压，因此我们无需检查其状态。我们将使用 [列表 20-7](ch20.xhtml#ch20list7)
    中的 `gpio_5_line_set` 函数来设置该引脚，从而将其设置为 +3.3 V。
- en: '*gpio_5_line_set.s*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*gpio_5_line_set.s*'
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 20-7: A function to set a GPIO line on the Raspberry Pi 5*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 20-7：在 Raspberry Pi 5 上设置 GPIO 引脚的函数*'
- en: We move a `1` to the bit position corresponding to our line number ❷. Then,
    we store this word in the RIO set register, which places the GPIO line at the
    high voltage ❶.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`1`移到与我们的引脚号对应的位位置 ❷。然后，我们将这个字存储到 RIO 设置寄存器中，从而将 GPIO 引脚设置为高电压 ❶。
- en: The algorithm to clear a line is the same as the one to set it, as shown in
    [Listing 20-8](ch20.xhtml#ch20list8).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 清除引脚的算法与设置引脚的算法相同，如 [列表 20-8](ch20.xhtml#ch20list8) 所示。
- en: '*gpio_5_line_clr.s*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*gpio_5_line_clr.s*'
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 20-8: A function to clear a GPIO line on the Raspberry Pi 5*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 20-8：在 Raspberry Pi 5 上清除 GPIO 引脚的函数*'
- en: The only difference in the `gpio_line_clr` function is that we use the RIO clear
    register to place the GPIO line at the low voltage ❶.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpio_line_clr`函数唯一的区别在于我们使用RIO清除寄存器将GPIO线路设置为低电压❶。'
- en: Blinking an LED is a very simple example of performing output. We don’t have
    to check to see if the line is ready for us to turn it on or off; we just send
    a command to the device. Most I/O isn’t this simple. It takes some time to form
    an image to display on a screen, or to convert a keystroke on a keyboard to a
    bit pattern.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 闪烁LED是一个非常简单的输出操作示例。我们不需要检查线路是否准备好让我们打开或关闭它；我们只需要发送命令给设备。大多数I/O操作并不像这样简单。它需要一些时间来形成要在屏幕上显示的图像，或者将键盘上的按键转换为比特模式。
- en: In the next section, I’ll give you a general overview of how our program code
    deals with these timing issues.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将为你提供一个总体概述，说明我们的程序代码如何处理这些定时问题。
- en: '**YOUR TURN**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**该轮到你了**'
- en: 20.1   The typical voltage drop across an LED is 2 to 3 V when it’s on, depending
    on its color. Compute the amount of current you expect to flow through the LED
    in the circuit in [Figure 20-2](ch20.xhtml#ch20fig2) when the LED is on.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 20.1   当LED开启时，其典型电压降为2到3伏，具体取决于LED的颜色。计算当LED开启时，[图20-2](ch20.xhtml#ch20fig2)中的电路中预计流经LED的电流。
- en: 20.2   Write a program in Python to blink an LED five times at three-second
    intervals. Refer to*[https://www.raspberrypi.com/documentation/computers/os.html#use-gpio-from-python](https://www.raspberrypi.com/documentation/computers/os.html#use-gpio-from-python)*
    for hints on how to do this.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 20.2   编写一个Python程序，每三秒钟闪烁一次LED，闪烁五次。可以参考*[https://www.raspberrypi.com/documentation/computers/os.html#use-gpio-from-python](https://www.raspberrypi.com/documentation/computers/os.html#use-gpio-from-python)*获取有关如何实现的提示。
- en: 20.3   Modify the `main` function in [Listing 20-2](ch20.xhtml#ch20list2) to
    alternately blink LEDs attached to GPIO lines 16 and 17\. If you’re using a Raspberry
    Pi model other than the 5, run the program under `gdb` and set breakpoints in
    the `gpio_line_to_output` function so you can see that the appropriate function
    codes are stored in the GPFSEL0 register. You can get a better view of this if
    you add an `ldr w7, [x0]` instruction to `gpio_line_to_output` just before the
    `ret` instruction. Programmers sometimes add code like this for debugging purposes,
    which is usually deleted in the final product.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 20.3   修改[清单 20-2](ch20.xhtml#ch20list2)中的`main`函数，使其交替闪烁连接到GPIO线16和17的LED。如果你使用的是除了5号之外的树莓派型号，请在`gdb`中运行程序，并在`gpio_line_to_output`函数中设置断点，这样你就可以看到适当的函数代码存储在GPFSEL0寄存器中。如果你在`gpio_line_to_output`函数的`ret`指令之前添加一条`ldr
    w7, [x0]`指令，你可以更清楚地看到这一点。程序员有时会添加这样的代码用于调试，通常在最终产品中会删除这些代码。
- en: 20.4   Modify the assembly language LED blinking program to blink the LED every
    0.5 seconds. You’ll need to use the `usleep` function. The integer argument to
    this function is the number of microseconds to sleep.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 20.4   修改汇编语言的LED闪烁程序，使LED每0.5秒闪烁一次。你需要使用`usleep`函数。此函数的整数参数是需要睡眠的微秒数。
- en: 20.5   If you’re using a Raspberry Pi 5, write a program in assembly language
    to toggle an LED on and off five times using a single `gpio_5_line_toggle` function
    instead of the `gpio_5_line_set` and `gpio_5_line_clr` functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 20.5   如果你使用的是树莓派5，编写一个汇编语言程序，使用单个`gpio_5_line_toggle`函数开关LED五次，而不是使用`gpio_5_line_set`和`gpio_5_line_clr`函数。
- en: '**Polled I/O Programming Algorithms**'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**轮询输入/输出编程算法**'
- en: Let’s look at some simple polling algorithms that show how we might program
    a *universal asynchronous receiver/transmitter (UART)* for I/O.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些简单的轮询算法，展示如何为I/O编程一个*通用异步接收器/发射器（UART）*。
- en: 'When used as an output device, a UART performs parallel-to-serial conversion
    to transmit a byte of data 1 bit at a time. As an input device, a UART receives
    the bits one at a time and performs serial-to-parallel conversion to reassemble
    the byte that was sent to it. Thus, an 8-bit byte can be transmitted and received
    using only three wires: transmit, receive, and common. Both the transmitting and
    receiving UARTs must be set at the same bit rate.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当UART作为输出设备使用时，它执行并行到串行转换，一次传输一个字节的数据位。作为输入设备时，UART一次接收一个比特，并执行串行到并行转换，以重新组装传输给它的字节。因此，一个8位字节可以通过仅使用三条线路（传输、接收和公共线路）进行传输和接收。传输和接收的UART必须设置为相同的比特率。
- en: In the idle state, the transmitting UART places the high voltage on the transmission
    line. When a program outputs a byte to the UART, the transmitting UART first sends
    a *start bit*; it does this by placing the transmission line at the low voltage
    for the amount of time it takes to transmit one bit, corresponding to the agreed-upon
    bit rate.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在空闲状态下，发送UART将高电压置于传输线上。当程序输出一个字节到UART时，发送UART首先发送一个*起始位*；它通过将传输线置于低电压，持续传输一个比特的时间，这个时间对应于约定的比特率。
- en: After the start bit, the transmitter sends the data bits at the agreed-upon
    bit rate. The UART uses a shift register to shift the byte 1 bit at a time, setting
    the voltage on the output line accordingly. Most UARTs start with the low-order
    bit. When the entire byte has been sent, the UART returns the output line to the
    idle state for at least 1 bit time, thus sending at least one *stop bit*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在起始位之后，发送器按约定的比特率发送数据位。UART使用移位寄存器一次移位一个比特，并相应地设置输出线路上的电压。大多数UART从低位比特开始。当整个字节发送完成后，UART将输出线路恢复为空闲状态，至少持续1个比特时间，从而发送至少一个*停止位*。
- en: '[Figure 20-3](ch20.xhtml#ch20fig3) shows how a UART with typical settings would
    send the two characters *m* and *n* encoded in ASCII.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[图20-3](ch20.xhtml#ch20fig3)展示了一个典型设置的UART如何发送ASCII编码的两个字符*m*和*n*。'
- en: '![Image](../images/pg489_Image_320.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg489_Image_320.jpg)'
- en: '*Figure 20-3: A UART output to send the characters* m *and* n'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图20-3：UART输出以发送字符* m *和* n'
- en: The receiving UART watches the transmission line, looking for a start bit. When
    it detects a start bit, it uses a shift register to reassemble the individual
    bits into a byte, which it provides to the receiving program as input.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接收UART监视传输线，寻找起始位。当它检测到起始位时，它使用移位寄存器将单个比特重新组装成一个字节，并将其作为输入提供给接收程序。
- en: We’ll use the 16550 UART, a common type, for our programming example. The 16550
    UART has 13 8-bit registers, shown in [Table 20-3](ch20.xhtml#ch20tab3).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用常见类型的16550 UART作为我们的编程示例。16550 UART有13个8位寄存器，如[表20-3](ch20.xhtml#ch20tab3)所示。
- en: '**Table 20-3:** The Registers of the 16550 UART'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**表20-3：** 16550 UART的寄存器'
- en: '| Name | Address | DLAB | Purpose |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 地址 | DLAB | 目的 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `RHR` | `000` | `0` | Receiver holding (input byte) |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `RHR` | `000` | `0` | 接收保持寄存器（输入字节） |'
- en: '| `THR` | `000` | `0` | Transmitter holding (output byte) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `THR` | `000` | `0` | 发送保持寄存器（输出字节） |'
- en: '| `IER` | `001` | `0` | Interrupt enable (set type of interrupt) |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `IER` | `001` | `0` | 中断使能（设置中断类型） |'
- en: '| `ISR` | `010` | `x` | Interrupt status (show type of interrupt) |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `ISR` | `010` | `x` | 中断状态（显示中断类型） |'
- en: '| `FCR` | `010` | `x` | FIFO control (set FIFO parameters) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `FCR` | `010` | `x` | FIFO控制（设置FIFO参数） |'
- en: '| `LCR` | `011` | `x` | Line control (set communications format) |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `LCR` | `011` | `x` | 行控制（设置通信格式） |'
- en: '| `MCR` | `100` | `x` | Modem control (set interface with modem) |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `MCR` | `100` | `x` | 调制解调器控制（设置与调制解调器的接口） |'
- en: '| `LSR` | `101` | `x` | Line status (show status of data transfers) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `LSR` | `101` | `x` | 行状态（显示数据传输状态） |'
- en: '| `MSR` | `110` | `0` | Modem status (show status of modem) |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `MSR` | `110` | `0` | 调制解调器状态（显示调制解调器状态） |'
- en: '| `SCR` | `111` | `x` | Scratch |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `SCR` | `111` | `x` | 临时寄存器 |'
- en: '| `DLL` | `000` | `1` | Divisor latch (low-order byte) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `DLL` | `000` | `1` | 除数锁存器（低位字节） |'
- en: '| `DLM` | `001` | `1` | Divisor latch (high-order byte) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `DLM` | `001` | `1` | 除数锁存器（高位字节） |'
- en: '| `PSD` | `101` | `1` | Prescaler division |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `PSD` | `101` | `1` | 预分频器分频 |'
- en: The addresses in [Table 20-3](ch20.xhtml#ch20tab3) are address offsets from
    the UART’s base address. You probably noticed that some of the registers have
    the same offset. The functionality of the register at that offset depends on how
    our program treats it. For example, if the program loads from offset `000`, it’s
    loading from the receiver holding register (`RHR`). But if the program stores
    to offset `000`, it’s storing to the transmitter holding register (`THR`).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[表20-3](ch20.xhtml#ch20tab3)中的地址是UART基地址的偏移量。你可能已经注意到，一些寄存器具有相同的偏移量。该偏移量处寄存器的功能取决于我们的程序如何处理它。例如，如果程序从偏移量`000`加载数据，它是从接收保持寄存器（`RHR`）加载。但如果程序将数据存储到偏移量`000`，则它是存储到发送保持寄存器（`THR`）。'
- en: The divisor latch access bit (DLAB) is bit number 7 in the line control register
    (`LCR`). When it is set to `1`, offset `000` connects to the low-order byte of
    the 16-bit divisor latch value and offset `001` connects to the high-order byte
    of the divisor latch value.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除数锁存器访问位（DLAB）是行控制寄存器（`LCR`）中的第7位。当它被设置为`1`时，偏移量`000`连接到16位除数锁存器值的低位字节，而偏移量`001`连接到除数锁存器值的高位字节。
- en: The 16550 UART can be programmed for interrupt-driven I/O and direct memory
    access. It includes 16-byte first in, first out (FIFO) buffers on both the transmitter
    and the receiver registers. It can also be programmed to control a serial modem.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Older PCs typically connected the UART to a COM port. In past years, COM ports
    were often used to connect devices such as printers and modems to computers, but
    most PCs today use USB ports for serial I/O.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi has a 16550-like UART with the receiver and transmitter registers
    connected to GPIO lines. Programming the UART is beyond the scope of this book,
    but I’ll use C to give a general idea of how it’s done.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Note that the C functions we’ll write in this section are meant only to show
    the concepts, not to do anything useful. In fact, running them will elicit an
    error message from the operating system.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll assume the UART is installed in a computer that uses memory-mapped I/O
    so I can show the algorithms in C. To keep things simple, I’ll do only polled
    I/O here, which requires these three functions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: UART_init   Initializes the UART. This includes setting parameters in the hardware,
    such as the speed and communications protocol.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: UART_in   Reads one character that was received by the UART.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: UART_out   Writes one character to be transmitted by the UART.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: These three functions would allow us to use a UART to receive a character and
    then transmit that same character, as shown in [Listing 20-9](ch20.xhtml#ch20list9).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '*UART_echo.c*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 20-9: A function to use a UART to read and write a single character*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore only a few features of the UART. Let’s start with a file that
    provides symbolic names for the registers and some numbers we’ll be using in our
    example program, as shown in [Listing 20-10](ch20.xhtml#ch20list10).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '*UART_def.h*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 20-10: The definitions for a 16550 UART*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The offsets to the registers are at fixed positions relative to the start of
    the mapped memory address of the UART. These offsets, and the status and control
    bit settings, are taken from a 16550 datasheet, which you can download at *[https://www.ti.com/product/TL16C550D](https://www.ti.com/product/TL16C550D)*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how I arrived at the value for the `SETCOM` control ❶. The communication
    parameters are set by writing 1 byte to the line status register. There can be
    5 to 8 bits in each data frame. The datasheet tells us that setting bits 1 and
    0 to `11` will specify 8 bits. Hence, I set `NBITS` to `0x03`. Setting bit 2 to
    `0` specifies one stop bit, so `STOPBIT` = `0x00`. I don’t use parity, which is
    bit 3, so `NOPARITY` = `0x00`. I combine these constants with the OR operator
    to create the byte that sets the communication parameters. Of course, we don’t
    really need the two zero values, but specifying them makes our intent explicit.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The unit *baud* is a measure of the speed of communication, defined as the number
    of symbols per second. A UART uses only two voltage levels for communication,
    symbolically `0` or `1`, or 1 bit. For a UART, the baud rate is equivalent to
    the number of bits transmitted or received per second. We need to set the DLAB
    bit to `1` to place our UART in the mode that allows us to set the baud rate ❷.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 单位*波特率*是通信速度的度量，定义为每秒钟符号的数量。UART只使用两种电压电平进行通信，即符号`0`或`1`，即1个比特。对于UART，波特率等同于每秒传输或接收的比特数。我们需要将DLAB位设置为`1`，以将我们的UART设置为允许我们设置波特率的模式❷。
- en: Next, we need a header file for declaring the functions, as shown in [Listing
    20-11](ch20.xhtml#ch20list11).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个头文件来声明这些函数，如[列表20-11](ch20.xhtml#ch20list11)所示。
- en: '*UART_functions.h*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*UART_functions.h*'
- en: '[PRE16]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 20-11: The UART function declarations*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表20-11：UART函数声明*'
- en: The header file declares the three basic functions for using our UART. I won’t
    cover the more advanced features of a UART in this book.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件声明了使用我们UART的三个基本函数。本书不会涉及UART的更高级特性。
- en: We’ll place the definitions of these three functions in one file, as shown in
    [Listing 20-12](ch20.xhtml#ch20list12), because they would typically be used together.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这三个函数的定义放在一个文件中，如[列表20-12](ch20.xhtml#ch20list12)所示，因为它们通常是一起使用的。
- en: '*UART_functions.c*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*UART_functions.c*'
- en: '[PRE17]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 20-12: The UART memory-mapped I/O function definitions in C*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表20-12：C语言中UART内存映射I/O函数的定义*'
- en: The `UART_init` function sets the various communication parameters for the UART.
    The purposes of the values I used in this example are explained after [Listing
    20-10](ch20.xhtml#ch20list10).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`UART_init`函数设置UART的各种通信参数。我在本示例中使用的值的目的将在[列表20-10](ch20.xhtml#ch20list10)之后进行解释。'
- en: The `UART_in` function waits in a `while` loop until the `RxRDY` bit becomes
    `1`, which occurs when the UART has a character ready to read from its receive
    holding register ❶. The character is read from the receive holding register with
    an assignment to a local variable.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`UART_in`函数在`while`循环中等待，直到`RxRDY`位变为`1`，即当UART有一个字符准备从其接收保持寄存器中读取时❶。该字符通过赋值给一个局部变量从接收保持寄存器中读取。'
- en: The `UART_out` function waits in a `while` loop until the `TxRDY` bit becomes
    `1`, which occurs when the UART is ready for us to send a character to the transmit
    holding register ❷. The character is sent with an assignment to the transmit holding
    register.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`UART_out`函数在`while`循环中等待，直到`TxRDY`位变为`1`，即当UART准备好接收我们发送到传输保持寄存器的字符时❷。该字符通过赋值给传输保持寄存器发送出去。'
- en: These functions provide an overall view of how a UART is used in a polling mode.
    I’ve omitted many details here that are required to ensure robust operation. If
    you would like to use one of the UARTs on a Raspberry Pi, you can start with the
    documentation at *[https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header](https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header)*.
    I recommend accessing the UART through the operating system instead of directly,
    as we did when blinking an LED earlier in this chapter. I have not used the UARTs
    on a Raspberry Pi, so I can’t vouch for any of them, but tutorials are available
    online.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数提供了一个如何在轮询模式下使用UART的总体视图。这里我省略了许多确保稳健操作所需的细节。如果你想使用树莓派上的某个UART，可以从*[https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header](https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header)*的文档开始。我建议通过操作系统来访问UART，而不是像我们之前在本章中点亮LED时那样直接访问。我没有在树莓派上使用过UART，因此不能为它们做担保，但网上有教程可以参考。
- en: '**What You’ve Learned**'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你所学到的内容**'
- en: '**Virtual memory** The memory address space used by a program.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟内存** 程序使用的内存地址空间。'
- en: '**Memory mapping unit (MMU)** A hardware device that uses a map table to convert
    virtual memory addresses to physical memory addresses.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存映射单元 (MMU)** 是一种硬件设备，使用映射表将虚拟内存地址转换为物理内存地址。'
- en: '**Translation lookaside buffer (TLB)** Memory in the MMU where the most recently
    used map table entries are cached.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换后备缓冲区 (TLB)** 是MMU中的内存，缓存最近使用的映射表条目。'
- en: '**Memory timing**   Memory access is synchronized with the timing of the CPU.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存时序** 内存访问与CPU的时序同步。'
- en: '**I/O timing**   I/O devices are much slower than the CPU and have a wide range
    of characteristics, so we need to program their access.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**I/O时序** I/O设备比CPU要慢得多，并且具有广泛的特性，因此我们需要编程来访问它们。'
- en: '**Bus timing**   Buses are often arranged in a hierarchical manner to better
    match the differences in timing between various I/O devices.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '**Port-mapped I/O**   With this technique, I/O device registers have their
    own address space.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory-mapped I/O**   With this technique, I/O registers are given a portion
    of the main memory address space.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmed I/O**   The program transfers data directly from an input device
    or to an output device at the point where it’s needed.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '**Polled I/O**   The program waits in a loop until the I/O device is ready
    to transfer data.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '**Interrupt-driven I/O**   The I/O device interrupts the CPU when it is ready
    to transfer data.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct memory access**   The I/O device can transfer data to and from main
    memory without using the CPU.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '**General-purpose I/O (GPIO)**   A general-purpose I/O device can be programmed
    to input or output a single bit of information.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about the CPU features that allow it to maintain
    control over the I/O hardware and prevent application programs from accessing
    the hardware without going through the operating system.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
