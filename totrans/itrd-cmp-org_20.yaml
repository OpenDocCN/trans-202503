- en: '## **20'
  prefs: []
  type: TYPE_NORMAL
- en: INPUT/OUTPUT**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The *I/O subsystem* is what programs use to communicate with the outside world,
    meaning devices other than the CPU and memory. Most programs read data from one
    or more input devices, process the data, and then write the results to one or
    more output devices.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboards and mice are typical input devices; display screens and printers are
    typical output devices. Although most people don’t think of them this way, devices
    such as magnetic disks, solid-state drives (SSDs), USB sticks, and so forth are
    also I/O devices.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start this chapter by discussing some of the timing characteristics of
    I/O devices compared to memory, then I’ll cover how this affects the interface
    between the CPU and I/O devices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Timing Considerations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the CPU accesses memory and I/O devices over the same buses (see [Figure
    1-1](ch01.xhtml#ch1fig1) in [Chapter 1](ch01.xhtml)), it might seem that a program
    could access I/O devices in the same way as it accesses memory. That is, you might
    expect that I/O can be performed by using the `ldr` and `str` instructions to
    transfer bytes of data between the CPU and a specific I/O device. This can be
    done with many devices, but some particularities must be taken into account to
    make it work correctly. One of the main issues lies in the timing differences
    between memory and I/O. Before tackling I/O timing, let’s consider memory timing
    characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As I’ve pointed out, the three-bus description given in this book shows the
    logical interaction between the CPU and I/O devices. Most modern computers employ
    several types of buses. The way the CPU connects to the various buses is handled
    in hardware. A programmer generally deals only with the logical view.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Memory Timing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An important characteristic of memory is that its timing is relatively uniform
    and not dependent on external events. This means memory timing can be handled
    by the hardware, so programmers don’t need to be concerned about it; we can simply
    move data to and from memory using CPU instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two types of RAM are commonly used in computers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SRAM**   Holds its values as long as the power is on. It requires more components
    to do this, so it is more expensive and physically larger, but access times are
    very fast.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DRAM**   Uses passive components that hold data values for only a few fractions
    of a second. DRAM includes circuitry that automatically refreshes the data values
    before the values are completely lost. It is less expensive than SRAM, but also
    5 to 10 times slower.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the memory on the Raspberry Pi is DRAM, because it is much less expensive
    and smaller than SRAM. As each instruction must be fetched from memory, slow memory
    access limits program execution speed.
  prefs: []
  type: TYPE_NORMAL
- en: Program execution speed is improved by using cache memory systems made from
    SRAM. The combination of SRAM cache with DRAM main memory works well to ensure
    minimal time delays when the CPU accesses memory.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting here that CPU speeds are still faster than memory speeds (even
    SRAM). Accessing memory—fetching an instruction, loading data, storing data—is
    typically the most important factor that slows program execution. There are techniques
    for improving cache performance, which improves memory access times, but employing
    such techniques requires a thorough understanding of the CPU and memory configuration
    of the system you’re using, which is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '***I/O Device Timing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Almost all I/O devices are much slower than memory. Consider a common input
    device, the keyboard. Typing at 120 words per minute is equivalent to entering
    approximately 10 characters per second, or a delay of ∼100 ms between each character.
    A CPU running at 2 GHz can execute approximately 200 million instructions during
    that time. This is to say nothing of the fact that the time intervals between
    keystrokes are very inconsistent. Many will be much longer than this.
  prefs: []
  type: TYPE_NORMAL
- en: Even an SSD is slow compared to memory. For example, data can be transferred
    to and from a typical SSD at about 500MBps. The transfer rate for DDR4 memory
    (which is commonly used for main memory) is around 20GBps, some 40 times faster.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being much slower, I/O devices exhibit much more variance in
    their timing. Some people type very quickly on a keyboard, some very slowly. The
    required data on a magnetic disk might be just coming up to the read/write head,
    or it may have just passed by, in which case you’ll have to wait for nearly a
    full revolution of the disk for it to come under the head again.
  prefs: []
  type: TYPE_NORMAL
- en: As pointed out at the beginning of [Chapter 9](ch09.xhtml), the Raspberry Pi
    uses a System on a Chip (SoC), which includes one or more processor cores and
    many of the controllers for other parts of the computer. Most SoCs based on the
    ARM architecture use the Advanced Microcontroller Bus Architecture (AMBA), first
    introduced by Arm in 1997\. This architecture specifies several protocols, which
    are used to select the appropriate speeds for the communications between the CPU
    and other functional parts in the SoC. The details are beyond the scope of this
    book, but if you’re interested in learning more about AMBA, a good starting point
    is the free online training videos at *[https://www.arm.com/architecture/system-architectures/amba](https://www.arm.com/architecture/system-architectures/amba)*.
  prefs: []
  type: TYPE_NORMAL
- en: The SoC includes controllers for most of the external I/O interfaces. All Raspberry
    Pis, except the Raspberry Pi Zero, have a second chip that provides additional
    external I/O interfaces. The I/O chip on a Raspberry Pi 1, 1+, 2, 3, or 3+ provides
    Ethernet and USB 2.0 ports, and it communicates with the SoC via USB 2.0\. The
    I/O chip on a Raspberry Pi 4 provides USB 2.0 and USB 3.0 ports, and it communicates
    with the SoC via a PCI Express (PCI-E) bus.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi 5 uses a new I/O controller chip named *RP1* that incorporates
    most of the controllers for the external I/O interfaces that were previously on
    the SoC, including USB, MIPI camera and display, Ethernet, and general-purpose
    input/output (GPIO). Such a device is often called a *southbridge*. The RP1 communicates
    with the SoC via a PCI-E bus. Moving the slower I/O functionality to a separate
    chip simplifies the SoC, allowing it to run faster and to focus on computation-intensive
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I’ll show you how we access the registers of an I/O device.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing I/O Devices**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CPU works with an I/O device through a *device controller*, the hardware
    that does the actual work of controlling the I/O device. For example, a keyboard
    controller detects which key is pressed and converts this to a bit pattern that
    represents the key. It also detects whether modifier keys, such as SHIFT or CTRL,
    are pressed and sets the bit pattern accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The device controller interfaces with the CPU through a set of registers. In
    general, a device controller provides the following types of I/O registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**   Used to send data to an output device or to read data from an input
    device'
  prefs: []
  type: TYPE_NORMAL
- en: '**Status**   Provides information about the current state of the device, including
    the controller itself'
  prefs: []
  type: TYPE_NORMAL
- en: '**Control**   Allows a program to send commands to the controller to change
    the settings of the device and the controller'
  prefs: []
  type: TYPE_NORMAL
- en: It’s common for a device controller interface to have more than one register
    of the same type, especially control registers and status registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending data to an output device is very much like storing data in memory:
    you store the data in a data register on the device controller. Where the output
    device differs from memory is the timing. As I’ve already said, a programmer doesn’t
    need to be concerned about the timing when storing data in memory. However, an
    output device may not be ready to accept new data—it may be working on previously
    sent data. This is where the status register comes into play. The program needs
    to check the status register to see if the device controller is ready to accept
    new data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading data from an input device is like loading data from memory into the
    CPU: you load the data from a data register on the device controller. Again, the
    difference from memory is that an input device may not have new data, so the program
    needs to check the status register of the input device controller to see if it
    does.'
  prefs: []
  type: TYPE_NORMAL
- en: Most I/O devices also need to be told what to do by a control register. For
    example, after waiting for an output device controller to become ready for new
    data and then moving the data to a data register, some device controllers require
    that you tell them to output the data to the actual device. Or, if you want to
    get data from an input device, some device controllers require that you request
    them to get an input. You can send commands like these to a control register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CPU can access the I/O registers on a device controller in two ways: via
    memory-mapped I/O and port-mapped I/O. With *memory-mapped I/O*, a range of memory
    addresses is dedicated to the I/O ports, and each I/O register is mapped to one
    of the memory addresses in that range. Then, the load and store instructions are
    used to read from or write to the I/O registers on a device controller.'
  prefs: []
  type: TYPE_NORMAL
- en: With *port-mapped I/O*, the I/O device controller registers are assigned addresses
    in a separate addressing space. The CPU uses special I/O instructions to communicate
    with the I/O registers.
  prefs: []
  type: TYPE_NORMAL
- en: The AArch64 architecture supports only memory-mapped I/O. The x86 architecture
    is an example of one that supports both types of I/O.
  prefs: []
  type: TYPE_NORMAL
- en: It’ll be easier to understand memory-mapped I/O if we first look at how memory
    is managed by Linux and most other operating systems when executing a program.
    Programs run in a *virtual memory* address space, a technique that simulates a
    large memory with contiguous addressing from 0 to some maximum value. These are
    the addresses you see when using `gdb`—for example, the addresses in the `sp`
    and `pc` registers.
  prefs: []
  type: TYPE_NORMAL
- en: Although the AArch64 architecture allows 64-bit addressing, current CPU hardware
    implementations use only 52 bits for the address. This allows a maximum address
    of 2^(52) bytes (4 pebibytes) to execute programs in this virtual address space.
    But a Raspberry Pi has only 1 to 8GiB (or gibibytes) of *physical memory*, the
    actual RAM installed in the computer, and a program needs to be in physical memory
    to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We commonly use the metric naming convention for specifying multiple-byte
    quantities that is based on powers of 10: kilobyte, megabyte, gigabyte, and so
    forth. The International Electrotechnical Commission (IEC) has also defined a
    naming convention that is based on powers of two: kibibyte, mebibyte, gibibyte,
    and so forth. For example, a kilobyte is 1,000 bytes, and a kibibyte is 1,024
    bytes. You can read more about the naming conventions at* [https://en.wikipedia.org/wiki/Byte](https://en.wikipedia.org/wiki/Byte).'
  prefs: []
  type: TYPE_NORMAL
- en: The operating system manages the placement of programs in physical memory by
    dividing each program into *pages*. Raspberry Pi OS uses a 4KiB (or kibibyte)
    page size on most models and a 16KiB page size on the model 5\. Physical memory
    is divided into the same size *page frames*. The page of the program that contains
    the code currently being executed by the CPU is loaded from the place where it’s
    stored (for example, disk, DVD, USB stick) into a page frame of physical memory.
  prefs: []
  type: TYPE_NORMAL
- en: The operating system maintains a *page table* that shows where the page of the
    program is currently loaded in physical memory. [Figure 20-1](ch20.xhtml#ch20fig1)
    shows the relationship between virtual memory and physical memory using the page
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg469_Image_318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-1: The relationship between virtual memory and physical memory*'
  prefs: []
  type: TYPE_NORMAL
- en: The SoC used on a Raspberry Pi includes a *memory management unit (MMU)*. When
    the CPU needs to access an item in memory, it uses the virtual address of the
    item. The MMU uses the virtual address as an index into the page table to locate
    the page in physical memory and, from there, the item. If the requested page is
    not currently loaded into physical memory, the MMU generates a *page fault exception*,
    which calls a function in the operating system to load the page into physical
    memory and enter its location in the page table. (You’ll learn about exceptions
    in [Chapter 21](ch21.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: 'The page table is stored in main memory, so using it requires two memory accesses:
    one to retrieve the frame number from the page table and another to access the
    location in main memory. To speed things up, the MMU includes a *translation lookaside
    buffer (TLB)* in its hardware. The TLB is a small amount of fast memory that contains
    the most recently used entries from the page table. Like the memory cache you
    learned about in [Chapter 8](ch08.xhtml), the TLB uses the tendency of a program
    to reference nearby memory addresses over a short period of time to speed up memory
    accesses. The MMU first looks in the TLB. If the page table entry is there, then
    only one access of main memory is required.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to how virtual memory is mapped to physical memory, virtual memory addresses
    can be mapped to the I/O device controller register address space. Having the
    controller registers associated with virtual memory addresses allows us to use
    the CPU instructions that access memory to access the I/O device controller registers.
    One advantage of memory-mapped I/O is that you can usually write the I/O functions
    in a higher-level language such as C without using inline assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: '**I/O Programming**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the amount of data they process and the speed with which they process
    it, I/O devices use different techniques for communicating with the CPU. These
    differences are reflected in the way a device controller is programmed to perform
    its functions.
  prefs: []
  type: TYPE_NORMAL
- en: When timing is not important, we can simply use instructions to send a data
    item to an output device or read a data item from an input device at the point
    in our program where we wish to output or input it. This works for I/O devices
    that don’t need time to process the binary data being transferred. You’ll see
    an example of this technique later in this chapter, when we program an I/O device
    to output one of two voltage levels on a single output pin.
  prefs: []
  type: TYPE_NORMAL
- en: Most I/O device controllers require significant time to process input and output
    data. For example, when we press a key on the keyboard, the keyboard device controller
    needs to detect which key was pressed and then convert that knowledge into an
    8-bit pattern that represents the character we pressed. If our program needs that
    character, we have to first check the status register of the keyboard device controller
    to determine if it has completed this process. If the device controller is in
    a ready state, then we can read data from the device controller.
  prefs: []
  type: TYPE_NORMAL
- en: We do this in our program using a *polling* algorithm. Polling typically involves
    a loop that iterates, checking the device’s status register in each iteration
    of the loop, until the device is in a ready state. When the device controller
    is ready, we load the data into a general-purpose CPU register. When programmed
    I/O uses a polling algorithm, it’s often called *polled I/O*.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, an output device controller might be busy outputting a previous data
    item. Our program needs to poll the device controller and wait until it’s ready
    to accept new output data.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of polled I/O is that the CPU can be tied up for a long time waiting
    for the device to become ready. This would probably be acceptable if the CPU were
    dedicated to running only one program on the system (for example, controlling
    a microwave oven), but it’s not acceptable in the multiprogram environments of
    modern computing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could get more work out of the CPU if we could tell an I/O device to let
    us know when it was ready for data input or output and use the CPU for something
    else in the meantime. Many I/O devices include an *interrupt controller* for just
    this purpose: it can send an interrupt signal to the CPU when the device has completed
    an operation or is ready to take on another operation.'
  prefs: []
  type: TYPE_NORMAL
- en: An interrupt from an external device causes the CPU to call an *interrupt handler*,
    a function within the operating system that deals with the input or output from
    the interrupting device. This is usually called *interrupt-driven I/O*. I’ll discuss
    the features of a CPU that allow it to call interrupt handlers in [Chapter 21](ch21.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: In all of these techniques, the CPU initiates the transfer of data to or from
    the I/O device controller. We call this *programmed I/O*.
  prefs: []
  type: TYPE_NORMAL
- en: I/O devices that transfer large amounts of data at high speed often have the
    capability of *direct memory access (DMA)*. They have a *DMA controller* that
    can access main memory directly without the CPU. For example, when reading from
    a disk, the DMA controller accepts a memory address and a command to read data
    from the disk. When the DMA controller has read the data from the disk into its
    own buffer memory, it writes that data directly to main memory. When the DMA data
    transfer has completed, the controller sends an interrupt to the CPU, thus invoking
    the disk interrupt handler that notifies the operating system that the data is
    now available in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll look at an output that doesn’t even need to be polled: a single
    pin that we can place at one of two voltages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming a General-Purpose I/O Device**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *general-purpose I/O (GPIO)* is a signal line that can be configured to either
    input or output 1 bit. They were originally implemented in groups on an integrated
    circuit chip, with each I/O line of the GPIO circuitry connected to a pin on the
    chip. These days, GPIO circuits are typically included in SoC designs, where they
    can be used for lighting an LED, reading a switch, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: All Raspberry Pi models include GPIOs arranged in groups, still called chips.
    One of the chips has 28 lines that are connected to pins on a 40-pin *GPIO header*
    located on the top edge of the Raspberry Pi board that we can use to control external
    I/O devices. (The original Raspberry Pi 1 has a 26-pin GPIO header connected to
    17 GPIO lines.)
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll show you how to program a GPIO line to output a single
    bit that causes its corresponding GPIO header pin to alternate between 0.0 V and
    +3.3 V. We don’t need to poll the GPIO line to see if it’s ready for this 1-bit
    output, because it’s always ready. We’ll use these voltage alternations to blink
    an LED.
  prefs: []
  type: TYPE_NORMAL
- en: The correspondences between the 28 GPIO lines and the GPIO header pins for a
    40-pin header are shown in [Table 20-1](ch20.xhtml#ch20tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 20-1:** Correspondences Between GPIO Lines and Raspberry Pi Header
    Pins'
  prefs: []
  type: TYPE_NORMAL
- en: '| Signal | Header | pins | Signal |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| +3.3 V power | 1 | 2 | +5 V power |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO2 | 3 | 4 | +5 V power |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO3 | 5 | 6 | Ground |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO4 | 7 | 8 | GPIO14 |'
  prefs: []
  type: TYPE_TB
- en: '| Ground | 9 | 10 | GPIO15 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO17 | 11 | 12 | GPIO18 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO27 | 13 | 14 | Ground |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO22 | 15 | 16 | GPIO23 |'
  prefs: []
  type: TYPE_TB
- en: '| +3.3 V power | 17 | 18 | GPIO24 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO10 | 19 | 20 | Ground |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO9 | 21 | 22 | GPIO25 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO11 | 23 | 24 | GPIO8 |'
  prefs: []
  type: TYPE_TB
- en: '| Ground | 25 | 26 | GPIO7 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO0 | 27 | 28 | GPIO1 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO5 | 29 | 30 | Ground |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO6 | 31 | 32 | GPIO12 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO13 | 33 | 34 | Ground |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO19 | 35 | 36 | GPIO16 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO26 | 37 | 38 | GPIO20 |'
  prefs: []
  type: TYPE_TB
- en: '| Ground | 39 | 40 | GPIO21 |'
  prefs: []
  type: TYPE_TB
- en: The pin numbering of the GPIO header assumes we are looking down at the top
    of the Raspberry Pi, with the header on the right. There are two rows of header
    pins, with the odd-numbered pins on the left and the even-numbered pins on the
    right. Notice that the GPIO lines are not in the same numerical order as the GPIO
    header pins.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see this information online at *[https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header](https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header)*,
    and on the Raspberry Pi the `pinout` command will give you the pin correspondence
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Much of the Raspberry Pi documentation calls the signal from the GPIO device
    a GPIO pin. To avoid confusion, I’ll use the names *GPIO line* for the signals
    and *GPIO header pin* for the physical connectors on the GPIO header. As you’ll
    see later in this chapter, this naming convention is consistent with the `gpiod`
    library, which we’ll use for programming the GPIO lines in C. We’ll start by connecting
    our hardware circuit for blinking an LED.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Connecting the Blinking LED Circuit***'
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with this project, you’ll need an LED, a 220 Ω resistor, and
    several connecting jumper wires. Building the circuit on a breadboard is easier
    than just putting the components on a desktop or a workbench.
  prefs: []
  type: TYPE_NORMAL
- en: Before you connect anything to the GPIO header pins on your Raspberry Pi, you
    should shut it down and turn off the power. The pins are close together, and it’s
    easy to accidentally short two of them together, which may damage your Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the circuit shown in [Figure 20-2](ch20.xhtml#ch20fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg473_Image_319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-2: The circuit for a blinking LED*'
  prefs: []
  type: TYPE_NORMAL
- en: You saw the circuit symbol for a resistor in [Figure 5-3](ch05.xhtml#ch5fig3)
    in [Chapter 5](ch05.xhtml). The triangle with two arrows above it is the circuit
    symbol for an LED, and the triangular-shaped group of three horizontal lines is
    the symbol for ground (0.0 V). Using the information in [Table 20-1](ch20.xhtml#ch20tab1),
    we’ll connect to GPIO17 using pin 11 on the GPIO header and connect to ground
    using header pin 9.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you connect the LED correctly. The left-hand side of the LED in this
    figure is the *anode* and the right-hand side is the *cathode*. The manufacturer
    of your LED should provide documentation showing which lead is which on the LED.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll write a program that alternates the voltage on the GPIO17 pin between
    +3.3 V and 0.0 V. At +3.3 V, current flows through the resistor and LED, causing
    the LED to turn on. The 220 Ω resistor is necessary to limit the amount of current
    flowing through it, as excessive current could destroy the LED. When our program
    switches the GPIO17 pin to 0.0 V, current no longer flows through the LED, turning
    it off.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a C program to make sure our circuit is connected correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '***Blinking an LED in C, All Models***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Raspberry Pi OS comes with two libraries of functions that allow us to work
    with the GPIO in high-level languages. The `pigpio` library provides C and Python
    functions, and `gpiozero` provides a simple Python programming interface. You
    can read about them at *[https://abyz.me.uk/rpi/pigpio/](https://abyz.me.uk/rpi/pigpio/)*
    and *[https://gpiozero.readthedocs.io/en/stable/](https://gpiozero.readthedocs.io/en/stable/)*,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of this writing, the `pigpio` library does not work on the Raspberry Pi
    5\. I installed the `gpiod` package, which includes some useful command line tools
    for working with the GPIO. It also installs the `libgpiod` library, which is the
    officially supported interface to the GPIO. I have tested this library with C
    and Python programs on both my Raspberry Pi 3 and my Raspberry Pi 5\. I installed
    the command line and development tools with the following three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*At the time of writing, this installs version 1.6.3 of the library and tools.
    The developers have released version 2.1.1, but it’s not yet in the Raspberry
    Pi OS repository. When the repository is updated, I expect additional utilities
    to be added, and some of the function names in the library may change. The source
    code for all versions is available at* [https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git](https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gpiod` package installs six utility programs for working with the GPIO
    device: `gpiodetect`, `gpiofind`, `gpioget`, `gpioinfo`, `gpiomon`, and `gpioset`.
    The `libgpiod-doc` package installs the man pages for each of these utilities,
    and the `libgpiod-dev` package installs the interface to the functions in the
    `libgpiod` library we’ll use to program the GPIO in C.'
  prefs: []
  type: TYPE_NORMAL
- en: Other useful tools included with Raspberry Pi OS are `pinout` and `pinctrl`.
    The `pinout` program has a man page that describes its use. The `pinctrl help`
    command shows how to use `pinctrl`. I used `pinctrl` to help debug the programs
    to blink an LED that you’ll see here.
  prefs: []
  type: TYPE_NORMAL
- en: We will use functions from the `libgpiod` library to write a program in C, which
    is shown in [Listing 20-1](ch20.xhtml#ch20list1), to blink an LED for testing
    the circuit in [Figure 20-2](ch20.xhtml#ch20fig2). The documentation for our version
    of the library can be found at *[https://www.lane-fu.com/linuxmirror/libgpiod/doc/html/index.html](https://www.lane-fu.com/linuxmirror/libgpiod/doc/html/index.html)*.
    If you prefer to use Python, see “Your Turn” [exercise 20.2](ch20.xhtml#ch20exe2)
    on [page 460](ch20.xhtml#ch20you1).
  prefs: []
  type: TYPE_NORMAL
- en: '*blink_led.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-1: A C program to blink an LED using the GPIO*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When compiling this file, we need to explicitly specify the `libgpiod` library
    at the end of the command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `struct gpiod_chip` and `struct gpiod_line` are declared in the *gpiod.h*
    header file ❶ as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This C syntax is a way to define the `chip` and `line` pointer variables as
    holding addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi has several GPIO chips. GPIO chip 0 is connected to the GPIO
    header pins on models 3 and 4; GPIO chip 4 is connected to the GPIO header pins
    on the Raspberry Pi 5, so you if you’re using that model you’ll need to change
    `gpiochip0` to `gpiochip4` ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Once the GPIO line is configured to be an output, we turn the bit on and off
    to blink the LED ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at how we can use assembly language to blink the LED.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The assembly language code we’ll be using is not robust. It’s intended to
    provide an overview of how I/O devices are programmed. If you want to use the
    GPIO to control external devices, I recommend using the functions in the* libgpiod
    *library. It’s integrated with the operating system to provide robust functioning
    of the GPIO.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Blinking an LED in Assembly Language, Models 3 and 4***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The function of each GPIO device line is selected through six 32-bit registers,
    named GPFSEL0 through GPFSEL5\. Three bits are used to select the function of
    a GPIO device line. Registers GPFSEL0 through GPFSEL4 each select the function
    of 10 lines, with 2 unused bits. The GPFSEL5 register on model 3 selects the functions
    of 4 lines, leaving 20 unused bits, and on model 4 the GPFSEL5 register selects
    the functions of 8 lines, leaving 8 unused bits.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend downloading the datasheet for your Raspberry Pi—the Broadcom BCM2835
    SoC datasheet at *[https://datasheets.raspberrypi.com/bcm2835/bcm2835-peripherals.pdf](https://datasheets.raspberrypi.com/bcm2835/bcm2835-peripherals.pdf)*
    for the model 3 or the Broadcom BCM-2711 SoC datasheet at *[https://datasheets.raspberrypi.com/bcm2711/bcm2711-peripherals.pdf](https://datasheets.raspberrypi.com/bcm2711/bcm2711-peripherals.pdf)*
    for the model 4—for reference while reading this section. It’s not easy to read
    the datasheets, but going back and forth between the explanation here and the
    datasheet for your model should help you learn how to read it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that I only tested this program on my Raspberry Pi 3\. The datasheet for
    the Raspberry Pi 4 shows that the GPIO registers are the same as on the model
    3, so this code should also work on a model 4.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 20-2](ch20.xhtml#ch20list2) shows our assembly language program to
    blink an LED.'
  prefs: []
  type: TYPE_NORMAL
- en: '*blink_led.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-2: An assembly language program to blink an LED using the GPIO*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C program in [Listing 20-1](ch20.xhtml#ch20list1) uses library functions
    provided by the operating system to control the GPIO line. Our assembly language
    program in [Listing 20-2](ch20.xhtml#ch20list2) accesses the GPIO registers directly.
    The operating system only allows a user with root privileges to do that, so we
    need to run the program with `sudo`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Linux treats I/O devices as files. They are listed by name in the */dev* directory.
    The */dev/mem* file is an image of main memory. Addresses in this file represent
    physical memory addresses. Opening the file with the `open` system call function
    gives us access to the I/O device’s physical memory ❹. Its man page gives us the
    prototype for the `open` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The pathname is the full path and name of the file or device to be opened. The
    man page lists the names of the flags that must be passed to the `open` function
    to specify how it can be accessed by the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: The numerical value of each flag can be found in the header file at */usr/include/asm-generic/fcntl.h*.
    The header file is written in C, so we can’t use the `.include` directive to add
    it into our assembly language source code. I’ve used the `.equ` directive to define
    the flags we need in the `open` function. The assembler supports arithmetic and
    logic operations on literal values. We use the OR operator (`|`) to combine the
    different flags we need into a single 32-bit integer for the flags argument ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The operating system prevents application programs from directly accessing the
    I/O memory address space. We need to tell the operating system to map the GPIO
    memory address space into the application memory address space so we can access
    the GPIO registers in our application.
  prefs: []
  type: TYPE_NORMAL
- en: The I/O peripheral address space begins at different places, depending on the
    Raspberry Pi model. The GNU assembler has directives that allow us to select which
    lines of code to include in the assembly. We use the `.if` directive together
    with a series of `.elseif` directives to select the value of `PERIPHS` according
    to the model we’re using ❷. Using a `.if` directive with a `.else` directive selects
    the correct offset of the GPIO registers from the beginning address of the I/O
    peripherals. A single `.equ` directive sets `RPI_MODEL` to control these *conditional
    assembly* directives ❶. Don’t forget to end each `.if` construct with a `.endif`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `mmap` system call function, specified in the POSIX standard, to
    map the GPIO registers into application memory ❺. Its man page gives us the prototype
    for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If addr is `0`, the operating system chooses the application memory address
    for the mapping. The length is the number of bytes we’ll need for all the registers
    on the device. The mapping will use an integral number of pages. I’ve chosen 4MB
    to ensure we include all the I/O registers used for programming the GPIO in all
    the Raspberry Pi models.
  prefs: []
  type: TYPE_NORMAL
- en: The man page for `mmap` lists the prot values that must be passed to the function
    to specify how it can be accessed by the calling function. The man page also lists
    values for the flags, which specify how access is treated by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The numerical value of each prot and flag can be found in the header file */usr/include/asm-generic/mman-common.h*.
    The header file is also written in C, so I have used `.equ` directives to define
    the prot and flags we need in this function.
  prefs: []
  type: TYPE_NORMAL
- en: After calling the `open` and `mmap` functions to make the GPIO registers accessible
    through application memory, we use the `close` function to release the file descriptor.
    The GPIO registers remain accessible to our application program.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can access the I/O registers on the GPIO through application memory
    addressing, we program our GPIO line to be an output. As you’ll see in the next
    section, the method for doing this is different for the Raspberry Pi 5 ❻. After
    setting up the GPIO as an output, we enter a loop where we alternately turn the
    LED on and off. Again, a different method is used for the Raspberry Pi 5 ❼ ❽.
    We leave the LED in its on or off state for a few seconds using the `sleep` function
    from the `unistd` library.
  prefs: []
  type: TYPE_NORMAL
- en: Although the program will release the application memory we used for the GPIO
    registers when it ends, it’s good practice to call the `munmap` function to release
    the memory in your program when it’s no longer needed ❾.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a GPIO line as an output is done with the function shown in [Listing
    20-3](ch20.xhtml#ch20list3).
  prefs: []
  type: TYPE_NORMAL
- en: '*gpio_line_to_output.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-3: Making a GPIO line an output in most Raspberry Pi models*'
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO has six 32-bit function-select registers, GPFSEL0 through GPFSEL5\.
    Each of these registers is divided into 10 3-bit fields, named FSEL*n*, where
    *n* = 0, 1, . . . , 57\. Bits 2 through 0 in GPFSEL0 are the FSEL0 field, bits
    5 through 3 are the FSEL1 field, and so forth up to bits 23 through 21 in GPFSEL5
    for the FSEL57 field. Bits 31 and 30 in GPFSEL0 through GPFSEL4 and bits 31 through
    24 in GPFSEL5 are unused. All the lines can be configured as an input, `000`,
    or an output, `001`. Some lines can be configured to have other functionalities;
    FSEL*n* specifies the functionality of GPIO line *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing the GPIO line number by 10 gives us the number of the GPFSEL register
    ❶. The remainder from this division gives us the number of the FSEL field in the
    register ❷. For example, our program uses GPIO line 17, and its function is controlled
    by the seventh FSEL field in the GPFSEL1 register.
  prefs: []
  type: TYPE_NORMAL
- en: The GPFSEL registers are located at the beginning of the GPIO memory, so multiplying
    the GPFSEL register number by 4 gives us the memory address offset of the register
    ❸. Each FSEL field is 3 bits, so we multiply the FSEL number by 3 to get the relative
    bit position in the GPFSEL register ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make sure we don’t change any of the other FSEL fields in the GPFSEL
    register. After loading a copy of the GPFSEL register into a CPU register, we
    use a 3-bit mask to clear our FSEL field with the `bic` instruction ❺:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bic`—Bit clear'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`bic w`d`, w`s1`, w`s2`{,`shft amnt`}` performs a bitwise AND between `w`s1
    and `w`s2, optionally shifted amnt bits before the AND, storing the result in
    `w`d. The shft can be `lsl`, `lsr`, `0` to `31`. The default is no shift.'
  prefs: []
  type: TYPE_NORMAL
- en: '`bic x`d`, x`s1`, x`s2`{,`shft amnt`}` performs a bitwise AND between `x`s1
    and `x`s2, optionally shifted amnt bits before the AND, storing the result in
    `x`d. The shft can be `lsl`, `lsr`, `asr`, or `ror`. The amnt can be `0` to `63`.
    The default is no shift.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we shift our function code to the FSEL field position in the GPFSEL register,
    use the `orr` instruction to insert the function code, and update the mapped GPIO
    memory ❻.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although we have mapped the GPIO registers into application memory addresses,
    we can’t directly examine the contents of these registers with* gdb *because it
    uses a different technique for accessing memory addresses than the* mmap *function.
    I’ll show you another way to examine the register contents in* gdb *in “Your Turn”
    [exercise 20.3](ch20.xhtml#ch20exe3) on [page 460](ch20.xhtml#ch20you1).*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up the GPIO line as a 1-bit output device, we can control
    the voltage it outputs. The line is always ready for us to change the voltage,
    so we don’t need to check its status. We’ll use the `gpio_line_set` function in
    [Listing 20-4](ch20.xhtml#ch20list4) to set the line, which places it at +3.3
    V.
  prefs: []
  type: TYPE_NORMAL
- en: '*gpio_line_set.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-4: Setting a GPIO line in most Raspberry Pi models*'
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO has two 32-bit output-set registers, GPSET0 and GPSET1\. The GPSET0
    register is located `0x1c` bytes from the beginning of GPIO memory ❶. The GPSET1
    register immediately follows at `0x20`. Bits 31 through 0 in GPSET0 control lines
    31 through 0, and bits 21 through 0 in GPSET1 control lines 53 through 32\. The
    GPIO header pins are connected only to GPIO lines 27 through 0, so this function
    only works with GPSET0.
  prefs: []
  type: TYPE_NORMAL
- en: The GPSET registers are write-only. Unlike the GPFSEL registers, we don’t load
    the contents of a GPSET register; we simply shift a `1` to the bit position corresponding
    to the line we’re using as an output and set the line with a `str` instruction,
    placing +3.3 V on the line ❷. Writing a `0` to a bit position has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: When we want to change the output of the line to 0.0 V, we clear the line, as
    shown in [Listing 20-5](ch20.xhtml#ch20list5).
  prefs: []
  type: TYPE_NORMAL
- en: '*gpio_line_clr.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-5: Clearing a GPIO line in most Raspberry Pi models*'
  prefs: []
  type: TYPE_NORMAL
- en: Like the set registers, the GPIO has two 32-bit output-clear registers, GPCLR0
    and GPCLR1\. GPCLR0 is located 12 bytes beyond GPSET0 ❶. They are programmed the
    same way as the GPSET registers, except that storing a `1` in a bit position corresponding
    to a line that is selected as an output clears the line, placing 0.0 V on the
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at blinking an LED on a Raspberry Pi 5, which uses a very different
    programming interface to the GPIO.
  prefs: []
  type: TYPE_NORMAL
- en: '***Blinking an LED in Assembly Language, Model 5***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `main` function in [Listing 20-2](ch20.xhtml#ch20list2) is designed to work
    for the Raspberry Pi 5 if you simply change the `RPI_MODEL` to `5`. The conditional
    assembly directives will then select the appropriate values and function calls.
    But the methods for controlling the GPIO are different. Let’s see how it’s done
    on the Raspberry Pi 5.
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO circuitry on the Raspberry Pi 5 is on the RP1 chip. The documentation
    is incomplete as of this writing, but a preliminary draft of *RP1 Peripherals*
    (November 2023) is available at *[https://datasheets.raspberrypi.com/rp1/rp1-peripherals.pdf](https://datasheets.raspberrypi.com/rp1/rp1-peripherals.pdf)*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a GPIO line to be an output on a Raspberry Pi 5 is different from on
    the other models. [Listing 20-6](ch20.xhtml#ch20list6) shows our function to do
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '*gpio_5_line _to_output.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-6: A function to make a GPIO line an output on the Raspberry Pi
    5*'
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi 5 GPIO device has 28 pairs of registers, which are called GPIO0_STATUS,
    GPIO0_CTRL, GPIO1_STATUS, GPIO1_CTRL through GPIO27_STATUS, and GPIO27_CTRL. The
    address offset of the GPIO*n*_CTRL register corresponding to GPIO line *n* is
    8 × *n* ❶. Bits 4 through 0 set the function.
  prefs: []
  type: TYPE_NORMAL
- en: RP1 provides a set of *registered I/O (RIO)* registers to control the GPIO lines.
    To use the RIO interface, we store the `SYS_RIO` function in the GPIO control
    register ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The output circuit of a GPIO line is called a *pad*. We can set the characteristics
    of the output pad in several ways—for example, to either 2, 4, 8, or 12 mA. We
    set it to 4 mA for blinking an LED ❸. We complete our setup of the GPIO line by
    making it an output device ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up the GPIO line as a 1-bit output device, we can control
    the voltage that it outputs. The RIO interface to the GPIO has four registers
    for controlling the lines. [Table 20-2](ch20.xhtml#ch20tab2) shows the offset
    of each register from the RIO base.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 20-2:** RIO Register Offsets'
  prefs: []
  type: TYPE_NORMAL
- en: '| Offset | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0x0000` | Normal read/write |'
  prefs: []
  type: TYPE_TB
- en: '| `0x1000` | XOR on write |'
  prefs: []
  type: TYPE_TB
- en: '| `0x2000` | Bitmask set on write |'
  prefs: []
  type: TYPE_TB
- en: '| `0x3000` | Bitmask clear on write |'
  prefs: []
  type: TYPE_TB
- en: Bit *n* in each register corresponds to the GPIO*n* line. Storing a word to
    one of these registers causes the action to be taken on the GPIO line(s). Bit-mask
    set or clear means that only the bits that are `1` act on the corresponding GPIO
    lines. A `0` in a bit position has no effect on the corresponding GPIO line. The
    separate set and clear registers mean that we don’t need to read the contents
    of a register, make our changes, and write the result back.
  prefs: []
  type: TYPE_NORMAL
- en: A GPIO line configured for output is always ready for us to change the voltage,
    so we don’t need to check its status. We’ll use the `gpio_5_line_set` function
    in [Listing 20-7](ch20.xhtml#ch20list7) to set the line, which places it at +3.3
    V.
  prefs: []
  type: TYPE_NORMAL
- en: '*gpio_5_line_set.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-7: A function to set a GPIO line on the Raspberry Pi 5*'
  prefs: []
  type: TYPE_NORMAL
- en: We move a `1` to the bit position corresponding to our line number ❷. Then,
    we store this word in the RIO set register, which places the GPIO line at the
    high voltage ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm to clear a line is the same as the one to set it, as shown in
    [Listing 20-8](ch20.xhtml#ch20list8).
  prefs: []
  type: TYPE_NORMAL
- en: '*gpio_5_line_clr.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-8: A function to clear a GPIO line on the Raspberry Pi 5*'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference in the `gpio_line_clr` function is that we use the RIO clear
    register to place the GPIO line at the low voltage ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Blinking an LED is a very simple example of performing output. We don’t have
    to check to see if the line is ready for us to turn it on or off; we just send
    a command to the device. Most I/O isn’t this simple. It takes some time to form
    an image to display on a screen, or to convert a keystroke on a keyboard to a
    bit pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I’ll give you a general overview of how our program code
    deals with these timing issues.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 20.1   The typical voltage drop across an LED is 2 to 3 V when it’s on, depending
    on its color. Compute the amount of current you expect to flow through the LED
    in the circuit in [Figure 20-2](ch20.xhtml#ch20fig2) when the LED is on.
  prefs: []
  type: TYPE_NORMAL
- en: 20.2   Write a program in Python to blink an LED five times at three-second
    intervals. Refer to*[https://www.raspberrypi.com/documentation/computers/os.html#use-gpio-from-python](https://www.raspberrypi.com/documentation/computers/os.html#use-gpio-from-python)*
    for hints on how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 20.3   Modify the `main` function in [Listing 20-2](ch20.xhtml#ch20list2) to
    alternately blink LEDs attached to GPIO lines 16 and 17\. If you’re using a Raspberry
    Pi model other than the 5, run the program under `gdb` and set breakpoints in
    the `gpio_line_to_output` function so you can see that the appropriate function
    codes are stored in the GPFSEL0 register. You can get a better view of this if
    you add an `ldr w7, [x0]` instruction to `gpio_line_to_output` just before the
    `ret` instruction. Programmers sometimes add code like this for debugging purposes,
    which is usually deleted in the final product.
  prefs: []
  type: TYPE_NORMAL
- en: 20.4   Modify the assembly language LED blinking program to blink the LED every
    0.5 seconds. You’ll need to use the `usleep` function. The integer argument to
    this function is the number of microseconds to sleep.
  prefs: []
  type: TYPE_NORMAL
- en: 20.5   If you’re using a Raspberry Pi 5, write a program in assembly language
    to toggle an LED on and off five times using a single `gpio_5_line_toggle` function
    instead of the `gpio_5_line_set` and `gpio_5_line_clr` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Polled I/O Programming Algorithms**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at some simple polling algorithms that show how we might program
    a *universal asynchronous receiver/transmitter (UART)* for I/O.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used as an output device, a UART performs parallel-to-serial conversion
    to transmit a byte of data 1 bit at a time. As an input device, a UART receives
    the bits one at a time and performs serial-to-parallel conversion to reassemble
    the byte that was sent to it. Thus, an 8-bit byte can be transmitted and received
    using only three wires: transmit, receive, and common. Both the transmitting and
    receiving UARTs must be set at the same bit rate.'
  prefs: []
  type: TYPE_NORMAL
- en: In the idle state, the transmitting UART places the high voltage on the transmission
    line. When a program outputs a byte to the UART, the transmitting UART first sends
    a *start bit*; it does this by placing the transmission line at the low voltage
    for the amount of time it takes to transmit one bit, corresponding to the agreed-upon
    bit rate.
  prefs: []
  type: TYPE_NORMAL
- en: After the start bit, the transmitter sends the data bits at the agreed-upon
    bit rate. The UART uses a shift register to shift the byte 1 bit at a time, setting
    the voltage on the output line accordingly. Most UARTs start with the low-order
    bit. When the entire byte has been sent, the UART returns the output line to the
    idle state for at least 1 bit time, thus sending at least one *stop bit*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-3](ch20.xhtml#ch20fig3) shows how a UART with typical settings would
    send the two characters *m* and *n* encoded in ASCII.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg489_Image_320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-3: A UART output to send the characters* m *and* n'
  prefs: []
  type: TYPE_NORMAL
- en: The receiving UART watches the transmission line, looking for a start bit. When
    it detects a start bit, it uses a shift register to reassemble the individual
    bits into a byte, which it provides to the receiving program as input.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the 16550 UART, a common type, for our programming example. The 16550
    UART has 13 8-bit registers, shown in [Table 20-3](ch20.xhtml#ch20tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 20-3:** The Registers of the 16550 UART'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Address | DLAB | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `RHR` | `000` | `0` | Receiver holding (input byte) |'
  prefs: []
  type: TYPE_TB
- en: '| `THR` | `000` | `0` | Transmitter holding (output byte) |'
  prefs: []
  type: TYPE_TB
- en: '| `IER` | `001` | `0` | Interrupt enable (set type of interrupt) |'
  prefs: []
  type: TYPE_TB
- en: '| `ISR` | `010` | `x` | Interrupt status (show type of interrupt) |'
  prefs: []
  type: TYPE_TB
- en: '| `FCR` | `010` | `x` | FIFO control (set FIFO parameters) |'
  prefs: []
  type: TYPE_TB
- en: '| `LCR` | `011` | `x` | Line control (set communications format) |'
  prefs: []
  type: TYPE_TB
- en: '| `MCR` | `100` | `x` | Modem control (set interface with modem) |'
  prefs: []
  type: TYPE_TB
- en: '| `LSR` | `101` | `x` | Line status (show status of data transfers) |'
  prefs: []
  type: TYPE_TB
- en: '| `MSR` | `110` | `0` | Modem status (show status of modem) |'
  prefs: []
  type: TYPE_TB
- en: '| `SCR` | `111` | `x` | Scratch |'
  prefs: []
  type: TYPE_TB
- en: '| `DLL` | `000` | `1` | Divisor latch (low-order byte) |'
  prefs: []
  type: TYPE_TB
- en: '| `DLM` | `001` | `1` | Divisor latch (high-order byte) |'
  prefs: []
  type: TYPE_TB
- en: '| `PSD` | `101` | `1` | Prescaler division |'
  prefs: []
  type: TYPE_TB
- en: The addresses in [Table 20-3](ch20.xhtml#ch20tab3) are address offsets from
    the UART’s base address. You probably noticed that some of the registers have
    the same offset. The functionality of the register at that offset depends on how
    our program treats it. For example, if the program loads from offset `000`, it’s
    loading from the receiver holding register (`RHR`). But if the program stores
    to offset `000`, it’s storing to the transmitter holding register (`THR`).
  prefs: []
  type: TYPE_NORMAL
- en: The divisor latch access bit (DLAB) is bit number 7 in the line control register
    (`LCR`). When it is set to `1`, offset `000` connects to the low-order byte of
    the 16-bit divisor latch value and offset `001` connects to the high-order byte
    of the divisor latch value.
  prefs: []
  type: TYPE_NORMAL
- en: The 16550 UART can be programmed for interrupt-driven I/O and direct memory
    access. It includes 16-byte first in, first out (FIFO) buffers on both the transmitter
    and the receiver registers. It can also be programmed to control a serial modem.
  prefs: []
  type: TYPE_NORMAL
- en: Older PCs typically connected the UART to a COM port. In past years, COM ports
    were often used to connect devices such as printers and modems to computers, but
    most PCs today use USB ports for serial I/O.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi has a 16550-like UART with the receiver and transmitter registers
    connected to GPIO lines. Programming the UART is beyond the scope of this book,
    but I’ll use C to give a general idea of how it’s done.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the C functions we’ll write in this section are meant only to show
    the concepts, not to do anything useful. In fact, running them will elicit an
    error message from the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll assume the UART is installed in a computer that uses memory-mapped I/O
    so I can show the algorithms in C. To keep things simple, I’ll do only polled
    I/O here, which requires these three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: UART_init   Initializes the UART. This includes setting parameters in the hardware,
    such as the speed and communications protocol.
  prefs: []
  type: TYPE_NORMAL
- en: UART_in   Reads one character that was received by the UART.
  prefs: []
  type: TYPE_NORMAL
- en: UART_out   Writes one character to be transmitted by the UART.
  prefs: []
  type: TYPE_NORMAL
- en: These three functions would allow us to use a UART to receive a character and
    then transmit that same character, as shown in [Listing 20-9](ch20.xhtml#ch20list9).
  prefs: []
  type: TYPE_NORMAL
- en: '*UART_echo.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-9: A function to use a UART to read and write a single character*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore only a few features of the UART. Let’s start with a file that
    provides symbolic names for the registers and some numbers we’ll be using in our
    example program, as shown in [Listing 20-10](ch20.xhtml#ch20list10).
  prefs: []
  type: TYPE_NORMAL
- en: '*UART_def.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-10: The definitions for a 16550 UART*'
  prefs: []
  type: TYPE_NORMAL
- en: The offsets to the registers are at fixed positions relative to the start of
    the mapped memory address of the UART. These offsets, and the status and control
    bit settings, are taken from a 16550 datasheet, which you can download at *[https://www.ti.com/product/TL16C550D](https://www.ti.com/product/TL16C550D)*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how I arrived at the value for the `SETCOM` control ❶. The communication
    parameters are set by writing 1 byte to the line status register. There can be
    5 to 8 bits in each data frame. The datasheet tells us that setting bits 1 and
    0 to `11` will specify 8 bits. Hence, I set `NBITS` to `0x03`. Setting bit 2 to
    `0` specifies one stop bit, so `STOPBIT` = `0x00`. I don’t use parity, which is
    bit 3, so `NOPARITY` = `0x00`. I combine these constants with the OR operator
    to create the byte that sets the communication parameters. Of course, we don’t
    really need the two zero values, but specifying them makes our intent explicit.
  prefs: []
  type: TYPE_NORMAL
- en: The unit *baud* is a measure of the speed of communication, defined as the number
    of symbols per second. A UART uses only two voltage levels for communication,
    symbolically `0` or `1`, or 1 bit. For a UART, the baud rate is equivalent to
    the number of bits transmitted or received per second. We need to set the DLAB
    bit to `1` to place our UART in the mode that allows us to set the baud rate ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a header file for declaring the functions, as shown in [Listing
    20-11](ch20.xhtml#ch20list11).
  prefs: []
  type: TYPE_NORMAL
- en: '*UART_functions.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-11: The UART function declarations*'
  prefs: []
  type: TYPE_NORMAL
- en: The header file declares the three basic functions for using our UART. I won’t
    cover the more advanced features of a UART in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll place the definitions of these three functions in one file, as shown in
    [Listing 20-12](ch20.xhtml#ch20list12), because they would typically be used together.
  prefs: []
  type: TYPE_NORMAL
- en: '*UART_functions.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-12: The UART memory-mapped I/O function definitions in C*'
  prefs: []
  type: TYPE_NORMAL
- en: The `UART_init` function sets the various communication parameters for the UART.
    The purposes of the values I used in this example are explained after [Listing
    20-10](ch20.xhtml#ch20list10).
  prefs: []
  type: TYPE_NORMAL
- en: The `UART_in` function waits in a `while` loop until the `RxRDY` bit becomes
    `1`, which occurs when the UART has a character ready to read from its receive
    holding register ❶. The character is read from the receive holding register with
    an assignment to a local variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `UART_out` function waits in a `while` loop until the `TxRDY` bit becomes
    `1`, which occurs when the UART is ready for us to send a character to the transmit
    holding register ❷. The character is sent with an assignment to the transmit holding
    register.
  prefs: []
  type: TYPE_NORMAL
- en: These functions provide an overall view of how a UART is used in a polling mode.
    I’ve omitted many details here that are required to ensure robust operation. If
    you would like to use one of the UARTs on a Raspberry Pi, you can start with the
    documentation at *[https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header](https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header)*.
    I recommend accessing the UART through the operating system instead of directly,
    as we did when blinking an LED earlier in this chapter. I have not used the UARTs
    on a Raspberry Pi, so I can’t vouch for any of them, but tutorials are available
    online.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Virtual memory** The memory address space used by a program.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory mapping unit (MMU)** A hardware device that uses a map table to convert
    virtual memory addresses to physical memory addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Translation lookaside buffer (TLB)** Memory in the MMU where the most recently
    used map table entries are cached.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory timing**   Memory access is synchronized with the timing of the CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: '**I/O timing**   I/O devices are much slower than the CPU and have a wide range
    of characteristics, so we need to program their access.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bus timing**   Buses are often arranged in a hierarchical manner to better
    match the differences in timing between various I/O devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Port-mapped I/O**   With this technique, I/O device registers have their
    own address space.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory-mapped I/O**   With this technique, I/O registers are given a portion
    of the main memory address space.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmed I/O**   The program transfers data directly from an input device
    or to an output device at the point where it’s needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Polled I/O**   The program waits in a loop until the I/O device is ready
    to transfer data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interrupt-driven I/O**   The I/O device interrupts the CPU when it is ready
    to transfer data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct memory access**   The I/O device can transfer data to and from main
    memory without using the CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: '**General-purpose I/O (GPIO)**   A general-purpose I/O device can be programmed
    to input or output a single bit of information.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about the CPU features that allow it to maintain
    control over the I/O hardware and prevent application programs from accessing
    the hardware without going through the operating system.
  prefs: []
  type: TYPE_NORMAL
