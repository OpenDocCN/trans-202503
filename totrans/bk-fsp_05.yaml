- en: Chapter 5. Let’s Get Functional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve mentioned several times that F# is a functional language, but as you’ve
    learned from previous chapters you can build rich applications in F# without using
    any functional techniques. Does that mean that F# isn’t really a functional language?
    No. F# is a general-purpose, multiparadigm language that allows you to program
    in the style most suited to your task. It is considered a functional-first language,
    meaning that its constructs encourage a functional style. In other words, when
    developing in F# you should favor functional approaches whenever possible and
    switch to other styles as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll see what functional programming really is and how functions
    in F# differ from those in other languages. Once we’ve established that foundation,
    we’ll explore several data types commonly used with functional programming and
    take a brief side trip into lazy evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Functional Programming?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming takes a fundamentally different approach toward developing
    software than object-oriented programming. While object-oriented programming is
    primarily concerned with managing an ever-changing system state, functional programming
    emphasizes immutability and the application of deterministic functions. This difference
    drastically changes the way you build software, because in object-oriented programming
    you’re mostly concerned with defining classes (or structs), whereas in functional
    programming your focus is on defining functions with particular emphasis on their
    input and output.
  prefs: []
  type: TYPE_NORMAL
- en: F# is an impure functional language where data is immutable by default, though
    you can still define mutable data or cause other side effects in your functions.
    Immutability is part of the functional concept called *referential transparency*,
    which means that an expression can be replaced with its result without affecting
    the program’s behavior. For example, if you can replace `let sum = add 5 10` with
    `let sum = 15` without otherwise affecting the program’s behavior, then `add`
    is said to be referentially transparent. But immutability and referential transparency
    are only two aspects of functional programming, and they certainly don’t make
    a language functional on their own.
  prefs: []
  type: TYPE_NORMAL
- en: Programming with Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve never done any “real” functional programming, F# will forever change
    the way you think about functions because its functions closely resemble mathematical
    functions in both structure and behavior. For example, [Chapter 3](ch03.html "Chapter 3. Fundamentals")
    introduced the `unit` type, but I avoided discussing its importance in functional
    programming. Unlike C# and Visual Basic, F# makes no distinction between functions
    that return values and those that don’t. In fact, every function in F# accepts
    exactly one input value and returns exactly one output value. The `unit` type
    enables this behavior. When a function doesn’t have any specific input (no parameters),
    it actually accepts `unit`. Similarly, when a function doesn’t have any specific
    output, it returns `unit`.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that every F# function returns a value allows the compiler to make
    certain assumptions about your code. One important assumption is that the result
    of the last evaluated expression in a function is the function’s return value.
    This means that although `return` is a keyword in F#, you don’t need to explicitly
    identify return values.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A defining (and arguably the most important) characteristic of any functional
    language is that it treats functions like any other data type. The .NET Framework
    has always supported this concept to some degree with delegation, but until relatively
    recently delegation was too cumbersome to be viable in all but a few limited scenarios.
    Only when LINQ was introduced with the goodness of lambda expressions and the
    built-in generic delegate types (`Action` and `Func`) did delegation reach its
    full potential. F# uses delegation behind the scenes, but unlike C# and Visual
    Basic, its syntax abstracts away the delegation with the `->` token. The `->`
    token, generally read as “goes to” or “returns,” identifies a value as a *function
    value* where the data type specified on the left is the function’s input type
    and the data type on the right is its return type. For example, the signature
    for a function that both accepts and returns a string is `string -> string`. Similarly,
    a parameterless function that returns a string is represented as `unit -> string`.
  prefs: []
  type: TYPE_NORMAL
- en: Signatures become increasingly complex when you begin working with *higher-order
    functions*—functions that accept or return other functions. Higher-order functions
    are used extensively in F# (and functional programming in general) because they
    allow you to isolate common parts of functions and substitute the parts that change.
  prefs: []
  type: TYPE_NORMAL
- en: In some ways, higher-order functions are to functional programming what interfaces
    are to object-oriented programming. For example, consider a function that applies
    a transformation to a string and prints the result. Its signature might look something
    like `(string -> string) -> string -> unit`. This simple notation goes a long
    way toward making your code more comprehensible than when you’re dealing with
    the delegates directly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*You can use the function signatures in type annotations whenever you’re expecting
    a function. As with other data types, though, the compiler can often infer the
    function type.*'
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability Considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Despite the fact that F# functions are ultimately based on delegation, be careful
    when working with libraries written in other .NET languages, because the delegate
    types aren’t interchangeable. F# functions rely on the overloaded `FSharpFunc`
    delegate types, whereas traditional .NET delegates are often based on the `Func`
    and `Action` types. If you need to pass `Func` and `Action` delegates into an
    F# assembly, you can use the following class to simplify the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `FSharpFuncUtil` class defines the overloaded `ToFSharpFunc` method as traditional
    .NET extension methods (via the `ExtensionAttribute` on both the class and methods)
    so you can easily call them from another language. The first overload handles
    converting single-parameter `Func` instances, while the second handles single-parameter
    `Action` instances. These extension methods don’t cover every use case, but they’re
    certainly a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions in F# work a bit differently than you’re probably accustomed to. For
    example, consider the simple `add` function, introduced in [Chapter 2](ch02.html
    "Chapter 2. F# Interactive").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You might think that `add` accepts two parameters, but that’s not how F# functions
    work. Remember, in F# every function accepts exactly one input and returns exactly
    one output. If you create the preceding binding in FSI or hover over the name
    in Visual Studio, you’ll see that its signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, the name `add` is bound to a function that accepts an integer (`a`) and
    returns a function. The returned function accepts an integer (`b`) and returns
    an integer. Understanding this automatic function chaining—called *currying*—is
    critical to using F# effectively because it enables several other features that
    affect how you design functions.
  prefs: []
  type: TYPE_NORMAL
- en: To better illustrate how currying actually works, let’s rewrite `add` to more
    closely resemble the compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The most significant thing here is that both this and the previous version have
    exactly the same signature. Here, though, `add` accepts only a single parameter
    (`a`) and returns a separate function as defined by a lambda expression. The returned
    function accepts the second parameter (`b`) and invokes the multiplication operator
    as another function call.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the capabilities unlocked by curried functions is partial application.
    *Partial application* allows you to create new functions from existing ones simply
    by supplying some of the arguments. For example, in the case of `add`, you could
    use partial application to create a new `addTen` function that always adds 10
    to a number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice at ① how `addTen`’s definition and signature are listed. Although we
    didn’t explicitly include any parameters in the definition, the signature is still
    a function that both accepts and returns an integer. The compiler evaluated the
    curried `add` function as far as it could with the provided arguments (just `10`,
    in this case) and bound the resulting function to the name, `addTen`.
  prefs: []
  type: TYPE_NORMAL
- en: Currying applies arguments one at a time, from left to right, so partially applied
    arguments must correspond to the function’s first parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Once you’re comfortable with currying and partial application, you may start
    thinking that you could simulate them in C# or Visual Basic by returning Func
    or Action instances. Don’t. Neither language is designed to support this type
    of functional programming, so simulating these concepts is inelegant at best and
    immensely error prone at worst.*'
  prefs: []
  type: TYPE_NORMAL
- en: Pipelining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another feature often associated with currying (and used extensively in F#)
    is pipelining. *Pipelining* allows you to create your own function chains by evaluating
    one expression and sending the result to another function as the final argument.
  prefs: []
  type: TYPE_NORMAL
- en: Forward Pipelining
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Usually you’ll send values forward to the next function using the *forward
    pipelining operator* (`|>`). If you don’t want to do anything with a function’s
    result when it returns something other than `unit`, you can pipe the result forward
    to the `ignore` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Pipelining isn’t restricted to simple scenarios like ignoring a result. As
    long as the last argument of the receiving function is compatible with the source
    function’s return type, you can create complex function chains. For example, suppose
    you have a list of daily temperatures in degrees Fahrenheit and want to find the
    average temperature, convert it to Celsius, and print the result. You could do
    it the old-fashioned, procedural way by defining a binding for each step, or you
    could use pipelining to chain the steps like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here the `marchHighTemps` list is piped to the `List` module’s `average` function.
    The `average` function is then evaluated and its result passed on to the `fahrenheitToCelsius`
    function. Finally, the average temperature in Celsius is passed along to `printfn`.
  prefs: []
  type: TYPE_NORMAL
- en: Backward Pipelining
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like its forward counterpart, the *backward pipelining operator* (`<|`) sends
    the result of an expression to another function as the final argument, but does
    it from right to left instead. Because it changes precedence within an expression,
    the backward pipelining operator is sometimes used as a replacement for parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: The backward pipelining operator can change the semantics of your code. For
    instance, in the `fahrenheitToCelsius` example in the previous section, the emphasis
    is on the list of temperatures because that’s what’s listed first. To change the
    semantics to emphasize the output, you could place the `printfn` function call
    ahead of the backward pipelining operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Noncurried Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although pipelining is typically associated with curried functions, it also
    works with noncurried functions (like methods) that accept only a single argument.
    For instance, to force a delay in execution you could pipe a value into the `TimeSpan`
    class’s static `FromSeconds` method and then send the resulting `TimeSpan` object
    to `Thread.Sleep`, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because neither the `TimeSpan` class nor the `Thread` class is defined in F#,
    the functions aren’t curried, but you can see how we can chain these functions
    together with the forward pipelining operator.
  prefs: []
  type: TYPE_NORMAL
- en: Function Composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like pipelining, *function composition* allows you to create function chains.
    It comes in two forms: forward (`>>`) and backward (`<<`).'
  prefs: []
  type: TYPE_NORMAL
- en: Function composition is subject to the same rules as pipelining regarding inputs
    and outputs. Where function composition differs is that instead of defining a
    one-time operation, the composition operators actually generate new functions.
    Continuing with our average temperature example, you could easily create a new
    function from the `List.average` and `fahrenheitToCelsius` functions with the
    forward composition operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The composition operator results in a new function that accepts a list of floats
    and returns a float. Now, instead of calling the two functions independently,
    you can simply call `averageInCelsius` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As with pipelining, you can compose functions from noncurried functions. For
    instance, you could compose the forced delay example from [Noncurried Functions](ch05.html#noncurried_functions
    "Noncurried Functions") as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, you can now call the `delay` function to temporarily pause
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Recursive Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are typically three looping constructs associated with imperative code:
    `while` loops, simple `for` loops, and enumerable `for` loops. Because each relies
    on a state change to determine when the exit criteria have been met, you’ll need
    to take a different approach to looping when writing purely functional code. In
    functional programming, the preferred looping mechanism is *recursion*. A *recursive
    function* is one that calls itself either directly or indirectly through another
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: Although methods within a type are implicitly recursive, `let`-bound functions,
    such as those defined within a module, are not. To make a `let-`bound function
    recursive, you must include the `rec` keyword in its definition, as this factorial
    function illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `rec` keyword instructs the compiler to make the function name available
    within the function but does not otherwise change the function’s signature (`int64
    -> int64`).
  prefs: []
  type: TYPE_NORMAL
- en: Tail-Call Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The preceding factorial example is simple, but it suffers from a major flaw.
    For example, consider what happens when you call `factorial 5`. On each recursive
    iteration (other than when the value is 1), the function calculates the product
    of `v` and the factorial of `v - 1`. In other words, calculating the factorial
    for a given value inherently requires each subsequent factorial call to complete.
    At run time, it looks a bit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet shows that each call is added to the stack. It’s unlikely
    that this would be a problem with a factorial function, since the calculation
    can quickly overflow the data type, but more complex recursion scenarios could
    result in running out of stack space. To address this problem, you can revise
    the function to use a *tail call* by removing the dependency on subsequent iterations,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The revised factorial function ① creates and then calls a nested recursive function,
    `fact` ②, to isolate the implementation details. The `fact` function accepts both
    the current iteration value (`c`) and the product calculated by the previous iteration
    (`p`). At ③ (the nonzero case), the `fact` function makes the recursive call.
    (Notice how only the arguments to the recursive call are calculated here.) Finally,
    to initiate recursion, the `factorial` function ④ invokes the first `fact` iteration,
    passing the supplied value and `1L`.
  prefs: []
  type: TYPE_NORMAL
- en: Although the recursive call is still present in the code, when the F# compiler
    detects that no iteration is dependent on subsequent iterations, it optimizes
    the compiled form by replacing the recursion with an imperative loop. This allows
    the system to iterate as long as necessary. You can observe this optimization
    by examining the stack traces for each version by inserting a breakpoint and looking
    at the call stack window (if you’re running this as a console application) or
    by printing out the stack information returned from `System.Diagnostics.StackTrace`,
    as shown here. (Note that your namespaces will likely vary.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Mutually Recursive Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When two or more functions call each other recursively, they are said to be
    *mutually recursive*. Like mutually recursive types (described in [Chapter 4](ch04.html
    "Chapter 4. Staying Objective")), mutually recursive functions must be defined
    together with the `and` keyword. For example, a Fibonacci number calculation is
    easily expressed through mutual recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `fibonacci` function defines two mutually recursive functions,
    `f` and `g`. (The function keyword inside each is a shortcut for pattern matching.)
    For all values other than 1, `f` calls `g`. Similarly, `g` recursively calls itself
    and `f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the mutual recursion is hidden inside `fibonacci`, consumers of this
    code can simply call `fibonacci` directly. For example, to compute the sixth number
    in the Fibonacci sequence you’d write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Mutual recursion can be useful, but this example is really only good for illustrating
    the concept. For performance reasons, a more realistic Fibonacci example would
    likely forego mutual recursion in favor of a technique called *memoization*, where
    expensive computations are performed once and the results are cached to avoid
    calculating the same values multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve ever used LINQ or done any other functional programming, you’re probably
    already familiar with *lambda expressions* (or *function expressions*, as they’re
    sometimes called). Lambda expressions are used extensively in functional programming.
    In brief, they provide a convenient way to define simple, single-use, anonymous
    (unnamed) functions. Lambda expressions are typically favored over let-bound functions
    when the function is significant only within its context (such as when filtering
    a collection).
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda expression syntax is similar to that of a function value except that
    it begins with the `fun` keyword, omits the function identifier, and uses the
    arrow token (`->`) in place of an equal sign. For example, you could express the
    Fahrenheit-to-Celsius conversion function inline as a lambda expression and immediately
    evaluate it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although defining ad hoc functions like this is certainly one use for lambda
    expressions, they’re more commonly created inline with calls to higher-order functions,
    or included in pipeline chains.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Closures* enable functions to access values visible in the scope where a function
    is defined regardless of whether that value is part of the function. Although
    closures are typically associated with lambda expressions, nested functions created
    with `let` bindings can be closures as well, since ultimately they both compile
    to either an `FSharpFunc` or a formal method. Closures are typically used to isolate
    some state. For instance, consider the quintessential closure example—a function
    that returns a function that manipulates an internal counter value, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `createCounter` function defines a reference cell that’s captured by the
    returned function. Because the reference cell is in scope when the returned function
    is created, the function has access to it no matter when it’s called. This allows
    you to simulate a stateful object without a formal type definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To observe the function modifying the reference cell’s value, we just need
    to invoke the generated function and call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Functional Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# includes native support for several additional data types. These types—tuples,
    records, and discriminated unions—are typically associated with functional programming,
    but they’re often useful in mixed-paradigm development as well. While each of
    these types has a specific purpose, they’re all intended to help you remain focused
    on the problem your software is trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most basic functional type is the *tuple*. Tuples are a convenient way to
    group a number of values within a single immutable construct without creating
    a custom type. Tuples are expressed as comma-delimited lists and are sometimes
    enclosed in parentheses. For example, the following two definitions representing
    geometric points as tuples are equally valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature for a tuple type includes the type of each value separated by
    an asterisk (`*`). The asterisk is used as the tuple element delimiter for mathematical
    reasons: Tuples represent the Cartesian product of all values their elements contain.
    Therefore, to express a tuple in a type annotation, you write it as an asterisk-delimited
    list of types like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Despite some syntactic similarities, particularly when the values are enclosed
    in parentheses, it’s important to recognize that other than the fact that they
    contain multiple values, tuples aren’t collections; they simply group a fixed
    number of values within a single construct. The tuple types don’t implement `IEnumerable<'T>`,
    so they can’t be enumerated or iterated over in an enumerable `for` loop, and
    individual tuple values are exposed only through properties with nonspecific names
    like `Item1` and `Item2`.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples in .NET
  prefs: []
  type: TYPE_NORMAL
- en: Tuples have always been part of F# but were only introduced to the larger .NET
    Framework with .NET 4\. Prior to .NET 4, the tuple classes were located in the
    `FSharp.Core` library, but they have since been moved to `mscorlib`. This difference
    is only really important if you intend to write cross-language code against earlier
    versions of the .NET Framework, because it affects which assembly you reference.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tuples are often useful for returning multiple values from a function or for
    sending multiple values to a function without currying them. For instance, to
    calculate the slope of a line you could pass two points as tuples to a `slope`
    function. To make the function work, though, you’ll need some way to access the
    individual values. (Fortunately, tupled values are always accessible in the order
    in which they’re defined, so some of the guesswork is eliminated.)
  prefs: []
  type: TYPE_NORMAL
- en: When working with *pairs* (tuples containing two values like the geometric points
    we discussed previously), you can use the `fst` and `snd` functions to retrieve
    the first and second values, respectively, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we define bindings for the various coordinates with the `fst` and
    `snd` functions. As you can see, however, extracting each value this way can get
    pretty tedious and these functions work only with pairs; if you were to try either
    against a *triple* (a tuple with three values), you’d get a type mismatch. (The
    reason is that at their core, tuples compile to one of the nine generic overloads
    of the `Tuple` class.) Aside from sharing a common name, the tuple classes are
    independent of each other and are otherwise incompatible.
  prefs: []
  type: TYPE_NORMAL
- en: A more practical approach to extract tuple values involves introducing a *Tuple
    pattern*. Tuple patterns allow you to specify an identifier for each value in
    the tuple by separating the identifiers with commas. For example, here’s the `slope`
    function revised to use Tuple patterns instead of the pair functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can see how Tuple patterns may help, but you need to be careful with them.
    If your pattern doesn’t match the number of values in the tuple, you’ll get a
    type mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, unlike the pair functions, resolving the problem is simply a matter
    of adding or removing identifiers. If you don’t care about a particular value
    in your Tuple pattern, you can ignore it with the Wildcard pattern (`_`). For
    instance, if you have three-dimensional coordinates but care only about the z-coordinate,
    you could ignore the x- and y-values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tuple patterns aren’t limited to `let` bindings. In fact, we can make a further
    revision to the `slope` function and include the patterns right in the function
    signature!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Equality Semantics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Despite the fact that they’re formally reference types, each of the built-in
    tuple types implements the `IStructuralEquatable` interface. This ensures that
    all equality comparisons involve comparing the individual component values rather
    than checking that two tuple instances reference the same `Tuple` object in memory.
    In other words, two tuple instances are considered equal when the corresponding
    component values in each instance are the same, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For the same reasons that the `fst` and `snd` functions work only with pairs,
    comparing tuples of different lengths will cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic Tuples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, all of the tuples we’ve looked have been concrete ones, but F# also
    includes *syntactic tuples*. For the most part, syntactic tuples are how F# works
    around noncurried functions in other languages. Because F# functions always accept
    a single parameter, but functions in C# and Visual Basic can accept more than
    one, in order to call functions from libraries written in other languages you
    can use a syntactic tuple and let the compiler work out the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `String` class’s `Format` method accepts both a format string
    and a `params` array of values. If `String.Format` were a curried function, you’d
    expect its signature to be something like `Format : format:string -> params args
    : obj [] -> string`, but it’s not. Instead, if you hover your cursor over the
    function name in Visual Studio, you’ll see that its signature is actually `Format(format:string,
    params args : obj []) : string`. This distinction is significant because it means
    that the arguments must be applied as a group rather than individually as they
    would with curried functions. If you were to try invoking the method as a curried
    F# function, you’d get an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct way to call `String.Format` in F# is with a syntactic tuple, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You’ve probably noticed that F# generally doesn’t require parentheses around
    arguments when calling a function; it uses parentheses primarily to establish
    precedence. Because functions are applied from left to right, you’ll mainly use
    parentheses in a function call to pass the result of another function as an argument.
    In this case, the parentheses around the arguments are necessary. Without them,
    the left-to-right evaluation would cause the compiler to essentially treat the
    expression as `((System.String.Format "hello {0}"), "Dave")`. In general, it’s
    good practice to include parentheses around syntactic tuples in order to remove
    any ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: Out Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: F# doesn’t directly support `out` parameters—parameters passed by reference
    with values assigned in the method body so they can be returned to the caller.
    To fully support the .NET Framework, however, F# needs a way to access `out` parameter
    values. For example, the `TryParse` methods on the various numeric data type classes
    attempt to convert a string to the corresponding numeric type and return a Boolean
    value indicating success or failure. If the conversion succeeds, the `TryParse`
    methods set the `out` parameter to the appropriate converted value. For instance,
    calling `System.Int32.TryParse` with `"10"` would return `true` and set the `out`
    parameter to `10`. Similarly, calling the same function with `"abc"` would return
    `false` and leave the `out` parameter unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, calling `System.Int32.TryParse` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The problem with `out` parameters in a functional language is that they require
    a side effect, as shown by the uninitialized variable at ①. To work around this
    problem, the F# compiler converts the return value and `out` parameter to a pair.
    Therefore, when you invoke a method with an `out` parameter in F#, you treat it
    exactly like any other tuple-returning function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the same `Int32.TryParse` method in F# looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For a behind-the-scenes look at the generated class, we can once again turn
    to ILSpy to see how it’s represented in C#.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, the F# compiler wrapped the `Int32.TryParse` call inside a static class.
    The generated class’s static constructor ① invokes `TryParse` at ③ and wraps the
    results in a tuple at ②. Then, the internal `v@3` and `r@3` fields are assigned
    to the `out` parameter value and the return value at ④ and ⑤, respectively. In
    turn, the `v` and `r` values defined by the `let` binding are compiled to read-only
    properties that return the `v@3` and `r@3` values.
  prefs: []
  type: TYPE_NORMAL
- en: Record Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like tuples, *record types* allow you to group values in a single immutable
    construct. You might think of them as bridging the functional gap between tuples
    and your own classes. Record types provide many of the same conveniences as tuples,
    like simple syntax and value equality semantics, while offering you some control
    over their internal structure and allowing you to add custom functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Record Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Record type definitions consist of the `type` keyword, an identifier, and a
    list of labels with type annotations all enclosed in braces. For example, this
    listing shows a simple record type representing an RGB color.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you take a peek at what the compiler generates from this definition, you’ll
    see a sealed class with read-only properties, equality semantics, and a single
    constructor to initialize all values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*When defining record types on a single line, you must separate each label
    and type annotation pair by semicolons. If you place each pair on a separate line,
    you can safely omit the semicolons.*'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Records
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: New records are created via *record expressions*. Record expressions allow you
    to specify a value for each label in the record type. For example, you could create
    a new `rgbColor` instance using a record expression, as shown next. (Note that,
    as when defining a record type, you must separate each label or assignment pair
    by semicolons or place it on a line of its own.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice that nowhere in the record expression do we include an explicit reference
    to the `rgbColor` type. This is another example of F#’s type inference engine
    at work. Based on the labels alone, the compiler was able to infer that we were
    creating an instance of `rgbColor`. Because the compiler relies on the labels
    rather than position to determine the correct type, order doesn’t matter. This
    means that you can place the label and value pairs in any order. Here, we create
    an `rgbColor` instance with the labels in `G`, `B`, `R` order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike with tuples, we don’t need to use special value extraction functions
    like `fst` or `snd` with record types, because each value can be accessed by its
    label. For instance, a function that converts an `rgbColor` value to its hexadecimal
    string equivalent might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding Naming Conflicts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The compiler can usually infer the correct type, but it’s possible to define
    two record types with the same structure. Consider what happens when you add a
    `color` type with the same structure as `rgbColor`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Despite having two record types with the same structure, type inference still
    succeeds, but notice at ① that the resulting type is `color`. Due to F#’s top-down
    evaluation, the compiler uses the most recently defined type that matches the
    labels. If your goal was to define `red` as `color` you’d be fine, but if you
    wanted `rgbColor` instead you’d have to be a bit more explicit in your record
    expression and include the type name, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: By qualifying one of the names with the type name at ①, you bypass type inference
    and the correct type is resolved ②. (Although you can technically qualify the
    type on any name, the convention is to do it on either the first one or all of
    them.)
  prefs: []
  type: TYPE_NORMAL
- en: Copying Records
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Not only can you use record expressions to create new record instances from
    scratch, but you can also use them to create new record instances from existing
    ones by copying values forward and setting new values for one or more properties.
    The alternate syntax, called a *copy and update record expression*, makes it easy
    to create yellow from red, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To specify new values for multiple properties, separate them with semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: Mutability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Like virtually everything else in F#, record types are immutable by default.
    However, because their syntax is so convenient, they’re commonly used in place
    of classes. In many cases, though, these scenarios require mutability. To make
    record type properties mutable within F#, use the `mutable` keyword just as with
    a `let` binding. For instance, you could make all of `rgbColor`’s members mutable
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When a record type property is mutable, you can change its value with the standard
    assignment operator (`<-`) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Climutable
  prefs: []
  type: TYPE_NORMAL
- en: Although record types support binary serialization by default, other forms of
    serialization require a default constructor and writable properties. To allow
    for more situations where record types can be used in favor of classes, the F#
    team introduced the `CLIMutable` attribute in F# 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating a record type with this attribute instructs the compiler to include
    a default constructor and to make the generated properties read/write, but the
    compiler doesn’t expose those capabilities within F#. Even though the generated
    properties are writable, unless they’re explicitly marked as mutable with the
    `mutable` keyword in the record type definition, their values can’t be changed
    in F# code. For this reason, be careful when using `CLIMutable` record types across
    language boundaries to ensure that you don’t inadvertently change something.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Members
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because record types are really just syntactic sugar for classes, you can define
    additional members just as you would on a class. For example, you could augment
    `rgbColor` with a method that returns its hexadecimal string equivalent like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now you can call the `ToHexString` method on any `rgbColor` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional members on record types can also be static. For example, suppose
    you wanted to expose a few common colors as static properties on a record type.
    You could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The static `Red`, `Green`, and `Blue` properties behave like any other static
    member and can be used anywhere you need an `rgbColor` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can also create custom operators for your record types as static members.
    Let’s implement the addition operator to add two `rgbColor` instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator overload on `rgbColor` is defined and invoked like any other operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Discriminated Unions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Discriminated unions* are user-defined data types whose values are restricted
    to a known set of values called *union cases*. There are no equivalent structures
    in the other popular .NET languages.'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, you might mistake some simple discriminated unions for enumerations
    because their syntax is so similar, but they’re entirely different constructs.
    For one, enumerations simply define labels for known integral values, but they
    aren’t restricted to those values. By contrast, the only valid values for discriminated
    unions are their union cases. Furthermore, each union case can either stand on
    its own or contain associated immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `Option<'T>` type highlights each of these points. We’re really
    only interested in its definition here, so let’s take a look at that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`Option<''T>` defines two cases, `None` and `Some`. `None` is an empty union
    case, meaning that it doesn’t contain any associated data. On the other hand,
    `Some` has an associated instance of `''T` as indicated by the `of` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how discriminated unions enforce a specific set of values, let’s
    define a simple function that accepts a generic option and writes out the associated
    value when the option is `Some`, or `"None"` when the option is `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When we invoke this function, we simply need to provide one of the option cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how in each of the three calls to `showValue`, we specified only the
    union case names. The compiler resolved both `Some` and `None` as `Option<''T>`.
    (In the event of a naming conflict, you can qualify the case names with the discriminated
    union name just as you would with a record type.) However, if you were to call
    `showValue` with a value other than `Some` or `None`, the compiler will raise
    an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Defining Discriminated Unions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like other types, discriminated union definitions begin with the `type` keyword.
    Union cases are delimited with bars. The bar before the first union case is optional,
    but omitting it when there’s only one case can be confusing because it will make
    the definition look like a type abbreviation. In fact, if you omit the bar in
    a single-case discriminated union and there is no data associated with the case,
    the compiler will treat the definition as a type abbreviation when there is a
    naming conflict with another type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The normal rules for identifiers apply when you are defining union cases, with
    one exception: Union case names must begin with an uppercase letter to help the
    compiler differentiate union cases from other identifiers in pattern matching.
    If a case name does not begin with an uppercase letter, the compiler will raise
    an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, discriminated unions typically serve one of three purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Representing simple object hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing tree structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing type abbreviations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple Object Hierarchies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Discriminated unions are commonly used to represent simple object hierarchies.
    In fact, they excel at this task so much that they’re often used as a substitute
    for formal classes and inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine working on a system that needs some basic geometry functionality. In
    an object-oriented environment, such functionality would probably consist of an
    `IShape` interface and a number of concrete shape classes like `Circle`, `Rectangle`,
    and `Triangle`, with each implementing `IShape`. A possible implementation might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Discriminated unions offer a cleaner alternative that is less prone to side
    effects. Here’s what that same object hierarchy might look like as a discriminated
    union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: It’s Bigger on the Inside
  prefs: []
  type: TYPE_NORMAL
- en: Discriminated unions are much more complex than their syntax might lead you
    to believe. Each discriminated union compiles to an abstract class responsible
    for handling equality and comparison semantics as well as type checking and union
    case creation. Similarly, each union case compiles to a class that is both nested
    within and inherits from the union class. The union case classes define the properties
    and backing stores for each of their associated values along with an internal
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s possible to replicate some of the discriminated union functionality
    within other languages, doing so is nontrivial. Proving just how complex discriminated
    unions really are, inspecting the compiled `Shape` type we just defined in ILSpy
    reveals nearly 700 lines of C# code!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Shape` type defines three cases: `Circle`, `Rectangle`, and `Triangle`.
    Each case has at least one attached value specific to the shape it represents.
    Notice at ① and ② how the tuple syntax is used to associate multiple data values
    with a case. But despite using the tuple syntax, cases don’t actually compile
    to tuples. Instead, each associated data item compiles to an individual property
    that follows the tuple naming pattern (that is, `Item1`, `Item2`, and so on).
    This distinction is important because there’s no direct conversion from a union
    case to a tuple, meaning that you can’t use them interchangeably. The only real
    exception to this rule is that when the types are wrapped in parentheses the compiler
    will interpret the grouping as a tuple. In other words, the compiler treats `of
    string * int` and `of (string * int)` differently; the former is tuple-like, while
    the latter actually is a tuple. Unless you really need a true tuple, though, use
    the default format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’d expect, creating `Shape` instances is the same as creating `Option<''T>`
    instances. For example, here’s how to create an instance of each case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: One of the major annoyances with the tuple syntax for multiple associated values
    is that it’s easy to forget what each position represents. To work around the
    issue, include XML documentation comments—like those preceding each case in this
    section’s `Shape` definition—as a reminder.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, relief is available. One of the language enhancements in F# 3.1
    is support for named union type fields. The refined syntax resembles a hybrid
    of the current tupled syntax and type-annotated field definitions. For example,
    under the new syntax, `Shape` could be redefined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For discriminated unions defined with the F# 3.1 syntax, creating new case
    instances is significantly more developer friendly—not only because the labels
    appear in IntelliSense, but also because you can use named arguments like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Tree Structures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Discriminated unions can also be *self-referencing*, meaning that the data
    associated with a union case can be another case from the same union. This is
    handy for creating simple trees like this one, which represents a rudimentary
    markup structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Most of this definition should be familiar by now, but notice that the `ContentElement`
    case has an associated string and list of `Markup` values.
  prefs: []
  type: TYPE_NORMAL
- en: The nested `Markup` list ① makes it trivial to construct a simple HTML document
    like the following. Here, `ContentElement` nodes represent elements (such as `html`,
    `head`, and `body`) that contain additional content, while `Content` nodes represent
    raw text contained within a `ContentElement`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert the preceding tree structure to an actual HTML document, you could
    write a simple recursive function with a match expression to handle each union
    case, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `match` expression is used here roughly like a `switch` statement in C#
    or a `SELECT CASE` statement in Visual Basic. Each match case, denoted by a vertical
    pipe (`|`), matches against an Identifier pattern that includes the union case
    name and identifiers for each of its associated values. For instance, the match
    case at ① matches `ContentElement` items and represents the associated values
    with the `tag` and `children` identifiers within the case body (the part after
    the arrow). Likewise, the match cases at ② and ③ match the `EmptyElement` and
    `Content` cases, respectively. (Note that because match expressions return a value,
    each match case’s return type must be the same.)
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the `toHtml` function with `movieList` results in the following HTML
    (formatted for readability). As you look over the resulting HTML, try tracing
    each element back to its node in `movieList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Replacing Type Abbreviations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Single-case discriminated unions can be a useful alternative to type abbreviations,
    which, while nice for aliasing existing types, don’t provide any additional type
    safety. For instance, suppose you’ve defined `UserId` as an alias for `System.Guid`
    and you have a function `UserId -> User`. Although the function accepts `UserId`,
    nothing prevents you from sending in an arbitrary `Guid`, no matter what that
    `Guid` actually represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extend the markup examples from the previous section to show how single-case
    discriminated unions can solve this problem. If you wanted to display the generated
    HTML in a browser, you could define a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The actual mechanics of the `displayHtml` function aren’t important for this
    discussion. Instead, focus your attention on ① the `HtmlString` type abbreviation
    and ② the type annotation explicitly stating that the `html` parameter is an `HtmlString`.
  prefs: []
  type: TYPE_NORMAL
- en: It’s clear from the signature that the `displayHtml` function expects the supplied
    string to contain HTML, but because `HtmlString` is merely a type abbreviation
    there’s nothing ensuring that it actually is HTML. As written, both `movieList
    |> toHtml |> displayHtml` and `"abc123" |> displayHtml` are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'To introduce a bit more type safety, we can replace the `HtmlString` definition
    with a single-case discriminated union, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now that `HtmlString` is a discriminated union, we need to change the `displayHtml`
    function to extract the associated string. We can do this in one of two ways.
    The first option requires us to change the function’s signature to include an
    Identifier pattern. Alternatively, we can leave the signature alone and introduce
    an intermediate binding (also using an Identifier pattern) for the associated
    value. The first option is cleaner, so that’s the approach we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the `displayHtml` function, we only need to wrap the string from the
    `toHtml` function in an `HtmlString` instance and pass it to `displayHtml` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can further simplify this code by revising the `toHtml` function
    to return an `HtmlString` instead of a string. One approach would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this revised version, we’ve wrapped each case’s return value in an `HtmlString`
    instance. Less trivial, though, is ①, which now uses an Identifier pattern to
    extract the HTML from the recursive result in order to write the raw text to the
    `StringWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `toHtml` function now returning an `HtmlString`, passing its result
    to `displayHtml` is simplified to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Single-case discriminated unions can’t guarantee that any associated values
    are actually correct, but they do offer a little extra safety in that they force
    developers to make conscious decisions about what they’re passing to a function.
    Developers could create an `HtmlString` instance with an arbitrary string, but
    if they do they’ll be forced to think about whether the data is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like record types, discriminated unions also allow additional members. For
    example, we could redefine the `toHtml` function as a method on the `Markup` discriminated
    union as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this method is like calling a method on any other type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Lazy Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, F# uses *eager evaluation*, which means that expressions are evaluated
    immediately. Most of the time, eager evaluation will be fine in F#, but sometimes
    you can improve perceived performance by deferring execution until the result
    is actually needed, through *lazy evaluation*.
  prefs: []
  type: TYPE_NORMAL
- en: F# supports a few mechanisms for enabling lazy evaluation, but one of the easiest
    and most common ways is through the use of the `lazy` keyword. Here, the lazy
    keyword is used in conjunction with a series of expressions that includes a delay
    to simulate a long-running operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: You can see the `lazy` keyword’s impact. If this expression had been eagerly
    evaluated, `evaluating lazy expression` would have been printed and there would
    have been an immediate one-second delay before it returned `42`. Instead, the
    expression’s result is an instance of the built-in `Lazy<'T>` type. In this case,
    the compiler inferred the return type and created an instance of `Lazy<int>`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Be careful using the lazy type across language boundaries. Prior to F# 3.0,
    the `Lazy<''T>` class was located in the FSharp.Core assembly. In .NET 4.0, `Lazy<''T>`
    was moved to `mscorlib`.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `Lazy<'T>` instance created by the `lazy` keyword can be passed around like
    any other type, but the underlying expression won’t be evaluated until you force
    that evaluation by either calling the `Force` method or accessing its `Value`
    property, as shown next. Convention generally favors the `Force` method, but it
    doesn’t really matter whether you use it or the `Value` property to force evaluation.
    Internally, `Force` is just an extension method that wraps the `Value` property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve forced evaluation, we see that the underlying expression has
    printed its message, slept, and returned `42`. The `Lazy<'T>` type can also improve
    application performance through memoization. Once the associated expression is
    evaluated, its result is cached within the `Lazy<'T>` instance and used for subsequent
    requests. If the expression involves an expensive or time-consuming operation,
    the result can be dramatic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To more effectively observe memoization’s impact, we can enable timing in FSI
    and repeatedly force evaluation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As you can see at ①, the first time `Force` is called we incur the expense of
    putting the thread to sleep. The subsequent calls at ② and ③ complete instantaneously
    because the memoization mechanism has cached the result.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen in this chapter, functional programming requires a different
    mindset than object-oriented programming. While object-oriented programming emphasizes
    managing system state, functional programming is more concerned with program correctness
    and predictability through the application of side-effect-free functions to data.
    Functional languages like F# treat functions as data. In doing so, they allow
    for greater composability within systems through concepts like higher-order functions,
    currying, partial application, pipelining, and function composition. Functional
    data types like tuples, record types, and discriminated unions help you write
    correct code by letting you focus on the problem you’re trying to solve instead
    of attempting to satisfy the compiler.
  prefs: []
  type: TYPE_NORMAL
