- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">RANDOMNESS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">随机性</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'Randomness is found everywhere in cryptography: in the generation of secret
    keys, in encryption schemes, and even in the attacks on cryptosystems. Without
    randomness, cryptography would be impossible because all operations would become
    predictable and therefore insecure.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性在加密学中无处不在：在生成密钥、加密方案，甚至在对加密系统的攻击中。如果没有随机性，加密将不可能，因为所有操作将变得可预测，从而变得不安全。
- en: This chapter introduces the concept of randomness in the context of cryptography
    and its applications. We discuss pseudorandom number generators and how operating
    systems can produce reliable randomness, and we conclude with real examples showing
    how flawed randomness can impact security.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在加密学中的随机性概念及其应用。我们讨论了伪随机数生成器以及操作系统如何生成可靠的随机性，最后通过实际例子展示了错误的随机性如何影响安全性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Random or Nonrandom?</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">随机还是非随机？</samp>
- en: You’ve probably heard the phrase *random bits* before, but strictly speaking,
    there is no such thing as a series of random bits. What *is* random is the *algorithm*,
    or process, that produces a series of random bits; therefore, when we say “random
    bits,” we actually mean randomly generated bits.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能以前听过*随机比特*这个词，但严格来说，实际上并不存在一系列随机比特。真正*随机*的是产生随机比特序列的*算法*，或者说是过程；因此，当我们说“随机比特”时，我们实际上指的是随机生成的比特。
- en: What do random bits look like? For example, the 8-bit string 11010110 might
    look more random than 00000000, although both have the same chance of being generated
    (namely, 1/256). The value 11010110 looks more random than 00000000 because it
    has the signs typical of a randomly generated value. That is, 11010110 has no
    obvious pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随机比特是什么样的？例如，8位字符串11010110可能看起来比00000000更随机，尽管它们生成的机会是相同的（即1/256）。11010110看起来比00000000更随机，因为它具有典型的随机生成值的特征。也就是说，11010110没有明显的模式。
- en: When we see the string 11010110, our brain registers that it has 3 zeros and
    5 ones, just like 55 other 8-bit strings (11111000, 11110100, 11110010, and so
    on), but only one 8-bit string has 8 zeros. Because the pattern 3-zeros-and-5-ones
    is more likely to occur than the pattern 8-zeros, we identify 11010110 as random
    and 00000000 as nonrandom, even if they’re not.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到字符串11010110时，大脑会识别出它包含3个零和5个一，就像其他55个8位字符串（11111000、11110100、11110010等）一样，但只有一个8位字符串是全零的。因为3个零和5个一的模式比8个零的模式更容易出现，所以我们将11010110识别为随机，而将00000000识别为非随机，即使它们并非如此。
- en: 'This example illustrates two types of errors people often make when identifying
    randomness:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了人们在识别随机性时常犯的两种错误：
- en: '**Mistaking nonrandomness for randomness **Thinking that an object was randomly
    generated simply because it *looks* random'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**将非随机性误认为随机性** 认为一个物体是随机生成的，仅仅因为它*看起来*随机'
- en: '**Mistaking randomness for nonrandomness **Thinking that patterns appearing
    by chance are there for a reason other than chance'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**将随机性误认为非随机性** 认为偶然出现的模式是有某种原因存在的，而不是偶然的'
- en: The distinction between random-looking and actually random is crucial. Indeed,
    in crypto, nonrandomness is often synonymous with insecurity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随机看起来和真正随机之间的区别至关重要。实际上，在加密领域，非随机性常常等同于不安全。
- en: The saying “it happened by chance” reflects the property that from a complex
    system (in this case, our universe that obeys the laws of physics, deterministic
    at the macroscopic level and truly random at the subatomic, quantum level) can
    emerge specific patterns, such as the string 00000000\. By the law of large numbers,
    if many events occur, some won’t look random—such as a series of sequential numbers
    in a lottery draw. Many pseudosciences and belief systems are in fact cases of
    mistaking randomness for nonrandomness.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: “它是偶然发生的”这句话反映了一个特性，即在复杂系统中（在这个例子中，是遵循物理定律的宇宙，宏观层面上是确定性的，而在亚原子、量子层面上是完全随机的），可以出现特定的模式，例如字符串00000000。根据大数法则，如果许多事件发生，有些事件看起来并不随机——例如彩票抽奖中的一系列顺序数字。许多伪科学和信仰体系实际上是将随机误认为非随机的例子。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Randomness as a Probability Distribution</samp>
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">随机性作为概率分布</samp>
- en: Any randomized process is characterized by a *probability distribution*, which
    gives all there is to know about the randomness of the process. A probability
    distribution, or simply *distribution*, lists the outcomes of a randomized process
    where each outcome is assigned a probability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何随机化过程的特征是由*概率分布*决定的，概率分布提供了关于该过程随机性的所有信息。概率分布，或简称*分布*，列出了一个随机化过程的所有结果，并为每个结果分配一个概率。
- en: A *probability* measures the likelihood of an event occurring. It’s expressed
    as a real number between 0 and 1 where a probability of 0 means impossible and
    a probability of 1 means certain. For example, when tossing a two-sided coin,
    each side has a 1/2 (or 0.5) probability of landing face up, and the probability
    of a coin landing on its edge has a probability close to 0.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*概率*是衡量事件发生可能性的指标。它表示为介于0和1之间的实数，其中0表示不可能，1表示确定。例如，在抛硬币时，每一面落正面的概率是1/2（或0.5），而硬币立在边缘的概率接近0。'
- en: A probability distribution must include all possible outcomes such that the
    sum of all probabilities is 1\. Specifically, if there are *N* possible events,
    there are *N* probabilities *p*[1], *p*[2], . . . , *p*N with *p*[1] + *p*[2]
    + . . . + *p*N = 1\. In the case of the coin toss, the distribution is 1/2 for
    heads and 1/2 for tails. The sum of both probabilities is equal to 1/2 + 1/2 =
    1, because the coin will fall on one of its two faces.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 概率分布必须包括所有可能的结果，使得所有概率的总和为1。具体来说，如果有*N*个可能的事件，就有*N*个概率*p*[1]，*p*[2]，...，*p*N，且*p*[1]
    + *p*[2] + ... + *p*N = 1。在抛硬币的例子中，硬币正面和反面的分布各为1/2。两者的总和为1/2 + 1/2 = 1，因为硬币会落在它的两个面之一。
- en: A *uniform distribution* occurs when all probabilities in the distribution are
    equal, meaning that all outcomes are equally likely to occur. If there are *N*
    events, then each event has probability 1/*N*. For example, if a 128-bit key is
    picked uniformly at random—that is, according to a uniform distribution—then each
    of the 2^(128) possible keys should have a probability of 1/2^(128).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*均匀分布*发生在分布中的所有概率相等时，这意味着所有结果发生的可能性相同。如果有*N*个事件，那么每个事件的概率是1/*N*。例如，如果一个128位密钥是均匀随机选择的——即根据均匀分布——那么2^(128)个可能的密钥中的每个密钥应该有1/2^(128)的概率。'
- en: In contrast, when a distribution is *nonuniform*, probabilities aren’t all equal.
    A coin toss with a nonuniform distribution is said to be biased and may yield
    heads with probability 1/4 and tails with probability 3/4, for example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当分布是*非均匀*时，概率并不相等。一个非均匀分布的硬币抛掷被称为偏倚的，例如，正面可能以1/4的概率出现，反面可能以3/4的概率出现。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注</samp>
- en: '*It’s possible to cheat with a loaded die, preventing the probabilities of
    each of the six faces to be 1/6; however, one can’t bias a coin. Coin tosses can
    be biased only if “the coin is allowed to bounce or be spun rather than simply
    flipped in the air,” as described in the article “You Can Load a Die but You Can’t
    Bias a Coin” (available at* [https://<wbr>www<wbr>.stat<wbr>.berkeley<wbr>.edu<wbr>/~nolan<wbr>/Papers<wbr>/dice<wbr>.pdf](https://www.stat.berkeley.edu/~nolan/Papers/dice.pdf)).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*可以通过使用加重的骰子作弊，使得每个面出现的概率不再是1/6；然而，硬币无法偏倚。只有当“硬币被允许反弹或旋转，而不是简单地在空中翻转”时，硬币抛掷才可能出现偏差，正如文章《你可以加重骰子，但不能偏倚硬币》中所描述的那样*（[https://<wbr>www<wbr>.stat<wbr>.berkeley<wbr>.edu<wbr>/~nolan<wbr>/Papers<wbr>/dice<wbr>.pdf](https://www.stat.berkeley.edu/~nolan/Papers/dice.pdf)）。'
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Entropy: A Measure of Uncertainty</samp>'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">熵：不确定性的度量</samp>
- en: '*Entropy* is the measure of uncertainty, or disorder, in a system. The higher
    the entropy, the less certainty found in the result of a randomized process.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*熵*是系统中不确定性或无序度的度量。熵越高，随机过程结果的不确定性越大。'
- en: 'We can compute the entropy of a probability distribution. If your distribution
    consists of probabilities *p*[1], *p*[2], . . . , *p*N, then its entropy is the
    negative sum of all probabilities multiplied by their logarithm, as shown in this
    expression:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算概率分布的熵。如果你的分布由概率*p*[1]，*p*[2]，...，*p*N组成，则其熵是所有概率与其对数的乘积的负和，如下所示：
- en: '![](../images/pg27-1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg27-1.jpg)'
- en: 'Here the function *log* is the *binary logarithm*, or logarithm in base two.
    Unlike the natural logarithm, the binary logarithm expresses the information in
    bits and yields integer values when probabilities are powers of two. For example,
    log(1/2) = –1, log(1/4) = –2, and more generally log(1/2*^n*) = –*n*. (We actually
    take the *negative sum* to end up with a positive number.) Random 128-bit keys
    produced using a uniform distribution therefore have the following entropy:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的函数*log*是*二进制对数*，即以二为底的对数。与自然对数不同，二进制对数表示信息的比特，并且当概率是二的幂时，结果为整数。例如，log(1/2)
    = -1，log(1/4) = -2，通常情况下log(1/2*^n*) = - *n*。（我们实际上取*负和*，以得到正数。）因此，使用均匀分布生成的随机128位密钥具有以下熵值：
- en: '![](../images/pg27-2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg27-2.jpg)'
- en: If you replace 128 with any integer *n*, the entropy of a uniformly distributed
    *n*-bit string will be *n* bits.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将128替换为任意整数*n*，那么一个均匀分布的*n*位字符串的熵将是*n*比特。
- en: 'Entropy is maximized when the distribution is uniform because a uniform distribution
    maximizes uncertainty: no outcome is more likely than the others. Therefore, *n*-bit
    values can’t have more than *n* bits of entropy.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当分布是均匀时，熵最大，因为均匀分布最大化了不确定性：没有任何结果比其他结果更可能。因此，*n*位值的熵不能超过*n*比特。
- en: 'By the same token, when the distribution is not uniform, entropy is lower.
    Consider the coin toss example. The entropy of a fair toss is the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的，当分布不是均匀时，熵会较低。考虑掷硬币的例子。公平掷硬币的熵值如下：
- en: '![](../images/pg28-1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg28-1.jpg)'
- en: What if one side of the coin has a higher probability of landing face up than
    the other? Say heads has a probability of 1/4 and tails 3/4\. (Remember that the
    sum of all probabilities should be 1.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果硬币的一面比另一面更可能朝上会怎么样？假设正面的概率是1/4，反面是3/4。（记住，所有概率的和应该为1。）
- en: 'The entropy of such a biased toss is this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个有偏掷硬币的熵值如下：
- en: '![](../images/pg28-2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg28-2.jpg)'
- en: The fact that 0.81 is less than the 1-bit entropy of a fair toss tells us that
    the more biased the coin, the less uniform the distribution and the lower the
    entropy. Taking this example further, if heads has a probability of 1/10, the
    entropy is 0.469; if the probability drops to 1/100, the entropy drops to 0.081.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 0.81小于公平掷硬币的1比特熵，这告诉我们，硬币越有偏，分布越不均匀，熵值也越低。进一步说明，如果正面朝上的概率是1/10，那么熵值为0.469；如果概率降到1/100，熵值则降至0.081。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Entropy can also be viewed as a measure of information. For example, the result
    of a fair coin toss gives you exactly 1 bit of information—heads or tails—and
    you’re unable to predict the result of the toss in advance. In the case of the
    unfair coin toss, you know in advance that tails is more probable, so you can
    predict the outcome. The result of the unfair coin toss gives you the information
    needed to predict the result with certainty.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*熵也可以被看作是信息的度量。例如，一个公平的掷硬币结果给你准确的1比特信息——正面或反面——并且你无法提前预测掷硬币的结果。在不公平的掷硬币情况下，你提前知道反面更可能出现，因此你可以预测结果。不公平掷硬币的结果为你提供了预测结果所需的信息。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Random and Pseudorandom Number Generators</samp>
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">随机与伪随机数生成器</samp>
- en: 'Cryptosystems need randomness to be secure and therefore need a component from
    which to get their randomness. The job of this component is to return random bits
    when requested to do so. To perform this randomness generation, you’ll need two
    things:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 加密系统需要随机性来保证安全，因此需要一个可以提供随机性的组件。这个组件的工作是当被请求时返回随机比特。为了生成这种随机性，你需要两样东西：
- en: A source of entropy, provided by random number generators.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数生成器提供的熵源。
- en: A cryptographic algorithm to produce high-quality random bits from the source
    of entropy. This is found in pseudorandom number generators.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种加密算法可以从熵源中生成高质量的随机比特。这在伪随机数生成器中得以实现。
- en: Using both random and pseudorandom number generators is the key to making cryptography
    practical and secure. Let’s briefly look at how random number generators work
    before exploring pseudorandom number generators in depth.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 同时使用随机和伪随机数生成器是使加密学既实用又安全的关键。让我们在深入探讨伪随机数生成器之前，简单了解一下随机数生成器的工作原理。
- en: Randomness comes from the environment, which is analog, chaotic, uncertain,
    and hence unpredictable. Randomness can’t be generated by computer-based algorithms
    alone. In cryptography, randomness usually comes from *random number generators
    (RNGs)*, which are software or hardware components that leverage entropy in the
    analog world to produce unpredictable bits in a digital system. For example, an
    RNG might directly sample bits from measurements of temperature, acoustic noise,
    air turbulence, or electrical static. Unfortunately, such analog entropy sources
    aren’t always available, and their entropy is often difficult to estimate.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性来源于环境，而环境是模拟的、混沌的、不确定的，因此无法预测。仅依赖计算机算法无法生成随机性。在密码学中，随机性通常来自*随机数生成器（RNG）*，这是一种软件或硬件组件，利用模拟世界中的熵来在数字系统中生成不可预测的比特。例如，一个RNG可能直接从温度、声学噪声、空气湍流或电静态的测量中采样比特。不幸的是，这些模拟熵源并不总是可用，而且它们的熵通常很难估计。
- en: RNGs can also harvest the entropy in a running operating system by drawing from
    attached sensors, I/O devices, network or disk activity, system logs, running
    processes, and user activities such as key presses and mouse movement. Such system-
    and human-generated activities can be a good source of entropy, but they can be
    fragile and manipulated by an attacker. Also, they’re slow to yield random bits.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: RNG也可以通过从附加的传感器、I/O设备、网络或磁盘活动、系统日志、运行中的进程以及用户活动（如按键和鼠标移动）中获取熵。此类系统和人为活动可以是一个良好的熵源，但它们可能非常脆弱，且容易受到攻击者的操控。此外，它们生成随机比特的速度较慢。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: Quantum random number generators (QRNGs) *are a type of RNG that rely on the
    randomness arising from quantum mechanical phenomena, such as radioactive decay,
    photon polarization, or thermal noise. These phenomena, not being characterized
    by equations that determine the future state from the current state, are random
    in the absolute sense. In practice, however, the raw bits extracted from a QRNG
    may be biased and tend to be slow to produce. Like the previously cited entropy
    sources, they require postprocessing to generate reliable bits at high speed.*
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 量子随机数生成器（QRNG）*是一种依赖于量子力学现象（如放射性衰变、光子极化或热噪声）产生的随机性的随机数生成器。这些现象不受通过方程式从当前状态推导未来状态的限制，因此是绝对意义上的随机性。然而，在实际应用中，从QRNG提取的原始比特可能会带有偏差，并且生成速度较慢。与前面提到的熵源类似，它们需要经过后处理才能以高速生成可靠的比特。*
- en: '*Pseudorandom number generators (PRNGs)* address the challenge in generating
    randomness by reliably producing many artificial random bits from a few true random
    bits. For example, an RNG that translates mouse movements to random bits would
    stop working if you stop moving the mouse, whereas a PRNG always returns pseudorandom
    bits when requested to do so.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*伪随机数生成器（PRNG）*通过可靠地产生大量人工随机比特来解决生成随机性的挑战，这些比特源自少量真实的随机比特。例如，一个将鼠标移动转换为随机比特的RNG，如果你停止移动鼠标，就会停止工作，而PRNG则始终在请求时返回伪随机比特。'
- en: 'PRNGs rely on RNGs but behave differently: RNGs produce true random bits relatively
    slowly from analog sources, in a nondeterministic way, and with no guarantee of
    uniform distribution or of high entropy per bit. In contrast, PRNGs produce random-looking
    bits quickly from digital sources, in a deterministic way, uniformly distributed,
    and with an entropy guaranteed to be high enough for cryptographic applications.
    Essentially, PRNGs transform a few unreliable random bits into a long stream of
    reliable pseudorandom bits suitable for crypto applications, as [Figure 2-1](chapter2.xhtml#fig2-1)
    shows.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: PRNG依赖于RNG，但行为有所不同：RNG从模拟源生成真实的随机比特相对较慢，采用非确定性方式，且无法保证比特的均匀分布或每个比特的高熵。相比之下，PRNG从数字源快速生成看似随机的比特，采用确定性方式，均匀分布，并且熵足够高，适用于加密应用。实际上，PRNG将少量不可靠的随机比特转化为适合加密应用的长时间可靠的伪随机比特流，正如[图2-1](chapter2.xhtml#fig2-1)所示。
- en: '![](../images/fig2-1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig2-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: RNGs produce few
    unreliable bits from analog sources, whereas PRNGs expand those bits to a long
    stream of reliable bits.</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-1：RNG从模拟源生成的比特较少且不可靠，而PRNG将这些比特扩展为长时间可靠的比特流。</samp>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How PRNGs Work</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">伪随机数生成器的工作原理</samp>
- en: A PRNG receives random bits from an RNG at regular intervals and uses them to
    update the contents of a large memory buffer, called the *entropy pool*. The entropy
    pool is the PRNG’s source of entropy, just like the physical environment is to
    an RNG. When the PRNG updates the entropy pool, it mixes the pool’s bits together
    to help remove any statistical bias.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: PRNG 定期从 RNG 接收随机位，并使用这些随机位更新一个大型内存缓冲区，称为 *熵池*。熵池是 PRNG 的熵来源，就像物理环境是 RNG 的熵来源一样。当
    PRNG 更新熵池时，它会将熵池中的位混合在一起，以帮助去除任何统计偏差。
- en: 'To generate pseudorandom bits, the PRNG runs a deterministic random bit generator
    (DRBG) algorithm that expands some bits from the entropy pool into a much longer
    sequence. As its name suggests, a DRBG is deterministic, not randomized: given
    one input, you will always get the same output. The PRNG ensures that its DRBG
    never receives the same input twice so it can generate unique pseudorandom sequences.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成伪随机位，PRNG 运行一个确定性随机位生成器（DRBG）算法，将熵池中的某些位扩展成一个更长的序列。顾名思义，DRBG 是确定性的，而非随机的：给定一个输入，你总是会得到相同的输出。PRNG
    确保其 DRBG 永远不会接收到相同的输入两次，因此可以生成唯一的伪随机序列。
- en: 'In the course of its work, the PRNG performs three operations:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在其工作过程中，PRNG 执行三项操作：
- en: '***init()* **Initializes the entropy pool and the internal state of the PRNG'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '***init()* **初始化熵池和 PRNG 的内部状态'
- en: '***refresh(R)* **Updates the entropy pool using some data, *R*, usually sourced
    from an RNG'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '***刷新(R)* **使用一些数据 *R* 更新熵池，这些数据通常来自 RNG'
- en: '***next(N)* **Returns *N* pseudorandom bits and updates the entropy pool'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '***下一步(N)* **返回 *N* 个伪随机位，并更新熵池'
- en: The *init* operation resets the PRNG to a fresh state, reinitializes the entropy
    pool to some default value, and initializes any variables or memory buffers used
    by the PRNG to carry out the *refresh* and *next* operations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*init* 操作将 PRNG 重置为一个全新的状态，重新初始化熵池为某个默认值，并初始化 PRNG 用于执行 *刷新* 和 *下一步* 操作的任何变量或内存缓冲区。'
- en: The *refresh* operation is often called *reseeding*, and its argument *R* is
    called a *seed*. When no RNG is available, seeds may be unique values hardcoded
    in a system. The *refresh* operation is typically called by the operating system,
    whereas *next* is typically called or requested by applications. The *next* operation
    runs the DRBG and modifies the entropy pool to ensure that the next call will
    yield different pseudorandom bits.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*刷新* 操作通常称为 *重新播种*，其参数 *R* 称为 *种子*。当没有可用的 RNG 时，种子可能是系统中硬编码的唯一值。通常操作系统会调用 *刷新*
    操作，而 *下一步* 操作通常由应用程序调用或请求。*下一步* 操作运行 DRBG，并修改熵池，以确保下一次调用会生成不同的伪随机位。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Concerns</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安全性问题</samp>
- en: Let’s talk briefly about how PRNGs address high-level security concerns. Specifically,
    PRNGs should guarantee *backtracking resistance* and *prediction resistance*.
    Backtracking resistance (also called *forward secrecy*) means that previously
    generated bits are impossible to recover, whereas prediction resistance (*backward
    secrecy*) means that future bits should be impossible to predict.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 简要谈一下伪随机数生成器（PRNG）如何解决高级安全性问题。具体来说，PRNG 应该保证 *回溯抗性* 和 *预测抗性*。回溯抗性（也叫 *前向保密性*）意味着先前生成的位无法恢复，而预测抗性（*后向保密性*）意味着未来的位应该无法预测。
- en: To achieve backtracking resistance, the PRNG should ensure that the transformations
    performed when updating the state through the *refresh* and *next* operations
    are irreversible. This way, if an attacker compromises the system and obtains
    the entropy pool’s value, they can’t determine the previous values of the pool
    or the previously generated bits. To achieve prediction resistance, the PRNG should
    call *refresh* regularly with *R* values that are unknown to an attacker and are
    difficult to guess, thus preventing an attacker from determining future values
    of the entropy pool, even if the whole pool is compromised. (If the list of *R*
    values were known, you’d need to know the order in which *refresh* and *next*
    calls were made to reconstruct the pool.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现回溯抗性，PRNG 应确保在通过 *刷新* 和 *下一步* 操作更新状态时所执行的变换是不可逆的。这样，如果攻击者破坏了系统并获得了熵池的值，他们就无法确定熵池的先前值或之前生成的位。为了实现预测抗性，PRNG
    应定期调用 *刷新* 操作，使用攻击者无法得知且难以猜测的 *R* 值，从而防止攻击者确定熵池的未来值，即使整个熵池已被破解。（如果 *R* 值的列表已知，那么你需要知道
    *刷新* 和 *下一步* 调用的顺序，才能重建熵池。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The PRNG Fortuna</samp>
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">PRNG Fortuna</samp>
- en: '*Fortuna* is a PRNG construction used in Windows originally designed in 2003
    by Niels Ferguson and Bruce Schneier. Fortuna superseded *Yarrow*, a 1998 design
    by John Kelsey and Bruce Schneier that was for a long time used in the macOS and
    iOS operating systems and has been replaced by Fortuna. I won’t provide the Fortuna
    specification here or show you how to implement it, but I will try to explain
    how it works. You’ll find a complete description of Fortuna in [Chapter 9](chapter9.xhtml)
    of *Cryptography Engineering* by Ferguson, Schneier, and Kohno (Wiley, 2010).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fortuna* 是一种伪随机数生成器（PRNG），最初由 Niels Ferguson 和 Bruce Schneier 于 2003 年设计，最早应用于
    Windows。Fortuna 取代了 *Yarrow*，这是 John Kelsey 和 Bruce Schneier 于 1998 年设计的方案，曾长期用于
    macOS 和 iOS 操作系统，并且已被 Fortuna 替代。我在这里不会提供 Fortuna 的规格，也不会告诉你如何实现它，但我会尽力解释它是如何工作的。你可以在
    Ferguson、Schneier 和 Kohno 的《Cryptography Engineering》（Wiley, 2010）一书的 [第 9 章](chapter9.xhtml)
    中找到 Fortuna 的完整描述。'
- en: 'Fortuna’s internal memory includes the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Fortuna 的内部内存包括以下内容：
- en: Thirty-two entropy pools, *P*[1], *P*[2], . . . , *P*[32], such that *P*i is
    used every 2*^i* reseeds.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三十二个熵池，*P*[1]，*P*[2]，...，*P*[32]，使得 *P*i 每进行 2*^i* 次重新种子时使用一次。
- en: A key, *K*, and a counter, *C* (both 16 bytes). These form the internal state
    of Fortuna’s DRBG.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个密钥 *K* 和一个计数器 *C*（都为 16 字节）。它们构成了 Fortuna 的 DRBG（确定性随机比特生成器）的内部状态。
- en: 'In simplest terms, Fortuna works like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，Fortuna 的工作原理如下：
- en: '*init*() sets *K* and *C* to zero and empties the 32 entropy pools *P*i, where
    *i* = 1 . . . 32.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*init*() 将 *K* 和 *C* 设为零，并清空 32 个熵池 *P*i，其中 *i* = 1 . . . 32。'
- en: '*refresh*(*R*) appends the data, *R*, to one of the entropy pools. The system
    chooses the RNGs used to produce *R* values, and it should call *refresh* regularly.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*refresh*(*R*) 将数据 *R* 添加到某个熵池中。系统选择用来生成 *R* 值的 RNG，并且应该定期调用 *refresh*。'
- en: '*next*(*N*) updates *K* using data from one or more entropy pools, where the
    choice of the entropy pools depends mainly on how many updates of *K* have already
    been done. The *N* bits requested are then produced by encrypting *C* using *K*
    as a key. If encrypting *C* is not enough, Fortuna encrypts *C* + 1, then *C*
    + 2, and so on, to get enough bits.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*next*(*N*) 使用来自一个或多个熵池的数据更新 *K*，其中熵池的选择主要取决于 *K* 已经更新了多少次。然后，通过使用 *K* 作为密钥加密
    *C* 来生成请求的 *N* 位。如果加密 *C* 还不够，Fortuna 会加密 *C* + 1，再加密 *C* + 2，以此类推，直到获得足够的位。'
- en: Although Fortuna’s operations look fairly simple, implementing them correctly
    is hard. For one, you need to get all the details of the algorithm right—how entropy
    pools are chosen, the type of cipher to be used in *next*, how to behave when
    no entropy is received, and so on. Although the specs define most of the details,
    they don’t include a comprehensive test suite to check that an implementation
    is correct, which makes it difficult to ensure that your implementation of Fortuna
    will behave as expected.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Fortuna 的操作看起来相当简单，但正确实现它是困难的。首先，你需要将算法的所有细节做到位——如何选择熵池，*next* 中使用的密码类型，如何在没有熵输入时进行处理，等等。尽管规格定义了大多数细节，但它们并未包含全面的测试套件来检查实现是否正确，这使得确保你对
    Fortuna 的实现能够按预期行为运行变得困难。
- en: Even if Fortuna is correctly implemented, security failures may occur for reasons
    other than the use of an incorrect algorithm. For example, Fortuna might not notice
    if the RNGs fail to produce enough random bits, and as a result Fortuna will produce
    lower-quality pseudorandom bits, or it may stop delivering pseudorandom bits altogether.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Fortuna 被正确实现，也可能由于算法错误以外的原因发生安全失败。例如，Fortuna 可能没有注意到 RNG 没有产生足够的随机位，因此 Fortuna
    会生成质量较差的伪随机位，或者甚至完全停止生成伪随机位。
- en: Another risk inherent in Fortuna implementations lies in the possibility of
    exposing associated *seed files* to attackers. The data in Fortuna seed files
    is used to feed entropy to Fortuna through *refresh* calls when an RNG is not
    immediately available—for example, immediately after a system reboot and before
    the system’s RNGs have recorded any unpredictable events. However, if an identical
    seed file is used twice, Fortuna will produce the same bit sequence twice. Seed
    files should therefore be erased after use to ensure they aren’t reused.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Fortuna 实现中的另一个风险在于可能将相关的 *种子文件* 暴露给攻击者。Fortuna 种子文件中的数据用于在 RNG（随机数生成器）不可立即使用时，通过
    *refresh* 调用将熵传递给 Fortuna——例如，在系统重启后，且在系统的 RNG 记录任何不可预测的事件之前。然而，如果相同的种子文件被使用了两次，Fortuna
    会产生相同的位序列。因此，种子文件应该在使用后被擦除，以确保它们不会被重复使用。
- en: Finally, if two Fortuna instances are in the same state because they’re sharing
    a seed file (meaning the same data in the entropy pools, including *C* and *K*),
    then the *next* operation will return the same bits in both instances.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果两个 Fortuna 实例处于相同状态，因为它们共享一个种子文件（即熵池中的数据相同，包括*C*和*K*），那么*下一个*操作将在两个实例中返回相同的位。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Cryptographic
    vs. Noncryptographic PRNGs</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加密与非加密伪随机数生成器</samp>'
- en: There are cryptographic and noncryptographic PRNGs. Noncrypto PRNGs are designed
    to produce uniform distributions for applications such as scientific simulations
    or video games. However, you should never use noncrypto PRNGs in crypto applications,
    because they’re insecure; they’re concerned only with the quality of the bits’
    probability distribution and not with their predictability. Crypto PRNGs, on the
    other hand, are unpredictable because they’re also concerned with the strength
    of the underlying *operations* used to deliver well-distributed bits.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有加密和非加密伪随机数生成器。非加密伪随机数生成器设计用于产生均匀分布，适用于科学模拟或视频游戏等应用。然而，绝不能在加密应用中使用非加密伪随机数生成器，因为它们不安全；它们只关心位的概率分布质量，而不关心它们的可预测性。另一方面，加密伪随机数生成器是不可预测的，因为它们还考虑了用于生成良好分布位的底层*操作*的强度。
- en: Unfortunately, most PRNGs exposed by programming languages—such as libc’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">rand</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">drand48</samp>,
    PHP’s <samp class="SANS_TheSansMonoCd_W5Regular_11">rand</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">mt_rand</samp>,
    Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">random</samp> module, and
    Java’s <samp class="SANS_TheSansMonoCd_W5Regular_11">java.util.Random</samp> class—are
    noncryptographic. Defaulting to a noncrypto PRNG is a recipe for disaster because
    it often ends up being used in crypto applications, so be sure to use only crypto
    PRNGs when generating randomness related to cryptographic or security applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，大多数编程语言暴露的伪随机数生成器（PRNG）——例如 libc 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">rand</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">drand48</samp>，PHP 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">rand</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">mt_rand</samp>，Python 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">random</samp> 模块，Java 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">java.util.Random</samp>
    类——都是非加密的。默认使用非加密的伪随机数生成器是灾难的开始，因为它通常会被用于加密应用中，所以在生成与加密或安全应用相关的随机性时，务必使用加密伪随机数生成器。
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_B_11">A Popular Noncrypto PRNG:
    Mersenne Twister</samp>'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">一种流行的非加密伪随机数生成器：梅森旋转算法</samp>
- en: 'The *Mersenne Twister (MT)* algorithm is a noncryptographic PRNG used (at the
    time of this writing) in PHP, Python, R, Ruby, and many other systems. It’s even
    been used (unfortunately) in blockchain wallet key generators. MT generates uniformly
    distributed random bits without statistical bias, but it’s predictable: given
    a few bits produced by MT, one can guess which bits will follow.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*梅森旋转算法 (MT)* 是一种非加密的伪随机数生成器（PRNG），目前（截至本文写作时）被 PHP、Python、R、Ruby 和许多其他系统使用。它甚至（不幸地）被用于区块链钱包密钥生成器中。MT
    生成均匀分布的随机位，没有统计偏差，但它是可预测的：只要知道由 MT 生成的几个位，就能猜出接下来的位是什么。'
- en: 'Let’s look under the hood to see what makes the Mersenne Twister insecure.
    The MT algorithm is much simpler than that of crypto PRNGs: its internal state
    is an array, *S*, consisting of 624 32-bit words. This array is initially set
    to *S*[1], *S*[2], . . . , *S*[624] and evolves to *S*[2], . . . , *S*[625], then
    *S*[3], . . . , *S*[626], and so on, according to this equation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解梅森旋转算法不安全的原因。MT 算法比加密伪随机数生成器的算法要简单得多：它的内部状态是一个数组 *S*，包含 624 个 32 位的字。这个数组最初被设置为
    *S*[1]，*S*[2]，...，*S*[624]，然后根据这个方程演变为 *S*[2]，...，*S*[625]，接着是 *S*[3]，...，*S*[626]，依此类推：
- en: '![](../images/pg32-1.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg32-1.jpg)'
- en: Here, ⊕ denotes the bitwise XOR (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>
    in the C programming language), ∧ denotes the bitwise AND (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    in C), ∨ denotes the bitwise OR (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>
    in C), and **A** is a function that transforms some 32-bit word, *x*, to (*x*
    >> 1) if *x*’s most significant bit is 0, or to (*x* >> 1) ⊕ 0x9908b0df otherwise.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，⊕ 表示按位异或（在 C 语言中为 <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>），∧
    表示按位与（在 C 中为 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>），∨ 表示按位或（在
    C 中为 <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>），**A** 是一个函数，它将某个
    32 位字 *x* 转换为 (*x* >> 1)，如果 *x* 的最高有效位是 0，或者转换为 (*x* >> 1) ⊕ 0x9908b0df 否则。
- en: In this equation, bits of *S* interact with each other only through XORs. The
    operators ∧ and ∨ never combine 2 bits of *S* together but instead combine bits
    of *S* with bits from the constants 0x80000000 and 0x7fffffff. This way, any bit
    from *S*[625] can be expressed as an XOR of bits from *S*[398], *S*[1], and *S*[2],
    and any bit from any future state can be expressed as an XOR combination of bits
    from the initial state *S*[1], . . . , *S*[624]. (When you express, say, *S*[228
    + 624] = *S*[852] as a function of *S*[625], *S*[228], and *S*[229], you can in
    turn replace *S*[625] by its expression in terms of *S*[398], *S*[1], and *S*[2].)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，*S*的比特仅通过异或运算相互作用。运算符∧和∨从不将*S*的两个比特结合起来，而是将*S*的比特与常量0x80000000和0x7fffffff中的比特结合。这样，*S*[625]的任何一个比特都可以表示为*S*[398]、*S*[1]和*S*[2]的异或运算，而任何未来状态中的比特都可以表示为初始状态*S*[1]、...、*S*[624]中比特的异或组合。（例如，当你将*S*[228
    + 624] = *S*[852]表示为*S*[625]、*S*[228]和*S*[229]的函数时，你可以进一步将*S*[625]替换为它在*S*[398]、*S*[1]和*S*[2]中的表示。）
- en: 'Because there are exactly 624 × 32 = 19,968 bits in the initial state (or 624
    32-bit words), any output bit can be expressed as an equation with at most 19,969
    terms (19,968 bits plus one constant bit). That’s about 2.5KB of data. The converse
    is also true: bits from the initial state can be expressed as an XOR of output
    bits.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为初始状态中恰好有624 × 32 = 19,968个比特（或624个32位字），任何输出比特都可以表示为至多包含19,969项（19,968个比特加一个常量比特）的方程。这大约是2.5KB的数据。反过来也是如此：初始状态中的比特可以表示为输出比特的异或组合。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Linearity Insecurity</samp>
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">线性不安全性</samp>
- en: We call an XOR combination of bits a *linear combination*. For example, if *X*,
    *Y*, and *Z* are bits, then the expression *X* ⊕ *Y* ⊕ *Z* is a linear combination,
    whereas (*X* ∧ *Y*) ⊕ *Z* is not because there’s an AND (∧). If you flip a bit
    of *X* in *X* ⊕ *Y* ⊕ *Z*, then the result changes as well, regardless of *Y*’s
    and *Z*’s values. In contrast, if you flip a bit of *X* in (*X* ∧ *Y*) ⊕ *Z*,
    the result changes only if *Y*’s bit at the same position is 1\. The upshot is
    that linear combinations are predictable because you don’t need to know the value
    of the bits in order to predict how a change in their value will affect the result.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称位的异或组合为*线性组合*。例如，如果*X*、*Y*和*Z*是位，那么表达式*X* ⊕ *Y* ⊕ *Z*就是线性组合，而(*X* ∧ *Y*)
    ⊕ *Z*则不是，因为存在与（∧）。如果你在*X* ⊕ *Y* ⊕ *Z*中翻转*X*的某一位，那么结果也会改变，而与*Y*和*Z*的值无关。相反，如果你在(*X*
    ∧ *Y*) ⊕ *Z*中翻转*X*的某一位，只有当*Y*在相同位置的位为1时，结果才会改变。关键在于，线性组合是可预测的，因为你不需要知道位的具体值就能预测它们的变化如何影响结果。
- en: For comparison, if the MT algorithm were cryptographically strong, its equations
    would be *nonlinear* and would involve not only single bits but also AND combinations
    (*products*) of bits, such as *S*[1]*S*[15]*S*[182] or *S*[17]*S*[256]*S*[257]*S*[354]*S*[498]*S*[601].
    Although linear combinations of those bits include at most 624 variables, nonlinear
    combinations allow for up to 2^(624) variables. It would be impossible to solve,
    let alone write down, the whole of these equations. (Note that 2^(305), a much
    smaller number, is the estimated information capacity of the observable universe.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行比较，如果MT算法在密码学上是强安全的，那么它的方程应该是*非线性*的，并且不仅涉及单个比特，还应包括比特的与运算（*乘积*），如*S*[1]*S*[15]*S*[182]或者*S*[17]*S*[256]*S*[257]*S*[354]*S*[498]*S*[601]。尽管这些比特的线性组合最多包含624个变量，但非线性组合则允许多达2^(624)个变量。解决这些方程几乎是不可能的，更不用说将其写下来了。（请注意，2^(305)是一个更小的数字，代表可观测宇宙的估算信息容量。）
- en: The key here is that linear transformations lead to short equations (comparable
    in size to the number of variables), which are easy to solve, whereas nonlinear
    transformations give rise to equations of exponential size, which are practically
    unsolvable. The game of cryptographers is thus to design PRNG algorithms that
    emulate such complex nonlinear transformations using only a small number of simple
    operations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键在于，线性变换导致简短的方程（其规模可与变量数量相当），这些方程容易求解，而非线性变换则会产生指数级的方程，其规模极大，实际上是无法求解的。因此，密码学家的任务是设计出能模拟如此复杂的非线性变换的伪随机数生成算法（PRNG），且只使用少量的简单操作。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Linearity is just one of many security criteria. Although necessary, nonlinearity
    alone does not make a PRNG cryptographically secure.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性只是众多安全标准中的一种。尽管非线性是必要的，但仅仅有非线性并不足以使得一个伪随机数生成器（PRNG）在密码学上是安全的。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Uselessness of
    Statistical Tests</samp>
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Statistical test suites like TestU01, Diehard, or the National Institute of
    Standards and Technology (NIST) test suite are one way to test the quality of
    pseudorandom bits. These tests take a sample of pseudorandom bits produced by
    a PRNG (say, 1MB’s worth), compute some statistics on the distribution of certain
    patterns in the bits, and compare the results with the typical results obtained
    for a uniform distribution. For example, some tests count the number of 1 bits
    versus the number of 0 bits, or the distribution of 8-bit patterns. But statistical
    tests are largely irrelevant to cryptographic security, and it’s possible to design
    a cryptographically weak PRNG that fools any statistical test.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run statistical tests on randomly generated data, you will usually
    see a bunch of statistical indicators as a result. These are typically *p*-values,
    a common statistical indicator. These results aren’t always easy to interpret
    because they’re rarely as simple as passed or failed. If your first results seem
    abnormal, don’t worry: they may be the result of some accidental deviation, or
    you may be testing too few samples. To ensure that the results you see are normal,
    compare them with those obtained for some reliable sample of identical size—for
    example, one generated with the OpenSSL toolkit using the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Real-World PRNGs</samp>
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s turn our attention to implementing PRNGs in the real world. You’ll find
    crypto PRNGs in the operating systems (OSs) of most platforms, from desktops and
    laptops to embedded systems such as routers and set-top boxes, as well as virtual
    machines, mobile phones, and so on. Most of these PRNGs are software based, but
    those that are pure hardware are used by applications running on the OS and sometimes
    by other PRNGs running on top of cryptographic libraries or applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll look at the most widely deployed PRNGs: for Linux, Android, and
    many other Unix-based systems; in Windows; and in recent Intel microprocessors,
    whose PRNG is hardware based.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Random Bits in Linux</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The device file */dev/urandom* is the userland interface to the crypto PRNG
    in operating systems based on the Linux kernel. You’ll typically use it to generate
    reliable random bits. Because it’s a device file, you request random bits from
    */dev/urandom* by reading it as a file. For example, the following command uses
    */dev/urandom* to write 10MB of random bits to a file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Wrong Way to Use /dev/urandom</samp>
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You could write a naive and insecure C program like the one shown in [Listing
    2-1](chapter2.xhtml#Lis2-1) to read random bits and hope for the best, but that
    would be a bad idea.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: An insecure use
    of</samp> <samp class="SANS_Futura_Std_Book_11">/dev/urandom</samp>'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is insecure; it doesn’t even check the return values of <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">read()</samp>, which means your
    expected random buffer could end up filled with zeros or left unchanged.  #####
    <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A Safer Way to Use /dev/urandom</samp>'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-2](chapter2.xhtml#Lis2-2), copied from the LibreSSL library, shows
    a safer way to use */dev/urandom*.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: A safe use of</samp>
    <samp class="SANS_Futura_Std_Book_11">/dev/urandom</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike [Listing 2-1](chapter2.xhtml#Lis2-1), [Listing 2-2](chapter2.xhtml#Lis2-2)
    makes several sanity checks. Compare, for example, the calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>
    ❶ and to <samp class="SANS_TheSansMonoCd_W5Regular_11">read()</samp> ❷ with those
    in [Listing 2-1](chapter2.xhtml#Lis2-1): the safer code checks the return values
    of those functions and upon failure closes the file descriptor and returns –1.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Differences Between /dev/urandom
    and /dev/random, Before 2022</samp>
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Linux PRNG, defined in *drivers/char/random.c* in the Linux kernel, underwent
    major changes in 2022 (since kernel version 5.17).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: First, the general structure of the PRNG, which is similar in the old and new
    versions, is based on a collection of entropy from various sources (including
    system activity, such as keyboard, mouse, and disk accesses), as well as from
    an entropy pool that can be seen as a large array, which is filled by hashing
    data collected from the entropy sources. Next, a DRBG is responsible for producing
    the pseudorandom data streams returned when */dev/random* or */dev/urandom* is
    read or when the <samp class="SANS_TheSansMonoCd_W5Regular_11">getrandom()</samp>
    system call is made.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Historically, prior to kernel version 5.17, the Linux PRNG behaved as follows:
    unlike */dev/urandom*, the */dev/random* interface was *blocking*; if the kernel
    estimated that the PRNG had an insufficient level of entropy, then */dev/random*
    would stop returning bytes (“block”) when it was read, until a sufficient level
    of entropy was estimated by the kernel. This was not a good idea. For one thing,
    entropy estimators are notoriously unreliable and can be fooled by attackers (which
    is one reason why Fortuna ditched Yarrow’s entropy estimation). Furthermore, */dev/random*
    ran out of estimated entropy pretty quickly, which could produce a denial-of-service
    condition, slowing applications that were forced to wait for more entropy. The
    upshot is that in practice, */dev/random* was no better than */dev/urandom* and
    created more problems than it solved.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Differences Between /dev/urandom
    and /dev/random, Since 2022</samp>
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2022年以来，/dev/urandom和/dev/random的区别</samp>
- en: In versions of the Linux kernel from 2022 (5.17 onward), several improvements
    have been incorporated. First, the SHA-1 hash function has been replaced by BLAKE2
    when creating the contents of the pool. The biggest change is the modification
    of the relative behavior of */dev/random* and */dev/urandom*; it has even been
    proposed to eliminate their differences altogether. At the time of writing, on
    most platforms both interfaces will detect if there isn’t enough entropy, but
    */dev/urandom* will resume producing pseudorandom bits if the kernel fails to
    collect enough entropy, whereas */dev/random* will block.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在2022年及以后的Linux内核版本（5.17及以后），加入了几项改进。首先，在创建池内容时，SHA-1哈希函数被BLAKE2替代。最大的变化是*/dev/random*和*/dev/urandom*之间相对行为的修改；甚至有人提议完全消除它们的区别。在本文写作时，在大多数平台上，这两个接口都会检测是否没有足够的熵，但是如果内核未能收集足够的熵，*/dev/urandom*将继续生成伪随机位，而*/dev/random*则会阻塞。
- en: 'In addition, the kernel’s entropy estimation logic has been greatly improved:
    instead of considering that entropy decreases when PRNG bits are read (a cryptographic
    nonsense), the kernel just looks for the point when enough uncertainty (that is,
    entropy) has been collected—for example, at system startup.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，内核的熵估算逻辑得到了极大的改进：不再认为当读取PRNG位时熵会减少（这是一个加密学的荒谬理论），而是内核会寻找足够的不确定性（即熵）收集完成的时刻——例如，在系统启动时。
- en: You can read the entropy value of a Linux system in the */proc/sys/kernel/random/entropy_avail*
    file. In older versions of the kernel, this value was a maximum of 4,096 bits
    and decreased with the generation of PRNG bits. In the new kernels, the value
    is capped at 256 bits and therefore no longer decreases.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*/proc/sys/kernel/random/entropy_avail*文件中读取Linux系统的熵值。在旧版本的内核中，这个值最大为4,096位，并随着伪随机数生成（PRNG）位的产生而减少。而在新内核中，这个值被限制为256位，因此不再减少。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The CryptGenRandom()
    Function in Windows</samp>
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Windows中的CryptGenRandom()函数</samp>
- en: 'In Windows, the legacy userland interface to the system’s PRNG is the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CryptGenRandom()</samp> function from
    the Cryptography application programming interface (API). Recent Windows versions
    replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGenRandom()</samp>
    function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">BcryptGenRandom()</samp>
    function in the Cryptography API: Next Generation (CNG). The Windows PRNG takes
    entropy from the kernel mode driver *cng.sys* (formerly *ksecdd.sys*), whose entropy
    collector is loosely based on Fortuna. As is usually the case in Windows, the
    process is complicated.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，系统的遗留用户态接口是来自加密应用程序接口（API）的<samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGenRandom()</samp>函数。最近的Windows版本将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CryptGenRandom()</samp>函数替换为加密API：下一代（CNG）中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">BcryptGenRandom()</samp>函数。Windows的PRNG从内核模式驱动程序*cng.sys*（前身为*ksecdd.sys*）获取熵，其熵收集器在一定程度上基于Fortuna算法。像Windows中常见的那样，整个过程相对复杂。
- en: '[Listing 2-3](chapter2.xhtml#Lis2-3) shows a typical C++ invocation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CryptGenRandom()</samp> with the required
    checks.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-3](chapter2.xhtml#Lis2-3)展示了一个典型的C++调用示例，使用了带有必要检查的<samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGenRandom()</samp>函数。'
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: Using the Windows</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">CryptGenRandom()</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">PRNG interface</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-3: 使用Windows</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">CryptGenRandom()</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">PRNG接口</samp>'
- en: Prior to calling the actual PRNG, you need to declare a *cryptographic service
    provider* (<samp class="SANS_TheSansMonoCd_W5Regular_11">HCRYPTPROV</samp>) and
    then acquire a *cryptographic context* with <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext()</samp>,
    which increases the likelihood that things will go wrong. For instance, the final
    version of the TrueCrypt encryption software was found to call <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext()</samp>
    in a way that could silently fail, leading to suboptimal randomness without notifying
    the user. Fortunately, the newer and simpler <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptGenRandom()</samp>
    interface for Windows doesn’t require the code to explicitly open a handle (or
    at least makes it much easier to use without a handle).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Hardware-Based
    PRNG: Intel Secure Key</samp>'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve discussed only software PRNGs so far, so let’s take a look at a hardware
    one. The *Intel Digital Random Number Generator*, or *Intel Secure Key*, is a
    hardware PRNG introduced in 2012 in Intel’s Ivy Bridge microarchitecture. It’s
    based on NIST’s SP 800-90 guidelines with the Advanced Encryption Standard (AES)
    in CTR_DRBG mode. Intel’s PRNG is accessed through the <samp class="SANS_TheSansMonoCd_W5Regular_11">RDRAND</samp>
    assembly instruction, which offers an interface independent of the operating system
    and is in principle faster than software PRNGs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Whereas software PRNGs try to collect entropy from unpredictable sources, Intel
    Secure Key has a single entropy source that provides a serial stream of entropy
    data as zeros and ones. In hardware engineering terms, this entropy source is
    a dual differential jamb latch with feedback—essentially, a small hardware circuit
    that jumps between two states (0 or 1) depending on thermal noise fluctuations,
    at a frequency of 3 GHz. This is usually pretty reliable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">RDRAND</samp> assembly instruction
    takes as an argument a register of 16, 32, or 64 bits and then writes a random
    value. When invoked, <samp class="SANS_TheSansMonoCd_W5Regular_11">RDRAND</samp>
    sets the carry flag to 1 if the data set in the destination register is a valid
    random value, and to 0 otherwise; be sure to check the <samp class="SANS_TheSansMonoCd_W5Regular_11">CF</samp>
    flag if you write assembly code directly. Note that the C intrinsics available
    in common compilers don’t check the <samp class="SANS_TheSansMonoCd_W5Regular_11">CF</samp>
    flag but do return its value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Intel’s PRNG framework provides an assembly instruction other than RDRAND:
    the RDSEED assembly instruction returns random bits directly from the entropy
    source, after some conditioning or cryptographic processing. It’s intended to
    be able to seed other PRNGs.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Intel Secure Key is only partially documented, but it’s built on known standards
    and has been audited by the well-regarded company Cryptography Research (see its
    report titled “Analysis of Intel’s Ivy Bridge Digital Random Number Generator”).
    Nonetheless, there have been some concerns about its security, especially following
    Edward Snowden’s revelations about cryptographic backdoors: PRNGs are indeed the
    perfect target for sabotage. If you’re concerned but still want to use <samp class="SANS_TheSansMonoCd_W5Regular_11">RDRAND</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RDSEED</samp>, mix them with
    other entropy sources. Doing so will prevent effective exploitation of a hypothetical
    backdoor in Intel Secure Key’s hardware or in the associated microcode in all
    but the most far-fetched scenarios.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To conclude, I’ll present a few examples of randomness failures. There are countless
    examples to choose from, but I’ve chosen four that are simple enough to understand
    and illustrate different problems.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Poor Entropy
    Sources</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In 1996, the SSL implementation of the Netscape browser was computing 128-bit
    PRNG seeds according to the pseudocode shown in [Listing 2-4](chapter2.xhtml#Lis2-4),
    copied from Goldberg and Wagner’s page at *[https://<wbr>www<wbr>.cs<wbr>.berkeley<wbr>.edu<wbr>/~daw<wbr>/papers<wbr>/ddj<wbr>-netscape<wbr>.html](https://www.cs.berkeley.edu/~daw/papers/ddj-netscape.html)*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: Pseudocode of
    the Netscape browser’s generation of 128-bit PRNG seeds</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that the PIDs and microseconds are guessable values. Assuming
    that you can guess the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">seconds</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">microseconds</samp> has only 10⁶
    possible values and thus an entropy of log(10⁶), or about 20 bits. The process
    ID (PID) and parent process ID (PPID) are 15-bit values, so you’d expect 15 +
    15 = 30 additional entropy bits. But looking at how <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is computed ❶ shows that the overlap of 3 bits yields an entropy of about 15 +
    12 = 27 bits, for a total entropy of only 47 bits, whereas a 128-bit seed should
    have 128 bits of entropy.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Insufficient Entropy
    at Boot Time</samp>
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 2012, researchers scanned the internet and harvested public keys from TLS
    certificates and SSH hosts. They found that a handful of systems had identical
    public keys, and in some cases very similar keys (namely, RSA keys with shared
    prime factors)—in short, two numbers, *n* = *pq* and *n*′ = *p*′*q*′, with *p*
    = *p*′, whereas normally all *p*s and *q*s should be different in distinct modulus
    values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: It turned out that many devices generated their public key early, at first boot,
    before having collected enough entropy, despite using an otherwise-decent PRNG
    (typically */dev/urandom*). PRNGs in different systems produced identical random
    bits due to having the same entropy source (for example, a hardcoded seed).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，许多设备在启动时就生成了它们的公钥，在收集足够的熵之前就已经生成，尽管它们使用了其他正常的PRNG（通常是*/dev/urandom*）。不同系统中的PRNG生成了相同的随机位，因为它们使用了相同的熵源（例如，硬编码的种子）。
- en: 'At a high level, the presence of identical keys is due to key-generation schemes
    like the following, in pseudocode:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，相同密钥的存在是由于类似以下的密钥生成方案，伪代码如下：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If two systems run this code given an identical seed, they’ll produce the same
    *p*, the same *q*, and therefore the same *n*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个系统在相同种子的情况下运行此代码，它们将生成相同的*p*、相同的*q*，因此也会生成相同的*n*。
- en: 'The presence of shared primes in different keys is due to key-generation schemes
    where additional entropy is injected during the process, as demonstrated here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 不同密钥中共享质因子的存在是由于密钥生成方案，在该过程中注入了额外的熵，如下所示：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If two systems run this code with the same seed, they’ll produce the same *p*,
    but the injection of entropy through <samp class="SANS_TheSansMonoCd_W5Regular_11">prng.add_entropy()</samp>
    will ensure distinct *q*s.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个系统使用相同的种子运行此代码，它们将生成相同的*p*，但通过<samp class="SANS_TheSansMonoCd_W5Regular_11">prng.add_entropy()</samp>注入的熵将确保生成不同的*q*。
- en: The problem with shared prime factors is that given *n* = *pq* and *n*′ = *pq*′,
    it’s trivial to recover the shared *p* by computing the greatest common divisor
    (GCD) of *n* and *n*′. For details, see the paper “Mining Your Ps and Qs” by Heninger,
    Durumeric, Wustrow, and Halderman, available at *[https://<wbr>factorable<wbr>.net](https://factorable.net)*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 共享质因子的问提在于，给定*n* = *pq*和*n*′ = *pq*′，通过计算*n*和*n*′的最大公约数（GCD），可以轻松恢复共享的*p*。有关详细信息，请参见Heninger、Durumeric、Wustrow和Halderman的论文《Mining
    Your Ps and Qs》，可以在*[https://<wbr>factorable<wbr>.net](https://factorable.net)找到。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Noncryptographic
    PRNG</samp>
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">非加密PRNG</samp>
- en: Earlier we discussed the difference between crypto and noncrypto PRNGs and why
    the latter should never be used for crypto applications. Alas, many systems overlook
    that detail, so we’ll look at one such example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们讨论了加密PRNG和非加密PRNG之间的区别，以及为什么后者永远不应该用于加密应用程序。可惜的是，许多系统忽略了这一点，因此我们将看看其中一个这样的例子。
- en: 'The popular MediaWiki application runs on Wikipedia and many other wikis. It
    uses randomness to generate things like security tokens and temporary passwords,
    which should be unpredictable. Unfortunately, a now obsolete version of MediaWiki
    used a noncrypto PRNG, the Mersenne Twister, to generate these tokens and passwords.
    Here’s a snippet from the vulnerable MediaWiki source code; look for the function
    called to get a random bit, and read the comments:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的MediaWiki应用程序运行在Wikipedia和许多其他维基网站上。它使用随机性来生成诸如安全令牌和临时密码等内容，这些内容应该是不可预测的。不幸的是，MediaWiki的一个现已过时的版本使用了一个非加密的PRNG——梅森旋转算法（Mersenne
    Twister），来生成这些令牌和密码。以下是漏洞版MediaWiki源代码的一个片段；查找获取随机位的函数，并阅读注释：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Did you notice <samp class="SANS_TheSansMonoCd_W5Regular_11">mt_rand()</samp>
    in the preceding code? Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">mt</samp>
    stands for Mersenne Twister. In 2012, researchers showed how to exploit the predictability
    of Mersenne Twister to predict future tokens and temporary passwords, given a
    couple of security tokens. MediaWiki was patched to use a crypto PRNG.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到前面的代码中的<samp class="SANS_TheSansMonoCd_W5Regular_11">mt_rand()</samp>了吗？这里，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mt</samp>代表梅森旋转算法（Mersenne Twister）。在2012年，研究人员展示了如何利用梅森旋转算法的可预测性，基于几个安全令牌预测未来的令牌和临时密码。MediaWiki已经修补，改用了加密PRNG。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sampling Bug
    with Strong Randomness</samp>'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">具有强随机性的采样错误</samp>'
- en: The next bug shows how even a strong crypto PRNG with sufficient entropy can
    produce a biased distribution. The chat program Cryptocat was designed to offer
    secure communication. It used a function that attempted to create a uniformly
    distributed string of decimal digits—namely, numbers in the range 0 through 9\.
    However, just taking random bytes modulo 10 doesn’t yield a uniform distribution;
    when taking all numbers between 0 and 255 and reducing them modulo 10, you don’t
    get an equal number of values in 0 to 9.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Cryptocat did the following to address that problem and obtain a uniform distribution:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And that was almost perfect. By taking only the numbers up to a multiple of
    10 and discarding others, you’d expect a uniform distribution of the digits 0
    through 9\. Unfortunately, there was an off-by-one error in the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    condition. I’ll leave the details to you as an exercise. You should find that
    there is a small statistical bias in favor of the index 0 (hint: <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    should have been <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve just scratched the surface of randomness in cryptography. There is much
    more to learn about the theory of randomness, including different entropy notions,
    randomness extractors, and even the power of randomization and derandomization
    in complexity theory. To learn more about PRNGs and their security, read the classic
    1998 paper “Cryptanalytic Attacks on Pseudorandom Number Generators” by Kelsey,
    Schneier, Wagner, and Hall. Then look at the implementation of PRNGs in your favorite
    applications and try to find their weaknesses. (Search online for “random generator
    bug” to find plenty of examples.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We’re not done with randomness, though. We’ll encounter it multiple times throughout
    this book, and you’ll discover the many ways it helps to construct secure systems.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
