- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">RANDOMNESS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Randomness is found everywhere in cryptography: in the generation of secret
    keys, in encryption schemes, and even in the attacks on cryptosystems. Without
    randomness, cryptography would be impossible because all operations would become
    predictable and therefore insecure.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces the concept of randomness in the context of cryptography
    and its applications. We discuss pseudorandom number generators and how operating
    systems can produce reliable randomness, and we conclude with real examples showing
    how flawed randomness can impact security.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Random or Nonrandom?</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve probably heard the phrase *random bits* before, but strictly speaking,
    there is no such thing as a series of random bits. What *is* random is the *algorithm*,
    or process, that produces a series of random bits; therefore, when we say “random
    bits,” we actually mean randomly generated bits.
  prefs: []
  type: TYPE_NORMAL
- en: What do random bits look like? For example, the 8-bit string 11010110 might
    look more random than 00000000, although both have the same chance of being generated
    (namely, 1/256). The value 11010110 looks more random than 00000000 because it
    has the signs typical of a randomly generated value. That is, 11010110 has no
    obvious pattern.
  prefs: []
  type: TYPE_NORMAL
- en: When we see the string 11010110, our brain registers that it has 3 zeros and
    5 ones, just like 55 other 8-bit strings (11111000, 11110100, 11110010, and so
    on), but only one 8-bit string has 8 zeros. Because the pattern 3-zeros-and-5-ones
    is more likely to occur than the pattern 8-zeros, we identify 11010110 as random
    and 00000000 as nonrandom, even if they’re not.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example illustrates two types of errors people often make when identifying
    randomness:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mistaking nonrandomness for randomness **Thinking that an object was randomly
    generated simply because it *looks* random'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mistaking randomness for nonrandomness **Thinking that patterns appearing
    by chance are there for a reason other than chance'
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between random-looking and actually random is crucial. Indeed,
    in crypto, nonrandomness is often synonymous with insecurity.
  prefs: []
  type: TYPE_NORMAL
- en: The saying “it happened by chance” reflects the property that from a complex
    system (in this case, our universe that obeys the laws of physics, deterministic
    at the macroscopic level and truly random at the subatomic, quantum level) can
    emerge specific patterns, such as the string 00000000\. By the law of large numbers,
    if many events occur, some won’t look random—such as a series of sequential numbers
    in a lottery draw. Many pseudosciences and belief systems are in fact cases of
    mistaking randomness for nonrandomness.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Randomness as a Probability Distribution</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any randomized process is characterized by a *probability distribution*, which
    gives all there is to know about the randomness of the process. A probability
    distribution, or simply *distribution*, lists the outcomes of a randomized process
    where each outcome is assigned a probability.
  prefs: []
  type: TYPE_NORMAL
- en: A *probability* measures the likelihood of an event occurring. It’s expressed
    as a real number between 0 and 1 where a probability of 0 means impossible and
    a probability of 1 means certain. For example, when tossing a two-sided coin,
    each side has a 1/2 (or 0.5) probability of landing face up, and the probability
    of a coin landing on its edge has a probability close to 0.
  prefs: []
  type: TYPE_NORMAL
- en: A probability distribution must include all possible outcomes such that the
    sum of all probabilities is 1\. Specifically, if there are *N* possible events,
    there are *N* probabilities *p*[1], *p*[2], . . . , *p*N with *p*[1] + *p*[2]
    + . . . + *p*N = 1\. In the case of the coin toss, the distribution is 1/2 for
    heads and 1/2 for tails. The sum of both probabilities is equal to 1/2 + 1/2 =
    1, because the coin will fall on one of its two faces.
  prefs: []
  type: TYPE_NORMAL
- en: A *uniform distribution* occurs when all probabilities in the distribution are
    equal, meaning that all outcomes are equally likely to occur. If there are *N*
    events, then each event has probability 1/*N*. For example, if a 128-bit key is
    picked uniformly at random—that is, according to a uniform distribution—then each
    of the 2^(128) possible keys should have a probability of 1/2^(128).
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, when a distribution is *nonuniform*, probabilities aren’t all equal.
    A coin toss with a nonuniform distribution is said to be biased and may yield
    heads with probability 1/4 and tails with probability 3/4, for example.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*It’s possible to cheat with a loaded die, preventing the probabilities of
    each of the six faces to be 1/6; however, one can’t bias a coin. Coin tosses can
    be biased only if “the coin is allowed to bounce or be spun rather than simply
    flipped in the air,” as described in the article “You Can Load a Die but You Can’t
    Bias a Coin” (available at* [https://<wbr>www<wbr>.stat<wbr>.berkeley<wbr>.edu<wbr>/~nolan<wbr>/Papers<wbr>/dice<wbr>.pdf](https://www.stat.berkeley.edu/~nolan/Papers/dice.pdf)).'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Entropy: A Measure of Uncertainty</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Entropy* is the measure of uncertainty, or disorder, in a system. The higher
    the entropy, the less certainty found in the result of a randomized process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compute the entropy of a probability distribution. If your distribution
    consists of probabilities *p*[1], *p*[2], . . . , *p*N, then its entropy is the
    negative sum of all probabilities multiplied by their logarithm, as shown in this
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg27-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here the function *log* is the *binary logarithm*, or logarithm in base two.
    Unlike the natural logarithm, the binary logarithm expresses the information in
    bits and yields integer values when probabilities are powers of two. For example,
    log(1/2) = –1, log(1/4) = –2, and more generally log(1/2*^n*) = –*n*. (We actually
    take the *negative sum* to end up with a positive number.) Random 128-bit keys
    produced using a uniform distribution therefore have the following entropy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg27-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you replace 128 with any integer *n*, the entropy of a uniformly distributed
    *n*-bit string will be *n* bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entropy is maximized when the distribution is uniform because a uniform distribution
    maximizes uncertainty: no outcome is more likely than the others. Therefore, *n*-bit
    values can’t have more than *n* bits of entropy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the same token, when the distribution is not uniform, entropy is lower.
    Consider the coin toss example. The entropy of a fair toss is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg28-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What if one side of the coin has a higher probability of landing face up than
    the other? Say heads has a probability of 1/4 and tails 3/4\. (Remember that the
    sum of all probabilities should be 1.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The entropy of such a biased toss is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg28-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The fact that 0.81 is less than the 1-bit entropy of a fair toss tells us that
    the more biased the coin, the less uniform the distribution and the lower the
    entropy. Taking this example further, if heads has a probability of 1/10, the
    entropy is 0.469; if the probability drops to 1/100, the entropy drops to 0.081.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Entropy can also be viewed as a measure of information. For example, the result
    of a fair coin toss gives you exactly 1 bit of information—heads or tails—and
    you’re unable to predict the result of the toss in advance. In the case of the
    unfair coin toss, you know in advance that tails is more probable, so you can
    predict the outcome. The result of the unfair coin toss gives you the information
    needed to predict the result with certainty.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Random and Pseudorandom Number Generators</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cryptosystems need randomness to be secure and therefore need a component from
    which to get their randomness. The job of this component is to return random bits
    when requested to do so. To perform this randomness generation, you’ll need two
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: A source of entropy, provided by random number generators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cryptographic algorithm to produce high-quality random bits from the source
    of entropy. This is found in pseudorandom number generators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using both random and pseudorandom number generators is the key to making cryptography
    practical and secure. Let’s briefly look at how random number generators work
    before exploring pseudorandom number generators in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Randomness comes from the environment, which is analog, chaotic, uncertain,
    and hence unpredictable. Randomness can’t be generated by computer-based algorithms
    alone. In cryptography, randomness usually comes from *random number generators
    (RNGs)*, which are software or hardware components that leverage entropy in the
    analog world to produce unpredictable bits in a digital system. For example, an
    RNG might directly sample bits from measurements of temperature, acoustic noise,
    air turbulence, or electrical static. Unfortunately, such analog entropy sources
    aren’t always available, and their entropy is often difficult to estimate.
  prefs: []
  type: TYPE_NORMAL
- en: RNGs can also harvest the entropy in a running operating system by drawing from
    attached sensors, I/O devices, network or disk activity, system logs, running
    processes, and user activities such as key presses and mouse movement. Such system-
    and human-generated activities can be a good source of entropy, but they can be
    fragile and manipulated by an attacker. Also, they’re slow to yield random bits.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Quantum random number generators (QRNGs) *are a type of RNG that rely on the
    randomness arising from quantum mechanical phenomena, such as radioactive decay,
    photon polarization, or thermal noise. These phenomena, not being characterized
    by equations that determine the future state from the current state, are random
    in the absolute sense. In practice, however, the raw bits extracted from a QRNG
    may be biased and tend to be slow to produce. Like the previously cited entropy
    sources, they require postprocessing to generate reliable bits at high speed.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Pseudorandom number generators (PRNGs)* address the challenge in generating
    randomness by reliably producing many artificial random bits from a few true random
    bits. For example, an RNG that translates mouse movements to random bits would
    stop working if you stop moving the mouse, whereas a PRNG always returns pseudorandom
    bits when requested to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PRNGs rely on RNGs but behave differently: RNGs produce true random bits relatively
    slowly from analog sources, in a nondeterministic way, and with no guarantee of
    uniform distribution or of high entropy per bit. In contrast, PRNGs produce random-looking
    bits quickly from digital sources, in a deterministic way, uniformly distributed,
    and with an entropy guaranteed to be high enough for cryptographic applications.
    Essentially, PRNGs transform a few unreliable random bits into a long stream of
    reliable pseudorandom bits suitable for crypto applications, as [Figure 2-1](chapter2.xhtml#fig2-1)
    shows.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig2-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: RNGs produce few
    unreliable bits from analog sources, whereas PRNGs expand those bits to a long
    stream of reliable bits.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How PRNGs Work</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A PRNG receives random bits from an RNG at regular intervals and uses them to
    update the contents of a large memory buffer, called the *entropy pool*. The entropy
    pool is the PRNG’s source of entropy, just like the physical environment is to
    an RNG. When the PRNG updates the entropy pool, it mixes the pool’s bits together
    to help remove any statistical bias.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate pseudorandom bits, the PRNG runs a deterministic random bit generator
    (DRBG) algorithm that expands some bits from the entropy pool into a much longer
    sequence. As its name suggests, a DRBG is deterministic, not randomized: given
    one input, you will always get the same output. The PRNG ensures that its DRBG
    never receives the same input twice so it can generate unique pseudorandom sequences.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the course of its work, the PRNG performs three operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '***init()* **Initializes the entropy pool and the internal state of the PRNG'
  prefs: []
  type: TYPE_NORMAL
- en: '***refresh(R)* **Updates the entropy pool using some data, *R*, usually sourced
    from an RNG'
  prefs: []
  type: TYPE_NORMAL
- en: '***next(N)* **Returns *N* pseudorandom bits and updates the entropy pool'
  prefs: []
  type: TYPE_NORMAL
- en: The *init* operation resets the PRNG to a fresh state, reinitializes the entropy
    pool to some default value, and initializes any variables or memory buffers used
    by the PRNG to carry out the *refresh* and *next* operations.
  prefs: []
  type: TYPE_NORMAL
- en: The *refresh* operation is often called *reseeding*, and its argument *R* is
    called a *seed*. When no RNG is available, seeds may be unique values hardcoded
    in a system. The *refresh* operation is typically called by the operating system,
    whereas *next* is typically called or requested by applications. The *next* operation
    runs the DRBG and modifies the entropy pool to ensure that the next call will
    yield different pseudorandom bits.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Concerns</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s talk briefly about how PRNGs address high-level security concerns. Specifically,
    PRNGs should guarantee *backtracking resistance* and *prediction resistance*.
    Backtracking resistance (also called *forward secrecy*) means that previously
    generated bits are impossible to recover, whereas prediction resistance (*backward
    secrecy*) means that future bits should be impossible to predict.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve backtracking resistance, the PRNG should ensure that the transformations
    performed when updating the state through the *refresh* and *next* operations
    are irreversible. This way, if an attacker compromises the system and obtains
    the entropy pool’s value, they can’t determine the previous values of the pool
    or the previously generated bits. To achieve prediction resistance, the PRNG should
    call *refresh* regularly with *R* values that are unknown to an attacker and are
    difficult to guess, thus preventing an attacker from determining future values
    of the entropy pool, even if the whole pool is compromised. (If the list of *R*
    values were known, you’d need to know the order in which *refresh* and *next*
    calls were made to reconstruct the pool.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The PRNG Fortuna</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Fortuna* is a PRNG construction used in Windows originally designed in 2003
    by Niels Ferguson and Bruce Schneier. Fortuna superseded *Yarrow*, a 1998 design
    by John Kelsey and Bruce Schneier that was for a long time used in the macOS and
    iOS operating systems and has been replaced by Fortuna. I won’t provide the Fortuna
    specification here or show you how to implement it, but I will try to explain
    how it works. You’ll find a complete description of Fortuna in [Chapter 9](chapter9.xhtml)
    of *Cryptography Engineering* by Ferguson, Schneier, and Kohno (Wiley, 2010).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortuna’s internal memory includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Thirty-two entropy pools, *P*[1], *P*[2], . . . , *P*[32], such that *P*i is
    used every 2*^i* reseeds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key, *K*, and a counter, *C* (both 16 bytes). These form the internal state
    of Fortuna’s DRBG.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In simplest terms, Fortuna works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*init*() sets *K* and *C* to zero and empties the 32 entropy pools *P*i, where
    *i* = 1 . . . 32.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*refresh*(*R*) appends the data, *R*, to one of the entropy pools. The system
    chooses the RNGs used to produce *R* values, and it should call *refresh* regularly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*next*(*N*) updates *K* using data from one or more entropy pools, where the
    choice of the entropy pools depends mainly on how many updates of *K* have already
    been done. The *N* bits requested are then produced by encrypting *C* using *K*
    as a key. If encrypting *C* is not enough, Fortuna encrypts *C* + 1, then *C*
    + 2, and so on, to get enough bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although Fortuna’s operations look fairly simple, implementing them correctly
    is hard. For one, you need to get all the details of the algorithm right—how entropy
    pools are chosen, the type of cipher to be used in *next*, how to behave when
    no entropy is received, and so on. Although the specs define most of the details,
    they don’t include a comprehensive test suite to check that an implementation
    is correct, which makes it difficult to ensure that your implementation of Fortuna
    will behave as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Even if Fortuna is correctly implemented, security failures may occur for reasons
    other than the use of an incorrect algorithm. For example, Fortuna might not notice
    if the RNGs fail to produce enough random bits, and as a result Fortuna will produce
    lower-quality pseudorandom bits, or it may stop delivering pseudorandom bits altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Another risk inherent in Fortuna implementations lies in the possibility of
    exposing associated *seed files* to attackers. The data in Fortuna seed files
    is used to feed entropy to Fortuna through *refresh* calls when an RNG is not
    immediately available—for example, immediately after a system reboot and before
    the system’s RNGs have recorded any unpredictable events. However, if an identical
    seed file is used twice, Fortuna will produce the same bit sequence twice. Seed
    files should therefore be erased after use to ensure they aren’t reused.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if two Fortuna instances are in the same state because they’re sharing
    a seed file (meaning the same data in the entropy pools, including *C* and *K*),
    then the *next* operation will return the same bits in both instances.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Cryptographic
    vs. Noncryptographic PRNGs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: There are cryptographic and noncryptographic PRNGs. Noncrypto PRNGs are designed
    to produce uniform distributions for applications such as scientific simulations
    or video games. However, you should never use noncrypto PRNGs in crypto applications,
    because they’re insecure; they’re concerned only with the quality of the bits’
    probability distribution and not with their predictability. Crypto PRNGs, on the
    other hand, are unpredictable because they’re also concerned with the strength
    of the underlying *operations* used to deliver well-distributed bits.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, most PRNGs exposed by programming languages—such as libc’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">rand</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">drand48</samp>,
    PHP’s <samp class="SANS_TheSansMonoCd_W5Regular_11">rand</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">mt_rand</samp>,
    Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">random</samp> module, and
    Java’s <samp class="SANS_TheSansMonoCd_W5Regular_11">java.util.Random</samp> class—are
    noncryptographic. Defaulting to a noncrypto PRNG is a recipe for disaster because
    it often ends up being used in crypto applications, so be sure to use only crypto
    PRNGs when generating randomness related to cryptographic or security applications.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_B_11">A Popular Noncrypto PRNG:
    Mersenne Twister</samp>'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *Mersenne Twister (MT)* algorithm is a noncryptographic PRNG used (at the
    time of this writing) in PHP, Python, R, Ruby, and many other systems. It’s even
    been used (unfortunately) in blockchain wallet key generators. MT generates uniformly
    distributed random bits without statistical bias, but it’s predictable: given
    a few bits produced by MT, one can guess which bits will follow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look under the hood to see what makes the Mersenne Twister insecure.
    The MT algorithm is much simpler than that of crypto PRNGs: its internal state
    is an array, *S*, consisting of 624 32-bit words. This array is initially set
    to *S*[1], *S*[2], . . . , *S*[624] and evolves to *S*[2], . . . , *S*[625], then
    *S*[3], . . . , *S*[626], and so on, according to this equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg32-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, ⊕ denotes the bitwise XOR (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>
    in the C programming language), ∧ denotes the bitwise AND (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    in C), ∨ denotes the bitwise OR (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>
    in C), and **A** is a function that transforms some 32-bit word, *x*, to (*x*
    >> 1) if *x*’s most significant bit is 0, or to (*x* >> 1) ⊕ 0x9908b0df otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: In this equation, bits of *S* interact with each other only through XORs. The
    operators ∧ and ∨ never combine 2 bits of *S* together but instead combine bits
    of *S* with bits from the constants 0x80000000 and 0x7fffffff. This way, any bit
    from *S*[625] can be expressed as an XOR of bits from *S*[398], *S*[1], and *S*[2],
    and any bit from any future state can be expressed as an XOR combination of bits
    from the initial state *S*[1], . . . , *S*[624]. (When you express, say, *S*[228
    + 624] = *S*[852] as a function of *S*[625], *S*[228], and *S*[229], you can in
    turn replace *S*[625] by its expression in terms of *S*[398], *S*[1], and *S*[2].)
  prefs: []
  type: TYPE_NORMAL
- en: 'Because there are exactly 624 × 32 = 19,968 bits in the initial state (or 624
    32-bit words), any output bit can be expressed as an equation with at most 19,969
    terms (19,968 bits plus one constant bit). That’s about 2.5KB of data. The converse
    is also true: bits from the initial state can be expressed as an XOR of output
    bits.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Linearity Insecurity</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We call an XOR combination of bits a *linear combination*. For example, if *X*,
    *Y*, and *Z* are bits, then the expression *X* ⊕ *Y* ⊕ *Z* is a linear combination,
    whereas (*X* ∧ *Y*) ⊕ *Z* is not because there’s an AND (∧). If you flip a bit
    of *X* in *X* ⊕ *Y* ⊕ *Z*, then the result changes as well, regardless of *Y*’s
    and *Z*’s values. In contrast, if you flip a bit of *X* in (*X* ∧ *Y*) ⊕ *Z*,
    the result changes only if *Y*’s bit at the same position is 1\. The upshot is
    that linear combinations are predictable because you don’t need to know the value
    of the bits in order to predict how a change in their value will affect the result.
  prefs: []
  type: TYPE_NORMAL
- en: For comparison, if the MT algorithm were cryptographically strong, its equations
    would be *nonlinear* and would involve not only single bits but also AND combinations
    (*products*) of bits, such as *S*[1]*S*[15]*S*[182] or *S*[17]*S*[256]*S*[257]*S*[354]*S*[498]*S*[601].
    Although linear combinations of those bits include at most 624 variables, nonlinear
    combinations allow for up to 2^(624) variables. It would be impossible to solve,
    let alone write down, the whole of these equations. (Note that 2^(305), a much
    smaller number, is the estimated information capacity of the observable universe.)
  prefs: []
  type: TYPE_NORMAL
- en: The key here is that linear transformations lead to short equations (comparable
    in size to the number of variables), which are easy to solve, whereas nonlinear
    transformations give rise to equations of exponential size, which are practically
    unsolvable. The game of cryptographers is thus to design PRNG algorithms that
    emulate such complex nonlinear transformations using only a small number of simple
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Linearity is just one of many security criteria. Although necessary, nonlinearity
    alone does not make a PRNG cryptographically secure.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Uselessness of
    Statistical Tests</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Statistical test suites like TestU01, Diehard, or the National Institute of
    Standards and Technology (NIST) test suite are one way to test the quality of
    pseudorandom bits. These tests take a sample of pseudorandom bits produced by
    a PRNG (say, 1MB’s worth), compute some statistics on the distribution of certain
    patterns in the bits, and compare the results with the typical results obtained
    for a uniform distribution. For example, some tests count the number of 1 bits
    versus the number of 0 bits, or the distribution of 8-bit patterns. But statistical
    tests are largely irrelevant to cryptographic security, and it’s possible to design
    a cryptographically weak PRNG that fools any statistical test.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run statistical tests on randomly generated data, you will usually
    see a bunch of statistical indicators as a result. These are typically *p*-values,
    a common statistical indicator. These results aren’t always easy to interpret
    because they’re rarely as simple as passed or failed. If your first results seem
    abnormal, don’t worry: they may be the result of some accidental deviation, or
    you may be testing too few samples. To ensure that the results you see are normal,
    compare them with those obtained for some reliable sample of identical size—for
    example, one generated with the OpenSSL toolkit using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_B_11">Real-World PRNGs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s turn our attention to implementing PRNGs in the real world. You’ll find
    crypto PRNGs in the operating systems (OSs) of most platforms, from desktops and
    laptops to embedded systems such as routers and set-top boxes, as well as virtual
    machines, mobile phones, and so on. Most of these PRNGs are software based, but
    those that are pure hardware are used by applications running on the OS and sometimes
    by other PRNGs running on top of cryptographic libraries or applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll look at the most widely deployed PRNGs: for Linux, Android, and
    many other Unix-based systems; in Windows; and in recent Intel microprocessors,
    whose PRNG is hardware based.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Random Bits in Linux</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The device file */dev/urandom* is the userland interface to the crypto PRNG
    in operating systems based on the Linux kernel. You’ll typically use it to generate
    reliable random bits. Because it’s a device file, you request random bits from
    */dev/urandom* by reading it as a file. For example, the following command uses
    */dev/urandom* to write 10MB of random bits to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Wrong Way to Use /dev/urandom</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You could write a naive and insecure C program like the one shown in [Listing
    2-1](chapter2.xhtml#Lis2-1) to read random bits and hope for the best, but that
    would be a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: An insecure use
    of</samp> <samp class="SANS_Futura_Std_Book_11">/dev/urandom</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is insecure; it doesn’t even check the return values of <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">read()</samp>, which means your
    expected random buffer could end up filled with zeros or left unchanged.  #####
    <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A Safer Way to Use /dev/urandom</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-2](chapter2.xhtml#Lis2-2), copied from the LibreSSL library, shows
    a safer way to use */dev/urandom*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: A safe use of</samp>
    <samp class="SANS_Futura_Std_Book_11">/dev/urandom</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike [Listing 2-1](chapter2.xhtml#Lis2-1), [Listing 2-2](chapter2.xhtml#Lis2-2)
    makes several sanity checks. Compare, for example, the calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>
    ❶ and to <samp class="SANS_TheSansMonoCd_W5Regular_11">read()</samp> ❷ with those
    in [Listing 2-1](chapter2.xhtml#Lis2-1): the safer code checks the return values
    of those functions and upon failure closes the file descriptor and returns –1.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Differences Between /dev/urandom
    and /dev/random, Before 2022</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Linux PRNG, defined in *drivers/char/random.c* in the Linux kernel, underwent
    major changes in 2022 (since kernel version 5.17).
  prefs: []
  type: TYPE_NORMAL
- en: First, the general structure of the PRNG, which is similar in the old and new
    versions, is based on a collection of entropy from various sources (including
    system activity, such as keyboard, mouse, and disk accesses), as well as from
    an entropy pool that can be seen as a large array, which is filled by hashing
    data collected from the entropy sources. Next, a DRBG is responsible for producing
    the pseudorandom data streams returned when */dev/random* or */dev/urandom* is
    read or when the <samp class="SANS_TheSansMonoCd_W5Regular_11">getrandom()</samp>
    system call is made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Historically, prior to kernel version 5.17, the Linux PRNG behaved as follows:
    unlike */dev/urandom*, the */dev/random* interface was *blocking*; if the kernel
    estimated that the PRNG had an insufficient level of entropy, then */dev/random*
    would stop returning bytes (“block”) when it was read, until a sufficient level
    of entropy was estimated by the kernel. This was not a good idea. For one thing,
    entropy estimators are notoriously unreliable and can be fooled by attackers (which
    is one reason why Fortuna ditched Yarrow’s entropy estimation). Furthermore, */dev/random*
    ran out of estimated entropy pretty quickly, which could produce a denial-of-service
    condition, slowing applications that were forced to wait for more entropy. The
    upshot is that in practice, */dev/random* was no better than */dev/urandom* and
    created more problems than it solved.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Differences Between /dev/urandom
    and /dev/random, Since 2022</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In versions of the Linux kernel from 2022 (5.17 onward), several improvements
    have been incorporated. First, the SHA-1 hash function has been replaced by BLAKE2
    when creating the contents of the pool. The biggest change is the modification
    of the relative behavior of */dev/random* and */dev/urandom*; it has even been
    proposed to eliminate their differences altogether. At the time of writing, on
    most platforms both interfaces will detect if there isn’t enough entropy, but
    */dev/urandom* will resume producing pseudorandom bits if the kernel fails to
    collect enough entropy, whereas */dev/random* will block.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the kernel’s entropy estimation logic has been greatly improved:
    instead of considering that entropy decreases when PRNG bits are read (a cryptographic
    nonsense), the kernel just looks for the point when enough uncertainty (that is,
    entropy) has been collected—for example, at system startup.'
  prefs: []
  type: TYPE_NORMAL
- en: You can read the entropy value of a Linux system in the */proc/sys/kernel/random/entropy_avail*
    file. In older versions of the kernel, this value was a maximum of 4,096 bits
    and decreased with the generation of PRNG bits. In the new kernels, the value
    is capped at 256 bits and therefore no longer decreases.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The CryptGenRandom()
    Function in Windows</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Windows, the legacy userland interface to the system’s PRNG is the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CryptGenRandom()</samp> function from
    the Cryptography application programming interface (API). Recent Windows versions
    replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGenRandom()</samp>
    function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">BcryptGenRandom()</samp>
    function in the Cryptography API: Next Generation (CNG). The Windows PRNG takes
    entropy from the kernel mode driver *cng.sys* (formerly *ksecdd.sys*), whose entropy
    collector is loosely based on Fortuna. As is usually the case in Windows, the
    process is complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-3](chapter2.xhtml#Lis2-3) shows a typical C++ invocation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CryptGenRandom()</samp> with the required
    checks.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: Using the Windows</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">CryptGenRandom()</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">PRNG interface</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to calling the actual PRNG, you need to declare a *cryptographic service
    provider* (<samp class="SANS_TheSansMonoCd_W5Regular_11">HCRYPTPROV</samp>) and
    then acquire a *cryptographic context* with <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext()</samp>,
    which increases the likelihood that things will go wrong. For instance, the final
    version of the TrueCrypt encryption software was found to call <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext()</samp>
    in a way that could silently fail, leading to suboptimal randomness without notifying
    the user. Fortunately, the newer and simpler <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptGenRandom()</samp>
    interface for Windows doesn’t require the code to explicitly open a handle (or
    at least makes it much easier to use without a handle).
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Hardware-Based
    PRNG: Intel Secure Key</samp>'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve discussed only software PRNGs so far, so let’s take a look at a hardware
    one. The *Intel Digital Random Number Generator*, or *Intel Secure Key*, is a
    hardware PRNG introduced in 2012 in Intel’s Ivy Bridge microarchitecture. It’s
    based on NIST’s SP 800-90 guidelines with the Advanced Encryption Standard (AES)
    in CTR_DRBG mode. Intel’s PRNG is accessed through the <samp class="SANS_TheSansMonoCd_W5Regular_11">RDRAND</samp>
    assembly instruction, which offers an interface independent of the operating system
    and is in principle faster than software PRNGs.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas software PRNGs try to collect entropy from unpredictable sources, Intel
    Secure Key has a single entropy source that provides a serial stream of entropy
    data as zeros and ones. In hardware engineering terms, this entropy source is
    a dual differential jamb latch with feedback—essentially, a small hardware circuit
    that jumps between two states (0 or 1) depending on thermal noise fluctuations,
    at a frequency of 3 GHz. This is usually pretty reliable.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">RDRAND</samp> assembly instruction
    takes as an argument a register of 16, 32, or 64 bits and then writes a random
    value. When invoked, <samp class="SANS_TheSansMonoCd_W5Regular_11">RDRAND</samp>
    sets the carry flag to 1 if the data set in the destination register is a valid
    random value, and to 0 otherwise; be sure to check the <samp class="SANS_TheSansMonoCd_W5Regular_11">CF</samp>
    flag if you write assembly code directly. Note that the C intrinsics available
    in common compilers don’t check the <samp class="SANS_TheSansMonoCd_W5Regular_11">CF</samp>
    flag but do return its value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Intel’s PRNG framework provides an assembly instruction other than RDRAND:
    the RDSEED assembly instruction returns random bits directly from the entropy
    source, after some conditioning or cryptographic processing. It’s intended to
    be able to seed other PRNGs.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Intel Secure Key is only partially documented, but it’s built on known standards
    and has been audited by the well-regarded company Cryptography Research (see its
    report titled “Analysis of Intel’s Ivy Bridge Digital Random Number Generator”).
    Nonetheless, there have been some concerns about its security, especially following
    Edward Snowden’s revelations about cryptographic backdoors: PRNGs are indeed the
    perfect target for sabotage. If you’re concerned but still want to use <samp class="SANS_TheSansMonoCd_W5Regular_11">RDRAND</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RDSEED</samp>, mix them with
    other entropy sources. Doing so will prevent effective exploitation of a hypothetical
    backdoor in Intel Secure Key’s hardware or in the associated microcode in all
    but the most far-fetched scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To conclude, I’ll present a few examples of randomness failures. There are countless
    examples to choose from, but I’ve chosen four that are simple enough to understand
    and illustrate different problems.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Poor Entropy
    Sources</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In 1996, the SSL implementation of the Netscape browser was computing 128-bit
    PRNG seeds according to the pseudocode shown in [Listing 2-4](chapter2.xhtml#Lis2-4),
    copied from Goldberg and Wagner’s page at *[https://<wbr>www<wbr>.cs<wbr>.berkeley<wbr>.edu<wbr>/~daw<wbr>/papers<wbr>/ddj<wbr>-netscape<wbr>.html](https://www.cs.berkeley.edu/~daw/papers/ddj-netscape.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: Pseudocode of
    the Netscape browser’s generation of 128-bit PRNG seeds</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that the PIDs and microseconds are guessable values. Assuming
    that you can guess the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">seconds</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">microseconds</samp> has only 10⁶
    possible values and thus an entropy of log(10⁶), or about 20 bits. The process
    ID (PID) and parent process ID (PPID) are 15-bit values, so you’d expect 15 +
    15 = 30 additional entropy bits. But looking at how <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is computed ❶ shows that the overlap of 3 bits yields an entropy of about 15 +
    12 = 27 bits, for a total entropy of only 47 bits, whereas a 128-bit seed should
    have 128 bits of entropy.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Insufficient Entropy
    at Boot Time</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 2012, researchers scanned the internet and harvested public keys from TLS
    certificates and SSH hosts. They found that a handful of systems had identical
    public keys, and in some cases very similar keys (namely, RSA keys with shared
    prime factors)—in short, two numbers, *n* = *pq* and *n*′ = *p*′*q*′, with *p*
    = *p*′, whereas normally all *p*s and *q*s should be different in distinct modulus
    values.
  prefs: []
  type: TYPE_NORMAL
- en: It turned out that many devices generated their public key early, at first boot,
    before having collected enough entropy, despite using an otherwise-decent PRNG
    (typically */dev/urandom*). PRNGs in different systems produced identical random
    bits due to having the same entropy source (for example, a hardcoded seed).
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, the presence of identical keys is due to key-generation schemes
    like the following, in pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If two systems run this code given an identical seed, they’ll produce the same
    *p*, the same *q*, and therefore the same *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The presence of shared primes in different keys is due to key-generation schemes
    where additional entropy is injected during the process, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If two systems run this code with the same seed, they’ll produce the same *p*,
    but the injection of entropy through <samp class="SANS_TheSansMonoCd_W5Regular_11">prng.add_entropy()</samp>
    will ensure distinct *q*s.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with shared prime factors is that given *n* = *pq* and *n*′ = *pq*′,
    it’s trivial to recover the shared *p* by computing the greatest common divisor
    (GCD) of *n* and *n*′. For details, see the paper “Mining Your Ps and Qs” by Heninger,
    Durumeric, Wustrow, and Halderman, available at *[https://<wbr>factorable<wbr>.net](https://factorable.net)*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Noncryptographic
    PRNG</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier we discussed the difference between crypto and noncrypto PRNGs and why
    the latter should never be used for crypto applications. Alas, many systems overlook
    that detail, so we’ll look at one such example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The popular MediaWiki application runs on Wikipedia and many other wikis. It
    uses randomness to generate things like security tokens and temporary passwords,
    which should be unpredictable. Unfortunately, a now obsolete version of MediaWiki
    used a noncrypto PRNG, the Mersenne Twister, to generate these tokens and passwords.
    Here’s a snippet from the vulnerable MediaWiki source code; look for the function
    called to get a random bit, and read the comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice <samp class="SANS_TheSansMonoCd_W5Regular_11">mt_rand()</samp>
    in the preceding code? Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">mt</samp>
    stands for Mersenne Twister. In 2012, researchers showed how to exploit the predictability
    of Mersenne Twister to predict future tokens and temporary passwords, given a
    couple of security tokens. MediaWiki was patched to use a crypto PRNG.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sampling Bug
    with Strong Randomness</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The next bug shows how even a strong crypto PRNG with sufficient entropy can
    produce a biased distribution. The chat program Cryptocat was designed to offer
    secure communication. It used a function that attempted to create a uniformly
    distributed string of decimal digits—namely, numbers in the range 0 through 9\.
    However, just taking random bytes modulo 10 doesn’t yield a uniform distribution;
    when taking all numbers between 0 and 255 and reducing them modulo 10, you don’t
    get an equal number of values in 0 to 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cryptocat did the following to address that problem and obtain a uniform distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And that was almost perfect. By taking only the numbers up to a multiple of
    10 and discarding others, you’d expect a uniform distribution of the digits 0
    through 9\. Unfortunately, there was an off-by-one error in the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    condition. I’ll leave the details to you as an exercise. You should find that
    there is a small statistical bias in favor of the index 0 (hint: <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    should have been <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve just scratched the surface of randomness in cryptography. There is much
    more to learn about the theory of randomness, including different entropy notions,
    randomness extractors, and even the power of randomization and derandomization
    in complexity theory. To learn more about PRNGs and their security, read the classic
    1998 paper “Cryptanalytic Attacks on Pseudorandom Number Generators” by Kelsey,
    Schneier, Wagner, and Hall. Then look at the implementation of PRNGs in your favorite
    applications and try to find their weaknesses. (Search online for “random generator
    bug” to find plenty of examples.)
  prefs: []
  type: TYPE_NORMAL
- en: We’re not done with randomness, though. We’ll encounter it multiple times throughout
    this book, and you’ll discover the many ways it helps to construct secure systems.
  prefs: []
  type: TYPE_NORMAL
