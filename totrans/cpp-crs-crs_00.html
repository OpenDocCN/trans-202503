<html><head></head><body>
<h2 class="h2" id="intro"><span epub:type="pagebreak" id="page_xxxi"/><strong>INTRODUCTION</strong></h2>&#13;
<p class="quote"><em>Grab the ol’ brush and paint along with us.<br/>—Bob Ross</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">The demand for system programming is enormous. With the ubiquity of web browsers, mobile devices, and the Internet of Things, there has perhaps never been a better time to be a system programmer. Efficient, maintainable, and correct code is desired in all cases, and it’s my firm belief that C++ is the right language for the job <em>in general</em>.</p>&#13;
<p class="indent">In the hands of a knowledgeable programmer, C++ can produce smaller, more efficient, and more readable code than any other system programming language on the planet. It’s a language committed to the ideal of zero-overhead abstraction mechanisms—so your programs are fast and quick to program—as well as simple, direct mapping to hardware—so you have low-level control when you need it. When you program in C++, you stand on the shoulders of giants who have spent decades crafting an incredibly powerful and flexible language.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xxxii"/>A huge benefit of learning C++ is that you gain access to the C++ Standard Library, the <em>stdlib</em>, free of charge. The stdlib is composed of three interlocking parts: <em>containers</em>, <em>iterators</em>, and <em>algorithms</em>. If you’ve ever written your own <em>quicksort</em> algorithm by hand or if you’ve programmed system code and been bitten by buffer overflows, dangling pointers, use-after frees, and double frees, you’ll enjoy getting acquainted with the stdlib. It provides you with an unrivaled combination of type safety, correctness, and efficiency. In addition, you’ll like how compact and expressive your code can be.</p>&#13;
<p class="indent">At the core of the C++ programming model is the <em>object life cycle</em>, which gives you strong guarantees that resources your program uses, such as files, memory, and network sockets, release correctly, even when error conditions occur. When used effectively, <em>exceptions</em> can clean out large amounts of error-condition-checking clutter from your code. Also, <em>move</em>/<em>copy</em> semantics provide safety, efficiency, and flexibility to manage resource ownership in a way that earlier system programming languages, like C, simply don’t provide.</p>&#13;
<p class="indent">C++ is a living, breathing language; after more than 30 years, the International Organization for Standardization (ISO) committee for C++ regularly makes improvements in the language. Several updates to the standard have been released in the past decade: C++11, C++14, and C++17, which were released in 2011, 2014, and 2017, respectively. You can expect a new C++20 in 2020.</p>&#13;
<p class="indent">When I use the term <em>modern C++</em>, I mean the latest C++ version that embraces the features and paradigms presented in these additions. These updates have made serious refinements to the language that improve its expressiveness, efficiency, safety, and overall usability. By some measures, the language has never been more popular, and it’s not going away any time soon. If you decide to invest in learning C++, it will pay dividends for years to come.</p>&#13;
<h3 class="h3" id="introlev1sec1"><strong>About This Book</strong></h3>&#13;
<p class="noindent">Although a number of very high-quality books are available to modern C++ programmers, such as Scott Meyer’s <em>Effective Modern C++</em> and Bjarne Stroustrup’s <em>The C++ Programming Language</em>, 4th Edition, they’re generally quite advanced. Some introductory C++ texts are available, but they often skip over crucial details because they’re geared to those totally new to programming. For the experienced programmer, it’s not clear where to dive into the C++ language.</p>&#13;
<p class="indent">I prefer to learn about complicated topics deliberately, building concepts from their fundamental elements. C++ has a daunting reputation because its fundamental elements nest so tightly together, making it difficult to construct a complete picture of the language. When I learned C++, I struggled to get my mind around the language, bouncing among books, videos, and exhausted colleagues. So I wrote the book I wish I’d had five years ago.</p>&#13;
<h3 class="h3" id="introlev1sec2"><span epub:type="pagebreak" id="page_xxxiii"/><strong>Who Should Read This Book?</strong></h3>&#13;
<p class="noindent">This book is intended for intermediate to advanced programmers already familiar with basic programming concepts. If you don’t specifically have <em>system</em> programming experience, that’s okay. Experienced application programmers are welcome.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you’re a seasoned C programmer or an aspiring system programmer wondering whether you should invest in learning C++, be sure to read An Overture to C Programmers on <a href="anoverture.xhtml#page_xxxvii">page xxxvii</a> for a detailed examination.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="introlev1sec3"><strong>What’s in This Book?</strong></h3>&#13;
<p class="noindent">The book is divided into two parts. <a href="part01.xhtml#part01">Part I</a> covers the core C++ language. Rather than presenting the C++ language chronologically (from old-style C++ 98 to modern C++11/14/17), you’ll learn idiomatic, modern C++ directly. <a href="part02.xhtml#part02">Part II</a> introduces you to the world of the C++ Standard Library (stdlib) where you’ll learn the most important and essential concepts.</p>&#13;
<h4 class="h4" id="introlev2sec1"><strong><em><a href="part01.xhtml#part01">Part I: The C++ Core Language</a></em></strong></h4>&#13;
<p class="bq"><strong><a href="ch01.xhtml">Chapter 1: Up and Running</a></strong> This introductory chapter will help you set up a C++ development environment. You’ll compile and run your first program, and you’ll learn how to debug it.</p>&#13;
<p class="bq"><strong><a href="ch02.xhtml">Chapter 2: Types</a></strong> Here you’ll explore the C++ type system. You’ll learn about the fundamental types, the foundation upon which all other types are built. Next, you’ll learn about plain-old-data types and fully featured classes. You’ll delve into the role of constructors, initialization, and destructors.</p>&#13;
<p class="bq"><strong><a href="ch03.xhtml">Chapter 3: Reference Types</a></strong> This chapter introduces you to objects that store the memory addresses of other objects. These types are the cornerstone of many important programming patterns, and they allow you to produce flexible, efficient code.</p>&#13;
<p class="bq"><strong><a href="ch04.xhtml">Chapter 4: The Object Life Cycle</a></strong> The discussion of class invariants and the constructor is continued within the context of storage durations. The destructor is introduced alongside the resource acquisition is initialization (RAII) paradigm. You’ll learn about exceptions and how they enforce class invariants and complement RAII. After a discussion of move and copy semantics, you’ll explore how to operationalize them with constructors and assignment operators.</p>&#13;
<p class="bq"><strong><a href="ch05.xhtml">Chapter 5: Runtime Polymorphism</a></strong> Here you’ll be introduced to interfaces, a programming concept that allows you to write code that’s polymorphic at runtime. You’ll learn the basics of inheritance and object composition, which underpin how you can operationalize interfaces in C++.</p>&#13;
<p class="bq"><span epub:type="pagebreak" id="page_xxxiv"/><strong><a href="ch06.xhtml">Chapter 6: Compile-Time Polymorphism</a></strong> This chapter introduces templates, a language feature that allows you to write polymorphic code. You’ll also explore concepts, a language feature that will be added to a future C++ release, and named conversion functions, which allow you to convert objects from one type to another.</p>&#13;
<p class="bq"><strong><a href="ch07.xhtml">Chapter 7: Expressions</a></strong> Now you’ll dive deeply into operands and operators. With a firm grasp of types, the object life cycle, and templates, you’ll be ready to plunge into the core components of the C++ language, and expressions are the first waypoint.</p>&#13;
<p class="bq"><strong><a href="ch08.xhtml">Chapter 8: Statements</a></strong> This chapter explores the elements that comprise functions. You’ll learn about expression statements, compound statements, declaration statements, iteration statements, and jump statements.</p>&#13;
<p class="bq"><strong><a href="ch09.xhtml">Chapter 9: Functions</a></strong> The final chapter of <a href="part01.xhtml#part01">Part I</a> expands on the discussion of how to arrange statements into units of work. You’ll learn the details of function definitions, return types, overload resolution, variadic functions, variadic templates, and function pointers. You’ll also learn how to create invokable user-defined types using the function call operator and lambda expressions. You’ll explore <code>std::function</code>, a class that provides a uniform container for storing invokable objects.</p>&#13;
<h4 class="h4" id="introlev2sec2"><strong><em><a href="part02.xhtml#part02">Part II: C++ Libraries and Frameworks</a></em></strong></h4>&#13;
<p class="bq"><strong><a href="ch10.xhtml">Chapter 10: Testing</a></strong> This chapter introduces you to the wonderful world of unit testing and mocking frameworks. You’ll practice test-driven development to develop software for an autonomous driving system while learning about frameworks, such as Boost Test, Google Test, Google Mock, and others.</p>&#13;
<p class="bq"><strong><a href="ch11.xhtml">Chapter 11: Smart Pointers</a></strong> The special utility classes that the stdlib provides for handling ownership of dynamic objects are explained.</p>&#13;
<p class="bq"><strong><a href="ch12.xhtml">Chapter 12: Utilities</a></strong> Here you’ll get an overview of the types, classes, and functions at your disposal in the stdlib and Boost libraries for tackling common programming problems. You’ll learn about data structures, numeric functions, and random number generators.</p>&#13;
<p class="bq"><strong><a href="ch13.xhtml">Chapter 13: Containers</a></strong> This chapter surveys the many special data structures in the Boost libraries and stdlib that help you organize data. You’ll learn about sequence containers, associative containers, and unordered associative containers.</p>&#13;
<p class="bq"><strong><a href="ch14.xhtml">Chapter 14: Iterators</a></strong> This is the interface between the containers you learned about in the previous chapter and the strings of the next chapter. You’ll learn about the different kinds of iterators and how their design provides you with incredible flexibility.</p>&#13;
<p class="bq"><strong><a href="ch15.xhtml">Chapter 15: Strings</a></strong> This chapter teaches you how to handle human language data in a single family of containers. You’ll also learn about the special facilities built into strings that allow you to perform common tasks.</p>&#13;
<p class="bq"><span epub:type="pagebreak" id="page_xxxv"/><strong><a href="ch16.xhtml">Chapter 16: Streams</a></strong> You’ll be introduced here to the major concept underpinning input and output operations. You’ll learn how to handle input and output streams with formatted and unformatted operations, as well as how to employ manipulators. You’ll also learn how to read and write data from and to files.</p>&#13;
<p class="bq"><strong><a href="ch17.xhtml">Chapter 17: Filesystems</a></strong> Here you’ll get an overview of the facilities in the stdlib for manipulating filesystems. You’ll learn how to construct and manipulate paths, inspect files and directories, and enumerate directory structures.</p>&#13;
<p class="bq"><strong><a href="ch18.xhtml">Chapter 18: Algorithms</a></strong> This is a quick reference to the dozens of problems you can solve easily from within the stdlib. You’ll learn about the impressive scope of the high-quality algorithms available to you.</p>&#13;
<p class="bq"><strong><a href="ch19.xhtml">Chapter 19: Concurrency and Parallelism</a></strong> This chapter teaches you some simple methods for multithreaded programming that are part of the stdlib. You’ll learn about futures, mutexes, condition variables, and atomics.</p>&#13;
<p class="bq"><strong><a href="ch20.xhtml">Chapter 20: Network Programming with Boost Asio</a></strong> Here you’ll learn how to build high-performance programs that communicate over networks. You’ll see how to use Boost Asio with blocking and non-blocking input and output.</p>&#13;
<p class="bq"><strong><a href="ch21.xhtml">Chapter 21: Writing Applications</a></strong> This final chapter rounds out the book with a discussion of several important topics. You’ll learn about program support facilities that allow you to hook into the application life cycle. You’ll also learn about Boost ProgramOptions, a library that makes writing console applications that accept user input straightforward.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Visit the companion site</em> <a href="https://ccc.codes/">https://ccc.codes/</a> <em>to access the code listings contained in this book.</em></p>&#13;
</div>&#13;
</body></html>