- en: Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C for Big Machines
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve concentrated on embedded programming. With embedded systems, you
    have limited memory and limited resources. However, C is designed to work on larger
    machines with operating systems (that we don’t have to program ourselves), and
    it has many features that are useful on these larger machines.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there is a memory region called the *heap* that allows you to allocate
    and free memory, as needed, to store complex objects. Things like web browsers
    and XML parsers make extensive use of the heap.
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t covered this before because we barely had enough memory for the stack—and
    dividing memory into a stack and heap would like dividing a drop of water between
    two glasses. It’s possible, but very tricky and not very useful.
  prefs: []
  type: TYPE_NORMAL
- en: We also haven’t covered the C I/O system. We’ve had to do the I/O ourselves,
    going directly to the hardware. On big machines with an operating system, the
    C I/O system and the operating system hide all those details from you.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the differences between embedded and non-embedded programming.
  prefs: []
  type: TYPE_NORMAL
- en: Inembedded programming, when you write to a device, you write directly to the
    device. This means that you must know the details of the device you are using.
    Fornon-embedded programming, when you call `write` to write to a device, you tell
    the operating system to do the work, including buffering to make the I/O more
    efficient and dealing with the actual device.
  prefs: []
  type: TYPE_NORMAL
- en: Inembedded programming, you have limited memory. You need to know where every
    byte is and how its being used. With non-embedded programming,you have an operating
    system and memory mapping system, which gives you access to a lot of memory. Most
    programs can afford to waste memory, and a lot of programs do.
  prefs: []
  type: TYPE_NORMAL
- en: An embedded program is loaded into flash memory by an external loader. In our
    case, it’s called ST-LINK and is hidden inside the IDE, but it’s there. The program
    stays in flash forever and is never unloaded or replaced during the normal operation
    of the system. Non-embedded systems, on the other hand, have an operating system
    that loads and unloads programs as needed.
  prefs: []
  type: TYPE_NORMAL
- en: An embedded system runs one program. You barely have enough memory for that.
    However non-embedded systems can and do run more than one program at a time. The
    system I’m writing this on is currently running 341 programs, and it’s a small
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded programs never stop, whereas non-embeddedones can exit and return control
    to the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded systems store all their data in memory. Non-embedded systems have a
    filesystem and can read and write file data as well as screens, networks, and
    other peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, errors in embedded systems must be handled by your program. For non-embedded
    systems, you have an operating system that will catch errors not handled by the
    program and print a warning or stop the program. The operating system keeps a
    bad program from damaging other resources on the system. In contrast, if an embedded
    programgoes south, you can easily brick the system.
  prefs: []
  type: TYPE_NORMAL
- en: C++ works well on larger systems because, in most cases, the overhead does not
    significantly affect things. For example, let’s suppose you want to write a program
    to read a bunch of data from a database and write a report. For a report that
    runs once a day, who cares if the program uses 0.5 seconds of CPU time versus
    0.2 seconds?
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are doing high-performance computing, such as gaming, animation,
    or video editing, you need the performance and precision of C. Even though it’s
    an older language, C still has its place on mainframes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you’ll learn how to use the heap, which is dynamic memory
    that can be allocated or freed at will. You will also learn how to deal with the
    operating system’s I/O system—actually, two I/O systems: the buffered I/O system
    and the raw I/O system.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will discover how to use floating-point numbers. Most cheap embedded
    processors don’t have a floating-point unit, so we can’t use floating-point numbers
    in embedded programs. Also, although mainframes have dedicated floating-point
    hardware, you must use this feature carefully; otherwise, you may get unexpected
    results.
  prefs: []
  type: TYPE_NORMAL
