["```\n   julia> typeof(17)\n   Int64\n\n   julia> typeof(17.0)\n   Float64\n\n   julia> typeof(17//1)\n➊ Rational{Int64}\n\n   julia> typeof(\"7\")\n   String\n\n   julia> typeof('7')\n   Char\n```", "```\njulia> using Printf\n\njulia> @printf \"%.16f\" 1/3\n0.3333333333333333\n\njulia> @printf \"%.17f\" 1/3\n0.33333333333333331\n\njulia> @printf \"%.18f\" 1/3\n0.333333333333333315\n```", "```\njulia> @printf \"%.16f\" Float32(1/3)\n0.3333333432674408\njulia> @printf \"%.16f\" Float16(1/3)\n0.3332519531250000\n```", "```\njulia> typemax(Int32)\n2147483647\n\njulia> typemin(Int32)\n-2147483648\n\njulia> typemax(Int16)\n32767\n\njulia> typemin(Int16)\n-32768\n```", "```\njulia> typemax(Float64)\nInf\n\njulia> typemax(Float16)\nInf16\n\njulia> Inf64 === Inf\ntrue\n```", "```\njulia> floatmax(Float64)\n1.7976931348623157e308\n\njulia> floatmin(Float64)\n2.2250738585072014e-308\n\njulia> floatmax(Float16)\nFloat16(6.55e4)\n\njulia> floatmin(Float16)\nFloat16(6.104e-5)\n```", "```\njulia> isa(17, Int64)\ntrue\n\njulia> 17 isa Number\ntrue\n\njulia> 17 isa String\nfalse\n```", "```\njulia> factorial(20)\n2432902008176640000\n\njulia> factorial(21)\nERROR: OverflowError: 21 is too large to look up in the table;\n       consider using `factorial(big(21))` instead\n```", "```\njulia> plot(factorial.(big.(1:50)), yscale=:log10,\n               legend=:topleft, label=\"Factorial\")\n```", "```\njulia> big(1.0)/3\n0.333333333333333333333333333333333333333333333333\n  3333333333333333333333333333348\n\njulia> setprecision(512);\n\njulia> big(1.0)/3\n0.3333333333333333333333333333333333333333333333333\n  3333333333333333333333333333333333333333333333333\n  3333333333333333333333333333333333333333333333333\n  333333346\n```", "```\njulia> precision(big(1.0))\n512\n\njulia> precision(float(1.0))\n53\n```", "```\njulia> π\nπ = 3.1415926535897...\n\njulia> typeof(π)\nIrrational{:π}\n```", "```\njulia> big(π)\n3.1415926535897932384626433832795028841971693993751\n  05820974944592307816406286198\n```", "```\n   julia> e\n   e = 2.7182818284590...\n\n   julia> big(e)\n➊ 2.7182818284590452353602874713526624977572470936999\n     59574966967627724076630353555\n\n   julia> log(e)\n➋ 1\n\n   julia> log(2.71828182845904)\n   0.9999999999999981\n\n   julia> log(2.718281828459045)\n   1.0\n```", "```\njulia> 1 + 1\n2\n\njulia> 1 + 1.0\n2.0\n```", "```\njulia> 1 + \"1\"\nERROR: MethodError: no method matching +(::Int64, ::String)\n```", "```\njulia> promote(big(2.0), 3.5, 3.4)\n(2.0, 3.5, 3.3999999999999999111821580299874767661\n 09466552734375)\n\njulia> typeof(promote(big(2.0), 3.5, 3.4))\nTuple{BigFloat, BigFloat, BigFloat}\n\njulia> typeof(promote(2, 3.5, 3.4))\nTuple{Float64, Float64, Float64}\n```", "```\n   julia> [1 2]\n   1×2 Matrix{Int64}:\n    1  2\n\n   julia> [1.0; 2]\n   2-element Vector{Float64}:\n    1.0\n    2.0\n\n   julia> [[1 2];;; [3 4]]\n➊ 1×2×2 Array{Int64, 3}:\n   [:, :, 1] =\n    1  2\n\n   [:, :, 2] =\n    3  4\n```", "```\n   julia> eltype([1 2])\n   Int64\n\n   julia> eltype([1.0 2])\n   Float64\n\n   julia> eltype([1.0 \"2\"])\n➊ Any\n\n   julia> [1.0 \"2\"]\n   1×2 Matrix{Any}:\n    1.0  \"2\"\n```", "```\njulia> promote(1.0, 2)\n(1.0, 2.0)\n\njulia> promote(1.0, \"2\")\nERROR: promotion of types Float64 and String failed to change any arguments\n```", "```\njulia> typeof(17)\nInt64\n\njulia> supertype(Int64)\nSigned\n\njulia> supertype(Signed)\nInteger\n\njulia> supertype(Integer)\nReal\n\njulia> supertype(Real)\nNumber\n\njulia> supertype(Number)\nAny\n\njulia> supertype(Any)\nAny\n```", "```\nusing Plots\nusing Graphs\nusing GraphRecipes\n\nsometypes = [Any, Complex, Float64, Int64, Number, Signed,\n             Irrational, AbstractFloat, Real,\n             AbstractIrrational, Integer, String, Char,\n             AbstractString, AbstractChar, Rational,\n             Int32, Vector, DenseVector, AbstractVector,\n             Array, DenseArray, AbstractArray]\n\ntype_tree = SimpleDiGraph(length(sometypes))\n\nfor t in sometypes[2:end]\n ➊ add_edge!(type_tree, indexin([supertype(t)], sometypes)[1],\n              indexin([t], sometypes)[1])\nend\n\ngraphplot(type_tree; names=[string(t) for t in sometypes], nodeshape=:rect,\n          fontsize=4, nodesize=0.17, nodecolor=:white, method=:buchheim)\n```", "```\njulia> supertypes(Irrational)\n(Irrational, AbstractIrrational, Real, Number, Any)\n```", "```\njulia> 17::Number\n17\n\njulia> 17::Integer\n17\n\njulia> 17::Int64\n17\n\njulia> 17::String\nERROR: TypeError: in typeassert, expected String, got a value of type Int64\n```", "```\nfunction greetings()\n    println(\"Who are you?\")\n    yourname = readline();\n    greeting = (\"Hello, \" * yourname * \".\")\n ➊ return greeting::String\nend\n```", "```\njulia> a::Int16 = 17\n17\n\njulia> typeof(a)\nInt16\n```", "```\njulia> a = \"Paris\"\nERROR: MethodError: Cannot `convert` an object\n  of type String to an object of type Int16\n\njulia> a::Int32 = 17\nERROR: cannot set type for global a. It already\n  has a value or is already set to a different type.\n```", "```\njulia> a = 32767\n32767\n\njulia> a = 32768\nERROR: InexactError: trunc(Int16, 32768)\n```", "```\njulia> global gf::Float64\n\njulia> gf = 17\n17\n\njulia> gf\n17.0 ➊\n\njulia> typeof(gf)\nFloat64\n\njulia> gf = \"London\"\nERROR: MethodError: Cannot `convert` an object\n  of type String to an object of type Float64 ➋\n\njulia> function weather_report(raining)\n           if !(raining isa Bool) ➌\n               println(\"Please tell us if it's raining with \\\"true\\\" or \\\"false\\\".\")\n               return\n           else\n               if raining\n                   n = \"\"\n               else\n                   n = \"not \"\n               end\n               local gf::String ➍\n               gf = \"London\"\n               return(\"It is $(n)raining in $gf today.\")\n           end\n        end\nweather_report (generic function with 1 method)\n```", "```\nfunction type_dec_demo()\n    a = 17\n    println(\"a = $a and has the type $(typeof(a)).\")\n    local a::Int16\nend\n```", "```\na = 17 and has the type Int16.\n```", "```\njulia> a = 17\n17\n\njulia> typeof(a)\nInt64\n```", "```\nfunction changing_type_demo()\n    a = 17\n    println(\"a = $a and has the type $(typeof(a)).\")\n    a = a + 1.0\n    println(\"a = $a and has the type $(typeof(a)).\")\nend\n```", "```\na = 17 and has the type Int64.\na = 18.0 and has the type Float64.\n```", "```\nfunction weather_report(raining)::String\n```", "```\nweather_report (generic function with 1 method)\n```", "```\njulia> function weather_report(raining::Bool)\n           if raining\n               n = \"\"\n           else\n               n = \"not \"\n           end\n           gf = \"London\"\n           println(\"It is $(n)raining in $gf today.\")\n        end\n\nweather_report (generic function with 1 method)\n\njulia> function weather_report(raining)\n           println(\"Please tell us if it's raining with \\\"true\\\" or \\\"false\\\".\")\n           return\n       end\n\nweather_report (generic function with 2 methods)\n```", "```\njulia> weather_report(true)\nIt is raining in London today.\n\njulia> weather_report(17)\n\"Please tell us if it's raining with \"true\" or \"false\".\"\n```", "```\njulia> function weather_report(raining::Bool, city::String)\n           if raining\n               n = \"\"\n           else\n               n = \"not \"\n           end\n               println(\"It is $(n)raining in $city today.\")\n       end\n\nweather_report (generic function with 3 methods)\n\njulia> weather_report(true, \"Tegucigalpa\")\nIt is raining in Tegucigalpa today.\n```", "```\njulia> weather_report(true, 17)\nERROR: MethodError: no method matching weather_report(::Bool, ::Int64)\nClosest candidates are:\n  weather_report(::Bool) at REPL[1]:1\n  weather_report(::Bool, ::String) at REPL[7]:1\n  weather_report(::Any) at REPL[4]:1\n```", "```\njulia> methods(weather_report)\n# 3 methods for generic function \"weather_report\":\n[1] weather_report(raining::Bool) in Main at REPL[1]:1\n[2] weather_report(raining::Bool, city::String) in Main at REPL[7]:1\n[3] weather_report(raining) in Main at REPL[4]:1\n```", "```\nimport Base.+\nfunction +(a::Number, b::String)\n    if Meta.parse(b) isa Number\n        return a + Meta.parse(b)\n    else\n        return a\n    end\nend\n```", "```\njulia> 1 + \"16\"\n17\n\njulia> 1 + \"16.0\"\n17.0\n\njulia> 1 + \"sixteen\"\n1\n\njulia> 1//2 + \"3\"\n7//2\n\njulia> π + \"1\"\n4.141592653589793\n```", "```\njulia> 17 isa Union{Number, String}\ntrue\n\njulia> Real <: Union{Number, String}\ntrue\n```", "```\njulia> abstract type MyNumber <: Number end\n```", "```\nstruct EarthLocation\n    latitude::Float64\n    longitude::Float64\n    timezone::String\nend\n```", "```\njulia> NYC = EarthLocation(40.7128, -74.006, \"ET\")\n\njulia> typeof(NYC)\nEarthLocation\n```", "```\njulia> NYC.latitude\n40.7128\n\njulia> NYC.timezone\n\"ET\"\n```", "```\njulia> EarthLocation(a, b) = EarthLocation(a, b, \"Unknown\")\nEarthLocation\n\njulia> someplace = EarthLocation(59.45607, -135.316681)\nEarthLocation(59.45607, -135.316681, \"Unknown\")\n\njulia> someplace.timezone\n\"Unknown\"\n```", "```\njulia> NYC.timezone = \"America/New_York\"\nERROR: setfield!: immutable struct of type EarthLocation cannot be changed\n```", "```\nmutable struct MutableEarthLocation\n    latitude::Float64\n    longitude::Float64\n    timezone::String\nend\n```", "```\njulia> NYC = MutableEarthLocation(40.7128, -74.006, \"ET\")\nMutableEarthLocation(40.7128, -74.006, \"ET\")\n\njulia> NYC.timezone = \"US/Eastern\"\n\"US/Eastern\"\n\njulia> NYC\nMutableEarthLocation(40.7128, -74.006, \"US/Eastern\")\n```", "```\nabstract type Circle end\n```", "```\nstruct FloatingCircle <: Circle\n    r::Real\nend\n```", "```\njulia> supertypes(FloatingCircle)\n(FloatingCircle, Circle, Any)\n```", "```\nstruct PositionedCircle <: Circle\n    x::Real\n    y::Real\n    r::Real\nend\n```", "```\njulia> subtypes(Circle)\n2-element Vector{Any}:\n FloatingCircle\n PositionedCircle\n```", "```\nfunction circle_area(c::Circle)\n    return π * c.r^2\nend\n```", "```\n   julia> c1 = FloatingCircle(1)\n   FloatingCircle(1)\n\n   julia> c1.r\n   1\n\n➊ julia> circle_area(c1)\n   3.141592653589793\n\n   julia> c2 = PositionedCircle(2, 2, 1)\n   PositionedCircle(2, 2, 1)\n\n   julia> c2.x, c2.y\n   (2, 2)\n\n   julia> c2.r\n   1\n\n➋ julia> circle_area(c2)\n   3.141592653589793\n\n   julia> circle_area(17)\n   ERROR: MethodError: no method matching circle_area(::Int64)\n```", "```\nfunction is_inside(c1::PositionedCircle, c2::PositionedCircle)\n    d = sqrt((c2.x - c1.x)^2 + (c2.y - c1.y)^2)\n    return d + c2.r < c1.r # true if c2 is inside c1\nend\n```", "```\njulia> a = PositionedCircle(2, 2, 2)\nPositionedCircle(2, 2, 2)\n\njulia> b = PositionedCircle(1, 1, 0.5)\nPositionedCircle(1, 1, 0.5)\n\njulia> is_inside(a, b)\ntrue\n\njulia> c = PositionedCircle(3, 3, 1)\nPositionedCircle(3, 3, 1)\n\njulia> is_inside(a, c)\nfalse\n```", "```\nusing Luxor\n@pdf begin\n    origin(Point(30, 30))\n ➊ scale(100, 100)\n    fontsize(0.32)\n    fontface(\"Liberation Sans\")\n    setdash(\"solid\")\n    setcolor(\"black\")\n    circle(Point(2, 2), 2, :stroke)\n    text(\"a\", Point(1, 3))\n    setcolor(\"blue\")\n    circle(Point(1, 1), 0.5, :stroke)\n    text(\"b\", Point(1, 1))\n    setcolor(\"green\")\n    circle(Point(3, 3), 1, :stroke)\n    text(\"c\", Point(3, 3))\nend 500 500 \"circles.pdf\"\n```", "```\nstruct ReasonableCircle <: Circle\n    r::Real\n ➊ ReasonableCircle(r) =\n        if r >= 0\n            new(r)\n        else\n            @error(\"It's not reasonable to make a circle with a negative radius.\")\n        end\nend\n\njulia> ReasonableCircle(-12)\n Error: It's not reasonable to make a circle with a negative radius.\n @ Main REPL[4]:7\n\njulia> ReasonableCircle(12).r\n12\n```", "```\n@kwdef struct Ellipse\n    axis1::Real = 1\n    axis2::Real = 1\nend\n```", "```\njulia> oval = Ellipse(axis2=2.6)\nEllipse(1, 2.6)\n\njulia> oval.axis1, oval.axis2\n(1, 2.6)\n```", "```\njulia> Ellipse(2, 3)\nEllipse(2, 3)\n\njulia> Ellipse(2, axis2=3)\nERROR: MethodError: no method matching Ellipse(::Int64; axis2=3)\n```", "```\nfunction safe_divide(a, b)\n    if b == 0\n        return 0\n    else\n        return a/b\n    end\nend\n```", "```\njulia> safe_divide(1, 2)\n0.5\n\njulia> safe_divide(1, 0)\n0\n```", "```\njulia> typeof(safe_divide(1, 2))\nFloat64\n\njulia> typeof(safe_divide(1, 0))\nInt64\n```", "```\njulia> @code_warntype safe_divide(1, 2)\nMethodInstance for safe_divide(::Int64, ::Int64)\n  from safe_divide(a, b) in Main at REPL[7]:1\nArguments\n  #self#::Core.Const(safe_divide)\n  a::Int64\n  b::Int64\nBody::Union{Float64, Int64}\n1 - %1 = (b == 0)::Bool\n--      goto #3 if not %1\n2 -      return 0\n3 - %4 = (a / b)::Float64\n--      return %4\n```", "```\nfunction safe_divide2(a, b)\n    if b == 0\n     ➊ return 0.0\n    else\n        return a/b\n    end\nend\n```", "```\n   julia> @code_warntype safe_divide2(1, 2)\n   MethodInstance for safe_divide2(::Int64, ::Int64)\n     from safe_divide2(a, b) in Main at REPL[5]:1\n   Arguments\n     #self#::Core.Const(safe_divide2)\n     a::Int64\n     b::Int64\n➊ Body::Float64\n   1 - %1 = (b == 0)::Bool\n   --      goto #3 if not %1\n   2 -      return 0.0\n   3 - %4 = (a / b)::Float64\n   --      return %4\n```", "```\nfunction safe_divide_typed(a, b)::Float64\n    if b == 0\n        return 0\n    else\n        return a/b\n    end\nend\n```", "```\nfunction leibπ(N)\n    s = 0\n    for n in 1:N\n        s += (-1)^(n+1) * 1/(2n-1)\n    end\n    return 4.0s\nend\n```", "```\njulia> @code_warntype leibπ(100)\nMethodInstance for leibπ(::Int64)\n  from leibπ(N) in Main at REPL[33]:1\nArguments\n  #self#::Core.Const(leibπ)\n  N::Int64\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  s::Union{Float64, Int64}\n  n::Int64\nBody::Float64\n1 -       (s = 0)\n|   %2  = (1:N)::Core.PartialStruct(UnitRange{Int64}, Any[Core.Const(1), Int64])\n|         (@_3 = Base.iterate(%2))\n|   %4  = (@_3 === nothing)::Bool\n|   %5  = Base.not_int(%4)::Bool\n--       goto #4 if not %5\n2   %7  = @_3::Tuple{Int64, Int64}\n|         (n = Core.getfield(%7, 1))\n|   %9  = Core.getfield(%7, 2)::Int64\n|   %10 = s::Union{Float64, Int64}\n|   %11 = (n + 1)::Int64\n|   %12 = ((-1) ^ %11)::Int64\n|   %13 = (%12 * 1)::Int64\n|   %14 = (2 * n)::Int64\n|   %15 = (%14 - 1)::Int64\n|   %16 = (%13 / %15)::Float64\n|         (s = %10 + %16)\n|         (@_3 = Base.iterate(%2, %9))\n|   %19 = (@_3 === nothing)::Bool\n|   %20 = Base.not_int(%19)::Bool\n--       goto #4 if not %20\n3 -       goto #2\n4   %23 = (4.0 * s)::Float64\n--       return %23\n```", "```\nfunction leibπ2(N)\n ➊ s = 0.0\n    for n in 1:N\n        s += (-1)^(n+1) * 1/(2n-1)\n    end\n    return 4.0s\nend\n```", "```\njulia> typeof(17)\nInt64\n\njulia> 17 isa Int\ntrue\n\njulia> Int === Int64\ntrue\n```", "```\njulia> const F64 = Float64\nFloat64\n\njulia> typeof(3.14)\nFloat64\n\njulia> 3.14 isa F64\ntrue\n```", "```\n   julia> typeof(2 + 2im)\n   Complex{Int64}\n\n   julia> typeof(2.0 + 2.0im)\n   ComplexF64 (alias for Complex{Float64})\n\n   julia> typeof(2.0 + 2im)\n➊ ComplexF64 (alias for Complex{Float64})\n\n   julia> typeof(1//2 + 1//2im)\n   Complex{Rational{Int64}}\n```", "```\n   julia> typeof([1,2])\n   Vector{Int64} (alias for Array{Int64, 1})\n\n   julia> supertype(Vector)\n➊ DenseVector (alias for DenseArray{T, 1} where T)\n\n   julia> supertype(DenseVector)\n   AbstractVector (alias for AbstractArray{T, 1} where T)\n```", "```\n@kwdef struct CEllipse{T}\n    axis1::T\n    axis2::T\nend\n```", "```\njulia> e1 = CEllipse(12.0, 17.0)\nCEllipse{Float64}(12.0, 17.0)\n\njulia> e2 = CEllipse(12.0, \"Snails\")\nERROR: MethodError: no method matching CEllipse(::Float64, ::String)\nClosest candidates are:\n  CEllipse(::T, ::T) where T at REPL[67]:2\n\njulia> e2 = CEllipse(\"Clams\", \"Snails\")\nCEllipse{String}(\"Clams\", \"Snails\")\n```", "```\n@kwdef struct CEllipse{T<:Number}\n    axis1::T\n    axis2::T\nend\n```", "```\njulia> e2 = CEllipse(\"Clams\", \"Snails\")\nERROR: MethodError: no method matching CEllipse(::String, ::String)\n\njulia> e2 = CEllipse(1//3, 1//5)\nCEllipse{Rational{Int64}}(1//3, 1//5)\n```", "```\nfunction eccentricity(e::CEllipse{<:Real})\n    a = max(e.axis1, e.axis2)\n    b = min(e.axis1, e.axis2)\n    return sqrt(a^2 - b^2)/a\nend\n```", "```\nfunction eccentricity(e::CEllipse{<:Complex})\n    a = max(abs(e.axis1), abs(e.axis2))\n    b = min(abs(e.axis1), abs(e.axis2))\n    return sqrt(abs(a)^2 - abs(b)^2)/abs(a)\nend\n```", "```\nusing Luxor\n@pdf begin\n    scale(100, 100)\n    fontsize(0.22)\n    fontface(\"Liberation Sans\")\n    setdash(\"dash\") # Coordinate axes\n    line(Point(-2, 0), Point(2, 0), :stroke)\n    line(Point(0, -2), Point(0, 2), :stroke)\n    text(\"Re\", Point(1.6, -0.1))\n    text(\"Im\", Point(0.1, -1.8))\n    setdash(\"dot\") # Ellipse axes\n    line(Point(0, 0), Point(sqrt(2), -sqrt(2)), :stroke)\n    line(Point(0, 0), Point(-1/sqrt(2), -1/sqrt(2)), :stroke)\n    text(\"α\", Point(0.25, -0.08))\n    setdash(\"solid\") # The ellipse\n    rotate(-π/4)\n    ellipse(0, 0, 4, 2, :stroke)\nend 500 500 \"ellipse.pdf\"\n```", "```\nfunction orientation(e::CEllipse{<:Complex})\n    if abs(e.axis1) > abs(e.axis2)\n        a = e.axis1\n    else\n        a = e.axis2\n    end\n    return angle(a)\nend\n```", "```\njulia> e45 = CEllipse(2 + 2im, -1 + im)\nCEllipse{Complex{Int64}}(2 + 2im, -1 + 1im)\n\njulia> eccentricity(e45)\n0.8660254037844387\n\njulia> orientation(e45)\n0.7853981633974483\n\njulia> orientation(e45) |> rad2deg\n45.0\n```", "```\nimport Base.@kwdef as @kwdef\nusing Dates\n\n@kwdef struct TempExtremes\n    tempunit::String = \"°C\"\n ➊ temps::Vector{Tuple{Float64, Float64}}\nend\n\n@kwdef struct WeatherData\n    temps::TempExtremes\n    rainfall::Vector{Float64}\nend\n\n@kwdef struct WeatherReport\n    notes::String\n    location::Tuple{Float64, Float64}\n    data::WeatherData\n    start::Dates.Date\nend\n```", "```\ntmin = randn(60) .+ 15.0\ntmax = tmin .+ abs.(randn(60) .+ 3.0)\ntd = TempExtremes(temps=collect(zip(tmin, tmax)))\nwd = WeatherData(rainfall=abs.(randn(60) .* 5.0 .+ 4), temps=td)\nwr = WeatherReport(notes=\"Rainfall and temperature extremes\",\n                   location=(-72.03, 45.47),\n                   data=wd, start=Date(1856, 12, 31))\n```", "```\nuser recipes:\n    user types => user types, numerical arrays\n\ntype recipes:\n    user types => numerical arrays\n\nplot recipes:\n    numerical arrays => series\n        and\n    series => series\n\nseries recipes:\n    numerical arrays => series\n        and\n    series => series\n```", "```\nusing RecipesBase\n\n@recipe function f(::Type{Val{:ebxbox}}, x, y, z; cycle=7)\n    if cycle <= 2; cycle = 7; end\n    ymin = similar(y)\n    ymax = similar(y)\n    yave = similar(y)\n ➊ seriestype := :line\n    for m = 1:cycle:length(y)\n        nxt = min(m+cycle-1, length(y))\n        ymin[m] = ymax[m] = yave[m] = NaN\n        ymin[m+1:nxt] .= minimum(y[m:nxt])\n        ymax[m+1:nxt] .= maximum(y[m:nxt])\n        yave[m+1:nxt] .= sum(y[m:nxt]) / (nxt - m + 1)\n    end\n ➋ @series begin\n        y := ymax\n     ➌ linecolor --> \"#ff000049\"\n        linewidth --> 6\n    end\n    @series begin\n        y := ymin\n        linecolor --> \"#0000ff49\"\n        linewidth --> 6\n    end\n\n    @series begin\n        y := yave\n        linecolor --> \"#66666649\"\n        linewidth --> 6\n    end\nend\n\n@recipe function f(::Type{Val{:temprange}}, x, y, z)\n    seriestype := :line\n    legend := false\n    if plotattributes[:series_plotindex] == 1\n     ➍ merge!(plotattributes[:extra_kwargs], Dict(:nextfr => y[:]))\n        linecolor := :blue\n        linewidth := 3\n    elseif plotattributes[:series_plotindex] == 2\n        fillrange := plotattributes[:extra_kwargs][:nextfr]\n        linecolor := :red\n        linewidth := 3\n        fillcolor := \"#45f19655\"\n    else\n        x := []\n        y := []\n    end\n    ()\nend\n```", "```\nusing Plots\n\n@shorthands temprange\n@shorthands ebxbox\n\ntl = [t[1] for t in wd.temps.temps]\nth = [t[2] for t in wd.temps.temps]\n\ntemprange([tl th])\n\nebxbox(wd.rainfall)\nplot!(wd.rainfall)\n```", "```\n@recipe function f(::Type{Val{:weatherplot}}, plt::AbstractPlot; cycle=7)\n    frames = get(plotattributes, :frames, 1)\n    if frames > 1 layout := (2, 1) end\n ➊ cycle := cycle\n    legend := false\n    @series begin\n     ➋ if frames > 1\n            subplot := 1\n            xguide := \"\"\n            ylabel := \"Temperature (°C)\"\n        end\n     ➌ seriestype := :temprange\n    end\n    if plotattributes[:series_plotindex] == 3\n        @series begin\n            if frames > 1 subplot := 2 end\n            seriestype := :ebxbox\n        end\n        @series begin\n            if frames > 1\n                subplot := 2\n                title := \"\"\n                ylabel := \"Rainfall (mm)\"\n            else\n                ylabel := \"Rainfall (mm) / Temperature (°C)\"\n            end\n            seriestype := :line\n            linecolor := :aqua\n            linewidth := 3\n            linestyle := :dot\n        end\n    end\nend\n```", "```\n@shorthands weatherplot\n\nweatherplot([tl th wd.rainfall])\n```", "```\n@recipe function f(::Type{TempExtremes}, v::TempExtremes)\n    tmin = [t[1] for t in v.temps]\n    tmax = [t[2] for t in v.temps]\n    [tmin tmax]\nend\n\n@recipe function f(::Type{WeatherData}, wdt::WeatherData)\n    tmin = [t[1] for t in wdt.temps.temps]\n    tmax = [t[2] for t in wdt.temps.temps]\n    [tmin tmax wdt.rainfall]\nend\n```", "```\n@recipe function f(wr::WeatherReport; frames=1)\n    title := wr.notes\n    frames := frames\n    xlabel --> \"Days from $(wr.start)\"\n    @series begin\n        seriestype := :weatherplot\n        wr.data\n    end\nend\n```", "```\nusing SpecialFunctions\n\n@userplot Risep\n\n@recipe function f(carray::Risep)\n    seriestype := :line\n ➊ x, y = carray.args\n    @series begin\n        label := \"Real part\"\n        linestyle := :solid\n        x, real.(y)\n    end\n    @series begin\n        label := \"Imaginary part\"\n        linestyle := :dot\n        x, imag.(y)\n    end\nend\n\nxc = 0.01:0.001:0.1\nrisep(xc, expint.(1im, xc); lw=2)\n```"]