<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch13">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch13">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_239" aria-label=" Page 239. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">CASE STUDY: A DETECTION-AWARE ATTACK</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">So far, we’ve covered the design of EDRs, the logic of their components, and the internal workings of their sensors. Still, we’ve missed one critical piece of the puzzle: how to apply this information in the real world. In this final chapter, we’ll systematically analyze the actions we’d like to take against target systems and determine our risk of being detected.</p>&#13;
<p class="TX">We’ll target a fictional company, Binford Tools, inventor of the Binford 6100 left-handed screwdriver. Binford has asked us to identify an attack path from a compromised user workstation to a database holding the proprietary design information for the 6100. We’re to be as stealthy as possible so that the company can see what its EDR is able to detect. Let’s get started.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-172"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_240" aria-label=" Page 240. "/><samp class="SANS_Futura_Std_Bold_B_11">The Rules of Engagement</samp></h2>&#13;
<p class="TNI">Binford’s environment consists only of hosts running up-to-date versions of the Windows operating system, and all authentication is controlled through on-premises Active Directory. Each host has a generic EDR deployed and running, and we aren’t allowed to disable, remove, or uninstall it at any point.</p>&#13;
<p class="TX">Our point of contact has agreed to provide us with a target email address, which an employee (whom we’ll refer to as the <i>white cell</i>) will monitor, clicking whatever links we send to them. However, they won’t add any rule explicitly allowing our payloads past their EDR. This will let us spend less time on social engineering and more time assessing technical detective and preventive measures.</p>&#13;
<p class="TX">Additionally, every employee at Binford has local administrator rights to their workstation, lowering the strain on Binford’s understaffed help desk. Binford has asked that we leverage this fact during the operation so that they can use the results of the engagement to drive a change to their policy.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h-173"/><samp class="SANS_Futura_Std_Bold_B_11">Initial Access</samp></h2>&#13;
<p class="TNI">We begin by selecting our phishing method. We need fast and direct access to the target’s workstation, so we opt to deliver a payload. Threat intelligence reporting at the time of the engagement tells us that the manufacturing sector is experiencing an uptick in malware dropped using Excel Add-In (XLL) files. Attackers have routinely abused XLL files, which allow developers to create high-performance Excel worksheet functions, to establish a foothold through phishing.</p>&#13;
<p class="TX">To mimic attacks Binford may respond to in the future, we opt to use this format as our payload. XLL files are really just DLLs that are required to export an <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoOpen()</samp> function (and, ideally, its complement, <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoClose()</samp>), so we can use a simple shellcode runner to speed up the development process.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h-174"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Payload</samp></h3>&#13;
<p class="TNI">Already, we must make a detection-related design decision. Should the shellcode be run locally, in the <i>excel.exe</i> process, where it will be tied to the lifetime of that process, or should it be run remotely? If we created our own host process and injected into it, or if we targeted an existing process, our shellcode could live longer but have a higher risk of detection due to <i>excel.exe</i> spawning a child process and the artifacts of remote process injection being present.</p>&#13;
<p class="TX">As we can always phish more later, we’ll opt to use the local runner and avoid prematurely tripping any detections. <a href="#list13-1">Listing 13-1</a> shows what our XLL payload code looks like.</p>&#13;
<pre id="list13-1"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_241" aria-label=" Page 241. "/>#define WIN32_LEAN_AND_MEAN&#13;
#include &lt;windows.h&gt;&#13;
&#13;
BOOL APIENTRY DllMain(HMODULE hModule,&#13;
                      DWORD ul_reason_for_call,&#13;
                      LPVOID lpReserved&#13;
                                    )&#13;
{&#13;
    switch (ul_reason_for_call)&#13;
    {&#13;
    case DLL_PROCESS_ATTACH:&#13;
    case DLL_THREAD_ATTACH:&#13;
    case DLL_THREAD_DETACH:&#13;
    case DLL_PROCESS_DETACH:&#13;
        break;&#13;
    }&#13;
&#13;
    return TRUE;&#13;
}&#13;
&#13;
extern "C"&#13;
__declspec(dllexport) short __stdcall xlAutoOpen()&#13;
{&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> const char shellcode[] = <var>--snip--</var>&#13;
    const size_t lenShellcode = sizeof(shellcode);&#13;
    char decodedShellcode[lenShellcode];&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> const char key[] = "specter";&#13;
&#13;
    int j = 0;&#13;
    for (int i = 0; i &lt; lenShellcode; i++)&#13;
    {&#13;
        if (j == sizeof(key) - 1)&#13;
        {&#13;
            j = 0;&#13;
        }&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> decodedShellcode[i] = shellcode[i] ^ key[j];&#13;
        j++;&#13;
    }&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> PVOID runIt = VirtualAlloc(0,&#13;
        lenShellcode,&#13;
        MEM_COMMIT,&#13;
        PAGE_READWRITE);&#13;
&#13;
    if (runIt == NULL)&#13;
    {&#13;
        return 1;&#13;
    }&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span> memcpy(runIt,&#13;
        decodedShellcode,&#13;
        lenShellcode);<span role="doc-pagebreak" epub:type="pagebreak" id="pg_242" aria-label=" Page 242. "/>&#13;
&#13;
    DWORD oldProtect = 0;&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation6">❻</span> VirtualProtect(runIt,&#13;
        lenShellcode,&#13;
        PAGE_EXECUTE_READ,&#13;
        &amp;oldProtect);&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation7">❼</span> CreateThread(NULL,&#13;
        NULL,&#13;
        (LPTHREAD_START_ROUTINE)runIt,&#13;
        NULL,&#13;
        NULL,&#13;
        NULL);&#13;
&#13;
    Sleep(1337);&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 13-1: The XLL payload source code</span></p>&#13;
<p class="TX">This local shellcode runner is similar to many DLL-based payloads. The exported <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoOpen()</samp> function begins with a chunk of shellcode (truncated for brevity) <span class="CodeAnnotation" aria-label="annotation1">❶</span> that has been XOR-encrypted using the string <i>specter</i> as the key <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The first action this function takes is decrypting the shellcode using this symmetric key <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Next, it creates a memory allocation tagged with read-write permissions using <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualAlloc()</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span> and then copies the decrypted shellcode into it <span class="CodeAnnotation" aria-label="annotation5">❺</span> ahead of execution. The function then changes the memory permissions of the new buffer to tag it as executable <span class="CodeAnnotation" aria-label="annotation6">❻</span>. Finally, the pointer to the buffer is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateThread()</samp>, which executes the shellcode in a new thread <span class="CodeAnnotation" aria-label="annotation7">❼</span>, still under the context of <i>excel.exe</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h-175"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Delivering the Payload</samp></h3>&#13;
<p class="TNI">We’ll assume that Binford’s inbound mail-filtering system allows XLL files to reach users’ inboxes, and we send our file to the white cell. Because the XLL needs to be run from disk, the white cell will download it to the internal host on which the EDR is deployed.</p>&#13;
<p class="TX">When the white cell executes the XLL, a few things will happen. First, <i>excel.exe</i> will be started with the path to the XLL passed in as a parameter. The EDR almost certainly collects this information from its driver’s process-creation callback routine (though the Microsoft-Windows-Kernel-Process ETW provider can provide most of the same information). The EDR may have a generic detection built around the execution of XLL files, which the process command line could trigger, causing an alert.</p>&#13;
<p class="TX">Additionally, the EDR’s scanner may conduct an on-access scan of the XLL file. The EDR will collect attributes of the file, assess its contents, and attempt to decide whether the content should be allowed to run. Let’s say that we did such a great job obfuscating our payload that the shellcode and associated runner inside weren’t detected by the scanner.</p>&#13;
<p class="TX">We’re not in the clear yet, though. Remember that most EDRs are deployed in multiple large environments and process large amounts of data. With this perspective, EDRs can assess the <i>global uniqueness</i> of a file, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_243" aria-label=" Page 243. "/>meaning how many times it has seen the file in the past. Because we crafted this payload ourselves and it contains shellcode tied to our infrastructure, it most likely hasn’t been seen before.</p>&#13;
<p class="TX">Luckily, this isn’t the end of the road by any stretch of the imagination. Users write new Word documents all the time. They generate reports for their organization and doodle in Paint during the third hour of meetings on “cross-functional synergy to meet key quarterly metrics.” If EDRs flagged every single unique file they came across, they would create an untenable amount of noise. While our global uniqueness may trigger some type of alert, it probably isn’t severe enough to kick off an investigation and won’t come into play unless the security operations center (SOC) responds to a higher-severity alert related to our activity.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h-176"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Executing the Payload</samp></h3>&#13;
<p class="TNI">Since we haven’t been blocked yet, <i>excel.exe</i> will load and process our XLL. As soon as our XLL is loaded, it will hit the <samp class="SANS_TheSansMonoCd_W5Regular_11">DLL_PROCESS_ATTACH</samp> reason code, which triggers the execution of our shellcode runner.</p>&#13;
<p class="TX">When our parent <i>excel.exe</i> process was spawned, the EDR injected its DLL, which hooked key functions unknown to us at this point. We didn’t use syscalls or include any logic to remap these hooked DLLs in <i>excel.exe</i>, so we’ll have to pass through these hooks and hope we don’t get caught. Thankfully, many of the functions commonly hooked by EDRs focus on remote process injection, which doesn’t affect us, as we’re not spawning a child process to inject into.</p>&#13;
<p class="TX">We also happen to know that this EDR makes use of the Microsoft-Windows-Threat-Intelligence ETW provider, so our activities will be subject to monitoring by those sensors on top of the EDR vendor’s own function hooks. Let’s examine the riskiness of the functions we call in our payload:</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!VirtualAlloc()</samp></p>&#13;
<p class="LIST1">Since this is the standard local-memory-allocation function in Windows and doesn’t allow for remote allocations (as in, memory being allocated in another process), its use likely won’t be scrutinized in isolation. Additionally, because we aren’t allocating read-write-execute memory, a common default for malware developers, we’ve mitigated pretty much all the risk that we can.</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">memcpy()</samp></p>&#13;
<p class="LIST1">Similar to the previous function, <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy()</samp> is a widely used function and isn’t subject to much scrutiny.</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!VirtualProtect()</samp></p>&#13;
<p class="LIST1">This is where things become riskier for us. Because we have to convert the protections for our allocation from read-write to read-execute, this step is unfortunately unavoidable. Since we’ve passed the desired protection level as a parameter to this function, EDRs can trivially identify this technique via function hooking. Additionally, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_244" aria-label=" Page 244. "/>the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp> sensor will detect the changes in protection state and notify consumers of the Microsoft-Windows-Threat-Intelligence ETW provider.</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!CreateThread()</samp></p>&#13;
<p class="LIST1">In isolation, this function doesn’t present much of a risk, as it is the standard way of creating new threads in multithreaded Win32 applications. However, since we’ve performed the previous three actions, which, combined, may indicate the presence of malware on the system, its use may be the proverbial straw that breaks the camel’s back in terms of causing an alert to fire. Unfortunately for us, we don’t really have many options to avoid its use, so we’ll just stick with it and hope that if we’ve gotten this far, our shellcode will execute.</p>&#13;
<p class="TX">This shellcode runner technique could be optimized in plenty of ways, but compared to the textbook <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateRemoteThread()</samp>-based approach to remote process injection, it’s not too bad. If we assume that these indicators fly under the radar of the EDR’s sensors, our agent shellcode will execute and begin its process of communicating back to our command-and-control infrastructure.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h-177"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Establishing Command and Control</samp></h3>&#13;
<p class="TNI">Most malicious agents establish command and control in similar ways. The first message the agent sends to the server is a check-in saying “I’m a new agent running on host X!” When the server receives this check-in, it will reply “Hello agent on host X! Sleep for this period of time, then message me again for tasking.” The agent then idles for the time specified by the server, after which it messages it again saying “Back again. This time I’m ready to do some work.” If the operator has specified tasking for the agent, the server will pass that information along in some format understood by the agent, and the agent will execute the task. Otherwise, the server will tell the agent to sleep and try again later.</p>&#13;
<p class="TX">How do command-and-control agents evade network-based detection? Most of the time, the communication happens over HTTPS, the favorite channel of most operators because it lets their messages blend in with the high volume of traffic commonly flowing to the internet over TCP port 443 on most workstations. To use this protocol (and its less-secure sister, HTTP), the communication must follow certain conventions.</p>&#13;
<p class="TX">For example, a request must have a <i>Uniform Resource Identifier (URI)</i> path for both GET requests, used for retrieving data, and POST requests, used for sending data. While these URIs don’t technically have to be the same in each request, many commercial command-and-control frameworks reuse one static URI path. Additionally, the agent and server must have an agreed-upon communication protocol that rides on top of HTTPS. This means that their messages generally follow a similar pattern. For instance, the lengths of check-in requests and polls for tasking will likely be static. They may also be sent at fixed intervals.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_245" aria-label=" Page 245. "/>All of this is to say that, even when command-and-control traffic attempts to blend in among the noise, it still generates strong indicators of beaconing activity. An EDR developer who knows what to look for can use these to pick out the malicious traffic from the benign, probably using the network filter driver and ETW providers such as Microsoft-Windows-WebIO and Microsoft-Windows-DNS-Client. While the contents of HTTPS messages are encrypted, many important details remain readable, such as the URI paths, headers, message lengths, and the time at which the message was sent.</p>&#13;
<p class="TX">Knowing this, how do we set up our command and control? Our HTTPS channel uses the domain blnfordtools.com. We purchased this domain a few weeks before the operation, set up DNS to point to a DigitalOcean virtual private server (VPS), and configured an NGINX web server on the VPS to use a LetsEncrypt SSL certificate. GET requests will be sent to the <i>/home/catalog</i> endpoint and POST requests to <i>/search?q=6100</i>, which will hopefully blend into normal traffic generated when browsing a tool manufacturer’s site. We set our default sleep interval to five minutes to allow us to quickly task the agent without being overly noisy, and we use a jitter of 20 percent to add some variability between request times.</p>&#13;
<p class="TX">This command-and-control strategy might seem insecure; after all, we’re using a newly registered, typo-squatted domain hosted on a cheap VPS. But let’s consider what the EDR’s sensors can actually capture:</p>&#13;
<ul class="BL">&#13;
<li class="BL1">A suspicious process making an outbound network connection</li>&#13;
<li class="BL1">Anomalous DNS lookups</li>&#13;
</ul>&#13;
<p class="TNI1">Notably missing is all the weirdness related to our infrastructure and indicators of beaconing.</p>&#13;
<p class="TX">Although the EDR’s sensors can collect the data required to determine that the compromised host is connecting to a newly registered, uncategorized domain pointing to a sketchy VPS, actually doing this would mean performing a ton of supporting actions, which could negatively affect system performance.</p>&#13;
<p class="TX">For example, to track domain categorization, the EDR would need to reach out to a reputation-monitoring service. To get registration information, it would need to query the registrar. Doing all of this for all connections made on the target system would be hard. For that reason, EDR agents typically offload these responsibilities to the central EDR server, which performs the lookups asynchronously and uses the results to fire off alerts if needed.</p>&#13;
<p class="TX">The indicators of beaconing are missing for nearly the same reasons. If our sleep interval were something like 10 seconds with 10 percent jitter, detecting the beaconing could be as simple as following a rule like this one: “If this system makes more than 10 requests to a website with nine to 11 seconds between each request, fire an alert.” But when the sleep interval is five minutes with 20 percent jitter, the system would have to generate an alert anytime the endpoint made more than 10 requests to a website with four to six minutes between each request, which would require maintaining the rolling state of every outbound network connection for between 40 minutes and one hour. Imagine how many websites you visit on a daily basis, and you can see why this function is better suited for the central server.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h-178"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_246" aria-label=" Page 246. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Evading the Memory Scanner</samp></h3>&#13;
<p class="TNI">The last big threat to the initial access phase of the engagement (as well as any future stages in which we spawn an agent) is the EDR’s memory scanner. Like the file scanner, this component seeks to detect the presence of malware on the system using static signatures. Instead of reading the file from disk and parsing its contents, it scans the file after it has been mapped into memory. This allows the scanner to assess the content of the file after it has been de-obfuscated so that it can be passed to the CPU for execution. In the case of our payload, this means our decrypted agent shellcode will be present in memory; the scanner needs only to find it and identify it as malicious.</p>&#13;
<p class="TX">Some agents include functionality to obscure the presence of the agent in memory during periods of inactivity. These techniques have varying levels of efficacy, and a scanner could still detect the shellcode by catching the agent between one of these sleep periods. Even so, custom shellcode and custom agents are generally harder to detect through static signatures. We’ll assume that our bespoke, handcrafted, artisanal command-and-control agent was novel enough to avoid being flagged by the memory scanner.</p>&#13;
<p class="TX">At this point, everything has worked in our favor: our initial beaconing didn’t fire off an alert worthy of the SOC’s attention. We’ve established access to the target system and can begin our post-compromise activities.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h2 class="H1" id="sec8"><span id="h-179"/><samp class="SANS_Futura_Std_Bold_B_11">Persistence</samp></h2>&#13;
<p class="TNI">Now that we’re inside the target environment, we need to make sure we can survive a technical or human-induced loss of connection. At this stage of the operation, our access is so fragile that if something were to happen to our agent, we’d have to start over from the beginning. Therefore, we need to set up some form of persistence that will establish a new command-and-control connection if things go south.</p>&#13;
<p class="TX">Persistence is a tricky thing. There are an overwhelming number of options at our disposal, each with pros and cons. Generally speaking, we’re evaluating the following metrics when choosing a persistence technique:</p>&#13;
<p class="RunInPara"><b>Reliability</b>   The degree of certainty that the persistence technique will trigger our action (for example, launching a new command-and-control agent)</p>&#13;
<p class="RunInPara"><b>Predictability</b>   The degree of certainty about when the persistence will trigger</p>&#13;
<p class="RunInPara"><b>Required permissions</b>   The level of access required to set up this persistence mechanism</p>&#13;
<p class="RunInPara"><b>Required user or system behaviors</b>   Any actions that must occur on the system for our persistence to fire, such as a system reboot or a user going idle</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_247" aria-label=" Page 247. "/><b>Detection risks</b>   The understood risk of detection inherent to the technique</p>&#13;
<p class="TX">Let’s use the creation of scheduled tasks as an example. <a href="#tab13-1">Table 13-1</a> shows how the technique would perform using our metrics. Things seem great initially. Scheduled tasks run like a Rolex and are incredibly easy to set up. The first issue we encounter is that we need local administrator rights to create a new scheduled task, as the associated directory, <i>C:\Windows\System32\Tasks\</i>, can’t be accessed by standard users.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab13-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-1:</samp> <samp class="SANS_Futura_Std_Book_11">Evaluating Scheduled Tasks as a Persistence Mechanism</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Metric</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Evaluation</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Reliability</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Highly reliably</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Predictability</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Highly predictable</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Required permissions</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Local administrator</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Required user or system behaviors</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">System must be connected to the network at the time of the trigger</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Detection risks</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Very high</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">The biggest issue for us, though, is the detection risk. Attackers have abused scheduled tasks for decades. It would be fair to say that any EDR agent worth its weight would be able to detect the creation of a new scheduled task. As a matter of fact, MITRE’s <i>ATT&amp;CK evaluations</i>, a capability-validation process that many vendors participate in every year, uses scheduled-task creation as one of its test criteria for APT3, an advanced persistent threat group attributed to China’s Ministry of State Security (MSS). Because remaining stealthy is one of our big goals, this technique is off the table for us.</p>&#13;
<p class="TX">What persistence mechanism should we choose? Well, nearly every EDR vendor’s marketing campaign claims that it covers most cataloged ATT&amp;CK techniques. ATT&amp;CK is a collection of known attacker techniques that we understand well and are tracking. But what about the unknowns: the techniques about which we are mostly ignorant? A vendor can’t guarantee coverage of these; nor can they be assessed against them. Even if an EDR has the ability to detect these uncatalogued techniques, it might not have the detection logic in place to make sense of the telemetry generated by them.</p>&#13;
<p class="TX">To lower our likelihood of detection, we can research, identify, and develop these “known unknowns.” To that end, let’s use <i>shell preview handlers</i>, a persistence technique that I, along with my colleague Emily Leidy, published research about in a blog post, “Life Is Pane: Persistence via Preview Handlers.” Preview handlers install an application that renders a preview of a file with a specific extension when viewed in Windows Explorer. In our case, the application we register will be our malware, and it will kick off a new command-and-control agent. This process is done almost entirely in the registry; we’ll create new keys that register a COM server. <a href="#tab13-2">Table 13-2</a> evaluates this technique’s riskiness.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab13-2"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_248" aria-label=" Page 248. "/><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-2:</samp> <samp class="SANS_Futura_Std_Book_11">Evaluating Shell Preview Handlers as a Persistence Mechanism</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Metric</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Evaluation</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Reliability</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Highly reliable</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Predictability</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Unpredictable</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Required permissions</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Standard user</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Required user or system behaviors</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">User must browse the target file type in Explorer with the pre</samp><samp class="SANS_Futura_Std_Book_11">view pane enabled, or the search indexer must process the file</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Detection risks</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Currently low but trivial to detect</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">As you can see, these “known unknowns” tend to trade strengths in some areas for weaknesses in others. Preview handlers require fewer permissions and are harder to detect (though detection is still possible, as their installation requires very specific registry changes to be made on the host). However, they are less predictable than scheduled tasks due to user-interaction requirements. For operations in which detection isn’t a significant concern, reliability and usability may trump the other factors.</p>&#13;
<p class="TX">Say we use this persistence mechanism. In the EDR, sensors are now hard at work collecting telemetry related to the hijacked preview handlers. We had to drop a DLL containing a runner for our backup agent to disk from <i>excel.exe</i>, so the scanner will probably give it a thorough examination, assuming that Excel writing a new DLL isn’t suspect enough. We also had to create a ton of registry keys, which the driver’s registry-notification callback routine will handle.</p>&#13;
<p class="TX">Also, the registry-related telemetry our actions generate can be a little difficult to manage. This is because COM object registration can be tricky to pick out from the large volume of registry data, and because it can be challenging to differentiate a benign COM object registration from a malicious one. Additionally, while the EDR can monitor the creation of the new preview-handler registry-key value, as it has a standard format and location, this requires performing a lookup between the class identifier written as the value and the COM object registration associated with that class identifier, which isn’t feasible at the sensor level.</p>&#13;
<p class="TX">Another detection risk is our manual enablement of Explorer’s preview pane. This isn’t crazy behavior on its own. Users can manually enable or disable the preview pane at any time through their file browser. It can also be enabled across the enterprise via a group policy object. In both of these instances, the process making the change (for example, <i>explorer.exe</i> in the case of manual enablement) is known, meaning that a detection targeting atypical processes setting this registry value may be possible. For <i>excel.exe</i> to make this change would be very much out of the ordinary.</p>&#13;
<p class="TX">Finally, Explorer has to load our DLL whenever the persistence is triggered. This DLL won’t be signed by Microsoft (or likely signed at all). The driver’s image-load callback notification routine will be responsible for detecting this DLL being loaded and can investigate the signature, along with other metadata about the image, to tip off the agent to the fact that a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_249" aria-label=" Page 249. "/>piece of malware is about to be mapped into Explorer’s address space. Of course, we could mitigate some of this risk by signing our DLL with a valid code-signing certificate, but this is beyond the reach of many threat actors, both real and simulated.</p>&#13;
<p class="TX">We’ll make a trade-off in predictability in favor of lowering our detection risk. We choose to install a preview handler for the <i>.docx</i> file extension by dropping our handler DLL to disk, performing the requisite COM registration, and manually enabling Explorer’s preview pane in the registry if it is not already enabled.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h2 class="H1" id="sec9"><span id="h-180"/><samp class="SANS_Futura_Std_Bold_B_11">Reconnaissance</samp></h2>&#13;
<p class="TNI">Now that we’ve established persistence, we can afford to start taking more risks. The next thing we need to figure out is how to get to where we need to go. This is when you must think the hardest about detection because you’ll generate vastly different indicators based on what you’re doing and how you do it.</p>&#13;
<p class="TX">We’ll need a way to run reconnaissance tooling without detection. One of my favorite tools for performing local reconnaissance is Seatbelt, a host-based situational awareness tool written by Lee Christensen and Will Schroeder. It can enumerate a ton of information about the current system, including the running processes, mapped drives, and amount of time the system has been online.</p>&#13;
<p class="TX">A common way to run Seatbelt is to use built-in features of the command- and-control agent, such as Cobalt Strike Beacon’s execute-assembly, to execute its .NET assembly in memory. Typically, this involves spawning a sacrificial process, loading the .NET common language runtime into it, and instructing it to run a specified .NET assembly with provided arguments.</p>&#13;
<p class="TX">This technique is substantially less detection prone than trying to drop the tool onto the target’s filesystem and executing it from there, but it’s not without risk. In fact, the EDR could catch us in a whole slew of ways:</p>&#13;
<p class="LH"><b>Child Process Creation</b></p>&#13;
<p class="LIST1">The EDR’s process-creation callback routine could detect the creation of the sacrificial process. If the child of the parent process is atypical, it could trigger an alert.</p>&#13;
<p class="LH"><b>Abnormal Module Loading</b></p>&#13;
<p class="LIST1">The sacrificial process spawned by the parent may not typically load the common language runtime if it is an unmanaged process. This may tip off the EDR’s image-load callback routine that in-memory .NET tradecraft is being used.</p>&#13;
<p class="LH"><b>Common Language Runtime ETW Events</b></p>&#13;
<p class="LIST1">Whenever the common language runtime is loaded and run, it emits events through the Microsoft-Windows-DotNETRuntime ETW provider. This allows EDRs that consume its events to identify key pieces <span role="doc-pagebreak" epub:type="pagebreak" id="pg_250" aria-label=" Page 250. "/>of information related to the assemblies executing on the system, such as their namespace, class and method names, and Platform Invoke signatures.</p>&#13;
<p class="LH"><b>Antimalware Scan Interface</b></p>&#13;
<p class="LIST1">If we’ve loaded version 4.8 or later of the .NET common language runtime, AMSI becomes a concern for us. AMSI will inspect the contents of our assembly, and each registered provider will have the opportunity to determine whether its contents are malicious.</p>&#13;
<p class="LH"><b>Common Language Runtime Hooks</b></p>&#13;
<p class="LIST1">While the technique isn’t directly covered in this book, many EDRs use hooks on the common language runtime to intercept certain execution paths, inspect parameters and return values, and optionally block them. For example, EDRs commonly monitor <i>reflection</i>, the .NET feature that enables the manipulation of loaded modules, among other things. An EDR that hooks the common language runtime in this way may be able to see things that AMSI alone couldn’t and detect tampering with the loaded <i>amsi.dll</i>.</p>&#13;
<p class="LH"><b>Tool-Specific Indicators</b></p>&#13;
<p class="LIST1">The actions our tooling takes after being loaded can generate additional indicators. Seatbelt, for instance, queries many registry keys.</p>&#13;
<p class="TX">In short, most vendors know how to identify the execution of .NET assemblies in memory. Thankfully for us, there are some alternative procedures, as well as tradecraft decisions we can make, that can limit our exposure.</p>&#13;
<p class="TX">An example of this is the <i>InlineExecute-Assembly</i> Beacon object file, an open source plug-in for Cobalt Strike’s Beacon that allows operators to do everything that the normal execute-assembly module allows but without the requirement of spawning a new process. On the tradecraft side, if our current process is managed (as in, is .NET), then loading the common language runtime would be expected behavior. Couple these with bypasses for AMSI and the .NET Runtime ETW provider and we’ve limited our detection risk down to any hooks placed into the common language runtime and the indicators unique to the tool, which can be addressed independently. If we implement these tradecraft and procedural changes, we’re in a decent spot to be able to run Seatbelt.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h2 class="H1" id="sec10"><span id="h-181"/><samp class="SANS_Futura_Std_Bold_B_11">Privilege Escalation</samp></h2>&#13;
<p class="TNI">We know that we need to expand our access to other hosts in Binford’s environment. We also know, from our point of contact, that our current user has low privileges and hasn’t been granted administrative access to remote systems. Remember, though, that Binford grants all domain users <span role="doc-pagebreak" epub:type="pagebreak" id="pg_251" aria-label=" Page 251. "/>local administrator rights on their designated workstation so that they can install applications without overburdening their helpdesk team. All of this means that we won’t be able to move around the network unless we can get into the context of another user, but we also have options for how to do that.</p>&#13;
<p class="TX">To take on the identity of another user, we could extract credentials from LSASS. Unfortunately, opening a handle to LSASS with <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp> rights can be a death sentence for our operation when facing a modern EDR. There are many ways to get around opening a handle with these rights, such as stealing a handle opened by another process or opening a handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_DUP_HANDLE</samp> rights and then changing the requested rights when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!DuplicateHandle()</samp>. However, we’re still running in <i>excel.exe</i> (or <i>explorer.exe</i>, if our persistence mechanism has fired), and opening a new process handle may cause further investigation to occur, if it doesn’t generate an alert outright.</p>&#13;
<p class="TX">If we want to act as another user but don’t want to touch LSASS, we still have plenty of options, especially since we’re local administrators.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h-182"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting a List of Frequent Users</samp></h3>&#13;
<p class="TNI">One of my favorite ways is to target users who I know log in to the system. To view the available users, we can run Seatbelt’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp> module, which tells us which users have logged on recently. This will generate some indicators related to Seatbelt’s default namespace, classes, and method names, but we can simply change those prior to compilation of the assembly. Once we get the results from Seatbelt, we can also check the subdirectories under <i>C:\Users\</i> using <i>dir</i> or an equivalent directory-listing utility to see which users have a home folder on the system.</p>&#13;
<p class="TX">Our execution of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp> module returns multiple login events from the user <i>TTAYLOR.ADMIN@BINFORD.COM</i> over the past 10 days. We can assume from the name that this user is an administrator to something, though we’re not quite sure to what.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h-183"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hijacking a File Handler</samp></h3>&#13;
<p class="TNI">Here are two methods for targeting users of the system on which you’re operating: backdooring a <i>.lnk</i> file on the user’s desktop for an application they frequently open, such as a browser, and hijacking a file handler for the target user through registry modification. Both techniques rely on the creation of new files on the host. However, the use of <i>.lnk</i> files has been covered extensively in public reporting, so there are likely detections around their creation. File-handler hijacks have gotten less attention. Therefore, their use may pose a smaller risk to the security of our operation.</p>&#13;
<p class="TX">For readers unfamiliar with this technique, let’s cover the relevant background information. Windows needs to know which applications open files with certain extensions. For instance, by default, the browser opens <i>.pdf</i> files, though users can change this setting. These extension-to-application mappings are stored in the registry, under <i>HKLM:\Software\Classes\</i> for handlers <span role="doc-pagebreak" epub:type="pagebreak" id="pg_252" aria-label=" Page 252. "/>registered for the whole system and <i>HKU:\&lt;SID&gt;\SOFTWARE\Classes\</i> for per-user registrations.</p>&#13;
<p class="TX">By changing the handler for a specific file extension to a program that we implement, we can get our code to execute in the context of the user who opened the hijacked file type. Then we can open the legitimate application to fool the user into thinking everything is normal. To make this work, we must create a tool that first runs our agent shellcode and then proxies the path of the file to be opened to the original file handler.</p>&#13;
<p class="TX">The shellcode runner portion can use any method of executing our agent code and as such will inherit the indicators unique to that execution method. This is the same as was the case with our initial access payload, so we won’t cover the details of that again. The proxying portion can be as simple as calling <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp> on the intended file handler and passing in the arguments received from the operating system when the user attempts to open the file. Depending on the target of the hijack, this can create an abnormal parent–child process relationship, as our malicious intermediary handler will be the parent of the legitimate handler. In other cases, such as <i>.accountpicture-ms</i> files, the handler is a DLL that is loaded into <i>explorer.exe</i>, making it so that the child process could look like a child of <i>explorer.exe</i> rather than another executable.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Choosing a File Extension</samp></h4>&#13;
<p class="TNI">Because we’re still running in <i>excel.exe</i>, the modification of arbitrary file-handler binaries may seem odd to an EDR monitoring the registry events. Excel is, however, directly responsible for certain file extensions, such as <i>.xlsx</i> and <i>.csv</i>. If detection is a concern, it’s best to choose a handler that is appropriate for the context.</p>&#13;
<p class="TX">Unfortunately for us, Microsoft has implemented measures to limit our ability to change the handler associated with certain file extensions via direct registry modification; it checks hashes that are unique to each app and user. We can enumerate these protected file extensions by looking for registry keys with <samp class="SANS_TheSansMonoCd_W5Regular_11">UserChoice</samp> subkeys containing a value called <samp class="SANS_TheSansMonoCd_W5Regular_11">Hash</samp>. Among these protected file extensions are Office file types (like <i>.xlsx</i> and <i>.docx</i>), <i>.pdf</i>, <i>.txt</i>, and <i>.mp4</i>, to name a few. If we want to hijack Excel-related file extensions, we need to somehow figure out the algorithm that Microsoft uses to create these hashes and reimplement it ourselves.</p>&#13;
<p class="TX">Thankfully, GitHub user “default-username-was-already-taken” offers a PowerShell version of the necessary hashing algorithm, <i>Set-FileAssoc.ps1</i>. Working with PowerShell can be tricky; it’s subject to high levels of scrutiny by AMSI, script-block logging, and consumers monitoring the associated ETW provider. Sometimes the mere fact of <i>powershell.exe</i> spawning can trigger an alert for a suspicious process.</p>&#13;
<p class="TX">Thus, we’ll aim to use PowerShell in the safest way possible, with the least risk of exposure. Let’s take a closer look at how the execution of this script on the target might get us caught and see what we can mitigate.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H3" id="sec14"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_253" aria-label=" Page 253. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Modifying the PowerShell Script</samp></h4>&#13;
<p class="TNI">If you review the script yourself, you’ll see that it isn’t too alarming; it appears to be a standard administrative tool. The script first sets up a P/Invoke signature for the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi32!RegQueryInfoKey()</samp> function and adds a custom C# class called <samp class="SANS_TheSansMonoCd_W5Regular_11">HashFuncs</samp>. It defines a few helper functions that interact with the registry, enumerate users, and calculate the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserChoice</samp> hash. The final block executes the script, setting the new file handler and hash for the specified file extension.</p>&#13;
<p class="TX">This means we won’t need to modify much. The only things we need to worry about are some of the static strings, as those are what sensors will capture. We can remove a vast majority of them, as they’re included for debugging purposes. The rest we can rename, or <i>mangle</i>. These strings include the contents of variables, as well as the names of the variables, functions, namespaces, and classes used throughout the script. All of these values are fully under our control, so we can change them to whatever we want.</p>&#13;
<p class="TX">We do need to be careful with what we change these values to, though. EDRs can detect script obfuscation by looking at the entropy, or randomness, of a string. In a truly random string, the characters should all receive equal representation. In the English language, the five most common letters are E, T, A, O, and I; less commonly used letters include Z, X, and Q. Renaming our strings to values like <i>z0fqxu5</i> and <i>xyz123</i> could alert an EDR to the presence of high-entropy strings. Instead, we can simply use English words, such as <i>eagle</i> and <i>oatmeal</i>, to perform our string replacement.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Executing the PowerShell Script</samp></h4>&#13;
<p class="TNI">The next decision we need to make is how we’re going to execute this PowerShell script. Using Cobalt Strike Beacon as an example agent, we have a few options readily available to us in our command-and-control agent:</p>&#13;
<ol class="NL">&#13;
<li class="NL">Drop the file to disk and execute it directly with <i>powershell.exe</i>.</li>&#13;
<li class="NL">Execute the script in memory using a download cradle and <i>powershell.exe</i>.</li>&#13;
<li class="NL">Execute the script in memory using Unmanaged PowerShell (<i>powerpick</i>) in a sacrificial process.</li>&#13;
<li class="NL">Inject Unmanaged PowerShell into a target process and execute the script in memory (<i>psinject</i>).</li>&#13;
</ol>&#13;
<p class="TX">Option 1 is the least preferrable, as it involves activities that Excel would rarely perform. Option 2 is slightly better because we no longer have to drop the script onto the host’s filesystem, but it introduces highly suspicious indicators, both in the network artifacts generated when we request the script from the payload-hosting server and in the invocation of <i>powershell.exe</i> by Excel with a script downloaded from the internet.</p>&#13;
<p class="TX">Option 3 is slightly better than the previous two but isn’t without its own risks. Spawning a child process is always dangerous, especially when <span role="doc-pagebreak" epub:type="pagebreak" id="pg_254" aria-label=" Page 254. "/>combined with code injection. Option 4 is not much better, as it drops the requirement of creating a child process but still necessitates opening a handle to an existing process and injecting code into it.</p>&#13;
<p class="TX">If we consider options 1 and 2 to be off the table because we don’t want Excel spawning <i>powershell.exe</i>, we’re left deciding between options 3 and 4. There is no right answer, but I find the risk of using a sacrificial process more palatable than the risk of injecting into another one. The sacrificial process will terminate as soon as our script completes its execution, removing persistent artifacts, including the loaded DLLs and the in-memory PowerShell script, from the host. If we were to inject into another process, those indicators could remain loaded in the host process even after our script completes. So, we’ll use option 3.</p>&#13;
<p class="TX">Next, we need to decide what our hijack should target. If we wanted to expand our access indiscriminately, we’d want to hijack an extension for the entire system. However, we’re after the user <i>TTAYLOR.ADMIN</i>. Since we have local administrator rights on the current system, we can modify the registry keys of a specific user through the <i>HKU</i> hive, assuming we know the user’s security identifier (SID).</p>&#13;
<p class="TX">Thankfully, there’s a way to get the SID from Seatbelt’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp> module. Each 4624 event contains the user’s SID in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubjectUserSid</samp> field. Seatbelt comments out this attribute in the code to keep the output clean, but we can simply uncomment that line and recompile the tool to get that information without needing to run anything else.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Building the Malicious Handler</samp></h4>&#13;
<p class="TNI">With all the requisite information collected we can hijack the handler for the <i>.xlsx</i> file extension for only this user. The first thing we need to do is create the malicious handler. This simple application will execute our shellcode and then open the intended file handle, which should open the file selected by the user in a way they’d expect. This file will need to be written to the target filesystem, so we know we’re going to be scanned, either at the time we upload it or on its first invocation based on the configuration of the EDR’s minifilter. To mitigate some of this risk, we can obfuscate the evil handler in a way that will hopefully allow us to fly under the radar.</p>&#13;
<p class="TX">The first big issue we’ll need to conceal is the huge blob of agent shellcode hanging out in our file. If we don’t obfuscate this, a mature scanner will quickly identify our handler as malicious. One of my favorite ways to obscure these agent shellcode blobs is called <i>environmental keying</i>. The general gist is that you encrypt the shellcode using a symmetric key derived from some attribute unique to the system or context under which you’ll be running. This can be anything from the target’s internal domain name to the serial number of the hard drive inside the system.</p>&#13;
<p class="TX">In our case, we’re targeting the user <i>TTAYLOR.ADMIN@BINFORD.COM</i>, so we use their username as our key. Because we want the key to be difficult to brute-force should our payload fall into the hands of an incident responder, we pad it out to 32 characters by repeating the string, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_255" aria-label=" Page 255. "/>making our symmetric key the following: <i>TTAYLOR.ADMIN@BINFORD.COMTTAYLOR</i>. We could also combine it with other attributes, such as the system’s current IP address, to add some more variation to the string.</p>&#13;
<p class="TX">Back on our payload development system, we generate the agent shellcode and encrypt it using a symmetric key algorithm—say, AES-256—along with our key. We then replace the non-obfuscated shellcode with the encrypted blob. Next, we need to add key-derivation and decryption functions. To get our key, our payload needs to query the executing user’s name. There are simple ways to do this, but bear in mind that the more simplistic the derivation method, the easier it will be for a skilled analyst to reverse the logic. The more obscure the method of identifying the user’s name, the better; I’ll leave finding a suitable strategy as an exercise to the reader. The decryption function is much more straightforward. We simply pad the key out to 32 bytes and then pass the encrypted shellcode and key through a standard AES-256 decryption implementation, then save the decrypted results.</p>&#13;
<p class="TX">Now here comes the trick. Only our intended user should be able to decrypt the payload, but we have no guarantees that it won’t fall into the hands of Binford’s SOC or managed security service providers. To account for this possibility, we can use a <i>tamper sensor</i>, which works like this. If decryption works as expected, the decrypted buffer will be filled with known contents we can hash. If the wrong key is used, the resultant buffer will be invalid, causing a hash mismatch. Our application can take the hash of the decrypted buffer before executing it and notify us if it detects a hash mismatch. This notification could be a POST request to a web server or something as subtle as changing the timestamp of a specific file on the system we monitor. We can then initiate a full infrastructure teardown so that incident responders can’t start hitting our infrastructure or simply collect information about the failure and adjust accordingly.</p>&#13;
<p class="TX">Since we know we’ll deploy this payload on only one host, we opt for the timestamp-monitoring approach. The implementation of this method is irrelevant and has a very low detection footprint; we merely change the timestamp of some file hidden deep in some directory and then use a persistent daemon to watch it for changes and to notify us if it detects something.</p>&#13;
<p class="TX">Now we need to figure out the location of the legitimate handler so that we can proxy requests to open <i>.xlsx</i> files to it. We can pull this from the registry for a specific user if we know their SID, which our modified copy of Seatbelt told us is <i>S-1-5-21-486F6D6549-6D70726F76-656D656E7-1032</i> for <i>TTAYLOR.ADMIN@BINFORD.COM</i>. We query the <i>xlsx</i> value in <i>HKU:\S-1-5-21-486F6D6549-6D70726F76-656D656E7-1032\SOFTWARE\Microsoft\Windows\CurrentVersion\Extensions</i>, which returns <i>C:\Program Files (x86)\Microsoft Office\Root\Office16\EXCEL.EXE</i>. Back in our handler, we write a quick function to call <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp> with the path to the real <i>excel.exe</i>, passing along the first parameter, which will be the path to the <i>.xlsx</i> file to open. This should execute after our shellcode runner but should not wait for it to complete so that the agent being spawned is apparent to the user.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H3" id="sec17"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_256" aria-label=" Page 256. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Compiling the Handler</samp></h4>&#13;
<p class="TNI">When it comes to compiling our handler, there are a couple of things we need to do to avoid detection. These include:</p>&#13;
<p class="RunInPara"><b>Removing or mangling all string constants</b>   This will reduce the chance that signatures will trigger or be created based on strings used in our code.</p>&#13;
<p class="RunInPara"><b>Disabling the creation of program database (PDB) files</b>   These files include the symbols used for debugging our application, which we won’t need on our target. They can leak information about our build environment, such as the path at which the project was compiled.</p>&#13;
<p class="RunInPara"><b>Populating image details</b>   By default, our compiled handler will contain only basic information when inspected. To make things look a little bit more realistic, we can populate the publisher, version, copyright information, and other details you’d see after opening the Details tab in the file’s properties.</p>&#13;
<p class="TX">Of course, we could take additional measures to further protect our handler, such as using LLVM to obfuscate the compiled code and signing the <i>.exe</i> with a code-signing certificate. But because the risk of this technique being detected is already pretty low and we have some protections in place, we’ll save those measures for another time.</p>&#13;
<p class="TX">Once we’ve compiled our handler with these optimizations and tested it in a lab environment that mimics the Binford system, we’ll be ready to deploy it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Registering the Handler</samp></h4>&#13;
<p class="TNI">Registering a file or protocol handler may seem relatively simple at face value; you overwrite the legitimate handler with a path to your own. Is that it? Not quite. Nearly every file handler is registered with a programmatic identifier (ProgID), a string used to identify a COM class. To follow this standard, we need to either register our own ProgID or hijack an existing one.</p>&#13;
<p class="TX">Hijacking an existing ProgID can be risky, as it may break some functionality on the system and tip the user off that something is wrong, so this probably isn’t the right strategy in this case. We could also look for an abandoned ProgID: one that used to be associated with some software installed on the system. Sometimes, when the software is removed, its uninstaller fails to delete the associated COM registration. However, finding these is relatively rare.</p>&#13;
<p class="TX">Instead, we’ll opt to register our own ProgID. It’s hard for an EDR to monitor the creation of all registry keys and all values being set at scale, so the odds are good that our malicious ProgID registration will go unnoticed. <a href="#tab13-3">Table 13-3</a> shows the basic changes we’ll need to make under the target user’s registry hive.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab13-3"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_257" aria-label=" Page 257. "/><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-3:</samp> <samp class="SANS_Futura_Std_Book_11">Keys to Be Created for Handler Registration</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Key</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Value</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Classes\Excel.WorkBook.16\CLSID</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">{1CE29631-7A1E-4A36-8C04-AFCCD716A718}</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Provides the ProgID-to-CLSID mapping</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Classes\CLSID\{1CE29631 -7A1E-4A36-8C04-AFCCD716A718}\ProgID</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">ExcelWorkBook.16</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Provides the CLSID-to-ProgID mapping</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Classes\CLSID\{1CE29631-7A1E -4A36-8C04-AFCCD716A718}\InprocServer32</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">C:\path\to\our\handler.dll</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Specifies the path to our malicious handler</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">Before deploying our changes to the live target, we can validate them in a lab environment using the PowerShell commands shown in <a href="#list13-2">Listing 13-2</a>.</p>&#13;
<pre id="list13-2"><code>PS &gt; <b>$type = [Type]::GetTypeFromProgId(Excel.Workbook.16)</b>&#13;
PS &gt; <b>$obj = [Activator]::CreateInstance($type)</b>&#13;
PS &gt; <b>$obj.GetMembers()</b></code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 13-2: Validating COM object registration</span></p>&#13;
<p class="TX">We get the type associated with our ProgID and then pass it to a function that creates an instance of a COM object. The last command shows the methods supported by our server as a final sanity check. If everything worked correctly, we should see the methods we implemented in our COM server returned to us via this newly instantiated object.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H3" id="sec19"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Deploying the Handler</samp></h4>&#13;
<p class="TNI">Now we can upload the handler to the target’s filesystem. This executable can be written to any location the user has access to. Your inclination may be to hide it deep in some folder unrelated to Excel’s operation, but this could end up looking odd when it’s executed.</p>&#13;
<p class="TX">Instead, hiding it in plain sight might be our best option. Since we’re an admin on this system, we can write to the directory in which the real version of Excel is installed. If we place our file alongside <i>excel.exe</i> and name it something innocuous, it may look less suspicious.</p>&#13;
<p class="TX">As soon as we drop our file to disk, the EDR will subject it to scanning. Hopefully, the protections we put in place mean it isn’t deemed malicious (though we might not know this until it is executed). If the file isn’t immediately quarantined, we can proceed by making the registry changes.</p>&#13;
<p class="TX">Making changes in the registry can be fairly safe depending on what is being modified. As discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, registry callback notifications might have to process thousands upon thousands of registry events per second. Thus, they must limit what they monitor. Most EDRs monitor only keys associated with specific services, as well as subkeys and values, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">RunAsPPL</samp> value, which controls whether LSASS is launched as a protected process. This works out well for us, because while we know that our actions will generate telemetry, we won’t touch any of the keys that are likely to be monitored.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_258" aria-label=" Page 258. "/>That said, we should change as little as possible. Our PowerShell script will modify the values shown in <a href="#tab13-4">Table 13-4</a> under the target user’s registry hive.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab13-4"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-4:</samp> <samp class="SANS_Futura_Std_Book_11">Registry Keys Modified During Handler Registration</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Registry key</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Operation</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.xlsx\UserChoice</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Delete</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Create</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice\Hash</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Set value</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice\ProgId</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Set value</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">As soon as these registry changes are made, our handler should be functional on the system. Whenever the user next opens a <i>.xlsx</i> file, our handler will be invoked via the common language runtime, execute our shellcode, and then open the real Excel to allow the user to interact with the spreadsheet. When our agent checks in with our command-and-control infrastructure, we should see it come through as <i>TTAYLOR.ADM@BINFORD.COM</i>, elevating our privileges to what appears to be an administrator account on Binford’s Active Directory domain, all without opening a handle to LSASS!</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h2 class="H1" id="sec20"><span id="h-184"/><samp class="SANS_Futura_Std_Bold_B_11">Lateral Movement</samp></h2>&#13;
<p class="TNI">Now that our agent is running on what we suspect to be a privileged account, we need to discover what kind of access we have in the domain. Rather than throwing SharpHound around to collect information (an activity that has become more difficult to do successfully), we can perform more surgical examination to figure out how we can move to another host.</p>&#13;
<p class="TX">You might think that lateral movement, or expanding our access to the environment, must involve deploying more agents on more hosts. However, this can add a ton of new indicators that we may not need. Take PsExec-based lateral movement, for example, in which a service binary containing agent shellcode is copied to the target system and a service targeting that newly copied binary is created and started, initiating a new callback. This would involve generating a network logon event, as well as creating a new file, registry keys for the associated service, a new process, and a network connection to either our command-and-control infrastructure or our compromised hosts.</p>&#13;
<p class="TX">The question then becomes: do we absolutely need to deploy a new agent, or are there other ways to get what we need?</p>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h3 class="H2" id="sec21"><span id="h-185"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_259" aria-label=" Page 259. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding a Target</samp></h3>&#13;
<p class="TNI">One of the first places to start looking for lateral movement targets is the list of established network connections on the current host. This approach has a few benefits. First, it doesn’t require network scanning. Second, it can help you understand the environment’s firewall configuration, because if there is an established connection from the host to another system, it’s safe to assume that a firewall rule allowed it. Lastly, it can let us blend in. Since our compromised system has connected to the hosts in the list at least once, a new connection might seem less anomalous than one to a system with which the host has never communicated.</p>&#13;
<p class="TX">Since we accepted the risk of using Seatbelt previously, we can use it again. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpConnections</samp> module lists the existing connections between our host and others in the network, as shown in <a href="#list13-3">Listing 13-3</a>.</p>&#13;
<pre id="list13-3"><code>====== TcpConnections ======&#13;
&#13;
   Local Address       Foreign Address    State   PID   Service      ProcessName&#13;
   0.0.0.0:135         0.0.0.0:0          LISTEN  768   RpcSs        svchost.exe&#13;
   0.0.0.0:445         0.0.0.0:0          LISTEN  4                  System&#13;
   0.0.0.0:3389        0.0.0.0:0          LISTEN  992   TermService  svchost.exe&#13;
   0.0.0.0:49664       0.0.0.0:0          LISTEN  448                wininit.exe&#13;
   0.0.0.0:49665       0.0.0.0:0          LISTEN  1012  EventLog     svchost.exe&#13;
   0.0.0.0:49666       0.0.0.0:0          LISTEN  944   Schedule     svchost.exe&#13;
   0.0.0.0:49669       0.0.0.0:0          LISTEN  1952  Spooler      spoolsv.exe&#13;
   0.0.0.0:49670       0.0.0.0:0          LISTEN  548   Netlogon     lsass.exe&#13;
   0.0.0.0:49696       0.0.0.0:0          LISTEN  548                lsass.exe&#13;
   0.0.0.0:49698       0.0.0.0:0          LISTEN  1672  PolicyAgent  svchost.exe&#13;
   0.0.0.0:49722       0.0.0.0:0          LISTEN  540                services.exe&#13;
   10.1.10.101:139     0.0.0.0:0          LISTEN  4                  System&#13;
   10.1.10.101:51308   52.225.18.44:443   ESTAB   984                edge.exe&#13;
   10.1.10.101:59024   34.206.39.153:80   ESTAB   984                edge.exe&#13;
   10.1.10.101:51308   50.62.194.59:443   ESTAB   984                edge.exe&#13;
   10.1.10.101:54892   10.1.10.5:49458    ESTAB   2544               agent.exe&#13;
   10.1.10.101:65532   10.1.10.48:445     ESTAB   4                  System <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span></code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 13-3: Enumerating network connections with Seatbelt</span></p>&#13;
<p class="TX">This output can sometimes be overwhelming due to the sheer volume of connections some systems make. We can prune this list a bit by removing connections we’re not interested in. For example, we can remove any HTTP and HTTPS connections, as we’d most likely need to provide a username and password to access these servers; we have access to a token belonging to <i>TTAYLOR.ADM@BINFORD.COM</i> but not the user’s password. We can also remove any loopback connections, as this won’t help us expand our access to new systems in the environment. That leaves us with a substantially smaller list.</p>&#13;
<p class="TX">From here, we notice multiple connections to internal hosts over arbitrarily high ports, indicative of RPC traffic. There are likely no firewalls between us and the hosts, as explicit rules for these ports are very rare, but figuring out the nature of the protocol is tricky if we don’t have GUI access to the host.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_260" aria-label=" Page 260. "/>There is also a connection to an internal host over TCP port 445 <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which is virtually always an indication of remote file-share browsing using SMB. SMB can use our token for authentication and won’t always require us to enter credentials. Furthermore, we can leverage the file-sharing functionality to browse the remote system without deploying a new agent. That sounds like exactly what we’re after!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h3 class="H2" id="sec22"><span id="h-186"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enumerating Shares</samp></h3>&#13;
<p class="TNI">Assuming this is a traditional SMB connection, we now need to find the name of the share being accessed. The easy answer, especially if we assume that we’re an administrator, is to mount the <i>C$</i> share. This will allow us to browse the operating system volume as if we were in the root of the <i>C:</i> drive.</p>&#13;
<p class="TX">However, in enterprise environments, shared drives are rarely accessed in this way. Shared folders are much more common. Unfortunately for us, enumerating these shares isn’t as simple as just listing out the contents of <i>\\10.1.10.48\</i>. There are plenty of ways to get this information, though. Let’s explore some of them:</p>&#13;
<p class="RunInPara"><b>Using the</b> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">net view</samp> <b>command</b>   Requires us to launch <i>net.exe</i> on the host, which an EDR’s process-creation sensors highly scrutinize</p>&#13;
<p class="RunInPara"><b>Running</b> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-SmbShare</samp> <b>in PowerShell</b>   Built-in PowerShell cmdlet that works both locally and remotely but requires us to invoke <i>powershell.exe</i></p>&#13;
<p class="RunInPara"><b>Running</b> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-WmiObject</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Win32_Share</samp> <b>in PowerShell</b>   Similar to the previous cmdlet but queries for shares over WMI</p>&#13;
<p class="RunInPara"><b>Running</b> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SharpWMI.exe</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">action=query query=" "select * from win32_share" "</samp>  Functionally the same as the previous PowerShell example but uses a .NET assembly, which allows us to operate using execute-assembly and its equivalents</p>&#13;
<p class="RunInPara"><b>Using</b> <b><i>Seatbelt.exe</i></b> <b>network shares</b>   Nearly identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">SharpWMI</samp>; uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32_Share WMI</samp> class to query the shares on a remote system</p>&#13;
<p class="TX">These are just a few examples, and there are pros and cons to each. Since we’ve already put in the work to obfuscate Seatbelt and know that it works well in this environment, we can use it again here. Most EDRs work on a process-centric model, meaning that they track activity based on processes. Like our initial access, we’ll be running in <i>excel.exe</i> and, if needed, set our <i>spawnto</i> process to the same image as it was previously. When we enumerate remote shares on <i>10.1.10.48</i>, Seatbelt generates the output shown in <a href="#list13-4">Listing 13-4</a>.</p>&#13;
<pre id="list13-4"><code>====== NetworkShares ======&#13;
&#13;
   Name                           : FIN&#13;
   Path                           : C:\Shares\FIN&#13;
   Description                    :&#13;
   Type                           : Disk Drive&#13;
   Name                           : ENG&#13;
   Path                           : C:\Shares\ENG<span role="doc-pagebreak" epub:type="pagebreak" id="pg_261" aria-label=" Page 261. "/>&#13;
   Description                    :&#13;
   Type                           : Disk Drive&#13;
   Name                           : IT&#13;
   Path                           : C:\Shares\IT&#13;
   Description                    :&#13;
   Type                           : Disk Drive&#13;
&#13;
    <var>--snip--</var>&#13;
&#13;
[*] Completed collection in 0.121 seconds</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 13-4: Enumerating network shares with Seatbelt</span></p>&#13;
<p class="TX">The information tells us a few things about the target system. First, we have the ability to browse <i>C$</i>, which indicates that either we were granted read access to their filesystem volume, or, more likely, we have administrative access to the host. Read access to <i>C$</i> allows us to enumerate things such as installed software and users’ files. These both can provide valuable context about how the system is used and who uses it.</p>&#13;
<p class="TX">The other network shares are more interesting than <i>C$</i>, though. They look like they belong to various business units inside Binford: <i>FIN</i> could stand for Finance, <i>ENG</i> for Engineering, <i>IT</i> for Information Technology, <i>MKT</i> for Marketing, and so on. <i>ENG</i> could be a good target based on our stated objectives.</p>&#13;
<p class="TX">However, there are detection risks to finding out for sure. When we list the contents of a remote share, a few things happen. First, a network connection is established with the remote server. The EDR’s network filter driver will monitor this, and because it is an SMB client connection, the Microsoft-Windows-SMBClient ETW provider comes into play as well. Our client will authenticate to the remote system, creating an event through the ETW provider Microsoft-Windows-Security-Auditing (as well as an event ID 5140, indicating that a network share was accessed, in the security event log) on the remote system. If a <i>system access control list (SACL)</i>, a type of access control list used to audit access requests made for an object, is set on the shared folder or files within, an event will be generated via the Microsoft-Windows-Security-Auditing ETW provider (as well as an event ID 4663) when the contents of the shared folder are accessed.</p>&#13;
<p class="TX">Remember, though, that the fact that telemetry was generated on the host doesn’t necessarily mean that it was captured. In my experience, EDRs monitor almost none of what I mentioned in the preceding paragraph. They might monitor the authentication event and network, but we’re using an already-established network connection to the SMB server, meaning browsing the <i>ENG</i> share could allow us to blend in with the normal traffic coming from this system, lessening the likelihood of detection due to an anomalous access event.</p>&#13;
<p class="TX">This is not to say that we’ll blend in so much that there is no risk at all. Our user may not typically browse the <i>ENG</i> share, making any access event anomalous at the file level. There may be non-EDR controls, such as data-loss prevention software or a canary facilitated through the SACL. We have <span role="doc-pagebreak" epub:type="pagebreak" id="pg_262" aria-label=" Page 262. "/>to measure the reward of this share potentially holding Binford’s crown jewels against the risk of detection posed by our browsing.</p>&#13;
<p class="TX">All signs are pointing to this drive holding what we’re after, so we start recursively listing the subdirectories of the <i>ENG</i> share and find <i>\\10.1.10.48\ENG\Products\6100\3d\screwdriver_v42.stl</i>, a stereolithography file commonly used by design applications in the mechanical engineering world. In order to verify that this file is the 3D model for the Binford 6100 left-handed screwdriver, we’ll need to exfiltrate it and open it in an application capable of processing <i>.stl</i> files.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h2 class="H1" id="sec23"><span id="h-187"/><samp class="SANS_Futura_Std_Bold_B_11">File Exfiltration</samp></h2>&#13;
<p class="TNI">The last step of our attack is pulling Binford’s crown jewels out of its environment. Oddly, of everything we’ve done in this operation, this has the lowest likelihood of detection by the EDR despite having the highest impact to the environment. To be fair, it isn’t really the EDR’s domain. Still, sensors could detect our data exfiltration, so we should remain thoughtful in our approach.</p>&#13;
<p class="TX">There are many ways to exfiltrate data from a system. Choosing a technique depends on a number of factors, such as the data’s location, contents, and size. Another factor to consider is how <i>fault tolerant</i> the data format is; if we don’t receive the full contents of the file, is it still workable? A text file is a good example of a very fault-tolerant file type, as missing half of the file means we’re simply missing half of the text in the document. On the other hand, images are generally not fault tolerant, because if we’re missing some portion of the picture, we generally won’t be able to reconstruct it in any meaningful way.</p>&#13;
<p class="TX">Lastly, we should consider how quickly we need the data. If we need it soon and all at once, we typically inherit a higher risk of detection than if we exfiltrate the file slowly because the volume of data transmitted across the network boundary, where security monitoring is likely to be implemented, will be higher in a given timeframe.</p>&#13;
<p class="TX">In our operation, we can afford to take more risk because we’re not interested in staying embedded in the environment for much longer. Through our reconnaissance against the <i>ENG</i> share, we see that the <i>.stl</i> file is 4MB, which isn’t excessive compared to other types of files. Since we have a high risk tolerance and are working with a small file, let’s take the easy route and exfiltrate the data over our command-and-control channel.</p>&#13;
<p class="TX">Even though we’re using HTTPS, we should still protect the contents of the data. Assume the contents of any message that we send will be subjected to inspection by a security product. When it comes to exfiltrating files specifically, one of our biggest concerns is the file signature, or <i>magic bytes</i>, at the beginning of the file used to uniquely identify the file type. For <i>.stl</i> files, this signature is <samp class="SANS_TheSansMonoCd_W5Regular_11">73 6F 6C 69 64</samp>.</p>&#13;
<p class="TX">Thankfully, there are many ways to obfuscate the type of file we’re exfiltrating, ranging from encrypting the contents of the file to simply trimming off the magic bytes before transmitting the file and then appending them again after the file is received. For human-readable file types, I prefer <span role="doc-pagebreak" epub:type="pagebreak" id="pg_263" aria-label=" Page 263. "/>encryption, since there may be monitoring in place for a specific string in an outbound connection request. For other types of files, I’ll usually either remove, mangle, or falsify the magic bytes for the file if detection at this stage is a concern.</p>&#13;
<p class="TX">When we’re ready to exfiltrate the file, we can use our agent’s built-in download functionality to send it over our established command-and-control channel. When we do this, we are going to make a request to open the file so that we can read its contents into memory. When this happens, the EDR’s filesystem minifilter driver will receive a notification and may look at certain attributes associated with the event, such as who the requestor is. Since the organization itself would have to build a detection from this data, the likelihood of an EDR having a detection here is relatively low.</p>&#13;
<p class="TX">Once we’ve read the contents of the file into our agent’s address space, we can close the handle to the file and start the transfer. Transmitting data over HTTP or HTTPS channels will cause related ETW providers to emit events, but these typically don’t include the message contents if the channel is secure, as with HTTPS. So, we shouldn’t have any issue getting our design plans out. Once we have the file downloaded, we simply add back the magic bytes and open the file in the 3D modeling software of choice (<a href="#fig13-1">Figure 13-1</a>).</p>&#13;
<figure class="IMG"><img id="fig13-1" class="img40" src="../images/Figure13-1.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: The Binford 6100 left-handed screwdriver</samp></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec24">&#13;
<h2 class="H1" id="sec24"><span id="h-188"/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">We’ve completed the engagement objective: accessing the design information for Binford’s revolutionary product (pun intended). While executing this operation, we used our knowledge of an EDR’s detection methods to make educated choices about how to move through the environment.</p>&#13;
<p class="TX">Bear in mind that the path we took may not have been the best (or only) way to reach the objective. Could we have outpaced Binford’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_264" aria-label=" Page 264. "/>defenders without considering the noise we were making? What if we decided not to work through Active Directory and instead used a cloud-based file-hosting application, such as SharePoint, to locate the design information? Each of these approaches significantly alters the ways in which Binford could detect us.</p>&#13;
<p class="TX">After reading this book, you should be armed with the information you need to make these strategic choices on your own. Tread carefully, and good luck.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>