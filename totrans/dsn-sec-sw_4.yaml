- en: Afterword
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are called to be architects of the future, not its victims.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —R. Buckminster Fuller
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: Having watched computing evolve over the last 50 years, I have learned that
    attempting to predict the future is folly. However, to conclude this book I would
    like to offer my thoughts about future directions in security that I think would
    be valuable, unlikely as some of them may be. The following are by no means predictions,
    but rather possibilities that would constitute significant progress.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The nascent internet received a wake-up call in 1988 when the Morris worm first
    demonstrated the potential power of online malware and how it can spread by exploiting
    existing vulnerabilities. More than 30 years later, though we have made astounding
    progress on many fronts, I wonder if we have fully understood these risks and
    prioritized our mitigation efforts sufficiently. Reports of attacks and private
    data disclosures are still commonplace, and no end is in sight. Sometimes, it
    seems that the attackers are having a field day while the defenders are frantically
    treading water. And it’s important to bear in mind that many incidents are kept
    secret, or may even persist undetected, so the reality is almost certainly worse
    than we know. In large part, we’ve learned to live with vulnerable software.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s remarkable is that, despite our imperfect systems continuing to be compromised,
    everything somehow manages to keep going. Perhaps this is why security problems
    persist: the status quo is good enough. But even though I understand the cool
    logic of returns on investment, deep down I just don’t accept that. I believe
    that when, as an industry, we accept the current state of affairs as the best
    we can do, we block real progress. Justifying additional work in the interest
    of security is always difficult because we rarely learn about failed attacks,
    or even what particular lines of defense were effective.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: This concluding chapter sketches out promising future directions to raise the
    level of our collective software security game. The first section recapitulates
    the core themes of the book, summarizing how you can apply the methods in this
    book to good effect. The remainder of this chapter envisions further innovations
    and future best practices, and is more speculative. A discussion of mobile device
    data protection provides an example of how much more needs to be done to actually
    deliver effective security in the “last mile.” I hope the conceptual and practical
    ideas in this book spark your interest in this vital and evolving field, and serve
    as a springboard for your own efforts in making software secure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Call to Action
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The great aim of education is not knowledge but action.
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Herbert Spencer
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This book is built around promoting two simple ideas that I believe will result
    in better software security: involving everyone building the software in promoting
    its security, and integrating a security perspective and strategy from the requirements
    and design stage. I entreat readers of this book to help lead the charge.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, a continuing focus on the quality of the software we create will
    contribute to better security, because fewer bugs mean fewer exploitable bugs.
    High-quality software requires work: competent designs, careful coding, comprehensive
    testing, and complete documentation, all kept up to date as the software evolves.
    Developers, as well as end users, must continue to push for higher standards of
    quality and polish to ensure this focus is maintained.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Security Is Everyone’s Job
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Security analysis is best done by people who deeply understand the software.
    This book lays out the conceptual basis for good security practice, empowering
    any software professional to understand the security facets of design, learn about
    secure coding, and more. Instead of asking experts to find and fix vulnerabilities
    because security has been largely neglected, let’s all pitch in to ensure at least
    a modest baseline is met for all the software we produce. We can then rely on
    experts for the more arcane and technical security work, where their skills are
    best applied. Here’s the rationale:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: However well expert consultants know security, as outsiders, they cannot fully
    understand the software and its requirements in context, including how it must
    operate within the culture of an enterprise and its end users.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security works best when it’s integral to the entire software lifecycle, but
    it isn’t practical to engage security consultants for the long haul.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skilled software security professionals are in high demand, difficult to find,
    and hard to schedule on short notice. Hiring them is expensive.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security thinking is not difficult, but it is abstract and may feel unfamiliar
    at first. Most vulnerabilities tend to be obvious in hindsight; nonetheless, we
    seem to make the same mistakes over and over. The trick, of course, is seeing
    the potential problem before it manifests. This book presents any number of methods
    to help you learn how to do just that. The good news is that nobody is perfect
    at this, so starting out with even a small contribution is better than nothing.
    Over time, you will get better at it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Broader security participation is best understood as a team effort, where every
    individual does the part that they do best. The idea is not that each individual
    can handle the entire job alone, but rather that the combined input of team members
    with a diverse set of skills synergistically produces the best result. Whatever
    your part is in producing, maintaining, or supporting a software product, focus
    on that as your primary contribution. But it’s also valuable to consider the security
    of related components, and double-check the work of your teammates to ensure they
    haven’t overlooked something. Even if your role is a small one, you just might
    spot a vital flaw, just as a soccer goalie occasionally scores a goal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to be clear that outside expertise is valuable for performing
    tasks such as gap analysis or penetration testing, for balancing organizational
    capacity, and as “fresh eyes” with deep experience. However, specialist consultants
    should supplement solid in-house security understanding and well-grounded practice,
    rather than being called in to carry the security burden alone. And even if specialists
    do contribute to the overall security stance, they go off to other engagements
    at the end of the day. As such, it’s always best to have as many people as possible
    on the team responsible for the software be thinking about security regularly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Baking in Security
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bridges, roads, buildings, factories, ships, dams, harbors, and rockets are
    all designed and meticulously reviewed to ensure quality and safety, and only
    then built. In any other engineering field, it’s acknowledged that refining a
    design on paper is better than retrofitting security measures after the fact.
    Yet most software is built first and then secured later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: A central premise of this book, which the author has seen proven in industry
    time and again, is that earlier security diligence saves time and reaps significant
    rewards, improving the quality of the result. When designs thoroughly consider
    security, implementers have a much easier job of delivering a secure solution.
    Structuring components to facilitate security makes it easy to anticipate potential
    issues.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The worst-case scenario, and most compelling reason for front-loading security
    into the design phase (“moving left,” in popular industry jargon), is to avoid
    by-design security flaws. Designed-in security flaws—whether in componentization,
    API structure, protocol design, or any other aspect of architecture—are potentially
    devastating, because they are nearly impossible to fix after the fact without
    breaking compatibility. Catching and fixing these problems early is the best way
    to avoid painful and time-consuming reactive redesigns.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Good security design decisions have greater benefits that often go unrecognized.
    The essence of good design is minimalism without compromising necessary functionality.
    Applied to security, this means the design minimizes the area of the attack surface
    and critical component interactions, which in turn means there are fewer opportunities
    for implementers to make mistakes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Security-focused design reviews are important because functional reviews of
    software designs take a different perspective and ask questions that don’t consider
    security. “Does it fulfill all the necessary requirements? Will it be easy to
    operate and maintain? Is there a better way?” In fact, an insecure design can
    easily pass all these tests with flying colors while being vulnerable to devastating
    attacks. Supplementing design review with a security assessment vets the security
    of the design by understanding the threats it faces and considering how it might
    fail or be abused.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The implementation side of software security consists of learning about, and
    vigilantly avoiding, the many potential ways of inadvertently creating vulnerabilities,
    or at least mitigating those common pitfalls. Secure designs minimize the opportunities
    for the implementation to introduce vulnerabilities, but it can never magically
    make software bulletproof. Developers must be diligent not to undermine security
    by stepping into any number of potential traps.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Security is a process that runs through the entire lifecycle of a software system,
    from conception to its inevitable retirement. Digital systems are complex and
    fragile, and as software “eats the world,” we become increasingly dependent on
    it. We are imperfect humans using imperfect components to build good-enough systems
    for imperfect people. But just because perfection is unattainable does not mean
    we cannot progress. Instead, it means that every bug fixed, every design improved,
    and every security test case added help in ways big and small to make systems
    more trustworthy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Future Security
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The future depends on what you do today.
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Mahatma Gandhi
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This book is built around the methods of improving security that I have practiced
    and seen work consistently, but there is much more to do beyond this. The following
    subsections sketch a few ideas that I think are promising. Although these notions
    require additional development, I believe they may lead to significant further
    advances.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Artificial intelligence or other advanced technologies offer much promise,
    but my intuition is that a lot of the work needed is of the “chop wood, carry
    water” variety. One way we can all contribute is by working to ensure the quality
    of the software we produce, because it is from bugs that vulnerabilities arise.
    Second, as our systems grow in power and scope, complexity necessarily grows,
    but we must manage it so as not to be overwhelmed. Third, in researching this
    book, I was disappointed (but not surprised) by the dearth of solid data about
    the state of the world’s software and how secure it is: surely, more transparency
    will enable a clearer view to better guide us forward. Fourth, authenticity, trust,
    and responsibility are the bedrock of how the software community works together
    safely, yet modern mechanisms that implement these are largely ad hoc and unreliable—advances
    in these areas could be game changers.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Improving Software Quality
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: “The programmers get paid to put the bugs in, and they get paid to take the
    bugs out.” This was one of the most memorable observations I heard as a Microsoft
    program manager 25 years ago, and this attitude about the inevitability of bugs
    still prevails, with little danger of changing any time soon. But bugs are the
    building blocks of vulnerabilities, so it’s important to be aware of the full
    cost of buggy software.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: One way to improve security is to augment the traditional bug triage by also
    considering whether each bug could possibly be part of an attack chain, and prioritizing
    fixing those where this seems more likely and the stakes are high. Even if just
    a fraction of these bug fixes closes an actual vulnerability, I would argue that
    these efforts are entirely worthwhile.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Managing Complexity
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An evolving system increases its complexity unless work is done to reduce it.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Meir Lehman
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As software systems grow larger, managing the resultant complexity becomes more
    challenging, and these systems risk becoming more fragile. The most reliable systems
    succeed by compartmentalizing complexity within components that present simple
    interfaces, loosely coupled in fault-tolerant configurations. Large web services
    achieve high resiliency by distributing requests over a number of machines that
    perform specific functions to synthesize the whole response. Designed with built-in
    redundancy, in the event of a failure or timeout, the system can retry using a
    different machine if necessary.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Compartmentalizing the respective security models of the many components of
    a large information system is a basic requirement for success. Subtle interactions
    between the assembled components may influence security, making the task of securing
    the system massively harder as interdependencies compound. In addition to excellent
    testing, well-documented security requirements and dependencies are important
    first lines of defense when dealing with a complex system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: From Minimizing to Maximizing Transparency
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perhaps the bleakest assessment of the state of software security derives from
    this (variously attributed) aphorism: “If you can’t measure it, you can’t improve
    it.” Lamentably, there is a dearth of measurements of the quality of the world’s
    software, in particular regarding security. Public knowledge of security vulnerabilities
    is limited to a subset of cases: software that is open source, public releases
    of proprietary software (usually requiring reverse engineering of binaries), or
    instances when a researcher finds flaws and goes public with a detailed analysis.
    Few enterprises would even consider making public the full details of their software
    security track record. As an industry, we learn little from security incidents
    because full details are rarely disclosed—which is in no small part due to fear.
    While this fear is not unfounded, it needs to be balanced against the potential
    value to the greater community of more informative disclosure.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或许对软件安全现状最为悲观的评价来源于这个（被不同人归于）格言：“如果你不能衡量它，你就不能改进它。”遗憾的是，世界上关于软件质量，尤其是安全性的衡量标准匮乏。公众对安全漏洞的了解仅限于几个案例：开源软件、专有软件的公开版本（通常需要逆向工程二进制文件），或是研究人员发现漏洞并公开详细分析的情况。很少有企业会考虑公开其软件安全记录的完整细节。作为一个行业，我们从安全事件中学到的东西很少，因为完整的细节很少被披露——这在很大程度上是因为恐惧。虽然这种恐惧并非没有根据，但它需要与更广泛社区从更具信息量的披露中获得的潜在价值相平衡。
- en: 'Even when we accept the barriers that exist to a full public disclosure of
    all security vulnerabilities, there is much room for improvement. The security
    update disclosures for major operating systems typically lack useful detail at
    the expense of their users, who would likely find additional information useful
    in responding to and assessing risk. In the author’s opinion, major software companies
    often obscure the information they do provide to the point of doublespeak. Here
    are a few examples from a recent operating system security update:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们接受公开披露所有安全漏洞的障碍，仍然有很大的改进空间。主要操作系统的安全更新披露通常缺乏有用的细节，这对用户造成了不利影响，因为用户可能会发现额外的信息有助于响应和评估风险。在作者看来，主要的软件公司常常对它们所提供的信息进行掩盖，甚至到达了双重表述的地步。以下是最近一个操作系统安全更新中的一些例子：
- en: “A logic issue was addressed with improved restrictions.” (This applies to almost
    any security bug.)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “通过改进限制解决了一个逻辑问题。”（这几乎适用于任何安全漏洞。）
- en: “A buffer overflow issue was addressed with improved memory handling.” (How
    is it possible to fix a buffer overflow any other way?)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “通过改进内存处理解决了一个缓冲区溢出问题。”（除了改进内存处理，还有什么方法可以修复缓冲区溢出问题呢？）
- en: “A validation issue was addressed with improved input sanitization.” (Again,
    this can be said of any input validation vulnerability.)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “通过改进输入消毒解决了一个验证问题。”（同样，这可以说是任何输入验证漏洞的描述。）
- en: This lack of detail has become reflexive with too many products; it harms customers,
    and the software security community would benefit from more informative disclosure.
    Software publishers can almost always provide additional information without compromising
    future security. Realistically, adversaries are going to analyze changes in the
    updates and glean basic details, so useless release notes only deprive honest
    customers of important details. Responsible software providers of the future would
    do better to begin with full disclosure, then redact it as necessary so as to
    not weaken security. Better yet, after the risk of exploit is past, it should
    be safe to disclose additional details held in abeyance that would be valuable
    to our understanding of the security of major commercial software products, if
    only in the rearview mirror.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缺乏细节的情况已经成为许多产品的惯例；它损害了客户的利益，软件安全社区也会从更具信息量的披露中受益。软件发布者几乎总是可以提供额外的信息，而不损害未来的安全性。实际上，敌对者会分析更新中的变化并提取基本细节，因此无用的发布说明只会剥夺诚实客户获得重要信息的机会。未来负责任的软件供应商最好从完全披露开始，然后根据需要进行删减，以免削弱安全性。更好的是，在利用风险过后，应该安全地披露那些尚未公开的额外细节，这些细节对于我们理解主要商业软件产品的安全性是有价值的，即使只是从事后视角来看。
- en: 'Providing detailed reporting of vulnerabilities may be embarrassing, because
    in hindsight the problem is usually blatantly obvious, but I maintain that honestly
    confronting these lapses is healthy and productive. The learning potential from
    a full disclosure is significant enough that if we are serious about security
    for the long term, we need greater transparency. As a customer, I would be much
    more impressed with a software vendor whose security fix release notes included:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Dates that the bug was reported, triaged, fixed, tested, and released, with
    an explanation of any untoward delays.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A description of when and how the vulnerability was created (for example, a
    careless edit, ignorance of the security implications, miscommunication, or a
    malicious attack).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about whether the commit that contained the flawed code was reviewed.
    If so, how was it missed; if not, why not?
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An account of whether there was an effort to look for similar flaws of the same
    kind. If so, what was found?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details of any precautions taken to prevent regression or similar flaws in the
    future.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shifting the industry toward a culture of sharing more forthcoming disclosures
    of vulnerabilities, their causes, and their mitigations enables us all to learn
    from these incidents. Without much detail or context, these disclosures are just
    going through the motions and benefit no one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: A great example of best practice is the National Transportation Safety Board,
    which publishes detailed reports that the aviation industry as well as pilots
    can follow to learn from accidents. For many reasons software cannot simply follow
    that process, but it serves as a model to aspire to. Ideally, leading software
    makers should see public disclosure as an opportunity to explain exactly what
    happened behind the scenes, demonstrating their competence and professionalism
    in responding. This would not only aid broad learning and prevention of similar
    problems in other products, but help rebuild trust in their products.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Improving Software Authenticity, Trust, and Responsibility
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Large modern software systems are built from many components, all of which must
    be authentic and built by trustworthy entities, from secure subcomponents, using
    a secure tool stack. This chain continues on and on, literally to the dawn of
    modern digital computing. The security of our systems depends on the security
    of all these iterations that have built up our modern software stack, yet the
    exact chains of descent have by now faded into the mists of computing history,
    back to a few early self-compiling compilers that began it all. The classic paper
    “[Reflections on Trusting Trust](https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf)”
    by Ken Thompson elegantly demonstrates how security depends on all of this history,
    as well as how hard it can be to find malware once it’s deeply embedded. How do
    we really know that something untoward isn’t lurking in there?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The tools necessary to ensure the integrity of how our software is built are
    by now freely available, and it’s reasonable to assume they work as advertised.
    However, their use tends to be dismayingly ad hoc and manual, making the process
    susceptible to human error, if not potential sabotage. Sometimes people understandably
    skip checking just to save time. Consider, for example, validating the legitimacy
    of a *nix distribution. After downloading an image from a trusted website, you
    would also download the separate authoritative keys and checksum files, then use
    a few commands (obtained from a trustworthy source) to verify it all. Only after
    these checks all pass should installation proceed. But in practice, how thoroughly
    are administrators actually performing these extra steps, especially when instances
    of these checks failing for a major distro are unheard of? And even if they always
    are, we have no record of it as assurance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Today, software publishers sign released code, but the signature only assures
    the integrity of the bits against tampering. There is an implication that signed
    code is trustworthy, yet any subsequent discovery of vulnerabilities in no way
    invalidates the signature, so that is not a safe interpretation at all.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In the future, better tools, including auditable records of the chain of authenticity,
    could provide a higher assurance of integrity, informing the trust decisions and
    dependencies that the security of our systems relies on. New computers, for example,
    should include a software manifest documenting that the operating system, drivers,
    applications, and so on are authentic. Documenting and authenticating the software
    bill of materials of components and the build environment require a major effort,
    but we shouldn’t let the difficulty deter us from starting with a subset of the
    complete solution and incrementally improving over time. If we start getting serious
    about software provenance and authenticity, we can do a much better job of providing
    assurance that important software releases are built from secure components, and
    the future will thank us.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Delivering the Last Mile
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The longest mile is the last mile home.
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Anonymous
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you diligently follow every best practice, apply the techniques described
    in this book, code with attention to avoid footguns, perform reviews, thoroughly
    test, and fully document the complete system, I wish that I could say your work
    will be perfectly secure. But of course, it’s more complicated than that. Not
    only is security work never finished, but even well-designed and well-engineered
    systems can still fall short of delivering the intended levels of security in
    the real world.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The “last mile,” a term taken from the telecommunications and transportation
    industries, refers to the challenge of connecting individual customers to the
    network. This is often the most expensive and hardest part of delivering services.
    For example, an internet service provider might already have high-speed fiber
    infrastructure in your neighborhood, but acquiring each new customer requires
    a service call, possibly running cables, and installing a modem. None of this
    scales well, and the time and expense become significant additional upfront investments.
    In much the same way, deploying a well-designed, secure system is often only the
    beginning of actually delivering real security.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand these “last mile” challenges for security, let’s take an in-depth
    look at the current state of the art of mobile device data security through the
    lens of a simple question: “If I lose my phone, can someone else read its contents?”
    After years of intensive engineering effort resulting in a powerful suite of well-built
    modern crypto technology, the answer, even for today’s high-end phones, seems
    to be, “Yes, they probably can get most of your data.” As this is perhaps the
    largest single software security effort in recent times, it’s important to understand
    where it falls short and why.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The following discussion is based on the 2021 paper “[Data Security on Mobile
    Devices: Current State of the Art, Open Problems, and Proposed Solutions](https://securephones.io/),”
    written by three security researchers at Johns Hopkins University. The report
    describes several important ways that delivering robust software security often
    remains elusive. I will simplify the discussion greatly in the interests of highlighting
    the larger lessons for security that this example teaches.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s talk about levels of data protection. Mobile apps do all kinds
    of useful things—too much for a single encryption regime to work for everything—so
    mobile operating systems provide a range of choices. The iOS platform offers three
    levels of data protection that differ mainly in how aggressively they minimize
    the time window that encryption keys are present in memory to facilitate access
    to protected data. You can think of this as analogous to how often a bank vault
    door is left open. Opening the big, heavy door in the morning and shutting it
    only at closing time provides the staff convenient access throughout the day,
    but it also means the vault is more exposed to intrusion when not in use. By contrast,
    if the staff has to find the bank manager to open the vault every time they need
    to enter, they trade that convenience for increased security: the vault is securely
    locked most of the time. For a mobile device, asking the user to unlock the encryption
    keys (by password, fingerprint, or facial recognition) in order to access protected
    data roughly corresponds to asking the bank manager to open the vault.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Under the highest level of protection, the encryption keys are only available
    while the phone is unlocked and in use. While very secure, this is a hindrance
    for most apps, because they lose access to data when the device is locked. For
    example, consider a calendar app that reminds you when it’s time for a meeting.
    A locked phone renders the app unable to access calendar data. Background operations,
    including syncing, will also be blocked during the locked state. This means that
    if an event were added to your calendar while the phone was locked, then you would
    fail to get the notification unless you happened to unlock the phone beforehand
    so it could sync. Even the least restrictive protection class, known as *After
    First Unlock (AFU)*, which requires user credentials to reconstitute encryption
    keys after booting, presents serious limitations. As the name suggests, a freshly
    rebooted device would not have encryption keys available, so a calendar notification
    would be blocked then, too.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: We can imagine designing apps to work around these restrictions by partitioning
    data into separate stores under different protection classes, depending on when
    it is needed. Perhaps for a calendar, the time would be unprotected so as to be
    available, so the notification would vaguely say, “You have a meeting at 4 PM,”
    requiring the user to unlock the device to get the details. Notifications lacking
    titles would be annoying, but users also expect their calendars to be encrypted
    for privacy, so a trade-off is necessary. The sensitivity of this information
    may vary between users and depend on the specifics of the meeting, but making
    the user explicitly decide in each case isn’t workable either, because people
    expect their apps to work on their own. In the end, most apps opt for increased
    access to the data they manage, and end up using lower levels of data protection—or,
    often, none at all.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: When most apps operate under the “no protection” option for convenience, all
    that data is a sitting duck for exfiltration if the attacker can inspect the device.
    It isn’t easy, but as the Johns Hopkins report details, sophisticated techniques
    often find a way into memory. With AFU protection, all the attacker needs to do
    is find the encryption key, which, since devices spend most of their time in this
    state, is often sitting in memory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Confidential messaging apps are the main exception to the rule; they use the
    “complete protection” class. Given their special purpose, users are predisposed
    to put up with the missing functionality when the device is locked and the extra
    effort required to use them. These are a minority of apps, comprising a tiny proportion
    of locally stored user data, yet most phone users (those who even think about
    security at all) probably believe all of their data is secure.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: As if the picture wasn’t already bleak enough, let’s consider how important
    cloud integration is for many apps, and how it is antithetical to strong data
    protection. The cloud computing model has revolutionized modern computing, and
    we are now accustomed to having ubiquitously connected datacenters at our fingertips,
    with web search, real-time translation, image and audio storage, and any number
    of other services instantly available. Functionality such as searching our photo
    collections for people using facial recognition vastly exceeds even the considerable
    compute power of modern devices, so it very much depends on the cloud. The cloud
    data model also makes multi-device access easy (no more syncing), and if we lose
    a device, the data is safely stored in the cloud so all we need to do is buy new
    hardware. But in order to leverage the power of the cloud, we must entrust it
    with our data instead of locking it down with encryption on our devices.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all of this seamless data access is antithetical to strong data protection,
    particularly in the case of a lost cloud-connected phone. Most mobile devices
    have persistent cloud data access, so whoever recovers the device potentially
    has access to the stored data too. That data most likely isn’t encrypted; even
    if we tried to envision, say, a photo app that stored end-to-end encrypted data
    in the cloud, that would mean only opaque blobs of bits could be stored, so we’d
    lose the power of the cloud to search or provide photo sharing. And since the
    decryption key would have to be strictly held on the device, multi-device access
    scenarios would be difficult. Also, if something happened to the key on the device,
    all the data in the cloud would potentially be useless. For all these reasons,
    apps that rely on the cloud almost completely opt out of encrypted data protection.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: We’ve only scratched the surface of the full technical details of the effectiveness
    of data protection in mobile devices here, but for our purposes, the outlines
    of the more general problem should be clear. Mobile devices exist in a rich and
    complicated ecosystem, and unless data protection works for all components and
    scenarios, it quickly becomes infeasible to use. The best advice remains to not
    use your phone for anything that you wouldn’t greatly mind possibly leaking if
    you lose it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The lessons of this story that I want to emphasize go beyond the design of mobile
    device encryption, and in broad outlines apply to any large systems seeking to
    deliver security. The point is that despite diligent design, with a rich set of
    features for data protection, it’s all too easy to fall short of fully delivering
    security in the last mile. Having a powerful security model is only effective
    if developers use it, and when users understand its benefits. Achieving effective
    security requires providing a useful balance of features that work with, instead
    of against, apps. All the data that needs protection must get it, and interactions
    with or dependencies on infrastructure (such as the cloud in this example) shouldn’t
    undermine its effectiveness. Finally, all of this must integrate with typical
    work flows so that end users are contributing to, rather than fighting, security
    mechanisms.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Years ago I witnessed a case of falling short on the last mile with the release
    of the .NET Framework. The security team worked hard getting Code Access Security
    (CAS)—described in Chapter 3—into this new programming platform, but failed to
    evangelize its use enough. Recall that CAS requires that managed code be granted
    permissions to perform privileged operations and then assert them when needed—an
    ideal tool for the Least Privilege pattern. Unfortunately, outside of the runtime
    team, developers perceived this as a burden and failed to see the feature’s security
    benefit. As a result, instead of using the fine-grained permissions that the system
    provided only where needed, applications would typically assert full privilege
    once, at the start of the program, and then operate entirely without restrictions.
    This worked functionally, but meant that applications ran under excess permissions—with
    the bank vault door always open, if you will—resulting in any vulnerabilities
    being far more exposed to risk than they would have been if CAS had been used
    as intended.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: These considerations are representative of the challenges that all systems face,
    and are a big reason why security work is never really done. Having built a great
    solution, we need to ensure that it is understood by developers as well as users,
    that it is actually used, and that it is used properly. Software has a way of
    getting used in novel ways its makers never anticipated, and as we learn about
    these cases, it’s important to consider the security ramifications and, if necessary,
    adapt. All of these factors and more are essential to building secure systems
    that really work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software has the unique and auspicious property of consisting entirely of bits—it’s
    just a bunch of 0s and 1s—so we can literally conjure it out of thin air. The
    materials are free and available in unlimited quantities, so our imagination and
    creativity are the only limiting factors. This is equally true for the forces
    of good as it is for those who seek to harm, so both the promise and the daunting
    challenge are unbounded.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provided a call to action and some forward-looking ideas. When
    developing software, consider security implications early in the process, and
    get more people thinking about security to provide more diverse perspectives on
    the topic. An increased awareness of security leads to healthy skepticism and
    vigilance throughout the software lifecycle. Lessen your dependence on manual
    checking, and provide more automated verification. Keep auditable records of all
    key decisions and actions along the way to realizing a system, so the security
    properties of the system are well defined. Choose components wisely, but also
    test assumptions and important properties of the system. Reduce fragility; manage
    complexity and change. When vulnerabilities arise, investigate their root causes,
    learn from them, and proactively reduce the risk going forward. Critically examine
    realistic scenarios and work toward delivering security to the last mile. Publish
    the details as fully as is responsible so others can learn from the issues you
    encounter and how you respond. Iterate relentlessly in small steps to improve
    security and honor privacy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for joining me on this trek through the hills and valleys of software
    security. We certainly did not cover every inch, but you should now have a grasp
    of the lay of the land. I hope you have found useful ideas herein and, with a
    better understanding of the topic, that you will begin to put them into practice.
    This book isn’t *the* answer, but it offers *some* answers to raising the bar
    on software security. Most importantly, please don your “security hat” from time
    to time and apply these concepts and techniques in your own work, starting today.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
