- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solving ciphers with hill climbing
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502727c16/g16001.png)'
  prefs: []
  type: TYPE_IMG
- en: Many of the encryption methods introduced in this book can be broken with a
    strategy called *hill climbing*. Computer scientists developed this technique
    to solve certain kinds of optimization problems, most of which are not crypto
    related. It is well suited, for instance, to finding the shortest route that includes
    certain cities or determining the most efficient configuration of a production
    facility. The method is named “hill climbing” because it aims to improve a given
    configuration iteratively, until the “top of the mountain” is reached and no further
    improvement is possible, as represented in [Figure 16-1](#figure16-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502727c16/f16001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-1: A hill-climbing algorithm takes a random key and checks whether
    the plaintext obtained with it looks like real language. By making small changes
    to the key, it tries to improve the result until no better one can be found. The
    last candidate often is the correct one.'
  prefs: []
  type: TYPE_NORMAL
- en: Hill climbing is especially suited for problems that have too many potential
    solutions for the cryptanalyst to check every single one. It requires that the
    problem be “smooth,” which means that a small change in the input may cause only
    a small change in the output. Most codebreaking tasks used on classical ciphers
    fulfill both requirements. For these deciphering methods, the number of potential
    solutions (i.e., the number of keys) is extremely large. For example, there are
    403,291,461,126,605,635,584,000,000 (about 400 trillion trillion, or 4 × 10^(26))
    ways to create a simple substitution table with twenty-six letters—way too many
    to check every one, even with the best computer. In addition, small changes in
    the key of many classical encryption methods cause only small changes in the ciphertext.
    For instance, if we switch two ciphertext symbols in a simple substitution table,
    the changes in the decryption result are only minor.
  prefs: []
  type: TYPE_NORMAL
- en: Hill climbing is only feasible when implemented as a computer program. Codebreakers
    have successfully used this method to break a wide range of encryption algorithms,
    including difficult machine ciphers such as the one used by the Enigma. Today,
    quite a few computer programs (for instance, CrypTool 2) support hill-climbing
    algorithms for codebreaking. However, codebreakers must still customize hill climbing
    for the system they are attacking. For this reason, a variety of hill-climbing
    implementations are available.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that, while hill climbing is a powerful tool for breaking
    historically important ciphers, it is not suited at all to attacking modern encryption
    algorithms such as AES or DES. This is because modern encryption algorithms are
    not smooth, and a small change in their key or plaintext should cause a major
    change in the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: Solving simple substitution ciphers with hill climbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we explain the technique of hill climbing by applying it to
    a simple substitution ciphertext. As you will see later in this chapter, we can
    apply the same technique to other ciphers. Take a look at the following cryptogram,
    a challenge published in Sabine Baring-Gould’s 1896 book *Curiosities of Olden
    Times*:^([1](b06.xhtml#c16-endnote-1))^, ^([2](b06.xhtml#c16-endnote-2))
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502727c16/g16002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s first translate this cryptogram into a version that is easier for a computer
    program to process. We replace the symbol that appears first with `A`, the next
    one with `B`, the third one with `C`, and so on, keeping the word breaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A BCDE CF GHI HAFE CJ KLDGH GKL CF GHI BMJH`'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We start by creating a random substitution table:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Plaintext:` `ABCDEFGHIJKLMNOPQRSTUVWXYZ`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ciphertext: SNOIJRGYZLMBPDQWUVHFCTAXEK`'
  prefs: []
  type: TYPE_NORMAL
- en: Step 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Then, we use the substitution table to decrypt the cryptogram, which gives
    us the following plaintext candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: '`S NOIJ OR GYZ YSRJ OL MBIGY GMB OR GYZ NPLY`'
  prefs: []
  type: TYPE_NORMAL
- en: Step 3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, we rate the correctness of the plaintext candidate with a so-called *fitness
    function*. Using a fitness function is the most sophisticated and critical part
    of a hill-climbing attack. There are many ways to check whether a certain text
    is more or less correct (i.e., whether it looks like real language). In our case,
    we take a simple approach based on letter frequencies. Advanced codebreakers will
    easily find better methods.
  prefs: []
  type: TYPE_NORMAL
- en: For each letter, we determine its frequency in the plaintext candidate and compare
    it with the distance from that frequency in an average English text of the same
    length. In our case, the ciphertext has thirty-three characters. Based on the
    fact that, in the English language, the letter *A* has a frequency of 8%, *B*
    of 1%, and *C* of 3%, we set the expected frequency of these letters in the plaintext
    candidate to three, zero, and one. The expected frequencies of the remaining letters
    are derived in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we compare the frequencies in the plaintext candidate with the expected
    frequencies and determine the distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Letter** | **Frequency in the plaintext candidate** | **Expected frequency**
    | **Distance** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | 0 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `B` | 2 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `E` | 0 | 4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `F` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `G` | 4 | 1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | 0 | 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `I` | 2 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `J` | 2 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `K` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `L` | 2 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | 2 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | 2 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `O` | 4 | 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `P` | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `Q` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `R` | 3 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | 2 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `T` | 0 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `U` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `W` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `X` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `Y` | 5 | 1 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `Z` | 2 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Sum: 34 |'
  prefs: []
  type: TYPE_TB
- en: The sum of the distances (here, thirty-four) is the result of the fitness function.
    The lower the result, the better the fit.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we slightly randomize the substitution table. In the following, the second
    line is the old substitution alphabet, while the third line is the new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Plaintext:` `ABCDEFGHIJKLMNOPQRSTUVWXYZ`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Old ciphertext: SNOIJRGYZLMBPDQWUVHFCTAXEK`'
  prefs: []
  type: TYPE_NORMAL
- en: '`New ciphertext: SNOIJFGYZLMBPDQWUVHRCTAXEK`'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have made only a small change, exchanging the positions of
    `F` and `R`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the next step, we decrypt the ciphertext with the new substitution table
    and get a new plaintext candidate (the old plaintext is listed for comparison):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Old plaintext:` `S NOIJ OR GYZ YSRJ OL MBIGY GMB OR GYZ NPLY`'
  prefs: []
  type: TYPE_NORMAL
- en: '`New plaintext:` `S NOIJ OF GYZ YSFJ OL MBIGY GMB OF GYZ NPLY`'
  prefs: []
  type: TYPE_NORMAL
- en: Step 6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Again, we rate the correctness of the plaintext candidate with our fitness
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Letter** | **Frequency in the plaintext candidate** | **Expected frequency**
    | **Distance** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | 0 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `B` | 2 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `E` | 0 | 4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `F` | 3 | 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `G` | 4 | 1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | 0 | 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `I` | 2 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `J` | 2 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `K` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `L` | 2 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | 2 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | 2 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `O` | 4 | 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `P` | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `Q` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `R` | 0 | 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | 2 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `T` | 0 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `U` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `W` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `X` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `Y` | 5 | 1 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `Z` | 2 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Sum: 36 |'
  prefs: []
  type: TYPE_TB
- en: The overall distance between the expected and real letter frequencies has become
    larger, which means that the correctness of the plaintext candidate has decreased.
    For this reason, we go back to the previous substitution alphabet. If there had
    been an improvement, we would have kept the current table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we change the substitution table slightly. Here, we have exchanged the
    positions of `T` and `J`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Plaintext:` `ABCDEFGHIJKLMNOPQRSTUVWXYZ`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Old ciphertext: SNOIJRGYZLMBPDQWUVHFCTAXEK`'
  prefs: []
  type: TYPE_NORMAL
- en: '`New ciphertext: SNOITRGYZLMBPDQWUVHFCJAXEK`'
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 (again)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We decrypt the ciphertext with the changed substitution table and get a new
    plaintext candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Old plaintext:` `S NOIJ OR GYZ YSRJ OL MBIGY GMB OR GYZ NPLY`'
  prefs: []
  type: TYPE_NORMAL
- en: '`New plaintext:` `S NOIT OR GYZ YSRT OL MBIGY GMB OR GYZ NPLY`'
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 (again)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Then, we rate the correctness of the plaintext candidate with our fitness function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Letter** | **Frequency in the plaintext candidate** | **Expected frequency**
    | **Distance** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | 0 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `B` | 2 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `E` | 0 | 4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `F` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `G` | 4 | 1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | 0 | 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `I` | 2 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `J` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `K` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `L` | 2 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | 2 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | 2 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `O` | 4 | 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `P` | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `Q` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `R` | 3 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | 2 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `T` | 2 | 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `U` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `W` | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `X` | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `Y` | 5 | 1 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `Z` | 2 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Sum: 30 |'
  prefs: []
  type: TYPE_TB
- en: The result of the fitness function has now decreased, which means that the plaintext
    candidate looks more like a text in the English language. We therefore keep the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: We repeat the procedure described in the previous paragraphs many times. If
    the new substitution table leads to a lower result from the fitness function,
    we keep it. Otherwise, we restore the previous table. We keep doing this until
    the result of the fitness function doesn’t improve any further for, say, ten steps.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the last plaintext candidate is correct. However, there is no guarantee
    of this, as it is possible for a wrong plaintext candidate to deliver a better
    fitness function result than all of its tested neighbors, at which point, we call
    it a *local maximum*. In such a case, we simply restart the algorithm with a new
    randomly generated key. If several hill-climbing trials fail to produce a plaintext
    that makes sense, our assumption that we are dealing with a simple-substitution
    cryptogram might be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the Baring-Gould cryptogram, the correct plaintext is `A BIRD
    IN THE HAND IS WORTH TWO IN THE BUSH`. Here’s the substitution table:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Plaintext:` `ABIRDNTHESWOU`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ciphertext: ABCDEFGHIJKLM`'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the plaintext contains only thirteen different letters.
  prefs: []
  type: TYPE_NORMAL
- en: Simulated annealing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid getting stuck at local maxima, some codebreakers use a variation on
    hill climbing known as *simulated annealing*. Unlike regular hill climbing, a
    simulated-annealing algorithm moves to a new key candidate not only if the fitness
    function result improves but also, in some cases, when it decreases. In other
    words, the path from one key candidate to another can also go downhill. These
    downhill steps are, however, exceptions, which ensures that the general direction
    of our path is uphill, as shown in [Figure 16-2](#figure16-2).
  prefs: []
  type: TYPE_NORMAL
- en: The decision to take a downhill step depends on a random number and some configurable
    details. We can vary the probability of a downhill step during the process, based
    on a control parameter known as the *temperature*. A higher temperature means
    that downhill steps are more likely, and a lower temperature decreases their probability.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502727c16/f16002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-2: Simulated annealing is a variation on hill climbing. While the
    latter moves to a new key only if the fitness function result increases, simulated
    annealing allows for downhill steps.'
  prefs: []
  type: TYPE_NORMAL
- en: Because simulated annealing allows for downhill steps, the algorithm can find
    a path leading away from a local maximum. However, simulated annealing is often
    slower than hill climbing, as the downhill steps cause the algorithm to take longer.
  prefs: []
  type: TYPE_NORMAL
- en: The term *simulated annealing* comes from the process of annealing in metallurgy,
    which is a method involving the heating and controlled cooling of a material to
    increase the size of its crystals and reduce their defects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: Bart Wenmeckers’s solution to the Baring-Gould cryptogram'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While CrypTool 2 supports hill climbing, some experienced codebreakers have
    written their own hill-climbing code, which allows them to adapt the fitness function
    and other parameters easily. This section considers the output of a program written
    by one of our colleagues, New Zealand-based crypto expert Bart Wenmeckers.^([3](b06.xhtml#c16-endnote-3))
  prefs: []
  type: TYPE_NORMAL
- en: 'Bart’s program uses a much more sophisticated fitness function than the one
    above. It delivers a higher value each time a plaintext candidate looks more like
    real language. This is the opposite of what is done above. The program prints
    two lines when a substitution table delivers a better result than its predecessor.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AYISLNTHEPFRBDJXMWCQOKZGVU,313`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A YISL IN THE HANL IP FRSTH TFR IN THE YDPH`'
  prefs: []
  type: TYPE_NORMAL
- en: This output indicates that the current substitution table is the following .
    . .
  prefs: []
  type: TYPE_NORMAL
- en: '`Plaintext:` `ABCDEFGHIJKLMNOPQRSTUVWXYZ`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ciphertext: AYISLNTHEPFRBDJXMWCQOKZGVU`'
  prefs: []
  type: TYPE_NORMAL
- en: '. . . and that the result of the fitness function is 313\. The output’s second
    line is the plaintext candidate (see below). When Bart tried his program with
    the cryptogram from Sabine Baring-Gould’s book, he received the following sequential
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AYISLNTHEMBUQDVWCGPJZRXKOF,323`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A YISL IN THE HANL IM BUSTH TBU IN THE YDMH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARISDNTHEMBOUFQWKXCZGPVLYJ,327`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A RISD IN THE HAND IM BOSTH TBO IN THE RFMH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARISDNTHEMOBUFQWKXCZGPVLYJ,331`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A RISD IN THE HAND IM OBSTH TOB IN THE RFMH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARISDNTHEMOPUFQWKXCZGBVLYJ,333`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A RISD IN THE HAND IM OPSTH TOP IN THE RFMH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARISDNTHEGOPZFQWUXVJMBCLYK,334`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A RISD IN THE HAND IG OPSTH TOP IN THE RFGH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARISDNTHEGOFZPQWUXVJMBCLYK,343`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A RISD IN THE HAND IG OFSTH TOF IN THE RPGH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARISDNTHEMOFZPQWUXVJGBCLYK,347`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A RISD IN THE HAND IM OFSTH TOF IN THE RPMH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARISDNTHEMOFCYBKWXZJVLUGQP,348`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A RISD IN THE HAND IM OFSTH TOF IN THE RYMH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARISDNTHELOFZUJMBXCKGVQPYW,349`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A RISD IN THE HAND IL OFSTH TOF IN THE RULH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARILDNTHESOFJMXVUWGQCPBKZY,354`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A RILD IN THE HAND IS OFLTH TOF IN THE RMSH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARILDNTHESOFVUKMXGPYZJWCBQ,355`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A RILD IN THE HAND IS OFLTH TOF IN THE RUSH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`AMILDNTHESOFVUJQXGPYZKWCBR,357`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A MILD IN THE HAND IS OFLTH TOF IN THE MUSH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`AMIRDNTHESCOYUBQVXLPWZGJFK,358`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A MIRD IN THE HAND IS CORTH TCO IN THE MUSH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ABIRDNTHESWOYUMXVQCZJLKGPF,365`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A BIRD IN THE HAND IS WORTH TWO IN THE BUSH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ABIRDNTHESPOGUJMQXZYKCWLFV,366`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A BIRD IN THE HAND IS PORTH TPO IN THE BUSH`'
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen, Bart’s program found the correct solution, rated 365, but didn’t
    stop there. It rated `A BIRD IN THE HAND IS PORTH TPO IN THE BUSH` as an even
    better solution, with 366 points. Things like this can happen. Of course, a human
    watching the computer do its work would probably have guessed the correct solution
    much earlier than the computer, by operating as if they were on *Wheel of Fortune*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: The Florida murder case cryptogram'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some ciphers and cryptograms are associated with horrific crimes. In 2004, eleven-year-old
    Carlie Brucia was kidnapped from a car wash in Sarasota, Florida, and later killed.
    Based on a surveillance video, police identified car mechanic Joseph P. Smith
    as the murderer. In 2005, while in jail and awaiting his trial, he tried to send
    an encrypted message ([Figure 16-3](#figure16-3)) to his brother.
  prefs: []
  type: TYPE_NORMAL
- en: The Cryptanalysis and Racketeering Records Unit (CRRU), the FBI’s codebreaking
    unit, soon broke this cryptogram but did not publicly release any details.^([4](b06.xhtml#c16-endnote-4))
    In 2014, when Klaus read about the story in a 2005 FBI report,^([5](b06.xhtml#c16-endnote-5))
    he posted the encrypted message on his blog, after which, German crypto expert
    and CrypTool 2 developer Nils Kopal quickly solved it via hill climbing.^([6](b06.xhtml#c16-endnote-6))
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502727c16/f16003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-3: The murderer of Carlie Brucia tried to send this encrypted message
    from prison to his brother.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, Nils created the following transcript:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+5 5 +1 5 %3 +2 -4 x4 -1 +1 %2 %4 x4 %2 +3 -5`'
  prefs: []
  type: TYPE_NORMAL
- en: '`%5 %2 -3 -5 -4 +3 -5 +1 %5 -1 +2 %2 %3 +1 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`x5 +3 +1 +2 -5 %4 -4 x4 5 x5 -5 +2 -1 3 +1 +2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-5 +3 -5 %3 3 x5 +1 1 -4 x5 -2 -5 %3 +1 -4 -5 %4`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-1 +3 -4 %2 x4 -5 +5 x5 -5 %3 +1 x4 %2 -1 5 x5 +1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`%2 +1 %5 -5 x2 %2 +1 %2 +1 x4 -5 3 %2 -5 +2 %2 4`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-4 -1 +3 x5 %5 -5 +2 5 x5 %3 +3 5 x5 1 x5 +1 -5 x3 -1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-3 %2 1 -1 -4 x4 x5 x3 +1 -1 %3 +1 +2 +3 -5 +1 +2 +5 x3 5 -4`'
  prefs: []
  type: TYPE_NORMAL
- en: '`+1 x4 -5 +3 -5 %5 %5 %2 -4 +3 5 x5 %5 x4 %2 +1 x4 -5`'
  prefs: []
  type: TYPE_NORMAL
- en: '`3 +2 -5 %3 +1 x5 x2 -3 -4 x4 -1 x1 -3 -1 +5 x1 -3 -1 -2 -5`'
  prefs: []
  type: TYPE_NORMAL
- en: '`%3 +1 x1 x5 %3 x5 1 -1 +2 x5 +1 1 -3 x2 5 %1 x4 x2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`%3 +1 x3 x5 +2 -4 -1 %3 x2 %3 +2 x2 3 %2`'
  prefs: []
  type: TYPE_NORMAL
- en: Nils performed some statistical analyses involving letter frequency, the index
    of coincidence, and other tests. He realized that the cryptogram looked like a
    simple substitution cipher, but all his attempts to break it failed. So, he made
    some educated guesses, such as checking whether the text might have been written
    backward.
  prefs: []
  type: TYPE_NORMAL
- en: 'When he applied the simple-substitution hill climber in CrypTool 2 on the backward-written
    cryptogram, he succeeded immediately, deriving the following gruesome plaintext
    (which contains a number of spelling errors):'
  prefs: []
  type: TYPE_NORMAL
- en: '`I WLSH L HAD SOMTHLN JULCY TO SAY OH OK THE BACKPACK AND CLOTHES WENT IN FOUR
    DIFFERENT DUMPSTERS THAT MONDAY I CAME TO YOUR HOUSE FOR ADVISE I WENT IT I LEFT
    IT OUT IN THE OPEN I DRAGED THE BODY TO WHERE ST WAS FOUND DESTROY THIS AFTER
    DECIFERING IT AND SHUT UP`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to the following substitution table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`A`** | **`B`** | **`C`** | **`D`** | **`E`** | **`F`** | **`G`** | **`H`**
    | **`I`** | **`J`** | **`K`** | **`L`** | **`M`** | **`N`** | **`O`** | **`P`**
    | **`Q`** | **`R`** | **`S`** | **`T`** | **`U`** | **`V`** | **`W`** | **`X`**
    | **`Y`** | **`Z`** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | -2 | -3 | -4 | -5 | %5 | %4 | %3 | %2 | %1 | x1 | x2 | x3 | x4 | x5
    | +5 | +4 | +3 | +2 | +1 | 5 | 4 | 3 | 2 | 1 |  |'
  prefs: []
  type: TYPE_TB
- en: The letters `Q`, `X`, and `Z` don’t appear in the plaintext. While the ciphertext
    equivalents of `Q` and `X` can be easily guessed (`Q`, for instance, lies between
    +5 and +3), the character for `Z` remains unknown.
  prefs: []
  type: TYPE_NORMAL
- en: In court, a CRRU specialist had presented the same result. Along with other
    evidence, it led to Smith being sentenced to death.
  prefs: []
  type: TYPE_NORMAL
- en: Solving a homophonic cipher with simulated annealing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to solving a homophonic cipher, hill climbing and simulated annealing
    are obvious methods to use. After all, a small change in the cipher’s substitution
    table causes only small changes in the ciphertext. Moreover, because a homophonic
    cipher has far more potential keys than we can exhaustively check one by one,
    hill climbing, as well as simulated annealing, provides much more efficient methods
    than brute force. Since most implementations that we know of use simulated annealing
    for this purpose, we will focus on only simulated annealing for the following.
  prefs: []
  type: TYPE_NORMAL
- en: Solving a homophonic cipher with simulated annealing is a relatively new field
    of research, with only a few papers published on the topic to date. One frequently
    cited article, written by Nils Kopal in 2019, offers an introduction to the subject.^([7](b06.xhtml#c16-endnote-7))
    However, various researchers around the world are studying this area and may publish
    the results of their homophonic-simulated-annealing projects in the years ahead.
  prefs: []
  type: TYPE_NORMAL
- en: The best software for homophonic simulated annealing we have found, AZDecrypt,
    was written by Belgian codebreaking expert Jarl Van Eycke (who released version
    1.21 in 2023). AZDecrypt comes with an impressive number of configuration options
    and implements a strong fitness function. It is available for free at [http://www.zodiackillerciphers.com](http://www.zodiackillerciphers.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: Dhavare, Low, and Stamp’s Zodiac Killer solutions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the few research papers about hill-climbing attacks on homophonic ciphers
    that we know of is “Efficient Cryptanalysis of Homophonic Substitution Ciphers,”
    published by Amrapali Dhavare, Richard M. Low, and Mark Stamp in 2013.^([8](b06.xhtml#c16-endnote-8))
    The authors describe a method that involves two hill-climbing steps: the first,
    called *outer hill climbing*, determines the number of homophones each plaintext
    letter maps to; while the second, *inner hill climbing*, reconstructs the substitution
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: Dhavare, Low, and Stamp initially tested their method on Z408, the first message
    written by the Zodiac Killer (see [Chapter 6](c06.xhtml)). Z408 was solved back
    in 1969, and the researchers wanted to see whether their algorithm could repeat
    this deciphering success. In fact, it could, quite easily (see [Figure 16-4](#figure16-4)).
  prefs: []
  type: TYPE_NORMAL
- en: The authors next applied their technique to a homophonic cipher challenge, titled
    Zodiac Cipher, which was available on the crypto-puzzle platform MysteryTwister.^([9](b06.xhtml#c16-endnote-9))
    This challenge mimics Z340, the second Zodiac Killer message, which, unlike Z408,
    hadn’t yet been solved. Again, the hill-climbing program had no trouble solving
    the cryptogram.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502727c16/g16003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-4: Dhavare, Low, and Stamp’s hill climber easily broke the (already-solved)
    first Zodiac Killer message.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Dhavare, Low, and Stamp used their method to attack Z340 itself, which
    was one of the most famous unsolved mysteries in the world. Unfortunately, this
    time, they did not succeed. The details of their efforts can be seen in their
    article. For the trio of solvers that did manage to crack Z340 in 2020, see [Chapter
    6](c06.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Solving a Vigenère cipher with hill climbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As pointed out in [Chapter 8](c08.xhtml), there are many ways to break a Vigenère
    cipher: some that require a computer and others that can be carried out by hand.
    One of the computer-based Vigenère-breaking methods is hill climbing. However,
    hill-climbing attacks on the Vigenère cipher seem to be less popular than on other
    ciphers, probably because there are efficient alternatives. We are not aware of
    a research paper that comprehensively covers Vigenère-cipher hill climbing, but
    at least a few implementations exist, including in CrypTool 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Hill-climbing software can either discover the keyword length as part of the
    hill climbing or determine the information in a different way. Most tools use
    the latter approach. The program either guesses the length of the keyword with
    Friedman’s method before it starts the hill-climbing procedure, or it conducts
    a separate hill-climbing attack for every keyword length between, say, three and
    twenty-five.
  prefs: []
  type: TYPE_NORMAL
- en: These implementations can use the same fitness function as for a simple substitution
    cipher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: Jim Gillogly’s solution to IRA Vigenère cryptograms'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 2001, historian Tom Mahon found around 300 documents containing encrypted
    messages in a Dublin archive. These documents originated from the estate of activist
    Moss Twomey (1897–1978), who was the leader of the IRA from 1926 to 1936\. Most
    of the encrypted texts Mahon found were dispatches exchanged between the IRA headquarters
    in Dublin and IRA activists in the British Isles or the United States. In all,
    the corpus comprised about 1,300 individual cryptograms.
  prefs: []
  type: TYPE_NORMAL
- en: As Mahon lacked the expertise to decipher these messages, he asked the American
    Cryptogram Association for support. Our colleague, ACA member Jim Gillogly, became
    interested, initiating a fruitful partnership between the two researchers. Over
    the next months, Jim managed to decipher almost all the cryptograms Twomey had
    left behind, providing insights into the work and structure of the IRA in the
    1920s. In 2008, Jim and Mahon published their results in a book titled *Decoding
    the IRA*.^([10](b06.xhtml#c16-endnote-10)) The book is an interesting read about
    Irish history, and the first chapter, in which Jim explains his decryptions, is
    a fascinating resource for anyone interested in codebreaking.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turned out, most of the IRA ciphertexts were encrypted using a column-based
    transposition, which is covered in the next section of this chapter. A smaller
    share consisted of short ciphertext passages, which contained strikingly many
    ampersand characters, embedded in cleartext sentences. The following message (dated
    May 4, 1923) is a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502727c16/g16004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s a transcript of the first two sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Have you yet got X&OYC&UIJO&MN? Did you look up that man FX&WA HKGKH/ whom
    I spoke to you about.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The letter frequencies and some other statistics suggested that its author
    had applied a Vigenère cipher. Hoping that the author had used the same key for
    each of these ciphertexts, Jim selected the first six letters of each one. As
    he didn’t know what to do with the ampersand, he ignored all six-letter blocks
    that contained this character. The following twenty-two remained:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SDRDPX VVQDTY WXGKTX SJMCEK LPMOCG MVLLWK HMNMLJ VDBDFX UMDMWO GGCOCS MMNEYJ
    KHAKCQ LPQXLI HMHQLT IJMPWG DDMCEX HVQDSU OISOCX DXNXEO IJLWPS IJNBOO OIREAK`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jim fed this block series into a hill-climbing program of his own design, starting
    with a keyword length of six. Although the twenty-two blocks came from different
    ciphertexts, characteristics reflected by the fitness function remained valid.
    In fact, the hill climber found a six-letter keyword candidate that produced promising
    results right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MISTER PARTIS QCHAIR MONSTE FUNERA FAMBLE BROCAD PICTUR ORECLI ALDERM GROUND
    EMBARK FURNAC BRIGAN CONFLA XINSTR BARTHO INTERR XCONTI COMMEM COORDI INSUPE`'
  prefs: []
  type: TYPE_NORMAL
- en: As every six-letter block represented a plausible English letter sequence, Jim
    knew that he was on the right track.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hill climber had delivered the keyword `GVZKLG`. Jim used it to decrypt
    all the Vigenère messages and learned that the ampersand served as a replacement
    for the letter `Z`, which is why no `Z` appears in the ciphertexts. The message
    shown above decrypted to the following plaintext (the `Z` and `X` in `Z XCAMPBELLZ`
    were used for padding):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Have you yet got REPORT ON KEOGH? Did you look up that man ZCAMPBELLX whom
    I spoke to you about.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why did the IRA use the keyword `GVZKLG`? After some experimentation, Jim found
    that it was the word `TEAPOT` encrypted with a simple substitution cipher, based
    on the following substitution table:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Plaintext:` `ABCDEFGHIJKLMNOPQRSTUVWXYZ`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ciphertext: ZYXWVUTSRQPONMLKJIHGFEDCBA`'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the substitution used an easy-to-remember backward alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: Solving a columnar transposition with hill climbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use hill climbing to solve both complete and incomplete columnar transposition
    ciphers, which are described in Chapters [9](c09.xhtml) and [10](c10.xhtml). However,
    the fitness function employed to break a simple substitution cipher doesn’t work
    here. In general, we can’t break a transposition with any fitness function that
    is based on the frequency of letters, because transposing letters doesn’t change
    their frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can rely on the frequency of letter groups to rate the correctness
    of a plaintext candidate. We have encountered anything from letter pairs (digraphs)
    to groups of eight letters (octagraphs) used in this context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a way to change the transposition cipher’s key slightly. If we
    are dealing with a columnar transposition of, say, ten columns, we can write the
    key like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`8,4,5,2,9,7,1,10,3,6.`'
  prefs: []
  type: TYPE_NORMAL
- en: To make a small change in the key, we might switch two randomly chosen numbers
    in this sequence. For instance, `8,4,5,2,9,7,1,10,3,6` might become `8,4,1,2,9,7,5,10,3,6`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the keyword used to encrypt a columnar transposition ciphertext doesn’t
    play a role in this process. Hill climbing works even if the keyword is a random
    string, like `VKWJIDPQFH`, and delivers the plaintext without re-creating the
    original keyword. In fact, determining the keyword is often impossible, as there
    might be several equivalent ones.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking an incomplete columnar transposition is, of course, more complex than
    solving a complete one. Still, we can think of the process as merely a special
    case of solving complete columnar transpositions. Because a computer usually does
    this task using a hill-climbing program, the complexity is generally not a problem,
    but the task may take longer.
  prefs: []
  type: TYPE_NORMAL
- en: If we do not know the length of the keyword (as is usually the case in practice),
    we have two possible approaches. First, we can make the keyword length a part
    of the key and change it slightly between hill-climbing rounds; however, this
    adds to the complexity of the program. The better approach is usually to perform
    several hill-climbing attacks for different keyword lengths. If we assume that
    the keyword has a length of between five and twenty letters, then we need sixteen
    tries—not much of a problem for today’s computers.
  prefs: []
  type: TYPE_NORMAL
- en: The software CrypTool 2 includes a powerful transposition hill climber. Bernhard
    Esslinger, the head of the CrypTool project, has demonstrated that this hill climber
    (even running on a PC) can easily break some of the IRA transposition cryptograms
    introduced in [Chapter 10](c10.xhtml) within two minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: Jim Gillogly’s solution to IRA transposition cryptograms'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s return to that 2008 book *Decoding the IRA* by Jim Gillogly and Tom Mahon.
    The following IRA cryptogram is one of six messages that Mahon, the historian,
    initially sent to the American Cryptogram Association in 2005\. It was subsequently
    shared on the association’s mailing list and then solved by Jim:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AEOOA IIIEO AEAEW LFRRD ELBAP RAEEA EIIIE AAAHO IFMFN COUMA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`FSOSG NEGHS YPITT WUSYA ORDOO ERHNQ EEEVR TTRDI SOSDR ISIEE ISUTI`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ERRAS TTKAH LFSUG RDLKP UEYDM ERNEO RULDC ERWTE ICNIA T`'
  prefs: []
  type: TYPE_NORMAL
- en: This cryptogram consists of 151 letters. When analyzing the ciphertext, Jim
    saw that `E` was by far the most common letter, with twenty-three appearances,
    followed by `A`, `R`, and `I`. The letters `Q`, `B`, and `V` turned out to be
    very rare. These frequencies are consistent with the English language, although
    the ratio of vowels (47%) seemed a little high (40% is typical). Jim assumed that
    he was dealing with a transposition cipher. As 151 is a prime number, it could
    not be a complete columnar transposition, but an incomplete one seemed possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In his forty years as a codebreaker, Jim had written a considerable amount
    of cryptanalysis software for his personal use. Among other things, he was one
    of the first to use hill climbing for cryptanalysis. To solve this particular
    encryption, he used a hill-climbing program tailored to breaking an incomplete
    columnar transposition, assuming a line length of between eight and fifteen and
    starting separate runs for each length. When he tried a length of twelve, he received
    the following plaintext candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: '`THEAADDARESSTOWHECIEHYOUWILLOESENDSTUFFFOR . . .`'
  prefs: []
  type: TYPE_NORMAL
- en: This string, as you can tell, contains many words that make sense. It is even
    possible to read a meaningful sentence from it (`THE ADDRESS TO WHICH YOU WILL
    SEND STUFF . . .`). However, quite a few letters seem unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jim restarted his hill-climbing program about a hundred times, with a different
    initial keyword candidate on each occasion, but he didn’t get a better result.
    His software had determined that the keyword was `FDBJALHCGKEI`—certainly not
    the original one used by the IRA, but equivalent. For further analysis, he looked
    at the transposition table his program had created:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FDBJALHCGKEI`'
  prefs: []
  type: TYPE_NORMAL
- en: '`------------`'
  prefs: []
  type: TYPE_NORMAL
- en: '`THEAADDARESS`'
  prefs: []
  type: TYPE_NORMAL
- en: '`TOWHECIEHYOU`'
  prefs: []
  type: TYPE_NORMAL
- en: '`WILLOESENDST`'
  prefs: []
  type: TYPE_NORMAL
- en: '`UFFFOROAQMGI`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SMRSAWSEEENE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`YFRUITDIERER`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ANDGIERIENGR`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OCERIIFIVEHA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ROLDECSEROSS`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DUBLONIATRYT`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OMAKAIEATUET`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OAPPEAEARLLK`'
  prefs: []
  type: TYPE_NORMAL
- en: '`EFRHATI`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jim immediately recognized why his software had delivered strange results.
    The encipherer had inserted two columns (the fifth and eighth) of meaningless
    vowels into the table. In addition, his hill-climbing program had switched the
    `L` and `H` columns. Here is the correct table (with the extra vowels omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '`FDBJAHLCGKEI`'
  prefs: []
  type: TYPE_NORMAL
- en: '`------------`'
  prefs: []
  type: TYPE_NORMAL
- en: '`THEA DD RESS`'
  prefs: []
  type: TYPE_NORMAL
- en: '`TOWH IC HYOU`'
  prefs: []
  type: TYPE_NORMAL
- en: '`WILL SE NDST`'
  prefs: []
  type: TYPE_NORMAL
- en: '`UFFF OR QMGI`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SMRS SW EENE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`YFRU DT ERER`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ANDG RE ENGR`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OCER FI VEHA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ROLD SC ROSS`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DUBL IN TRYT`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OMAK EI TUET`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OAPP EA RLLK`'
  prefs: []
  type: TYPE_NORMAL
- en: '`EFRH IT`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct plaintext reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`THE ADDRESS TO WHICH YOU WILL SEND STUFF FOR QMG IS MRS SWEENEY FRUDTERER
    AND GREENGROCER FIVE HAROLD’S CROSS DUBLIN TRY TO MAKE IT UP TO APPEAR LIKE FRUIT.`'
  prefs: []
  type: TYPE_NORMAL
- en: The actual keyword used by the IRA has never been determined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: Richard Bean’s solution to the last unsolved IRA cryptogram'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As described in the previous section, Jim Gillogly solved hundreds of transposition
    cryptograms left behind by IRA activist Moss Twomey, but there was one he couldn’t
    break:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GTHOO RCSNM EOTDE TAEDI NRAHE EBFNS INSGD AILLA YTTSE AOITDE`'
  prefs: []
  type: TYPE_NORMAL
- en: In the Twomey files, every encrypted message has a header that indicates its
    length. In this case, the number of letters is specified to be fifty-two, though
    the ciphertext consists of only fifty-one characters. It was clear that something
    had gone wrong; perhaps this was the reason Jim had not succeeded in breaking
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: In 2018, our colleague Richard Bean, a mathematician from Brisbane, Australia,
    specializing in combinatorics and statistics, became interested in this cryptogram
    after reading Jim Gillogly and Tom Mahon’s book.^([11](b06.xhtml#c16-endnote-11))
    He tried to solve it with hill climbing, checking different keyword lengths and
    iteratively improving his fitness function. Drawing from George Lasry’s PhD thesis,^([12](b06.xhtml#c16-endnote-12))
    he realized that hexagraph frequencies would prove especially helpful for distinguishing
    meaningful text from gibberish. He also noticed that a keyword length of eleven
    produced the best hill-climbing scores. When adding letters to all different parts
    of the ciphertext, he received the most meaningful results by inserting a character
    between the two `E`s (letters twenty-five and twenty-six).
  prefs: []
  type: TYPE_NORMAL
- en: 'Richard also observed that, in some of the best-scoring ciphertext candidates,
    the string `LIGNIT` appeared. As the IRA used gelignite (an explosive) in the
    1920s, this discovery provided a potential crib. When Richard forced the string
    `GELIGNIT` into the hill-climbing output, many other meaningful words became visible,
    such as `THEYRAID` and `ANDOBTAINED`. The additional letter ended up in the string
    `SCOT*AND`, so he could easily identify it as an `L`. Finally, Richard detected
    the following plaintext:'
  prefs: []
  type: TYPE_NORMAL
- en: '`REGELIGNITSCOTLANDSTAESTHEYRAIDEANDOBTAINEDOMEOFTHLS`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the message in a more readable form: `RE GELIGNIT[E] SCOTLAND STA[T]ES
    THEY RAIDE[D] AND OBTAINED [S]OME OF THLS`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that four letters in the plaintext (`E`, `T`, `D`, and `S`) are missing
    and that there’s a typo in the last word. Along with the missing ciphertext letter
    `L`, these mistakes made it extremely difficult to break the message. After some
    more analysis, Richard found that he could obtain a better result if he assumed
    a twelve-letter keyword and an additional column in the transposition table containing
    the letters `E`, `T`, `D`, and `S` (four of the missing plaintext letters). Because
    the original location of this additional column isn’t known, it is very difficult
    to determine the keyword used. As we will show, `BCAFIEHGKDLJ` works, though this
    is certainly not the keyword used by the IRA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this information, we can reconstruct the process by which the message
    was encrypted. We start with the plaintext, including the letters `E`, `T`, `D`,
    `S`, and `L` (which were lost at a later point in time) and keeping the typo in
    the last word:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RE GELIGNITE SCOTLAND STATES THEY RAIDED AND OBTAINED SOME OF THLS`'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we write this text below the keyword. (Note that the letters `E`, `T`,
    `D`, and `S` appear in the next-to-last column.)
  prefs: []
  type: TYPE_NORMAL
- en: '`BCAFIEHGKDLJ`'
  prefs: []
  type: TYPE_NORMAL
- en: '`------------`'
  prefs: []
  type: TYPE_NORMAL
- en: '`REGELIGNITES`'
  prefs: []
  type: TYPE_NORMAL
- en: '`COTLANDSTATE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`STHEYRAIDEDA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NDOBTAINEDSO`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MEOFTHLS`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we transpose the columns such that the keyword letters are in alphabetical
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ABCDEFGHIJKL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`------------`'
  prefs: []
  type: TYPE_NORMAL
- en: '`GRETIENGLSIE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`TCOANLSDAETT`'
  prefs: []
  type: TYPE_NORMAL
- en: '`HSTEREIAYADD`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ONDDABNITOES`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OME HFSLT`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading out the text column-wise, we receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GTHOO RCSNM EOTDE TAEDI NRAHE LEBFN SINSG DAILL AYTTS EAOIT DEETDS`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This message consists of fifty-six letters. Somehow, the final five characters
    were later lost (the `ETDS` at the end and the `L` in `LEBEN`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`GTHOO RCSNM EOTDE TAEDI NRAHE LEBFN SINSG DAILL AYTTS EAOIT DEETDS`'
  prefs: []
  type: TYPE_NORMAL
- en: In August 2019, Richard Bean informed Klaus and Jim of this solution he had
    found. Jim was able to verify it, confirming that it was correct. Over a decade
    after his initial success, the last of Twomey’s messages had finally been deciphered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: George Lasry’s solution of the double columnar transposition
    challenge'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1999, Otto Leiberich, the former president of the German crypto authority
    *Zentralstelle für das Chiffrierwesen* *(ZfCh)*, or the Central Authority for
    Cipher Affairs, published an article in the German science journal *Spektrum der
    Wissenschaft*.^([13](b06.xhtml#c16-endnote-13)) In this article, Leiberich discussed
    double columnar transposition (see Chapter 10), which East German agents had used
    during the Cold War.
  prefs: []
  type: TYPE_NORMAL
- en: 'Double columnar transposition is one of the best manual ciphers known. Leiberich
    and his team worked intensively on the cryptanalysis of this method, and in 1974,
    one of their results led to the unmasking of a top spy: Günter Guillaume, the
    personal secretary of the West German Chancellor, Willy Brandt. Guillaume had
    been feeding information to the East Germans. He was arrested, tried, and sentenced
    to prison but freed in 1981 as part of a prisoner exchange.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In his 1999 article, published long after the end of the Cold War, Leiberich
    encouraged researchers to study double columnar transposition further, for the
    technique’s historical value. He also suggested that a challenge cryptogram be
    created with this cipher. His recommendations for this challenge included the
    following items:'
  prefs: []
  type: TYPE_NORMAL
- en: Both keywords should have twenty to twenty-five characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lengths of the two keywords should have no common divisor except one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of the ciphertext should not be a multiple of the length of either
    keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ciphertext should have approximately five hundred characters (roughly the
    product of the lengths of the two keywords).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leiberich never published a challenge of this kind himself, so Klaus decided
    to do so because he was always interested in challenging his readers. He chose
    a few paragraphs from the 1910 novel *Mistress Wilding* by Rafael Sabatini and
    encrypted them using two keywords consisting of English phrases with twenty to
    twenty-five letters.^([14](b06.xhtml#c16-endnote-14)) The length of the plaintext
    was 599\. Klaus published this challenge ciphertext in 2007 in an online article:^([15](b06.xhtml#c16-endnote-15))
  prefs: []
  type: TYPE_NORMAL
- en: '`VESINTNVONMWSFEWNOEALWRNRNCFITEEICRHCODEE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`AHEACAEOHMYTONTDFIFMDANGTDRVAONRRTORMTDHE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OUALTHNFHHWHLESLIIAOETOUTOSCDNRITYEELSOAN`'
  prefs: []
  type: TYPE_NORMAL
- en: '`GPVSHLRMUGTNUITASETNENASNNANRTTRHGUODAAAR`'
  prefs: []
  type: TYPE_NORMAL
- en: '`AOEGHEESAODWIDEHUNNTFMUSISCDLEDTRNARTMOOI`'
  prefs: []
  type: TYPE_NORMAL
- en: '`REEYEIMINFELORWETDANEUTHEEEENENTHEOOEAUEA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`EAHUHICNCGDTUROUTNAEYLOEINRDHEENMEIAHREED`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OLNNIRARPNVEAHEOAATGEFITWMYSOTHTHAANIUPTA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DLRSRSDNOTGEOSRLAAAURPEETARMFEHIREAQEEOIL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SEHERAHAOTNTRDEDRSDOOEGAEFPUOBENADRNLEIAF`'
  prefs: []
  type: TYPE_NORMAL
- en: '`RHSASHSNAMRLTUNNTPHIOERNESRHAMHIGTAETOHSE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NGFTRUANIPARTAORSIHOOAEUTRMERETIDALSDIRUA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`IEFHRHADRESEDNDOIONITDRSTIEIRHARARRSETOIH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OKETHRSRUAODTSCTTAFSTHCAHTSYAOLONDNDWORIW`'
  prefs: []
  type: TYPE_NORMAL
- en: '`HLENTHHMHTLCVROSTXVDRESDR`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Neither Klaus nor Leiberich expected that this cryptogram could be broken;
    however, six years later, in 2013, Klaus received an email from our colleague,
    the then-unknown Israeli George Lasry, who claimed to have solved the double columnar
    transposition challenge. His solution proved correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '`THEGIRLHADARRIVEDATLUPTONHOUSEAHALFHOURAH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`EADOFMISSWESTMACOTTANDUPONHERARRIVALSHEHA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DEXPRESSEDSURPRISEEITHERFEIGNEDORREALATFI`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NDINGRUTHSTILLABSENTDETECTINGTHEALARMTHAT`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DIANAWASCAREFULTOTHROWINTOHERVOICEANDMANN`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ERHERMOTHERQUESTIONEDHERANDELICITEDTHESTO`'
  prefs: []
  type: TYPE_NORMAL
- en: '`RYOFHERFAINTNESSANDOFRUTHSHAVINGRIDDENONA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`LONETOMRWILDINGSSOOUTRAGEDWASLADYHORTONTH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ATFORONCEINAWAYTHISWOMANUSUALLYSOMEEKANDE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ASELOVINGWASROUSEDTOANENERGYANDANGERWITHH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ERDAUGHTERANDHERNIECETHATTHREATENEDTOREMO`'
  prefs: []
  type: TYPE_NORMAL
- en: '`VEDIANAATONCEFROMTHEPERNICIOUSATMOSPHEREO`'
  prefs: []
  type: TYPE_NORMAL
- en: '`FLUPTONHOUSEANDCARRYHERHOMETOTAUNTONRUTHF`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OUNDHERSTILLATHERREMONSTRANCESARRIVEDINDE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`EDINTIMEFORHERSHAREOFTHEM`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, George had found two different methods for breaking the challenge.
    In the first, a dictionary attack, his computer program had guessed the two keywords:
    `PREPONDERANCEOFEVIDENCE` and `TOSTAYYOUFROMELECTION`. His second method was based
    on hill climbing. Later, Jim came up with a third method: using a computer program,
    he checked all nineteenth-century texts available online and identified the one
    Klaus had chosen.'
  prefs: []
  type: TYPE_NORMAL
- en: Readers interested in this ingenious act of cryptanalysis are advised to read
    George’s 2014 publication in *Cryptologia* (co-written with Arno Wacker and Nils
    Kopal).^([16](b06.xhtml#c16-endnote-16)) If you are interested in an even more
    difficult cryptogram of this type, see the “Double Columnar Transposition Reloaded
    Challenge” in the “Challenges” section of [Chapter 10](c10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Solving a turning grille cipher with hill climbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hill climbing has proven to be a very powerful method of breaking turning grille
    cryptograms. As we will show, we can solve even large turning grilles, consisting
    of 20 × 20 squares or more, with this technique. This is because we can easily
    construct a turning grille of size 2*n* × 2*n* with an *n* × *n* matrix, as described
    in [Chapter 11](c11.xhtml). As an example, the following diagram shows how a 3
    × 3 matrix can become a 6 × 6 grille:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502727c16/g16005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In a computer program, the number sequence in the 3 × 3 matrix (`2,4,1,1,4,3,3,2,2`)
    can represent the grille, which serves as this encryption method’s key. Next,
    we need a way to change the grille slightly. We can do this, for instance, by
    adding 2 to one of the numbers representing the grille, as in the following example.
    If the result were greater than 4, we would subtract 4 from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Old key: 2,4,1,1,4,3,3,2,2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`New key: 2,4,3,1,4,3,3,2,2`'
  prefs: []
  type: TYPE_NORMAL
- en: For a turning grille hill climber, we also need to modify the kind of fitness
    function that we employ to rate the correctness of a plaintext candidate. We can’t
    base it on the frequency of letters, as this kind of encryption doesn’t change
    a plaintext’s letter frequencies. (No transposition cipher does.) Instead, we
    might create a fitness function based on the frequencies of digraphs, trigraphs,
    or other *n*-graphs.
  prefs: []
  type: TYPE_NORMAL
- en: The computer program JCrypTool offers a turning grille solver based on hill
    climbing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: Bart Wenmeckers’s solution to a turning grille cryptogram'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 11](c11.xhtml), we mentioned that the Italian crypto-history expert
    Paolo Bonavoglia recently found a turning grille cryptogram in a notebook belonging
    to his famous grandfather, Luigi Sacco (1883–1970).^([17](b06.xhtml#c16-endnote-17))
    After solving the cryptogram himself, Paolo also published it as a challenge in
    the “Cryptograms & Classical Ciphers” Facebook group. Our colleague Bart Wenmeckers,
    the host of the group, took up the challenge.^([18](b06.xhtml#c16-endnote-18))
  prefs: []
  type: TYPE_NORMAL
- en: 'Like many other specialists in breaking classical ciphers, Bart makes frequent
    use of hill climbing, employing a modified program that he wrote himself. The
    program returns the grille written in a line, with the letter `C` representing
    a hole and `D` representing no hole. It also returns the result of its fitness
    function (the higher, the better) and the plaintext candidate produced each time
    that result increases. Here’s the final part of the log of Bart’s hill-climbing
    attack on Sacco’s turning grille cryptogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DDCCCDCDDDDDDDDCDDCDDDDDDCDDDDDDDDDCDDCCCCDDDDDDD, 323`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOSPDSEHERSEEUCHNGENDWITRSTWRKECYHEIESULLIUNTEXE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DDCCCDCDDDDDDDDCDDCDDDDDDCDDDDDDDDDCCDCCDCDDDDDDD, 329`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOSPDSEHWEREESUCHNGENDITRTWURKECYHEIESLLIUNTEXSE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DDCCCDCDDDDDDDDDDDCDDDDDDCDDDDDDDCDCCDCCDCDDDDDDD, 334`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOSPSECHWEREESCHNGENDXITRTWURDKEYHEIESULLIUNTESE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DDCCCDDDDDDDDDDDDDCDDDDDDCDDDDDDDCDCCDCCDCCDDDDDD, 344`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOSSECHWEREYEESCHNGENDXIPRTWURDKEHEISULLIUNTESET`'
  prefs: []
  type: TYPE_NORMAL
- en: '`CDCCCDDDDDDDDDDDDDCDDDDDDCDDDDDDDCDCCDCCDCDDDDDDD, 362`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ENOSSECHWEREEPSCHNGENDXIRTWURDKEHEITSULLIUNTESYE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`CDCCCDDDDDDDDDDDDCCDDDDDDDDDDDDDDCDCCDCCDCDDDDDDD, 385`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ENOSISCHWEREEPSCHENGNDXIRTWURDEEHEITSULLUNKTESYE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DDCCCDDDDDDDDDDDDCCDDDDDDDDDDDDDDCDCCDCCDCDDDDDDC, 402`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOSISCHWERETESCHENGNDXYIERTWURDEEHEISPULLUNKTESE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DDCCDDDDDDDDDDCDCCDDDDDDDDDDDDDDDCDCCDCCDCDDDDDDC, 410`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOLLICHWERETESSSCHENGXYIERTWURDENDEISPUUNKTEESHE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DDDDDCDDDCCDCCDCDDDDDDDDDDDDDDDCCDCDDDDDDDDDDCCDC, 416`'
  prefs: []
  type: TYPE_NORMAL
- en: '`STWURDENDEITUUNKTEESEYHEENOLLICHWERIESPRSSCHENGX`'
  prefs: []
  type: TYPE_NORMAL
- en: '`CDDDDCDDDCCDCCDCDDDDDDDDDDDDDDDCCDCDDDDDDDDDDCCDD, 424`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ESTWURDENDEIPUUNKTEESEHENOLLICHWERITESRSSCHENGXY`'
  prefs: []
  type: TYPE_NORMAL
- en: '`CDDDDCDDDCCDCCDCDDDDDDDDDDDDDDDCCDDDDDDDDDDDCCCDD, 425`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ESTWURDENHEIPULUNKTEESEENOSLICHWERITERSSCHENGDXY`'
  prefs: []
  type: TYPE_NORMAL
- en: '`CDDDDCDDDCCDCCDCDDDDDDDDDDDDDDCCDDDDDDDDDDDDCCCDD, 428`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ESTWURDEEHEIPULLUNKTESEENOSISCHWERITERSCHENGNDXY`'
  prefs: []
  type: TYPE_NORMAL
- en: '`CDDDDCDDDDCDCCDCDDDDDDDDDDDDDDDCCDCDDDDCDDDDDCCDD, 442`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ESWURDENDREIPUNKTEGESEHENOTLLICHWEITESRSSUCHENXY`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know German (the language of the original message), you’ll see words
    show up immediately. Here’s the plaintext (the mistakes were present in the original):
    `ES WURDEN DREI PUNKTE GESEHEN OTLLICH WEITESRSSUCHEN XY`.'
  prefs: []
  type: TYPE_NORMAL
- en: It translates to `THREE POINTS HAVE BEEN SEEN. KEEP ON SEARCHING IN THE EAST
    XY.` The `X` and `Y` at the end of the message are almost certainly padding that
    was added to ensure a plaintext of exactly forty-eight letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: Armin Krauss’s solution to a turning grille challenge'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Can a 20 × 20 turning grille cryptogram be broken with hill climbing? Because
    Klaus had never found an answer to this question in the literature, he decided
    to create a challenge for his blog readers that tested the idea. He took an English
    text consisting of 400 letters, encrypted it with a 20 × 20 turning grille, and
    published the ciphertext on his blog in 2017:^([19](b06.xhtml#c16-endnote-19))
  prefs: []
  type: TYPE_NORMAL
- en: '`ENPAIGEZLANEDMTHSENF`'
  prefs: []
  type: TYPE_NORMAL
- en: '`EIORDEMATANNATMOOFSL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`AEPLMHOIERITOECDMVNE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OXNPBROEDOIETRANEEIU`'
  prefs: []
  type: TYPE_NORMAL
- en: '`XPNPONRNTAREOMMYDWIT`'
  prefs: []
  type: TYPE_NORMAL
- en: '`IANHTNEIOODNSOUOTETD`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MOOVEARPHRIOLAEGNALN`'
  prefs: []
  type: TYPE_NORMAL
- en: '`INATTFINOREATDNGWDDA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`UHSIEURININGTTEDASTN`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ATGHPEESAOMEISEADRMM`'
  prefs: []
  type: TYPE_NORMAL
- en: '`YANTSOEJOESYTERTHACH`'
  prefs: []
  type: TYPE_NORMAL
- en: '`BNINCALURDCHLEALLHLA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OIFWESTEHENGREERRTHE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SAAMSIBEIOVNSAINARLI`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DTESGIIETTUCNARILYLO`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ESENRUUISINEADSRANLA`'
  prefs: []
  type: TYPE_NORMAL
- en: '`COUWNEAUETCPOHRNSDTW`'
  prefs: []
  type: TYPE_NORMAL
- en: '`BYEOFNINGHERHIVNTOTE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MNTBERAEHEUNSPNSUTIX`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NPOITYPFIKSAVULEATRA`'
  prefs: []
  type: TYPE_NORMAL
- en: Three days after Klaus’s publication, our colleague Armin Krauss posted the
    solution:^([20](b06.xhtml#c16-endnote-20))
  prefs: []
  type: TYPE_NORMAL
- en: '`PLANS FOR MANNED MOON EXPEDITIONS ORIGINATED DURING THE EISENHOWER ERA IN
    AN ARTICLE SERIES WERNHER VON BRAUN POPULARIZED THE IDEA OF A MOON EXPEDITION
    A MANNED MOON LANDING POSED MANY TECHNICAL CHALLENGES BESIDES GUIDANCE AND WEIGHT
    MANAGEMENT ATMOSPHERIC REENTRY WITHOUT OVERHEATING WAS A MAJOR HURDLE AFTER THE
    SOVIET UNIONS LAUNCH OF THE SPUTNIK SATELLITE VON BRAUN PROMOTED A PLAN FOR THE
    UNITED STATES ARMY TO ESTABLISH A MILITARY LUNAR OUTPOST BY NINETEEN SIXTY FIVE`'
  prefs: []
  type: TYPE_NORMAL
- en: Armin had used a hill-climbing and simulated-annealing program of his own design
    to break this cryptogram. The fitness function he applied was based on trigraph
    frequencies. In addition, Armin used a sequence of numbers between one and four
    to represent a grille, as explained in the introduction to this section. In each
    round, he changed one of the numbers at random.
  prefs: []
  type: TYPE_NORMAL
- en: Because the original ciphertext contained a mistake, Armin had to perform some
    additional manual codebreaking. After he learned via Google that Klaus’s plaintext
    was derived from a Wikipedia article, he managed to solve the challenge in spite
    of the error.
  prefs: []
  type: TYPE_NORMAL
- en: Solving a general digraph substitution with hill climbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hill climbing is a perfect approach to solving general digraph substitutions.
    This technique resembles the breaking of simple substitution ciphers; we can even
    use a comparable fitness function, based on letter or *n*-graph frequencies, to
    check whether a plaintext candidate looks like real language. However, we need
    a larger substitution table (one with 676 columns, in the case of a twenty-six-letter
    alphabet) and a larger ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: Some digraph challenges'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because researchers have published little in the field of general digraph substitution,
    Klaus decided to challenge his blog readers with digraph cryptograms. This led
    to a series of notable codebreaking records:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In February 2017, on his blog, Klaus published two digraph challenges: “Bigram
    5000” and “Bigram 2500.”^([21](b06.xhtml#c16-endnote-21)) *Bigram* is another
    word for *digraph*, while 2,500 and 5,000 were the number of letters contained
    in the challenge ciphertexts. Within three days, German codebreaker Norbert Biermann,
    supported by Armin Krauß, found both plaintexts with a hill-climbing program of
    Norbert’s own design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two years later, in July 2019, Klaus created a new and even shorter challenge.
    This time, the ciphertext consisted of only 1,346 letters: the “Bigram 1346.”^([22](b06.xhtml#c16-endnote-22))
    Four weeks later, Biermann once again broke this challenge, setting a new record.^([23](b06.xhtml#c16-endnote-23))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A few months later, in October 2019, Klaus challenged his readers yet again
    with an even shorter ciphertext of the same kind, consisting of exactly 1,000
    letters.^([24](b06.xhtml#c16-endnote-24)) Again, the cryptogram was broken quickly,
    setting another record. This time, the solution came from two blog readers: Jarl
    Van Eycke of Belgium and Louie Helm of Switzerland, who worked together.^([25](b06.xhtml#c16-endnote-25))
    They solved the challenge with a highly sophisticated hill-climbing program that
    included a fitness function based on octagraph frequencies. Given that a twenty-six-letter
    alphabet can generate approximately 200 billion eight-letter blocks, the codebreakers
    needed huge amounts of text to generate useful reference statistics. They used
    about two terabytes of English text taken from a database they created from millions
    of books, all of Wikipedia, seven billion words extracted from Usenet posts, and
    more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two months later, in December 2019, Klaus published an even shorter challenge,
    consisting of only 750 letters: “Bigram 750.”^([26](b06.xhtml#c16-endnote-26))
    Again, Van Eycke and Helm solved it within two days.^([27](b06.xhtml#c16-endnote-27))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After Van Eycke and Helm’s success, Klaus published the “Bigram 600” challenge
    in March 2020 (see [Chapter 12](c12.xhtml)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of this writing, the “Bigram 750” ciphertext remains the shortest general
    digraph cryptogram ever solved.
  prefs: []
  type: TYPE_NORMAL
- en: Solving a Playfair cipher with hill climbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hill climbing has proven very efficient for breaking Playfair cryptograms. It
    works much better than the manual codebreaking technique we introduced in Chapter
    12. It is also superior to a dictionary attack, as it doesn’t require the codebreaker
    to derive the Playfair matrix from a guessable keyword.
  prefs: []
  type: TYPE_NORMAL
- en: To introduce a small change in the Playfair matrix, all we need to do is switch
    the positions of two letters. Defining a fitness function is also straightforward,
    because we can rely on letter frequencies to judge whether a plaintext candidate
    looks like real language. Using the frequencies of other *n*-graphs (ranging from
    digraphs to octagraphs) can be even more helpful for deducing the final plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: How quickly could a computer handle this task? The software CrypTool 2 features
    a powerful Playfair hill climber, named Playfair Analyzer, which includes a fitness
    function based on hexagraph frequencies. Esslinger, the head of the CrypTool project,
    showed us how this component performed on a Playfair cryptogram from Dorothy L.
    Sayers’s 1932 novel *Have His Carcase*. In [Chapter 12](c12.xhtml), we dedicated
    multiple pages to describing how difficult this same cryptogram is to break without
    computer support. [Figure 16-5](#figure16-5) shows how Playfair Analyzer works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502727c16/f16004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-5: The software CrypTool 2, running on a PC, breaks the Playfair
    cryptogram from Dorothy L. Sayers’s novel *Have His Carcase* within a minute.'
  prefs: []
  type: TYPE_NORMAL
- en: After the user has copied the ciphertext into the left window and started the
    hill climber, the software displays every climbing step in the middle window.
    CrypTool 2 needs about a minute to produce both the cryptogram’s key and the plaintext.
    Even an experienced codebreaker would require hours to perform this task without
    computer support.
  prefs: []
  type: TYPE_NORMAL
- en: 'The software displays the following correct Playfair matrix, written on one
    line, in the lower-right window. It uses the keyword `MONARCHY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MONAR|CHYBD|EFGIK|LPQST|UVWXZ`'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the plaintext in the upper-right window or reproduced in [Chapter
    12](c12.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: Dan Girard’s solution to the Cheltenham Letter Stone'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In 2005, British artist Gordon Young created the *Listening Stones* in Cheltenham,
    United Kingdom (see [Chapter 4](c04.xhtml)). Two of these ten-foot-tall stones,
    called the Number Stone and the Letter Stone, bear encrypted inscriptions. Here
    is the message on the Letter Stone, as provided to us by the sculptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EC KH LO PT OA DL LU AB KW LO YS NA EC BF MZ FA LC NQ XR UT DK`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SQ KH EC ZK NL CK SQ CB SA SA QU LF MZ IV FA LC OA VB OK CK AV`'
  prefs: []
  type: TYPE_NORMAL
- en: '`DY SY LO WL KL NI BH BX LO MY VA EK AP LB CW PY OA OK MO AV BL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`VM PK LC UP BY KQ MK BN AN BF GA YM LO AK NI BP PI HT TI NT CV`'
  prefs: []
  type: TYPE_NORMAL
- en: '`EC FI LW CQ GL TI KL NI BH RP GZ SU LQ AS YT GA VB FW NM XC UP`'
  prefs: []
  type: TYPE_NORMAL
- en: '`EB NA WL ID PM ZK LM WL RO VI AO LC IC VI KQ FW OA PA XC UP EQ`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SO PM QU MB PU CL VA KI OM NE LM BF UP IG BC FR LO CV KI OM VT`'
  prefs: []
  type: TYPE_NORMAL
- en: '`BF YF IP EQ CQ SX NK MZ CQ YS GZ BF UI XD SQ QK AG KL SQ YF PM`'
  prefs: []
  type: TYPE_NORMAL
- en: '`RF TV KE CW LW ME VA KN UP FA UI FI KM NQ XR AV TR LO CV EL NL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`LQ FY UP PN NK IG NO BN EC NP BF GA NE HM IV FY DQ LM YF DQ AM`'
  prefs: []
  type: TYPE_NORMAL
- en: '`BP NI KF LU BN RY UK NA KI OM WF SO OK KQ OA BL KL QA BL VK CK`'
  prefs: []
  type: TYPE_NORMAL
- en: '`HL MP TO AG QT PI HL TI NT CV EC IA SL LM YF RL HT IP PS CW CW`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-6](#figure16-6) shows the sculpture. When Klaus learned about this
    cryptogram in 2015, it was still unsolved. According to the sculptor, the digraphs
    on the stone were a message encrypted using a Playfair cipher. However, he didn’t
    remember the details of the encryption, let alone the key.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502727c16/f16005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-6: The Letter Stone, a sculpture located next to the GCHQ Headquarters
    in Cheltenham, UK, bears a Playfair-encrypted inscription, arrows, and letter
    pairs within each of the circles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Klaus published an article about this cryptogram on his blog in September 2015.^([28](b06.xhtml#c16-endnote-28))
    After only a few hours, blog reader Dan Girard posted the solution, having broken
    it with his own hill-climbing program. It turned out that the keyword was `LECKHAMPTON`.
    Here’s the beginning of the plaintext:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LECKHAMPTON CHIMNEY HAS FALLEN DOWN`'
  prefs: []
  type: TYPE_NORMAL
- en: '`THE BIRDS OF CRICKLEY HAVE CRIED IT IT IS KNOWN IN THE TOWN`'
  prefs: []
  type: TYPE_NORMAL
- en: '`THE CLIFXFS HAVE CHANGED WHAT WILL COME NEXT XTO THAT LINE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`WATCHER OF WEST ENGLAND NOW THAT LANDMARK OAS FALXLEN . . .`'
  prefs: []
  type: TYPE_NORMAL
- en: Devil’s Chimney is a rock formation at Leckhampton Hill, near Cheltenham.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: Playfair world records'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 12](c12.xhtml), we mentioned that in 1936, the American cryptanalyst
    Alf Monge broke a thirty-letter Playfair message based on a keyword.^([29](b06.xhtml#c16-endnote-29))
    In 2018, Klaus wanted to know how short a Playfair cryptogram a codebreaker could
    solve if the matrix was not keyword based, meaning a dictionary attack wouldn’t
    work. Thus, he presented a series of increasingly difficult Playfair challenges
    on his blog, along with corresponding solutions provided by readers. Most of the
    codebreaking work depended on hill climbing and simulated annealing.
  prefs: []
  type: TYPE_NORMAL
- en: As far as we are aware, the cryptanalysis results produced over the course of
    these challenges represent the best results of such an experiment. This means
    that they set world records, the last of which is still valid as of this writing.
    We and the challenge solvers published these codebreaking success stories in an
    article titled “How We Set New World Records in Breaking Playfair Ciphertexts,”
    in *Cryptologia*.^([30](b06.xhtml#c16-endnote-30)) In the following, we will present
    a summary of this article.
  prefs: []
  type: TYPE_NORMAL
- en: In April 2018, Klaus published on his blog a fifty-letter Playfair message not
    based on a keyword:^([31](b06.xhtml#c16-endnote-31))
  prefs: []
  type: TYPE_NORMAL
- en: '`MQ VS KP EV IS BA WK TP KP PN AU NU NE GL UZ TY UZ LY GC TZ KN KU ST AG CT
    NQ`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The challenge didn’t remain a mystery for long; our colleague George Lasry
    solved it on the same day with a simulated annealing program of his own design.
    His fitness function used statistics about hexagraphs. Here’s the plaintext:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WHILE IN PARIS I RECEIVED ORDERS TO REPORT X TO GENERAL FOSTER X`'
  prefs: []
  type: TYPE_NORMAL
- en: In December 2018, Klaus created another challenge, based on a plaintext with
    only forty letters:^([32](b06.xhtml#c16-endnote-32))
  prefs: []
  type: TYPE_NORMAL
- en: '`OF FC ER VU MW MO OM RU FI WC MA OG FV ZY FX YB HG UX ZV EH`'
  prefs: []
  type: TYPE_NORMAL
- en: This time, German codebreaker Nils Kopal, the developer of CrypTool 2, was the
    one to post the solution on the same day. He had applied the same simulated-annealing
    algorithm written by George, including his hexagraph-based fitness function. The
    software delivered the following solution:^([33](b06.xhtml#c16-endnote-33))
  prefs: []
  type: TYPE_NORMAL
- en: '`MEET YOU TOMORROW AT FOUR TWENTY AT MARKET PLACE`'
  prefs: []
  type: TYPE_NORMAL
- en: Next, in April 2019, Klaus published a thirty-two-letter Playfair cryptogram
    based on a thirty-letter plaintext:^([34](b06.xhtml#c16-endnote-34))
  prefs: []
  type: TYPE_NORMAL
- en: '`SX CR ED BQ UG VZ RS MN DS IK RK WR SG NS NX VM`'
  prefs: []
  type: TYPE_NORMAL
- en: The challenge proved more difficult than the previous ones, as no solution popped
    up that day, week, or even month. However, five months later, in September 2019,
    Magnus Ekhall from Sweden deciphered the message with simulated annealing and
    again set a new record. His fitness function used the frequencies of five-letter
    groups (pentagraphs). The plaintext read as follows and included two `X`s as filler
    characters:^([35](b06.xhtml#c16-endnote-35))
  prefs: []
  type: TYPE_NORMAL
- en: '`TAKE THE LAST X TRAIN TO YORK ON SUNDAY X`'
  prefs: []
  type: TYPE_NORMAL
- en: In September 2019, Klaus created a new Playfair challenge—this time with twenty-eight
    letters:^([36](b06.xhtml#c16-endnote-36))
  prefs: []
  type: TYPE_NORMAL
- en: '`ZX LS EW HC HU CE LQ OE PN YR IW YC VQ LS`'
  prefs: []
  type: TYPE_NORMAL
- en: Again, Magnus Ekhall came up with the solution. The process, however, made it
    clear that a twenty-eight-letter Playfair message was considerably more difficult
    to break than one with thirty-two letters. Using simulated annealing, Magnus’s
    software produced 100,000 solution candidates. Magnus then wrote an additional
    program to determine the correct candidate, reproduced here:^([37](b06.xhtml#c16-endnote-37))
  prefs: []
  type: TYPE_NORMAL
- en: '`STAY WHERE YOU ARE UNTIL THURSDAY`'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing the experiment, Klaus published a twenty-six-letter challenge in
    November 2019:^([38](b06.xhtml#c16-endnote-38))
  prefs: []
  type: TYPE_NORMAL
- en: '`DB AQ IH KN RW VB KW NA DQ WR AM OQ IY`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Four weeks later, the solution was posted by a person thus far unknown in the
    codebreaking community: Konstantin Hamidullin, from Riga, Latvia. Here’s the plaintext:^([39](b06.xhtml#c16-endnote-39))'
  prefs: []
  type: TYPE_NORMAL
- en: '`WAIT FOR FURTHER INSTRUCTIONS`'
  prefs: []
  type: TYPE_NORMAL
- en: Surprisingly, Konstantin (who has since become a working colleague of ours)
    had found this solution with neither a hill climber nor a simulated-annealing
    algorithm but with his own unique method, which performed a kind of dictionary
    attack against the first words of the plaintext. This attack required a list,
    or dictionary, of word groups that frequently appear at the beginning of English
    sentences. For instance, `ONCEUPONATIME` or `THEQUESTIONWEWILLDISCUSSTODAY` could
    appear in such a list.
  prefs: []
  type: TYPE_NORMAL
- en: As Konstantin couldn’t find an existing collection that would suit his needs,
    he decided to create one. For this purpose, he turned to Project Gutenberg, a
    digital library that collects the full texts of tens of thousands of books in
    the public domain. He wrote a software program that worked through about 3,000
    English-language books and generated a list of the most frequent word groups that
    appeared at the start of all the sentences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Konstantin’s codebreaking software then used the more frequent entries on this
    list as cribs for the beginning of the plaintext. Next, it checked whether a Playfair
    matrix existed that would lead from the crib to the corresponding ciphertext.
    In many instances, this was not the case: for example, the word group `THISIS`
    cannot encode to `DBAQIH`, as the repetition of `IS` would lead to a repetition
    in the ciphertext not present here. If, for a certain crib, a Playfair matrix
    existed, the software would extend the word group by another likely word—for instance,
    `ONCEUPONATIME` could become `ONCEUPONATIMETHERE`—and test again.'
  prefs: []
  type: TYPE_NORMAL
- en: The breakthrough came when Konstantin’s software received a positive result
    for the word group `WAITFOR` and successfully extended it to `WAITFORFURTHER`.
    When it added `INSTRUCTIONS` as the fourth word and rendered a positive result,
    the solution was found.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, Klaus published a twenty-four-letter challenge, which you can find in
    [Chapter 12](c12.xhtml). As of this writing, the twenty-six-letter Playfair cryptogram
    solved by Konstantin is the shortest one ever deciphered. If you would like to
    try to break this record, try your luck at the twenty-four-letter one. To find
    out whether or not this challenge is still active, check out [https://codebreaking-guide.com/errata/](https://codebreaking-guide.com/errata/).
  prefs: []
  type: TYPE_NORMAL
- en: Solving machine ciphers with hill climbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hill climbing works not only for most substitutions and transpositions but also
    for the more sophisticated ciphers of the encryption machine era (which spanned
    roughly 1920 to 1970 and is discussed in [Chapter 15](c15.xhtml)). Most importantly,
    hill climbing proved extremely successful for breaking Enigma messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success story: Breaking original Enigma messages'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The exact number isn’t known, but experts estimate that the Germans transmitted
    about a million Enigma messages during World War II.^([40](b06.xhtml#c16-endnote-40))
    For security reasons, radio operators usually destroyed any record of a ciphertext
    after decryption, which is why most original Enigma messages are lost today. Luckily,
    there are exceptions, and a few thousand Enigma messages from the war are preserved
    in archives, museums, or private collections. Of course, researchers may discover
    more of these messages in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the last two decades, several Enigma enthusiasts have tried to break original
    Enigma cryptograms—with considerable success. We are aware of the following projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '*M4 Project*: This is an effort by German violinist Stefan Krah to break three
    original German Navy messages from World War II, which were encrypted with the
    four-rotor Enigma M4.^([41](b06.xhtml#c16-endnote-41)) The goal was to find the
    solutions with the help of distributed computing. Thousands of people downloaded
    software that Krah had written for this purpose and provided CPU resources. The
    M4 project succeeded in breaking two of the messages in 2006\. The third one was
    solved seven years later, in 2013.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Breaking German Wehrmacht Ciphers*: This is an ongoing project started by
    Geoff Sullivan and Frode Weierud in 2002.^([42](b06.xhtml#c16-endnote-42)) Olaf
    Ostwald later joined the effort. Together, they have broken hundreds of original
    Enigma ciphertexts, including radio messages from the Flossenbürg concentration
    camp and Germany’s Russia campaign (Operation Barbarossa).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Breaking German Navy Ciphers*: This is another ongoing project that aims to
    break original Enigma messages. It was started in 2012 by German schoolteacher
    Michael Hörenberg.^([43](b06.xhtml#c16-endnote-43)) As of this writing, he and
    his cryptanalytic partner Dan Girard have succeeded in deciphering over sixty
    Enigma cryptograms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The people involved in these projects have developed computer-based Enigma-breaking
    techniques that are much more powerful than the methods used by the British in
    Bletchley Park during the war. Many of these are based on hill climbing. Most
    of the original Enigma messages that are known to exist have been broken. The
    only exceptions tend to be very short messages or ciphertexts that likely contain
    errors.
  prefs: []
  type: TYPE_NORMAL
