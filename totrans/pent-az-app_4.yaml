- en: '**5**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**TARGETING VIRTUAL MACHINES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Every penetration tester is likely to encounter numerous virtual machines (VMs)
    in Azure. As you’ll learn in this chapter, attackers can leverage Azure Storage
    as a vector to steal secrets from, and take control of, Azure virtual machines.
    With the right level of access to these systems, an attacker could take complete
    control over any service running on the VMs and surreptitiously collect data about
    the users who connect to them.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, I begin with a look at how to obtain the *virtual hard
    disk (VHD)* images for virtual machines, without ever gaining Azure portal access.
    Once a copy of the VM’s VHD is obtained, I explain how to extract important data.
    Finally, I show you how to leverage the VM password reset option in the Azure
    portal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Best Practices: VM Security**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Virtual machines are one of the most common cloud workloads, because they allow
    businesses to quickly migrate on-premises servers into the cloud. Although VMs
    are a great way to take advantage of the benefits of the cloud with limited engineering
    effort, this approach can lead to security problems if companies don’t fully consider
    the new threats they might encounter as a result of such a move.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, administrators of on-premises servers often take for granted
    the firewalls and other security appliances on the border of the corporate network.
    By default, cloud-hosted VMs are internet-facing, so every open port must be carefully
    considered, with only the minimum number of services exposed, as each is a potential
    target for attack. Use network security groups in addition to the VM’s host firewall
    to restrict access to all unneeded ports. Additionally, consider using virtual
    networks that aren’t exposed to the internet for those VMs that host services
    that need to be accessed only from other cloud resources.
  prefs: []
  type: TYPE_NORMAL
- en: If you do expose a management service to the internet, such as RDP or SSH, you
    can reduce the risk of successful password spray or brute-force password attacks
    by ensuring that user accounts on the system use unusual account names (avoid
    common privileged account names like *administrator*, *admin*, and *root*) and
    strong passwords or, if possible, certificate-based or multi-factor authentication.
    Encourage the use of a password manager so users don’t balk at remembering strange
    usernames and complex passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Next, whenever possible, utilize full disk encryption on your VMs to protect
    any data that resides on them. This prevents offline VHD analysis, as described
    in “[Exploring the VHD with Autopsy](part0014.html#lev119)” on [page 95](part0014.html#page_95).
    Azure Disk Encryption is a convenient way to encrypt VHDs. It utilizes Key Vault
    to store the encryption keys for the disk, so you don’t need to worry about managing
    the keys. It is a free service in Azure and is available for most VM pricing tiers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, make sure that all relevant events for the VM are being monitored.
    Enabling Azure’s VM logs and including them in your blue team’s security log analysis
    tools is a good start. However, even more events can be detected by using Azure
    Security Center (ASC) and Operations Management Suite (OMS). ASC monitors VMs
    for known threats, while OMS provides detailed logs for any system where its agent
    is installed. Both solutions are described in detail in [Chapter 8](part0017.html#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual Hard Disk Theft and Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because one can obtain credentials for Azure Storage without full access to
    a subscription (as discussed in [Chapter 4](part0013.html#ch04)), an attacker
    may be able to control a running VM with just a storage account key. To do this,
    the attacker needs to obtain a VHD, retrieve passwords or certificates stored
    on the VHD, and then use those secrets to access the VM. Let’s start by looking
    at how a penetration tester can acquire a copy of a VM’s VHD.
  prefs: []
  type: TYPE_NORMAL
- en: '***Downloading a VHD Snapshot***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to download the disk image, you’ll need the key for the storage account
    that contains the desired VM’s VHD. This can be obtained directly from the Azure
    portal or through Azure PowerShell’s cmdlet `Get-AzureRmStorageAccountKey` if
    you have subscription access. Alternatively, you can use any of the storage key
    recovery methods described in [Chapter 4](part0013.html#ch04) if you don’t have
    subscription access. Once you’ve procured storage credentials, launch either Microsoft
    Azure Storage Explorer or ClumsyLeaf CloudXplorer. These are the only two tools
    that can create snapshots of files in Azure Storage. I’ll show how to use Microsoft
    Azure Storage Explorer because it is the free option.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you attempt to download a file from Azure while it’s in use, such as a
    VHD being used by a running VM, the download will be interrupted and the file
    will be corrupt or incomplete. The snapshot API creates a consistent (meaning
    non-corrupt) point-in-time duplicate of a file that you can copy. Because you
    can’t tell if a VHD is in use, you should always assume that it is and make a
    snapshot.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to download a snapshot in Microsoft Azure Storage Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the VHD file you want to copy and then click the **Make Snapshot** button
    in the ribbon menu, as shown in [Figure 5-1](part0014.html#ch05fig1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/00035.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 5-1: Creating a snapshot for a VHD in Microsoft Azure Storage Explorer*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Manage Snapshot** button. You should see all of the selected file’s
    snapshots in the file list. Their names should start with the name of the VHD,
    followed by a date and time in parentheses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To save the snapshot to your PC, select the snapshot and click **Download**
    in the ribbon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to delete the snapshot from the storage account once you’ve downloaded
    the VHD snapshot. Not only might a user notice the duplicate file, but the duplicate
    also takes up additional space in the storage account, which will lead to additional
    charges on the subscription’s monthly invoice. Although having the snapshot around
    for an hour or two while copying the VHD will likely go unnoticed, a full month’s
    worth of charges for potentially hundreds of gigabytes of blob storage will stand
    out to a good accountant.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFENDER’S TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Storage Analytics logging will record Azure Storage activity for blobs,
    queues, and tables. This includes successful and failed authentication attempts,
    uploads, downloads, deletions, and snapshot operations. Be sure to enable it and
    review this data for unusual activity. For more information see *[https://docs.microsoft.com/en-us/rest/api/storageservices/enabling-storage-logging-and-accessing-log-data/](https://docs.microsoft.com/en-us/rest/api/storageservices/enabling-storage-logging-and-accessing-log-data/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Also, billing data can be a surprisingly helpful tool to alert you if someone
    is exploiting your subscription. If you expect a subscription’s usage to be constant
    from month to month, a sudden change in cost warrants an investigation. The cause
    might be something innocuous, like a change in Azure’s rates, but it also might
    be someone running additional services in your subscription for nefarious purposes!
  prefs: []
  type: TYPE_NORMAL
- en: To delete snapshots in Microsoft Azure Storage Explorer, click the snapshot
    in the list of files to highlight it and then click the **Delete** button on the
    ribbon. If you don’t see any snapshots listed, click **Manage Snapshot** in the
    ribbon menu first.
  prefs: []
  type: TYPE_NORMAL
- en: '***Retrieving a VHD’s Secrets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you have a copy of the VHD on your computer, you can review it for useful
    information. The files to look for will depend on the guest’s operating system,
    but the goal is the same: identify information that is either valuable as a penetration
    test finding in its own right (for example, not-yet-released financials) or information
    that furthers your access to target systems (for example, passwords).'
  prefs: []
  type: TYPE_NORMAL
- en: Finding a password for the same VM that uses the stolen VHD is quite desirable.
    Although having that credential might seem moot with the VHD in hand, once you’ve
    found a password, you can perform many useful actions against a running VM that
    would not work against a static VHD copy. For example, with access to a VM, you
    could run Mimikatz to look for credentials you haven’t yet obtained. You could
    also modify a running service on the VM to covertly forward information to you
    as it arrives. You could even use it to send phishing emails, because users are
    typically more trusting of links to a server that they already know. The possibilities
    are limited only by your imagination.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the contents of VHD files can become a lengthy exercise in computer
    forensics, depending on the number of VHDs you obtain. Because you likely won’t
    have time to dig through every file in every disk image, let’s focus on a few
    key areas that are usually the most fruitful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploring the VHD with Autopsy**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you can review the contents of a VHD, you have to find a way to open
    it. If you are using Windows 10 and your target VM is also running a version of
    Windows, you should be able to right-click the VHD and select **Mount** to mount
    the VHD as a new virtual disk in Windows Explorer. If you’re running Linux and
    you have a VHD library installed, you should be able to use the mount command
    to attach the VHD. However, I prefer to explore the VHD using disk forensic tools
    like Autopsy. Using a disk forensic program has several advantages over native
    mount options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Broad disk format support** Whereas Windows can only mount disk images in
    NTFS and FAT formats, forensic tools can open dozens of formats—even when running
    on Windows. And on Linux, forensic tools often do a better job reading from unusual
    formats than Linux itself does.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better protection from malware** When mounting an untrusted file system directly
    into your system, you run the risk that any malware on the VHD could end up infecting
    your host. By using the forensic tool to extract only a few specific files of
    interest, you greatly reduce that risk.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protection for the integrity of the VHD** Forensic tools are designed to
    mount disk images in read-only mode, which prevents you from accidentally modifying
    or deleting files in the VHD. This not only prevents mistakes, but can also help
    quell skepticism when you present your findings.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ability to recover deleted files** Forensic tools specialize in re-creating
    files in disk images that users have deleted but that haven’t yet been overwritten
    by new data. You might come across some very interesting files that wouldn’t appear
    with a native mount command.'
  prefs: []
  type: TYPE_NORMAL
- en: My go-to forensic tool is the free, open source Autopsy (*[http://www.sleuthkit.org/](http://www.sleuthkit.org/)*).
    You can run it on Windows, Linux, and macOS. Although it lacks some of the advanced
    features and polish of commercial forensic programs, it’s more than sufficient
    for penetration testing, and it avoids the high cost associated with niche commercial
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: '***Importing the VHD***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Regardless of your computer’s operating system or that of the VHD, the instructions
    for using Autopsy to import the VHD for examination are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Autopsy and choose **Create New Case** on the Welcome screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the case a name (use the name of the VM) and select a directory for Autopsy
    to save its working files. Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the Case Number and Examiner fields blank and then click **Finish** to
    open the Add Data Source Wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Add Data Source window, browse to the downloaded VHD, select it, and
    click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Configure Ingest Modules screen, depicted in [Figure 5-2](part0014.html#ch05fig2),
    allows you to select what post-processing Autopsy will perform on the VHD, such
    as creating a search index and thumbnails of all pictures. Make your choices and
    then click **Next**, followed by **Finish** on the next screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Selecting ingestion options in Autopsy*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: Ingestion *is the process used by forensics software to automatically scan through
    the contents of the disk being examined and call out items of interest for the
    examiner. Autopsy provides a number of preconfigured ingestion options, such as
    email and credit card number identification and photo retrieval. It also supports
    custom filters so examiners can add their own.*
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be at the main Autopsy interface, as shown in [Figure
    5-3](part0014.html#ch05fig3). Double-click the VHD file in the Directory Listing
    area and you’ll see a list of partitions within the VHD, including unallocated
    partitions that represent unused space in the virtual disk.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: Navigating the disk image using Autopsy*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If Autopsy fails to load the VHD, either the VHD is corrupt and should be downloaded
    again, or the VM owner has enabled Azure Disk Encryption, in which case there’s
    nothing else you can do here. To check if encryption is enabled, try mounting
    the VHD on a Windows system using PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the image is corrupt, PowerShell will display the error `The file or directory
    is corrupted and unreadable`. If it is encrypted, a new Windows Explorer window
    will open attempting to display the VHD’s contents, but will report that the drive
    is not accessible.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFENDER’S TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Disk Encryption allows you to encrypt the contents of your VHDs in Azure
    Storage. It leverages BitLocker for Windows VMs and DM-Crypt for Linux VMs in
    order to fully encrypt the virtual disk, so if the VHD is removed from Azure,
    you won’t be able to read its contents. The encryption keys for the VHD are stored
    in Azure Key Vault. Note that to use Azure Disk Encryption, you must be using
    Standard or Premium tier VMs and the VMs must be ARM-based. You can learn more
    about Azure Disk Encryption at *[https://docs.microsoft.com/en-us/azure/security/azure-security-disk-encryption/](https://docs.microsoft.com/en-us/azure/security/azure-security-disk-encryption/)*.
  prefs: []
  type: TYPE_NORMAL
- en: When the VHD loads, double-click the first partition not labeled *unallocated*.
    You should see a list of the files on the VHD, as shown in [Figure 5-4](part0014.html#ch05fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: Examining a VHD in Autopsy*'
  prefs: []
  type: TYPE_NORMAL
- en: From within this interface, browse through the file system in search of interesting
    files. You can use the built-in hex viewer in the lower portion of the screen
    to preview files. To take a deeper look, select the file, right-click it, and
    then select **Extract File(s)** to save the file to your host system.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at some of the most interesting files to seek out on Windows
    and Linux VHDs.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing Windows VHDs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When I’m analyzing a VM’s disk, my first priority is to collect credentials. When
    analyzing a Windows VHD, I start with the *Security Account Manager (SAM)* database
    at *\Windows\System32\config\SAM*. The SAM stores password hashes for all local,
    non-domain users on a system, such as the local administrator account. Windows
    uses an encryption key, called a *Syskey*, to protect the SAM. You can find this
    key in *\Windows\System32\config\SYSTEM*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to decrypt the SAM file and obtain the hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the SYSTEM and SAM registry hive files from the VHD to your computer
    using Autopsy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch Cain & Abel (available from *[http://www.oxid.it/cain.html](http://www.oxid.it/cain.html)*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Cracker** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **File** ▸ **Add to list**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Import Hashes from a SAM database** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the browse button (**...**) next to SAM Filename and select the extracted
    SAM file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the browse button next to Boot Key and select the extracted SAM file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Syskey Decoder box that opens, click the browse button and select the
    SYSTEM file you extracted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Highlight and copy the displayed boot key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the Syskey Decoder box and then paste the key into the Boot Key field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the hashes for every account on the system, as shown in [Figure
    5-5](part0014.html#ch05fig5). (We’ll look at what to do with these hashes in “[Password
    Hash Attack Tools](part0014.html#lev129)” on [page 103](part0014.html#page_103),
    including how Cain & Abel can use them to obtain cleartext passwords.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: Hashes in Cain & Abel*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from passwords, when examining a VHD I’m also interested in source code,
    configuration files, and documents. What you’ll find depends on how the VM is
    being used and what software is installed on it. Check these locations, if present,
    for a good chance of finding valuable content:'
  prefs: []
  type: TYPE_NORMAL
- en: The *\InetPub* directory for website source code and configuration files (usually
    *web.config*). These may contain passwords and other secrets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each user’s home directory within *\Users*—especially their *Documents* folder
    for specifications and deployment documents about the target environment; *Desktop*
    folder for documents, keys, and notes; *Downloads* folder for hints about what
    tools may be used on the VM; and *AppData\Roaming* folder for Internet Explorer,
    Firefox, and Chrome subdirectories that contain web history, cookies, and saved
    passwords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directories that SQL uses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any directories that Azure management tools use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temp directories for output of scheduled tasks, test scripts, and other random
    gems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directories containing backups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, perform a full-VHD search for file extensions like **.pfx* for certificate
    private keys; **.doc*, **.docx*, **.xls*, **.xlsx*, **.ppt*, and **.pptx* for
    Microsoft Office files; **.bak* for backups; and **.txt* for notes, which will
    sometimes contain passwords. You might also want to search for files that password
    managers use, like **.kdx* and **.kdbx* for KeePass, **.psafe3* for Password Safe,
    and **.dash* or **.dashlane* for Dashlane. Finally, find copies of any scripts
    not included with the operating system, like **.bat*, **.cmd*, and **.ps1* from
    any directory besides *\Windows*, and see what they are used for.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing Linux VHDs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To retrieve password hashes from a Linux VHD, export the */etc/passwd* and */etc/shadow*
    files to get a list of users and their password hashes. It’s also a good idea
    to copy */etc/group* and */etc/gshadow* to determine what group memberships, and
    what rights, user accounts have.
  prefs: []
  type: TYPE_NORMAL
- en: The */etc/samba*, */etc/ssl*, and */etc/ssh* directories should contain configuration
    files and certificates that the system uses. Additionally, */etc/hostname* will
    contain the name of the VM, */etc/fstab* will list any other mounted disks in
    the VM, and */etc/hosts* may show static name-to-IP mappings of other servers
    that the VM interacts with.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good idea to try to retrieve source code and configuration files for
    any websites hosted on the VM because they may contain secrets. This is especially
    true of Apache’s *.htpasswd* and *.htaccess* files, which control access to web
    content. Common locations for these files include */var/www*, */usr/share/nginx*,
    and */httpd*.
  prefs: []
  type: TYPE_NORMAL
- en: Users’ home directories are another good source of information; these directories
    are typically found in */home* and also */root*. Saved Secure Shell (SSH) key
    files for connecting to remote systems and the history of commands, usually named
    *.bash_history*, are particularly interesting. Command histories will often have
    the names of other servers worth investigating. Look for commands like `ssh`,
    `telnet`, `scp`, and `smbclient`, as well as for a valid username for those systems.
  prefs: []
  type: TYPE_NORMAL
- en: Even though Linux doesn’t use file extensions as universally as Windows does,
    you should perform a file extension search on Linux VHDs because many users and
    applications use extensions. Scan for certificate-related files (**.pfx*, **.p12*,
    **.jks*) as well as shell scripts (**.sh*) and text files (**.txt*). You might
    also find something interesting in database files such as **.sql*, **.db*, and
    **.myd*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cracking Password Hashes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you successfully obtain password hashes from either Linux or Windows VMs,
    you will need to recover their plaintext values in order to use them. Hashes are
    meant to be *one directional*, meaning that you should not be able to determine
    the actual plaintext password from only the hash. But as you’ll see in this section,
    there are a few possible ways to retrieve passwords from hashes, including dictionary
    attacks, brute-force attacks, hybrid attacks, and rainbow table attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '***Dictionary Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a dictionary attack, an attacker compiles a list of common words or phrases
    and then hashes each item in the list with the same hashing algorithm the target
    server’s password system uses. Then, the attacker compares the hash of each dictionary
    word to the password hash list and displays the matches.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary attacks are great if you have a list of passwords that the target
    organization commonly uses, if you suspect users have simple one-word passwords
    that would appear in your compiled list of English words, or if you have a large
    password dictionary. You can usually find these large dictionaries online after
    criminals have compromised a popular website and released the stolen passwords.
    A good source is *[https://github.com/danielmiessler/SecLists/](https://github.com/danielmiessler/SecLists/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Always check with the legal teams at your company and at your target company
    before using leaked password lists. Simply because they are publicly available
    does not mean that you are free to use them. Some organizations might consider
    these files stolen property and deem them off limits. If you intend to use these
    lists, consider mentioning that fact in your rules of engagement.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Brute-Force Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When brute-forcing passwords, you generate every possible password combination
    of letters, numbers, and special characters and then hash that until a match is
    found. This method is very time consuming and is generally not practical for passwords
    greater than about eight characters in length, but it may find a short password
    that an attacker wouldn’t find in a typical dictionary, such as *f8i!R+*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hybrid Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hybrid attacks combine dictionary and brute-force attacks to try to recover
    complex passwords quickly. In this method, an attacker combines a base dictionary
    word with a sequence of characters, tests the result against the hash, and then
    moves on to the next word. For example, a password like *hippopotamus200* would
    likely not show up in any dictionary word list, and brute-forcing a 15-character
    password would take an unreasonable amount of time. However, a hybrid attack that
    uses one English word followed by one to four numbers would likely find this password
    in a matter of hours or days. The biggest drawback to a hybrid attack is that
    you need some idea of what the password’s format looks like. For example, the
    “word plus one to four characters” paradigm would not successfully find *200hippopotamus*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rainbow Table Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A rainbow table attack is a bit like a brute-force attack, where the attacker
    computes and stores all the hashes ahead of time to match against captured target
    hashes. However, truly storing every possible hash for a password of a given length
    would require a massive amount of space, making it impractical. To avoid this
    problem, the designers of rainbow tables perform a complex cryptographic operation
    (called a reduction function) that chains hashes together and only stores the
    beginning and end of each chain. (To learn how, see the original paper on the
    topic by Philippe Oechslin at *[https://lasec.epfl.ch/pub/lasec/doc/Oech03.pdf](https://lasec.epfl.ch/pub/lasec/doc/Oech03.pdf)*.)
  prefs: []
  type: TYPE_NORMAL
- en: In order for an attacker to use the rainbow table, a program takes in the target
    hash and begins computations against the precomputed table by passing the captured
    hash through the reduction function and seeing if the result matches the end of
    any chain. If so, it takes the value at the beginning of that chain and begins
    hashing and then reducing from the start of that chain until the value that created
    the original hash is found. If the reduced version of the captured hash doesn’t
    match the end of any chain, it is passed through the hash and reduction functions,
    and the cycle is performed again until the correct chain is identified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attackers optimize rainbow tables for either speed or size: a smaller rainbow
    table will take longer to return the password (though it will still be considerably
    faster than brute-forcing), whereas a larger table will return the result faster
    but consume more disk space.'
  prefs: []
  type: TYPE_NORMAL
- en: Although rainbow tables can be considerably faster than the other attacks discussed
    in this section, they have three major drawbacks. First, you must precompute them,
    so they require more planning and preparation than the other methods. Second,
    a rainbow table is only good for one hash format, such as MD5\. This means that
    you’ll need different rainbow tables for each type of hash you encounter. At a
    minimum, expect to find LM and NTLM hashes on Windows, and MD5 and SHA1 hashes
    on Linux. Third, they are ineffective against salted hash formats.
  prefs: []
  type: TYPE_NORMAL
- en: '***Weaknesses in Windows Password Hashes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For Azure-based Windows VMs, Azure mandates that the username not be *admin*
    or *administrator*, that the password be between 12 and 123 characters in length,
    and that the password include at least three of the four character types: lowercase
    letters, uppercase letters, numbers, and symbols. This would normally make brute-force
    attacks infeasible except that Windows stores passwords in both NTLM and LM hash
    formats for compatibility reasons. Early versions of Windows use the LM hash format
    whereas later ones use the more secure NTLM. LM has a number of weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Passwords are padded with null characters as needed to get a total length of
    14 characters, which is then split into two equal parts. Both parts are hashed
    separately and then concatenated to form the final LM hash value, so an attacker
    only needs to attack the hashes for two 7-character strings, which can be done
    in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords are limited to 14 characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letters in passwords are converted to uppercase before hashing, making them
    case insensitive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user has a password that is fewer than 15 characters on Windows, it is
    likely stored in both NTLM and LM formats in the SAM. When a password is seven
    characters or fewer, LM sets the second half of the LM hash to AAD3B435B51404EE
    (the hashed value of 7 null bytes), so an attacker only has to crack the first
    half. For passwords over 14 characters, Windows doesn’t store an LM hash and instead
    stores a default value of AAD3B435B51404EEAAD3B435B51404EE. Windows uses this
    same hash value for accounts with no password at all, so if you come across it,
    try that account with a blank password and you might just get lucky!
  prefs: []
  type: TYPE_NORMAL
- en: Because any password stored with an LM hash is essentially just the hash of
    two seven-character passwords and because neither hash contains lowercase characters,
    the keyspace that must be attacked for an LM hash is rather small. Therefore,
    an attacker can very quickly recover any password stored in LM format. Once an
    attacker cracks an LM hash, the resulting password might not be the account’s
    actual password, due to the case insensitivity of LM. Thus, an attacker will need
    to perform a short brute-force test of each of that password’s case permutations
    against the NTLM hash to find the final correct password. For example, if the
    LM hash is the password *DOG*, the user’s actual password could be *dog*, *Dog*,
    *dOg*, *doG*, *DOg*, *DoG*, *dOG*, or *DOG*.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFENDER’S TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: To make your passwords harder to attack, ensure they have at least 15 characters
    so that Windows doesn’t store LM hashes. Additionally, be sure that your passwords
    contain uppercase letters, lowercase letters, symbols, and numbers, and that they
    are not based on dictionary words. Such passwords can be hard to remember, so
    consider using a secure password manager with a very strong master password!
  prefs: []
  type: TYPE_NORMAL
- en: '**Password Hash Attack Tools**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will probably use one of two tools to perform password hash attacks: Cain
    & Abel or hashcat. Cain & Abel is a jack-of-all-trades security tool that has
    been an industry standard for years. In addition to having numerous features,
    it also has a GUI that makes it easy to learn. Hashcat is a newer addition to
    the penetration tester’s toolkit. It lacks a GUI and has only one feature: cracking
    hashes. However, what hashcat lacks in ease of use it makes up for in performance
    and support for a huge number of hash types. As a penetration tester, it is useful
    to know how to use each tool.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Attacking Hashes with Cain & Abel***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Cain & Abel offers hash cracking in the Cracker tab (the same tab you used
    for decrypting a SAM file in “[Analyzing Windows VHDs](part0014.html#lev121)”
    on [page 98](part0014.html#page_98)). Once you load the hashes in the Cracker
    tab, highlight the hashes you want to crack and then right-click any of the selected
    hashes. A context menu should appear with three cracking options at the top: Dictionary
    Attack, Brute-Force Attack, and Cryptanalysis Attack, as shown in [Figure 5-6](part0014.html#ch05fig6).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: The Cain & Abel hash context menu*'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Dictionary Attack presents a screen where you can select dictionary
    wordlists and perform some limited modifications on dictionary terms, such as
    trying each word in all uppercase and all lowercase, as shown in [Figure 5-7](part0014.html#ch05fig7).
  prefs: []
  type: TYPE_NORMAL
- en: The Brute-Force Attack option opens a different window where you can enter the
    characters to include in the attack, as well as the length of passwords to attempt,
    as shown in [Figure 5-8](part0014.html#ch05fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: The Cain & Abel Dictionary Attack window*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-8: The Cain & Abel Brute-Force Attack window*'
  prefs: []
  type: TYPE_NORMAL
- en: Cain & Abel includes logic that automatically adjusts the brute-force options,
    depending on the hash type. When you’re targeting LM hashes, the default keyspace
    doesn’t include lowercase characters and is preset to try passwords between one
    and seven characters in length, because these are known limitations of LM hashes.
    Once the attack is started, Cain & Abel shows test progress, including the rate
    of passwords tried per second and the total time remaining.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Cryptanalysis Attack option will perform a rainbow table attack
    against the hashes. The option screen for this attack is very simple, providing
    only an option to specify paths to the rainbow tables. As with a brute-force attack,
    it also displays the attack’s progress.
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing Hashes with hashcat***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hashcat is a free, open source, cross-platform password hash cracking tool,
    optimized to make full use of the processing power of the GPUs in modern graphics
    cards as well as the CPU. You can download hashcat from *[https://hashcat.net/hashcat/](https://hashcat.net/hashcat/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Much like Cain & Abel, hashcat offers both dictionary and brute-force options,
    but it really shines in hybrid mode. By leveraging the power of the GPU, hashcat
    can test a huge number of password permutations each second—on the order of millions,
    billions, or even trillions, depending on the graphics card and the hash type.
    Hashcat also supports the use of complex rules to control its password generation,
    which can prove very useful if you can determine a target company’s password policy.
    For example, if you know that all passwords must be at least eight characters
    and contain a number and a symbol, you can start your testing by eliminating all
    passwords that do not meet that criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Hashcat offers extensive support for various hash formats. Whereas Cain & Abel
    supports only about 30 hash formats, hashcat supports over 200\. This extensive
    support will come in really handy should you encounter a VM running some operating
    system or software that keeps its own password list (like PeopleSoft, Lotus Notes,
    or Joomla).
  prefs: []
  type: TYPE_NORMAL
- en: To learn how to use hashcat, I suggest reading the wiki at *[https://hashcat.net/wiki/](https://hashcat.net/wiki/)*.
    Note that a misconfigured hashcat job could take orders of magnitude longer than
    one that is properly configured with a good dictionary and proper rules. Worse,
    a hastily created job might inadvertently exclude legitimate passwords for a target
    system. Few things are more painful during a penetration test than realizing that
    you need to restart a cracking job that has been running for several days because
    of a command line error!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If the GPU in your computer isn’t very powerful, you might want to consider
    running hashcat on specialty Azure VMs that include NVIDIA-based GPUs, which are
    designed for computationally intensive tasks. Unfortunately, the cost of running
    these VMs for an extended period is usually costlier than building and operating
    your own PC with a few high-end video cards. You might prefer using the Azure
    GPUs under two circumstances, though. The first is if you need to crack a very
    important password very quickly. Using Azure, you could create dozens of these
    special VMs and assign each a different subset of the keyspace to test. The other
    is if you find password cracking to be a very rarely used technique in your engagements.
    In this case, it may make more sense to use Azure rather than make the initial
    capital investment in GPU hardware.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a VHD’s Secrets Against a VM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve recovered a username and password from a VHD, you can begin to assess
    the running VM in Azure—but first you’ll need to know how to connect to the VM.
    To do this, you’ll need its hostname or IP address and you’ll need to know which
    remote administration service is running on the VM and its port. Azure VMs running
    Windows will usually have Remote Desktop Protocol (RDP) available, whereas Linux
    VMs will typically have Secure Shell (SSH) open. Less frequently, Virtual Network
    Computing (VNC) protocol or telnet will be exposed, but these protocols aren’t
    encrypted by default and shouldn’t be used, especially over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: '***Determining the Hostname***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given the choice of hostname or IP, I prefer to use the hostname because IPs
    may be dynamically assigned. By default, Azure names its VHDs after the hostname
    of their associated VM. For example, if a VHD filename is *myazurevm20151231220005.vhd*,
    its hostname would usually be *myazurevm.cloudapp.net*.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, VHDs can be renamed, or their VM could be assigned a different hostname.
    If you find that to be the case, you can try to retrieve the hostname information
    from Azure or from within the VHD. The easiest way to do so is to use Azure PowerShell
    and the `Get-AzureVM` cmdlet to return the hostnames of every VM in the subscription,
    but that assumes you have an account with proper access.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can turn to the VHD itself. Windows stores the hostname in
    the SYSTEM registry hive, which we exported earlier in “[Analyzing Windows VHDs](part0014.html#lev121)”
    on [page 98](part0014.html#page_98). To see this value, you’ll need to load this
    file into a registry viewer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Recovering the Hostname from the VHD on Windows**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Be very careful when using the Windows built-in `regedit` tool to recover the
    hostname from the VHD; it’s just too easy to accidentally overwrite your own PC’s
    registry with values from the VM. A better choice is to use MiTeC’s Windows Registry
    Recovery (*[http://www.mitec.cz/wrr.html](http://www.mitec.cz/wrr.html)*), as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: Install Windows Registry Recovery and then click **File**▸**Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the *SYSTEM* file exported from the VHD and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Raw Data** option in the menu on the left (see [Figure 5-9](part0014.html#ch05fig9)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the middle pane, navigate to *ROOT\ControlSet001\Control\ComputerName\ComputerName*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The hostname should be in the ComputerName string in the pane on the right,
    as shown in [Figure 5-9](part0014.html#ch05fig9).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you see directories named *ControlSet002* or *ControlSet003* under *ROOT*,
    be sure to check those as well because the hostname may have changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-9: Viewing the hostname from the SYSTEM registry hive*'
  prefs: []
  type: TYPE_NORMAL
- en: There are other files in a Windows VM’s VHD that may contain the hostname, but
    the SYSTEM hive is the most reliable way to obtain it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Recovering the Hostname from the VHD on Linux**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s quite simple to recover the hostname from the VHD on Linux. To do so, simply
    locate the */etc/hostname* file and display it. It should contain the VM’s hostname.
  prefs: []
  type: TYPE_NORMAL
- en: '***Finding a Remote Administration Service***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you know the hostname, you should determine if the VM has an accessible
    remote administration tool. Although the RDP, SSH, VNC, and telnet services have
    default ports, the target VM may not use those ports, so you’ll need to determine
    which one the remote service is using. This can be done by using information from
    the subscription, checking known ports, or performing a full port scan.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using PowerShell**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The best way to find any accessible remote ports in a VM, provided you have
    proper credentials, is to use the PowerShell reconnaissance you learned in “[Gathering
    Information on Networking](part0012.html#lev76)” on [page 56](part0012.html#page_56).
    This data will contain the open ports allowed through the firewall for each VM
    from the output of the `Get-AzureEndpoint` and `Get-AzureRmNetworkSecurityGroup`
    cmdlets. Review this output and compare any listed open ports with well-known
    administration ports, as listed in [Table 5-1](part0014.html#ch05tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** Common Administration Ports'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service** | **TCP port(s)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RDP | 3389 |'
  prefs: []
  type: TYPE_TB
- en: '| SSH | 22 |'
  prefs: []
  type: TYPE_TB
- en: '| VNC | 5900 |'
  prefs: []
  type: TYPE_TB
- en: '| telnet | 21 |'
  prefs: []
  type: TYPE_TB
- en: '| Windows Remote Management (PowerShell remoting) | 5985, 5986 |'
  prefs: []
  type: TYPE_TB
- en: If you find any matches, try to connect to the VM using a client for that protocol.
    For example, in Windows, you could use the built-in *mstsc.exe* application to
    connect to RDP endpoints, PuTTY (*[https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)*)
    for SSH and telnet, or TightVNC (*[http://tightvnc.net/](http://tightvnc.net/))*
    for VNC servers. If you are running Linux, clients for SSH, VNC, and telnet are
    usually built in. For RDP, freeRDP (*[http://www.freerdp.com/](http://www.freerdp.com/)*)
    is a popular choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'If Windows Remote Management is available, you can connect using PowerShell.
    To do so, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will instruct PowerShell to bypass SSL certificate validation ➊ (since
    your client doesn’t trust this host), prompt you for credentials for the target
    machine ➋, and then connect ➌. If the connection succeeds, the command prompt
    will change to show that you are connected to the remote host and can now run
    commands on that machine ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing Default Ports**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If PowerShell access to the subscription isn’t an option, try testing the common
    default ports for each service in [Table 5-1](part0014.html#ch05tab1). This can
    be performed quickly on Windows using the built-in `Test-NetConnection` PowerShell
    cmdlet, with no subscription access needed. Simply run the command for each port
    you need to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a test connection to port 3389 was attempted ➊ and succeeded
    ➋, whereas the connection to port 21 ➌ failed ➍. Because 3389 is the port for
    RDP, I would then attempt to connect to this VM using *mstsc.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Port Scanning**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If your test of default ports fails and you don’t have proper PowerShell access,
    move on to a full TCP port scan of the VM. This will take several minutes, depending
    on the speed of your internet connection and the VM’s current load, but it will
    reliably determine every available port that is both open on the VM and accessible
    from your PC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best port-scanning tool for this task is Nmap (*[https://nmap.org/](https://nmap.org/)*).
    It can be installed on Windows or Linux, though I recommend using it on Linux,
    if possible, because it runs faster there. After installing Nmap, open a command
    prompt and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `-Pn` switch tells Nmap to continue even if the host doesn’t respond to
    a ping request. The `-p` switch tells Nmap which ports to scan (in this case,
    all possible TCP ports). Finally, `-sV` instructs Nmap to try to determine which
    service is running on any open ports it finds. Based on these results, you should
    learn which remote administration services are available in your target VM and
    on which ports they run.
  prefs: []
  type: TYPE_NORMAL
- en: 'These techniques can fail for three possible reasons: either the VM is currently
    shut down, all administration services have been disabled (or their ports have
    been restricted by a firewall), or the hostname or IP address isn’t correct. The
    only options in this case are to try again later or to give up and move on to
    other parts of the penetration test.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resetting a Virtual Machine’s Credentials**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Combining VHD forensics with password cracking, as discussed previously, is
    a powerful way to obtain credentials from a VM, but it’s limited to cases where
    Azure Disk Encryption isn’t enabled and when the attacker has time to crack the
    administrator password. If you manage to gain administrative rights to a subscription,
    you can use another, much faster method that doesn’t rely on obtaining information
    from disks: you can reset a VM’s administrator password. Although this method
    is fast and reliable, it also has a high likelihood of being detected, so I save
    it as a last resort.'
  prefs: []
  type: TYPE_NORMAL
- en: '***How to Reset a VM’s Credentials***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To avoid permanently locking users out of VMs when they’ve forgotten their password,
    the Azure portal offers a reset option for VM passwords, as shown in [Figure 5-10](part0014.html#ch05fig10).
    To access it for your target VM, sign in to the portal, click the **Virtual Machines**
    section, click your target VM, and then select **Reset password**.
  prefs: []
  type: TYPE_NORMAL
- en: This form has a few nice features. For one, it shows the VM’s built-in administrator
    or root account name (*azureadmin* in this case), even if it has been changed.
    This can be very helpful even if you aren’t planning to perform a password reset,
    because it allows you to determine a valid account name that can be used for things
    like dictionary attacks. Second, when a password is too weak, a red exclamation
    point appears at the right end of the password box. If you hover over the exclamation
    point, you’ll be able to read a tool tip about password complexity requirements.
    This would be perfect information to use to configure hashcat’s rules.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-10: Reset password screen for an Azure VM*'
  prefs: []
  type: TYPE_NORMAL
- en: To actually complete the password reset and change the administrator password,
    simply enter your desired password in the Password field and click **Update**.
    If you modify the User Name field, the administrator account should also be renamed.
    Additionally, if the built-in administrator account is disabled, the password
    reset option should re-enable it.
  prefs: []
  type: TYPE_NORMAL
- en: This form also contains an option in the Mode drop-down menu to reset the remote
    access configuration. This option will leave the original password intact but
    will enable RDP (Windows) or SSH (Linux) on the VM to restore the ability to connect
    remotely. This feature is intended to restore an administrator’s ability to connect
    to a VM after a misconfiguration, but for a penetration tester, it can re-open
    a remote access service on a VM that has been hardened.
  prefs: []
  type: TYPE_NORMAL
- en: '***Downsides to Password Resets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though a password reset is a fairly reliable way to gain access to a VM,
    it has some downsides. Most importantly, when the password is successfully changed
    via the portal, you’ll have no way to determine what the previous password was.
    That means that the password can’t be set back to its original value, and you
    are now the only one with the credentials. Of course, this also means that as
    soon as a legitimate user of the VM’s administrator account tries to connect to
    the VM, they will realize something is wrong. They won’t necessarily be blocked
    from accessing the VM because they can just perform a password reset themselves
    (assuming they have Azure portal access), but even inexperienced users will likely
    realize that a security incident may have occurred and will begin investigating
    or report it to their security monitoring team.
  prefs: []
  type: TYPE_NORMAL
- en: Second, even though you will have the credentials, you will likely have little
    to no idea how the target VM is configured. If the software running in the VM
    is actively using the account you reset, resetting the password may cause unforeseen
    outages in other services, which expect a different password.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this method has some technical limitations. The VM must be in a running
    state for the password reset option to be available. Additionally, the Azure VM
    agent software must be installed on the VM. The default OS images in Azure typically
    have this agent already installed, but some VMs may have had the agent removed
    by an administrator, may be running a less popular or older operating system with
    no agent available, or may have been built from nonstandard images.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we discussed how an attacker can create and download a snapshot
    for a virtual machine’s disk image from Azure Storage and then recover password
    hashes and other sensitive data from it with forensic recovery tools like Autopsy.
    We then examined how to crack these hashes in either Cain & Abel or hashcat to
    determine the original plaintext passwords. From there, we determined what management
    services were accessible on the VM using PowerShell or port scanning. Then, we
    used the cracked passwords to connect back to the VMs.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we looked at Azure’s VM password reset option. You can use this
    option to gain administrator level access to any VM that you can access in the
    portal, with no additional knowledge about the VM’s configuration. Finally, we
    considered some possible limitations to this attack.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at Azure networking to examine how to target
    internet-facing VMs, as well as how systems within a corporate network can interact
    with Azure services.
  prefs: []
  type: TYPE_NORMAL
