- en: '**2**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CAPTURING APPLICATION TRAFFIC**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Surprisingly, capturing useful traffic can be a challenging aspect of protocol
    analysis. This chapter describes two different capture techniques: *passive* and
    *active*. Passive capture doesn’t directly interact with the traffic. Instead,
    it extracts the data as it *travels on the wire*, which should be familiar from
    tools like Wireshark. You’ll find that different applications provide different
    mechanisms (which have their own advantages and disadvantages) to redirect traffic.
    Active capture interferes with traffic between a client application and the server;
    this has great power but can cause some complications. You can think of active
    capture in terms of proxies or even a man-in-the-middle attack. Let’s look at
    both active and passive techniques in more depth.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passive Network Traffic Capture**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Passive capture is a relatively easy technique: it doesn’t typically require
    any specialist hardware, nor do you usually need to write your own code. [Figure
    2-1](../Text/ch02.xhtml#ch2fig1) shows a common scenario: a client and server
    communicating via Ethernet over a network.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: An example of passive network capture*'
  prefs: []
  type: TYPE_NORMAL
- en: Passive network capture can take place either on the network by tapping the
    traffic as it passes in some way or by sniffing directly on either the client
    or server host.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick Primer for Wireshark**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wireshark is perhaps the most popular packet-sniffing application available.
    It’s cross platform and easy to use, and it comes with many built-in protocol
    analysis features. In [Chapter 5](../Text/ch05.xhtml#ch05) you’ll learn how to
    write a dissector to aid in protocol analysis, but for now, let’s set up Wireshark
    to capture IP traffic from the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture traffic from an Ethernet interface (wired or wireless), the capturing
    device must be in *promiscuous mode*. A device in promiscuous mode receives and
    processes any Ethernet frame it sees, even if that frame wasn’t destined for that
    interface. Capturing an application running on the same computer is easy: just
    monitor the outbound network interface or the local loopback interface (better
    known as localhost). Otherwise, you might need to use networking hardware, such
    as a hub or a configured switch, to ensure traffic is sent to your network interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-2](../Text/ch02.xhtml#ch2fig2) shows the default view when capturing
    traffic from an Ethernet interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: The default Wireshark view*'
  prefs: []
  type: TYPE_NORMAL
- en: There are three main view areas. Area ➊ shows a timeline of raw packets captured
    off the network. The timeline provides a list of the source and destination IP
    addresses as well as decoded protocol summary information. Area ➋ provides a dissected
    view of the packet, separated into distinct protocol layers that correspond to
    the OSI network stack model. Area ➌ shows the captured packet in its raw form.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP network protocol is stream based and designed to recover from dropped
    packets or data corruption. Due to the nature of networks and IP, there is no
    guarantee that packets will be received in a particular order. Therefore, when
    you are capturing packets, the timeline view might be difficult to interpret.
    Fortunately, Wireshark offers dissectors for known protocols that will normally
    reassemble the entire stream and provide all the information in one place. For
    example, highlight a packet in a TCP connection in the timeline view and then
    select **Analyze** ▸ **Follow TCP Stream** from the main menu. A dialog similar
    to [Figure 2-3](../Text/ch02.xhtml#ch2fig3) should appear. For protocols without
    a dissector, Wireshark can decode the stream and present it in an easy-to-view
    dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Following a TCP stream*'
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark is a comprehensive tool, and covering all of its features is beyond
    the scope of this book. If you’re not familiar with it, obtain a good reference,
    such as *Practical Packet Analysis, 3rd Edition* (No Starch Press, 2017), and
    learn many of its useful features. Wireshark is indispensable for analyzing application
    network traffic, and it’s free under the General Public License (GPL).
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative Passive Capture Techniques**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes using a packet sniffer isn’t appropriate, for example, in situations
    when you don’t have permission to capture traffic. You might be doing a penetration
    test on a system with no administrative access or a mobile device with a limited
    privilege shell. You might also just want to ensure that you look at traffic only
    for the application you’re testing. That’s not always easy to do with packet sniffing
    unless you correlate the traffic based on time. In this section, I’ll describe
    a few techniques for extracting network traffic from a local application without
    using a packet-sniffing tool.
  prefs: []
  type: TYPE_NORMAL
- en: '***System Call Tracing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many modern operating systems provide two modes of execution. *Kernel mode*
    runs with a high level of privilege and contains code implementing the OS’s core
    functionality. *User mode* is where everyday processes run. The kernel provides
    services to user mode by exporting a collection of special system calls (see [Figure
    2-4](../Text/ch02.xhtml#ch2fig4)), allowing users to access files, create processes—and
    most important for our purposes—connect to networks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: An example of user-to-kernel network communication via system
    calls*'
  prefs: []
  type: TYPE_NORMAL
- en: When an application wants to connect to a remote server, it issues special system
    calls to the OS’s kernel to open a connection. The app then reads and writes the
    network data. Depending on the operating system running your network applications,
    you can monitor these calls directly to passively extract data from an application.
  prefs: []
  type: TYPE_NORMAL
- en: Most Unix-like systems implement system calls resembling the Berkeley Sockets
    model for network communication. This isn’t surprising, because the IP protocol
    was originally implemented in the Berkeley Software Distribution (BSD) 4.2 Unix
    operating system. This socket implementation is also part of POSIX, making it
    the de facto standard. [Table 2-1](../Text/ch02.xhtml#ch2tab1) shows some of the
    more important system calls in the Berkeley Sockets API.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Common Unix System Calls for Networking'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `socket` | Creates a new socket file descriptor. |'
  prefs: []
  type: TYPE_TB
- en: '| `connect` | Connects a socket to a known IP address and port. |'
  prefs: []
  type: TYPE_TB
- en: '| `bind` | Binds the socket to a local known IP address and port. |'
  prefs: []
  type: TYPE_TB
- en: '| `recv`, `read`, `recvfrom` | Receives data from the network via the socket.
    The generic function `read` is for reading from a file descriptor, whereas `recv`
    and `recvfrom` are specific to the socket’s API. |'
  prefs: []
  type: TYPE_TB
- en: '| `send`, `write`, `sendfrom` | Sends data over the network via the socket.
    |'
  prefs: []
  type: TYPE_TB
- en: To learn more about how these system calls work, a great resource is *The TCP/IP
    Guide* (No Starch Press, 2005). Plenty of online resources are also available,
    and most Unix-like operating systems include manuals you can view at a terminal
    using the command `man 2 syscall_name`. Now let’s look at how to monitor system
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: '***The strace Utility on Linux***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Linux, you can directly monitor system calls from a user program without
    special permissions, unless the application you want to monitor runs as a privileged
    user. Many Linux distributions include the handy utility `strace`, which does
    most of the work for you. If it isn’t installed by default, download it from your
    distribution’s package manager or compile it from source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command, replacing `/path/to/app` with the application you’re
    testing and `args` with the necessary parameters, to log the network system calls
    used by that application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s monitor a networking application that reads and writes a few strings and
    look at the output from `strace`. [Listing 2-1](../Text/ch02.xhtml#ch2list1) shows
    four log entries (extraneous logging has been removed from the listing for brevity).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-1: Example output of the `strace` utility*'
  prefs: []
  type: TYPE_NORMAL
- en: The first entry ➊ creates a new TCP socket, which is assigned the handle 3\.
    The next entry ➋ shows the `connect` system call used to make a TCP connection
    to IP address 192.168.10.1 on port 5555\. The application then writes the string
    `Hello World!` ➌ before reading out a string `Boo!` ➍. The output shows it’s possible
    to get a good idea of what an application is doing at the system call level using
    this utility, even if you don’t have high levels of privilege.
  prefs: []
  type: TYPE_NORMAL
- en: '***Monitoring Network Connections with DTrace***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: DTrace is a very powerful tool available on many Unix-like systems, including
    Solaris (where it was originally developed), macOS, and FreeBSD. It allows you
    to set system-wide probes on special trace providers, including system calls.
    You configure DTrace by writing scripts in a language with a C-like syntax. For
    more details on this tool, refer to the DTrace Guide online at *[http://www.dtracebook.com/index.php/DTrace_Guide](http://www.dtracebook.com/index.php/DTrace_Guide)*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-2](../Text/ch02.xhtml#ch2list2) shows an example of a script that
    monitors outbound IP connections using DTrace.'
  prefs: []
  type: TYPE_NORMAL
- en: traceconnect.d
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-2: A simple DTrace script to monitor a `connect` system call*'
  prefs: []
  type: TYPE_NORMAL
- en: This simple script monitors the `connect` system call and outputs IPv4 TCP and
    UDP connections. The system call takes three parameters, represented by `arg0`,
    `arg1`, and `arg2` in the DTrace script language, that are initialized for us
    in the kernel. The `arg0` parameter is the socket file descriptor (that we don’t
    need), `arg1` is the address of the socket we’re connecting to, and `arg2` is
    the length of that address. Parameter `0` is the socket handle, which is not needed
    in this case. The next parameter is the user process memory address of a socket
    address structure, which is the address to connect to and can be different sizes
    depending on the socket type. (For example, IPv4 addresses are smaller than IPv6.)
    The final parameter is the length of the socket address structure in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The script defines a `sockaddr_in` structure that is used for IPv4 connections
    at ➊; in many cases these structures can be directly copied from the system’s
    C header files. The system call to monitor is specified at ➋. At ➌, a DTrace-specific
    filter is used to ensure we trace only connect calls where the socket address
    is the same size as `sockaddr_in`. At ➍, the `sockaddr_in` structure is copied
    from your process into a local structure for DTrace to inspect. At ➎, the process
    name, the destination IP address, and the port are printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: To run this script, copy it to a file called *traceconnect.d* and then run the
    command `dtrace -s traceconnect.d` as the root user. When you use a network-connected
    application, the output should look like [Listing 2-3](../Text/ch02.xhtml#ch2list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-3: Example output from* traceconnect.d *script*'
  prefs: []
  type: TYPE_NORMAL
- en: The output shows individual connections to IP addresses, printing out the process
    name, for example `'Google Chrome'`, the IP address, and the port connected to.
    Unfortunately, the output isn’t always as useful as the output from `strace` on
    Linux, but DTrace is certainly a valuable tool. This demonstration only scratches
    the surface of what DTrace can do.
  prefs: []
  type: TYPE_NORMAL
- en: '***Process Monitor on Windows***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In contrast to Unix-like systems, Windows implements its user-mode network functions
    without direct system calls. The networking stack is exposed through a driver,
    and establishing a connection uses the file `open`, `read`, and `write` system
    calls to configure a network socket for use. Even if Windows supported a facility
    similar to `strace`, this implementation makes it more difficult to monitor network
    traffic at the same level as other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows, starting with Vista and later, has supported an event generation framework
    that allows applications to monitor network activity. Writing your own implementation
    of this would be quite complex, but fortunately, someone has already written a
    tool to do it for you: Microsoft’s Process Monitor tool. [Figure 2-5](../Text/ch02.xhtml#ch2fig5)
    shows the main interface when filtering only on network connection events.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: An example Process Monitor capture*'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the filter circled in [Figure 2-5](../Text/ch02.xhtml#ch2fig5) displays
    only events related to network connections from a monitored process. Details include
    the hosts involved as well as the protocol and port being used. Although the capture
    doesn’t provide any data associated with the connections, it does offer valuable
    insight into the network communications the application is establishing. Process
    Monitor can also capture the state of the current calling stack, which helps you
    determine where in an application network connections are being made. This will
    become important in [Chapter 6](../Text/ch06.xhtml#ch06) when we start reverse
    engineering binaries to work out the network protocol. [Figure 2-6](../Text/ch02.xhtml#ch2fig6)
    shows a single HTTP connection to a remote server in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: A single captured connection*'
  prefs: []
  type: TYPE_NORMAL
- en: Column ➊ shows the name of the process that established the connection. Column
    ➋ shows the operation, which in this case is connecting to a remote server, sending
    the initial HTTP request and receiving a response. Column ➌ indicates the source
    and destination addresses, and column ➍ provides more in-depth information about
    the captured event.
  prefs: []
  type: TYPE_NORMAL
- en: Although this solution isn’t as helpful as monitoring system calls on other
    platforms, it’s still useful in Windows when you just want to determine the network
    protocols a particular application is using. You can’t capture data using this
    technique, but once you determine the protocols in use, you can add that information
    to your analysis through more active network traffic capture.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages and Disadvantages of Passive Capture**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The greatest advantage of using passive capture is that it doesn’t disrupt the
    client and server applications’ communication. It will not change the destination
    or source address of traffic, and it doesn’t require any modifications or reconfiguration
    of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Passive capture might also be the only technique you can use when you don’t
    have direct control over the client or the server. You can usually find a way
    to listen to the network traffic and capture it with a limited amount of effort.
    After you’ve collected your data, you can determine which active capture techniques
    to use and the best way to attack the protocol you want to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: One major disadvantage of passive network traffic capture is that capture techniques
    like packet sniffing run at such a low level that it can difficult to interpret
    what an application received. Tools such as Wireshark certainly help, but if you’re
    analyzing a custom protocol, it might not be possible to easily take apart the
    protocol without interacting with it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Passive capture also doesn’t always make it easy to modify the traffic an application
    produces. Modifying traffic isn’t always necessary, but it’s useful when you encounter
    encrypted protocols, want to disable compression, or need to change the traffic
    for exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing traffic and injecting new packets doesn’t yield results, switch
    tactics and try using active capture techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '**Active Network Traffic Capture**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Active capture differs from passive in that you’ll try to influence the flow
    of the traffic, usually by using a man-in-the-middle attack on the network communication.
    As shown in [Figure 2-7](../Text/ch02.xhtml#ch2fig7), the device capturing traffic
    usually sits between the client and server applications, acting as a bridge. This
    approach has several advantages, including the ability to modify traffic and disable
    features like encryption or compression, which can make it easier to analyze and
    exploit a network protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: A man-in-the-middle proxy*'
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage of this approach is that it’s usually more difficult because
    you need to reroute the application’s traffic through your active capture system.
    Active capture can also have unintended, undesirable effects. For example, if
    you change the network address of the server or client to the proxy, this can
    cause confusion, resulting in the application sending traffic to the wrong place.
    Despite these issues, active capture is probably the most valuable technique for
    analyzing and exploiting application network protocols.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Proxies**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common way to perform a man-in-the-middle attack on network traffic
    is to force the application to communicate through a proxy service. In this section,
    I’ll explain the relative advantages and disadvantages of some of the common proxy
    types you can use to capture traffic, analyze that data, and exploit a network
    protocol. I’ll also show you how to get traffic from typical client applications
    into a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '***Port-Forwarding Proxy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Port forwarding is the easiest way to proxy a connection. Just set up a listening
    server (TCP or UDP) and wait for a new connection. When that new connection is
    made to the proxy server, it will open a forwarding connection to the real service
    and logically connect the two, as shown in [Figure 2-8](../Text/ch02.xhtml#ch2fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: Overview of a TCP port-forwarding proxy*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Implementation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To create our proxy, we’ll use the built-in TCP port forwarder included with
    the Canape Core libraries. Place the code in [Listing 2-4](../Text/ch02.xhtml#ch2list4)
    into a C# script file, changing `LOCALPORT` ➋, `REMOTEHOST` ➌, and `REMOTEPORT`
    ➍ to appropriate values for your network.
  prefs: []
  type: TYPE_NORMAL
- en: PortFormat
  prefs: []
  type: TYPE_NORMAL
- en: Proxy.csx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-4: A simple TCP port-forwarding proxy example*'
  prefs: []
  type: TYPE_NORMAL
- en: This very simple script creates an instance of a `FixedProxyTemplate` ➊. Canape
    Core works on a template model, although if required you can get down and dirty
    with the low-level network configuration. The script configures the template with
    the desired local and remote network information. The template is used to create
    a service instance at ➎; you can think of documents in the framework acting as
    templates for services. The newly created service is then started; at this point,
    the network connections are configured. After waiting for a key press, the service
    is stopped at ➏. Then all the captured packets are written to the console using
    the `WritePackets()` method ➐.
  prefs: []
  type: TYPE_NORMAL
- en: Running this script should bind an instance of our forwarding proxy to the `LOCALPORT`
    number for the localhost interface only. When a new TCP connection is made to
    that port, the proxy code should establish a new connection to `REMOTEHOST` with
    TCP port `REMOTEPORT` and link the two connections together.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Binding a proxy to all network addresses can be risky from a security perspective
    because proxies written for testing protocols rarely implement robust security
    mechanisms. Unless you have complete control over the network you are connected
    to or have no choice, only bind your proxy to the local loopback interface. In
    [Listing 2-4](../Text/ch02.xhtml#ch2list4), the default is `LOCALHOST`; to bind
    to all interfaces, set the `AnyBind` property to `true`.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redirecting Traffic to Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With our simple proxy application complete, we now need to direct our application
    traffic through it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a web browser, it’s simple enough: to capture a specific request, instead
    of using the URL form *http://www.domain.com/resource*, use *http://**localhost:localport**/resource*,
    which pushes the request through your port-forwarding proxy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other applications are trickier: you might have to dig into the application’s
    configuration settings. Sometimes, the only setting an application allows you
    to change is the destination IP address. But this can lead to a chicken-and-egg
    scenario where you don’t know which TCP or UDP ports the application might be
    using with that address, especially if the application contains complex functions
    running over multiple different service connections. This occurs with *Remote
    Procedure Call (RPC)* protocols, such as the Common Object Request Broker Architecture
    (CORBA). This protocol usually makes an initial network connection to a broker,
    which acts as a directory of available services. A second connection is then made
    to the requested service over an instance-specific TCP port.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, a good approach is to use as many network-connected features of
    the application as possible while monitoring it using passive capture techniques.
    By doing so, you should uncover the connections that application typically makes,
    which you can then easily replicate with forwarding proxies.
  prefs: []
  type: TYPE_NORMAL
- en: If the application doesn’t support changing its destination, you need to be
    a bit more creative. If the application resolves the destination server address
    via a hostname, you have more options. You could set up a custom DNS server that
    responds to name requests with the IP address of your proxy. Or you could use
    the *hosts* file facility, which is available on most operating systems, including
    Windows, assuming you have control over system files on the device the application
    is running on.
  prefs: []
  type: TYPE_NORMAL
- en: During hostname resolving, the OS (or the resolving library) first refers to
    the *hosts* file to see if any local entries exist for that name, making a DNS
    request only if one is not found. For example, the hosts file in [Listing 2-5](../Text/ch02.xhtml#ch2list5)
    redirects the hostnames *[www.badgers.com](http://www.badgers.com)* and *[www.domain.com](http://www.domain.com)*
    to *localhost*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-5: An example* hosts *file*'
  prefs: []
  type: TYPE_NORMAL
- en: The standard location of the *hosts* file on Unix-like OSes is */etc/hosts*,
    whereas on Windows it is *C:\Windows\System32\Drivers\etc\hosts*. Obviously, you’ll
    need to replace the path to the Windows folder as necessary for your environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some antivirus and security products track changes to the system’s hosts,
    because changes are a sign of malware. You might need to disable the product’s
    protection if you want to change the* hosts *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages of a Port-Forwarding Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The main advantage of a port-forwarding proxy is its simplicity: you wait for
    a connection, open a new connection to the original destination, and then pass
    traffic back and forth between the two. There is no protocol associated with the
    proxy to deal with, and no special support is required by the application from
    which you are trying to capture traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: A port-forwarding proxy is also the primary way of proxying UDP traffic; because
    it isn’t connection oriented, the implementation of a forwarder for UDP is considerably
    simpler.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disadvantages of a Port-Forwarding Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Of course, the simplicity of a port-forwarding proxy also contributes to its
    disadvantages. Because you are only forwarding traffic from a listening connection
    to a single destination, multiple instances of a proxy would be required if the
    application uses multiple protocols on different ports.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider an application that has a single hostname or IP address
    for its destination, which you can control either directly by changing it in the
    application’s configuration or by spoofing the hostname. The application then
    attempts to connect to TCP ports 443 and 1234\. Because you can control the address
    it connects to, not the ports, you need to set up forwarding proxies for both,
    even if you are only interested in the traffic running over port 1234.
  prefs: []
  type: TYPE_NORMAL
- en: This proxy can also make it difficult to handle more than one connection to
    a well-known port. For example, if the port-forwarding proxy is listening on port
    1234 and making a connection to *[www.domain.com](http://www.domain.com)* port
    1234, only redirected traffic for the original domain will work as expected. If
    you wanted to also redirect *[www.badgers.com](http://www.badgers.com)*, things
    would be more difficult. You can mitigate this if the application supports specifying
    the destination address and port or by using other techniques, such as Destination
    Network Address Translation (DNAT), to redirect specific connections to unique
    forwarding proxies. ([Chapter 5](../Text/ch05.xhtml#ch05) contains more details
    on DNAT as well as numerous other more advanced network capture techniques.)
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the protocol might use the destination address for its own purposes.
    For example, the Host header in HyperText Transport Protocol (HTTP) can be used
    for Virtual Host decisions, which might make a port-forwarded protocol work differently,
    or not at all, from a redirected connection. Still, at least for HTTP, I will
    discuss a workaround for this limitation in “[Reverse HTTP Proxy](../Text/ch02.xhtml#ch00lev1sec42)”
    on [page 32](../Text/ch02.xhtml#page_32).
  prefs: []
  type: TYPE_NORMAL
- en: '***SOCKS Proxy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Think of a SOCKS proxy as a port-forwarding proxy on steroids. Not only does
    it forward TCP connections to the desired network location, but all new connections
    start with a simple handshake protocol that informs the proxy of the ultimate
    destination rather than having it fixed. It can also support listening connections,
    which is important for protocols like File Transfer Protocol (FTP) that need to
    open new local ports for the server to send data to. [Figure 2-9](../Text/ch02.xhtml#ch2fig9)
    provides an overview of SOCKS proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-9: Overview of SOCKS proxy*'
  prefs: []
  type: TYPE_NORMAL
- en: Three common variants of the protocol are currently in use—SOCKS 4, 4a, and
    5—and each has its own use. Version 4 is the most commonly supported version of
    the protocol; however, it supports only IPv4 connections, and the destination
    address must be specified as a 32-bit IP address. An update to version 4, version
    4a allowed connections by hostname (which is useful if you don’t have a DNS server
    that can resolve IP addresses). Version 5 introduced hostname support, IPv6, UDP
    forwarding, and improved authentication mechanisms; it is also the only one specified
    in an RFC (1928).
  prefs: []
  type: TYPE_NORMAL
- en: As an example, a client will send the request shown in [Figure 2-10](../Text/ch02.xhtml#ch2fig10)
    to establish a SOCKS connection to IP address 10.0.0.1 on port 12345\. The `USERNAME`
    component is the only method of authentication in SOCKS version 4 (not especially
    secure, I know). `VER` represents the version number, which in this case is 4\.
    `CMD` indicates it wants to connect out (binding to an address is `CMD` 2), and
    the TCP port and address are specified in binary form.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-10: A SOCKS version 4 request*'
  prefs: []
  type: TYPE_NORMAL
- en: If the connection is successful, it will send back the appropriate response,
    as shown in [Figure 2-11](../Text/ch02.xhtml#ch2fig11). The `RESP` field indicates
    the status of the response; the TCP port and address fields are only significant
    for binding requests. Then the connection becomes transparent and the client and
    server directly negotiate with each other; the proxy server only acts to forward
    traffic in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-11: A SOCKS version 4 successful response*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Implementation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Canape Core libraries have built-in support for SOCKS 4, 4a, and 5\. Place
    [Listing 2-6](../Text/ch02.xhtml#ch2list6) into a C# script file, changing `LOCALPORT`
    ➋ to the local TCP port you want to listen on for the SOCKS proxy.
  prefs: []
  type: TYPE_NORMAL
- en: SocksProxy.csx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-6: A simple SOCKS proxy example*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-6](../Text/ch02.xhtml#ch2list6) follows the same pattern established
    with the TCP port-forwarding proxy in [Listing 2-4](../Text/ch02.xhtml#ch2list4).
    But in this case, the code at ➊ creates a SOCKS proxy template. The rest of the
    code is exactly the same.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redirecting Traffic to Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To determine a way of pushing an application’s network traffic through a SOCKS
    proxy, look in the application first. For example, when you open the proxy settings
    in Mozilla Firefox, the dialog in [Figure 2-12](../Text/ch02.xhtml#ch2fig12) appears.
    From there, you can configure Firefox to use a SOCKS proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-12: Firefox proxy configuration*'
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes SOCKS support is not immediately obvious. If you are testing a
    Java application, the Java Runtime accepts command line parameters that enable
    SOCKS support for any outbound TCP connection. For example, consider the very
    simple Java application in [Listing 2-7](../Text/ch02.xhtml#ch2list7), which connects
    to IP address 192.168.10.1 on port 5555.
  prefs: []
  type: TYPE_NORMAL
- en: SocketClient.java
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-7: A simple Java TCP client*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this compiled program normally, it would do as you expect. But
    if on the command line you pass two special system properties, `socksProxyHost`
    and `socksProxyPort`, you can specify a SOCKS proxy for any TCP connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will make the TCP connection through the SOCKS proxy on localhost port
    1080.
  prefs: []
  type: TYPE_NORMAL
- en: Another place to look to determine how to push an application’s network traffic
    through a SOCKS proxy is the OS’s default proxy. On macOS, navigate to **System
    Preferences** ▸ **Network** ▸ **Advanced** ▸ **Proxies**. The dialog shown in
    [Figure 2-13](../Text/ch02.xhtml#ch2fig13) appears. From here, you can configure
    a system-wide SOCKS proxy or general proxies for other protocols. This won’t always
    work, but it’s an easy option worth trying out.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if the application just will not support a SOCKS proxy natively,
    certain tools will add that function to arbitrary applications. These tools range
    from free and open source tools, such as Dante (*[https://www.inet.no/dante/](https://www.inet.no/dante/)*)
    on Linux, to commercial tools, such as Proxifier (*[https://www.proxifier.com/](https://www.proxifier.com/)*),
    which runs on Windows and macOS. In one way or another, they all inject into the
    application to add SOCKS support and modify the operation of the socket functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-13: A proxy configuration dialog on macOS*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages of a SOCKS Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The clear advantage of using a SOCKS proxy, as opposed to using a simple port
    forwarder, is that it should capture all TCP connections (and potentially some
    UDP if you are using SOCKS version 5) that an application makes. This is an advantage
    as long as the OS socket layer is wrapped to effectively push all connections
    through the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: A SOCKS proxy also generally preserves the destination of the connection from
    the point of view of the client application. Therefore, if a client application
    sends in-band data that refers to its endpoint, then the endpoint will be what
    the server expects. However, this does not preserve the source address. Some protocols,
    such as FTP, assume they can request ports to be opened on the originating client.
    The SOCKS protocol provides a facility for binding listening connections but adds
    to the complexity of the implementation. This makes capture and analysis more
    difficult because you must consider many different streams of data to and from
    a server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disadvantages of a SOCKS Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The main disadvantage of SOCKS is that support can be inconsistent between applications
    and platforms. The Windows system proxy supports only SOCKS version 4 proxies,
    which means it will resolve only local hostnames. It does not support IPv6 and
    does not have a robust authentication mechanism. Generally, you get better support
    by using a SOCKS tool to add to an existing application, but this doesn’t always
    work well.
  prefs: []
  type: TYPE_NORMAL
- en: '***HTTP Proxies***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: HTTP powers the World Wide Web as well as a myriad of web services and RESTful
    protocols. [Figure 2-14](../Text/ch02.xhtml#ch2fig14) provides an overview of
    an HTTP proxy. The protocol can also be co-opted as a transport mechanism for
    non-web protocols, such as Java’s Remote Method Invocation (RMI) or Real Time
    Messaging Protocol (RTMP), because it can tunnel though the most restrictive firewalls.
    It is important to understand how HTTP proxying works in practice, because it
    will almost certainly be useful for protocol analysis, even if a web service is
    not being tested. Existing web application–testing tools rarely do an ideal job
    when HTTP is being used out of its original environment. Sometimes rolling your
    own implementation of an HTTP proxy is the only solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f02-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-14: Overview of an HTTP proxy*'
  prefs: []
  type: TYPE_NORMAL
- en: The two main types of HTTP proxy are the forwarding proxy and the reverse proxy.
    Each has advantages and disadvantages for the prospective network protocol analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: '***Forwarding an HTTP Proxy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The HTTP protocol is specified in RFC 1945 for version 1.0 and RFC 2616 for
    version 1.1; both versions provide a simple mechanism for proxying HTTP requests.
    For example, HTTP 1.1 specifies that the first full line of a request, the *request
    line*, has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The method ➊ specifies what to do in that request using familiar verbs, such
    as `GET`, `POST`, and `HEAD`. In a proxy request, this does not change from a
    normal HTTP connection. The path ➋ is where the proxy request gets interesting.
    As is shown, an absolute path indicates the resource that the method will act
    upon. Importantly, the path can also be an absolute Uniform Request Identifier
    (URI). By specifying an absolute URI, a proxy server can establish a new connection
    to the destination, forwarding all traffic on and returning data back to the client.
    The proxy can even manipulate the traffic, in a limited fashion, to add authentication,
    hide version 1.0 servers from 1.1 clients, and add transfer compression along
    with all manner of other things. However, this flexibility comes with a cost:
    the proxy server must be able to process the HTTP traffic, which adds massive
    complexity. For example, the following request line accesses an image resource
    on a remote server through a proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You, the attentive reader, might have identified an issue with this approach
    to proxying HTTP communication. Because the proxy must be able to access the underlying
    HTTP protocol, what about HTTPS, which transports HTTP over an encrypted TLS connection?
    You could break out the encrypted traffic; however, in a normal environment, it
    is unlikely the HTTP client would trust whatever certificate you provided. Also,
    TLS is intentionally designed to make it virtually impossible to use a man-in-the-middle
    attack any other way. Fortunately, this was anticipated, and RFC 2817 provides
    two solutions: it includes the ability to upgrade an HTTP connection to encryption
    (there is no need for more details here), and more importantly for our purposes,
    it specifies the `CONNECT` HTTP method for creating transparent, tunneled connections
    over HTTP proxies. As an example, a web browser that wants to establish a proxy
    connection to an HTTPS site can issue the following request to the proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the proxy accepts this request, it will make a new TCP connection to the
    server. On success, it should return the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The TCP connection to the proxy now becomes transparent, and the browser is
    able to establish the negotiated TLS connection without the proxy getting in the
    way. Of course, it’s worth noting that the proxy is unlikely to verify that TLS
    is actually being used on this connection. It could be any protocol you like,
    and this fact is abused by some applications to tunnel out their own binary protocols
    through HTTP proxies. For this reason, it’s common to find deployments of HTTP
    proxies restricting the ports that can be tunneled to a very limited subset.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Implementation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once again, the Canape Core libraries include a simple implementation of an
    HTTP proxy. Unfortunately, they don’t support the `CONNECT` method to create a
    transparent tunnel, but it will suffice for demonstration purposes. Place [Listing
    2-8](../Text/ch02.xhtml#ch2list8) into a C# script file, changing `LOCALPORT`
    ➋ to the local TCP port you want to listen on.
  prefs: []
  type: TYPE_NORMAL
- en: HttpProxy.csx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-8: A simple forward HTTP proxy example*'
  prefs: []
  type: TYPE_NORMAL
- en: Here we created a forward HTTP Proxy. The code at line ➊ is again only a slight
    variation from the previous examples, creating an HTTP proxy template.
  prefs: []
  type: TYPE_NORMAL
- en: '**Redirecting Traffic to Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As with SOCKS proxies, the first port of call will be the application. It’s
    rare for an application that uses the HTTP protocol to not have some sort of proxy
    configuration. If the application has no specific settings for HTTP proxy support,
    try the OS configuration, which is in the same place as the SOCKS proxy configuration.
    For example, on Windows you can access the system proxy settings by selecting
    Control Panel ▸ Internet Options ▸ Connections ▸ LAN Settings.
  prefs: []
  type: TYPE_NORMAL
- en: Many command line utilities on Unix-like systems, such as `curl`, `wget`, and
    `apt`, also support setting HTTP proxy configuration through environment variables.
    If you set the environment variable `http_proxy` to the URL for the HTTP proxy
    to use—for example, *http://localhost:3128*—the application will use it. For secure
    traffic, you can also use *https_proxy*. Some implementations allow special URL
    schemes, such as *socks4://*, to specify that you want to use a SOCKS proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages of a Forwarding HTTP Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The main advantage of a forwarding HTTP proxy is that if the application uses
    the HTTP protocol exclusively, all it needs to do to add proxy support is to change
    the absolute path in the Request Line to an absolute URI and send the data to
    a listening proxy server. Also, only a few applications that use the HTTP protocol
    for transport do not already support proxying.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disadvantages of a Forwarding HTTP Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The requirement of a forwarding HTTP proxy to implement a full HTTP parser to
    handle the many idiosyncrasies of the protocol adds significant complexity; this
    complexity might introduce processing issues or, in the worst case, security vulnerabilities.
    Also, the addition of the proxy destination within the protocol means that it
    can be more difficult to retrofit HTTP proxy support to an existing application
    through external techniques, unless you convert connections to use the `CONNECT`
    method (which even works for unencrypted HTTP).
  prefs: []
  type: TYPE_NORMAL
- en: Due to the complexities of handling a full HTTP 1.1 connection, it is common
    for proxies to either disconnect clients after a single request or downgrade communications
    to version 1.0 (which always closes the response connection after all data has
    been received). This might break a higher-level protocol that expects to use version
    1.1 or request *pipelining*, which is the ability to have multiple requests *in
    flight* to improve performance or state locality.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reverse HTTP Proxy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Forwarding proxies are fairly common in environments where an internal client
    is connecting to an outside network. They act as a security boundary, limiting
    outbound traffic to a small subset of protocol types. (Let’s just ignore the potential
    security implications of the `CONNECT` proxy for a moment.) But sometimes you
    might want to proxy inbound connections, perhaps for load-balancing or security
    reasons (to prevent exposing your servers directly to the outside world). However,
    a problem arises if you do this. You have no control over the client. In fact,
    the client probably doesn’t even realize it’s connecting to a proxy. This is where
    the *reverse HTTP proxy* comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of requiring the destination host to be specified in the request line,
    as with a forwarding proxy, you can abuse the fact that all HTTP 1.1–compliant
    clients *must* send a Host HTTP header in the request that specifies the original
    hostname used in the URI of the request. (Note that HTTP 1.0 has no such requirement,
    but most clients using that version will send the header anyway.) With the Host
    header information, you can infer the original destination of the request, making
    a proxy connection to that server, as shown in [Listing 2-9](../Text/ch02.xhtml#ch2list9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-9: An example HTTP request*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-9](../Text/ch02.xhtml#ch2list9) shows a typical Host header ➊ where
    the HTTP request was to the URL *[http://www.domain.com/image.jpg](http://www.domain.com/image.jpg)*.
    The reverse proxy can easily take this information and reuse it to construct the
    original destination. Again, because there is a requirement for parsing the HTTP
    headers, it is more difficult to use for HTTPS traffic that is protected by TLS.
    Fortunately, most TLS implementations take wildcard certificates where the subject
    is in the form of **.domain.com* or similar, which would match any subdomain of
    *[domain.com](http://domain.com)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Implementation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unsurprisingly, the Canape Core libraries include a built-in HTTP reverse proxy
    implementation, which you can access by changing the template object to *HttpReverseProxyTemplate*
    from *HttpProxyTemplate*. But for completeness, [Listing 2-10](../Text/ch02.xhtml#ch2list10)
    shows a simple implementation. Place the following code in a C# script file, changing
    `LOCALPORT` ➊ to the local TCP port you want to listen on. If `LOCALPORT` is less
    than 1024 and you’re running this on a Unix-style system, you’ll also need to
    run the script as root.
  prefs: []
  type: TYPE_NORMAL
- en: ReverseHttp
  prefs: []
  type: TYPE_NORMAL
- en: Proxy.csx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-10: A simple reverse HTTP proxy example*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redirecting Traffic to Your Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The approach to redirecting traffic to a reverse HTTP proxy is similar to that
    employed for TCP port-forwarding, which is by redirecting the connection to the
    proxy. But there is a big difference; you can’t just change the destination hostname.
    This would change the Host header, shown in Listing 2-10\. If you’re not careful,
    you could cause a proxy loop.^([1](../Text/footnote.xhtml#ch02nt01)) Instead,
    it’s best to change the IP address associated with a hostname using the *hosts*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: But perhaps the application you’re testing is running on a device that doesn’t
    allow you to change the *hosts* file. Therefore, setting up a custom DNS server
    might be the easiest approach, assuming you’re able to change the DNS server configuration.
  prefs: []
  type: TYPE_NORMAL
- en: You could use another approach, which is to configure a full DNS server with
    the appropriate settings. This can be time consuming and error prone; just ask
    anyone who has ever set up a bind server. Fortunately, existing tools are available
    to do what we want, which is to return our proxy’s IP address in response to a
    DNS request. Such a tool is *dnsspoof*. To avoid installing another tool, you
    can do it using Canape’s DNS server. The basic DNS server spoofs only a single
    IP address to all DNS requests (see [Listing 2-11](../Text/ch02.xhtml#ch2list11)).
    Replace `IPV4ADDRESS` ➊, `IPV6ADDRESS` ➋, and `REVERSEDNS` ➌ with appropriate
    strings. As with the HTTP Reverse Proxy, you’ll need to run this as root on a
    Unix-like system, as it will try to bind to port 53, which is not usually allowed
    for normal users. On Windows, there’s no such restriction on binding to ports
    less than 1024.
  prefs: []
  type: TYPE_NORMAL
- en: DnsServer.csx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-11: A simple DNS server*'
  prefs: []
  type: TYPE_NORMAL
- en: Now if you configure the DNS server for your application to point to your spoofing
    DNS server, the application should send its traffic through.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantage of a Reverse HTTP Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The advantage of a reverse HTTP proxy is that it doesn’t require a client application
    to support a typical forwarding proxy configuration. This is especially useful
    if the client application is not under your direct control or has a fixed configuration
    that cannot be easily changed. As long as you can force the original TCP connections
    to be redirected to the proxy, it’s possible to handle requests to multiple different
    hosts with little difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disadvantages of a Reverse HTTP Proxy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The disadvantages of a reverse HTTP proxy are basically the same as for a forwarding
    proxy. The proxy must be able to parse the HTTP request and handle the idiosyncrasies
    of the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Final Words**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve read about passive and active capture techniques in this chapter, but
    is one better than the other? That depends on the application you’re trying to
    test. Unless you are just monitoring network traffic, it pays to take an active
    approach. As you continue through this book, you’ll realize that active capture
    has significant benefits for protocol analysis and exploitation. If you have a
    choice in your application, use SOCKS because it’s the easiest approach in many
    circumstances.
  prefs: []
  type: TYPE_NORMAL
