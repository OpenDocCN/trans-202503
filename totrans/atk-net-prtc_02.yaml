- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**CAPTURING APPLICATION TRAFFIC**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**捕获应用程序流量**'
- en: 'Surprisingly, capturing useful traffic can be a challenging aspect of protocol
    analysis. This chapter describes two different capture techniques: *passive* and
    *active*. Passive capture doesn’t directly interact with the traffic. Instead,
    it extracts the data as it *travels on the wire*, which should be familiar from
    tools like Wireshark. You’ll find that different applications provide different
    mechanisms (which have their own advantages and disadvantages) to redirect traffic.
    Active capture interferes with traffic between a client application and the server;
    this has great power but can cause some complications. You can think of active
    capture in terms of proxies or even a man-in-the-middle attack. Let’s look at
    both active and passive techniques in more depth.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，捕获有用的流量可能是协议分析中的一个具有挑战性的方面。本章描述了两种不同的捕获技术：*被动*和*主动*。被动捕获不会直接与流量交互，而是提取其在*传输过程中*的数据，这一点在使用
    Wireshark 等工具时应该很熟悉。你会发现不同的应用程序提供了不同的机制（这些机制有自己的优缺点）来重定向流量。主动捕获会干扰客户端应用程序和服务器之间的流量；这种方法具有强大的功能，但可能会带来一些复杂性。你可以将主动捕获理解为代理或甚至是中间人攻击。让我们更深入地了解主动和被动技术。
- en: '**Passive Network Traffic Capture**'
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**被动网络流量捕获**'
- en: 'Passive capture is a relatively easy technique: it doesn’t typically require
    any specialist hardware, nor do you usually need to write your own code. [Figure
    2-1](../Text/ch02.xhtml#ch2fig1) shows a common scenario: a client and server
    communicating via Ethernet over a network.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 被动捕获是一种相对简单的技术：通常不需要任何专门的硬件，也不需要编写自己的代码。[图 2-1](../Text/ch02.xhtml#ch2fig1)展示了一个常见的场景：客户端和服务器通过以太网在网络上进行通信。
- en: '![image](../Images/f02-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-01.jpg)'
- en: '*Figure 2-1: An example of passive network capture*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：被动网络捕获示例*'
- en: Passive network capture can take place either on the network by tapping the
    traffic as it passes in some way or by sniffing directly on either the client
    or server host.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 被动网络捕获可以通过在网络上以某种方式拦截经过的流量，或者通过直接嗅探客户端或服务器主机来进行。
- en: '**Quick Primer for Wireshark**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Wireshark 快速入门**'
- en: Wireshark is perhaps the most popular packet-sniffing application available.
    It’s cross platform and easy to use, and it comes with many built-in protocol
    analysis features. In [Chapter 5](../Text/ch05.xhtml#ch05) you’ll learn how to
    write a dissector to aid in protocol analysis, but for now, let’s set up Wireshark
    to capture IP traffic from the network.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 可能是目前最受欢迎的数据包嗅探工具。它是跨平台的，易于使用，并且带有许多内置的协议分析功能。在[第 5 章](../Text/ch05.xhtml#ch05)中，你将学习如何编写一个解码器来辅助协议分析，但现在，让我们设置
    Wireshark 来捕获网络中的 IP 流量。
- en: 'To capture traffic from an Ethernet interface (wired or wireless), the capturing
    device must be in *promiscuous mode*. A device in promiscuous mode receives and
    processes any Ethernet frame it sees, even if that frame wasn’t destined for that
    interface. Capturing an application running on the same computer is easy: just
    monitor the outbound network interface or the local loopback interface (better
    known as localhost). Otherwise, you might need to use networking hardware, such
    as a hub or a configured switch, to ensure traffic is sent to your network interface.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要从以太网接口（有线或无线）捕获流量，捕获设备必须处于*混杂模式*。处于混杂模式的设备接收并处理它看到的任何以太网帧，即使该帧并非为该接口所传送。捕获同一台计算机上运行的应用程序流量很简单：只需监控出站网络接口或本地回环接口（通常称为
    localhost）。否则，您可能需要使用网络硬件，如集线器或配置过的交换机，来确保流量发送到您的网络接口。
- en: '[Figure 2-2](../Text/ch02.xhtml#ch2fig2) shows the default view when capturing
    traffic from an Ethernet interface.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-2](../Text/ch02.xhtml#ch2fig2)显示了从以太网接口捕获流量时的默认视图。'
- en: '![image](../Images/f02-02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-02.jpg)'
- en: '*Figure 2-2: The default Wireshark view*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：Wireshark 默认视图*'
- en: There are three main view areas. Area ➊ shows a timeline of raw packets captured
    off the network. The timeline provides a list of the source and destination IP
    addresses as well as decoded protocol summary information. Area ➋ provides a dissected
    view of the packet, separated into distinct protocol layers that correspond to
    the OSI network stack model. Area ➌ shows the captured packet in its raw form.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个主要的视图区。区域 ➊ 显示了从网络捕获的原始数据包时间线。时间线提供了源和目标 IP 地址以及解码后的协议概要信息。区域 ➋ 提供了数据包的详细视图，分为多个协议层，分别对应
    OSI 网络堆栈模型。区域 ➌ 显示了捕获的数据包的原始形式。
- en: The TCP network protocol is stream based and designed to recover from dropped
    packets or data corruption. Due to the nature of networks and IP, there is no
    guarantee that packets will be received in a particular order. Therefore, when
    you are capturing packets, the timeline view might be difficult to interpret.
    Fortunately, Wireshark offers dissectors for known protocols that will normally
    reassemble the entire stream and provide all the information in one place. For
    example, highlight a packet in a TCP connection in the timeline view and then
    select **Analyze** ▸ **Follow TCP Stream** from the main menu. A dialog similar
    to [Figure 2-3](../Text/ch02.xhtml#ch2fig3) should appear. For protocols without
    a dissector, Wireshark can decode the stream and present it in an easy-to-view
    dialog.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 网络协议是基于流的，设计用来从丢失的数据包或数据损坏中恢复。由于网络和 IP 的特性，无法保证数据包会按照特定的顺序接收。因此，当你捕获数据包时，时间线视图可能难以解释。幸运的是，Wireshark
    为已知协议提供了解析器，通常会重新组装整个流，并将所有信息集中展示。例如，在时间线视图中高亮显示一个 TCP 连接的数据包，然后从主菜单选择 **分析**
    ▸ **跟踪 TCP 流**。一个类似[图 2-3](../Text/ch02.xhtml#ch2fig3)的对话框应该会出现。对于没有解析器的协议，Wireshark
    可以解码流并以易于查看的对话框呈现出来。
- en: '![image](../Images/f02-03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-03.jpg)'
- en: '*Figure 2-3: Following a TCP stream*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：跟踪 TCP 流*'
- en: Wireshark is a comprehensive tool, and covering all of its features is beyond
    the scope of this book. If you’re not familiar with it, obtain a good reference,
    such as *Practical Packet Analysis, 3rd Edition* (No Starch Press, 2017), and
    learn many of its useful features. Wireshark is indispensable for analyzing application
    network traffic, and it’s free under the General Public License (GPL).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 是一款功能全面的工具，涵盖其所有功能超出了本书的范围。如果你不熟悉它，可以参考一本好的资料，比如 *Practical Packet
    Analysis, 第3版*（No Starch Press, 2017），学习其许多有用的功能。Wireshark 对于分析应用程序网络流量是必不可少的，并且在通用公共许可证（GPL）下免费提供。
- en: '**Alternative Passive Capture Techniques**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**替代的被动捕获技术**'
- en: Sometimes using a packet sniffer isn’t appropriate, for example, in situations
    when you don’t have permission to capture traffic. You might be doing a penetration
    test on a system with no administrative access or a mobile device with a limited
    privilege shell. You might also just want to ensure that you look at traffic only
    for the application you’re testing. That’s not always easy to do with packet sniffing
    unless you correlate the traffic based on time. In this section, I’ll describe
    a few techniques for extracting network traffic from a local application without
    using a packet-sniffing tool.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候使用数据包嗅探器并不合适，例如在你没有权限捕获流量的情况下。你可能正在对一个没有管理权限的系统进行渗透测试，或者对一个权限有限的移动设备进行测试。你可能还只想确保你只查看正在测试的应用程序的流量。在使用数据包嗅探工具时，除非你根据时间关联流量，否则这并不容易做到。在这一节中，我将介绍几种不使用数据包嗅探工具从本地应用程序中提取网络流量的技术。
- en: '***System Call Tracing***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***系统调用追踪***'
- en: Many modern operating systems provide two modes of execution. *Kernel mode*
    runs with a high level of privilege and contains code implementing the OS’s core
    functionality. *User mode* is where everyday processes run. The kernel provides
    services to user mode by exporting a collection of special system calls (see [Figure
    2-4](../Text/ch02.xhtml#ch2fig4)), allowing users to access files, create processes—and
    most important for our purposes—connect to networks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代操作系统提供两种执行模式。*内核模式*以较高的权限运行，包含实现操作系统核心功能的代码。*用户模式*是日常进程运行的地方。内核通过导出一组特殊的系统调用（参见[图
    2-4](../Text/ch02.xhtml#ch2fig4)），向用户模式提供服务，允许用户访问文件、创建进程——以及对我们来说最重要的——连接到网络。
- en: '![image](../Images/f02-04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-04.jpg)'
- en: '*Figure 2-4: An example of user-to-kernel network communication via system
    calls*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：通过系统调用进行用户与内核网络通信的示例*'
- en: When an application wants to connect to a remote server, it issues special system
    calls to the OS’s kernel to open a connection. The app then reads and writes the
    network data. Depending on the operating system running your network applications,
    you can monitor these calls directly to passively extract data from an application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序想要连接到远程服务器时，它会向操作系统的内核发出特殊的系统调用以打开连接。然后，应用程序会读取和写入网络数据。根据运行网络应用程序的操作系统，你可以直接监控这些调用，以被动地从应用程序中提取数据。
- en: Most Unix-like systems implement system calls resembling the Berkeley Sockets
    model for network communication. This isn’t surprising, because the IP protocol
    was originally implemented in the Berkeley Software Distribution (BSD) 4.2 Unix
    operating system. This socket implementation is also part of POSIX, making it
    the de facto standard. [Table 2-1](../Text/ch02.xhtml#ch2tab1) shows some of the
    more important system calls in the Berkeley Sockets API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类Unix系统实现了类似于伯克利套接字模型的网络通信系统调用。这并不令人惊讶，因为IP协议最初是在伯克利软件分发（BSD）4.2 Unix操作系统中实现的。这个套接字实现也是POSIX的一部分，使其成为事实上的标准。[表
    2-1](../Text/ch02.xhtml#ch2tab1)展示了伯克利套接字API中的一些重要系统调用。
- en: '**Table 2-1:** Common Unix System Calls for Networking'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 常见的Unix网络系统调用'
- en: '| **Name** | **Description** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `socket` | Creates a new socket file descriptor. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `socket` | 创建一个新的套接字文件描述符。 |'
- en: '| `connect` | Connects a socket to a known IP address and port. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `connect` | 将套接字连接到已知的IP地址和端口。 |'
- en: '| `bind` | Binds the socket to a local known IP address and port. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `bind` | 将套接字绑定到一个已知的本地IP地址和端口。 |'
- en: '| `recv`, `read`, `recvfrom` | Receives data from the network via the socket.
    The generic function `read` is for reading from a file descriptor, whereas `recv`
    and `recvfrom` are specific to the socket’s API. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `recv`, `read`, `recvfrom` | 通过套接字从网络接收数据。通用函数`read`用于从文件描述符读取，而`recv`和`recvfrom`则专用于套接字的API。
    |'
- en: '| `send`, `write`, `sendfrom` | Sends data over the network via the socket.
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `send`, `write`, `sendfrom` | 通过套接字将数据发送到网络。 |'
- en: To learn more about how these system calls work, a great resource is *The TCP/IP
    Guide* (No Starch Press, 2005). Plenty of online resources are also available,
    and most Unix-like operating systems include manuals you can view at a terminal
    using the command `man 2 syscall_name`. Now let’s look at how to monitor system
    calls.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些系统调用是如何工作的，一个很好的资源是*《TCP/IP指南》*（No Starch Press，2005）。网上也有很多相关资源，并且大多数类Unix操作系统都包括可以通过终端使用`man
    2 syscall_name`命令查看的手册。现在让我们来看一下如何监视系统调用。
- en: '***The strace Utility on Linux***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux上的strace工具***'
- en: In Linux, you can directly monitor system calls from a user program without
    special permissions, unless the application you want to monitor runs as a privileged
    user. Many Linux distributions include the handy utility `strace`, which does
    most of the work for you. If it isn’t installed by default, download it from your
    distribution’s package manager or compile it from source.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，你可以直接监视用户程序的系统调用，而无需特殊权限，除非你要监视的应用程序以特权用户身份运行。许多Linux发行版包含了实用的工具`strace`，它为你做大部分工作。如果它没有默认安装，可以通过发行版的包管理器下载，或者从源代码编译安装。
- en: 'Run the following command, replacing `/path/to/app` with the application you’re
    testing and `args` with the necessary parameters, to log the network system calls
    used by that application:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令，将`/path/to/app`替换为你正在测试的应用程序路径，将`args`替换为所需的参数，以记录该应用程序使用的网络系统调用：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s monitor a networking application that reads and writes a few strings and
    look at the output from `strace`. [Listing 2-1](../Text/ch02.xhtml#ch2list1) shows
    four log entries (extraneous logging has been removed from the listing for brevity).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们监视一个读取和写入几个字符串的网络应用程序，并查看`strace`的输出。[列表 2-1](../Text/ch02.xhtml#ch2list1)显示了四个日志条目（为了简洁，已移除多余的日志记录）。
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 2-1: Example output of the `strace` utility*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-1：`strace`工具的示例输出*'
- en: The first entry ➊ creates a new TCP socket, which is assigned the handle 3\.
    The next entry ➋ shows the `connect` system call used to make a TCP connection
    to IP address 192.168.10.1 on port 5555\. The application then writes the string
    `Hello World!` ➌ before reading out a string `Boo!` ➍. The output shows it’s possible
    to get a good idea of what an application is doing at the system call level using
    this utility, even if you don’t have high levels of privilege.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条目 ➊ 创建一个新的TCP套接字，分配给句柄3。接下来的条目 ➋ 显示使用`connect`系统调用建立到IP地址192.168.10.1，端口5555的TCP连接。然后应用程序写入字符串`Hello
    World!` ➌，接着读取字符串`Boo!` ➍。输出表明，即使你没有高权限，也能通过这个工具大致了解应用程序在系统调用层面的行为。
- en: '***Monitoring Network Connections with DTrace***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用DTrace监视网络连接***'
- en: DTrace is a very powerful tool available on many Unix-like systems, including
    Solaris (where it was originally developed), macOS, and FreeBSD. It allows you
    to set system-wide probes on special trace providers, including system calls.
    You configure DTrace by writing scripts in a language with a C-like syntax. For
    more details on this tool, refer to the DTrace Guide online at *[http://www.dtracebook.com/index.php/DTrace_Guide](http://www.dtracebook.com/index.php/DTrace_Guide)*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: DTrace 是一个非常强大的工具，适用于许多类 Unix 系统，包括 Solaris（最初开发的地方）、macOS 和 FreeBSD。它允许你在特殊的追踪提供者上设置系统范围的探针，包括系统调用。你可以通过编写
    C 风格语法的脚本来配置 DTrace。有关此工具的更多详细信息，请参考 DTrace 在线指南，网址为 *[http://www.dtracebook.com/index.php/DTrace_Guide](http://www.dtracebook.com/index.php/DTrace_Guide)*。
- en: '[Listing 2-2](../Text/ch02.xhtml#ch2list2) shows an example of a script that
    monitors outbound IP connections using DTrace.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-2](../Text/ch02.xhtml#ch2list2) 展示了一个使用 DTrace 监控外发 IP 连接的脚本示例。'
- en: traceconnect.d
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: traceconnect.d
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 2-2: A simple DTrace script to monitor a `connect` system call*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-2：一个简单的 DTrace 脚本，用于监控 `connect` 系统调用*'
- en: This simple script monitors the `connect` system call and outputs IPv4 TCP and
    UDP connections. The system call takes three parameters, represented by `arg0`,
    `arg1`, and `arg2` in the DTrace script language, that are initialized for us
    in the kernel. The `arg0` parameter is the socket file descriptor (that we don’t
    need), `arg1` is the address of the socket we’re connecting to, and `arg2` is
    the length of that address. Parameter `0` is the socket handle, which is not needed
    in this case. The next parameter is the user process memory address of a socket
    address structure, which is the address to connect to and can be different sizes
    depending on the socket type. (For example, IPv4 addresses are smaller than IPv6.)
    The final parameter is the length of the socket address structure in bytes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的脚本监控 `connect` 系统调用，并输出 IPv4 TCP 和 UDP 连接。该系统调用接受三个参数，在 DTrace 脚本语言中分别由
    `arg0`、`arg1` 和 `arg2` 表示，这些参数在内核中为我们初始化。`arg0` 参数是套接字文件描述符（我们不需要使用它），`arg1` 是我们正在连接的套接字的地址，`arg2`
    是该地址的长度。参数 `0` 是套接字句柄，在本例中不需要。下一个参数是套接字地址结构的用户进程内存地址，它是要连接的地址，并且根据套接字类型的不同，大小可能不同。（例如，IPv4
    地址比 IPv6 地址小。）最后一个参数是套接字地址结构的字节长度。
- en: The script defines a `sockaddr_in` structure that is used for IPv4 connections
    at ➊; in many cases these structures can be directly copied from the system’s
    C header files. The system call to monitor is specified at ➋. At ➌, a DTrace-specific
    filter is used to ensure we trace only connect calls where the socket address
    is the same size as `sockaddr_in`. At ➍, the `sockaddr_in` structure is copied
    from your process into a local structure for DTrace to inspect. At ➎, the process
    name, the destination IP address, and the port are printed to the console.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本在 ➊ 处定义了一个 `sockaddr_in` 结构，用于 IPv4 连接；在许多情况下，这些结构可以直接从系统的 C 头文件中复制过来。要监控的系统调用在
    ➋ 处指定。在 ➌ 处，使用了一个特定于 DTrace 的过滤器，以确保我们只追踪那些套接字地址与 `sockaddr_in` 大小相同的连接调用。在 ➍
    处，`sockaddr_in` 结构被从你的进程复制到 DTrace 检查的本地结构中。在 ➎ 处，进程名称、目标 IP 地址和端口被打印到控制台。
- en: To run this script, copy it to a file called *traceconnect.d* and then run the
    command `dtrace -s traceconnect.d` as the root user. When you use a network-connected
    application, the output should look like [Listing 2-3](../Text/ch02.xhtml#ch2list3).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个脚本，将其复制到一个名为 *traceconnect.d* 的文件中，然后以 root 用户身份运行命令 `dtrace -s traceconnect.d`。当你使用一个网络连接的应用程序时，输出应类似于
    [清单 2-3](../Text/ch02.xhtml#ch2list3)。
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 2-3: Example output from* traceconnect.d *script*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-3：来自* traceconnect.d *脚本的示例输出*'
- en: The output shows individual connections to IP addresses, printing out the process
    name, for example `'Google Chrome'`, the IP address, and the port connected to.
    Unfortunately, the output isn’t always as useful as the output from `strace` on
    Linux, but DTrace is certainly a valuable tool. This demonstration only scratches
    the surface of what DTrace can do.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了单独的 IP 地址连接，打印出进程名称，例如 `'Google Chrome'`、IP 地址以及连接的端口。不幸的是，输出并不像 Linux
    中 `strace` 的输出那样总是非常有用，但 DTrace 绝对是一个有价值的工具。这个演示仅仅是 DTrace 能做的一小部分。
- en: '***Process Monitor on Windows***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Windows 上的进程监视器***'
- en: In contrast to Unix-like systems, Windows implements its user-mode network functions
    without direct system calls. The networking stack is exposed through a driver,
    and establishing a connection uses the file `open`, `read`, and `write` system
    calls to configure a network socket for use. Even if Windows supported a facility
    similar to `strace`, this implementation makes it more difficult to monitor network
    traffic at the same level as other platforms.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与类 Unix 系统不同，Windows 实现了不直接通过系统调用的用户模式网络功能。网络协议栈通过驱动程序暴露出来，建立连接时使用 `open`、`read`
    和 `write` 系统调用来配置网络套接字供使用。即使 Windows 支持类似 `strace` 的工具，这种实现方式仍然使得在相同层次上监控网络流量变得更加困难。
- en: 'Windows, starting with Vista and later, has supported an event generation framework
    that allows applications to monitor network activity. Writing your own implementation
    of this would be quite complex, but fortunately, someone has already written a
    tool to do it for you: Microsoft’s Process Monitor tool. [Figure 2-5](../Text/ch02.xhtml#ch2fig5)
    shows the main interface when filtering only on network connection events.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Vista 及之后版本开始，Windows 支持一个事件生成框架，允许应用程序监控网络活动。编写你自己的实现会相当复杂，但幸运的是，有人已经为你编写了一个工具：微软的进程监视器工具。[图
    2-5](../Text/ch02.xhtml#ch2fig5)显示了在仅过滤网络连接事件时的主界面。
- en: '![image](../Images/f02-05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-05.jpg)'
- en: '*Figure 2-5: An example Process Monitor capture*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：一个示例进程监视器捕获*'
- en: Selecting the filter circled in [Figure 2-5](../Text/ch02.xhtml#ch2fig5) displays
    only events related to network connections from a monitored process. Details include
    the hosts involved as well as the protocol and port being used. Although the capture
    doesn’t provide any data associated with the connections, it does offer valuable
    insight into the network communications the application is establishing. Process
    Monitor can also capture the state of the current calling stack, which helps you
    determine where in an application network connections are being made. This will
    become important in [Chapter 6](../Text/ch06.xhtml#ch06) when we start reverse
    engineering binaries to work out the network protocol. [Figure 2-6](../Text/ch02.xhtml#ch2fig6)
    shows a single HTTP connection to a remote server in detail.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 选择[图 2-5](../Text/ch02.xhtml#ch2fig5)中圈出的过滤器，只显示与被监控进程的网络连接相关的事件。详细信息包括涉及的主机以及使用的协议和端口。虽然捕获的数据不提供与连接相关的任何数据，但它确实为应用程序建立的网络通信提供了有价值的见解。进程监视器还可以捕获当前调用栈的状态，帮助你确定应用程序中在哪个位置正在建立网络连接。这在我们开始反向工程二进制文件以研究网络协议时，在[第
    6 章](../Text/ch06.xhtml#ch06)中将变得非常重要。[图 2-6](../Text/ch02.xhtml#ch2fig6)详细显示了一个到远程服务器的单一
    HTTP 连接。
- en: '![image](../Images/f02-06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-06.jpg)'
- en: '*Figure 2-6: A single captured connection*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：一个捕获的单一连接*'
- en: Column ➊ shows the name of the process that established the connection. Column
    ➋ shows the operation, which in this case is connecting to a remote server, sending
    the initial HTTP request and receiving a response. Column ➌ indicates the source
    and destination addresses, and column ➍ provides more in-depth information about
    the captured event.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➊ 列显示了建立连接的进程名称。第 ➋ 列显示了操作，在本例中是连接到远程服务器，发送初始的 HTTP 请求并接收响应。第 ➌ 列指示源地址和目标地址，第
    ➍ 列提供了关于捕获事件的更深入信息。
- en: Although this solution isn’t as helpful as monitoring system calls on other
    platforms, it’s still useful in Windows when you just want to determine the network
    protocols a particular application is using. You can’t capture data using this
    technique, but once you determine the protocols in use, you can add that information
    to your analysis through more active network traffic capture.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法在其他平台上监控系统调用时没有那么有用，但在 Windows 中，当你只想确定某个特定应用程序使用的网络协议时，它仍然是有用的。你不能通过这种技术捕获数据，但一旦确定了使用的协议，你可以通过更主动的网络流量捕获将这些信息加入到你的分析中。
- en: '**Advantages and Disadvantages of Passive Capture**'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**被动捕获的优缺点**'
- en: The greatest advantage of using passive capture is that it doesn’t disrupt the
    client and server applications’ communication. It will not change the destination
    or source address of traffic, and it doesn’t require any modifications or reconfiguration
    of the applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用被动捕获的最大优势在于，它不会干扰客户端和服务器应用程序的通信。它不会改变流量的目标地址或源地址，也不需要对应用程序进行任何修改或重新配置。
- en: Passive capture might also be the only technique you can use when you don’t
    have direct control over the client or the server. You can usually find a way
    to listen to the network traffic and capture it with a limited amount of effort.
    After you’ve collected your data, you can determine which active capture techniques
    to use and the best way to attack the protocol you want to analyze.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你无法直接控制客户端或服务器时，被动捕获可能是你能使用的唯一技术。你通常可以找到一种方法，监听网络流量并用有限的精力捕获它。收集到数据后，你可以确定使用哪些主动捕获技术以及分析你想要研究的协议的最佳攻击方式。
- en: One major disadvantage of passive network traffic capture is that capture techniques
    like packet sniffing run at such a low level that it can difficult to interpret
    what an application received. Tools such as Wireshark certainly help, but if you’re
    analyzing a custom protocol, it might not be possible to easily take apart the
    protocol without interacting with it directly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 被动网络流量捕获的一个主要缺点是，像数据包嗅探这类捕获技术运行在非常低的层级，可能很难解释应用程序接收到的数据。像 Wireshark 这样的工具无疑有帮助，但如果你分析的是自定义协议，可能很难在不直接与其交互的情况下轻松拆解该协议。
- en: Passive capture also doesn’t always make it easy to modify the traffic an application
    produces. Modifying traffic isn’t always necessary, but it’s useful when you encounter
    encrypted protocols, want to disable compression, or need to change the traffic
    for exploitation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 被动捕获也不总是容易修改应用程序产生的流量。修改流量并非总是必要的，但在遇到加密协议、需要禁用压缩，或需要改变流量以进行利用时，这种修改是很有用的。
- en: When analyzing traffic and injecting new packets doesn’t yield results, switch
    tactics and try using active capture techniques.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当分析流量并注入新数据包没有得到结果时，可以切换战术，尝试使用主动捕获技术。
- en: '**Active Network Traffic Capture**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**主动网络流量捕获**'
- en: Active capture differs from passive in that you’ll try to influence the flow
    of the traffic, usually by using a man-in-the-middle attack on the network communication.
    As shown in [Figure 2-7](../Text/ch02.xhtml#ch2fig7), the device capturing traffic
    usually sits between the client and server applications, acting as a bridge. This
    approach has several advantages, including the ability to modify traffic and disable
    features like encryption or compression, which can make it easier to analyze and
    exploit a network protocol.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 主动捕获与被动捕获不同，它试图通过中间人攻击来影响流量的流向，通常是通过网络通信中的中间人攻击。正如[图 2-7](../Text/ch02.xhtml#ch2fig7)所示，捕获流量的设备通常位于客户端和服务器应用程序之间，充当桥梁。这种方法有几个优点，包括能够修改流量和禁用像加密或压缩等功能，这些都能让分析和利用网络协议变得更容易。
- en: '![image](../Images/f02-07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-07.jpg)'
- en: '*Figure 2-7: A man-in-the-middle proxy*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：中间人代理*'
- en: A disadvantage of this approach is that it’s usually more difficult because
    you need to reroute the application’s traffic through your active capture system.
    Active capture can also have unintended, undesirable effects. For example, if
    you change the network address of the server or client to the proxy, this can
    cause confusion, resulting in the application sending traffic to the wrong place.
    Despite these issues, active capture is probably the most valuable technique for
    analyzing and exploiting application network protocols.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是通常更困难，因为你需要通过你的主动捕获系统重新路由应用程序的流量。主动捕获也可能带来一些意想不到的、不希望出现的效果。例如，如果你将服务器或客户端的网络地址更改为代理的地址，这可能会导致混乱，进而导致应用程序将流量发送到错误的地方。尽管有这些问题，主动捕获可能是分析和利用应用程序网络协议时最有价值的技术。
- en: '**Network Proxies**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络代理**'
- en: The most common way to perform a man-in-the-middle attack on network traffic
    is to force the application to communicate through a proxy service. In this section,
    I’ll explain the relative advantages and disadvantages of some of the common proxy
    types you can use to capture traffic, analyze that data, and exploit a network
    protocol. I’ll also show you how to get traffic from typical client applications
    into a proxy.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对网络流量执行中间人攻击最常见的方式是强制应用程序通过代理服务进行通信。在本节中，我将解释一些常见代理类型的相对优缺点，你可以使用这些代理捕获流量、分析数据，并利用网络协议。我还会展示如何将典型客户端应用程序的流量引导到代理中。
- en: '***Port-Forwarding Proxy***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***端口转发代理***'
- en: Port forwarding is the easiest way to proxy a connection. Just set up a listening
    server (TCP or UDP) and wait for a new connection. When that new connection is
    made to the proxy server, it will open a forwarding connection to the real service
    and logically connect the two, as shown in [Figure 2-8](../Text/ch02.xhtml#ch2fig8).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 端口转发是代理连接最简单的方法。只需设置一个监听服务器（TCP 或 UDP），然后等待新的连接。当新的连接建立到代理服务器时，它会打开一个到实际服务的转发连接，并逻辑上将两者连接起来，如[图
    2-8](../Text/ch02.xhtml#ch2fig8)所示。
- en: '![image](../Images/f02-08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-08.jpg)'
- en: '*Figure 2-8: Overview of a TCP port-forwarding proxy*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：TCP 端口转发代理概览*'
- en: '**Simple Implementation**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**简单实现**'
- en: To create our proxy, we’ll use the built-in TCP port forwarder included with
    the Canape Core libraries. Place the code in [Listing 2-4](../Text/ch02.xhtml#ch2list4)
    into a C# script file, changing `LOCALPORT` ➋, `REMOTEHOST` ➌, and `REMOTEPORT`
    ➍ to appropriate values for your network.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的代理，我们将使用 Canape Core 库中内置的 TCP 端口转发器。将[清单 2-4](../Text/ch02.xhtml#ch2list4)中的代码放入一个
    C# 脚本文件，并将 `LOCALPORT` ➋、`REMOTEHOST` ➌ 和 `REMOTEPORT` ➍更改为适合您网络的值。
- en: PortFormat
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: PortFormat
- en: Proxy.csx
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Proxy.csx
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 2-4: A simple TCP port-forwarding proxy example*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-4：一个简单的 TCP 端口转发代理示例*'
- en: This very simple script creates an instance of a `FixedProxyTemplate` ➊. Canape
    Core works on a template model, although if required you can get down and dirty
    with the low-level network configuration. The script configures the template with
    the desired local and remote network information. The template is used to create
    a service instance at ➎; you can think of documents in the framework acting as
    templates for services. The newly created service is then started; at this point,
    the network connections are configured. After waiting for a key press, the service
    is stopped at ➏. Then all the captured packets are written to the console using
    the `WritePackets()` method ➐.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的脚本创建了一个 `FixedProxyTemplate` ➊ 的实例。Canape Core 基于模板模型工作，虽然如果需要，您可以深入到底层网络配置。脚本使用所需的本地和远程网络信息来配置模板。模板用于在
    ➎ 创建服务实例；你可以将框架中的文档视为服务的模板。然后启动新创建的服务；此时，网络连接已配置好。在等待按键后，服务在 ➏ 被停止。然后，所有捕获的包将使用
    `WritePackets()` 方法 ➐ 写入控制台。
- en: Running this script should bind an instance of our forwarding proxy to the `LOCALPORT`
    number for the localhost interface only. When a new TCP connection is made to
    that port, the proxy code should establish a new connection to `REMOTEHOST` with
    TCP port `REMOTEPORT` and link the two connections together.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本应将我们的转发代理实例仅绑定到本地接口的 `LOCALPORT` 端口。当建立新的 TCP 连接到该端口时，代理代码应建立到 `REMOTEHOST`
    的新连接，使用 TCP 端口 `REMOTEPORT`，并将这两个连接链接在一起。
- en: '**WARNING**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Binding a proxy to all network addresses can be risky from a security perspective
    because proxies written for testing protocols rarely implement robust security
    mechanisms. Unless you have complete control over the network you are connected
    to or have no choice, only bind your proxy to the local loopback interface. In
    [Listing 2-4](../Text/ch02.xhtml#ch2list4), the default is `LOCALHOST`; to bind
    to all interfaces, set the `AnyBind` property to `true`.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*将代理绑定到所有网络地址从安全角度来看可能是有风险的，因为用于测试协议的代理通常不会实现强大的安全机制。除非您完全控制所连接的网络或别无选择，否则请只将代理绑定到本地回环接口。在[清单
    2-4](../Text/ch02.xhtml#ch2list4)中，默认值是 `LOCALHOST`；要绑定到所有接口，请将 `AnyBind` 属性设置为
    `true`。*'
- en: '**Redirecting Traffic to Proxy**'
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将流量重定向到代理**'
- en: With our simple proxy application complete, we now need to direct our application
    traffic through it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成简单的代理应用后，我们现在需要将应用流量通过它进行转发。
- en: 'For a web browser, it’s simple enough: to capture a specific request, instead
    of using the URL form *http://www.domain.com/resource*, use *http://**localhost:localport**/resource*,
    which pushes the request through your port-forwarding proxy.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网页浏览器来说，操作非常简单：要捕获特定的请求，使用 *http://localhost:localport/resource* 代替 *http://www.domain.com/resource*，这样请求就会通过你的端口转发代理。
- en: 'Other applications are trickier: you might have to dig into the application’s
    configuration settings. Sometimes, the only setting an application allows you
    to change is the destination IP address. But this can lead to a chicken-and-egg
    scenario where you don’t know which TCP or UDP ports the application might be
    using with that address, especially if the application contains complex functions
    running over multiple different service connections. This occurs with *Remote
    Procedure Call (RPC)* protocols, such as the Common Object Request Broker Architecture
    (CORBA). This protocol usually makes an initial network connection to a broker,
    which acts as a directory of available services. A second connection is then made
    to the requested service over an instance-specific TCP port.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 其他应用程序则更棘手：你可能需要深入到应用程序的配置设置。有时，应用程序允许你更改的唯一设置是目标IP地址。但这可能会导致一个鸡和蛋的问题，你不知道应用程序可能会使用哪些TCP或UDP端口，特别是当应用程序包含多个不同服务连接运行的复杂功能时。这种情况通常发生在
    *远程过程调用（RPC）* 协议中，例如通用对象请求代理架构（CORBA）。该协议通常首先与代理建立网络连接，代理充当可用服务的目录。然后，第二个连接通过特定实例的TCP端口与请求的服务建立连接。
- en: In this case, a good approach is to use as many network-connected features of
    the application as possible while monitoring it using passive capture techniques.
    By doing so, you should uncover the connections that application typically makes,
    which you can then easily replicate with forwarding proxies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一种好的方法是尽可能使用应用程序的所有网络连接功能，同时使用被动捕获技术进行监控。通过这样做，你应该能够发现该应用程序通常会建立的连接，然后你可以使用转发代理轻松地复制这些连接。
- en: If the application doesn’t support changing its destination, you need to be
    a bit more creative. If the application resolves the destination server address
    via a hostname, you have more options. You could set up a custom DNS server that
    responds to name requests with the IP address of your proxy. Or you could use
    the *hosts* file facility, which is available on most operating systems, including
    Windows, assuming you have control over system files on the device the application
    is running on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序不支持更改其目标地址，你需要更具创意。如果应用程序通过主机名解析目标服务器地址，你会有更多的选择。你可以设置一个自定义的DNS服务器，响应名称请求并返回代理的IP地址。或者你可以使用大多数操作系统（包括Windows）上都可用的
    *hosts* 文件功能，前提是你有权限控制应用程序运行设备上的系统文件。
- en: During hostname resolving, the OS (or the resolving library) first refers to
    the *hosts* file to see if any local entries exist for that name, making a DNS
    request only if one is not found. For example, the hosts file in [Listing 2-5](../Text/ch02.xhtml#ch2list5)
    redirects the hostnames *[www.badgers.com](http://www.badgers.com)* and *[www.domain.com](http://www.domain.com)*
    to *localhost*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机名解析过程中，操作系统（或解析库）首先会参考 *hosts* 文件，查看该名称是否有本地条目，如果没有找到，则才会发起DNS请求。例如，[清单 2-5](../Text/ch02.xhtml#ch2list5)中的hosts文件将主机名
    *[www.badgers.com](http://www.badgers.com)* 和 *[www.domain.com](http://www.domain.com)*
    重定向到 *localhost*。
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 2-5: An example* hosts *file*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-5：一个示例* 主机 *文件*'
- en: The standard location of the *hosts* file on Unix-like OSes is */etc/hosts*,
    whereas on Windows it is *C:\Windows\System32\Drivers\etc\hosts*. Obviously, you’ll
    need to replace the path to the Windows folder as necessary for your environment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在类Unix操作系统中，*hosts* 文件的标准位置是 */etc/hosts*，而在Windows中则是 *C:\Windows\System32\Drivers\etc\hosts*。显然，你需要根据你的环境，适当替换Windows文件夹的路径。
- en: '**NOTE**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some antivirus and security products track changes to the system’s hosts,
    because changes are a sign of malware. You might need to disable the product’s
    protection if you want to change the* hosts *file.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些杀毒软件和安全产品会跟踪系统的hosts文件变化，因为这些变化是恶意软件的迹象。如果你想修改* hosts *文件，可能需要禁用该产品的保护。*'
- en: '**Advantages of a Port-Forwarding Proxy**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**端口转发代理的优势**'
- en: 'The main advantage of a port-forwarding proxy is its simplicity: you wait for
    a connection, open a new connection to the original destination, and then pass
    traffic back and forth between the two. There is no protocol associated with the
    proxy to deal with, and no special support is required by the application from
    which you are trying to capture traffic.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 端口转发代理的主要优势在于其简单性：你等待连接，打开到原始目标的新连接，然后在两者之间传递流量。代理没有与之相关的协议需要处理，也不需要应用程序提供特别的支持来捕获流量。
- en: A port-forwarding proxy is also the primary way of proxying UDP traffic; because
    it isn’t connection oriented, the implementation of a forwarder for UDP is considerably
    simpler.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 端口转发代理也是代理UDP流量的主要方式；由于它不是面向连接的，UDP转发器的实现相对简单。
- en: '**Disadvantages of a Port-Forwarding Proxy**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**端口转发代理的缺点**'
- en: Of course, the simplicity of a port-forwarding proxy also contributes to its
    disadvantages. Because you are only forwarding traffic from a listening connection
    to a single destination, multiple instances of a proxy would be required if the
    application uses multiple protocols on different ports.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，端口转发代理的简单性也带来了它的缺点。因为你只是将流量从一个监听连接转发到一个单一的目的地，如果应用程序在不同端口上使用多种协议，那么就需要多个代理实例。
- en: For example, consider an application that has a single hostname or IP address
    for its destination, which you can control either directly by changing it in the
    application’s configuration or by spoofing the hostname. The application then
    attempts to connect to TCP ports 443 and 1234\. Because you can control the address
    it connects to, not the ports, you need to set up forwarding proxies for both,
    even if you are only interested in the traffic running over port 1234.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个应用程序只有一个主机名或IP地址作为目标，你可以直接通过更改应用程序配置或伪造主机名来控制该地址。然后该应用程序尝试连接TCP端口443和1234。因为你能控制它连接的地址，而不是端口，所以你需要为两个端口都设置转发代理，即使你只关心通过端口1234传输的流量。
- en: This proxy can also make it difficult to handle more than one connection to
    a well-known port. For example, if the port-forwarding proxy is listening on port
    1234 and making a connection to *[www.domain.com](http://www.domain.com)* port
    1234, only redirected traffic for the original domain will work as expected. If
    you wanted to also redirect *[www.badgers.com](http://www.badgers.com)*, things
    would be more difficult. You can mitigate this if the application supports specifying
    the destination address and port or by using other techniques, such as Destination
    Network Address Translation (DNAT), to redirect specific connections to unique
    forwarding proxies. ([Chapter 5](../Text/ch05.xhtml#ch05) contains more details
    on DNAT as well as numerous other more advanced network capture techniques.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代理还可能使得处理与一个知名端口的多个连接变得困难。例如，如果端口转发代理正在监听端口1234并与*[www.domain.com](http://www.domain.com)*的1234端口建立连接，只有原始域名的重定向流量才会按预期工作。如果你还想重定向*[www.badgers.com](http://www.badgers.com)*，情况就会更复杂。如果应用程序支持指定目标地址和端口，或者使用其他技术，如目标网络地址转换（DNAT），可以将特定连接重定向到独特的转发代理，那么可以缓解这一问题。（[第5章](../Text/ch05.xhtml#ch05)包含了更多关于DNAT以及其他高级网络捕获技术的详细信息。）
- en: Additionally, the protocol might use the destination address for its own purposes.
    For example, the Host header in HyperText Transport Protocol (HTTP) can be used
    for Virtual Host decisions, which might make a port-forwarded protocol work differently,
    or not at all, from a redirected connection. Still, at least for HTTP, I will
    discuss a workaround for this limitation in “[Reverse HTTP Proxy](../Text/ch02.xhtml#ch00lev1sec42)”
    on [page 32](../Text/ch02.xhtml#page_32).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，协议可能会将目的地地址用于自身的目的。例如，超文本传输协议（HTTP）中的Host头可以用于虚拟主机决策，这可能会导致端口转发的协议与重定向连接的行为不同，甚至完全无法工作。不过，至少对于HTTP，我将在“[反向HTTP代理](../Text/ch02.xhtml#ch00lev1sec42)”一节中讨论这个限制的解决方法，见[第32页](../Text/ch02.xhtml#page_32)。
- en: '***SOCKS Proxy***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SOCKS代理***'
- en: Think of a SOCKS proxy as a port-forwarding proxy on steroids. Not only does
    it forward TCP connections to the desired network location, but all new connections
    start with a simple handshake protocol that informs the proxy of the ultimate
    destination rather than having it fixed. It can also support listening connections,
    which is important for protocols like File Transfer Protocol (FTP) that need to
    open new local ports for the server to send data to. [Figure 2-9](../Text/ch02.xhtml#ch2fig9)
    provides an overview of SOCKS proxy.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以把SOCKS代理看作是增强版的端口转发代理。它不仅将TCP连接转发到目标网络位置，而且所有新的连接都通过一个简单的握手协议来启动，告知代理最终的目标位置，而不是固定的目标。它还支持监听连接，这对于像文件传输协议（FTP）这样的协议非常重要，因为FTP需要为服务器打开新的本地端口以发送数据。[图2-9](../Text/ch02.xhtml#ch2fig9)提供了SOCKS代理的概述。
- en: '![image](../Images/f02-09.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-09.jpg)'
- en: '*Figure 2-9: Overview of SOCKS proxy*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-9：SOCKS代理概述*'
- en: Three common variants of the protocol are currently in use—SOCKS 4, 4a, and
    5—and each has its own use. Version 4 is the most commonly supported version of
    the protocol; however, it supports only IPv4 connections, and the destination
    address must be specified as a 32-bit IP address. An update to version 4, version
    4a allowed connections by hostname (which is useful if you don’t have a DNS server
    that can resolve IP addresses). Version 5 introduced hostname support, IPv6, UDP
    forwarding, and improved authentication mechanisms; it is also the only one specified
    in an RFC (1928).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当前有三种常见的协议变体——SOCKS 4、4a和5——每种都有其独特的用途。版本4是协议中最常支持的版本；然而，它仅支持IPv4连接，且目标地址必须指定为32位IP地址。版本4的更新版，版本4a，允许通过主机名连接（如果没有DNS服务器能解析IP地址，这非常有用）。版本5引入了主机名支持、IPv6、UDP转发以及改进的身份验证机制；它也是唯一在RFC（1928）中指定的版本。
- en: As an example, a client will send the request shown in [Figure 2-10](../Text/ch02.xhtml#ch2fig10)
    to establish a SOCKS connection to IP address 10.0.0.1 on port 12345\. The `USERNAME`
    component is the only method of authentication in SOCKS version 4 (not especially
    secure, I know). `VER` represents the version number, which in this case is 4\.
    `CMD` indicates it wants to connect out (binding to an address is `CMD` 2), and
    the TCP port and address are specified in binary form.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，客户端将发送如[图2-10](../Text/ch02.xhtml#ch2fig10)所示的请求，以建立与IP地址10.0.0.1、端口12345的SOCKS连接。`USERNAME`组件是SOCKS版本4中唯一的身份验证方法（我知道，这不算特别安全）。`VER`表示版本号，在此案例中为4。`CMD`表示它想要连接外部（绑定到地址是`CMD`
    2），TCP端口和地址以二进制形式指定。
- en: '![image](../Images/f02-10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-10.jpg)'
- en: '*Figure 2-10: A SOCKS version 4 request*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-10：SOCKS版本4请求*'
- en: If the connection is successful, it will send back the appropriate response,
    as shown in [Figure 2-11](../Text/ch02.xhtml#ch2fig11). The `RESP` field indicates
    the status of the response; the TCP port and address fields are only significant
    for binding requests. Then the connection becomes transparent and the client and
    server directly negotiate with each other; the proxy server only acts to forward
    traffic in either direction.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接成功，它将返回适当的响应，如[图2-11](../Text/ch02.xhtml#ch2fig11)所示。`RESP`字段表示响应的状态；TCP端口和地址字段仅对绑定请求有意义。然后，连接变得透明，客户端和服务器直接进行协商；代理服务器只在两个方向上传递流量。
- en: '![image](../Images/f02-11.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-11.jpg)'
- en: '*Figure 2-11: A SOCKS version 4 successful response*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-11：SOCKS版本4成功响应*'
- en: '**Simple Implementation**'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**简单实现**'
- en: The Canape Core libraries have built-in support for SOCKS 4, 4a, and 5\. Place
    [Listing 2-6](../Text/ch02.xhtml#ch2list6) into a C# script file, changing `LOCALPORT`
    ➋ to the local TCP port you want to listen on for the SOCKS proxy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Canape Core库内置了对SOCKS 4、4a和5的支持。将[清单2-6](../Text/ch02.xhtml#ch2list6)放入C#脚本文件中，将`LOCALPORT`
    ➋改为你希望监听SOCKS代理的本地TCP端口。
- en: SocksProxy.csx
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: SocksProxy.csx
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 2-6: A simple SOCKS proxy example*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-6：一个简单的SOCKS代理示例*'
- en: '[Listing 2-6](../Text/ch02.xhtml#ch2list6) follows the same pattern established
    with the TCP port-forwarding proxy in [Listing 2-4](../Text/ch02.xhtml#ch2list4).
    But in this case, the code at ➊ creates a SOCKS proxy template. The rest of the
    code is exactly the same.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单2-6](../Text/ch02.xhtml#ch2list6)遵循与[清单2-4](../Text/ch02.xhtml#ch2list4)中TCP端口转发代理相同的模式。但在这种情况下，➊处的代码创建了一个SOCKS代理模板。其余的代码完全相同。'
- en: '**Redirecting Traffic to Proxy**'
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将流量重定向到代理**'
- en: To determine a way of pushing an application’s network traffic through a SOCKS
    proxy, look in the application first. For example, when you open the proxy settings
    in Mozilla Firefox, the dialog in [Figure 2-12](../Text/ch02.xhtml#ch2fig12) appears.
    From there, you can configure Firefox to use a SOCKS proxy.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定如何通过SOCKS代理转发应用程序的网络流量，首先查看该应用程序。例如，当你在Mozilla Firefox中打开代理设置时，[图2-12](../Text/ch02.xhtml#ch2fig12)对话框会出现。在这里，你可以配置Firefox使用SOCKS代理。
- en: '![image](../Images/f02-12.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-12.jpg)'
- en: '*Figure 2-12: Firefox proxy configuration*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-12：Firefox代理配置*'
- en: But sometimes SOCKS support is not immediately obvious. If you are testing a
    Java application, the Java Runtime accepts command line parameters that enable
    SOCKS support for any outbound TCP connection. For example, consider the very
    simple Java application in [Listing 2-7](../Text/ch02.xhtml#ch2list7), which connects
    to IP address 192.168.10.1 on port 5555.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时候SOCKS支持并不显而易见。如果你正在测试一个Java应用程序，Java运行时接受命令行参数，这些参数可以为任何外发的TCP连接启用SOCKS支持。例如，考虑[列表
    2-7](../Text/ch02.xhtml#ch2list7)中的这个非常简单的Java应用程序，它连接到IP地址192.168.10.1的5555端口。
- en: SocketClient.java
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SocketClient.java
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 2-7: A simple Java TCP client*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-7：一个简单的Java TCP客户端*'
- en: 'When you run this compiled program normally, it would do as you expect. But
    if on the command line you pass two special system properties, `socksProxyHost`
    and `socksProxyPort`, you can specify a SOCKS proxy for any TCP connection:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正常运行这个编译后的程序时，它会按照预期的方式工作。但如果在命令行中传递两个特殊的系统属性，`socksProxyHost` 和 `socksProxyPort`，你可以为任何TCP连接指定一个SOCKS代理：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will make the TCP connection through the SOCKS proxy on localhost port
    1080.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会使TCP连接通过本地主机的SOCKS代理，端口为1080。
- en: Another place to look to determine how to push an application’s network traffic
    through a SOCKS proxy is the OS’s default proxy. On macOS, navigate to **System
    Preferences** ▸ **Network** ▸ **Advanced** ▸ **Proxies**. The dialog shown in
    [Figure 2-13](../Text/ch02.xhtml#ch2fig13) appears. From here, you can configure
    a system-wide SOCKS proxy or general proxies for other protocols. This won’t always
    work, but it’s an easy option worth trying out.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以查看的地方来确定如何将应用程序的网络流量通过SOCKS代理转发的是操作系统的默认代理。在macOS中，导航到**系统偏好设置** ▸ **网络**
    ▸ **高级** ▸ **代理**。此时将会出现[图 2-13](../Text/ch02.xhtml#ch2fig13)所示的对话框。在这里，你可以配置一个系统范围的SOCKS代理或为其他协议配置通用代理。虽然这种方法并不总是有效，但它是一个值得尝试的简单选项。
- en: In addition, if the application just will not support a SOCKS proxy natively,
    certain tools will add that function to arbitrary applications. These tools range
    from free and open source tools, such as Dante (*[https://www.inet.no/dante/](https://www.inet.no/dante/)*)
    on Linux, to commercial tools, such as Proxifier (*[https://www.proxifier.com/](https://www.proxifier.com/)*),
    which runs on Windows and macOS. In one way or another, they all inject into the
    application to add SOCKS support and modify the operation of the socket functions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果应用程序原生不支持SOCKS代理，某些工具可以将该功能添加到任意应用程序中。这些工具从免费的开源工具（如Linux上的Dante（*[https://www.inet.no/dante/](https://www.inet.no/dante/)）*）到商业工具（如Proxifier（*[https://www.proxifier.com/](https://www.proxifier.com/)*），它们运行在Windows和macOS上）。无论哪种方式，它们都会注入到应用程序中以添加SOCKS支持，并修改套接字功能的操作。
- en: '![image](../Images/f02-13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-13.jpg)'
- en: '*Figure 2-13: A proxy configuration dialog on macOS*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-13：macOS 上的代理配置对话框*'
- en: '**Advantages of a SOCKS Proxy**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SOCKS代理的优点**'
- en: The clear advantage of using a SOCKS proxy, as opposed to using a simple port
    forwarder, is that it should capture all TCP connections (and potentially some
    UDP if you are using SOCKS version 5) that an application makes. This is an advantage
    as long as the OS socket layer is wrapped to effectively push all connections
    through the proxy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SOCKS代理的明显优势，相比于使用简单的端口转发器，是它应该捕获应用程序所做的所有TCP连接（如果你使用的是SOCKS版本5，可能还包括一些UDP）。只要操作系统的套接字层被包装起来，能够有效地将所有连接通过代理转发，这就是一个优势。
- en: A SOCKS proxy also generally preserves the destination of the connection from
    the point of view of the client application. Therefore, if a client application
    sends in-band data that refers to its endpoint, then the endpoint will be what
    the server expects. However, this does not preserve the source address. Some protocols,
    such as FTP, assume they can request ports to be opened on the originating client.
    The SOCKS protocol provides a facility for binding listening connections but adds
    to the complexity of the implementation. This makes capture and analysis more
    difficult because you must consider many different streams of data to and from
    a server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: SOCKS代理通常会从客户端应用程序的角度保留连接的目标。因此，如果客户端应用程序发送包含其端点的带内数据，那么端点将是服务器所期望的。然而，这并不会保留源地址。一些协议，例如FTP，假设它们可以请求在源客户端上打开端口。SOCKS协议提供了一个绑定监听连接的功能，但这增加了实现的复杂性。这使得捕获和分析变得更加困难，因为你必须考虑许多不同的数据流进出服务器。
- en: '**Disadvantages of a SOCKS Proxy**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SOCKS代理的缺点**'
- en: The main disadvantage of SOCKS is that support can be inconsistent between applications
    and platforms. The Windows system proxy supports only SOCKS version 4 proxies,
    which means it will resolve only local hostnames. It does not support IPv6 and
    does not have a robust authentication mechanism. Generally, you get better support
    by using a SOCKS tool to add to an existing application, but this doesn’t always
    work well.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SOCKS 的主要缺点是它在不同应用程序和平台之间的支持可能不一致。Windows 系统代理仅支持 SOCKS 版本 4 代理，这意味着它只能解析本地主机名。它不支持
    IPv6，也没有健壮的身份验证机制。通常，使用 SOCKS 工具添加到现有应用程序中会获得更好的支持，但这并不总是有效。
- en: '***HTTP Proxies***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***HTTP 代理***'
- en: HTTP powers the World Wide Web as well as a myriad of web services and RESTful
    protocols. [Figure 2-14](../Text/ch02.xhtml#ch2fig14) provides an overview of
    an HTTP proxy. The protocol can also be co-opted as a transport mechanism for
    non-web protocols, such as Java’s Remote Method Invocation (RMI) or Real Time
    Messaging Protocol (RTMP), because it can tunnel though the most restrictive firewalls.
    It is important to understand how HTTP proxying works in practice, because it
    will almost certainly be useful for protocol analysis, even if a web service is
    not being tested. Existing web application–testing tools rarely do an ideal job
    when HTTP is being used out of its original environment. Sometimes rolling your
    own implementation of an HTTP proxy is the only solution.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 驱动着万维网以及无数的网页服务和 RESTful 协议。[图 2-14](../Text/ch02.xhtml#ch2fig14) 提供了 HTTP
    代理的概览。该协议还可以作为传输机制，支持非网页协议，如 Java 的远程方法调用（RMI）或实时消息协议（RTMP），因为它可以穿透最严格的防火墙。了解
    HTTP 代理如何在实践中工作非常重要，因为它几乎肯定对协议分析有所帮助，即使没有进行网页服务的测试。现有的网页应用测试工具在 HTTP 超出其原始环境使用时，通常无法做到理想的效果。有时，自己实现一个
    HTTP 代理是唯一的解决方案。
- en: '![image](../Images/f02-14.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f02-14.jpg)'
- en: '*Figure 2-14: Overview of an HTTP proxy*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-14：HTTP 代理概览*'
- en: The two main types of HTTP proxy are the forwarding proxy and the reverse proxy.
    Each has advantages and disadvantages for the prospective network protocol analyzer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 代理的两种主要类型是转发代理和反向代理。对于潜在的网络协议分析师来说，每种类型都有其优缺点。
- en: '***Forwarding an HTTP Proxy***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***转发 HTTP 代理***'
- en: 'The HTTP protocol is specified in RFC 1945 for version 1.0 and RFC 2616 for
    version 1.1; both versions provide a simple mechanism for proxying HTTP requests.
    For example, HTTP 1.1 specifies that the first full line of a request, the *request
    line*, has the following format:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 协议在 RFC 1945 中为版本 1.0 进行了规范，在 RFC 2616 中为版本 1.1 进行了规范；这两个版本都提供了一个简单的 HTTP
    请求代理机制。例如，HTTP 1.1 规定，请求的第一行，也就是 *请求行*，具有以下格式：
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The method ➊ specifies what to do in that request using familiar verbs, such
    as `GET`, `POST`, and `HEAD`. In a proxy request, this does not change from a
    normal HTTP connection. The path ➋ is where the proxy request gets interesting.
    As is shown, an absolute path indicates the resource that the method will act
    upon. Importantly, the path can also be an absolute Uniform Request Identifier
    (URI). By specifying an absolute URI, a proxy server can establish a new connection
    to the destination, forwarding all traffic on and returning data back to the client.
    The proxy can even manipulate the traffic, in a limited fashion, to add authentication,
    hide version 1.0 servers from 1.1 clients, and add transfer compression along
    with all manner of other things. However, this flexibility comes with a cost:
    the proxy server must be able to process the HTTP traffic, which adds massive
    complexity. For example, the following request line accesses an image resource
    on a remote server through a proxy:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 ➊ 使用熟悉的动词，如 `GET`、`POST` 和 `HEAD`，指定在请求中应该执行的操作。在代理请求中，这一点与普通 HTTP 连接无异。路径
    ➋ 是代理请求变得有趣的地方。如所示，绝对路径指示方法将作用于的资源。重要的是，路径也可以是绝对的统一资源标识符（URI）。通过指定绝对 URI，代理服务器可以建立与目标的全新连接，转发所有流量并将数据返回给客户端。代理甚至可以在一定程度上操控流量，添加身份验证、将
    1.0 版本的服务器隐藏于 1.1 客户端背后，并增加传输压缩及其他种种功能。然而，这种灵活性也带来了成本：代理服务器必须能够处理 HTTP 流量，这增加了巨大的复杂性。例如，以下请求行通过代理访问远程服务器上的图像资源：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You, the attentive reader, might have identified an issue with this approach
    to proxying HTTP communication. Because the proxy must be able to access the underlying
    HTTP protocol, what about HTTPS, which transports HTTP over an encrypted TLS connection?
    You could break out the encrypted traffic; however, in a normal environment, it
    is unlikely the HTTP client would trust whatever certificate you provided. Also,
    TLS is intentionally designed to make it virtually impossible to use a man-in-the-middle
    attack any other way. Fortunately, this was anticipated, and RFC 2817 provides
    two solutions: it includes the ability to upgrade an HTTP connection to encryption
    (there is no need for more details here), and more importantly for our purposes,
    it specifies the `CONNECT` HTTP method for creating transparent, tunneled connections
    over HTTP proxies. As an example, a web browser that wants to establish a proxy
    connection to an HTTPS site can issue the following request to the proxy:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你，细心的读者，可能已经发现了这种代理 HTTP 通信方法中的一个问题。因为代理必须能够访问底层的 HTTP 协议，那么处理传输加密的 HTTPS 怎么办呢？你可以解密加密流量；然而，在正常环境下，HTTP
    客户端不太可能信任你提供的任何证书。而且，TLS 是故意设计的，几乎不可能通过其他方式进行中间人攻击。幸运的是，这一点早已被预见到，RFC 2817 提供了两种解决方案：它包括将
    HTTP 连接升级为加密的能力（此处不再详细说明），更重要的是，它为我们的问题指定了 `CONNECT` HTTP 方法，用于通过 HTTP 代理创建透明的隧道连接。举个例子，一个想要建立与
    HTTPS 网站的代理连接的网页浏览器，可以向代理发出以下请求：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the proxy accepts this request, it will make a new TCP connection to the
    server. On success, it should return the following response:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代理接受此请求，它将与服务器建立一个新的 TCP 连接。成功后，它应返回以下响应：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The TCP connection to the proxy now becomes transparent, and the browser is
    able to establish the negotiated TLS connection without the proxy getting in the
    way. Of course, it’s worth noting that the proxy is unlikely to verify that TLS
    is actually being used on this connection. It could be any protocol you like,
    and this fact is abused by some applications to tunnel out their own binary protocols
    through HTTP proxies. For this reason, it’s common to find deployments of HTTP
    proxies restricting the ports that can be tunneled to a very limited subset.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代理的 TCP 连接变得透明，浏览器能够建立协商后的 TLS 连接，而不会被代理阻碍。当然，值得注意的是，代理不太可能验证此连接上是否实际使用了
    TLS。它可以是任何协议，而这一点被一些应用程序滥用，通过 HTTP 代理隧道它们自己的二进制协议。因此，通常会发现 HTTP 代理的部署会限制可以隧道的端口，只允许非常有限的子集。
- en: '**Simple Implementation**'
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**简单实现**'
- en: Once again, the Canape Core libraries include a simple implementation of an
    HTTP proxy. Unfortunately, they don’t support the `CONNECT` method to create a
    transparent tunnel, but it will suffice for demonstration purposes. Place [Listing
    2-8](../Text/ch02.xhtml#ch2list8) into a C# script file, changing `LOCALPORT`
    ➋ to the local TCP port you want to listen on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，Canape 核心库包含一个简单的 HTTP 代理实现。不幸的是，它们不支持 `CONNECT` 方法来创建透明隧道，但这对于演示目的已经足够了。将[示例
    2-8](../Text/ch02.xhtml#ch2list8)放入 C# 脚本文件中，将 `LOCALPORT` ➋ 更改为你想要监听的本地 TCP 端口。
- en: HttpProxy.csx
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: HttpProxy.csx
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 2-8: A simple forward HTTP proxy example*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-8：一个简单的正向 HTTP 代理示例*'
- en: Here we created a forward HTTP Proxy. The code at line ➊ is again only a slight
    variation from the previous examples, creating an HTTP proxy template.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个正向 HTTP 代理。第 ➊ 行的代码与之前的示例几乎相同，用于创建 HTTP 代理模板。
- en: '**Redirecting Traffic to Proxy**'
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将流量重定向到代理**'
- en: As with SOCKS proxies, the first port of call will be the application. It’s
    rare for an application that uses the HTTP protocol to not have some sort of proxy
    configuration. If the application has no specific settings for HTTP proxy support,
    try the OS configuration, which is in the same place as the SOCKS proxy configuration.
    For example, on Windows you can access the system proxy settings by selecting
    Control Panel ▸ Internet Options ▸ Connections ▸ LAN Settings.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SOCKS 代理类似，首要步骤将是应用程序。使用 HTTP 协议的应用程序不太可能没有某种形式的代理配置。如果应用程序没有专门的 HTTP 代理支持设置，可以尝试操作系统的配置，它与
    SOCKS 代理配置位于同一位置。例如，在 Windows 上，你可以通过选择控制面板 ▸ Internet 选项 ▸ 连接 ▸ 局域网设置来访问系统代理设置。
- en: Many command line utilities on Unix-like systems, such as `curl`, `wget`, and
    `apt`, also support setting HTTP proxy configuration through environment variables.
    If you set the environment variable `http_proxy` to the URL for the HTTP proxy
    to use—for example, *http://localhost:3128*—the application will use it. For secure
    traffic, you can also use *https_proxy*. Some implementations allow special URL
    schemes, such as *socks4://*, to specify that you want to use a SOCKS proxy.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 系统上的许多命令行工具，如`curl`、`wget`和`apt`，也支持通过环境变量设置 HTTP 代理配置。如果你将环境变量`http_proxy`设置为要使用的
    HTTP 代理的 URL，例如 *http://localhost:3128*，应用程序就会使用它。对于安全流量，你还可以使用 *https_proxy*。一些实现允许特殊的
    URL 方案，如 *socks4://*，来指定你希望使用 SOCKS 代理。
- en: '**Advantages of a Forwarding HTTP Proxy**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**转发 HTTP 代理的优点**'
- en: The main advantage of a forwarding HTTP proxy is that if the application uses
    the HTTP protocol exclusively, all it needs to do to add proxy support is to change
    the absolute path in the Request Line to an absolute URI and send the data to
    a listening proxy server. Also, only a few applications that use the HTTP protocol
    for transport do not already support proxying.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 转发 HTTP 代理的主要优点是，如果应用程序仅使用 HTTP 协议，它所需要做的就是将请求行中的绝对路径改为绝对 URI，并将数据发送到一个监听的代理服务器。并且，只有少数几款使用
    HTTP 协议进行传输的应用程序不支持代理。
- en: '**Disadvantages of a Forwarding HTTP Proxy**'
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**转发 HTTP 代理的缺点**'
- en: The requirement of a forwarding HTTP proxy to implement a full HTTP parser to
    handle the many idiosyncrasies of the protocol adds significant complexity; this
    complexity might introduce processing issues or, in the worst case, security vulnerabilities.
    Also, the addition of the proxy destination within the protocol means that it
    can be more difficult to retrofit HTTP proxy support to an existing application
    through external techniques, unless you convert connections to use the `CONNECT`
    method (which even works for unencrypted HTTP).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 转发 HTTP 代理要求实现一个完整的 HTTP 解析器，以处理协议中的许多特性，这增加了复杂性；这种复杂性可能导致处理问题，甚至在最坏的情况下引发安全漏洞。此外，协议中添加代理目的地意味着，通过外部技术将
    HTTP 代理支持集成到现有应用程序中可能会变得更加困难，除非你将连接转换为使用 `CONNECT` 方法（即使是未加密的 HTTP 也可以使用此方法）。
- en: Due to the complexities of handling a full HTTP 1.1 connection, it is common
    for proxies to either disconnect clients after a single request or downgrade communications
    to version 1.0 (which always closes the response connection after all data has
    been received). This might break a higher-level protocol that expects to use version
    1.1 or request *pipelining*, which is the ability to have multiple requests *in
    flight* to improve performance or state locality.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理完整的 HTTP 1.1 连接的复杂性，代理通常会在一次请求后断开与客户端的连接，或者将通信降级到 1.0 版本（该版本在接收完所有数据后总是会关闭响应连接）。这可能会破坏一些期望使用
    1.1 版本或请求 *管道化*（即能够并行处理多个请求以提高性能或状态局部性）的高级协议。
- en: '***Reverse HTTP Proxy***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反向 HTTP 代理***'
- en: Forwarding proxies are fairly common in environments where an internal client
    is connecting to an outside network. They act as a security boundary, limiting
    outbound traffic to a small subset of protocol types. (Let’s just ignore the potential
    security implications of the `CONNECT` proxy for a moment.) But sometimes you
    might want to proxy inbound connections, perhaps for load-balancing or security
    reasons (to prevent exposing your servers directly to the outside world). However,
    a problem arises if you do this. You have no control over the client. In fact,
    the client probably doesn’t even realize it’s connecting to a proxy. This is where
    the *reverse HTTP proxy* comes in.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 转发代理在内部客户端连接到外部网络的环境中相当常见。它们充当安全边界，限制外向流量只使用少量的协议类型。（暂时忽略 `CONNECT` 代理的潜在安全隐患。）但有时你可能希望代理入站连接，可能是出于负载均衡或安全原因（防止直接暴露服务器到外部世界）。然而，如果这样做，会出现一个问题：你无法控制客户端。事实上，客户端可能根本没有意识到它正在连接到一个代理。这时，*反向
    HTTP 代理* 就派上用场了。
- en: Instead of requiring the destination host to be specified in the request line,
    as with a forwarding proxy, you can abuse the fact that all HTTP 1.1–compliant
    clients *must* send a Host HTTP header in the request that specifies the original
    hostname used in the URI of the request. (Note that HTTP 1.0 has no such requirement,
    but most clients using that version will send the header anyway.) With the Host
    header information, you can infer the original destination of the request, making
    a proxy connection to that server, as shown in [Listing 2-9](../Text/ch02.xhtml#ch2list9).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与转发代理需要在请求行中指定目标主机不同，你可以利用所有符合 HTTP 1.1 标准的客户端 *必须* 在请求中发送一个 Host HTTP 头，指定请求
    URI 中使用的原始主机名。（注意，HTTP 1.0 没有此要求，但大多数使用该版本的客户端仍然会发送此头。）通过 Host 头信息，你可以推断请求的原始目标，并与该服务器建立代理连接，如
    [示例 2-9](../Text/ch02.xhtml#ch2list9) 所示。
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 2-9: An example HTTP request*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-9：一个 HTTP 请求示例*'
- en: '[Listing 2-9](../Text/ch02.xhtml#ch2list9) shows a typical Host header ➊ where
    the HTTP request was to the URL *[http://www.domain.com/image.jpg](http://www.domain.com/image.jpg)*.
    The reverse proxy can easily take this information and reuse it to construct the
    original destination. Again, because there is a requirement for parsing the HTTP
    headers, it is more difficult to use for HTTPS traffic that is protected by TLS.
    Fortunately, most TLS implementations take wildcard certificates where the subject
    is in the form of **.domain.com* or similar, which would match any subdomain of
    *[domain.com](http://domain.com)*.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-9](../Text/ch02.xhtml#ch2list9) 显示了一个典型的 Host 头 ➊，其中 HTTP 请求的 URL 是 *[http://www.domain.com/image.jpg](http://www.domain.com/image.jpg)*。反向代理可以轻松地获取这些信息并加以利用，重构原始目标。再次强调，由于需要解析
    HTTP 头，对于受 TLS 保护的 HTTPS 流量使用起来更为困难。幸运的是，大多数 TLS 实现支持通配符证书，其主体形式为 **.domain.com**
    或类似形式，这样就可以匹配 *[domain.com](http://domain.com)* 的任何子域名。'
- en: '**Simple Implementation**'
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**简单实现**'
- en: Unsurprisingly, the Canape Core libraries include a built-in HTTP reverse proxy
    implementation, which you can access by changing the template object to *HttpReverseProxyTemplate*
    from *HttpProxyTemplate*. But for completeness, [Listing 2-10](../Text/ch02.xhtml#ch2list10)
    shows a simple implementation. Place the following code in a C# script file, changing
    `LOCALPORT` ➊ to the local TCP port you want to listen on. If `LOCALPORT` is less
    than 1024 and you’re running this on a Unix-style system, you’ll also need to
    run the script as root.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，Canape 核心库包含了一个内置的 HTTP 反向代理实现，你可以通过将模板对象从 *HttpProxyTemplate* 更改为 *HttpReverseProxyTemplate*
    来访问该实现。但为了完整起见，[示例 2-10](../Text/ch02.xhtml#ch2list10) 显示了一个简单的实现。将以下代码放入 C# 脚本文件中，将
    `LOCALPORT` ➊ 更改为你希望监听的本地 TCP 端口。如果 `LOCALPORT` 小于 1024，并且你在 Unix 风格的系统上运行该脚本，你还需要以
    root 用户身份运行此脚本。
- en: ReverseHttp
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ReverseHttp
- en: Proxy.csx
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Proxy.csx
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 2-10: A simple reverse HTTP proxy example*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-10：一个简单的反向 HTTP 代理示例*'
- en: '**Redirecting Traffic to Your Proxy**'
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将流量重定向到你的代理**'
- en: The approach to redirecting traffic to a reverse HTTP proxy is similar to that
    employed for TCP port-forwarding, which is by redirecting the connection to the
    proxy. But there is a big difference; you can’t just change the destination hostname.
    This would change the Host header, shown in Listing 2-10\. If you’re not careful,
    you could cause a proxy loop.^([1](../Text/footnote.xhtml#ch02nt01)) Instead,
    it’s best to change the IP address associated with a hostname using the *hosts*
    file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将流量重定向到反向 HTTP 代理的方法与 TCP 端口转发的方法相似，都是通过将连接重定向到代理。但有一个很大的区别；你不能只更改目标主机名。这会改变
    Host 头，如示例 2-10 所示。如果不小心，可能会导致代理循环。^([1](../Text/footnote.xhtml#ch02nt01)) 相反，最好是通过修改
    *hosts* 文件来更改与主机名相关联的 IP 地址。
- en: But perhaps the application you’re testing is running on a device that doesn’t
    allow you to change the *hosts* file. Therefore, setting up a custom DNS server
    might be the easiest approach, assuming you’re able to change the DNS server configuration.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许你正在测试的应用程序运行在一个无法修改 *hosts* 文件的设备上。因此，设置一个自定义的 DNS 服务器可能是最简单的方法，前提是你能够更改
    DNS 服务器配置。
- en: You could use another approach, which is to configure a full DNS server with
    the appropriate settings. This can be time consuming and error prone; just ask
    anyone who has ever set up a bind server. Fortunately, existing tools are available
    to do what we want, which is to return our proxy’s IP address in response to a
    DNS request. Such a tool is *dnsspoof*. To avoid installing another tool, you
    can do it using Canape’s DNS server. The basic DNS server spoofs only a single
    IP address to all DNS requests (see [Listing 2-11](../Text/ch02.xhtml#ch2list11)).
    Replace `IPV4ADDRESS` ➊, `IPV6ADDRESS` ➋, and `REVERSEDNS` ➌ with appropriate
    strings. As with the HTTP Reverse Proxy, you’ll need to run this as root on a
    Unix-like system, as it will try to bind to port 53, which is not usually allowed
    for normal users. On Windows, there’s no such restriction on binding to ports
    less than 1024.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用另一种方法，即配置一个完整的 DNS 服务器并设置适当的配置。这可能会非常耗时且容易出错；只需问问任何曾经配置过绑定服务器的人。幸运的是，现有的工具可以做我们想做的事情，即在响应
    DNS 请求时返回代理的 IP 地址。这样的工具是*dnsspoof*。为了避免安装另一个工具，你可以使用 Canape 的 DNS 服务器来完成。基础的
    DNS 服务器只会将所有 DNS 请求伪造为单一的 IP 地址（请参见[清单 2-11](../Text/ch02.xhtml#ch2list11)）。将`IPV4ADDRESS`
    ➊、`IPV6ADDRESS` ➋ 和 `REVERSEDNS` ➌ 替换为合适的字符串。和 HTTP 反向代理一样，你需要在类 Unix 系统上以 root
    用户身份运行，因为它会尝试绑定到 53 端口，而普通用户通常不允许这么做。在 Windows 上，绑定到低于 1024 的端口没有这样的限制。
- en: DnsServer.csx
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: DnsServer.csx
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 2-11: A simple DNS server*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-11：一个简单的 DNS 服务器*'
- en: Now if you configure the DNS server for your application to point to your spoofing
    DNS server, the application should send its traffic through.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将应用程序的 DNS 服务器配置为指向你的伪造 DNS 服务器，那么应用程序应该会通过该服务器发送其流量。
- en: '**Advantage of a Reverse HTTP Proxy**'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**反向 HTTP 代理的优势**'
- en: The advantage of a reverse HTTP proxy is that it doesn’t require a client application
    to support a typical forwarding proxy configuration. This is especially useful
    if the client application is not under your direct control or has a fixed configuration
    that cannot be easily changed. As long as you can force the original TCP connections
    to be redirected to the proxy, it’s possible to handle requests to multiple different
    hosts with little difficulty.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 反向 HTTP 代理的优势在于它不要求客户端应用程序支持典型的转发代理配置。如果客户端应用程序不在你的直接控制之下，或者具有无法轻易更改的固定配置，这一点尤其有用。只要你能强制将原始
    TCP 连接重定向到代理，就可以在几乎没有困难的情况下处理对多个不同主机的请求。
- en: '**Disadvantages of a Reverse HTTP Proxy**'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**反向 HTTP 代理的缺点**'
- en: The disadvantages of a reverse HTTP proxy are basically the same as for a forwarding
    proxy. The proxy must be able to parse the HTTP request and handle the idiosyncrasies
    of the protocol.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 反向 HTTP 代理的缺点基本上和转发代理一样。代理必须能够解析 HTTP 请求并处理协议的特性。
- en: '**Final Words**'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: You’ve read about passive and active capture techniques in this chapter, but
    is one better than the other? That depends on the application you’re trying to
    test. Unless you are just monitoring network traffic, it pays to take an active
    approach. As you continue through this book, you’ll realize that active capture
    has significant benefits for protocol analysis and exploitation. If you have a
    choice in your application, use SOCKS because it’s the easiest approach in many
    circumstances.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你已经了解了被动和主动捕获技术，但哪种方法更好呢？这取决于你想要测试的应用程序。除非你只是监控网络流量，否则采用主动方法是值得的。随着你继续阅读本书，你会意识到主动捕获对协议分析和利用有显著的好处。如果你的应用程序有选择的话，使用
    SOCKS，因为在许多情况下这是最简单的方法。
