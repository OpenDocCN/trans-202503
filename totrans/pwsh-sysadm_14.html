<html><head></head><body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_157"/><span class="big">12</span><br/>WORKING WITH AZURE</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">With organizations pushing more and more services to the cloud, it’s important that automators understand how to work there. Luckily, thanks to PowerShell’s modules, and its ability to work with just about any API, working in the cloud is a breeze. In this and the next chapter,</span> I’ll show you how to use PowerShell to automate tasks; in this chapter, you’ll work with Microsoft Azure, and in the next, with Amazon Web Services.</p>&#13;
<h3 class="h3" id="ch12lev1">Prerequisites</h3>&#13;
<p class="noindent">If you’ll be running the code in this chapter, I make a few assumptions about your environment. The first is that you have a Microsoft Azure subscription set up. You’ll be working with real cloud resources in this chapter, so you will receive charges to your account, but the fees should be reasonable. As long as you don’t leave any of the virtual machines you’re creating up for too long, the fees should be less than $10.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_158"/>Once you have an Azure subscription set up, you’ll need the <span class="literal">Az</span> PowerShell module bundle. This bundle of modules provided by Microsoft has hundreds of commands to perform tasks on nearly every Azure service available. You can download it by running <span class="codestrong">Install-Module Az</span> in your console (make sure to run as the administrator). I should note that I am using version 2.4.0 of the <span class="literal">Az</span> module. If you’re using a later version, I can’t guarantee that all of these commands will work exactly the same way.</p>&#13;
<h3 class="h3" id="ch12lev2">Azure Authentication</h3>&#13;
<p class="noindent">Azure gives us a few ways to authenticate to its service. In this chapter, you’ll use a service principal. A <em>service principal</em> is an Azure application’s identity. It is the object that represents an application that can then be assigned various permissions.</p>&#13;
<p class="indent">Why are you creating a service principal? You want to authenticate to Azure by using an automated script that requires no user interaction. To do this, Azure requires you to use either a service principal or an organizational account. I want everyone to be able to follow along regardless of the type of account they have, so you’ll use a service principal to authenticate to Azure.</p>&#13;
<h4 class="h4" id="ch12lev2sec1">Creating a Service Principal</h4>&#13;
<p class="noindent">Counterintuitively, the first thing you have to do to create a service principal is authenticate the old-fashioned way. To do this, use <span class="literal">Connect-AzAccount</span>, which produces a window like <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>.</p>&#13;
<div class="image"><img src="../images/12fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch12fig1"><em>Figure 12-1: The <span class="literal">Connect-AzAccount</span> credential prompt</em></p>&#13;
<p class="indent">Provide your Azure username and password, and the window should close, giving an output similar to <a href="ch12.xhtml#ch12list1">Listing 12-1</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_159"/>PS&gt; <span class="codestrong1">Connect-AzAccount</span>&#13;
&#13;
Environment           : AzureCloud&#13;
Account               : <span class="codeitalic1">email</span>&#13;
TenantId              : <span class="codeitalic1">tenant id</span>&#13;
SubscriptionId        : <span class="codeitalic1">subscription id</span>&#13;
SubscriptionName      : <span class="codeitalic1">subscription name</span>&#13;
CurrentStorageAccount :</pre>&#13;
<p class="caption" id="ch12list1"><em>Listing 12-1: Output from <span class="literal">Connect-AzAccount</span></em></p>&#13;
<p class="indent">Be sure to record the subscription ID and tenant ID. You’ll need those in your script a little later. If, for some reason, you don’t catch them while authenticating with <span class="literal">Connect-AzAccount</span> here, you can always get them by using the <span class="literal">Get-AzSubscription</span> command later.</p>&#13;
<p class="indent">Now that you’re (interactively) authenticated, you can start creating a service principal. It’s a three-step process: first, you create a new Azure AD application; then, you create the service principal itself; and last, you create a role assignment for that service principal.</p>&#13;
<p class="indent">You can create the Azure AD application by using whatever name and URI you like (<a href="ch12.xhtml#ch12list2">Listing 12-2</a>). What URI you use doesn’t matter for our purposes, but a URI is required to create the AD application. To ensure that you have adequate rights to create an AD application, refer to <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/app-objects-and-service-principals"><em>https://docs</em><em>.microsoft.com/en-us/azure/active-directory/develop/app-objects-and-service-principals</em></a><em>.</em></p>&#13;
<pre>PS&gt;<span class="codestrong1"/> <span class="ent">❶</span><span class="codestrong1">$secPassword = ConvertTo-SecureString -AsPlainText -Force -String '</span><span class="codeitalicst1">password</span><span class="codestrong1">'</span>&#13;
PS&gt; <span class="ent">❷</span><span class="codestrong1">$myApp = New-AzADApplication -DisplayName AppForServicePrincipal -IdentifierUris&#13;
'http://</span><span class="codeitalicst1">Some URL here</span><span class="codestrong1">' -Password $secPassword</span></pre>&#13;
<p class="caption" id="ch12list2"><em>Listing 12-2: Creating an Azure AD application</em></p>&#13;
<p class="indent">You can see that you’re first creating a secure string by using a password <span class="ent">❶</span>. After you have the password in the correct format, you create a new Azure AD application <span class="ent">❷</span>. A service principal requires an Azure AD application to be created.</p>&#13;
<p class="indent">Next, you use the <span class="literal">New-AzADServicePrincipal</span> command to create the service principal, as in <a href="ch12.xhtml#ch12list3">Listing 12-3</a>. You reference the application created in <a href="ch12.xhtml#ch12list2">Listing 12-2</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$sp = New-AzADServicePrincipal -ApplicationId $myApp.ApplicationId</span>&#13;
PS&gt; <span class="codestrong1">$sp</span>&#13;
&#13;
ServicePrincipalNames : {<span class="codeitalic1">application id</span>, http://appforserviceprincipal}&#13;
ApplicationId         : <span class="codeitalic1">application id</span>&#13;
DisplayName           : AppForServicePrincipal&#13;
Id                    : <span class="codeitalic1">service principal id</span>&#13;
Type                  : ServicePrincipal</pre>&#13;
<p class="caption" id="ch12list3"><em>Listing 12-3: Creating an Azure service principal with PowerShell</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_160"/>Last, you need to assign a role to the service principal. <a href="ch12.xhtml#ch12list4">Listing 12-4</a> assigns a <span class="literal">Contributor</span> role to ensure that the service principal has the access it needs to perform all of the tasks in this chapter.</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-AzRoleAssignment -RoleDefinitionName Contributor -ServicePrincipalName</span> &#13;
<span class="codestrong1">$sp.ServicePrincipalNames[0]</span>&#13;
&#13;
RoleAssignmentId   : /subscriptions/<span class="codeitalic1">subscription id</span>/providers/Microsoft.Authorization/&#13;
                     roleAssignments/<span class="codeitalic1">assignment id</span>&#13;
Scope              : /subscriptions/<span class="codeitalic1">subscription id</span>&#13;
DisplayName        : AppForServicePrincipal&#13;
SignInName         :&#13;
RoleDefinitionName : Contributor&#13;
RoleDefinitionId   : <span class="codeitalic1">id</span>&#13;
ObjectId           : <span class="codeitalic1">id</span>&#13;
ObjectType         : ServicePrincipal&#13;
CanDelegate        : False</pre>&#13;
<p class="caption" id="ch12list4"><em>Listing 12-4: Creating a role assignment for a service principal</em></p>&#13;
<p class="indent">With that, the service principal has been created and assigned a role.</p>&#13;
<p class="indent">The only thing left to do is save the encrypted password represented as a secure string for the application you just created somewhere on the disk. You can do that by using the <span class="literal">ConvertFrom-SecureString</span> command. The <span class="literal">ConvertFrom-SecureString</span> command (the complement of <span class="literal">ConvertTo-SecureString</span>) converts encrypted text represented as a PowerShell secure string to a general string, allowing you to save and reference it later:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$secPassword | ConvertFrom-SecureString | Out-File -FilePath C:\AzureAppPassword.txt</span></pre>&#13;
<p class="indent">Once you have the password saved to disk, you’re ready to set up noninteractive authentication for Azure.</p>&#13;
<h4 class="h4" id="ch12lev2sec2">Noninteractively Authenticating with Connect-AzAccount</h4>&#13;
<p class="noindent">The <span class="literal">Connect-AzAccount</span> command prompts you to manually input a username and password. In your scripts, you want to be as noninteractive as possible, because the last thing you want to do is depend on someone sitting in front of a computer to type in your password! Luckily, you can also pass a <span class="literal">PSCredential</span> object to <span class="literal">Connect-AzAccount</span>.</p>&#13;
<p class="indent">You’ll write a small script to handle noninteractive authentication. First, let’s create a <span class="literal">PSCredential</span> object that contains the Azure app ID and password:</p>&#13;
<pre>$azureAppId = '<span class="codeitalic1">application id</span>'&#13;
$azureAppIdPasswordFilePath = 'C:\AzureAppPassword.txt'&#13;
$pwd = (Get-Content -Path $azureAppIdPasswordFilePath | ConvertTo-SecureString)&#13;
$azureAppCred = (New-Object System.Management.Automation.PSCredential $azureAppId,$pwd)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_161"/>Remember the subscription ID and tenant ID you wrote down earlier? You need to pass those into <span class="literal">Connect-AzAccount</span> as well:</p>&#13;
<pre>$subscriptionId = '<span class="codeitalic1">subscription id</span>'&#13;
$tenantId = '<span class="codeitalic1">tenant id</span>'&#13;
Connect-AzAccount -ServicePrincipal -SubscriptionId $subscriptionId -TenantId $tenantId&#13;
-Credential $azureAppCred</pre>&#13;
<p class="indent">You’re all set up for noninteractive authentication! Now that you have this set up, it will be saved so you don’t have to authenticate like this again.</p>&#13;
<p class="indent">If you want the condensed code, download the <em>AzureAuthentication.ps1</em> script from the book’s resources for this chapter.</p>&#13;
<h3 class="h3" id="ch12lev3">Creating an Azure Virtual Machine and All Dependencies</h3>&#13;
<p class="noindent">It’s time to set up an Azure virtual machine. <em>Azure virtual machines</em> are one of the most popular Azure services, and having the skills to build Azure VMs will be a big advantage for anyone working in an Azure environment.</p>&#13;
<p class="indent">Now, way back in the day, when I first created my Azure subscription and wanted to play around with a virtual machine, I thought there’d be a single command to set it up—like all I’d have to do was run <span class="literal">New-AzureVm</span>, and voila! There’d be a brand-new virtual machine for me to play with. Boy, was I wrong.</p>&#13;
<p class="indent">Little did I realize the number of dependencies that had to be in place before a virtual machine would actually work. Did you notice how short the prerequisite section of this chapter is? I left it that way for a reason: to get more experience working with PowerShell, you’ll install all the dependencies you need to create a virtual machine with Azure. You’ll install a resource group, a virtual network, a storage account, a public IP address, a network interface, and an operating system image. In other words, you’ll build this VM from the ground up. Let’s get started!</p>&#13;
<h4 class="h4" id="ch12lev3sec3">Creating a Resource Group</h4>&#13;
<p class="noindent">In Azure, everything is a <em>resource</em>, and everything must live inside a <em>resource group</em>. Your first task is to create a resource group. To do that, you’ll use the <span class="literal">New-AzResourceGroup</span> command. This command requires a resource group name and the geographic region that it will be created in. For this example, you’ll create a resource group named <span class="literal">PowerShellForSysAdmins-RG</span>, and you’ll place it in the East US region (as shown in <a href="ch12.xhtml#ch12list5">Listing 12-5</a>). You can find all available regions by running the <span class="literal">Get-AzLocation</span> command.</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-AzResourceGroup -Name 'PowerShellForSysAdmins-RG' -Location 'East US'</span></pre>&#13;
<p class="caption" id="ch12list5"><em>Listing 12-5: Creating an Azure resource group</em></p>&#13;
<p class="indent">Once the resource group is created, it’s time to build out the network stack your VM will use.</p>&#13;
<h4 class="h4" id="ch12lev3sec4"><span epub:type="pagebreak" id="page_162"/>Creating the Network Stack</h4>&#13;
<p class="noindent">For your VM to connect to the outside world and other Azure resources, it needs a <em>network stack</em>: the subnet, virtual network, public IP address (optional), and virtual network adapter (vNIC) that the VM uses.</p>&#13;
<h5 class="h5">The Subnet</h5>&#13;
<p class="noindent">Your first step is to create a subnet. A <em>subnet</em> is a logical network of IP addresses that can communicate with one another without the use of a router. The subnet will be what goes “into” the virtual network. Subnets segment a virtual network into smaller networks.</p>&#13;
<p class="indent">To create a subnet config, use the <span class="literal">New-AzVirtualNetworkSubnetConfig</span> command (<a href="ch12.xhtml#ch12list6">Listing 12-6</a>). This command requires a name and the IP address prefix or network identity.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$newSubnetParams = @{</span>&#13;
<span class="codestrong1">    'Name' = 'PowerShellForSysAdmins-Subnet'</span>&#13;
<span class="codestrong1">    'AddressPrefix' = '10.0.1.0/24'</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">$subnet = New-AzVirtualNetworkSubnetConfig @newSubnetParams</span></pre>&#13;
<p class="caption" id="ch12list6"><em>Listing 12-6: Creating a virtual network subnet config</em></p>&#13;
<p class="indent">You assign the subnet a name of <span class="literal">PowerShellForSysAdmins-Subnet</span> and use the prefix of 10.0.1.0/24.</p>&#13;
<h5 class="h5">The Virtual Network</h5>&#13;
<p class="noindent">Now that you’ve created a subnet config, you can use it to create the virtual network. The <em>virtual network</em> is an Azure resource that allows you to segment various resources such as virtual machines from all other resources. A virtual network can be thought of in the same context as a logical network that you may implement on premises in a network router.</p>&#13;
<p class="indent">To create a virtual network, use the <span class="literal">New-AzVirtualNetwork</span> command, as shown in <a href="ch12.xhtml#ch12list7">Listing 12-7</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$newVNetParams = @{</span>&#13;
 <span class="ent">❶</span> <span class="codestrong1">'Name' = 'PowerShellForSysAdmins-vNet'</span>&#13;
 <span class="ent">❷</span> <span class="codestrong1">'ResourceGroupName' = 'PowerShellForSysAdmins-RG'</span>&#13;
 <span class="ent">❸</span> <span class="codestrong1">'Location' = 'East US'</span>&#13;
 <span class="ent">❹</span> <span class="codestrong1">'AddressPrefix' = '10.0.0.0/16'</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">$vNet = New-AzVirtualNetwork @newVNetParams -Subnet $subnet</span></pre>&#13;
<p class="caption" id="ch12list7"><em>Listing 12-7: Creating a virtual network</em></p>&#13;
<p class="indent">Notice that to create a virtual network, you have to specify the name of the network <span class="ent">❶</span>, the resource group <span class="ent">❷</span>, the region (location) <span class="ent">❸</span>, and the overarching private network that your subnet will be a part of <span class="ent">❹</span>.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_163"/>The Public IP Address</h5>&#13;
<p class="noindent">Now that you’ve set up a virtual network, you need a public IP address so you can connect your VM to the internet and have clients connect to your VM. Note that this step isn’t technically necessary if you plan to make your virtual machine available only to other Azure resources. But since you have bigger plans for your VM, you’ll go ahead and do it.</p>&#13;
<p class="indent">Again, you can create a public IP address by using a single command: <span class="literal">New-AzPublicIpAddress</span>. You’ve seen most of the parameters for this function before, but notice that there’s a new one named <span class="literal">AllocationMethod</span>. This parameter tells Azure whether to create a dynamic or static IP address resource. As shown in <a href="ch12.xhtml#ch12list8">Listing 12-8</a>, specify that you want a dynamic IP address. You assign your virtual machines dynamic IP addresses because it’s one less task to worry about. Because you don’t require an IP address to always be the same, using dynamic IP addresses frees you from another task.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$newPublicIpParams = @{</span>&#13;
<span class="codestrong1">    'Name' = 'PowerShellForSysAdmins-PubIp'</span>&#13;
<span class="codestrong1">    'ResourceGroupName' = 'PowerShellForSysAdmins-RG'</span>&#13;
<span class="codestrong1">    'AllocationMethod' = 'Dynamic' ## Dynamic or Static</span>&#13;
<span class="codestrong1">    'Location' = 'East US'</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">$publicIp = New-AzPublicIpAddress @newPublicIpParams</span></pre>&#13;
<p class="caption" id="ch12list8"><em>Listing 12-8: Creating a public IP address</em></p>&#13;
<p class="indent">Although this public IP address exists, it’s useless because it’s not associated with anything yet. You need to <em>bind</em> it to a vNIC.</p>&#13;
<h5 class="h5">The Virtual Network Adapter</h5>&#13;
<p class="noindent">To build the vNIC, you need to execute another single-line command, <span class="literal">New-AzNetworkInterface</span>, and you can use a lot of the same parameters you’ve been using. You also need the ID of the subnet and the ID of the public IP address you created earlier. Both the subnet and the public IP address were stored as objects with an ID property; you simply need to access that property, as shown in <a href="ch12.xhtml#ch12list9">Listing 12-9</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$newVNicParams = @{</span>&#13;
<span class="codestrong1">    'Name' = 'PowerShellForSysAdmins-vNIC'</span>&#13;
<span class="codestrong1">    'ResourceGroupName' = 'PowerShellForSysAdmins-RG'</span>&#13;
<span class="codestrong1">    'Location' = 'East US'</span>&#13;
<span class="codestrong1">    'SubnetId' = $vNet.Subnets[0].Id</span>&#13;
<span class="codestrong1">    'PublicIpAddressId' = $publicIp.Id</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">$vNic = New-AzNetworkInterface @newVNicParams</span></pre>&#13;
<p class="caption" id="ch12list9"><em>Listing 12-9: Creating an Azure vNIC</em></p>&#13;
<p class="indent">Your network stack is complete! The next step is creating the storage account.</p>&#13;
<h4 class="h4" id="ch12lev3sec5"><span epub:type="pagebreak" id="page_164"/>Creating a Storage Account</h4>&#13;
<p class="noindent">You need to store the virtual machine somewhere. That somewhere is called a <em>storage account</em>. Creating a basic storage account is as easy as using the <span class="literal">New</span><span class="literal">-AzStorageAccount</span> command. As with the past few commands you’ve seen, you need a name, resource group, and location; but here you have the new <span class="literal">Type</span> parameter, which specifies the level of redundancy your storage account will contain. Use the least expensive type of storage account (<em>locally redundant</em>), specified by the <span class="literal">Standard_LRS</span> argument, as you can see in <a href="ch12.xhtml#ch12list10">Listing 12-10</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$newStorageAcctParams = @{</span>&#13;
<span class="codestrong1">    'Name' = 'powershellforsysadmins'</span>&#13;
<span class="codestrong1">    'ResourceGroupName' = 'PowerShellForSysAdmins-RG'</span>&#13;
<span class="codestrong1">    'Type' = 'Standard_LRS'</span>&#13;
<span class="codestrong1">    'Location' = 'East US'</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">$storageAccount = New-AzStorageAccount @newStorageAcctParams</span></pre>&#13;
<p class="caption" id="ch12list10"><em>Listing 12-10: Creating an Azure storage account</em></p>&#13;
<p class="indent">Now that you have somewhere for the VM to live, it’s time to set up the operating system image.</p>&#13;
<h4 class="h4" id="ch12lev3sec6">Creating the Operating System Image</h4>&#13;
<p class="noindent">The <em>operating system image</em> is the base to the virtual disk your virtual machine will be using. Instead of installing Windows on your virtual machine, you’ll use a preexisting operating system image to get you to the point to where you can just turn it on.</p>&#13;
<p class="indent">You create an operating system image in two steps: defining some OS configuration settings, and then defining the offer or OS image to use. Azure uses the term <em>offer</em> to reference the VM image.</p>&#13;
<p class="indent">To set up all the configuration settings, you build a VM configuration object. This object defines the name and size of the VM you’re creating. You do this by using the <span class="literal">New-AzVMConfig</span> command. In <a href="ch12.xhtml#ch12list11">Listing 12-11</a>, you create a <span class="literal">Standard_A3</span> VM. (You can find a list of all sizes available by running <span class="literal">Get-AzVMSize</span> and specifying the region.).</p>&#13;
<pre>PS&gt; <span class="codestrong1">$newConfigParams = @{</span>&#13;
<span class="codestrong1">    'VMName' = 'PowerShellForSysAdmins-VM'</span>&#13;
<span class="codestrong1">    'VMSize' = 'Standard_A3'</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">$vmConfig = New-AzVMConfig @newConfigParams</span></pre>&#13;
<p class="caption" id="ch12list11"><em>Listing 12-11: Creating a VM configuration</em></p>&#13;
<p class="indent">Once the configuration is created, you can pass the object as the VM parameter for the <span class="literal">Set-AzVMOperatingSystem</span> command. This command allows you to both define operating-system-specific attributes, such as the hostname of the VM, and enable Windows Update and other attributes. We’ll <span epub:type="pagebreak" id="page_165"/>keep it simple here, but if you’d like to see everything possible, check out <span class="literal">Set-AzVMOperatingSystem</span> information by using <span class="literal">Get-Help</span>.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12list12">Listing 12-12</a> creates a Windows operating system object that will have the hostname of <span class="literal">Automate-VM</span> (note: the hostname must be fewer than 16 characters). You use the username and password returned by the <span class="literal">Get-Credential</span> command to create a new administrative user with the provided password, and you use the <span class="literal">EnableAutoUpdate</span> parameter to automatically apply any new Windows updates.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$newVmOsParams = @{</span>&#13;
<span class="codestrong1">    'Windows' = $true</span>&#13;
<span class="codestrong1">    'ComputerName' = 'Automate-VM'</span>&#13;
<span class="codestrong1">    'Credential' = (Get-Credential -Message 'Type the name and password of the&#13;
    local administrator account.')</span>&#13;
<span class="codestrong1">    'EnableAutoUpdate' = $true</span>&#13;
<span class="codestrong1">    'VM' = $vmConfig</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">$vm = Set-AzVMOperatingSystem @newVmOsParams</span></pre>&#13;
<p class="caption" id="ch12list12"><em>Listing 12-12: Creating an operating system image</em></p>&#13;
<p class="indent">Now you need to create a VM offer. An offer is how Azure allows you to choose what kind of operating system will be installed on the VM’s OS disk. This example uses a Windows Server 2012 R2 Datacenter image. This image is one provided by Microsoft, so no need to create your own.</p>&#13;
<p class="indent">Once you’ve created the offer object, you can create a source image by using the <span class="literal">Set-AzVMSourceImage</span> command, as shown in <a href="ch12.xhtml#ch12list13">Listing 12-13</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$offer = Get-AzVMImageOffer -Location 'East US'</span><span class="ent">❶</span><span class="codestrong1"> –PublisherName&#13;
'MicrosoftWindowsServer'</span><span class="ent">❷</span><span class="codestrong1"> | Where-Object { $_.Offer -eq 'WindowsServer' }</span><span class="ent">❸</span>&#13;
PS&gt; <span class="codestrong1">$newSourceImageParams = @{</span>&#13;
<span class="codestrong1">    'PublisherName' = 'MicrosoftWindowsServer'</span>&#13;
<span class="codestrong1">    'Version' = 'latest'</span>&#13;
<span class="codestrong1">    'Skus' = '2012-R2-Datacenter'</span>&#13;
<span class="codestrong1">    'VM' = $vm</span>&#13;
<span class="codestrong1">    'Offer' = $offer.Offer</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">$vm = Set-AzVMSourceImage @newSourceImageParams</span></pre>&#13;
<p class="caption" id="ch12list13"><em>Listing 12-13: Finding and creating a VM source image</em></p>&#13;
<p class="indent">Here, you’re querying all offers in the East US region <span class="ent">❶</span> with a publisher name of <span class="literal">MicrosoftWindowsServer</span> <span class="ent">❷</span>. You may use <span class="literal">Get-AzVMImagePublisher</span> to find a list of publishers. You then limit the offers to a name of <span class="literal">WindowsServer</span> <span class="ent">❸</span>. With the source image allocated, you can now assign the image to the VM object. This completes the setup of the VM’s virtual disk.</p>&#13;
<p class="indent">To assign the image to the VM object, you need a URI for the OS disk you just created, and you need to pass that URI along with the VM object to the <span class="literal">Set-AzVMOSDisk</span> command (<a href="ch12.xhtml#ch12list14">Listing 12-14</a>).</p>&#13;
<pre><span epub:type="pagebreak" id="page_166"/>PS&gt; $osDiskName = <span class="codestrong1">'PowerShellForSysAdmins-Disk'</span>&#13;
PS&gt; $osDiskUri =<span class="codestrong1"> '{0}vhds/PowerShellForSysAdmins-VM{1}.vhd' -f $storageAccount&#13;
                 .PrimaryEndpoints.Blob.ToString(), $osDiskName</span>&#13;
PS&gt; $vm =<span class="codestrong1"> Set-AzVMOSDisk -Name $osDiskName -CreateOption 'fromImage' -VM $vm -VhdUri $osDiskUri</span></pre>&#13;
<p class="caption" id="ch12list14"><em>Listing 12-14: Assigning the operating system disk to the VM</em></p>&#13;
<p class="indent">At this point, you have an OS disk, and it’s assigned to a VM object. Time to finish this up!</p>&#13;
<h4 class="h4" id="ch12lev3sec7">Wrapping Up</h4>&#13;
<p class="noindent">You’re <em>almost</em> done. All that’s left is to attach the vNIC you created earlier and, well, create the actual VM.</p>&#13;
<p class="indent">To attach the vNIC to the VM, you use the <span class="literal">Add-AzVmNetworkInterface</span> command and pass the VM object you created along with the ID of the vNIC you created earlier—all of which you can see in <a href="ch12.xhtml#ch12list15">Listing 12-15</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$vm = Add-AzVMNetworkInterface -VM $vm -Id $vNic.Id</span></pre>&#13;
<p class="caption" id="ch12list15"><em>Listing 12-15: Attaching the vNIC to the VM</em></p>&#13;
<p class="indent">And now, at last, you can create the VM, as shown in <a href="ch12.xhtml#ch12list16">Listing 12-16</a>. By calling the <span class="literal">New-AzVm</span> command with the VM object, the resource group, and region, you finally have your VM! Note that this will start the VM, and at this point, you’ll begin incurring charges.</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-AzVM -VM $vm -ResourceGroupName 'PowerShellForSysAdmins-RG' -Location 'East US'</span>&#13;
&#13;
RequestId IsSuccessStatusCode StatusCode ReasonPhrase&#13;
--------- ------------------- ---------- ------------&#13;
                         True         OK OK</pre>&#13;
<p class="caption" id="ch12list16"><em>Listing 12-16: Creating the Azure virtual machine</em></p>&#13;
<p class="indent">You should have a brand-new VM in Azure called <span class="literal">Automate-VM</span>. To confirm, you can run <span class="literal">Get-AzVm</span> to ensure that the VM exists. Check out the output in <a href="ch12.xhtml#ch12list17">Listing 12-17</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-AzVm -ResourceGroupName 'PowerShellForSysAdmins-RG' -Name PowerShellForSysAdmins-VM</span>&#13;
&#13;
&#13;
ResourceGroupName  : PowerShellForSysAdmins-RG&#13;
Id                 : /subscriptions/XXXXXXXXXXXXX/resourceGroups/PowerShellForSysAdmins-RG/&#13;
                     providers/Microsoft.Compute/virtualMachines/PowerShellForSysAdmins-VM&#13;
VmId               : e459fb9e-e3b2-4371-9bdd-42ecc209bc01&#13;
Name               : PowerShellForSysAdmins-VM&#13;
Type               : Microsoft.Compute/virtualMachines&#13;
Location           : eastus&#13;
Tags               : {}&#13;
DiagnosticsProfile : {BootDiagnostics}&#13;
<span epub:type="pagebreak" id="page_167"/>Extensions         : {BGInfo}&#13;
HardwareProfile    : {VmSize}&#13;
NetworkProfile     : {NetworkInterfaces}&#13;
OSProfile          : {ComputerName, AdminUsername, WindowsConfiguration, Secrets}&#13;
ProvisioningState  : Succeeded&#13;
StorageProfile     : {ImageReference, OsDisk, DataDisks}</pre>&#13;
<p class="caption" id="ch12list17"><em>Listing 12-17: Discovering your Azure VM</em></p>&#13;
<p class="indent">If you see similar output, you’ve successfully created an Azure virtual machine!</p>&#13;
<h4 class="h4" id="ch12lev3sec8">Automating the VM Creation</h4>&#13;
<p class="noindent">Whew! That was a lot of work getting a single virtual machine running and building all of the dependencies; I would hate to have to go through it again when I want to build my next VM. Why don’t we create a single function that’ll handle all this for us? With a function, we can incorporate all the code we just went through into a single, executable chunk of code that we can reuse over and over again.</p>&#13;
<p class="indent">If you’re feeling adventurous, I created a custom PowerShell function called <span class="literal">New-CustomAzVm</span>, available in this chapter’s resources. It provides an excellent example of how to incorporate all the tasks accomplished in this section into a single, cohesive function with a minimal amount of input.</p>&#13;
<h3 class="h3" id="ch12lev4">Deploying an Azure Web App</h3>&#13;
<p class="noindent">If you’re working with Azure, you’ll want to know how to deploy an Azure web app. <em>Azure web apps</em> allow you to quickly provision websites and various other web services running on servers such as IIS, Apache, and more without worrying about building the web server itself. Once you learn how to deploy an Azure web app with PowerShell, you’ll be able to work the process into larger workflows including development build pipelines, test environment provisioning, lab provisioning, and more.</p>&#13;
<p class="indent">Deploying an Azure web app is a two-step process: you create an app service plan and then create the web app itself. Azure web apps are a part of Azure App Services, and any resource under this umbrella must have an associated app service plan. <em>App service plans</em> tell the web app which kind of underlying compute resources to build the program on.</p>&#13;
<h4 class="h4" id="ch12lev4sec9">Creating an App Service Plan and Web App</h4>&#13;
<p class="noindent">Creating an Azure service plan is simple enough. As before, you need only a single command. This command requires you to provide the name of the app service plan, the region or location where it will exist, the resource group, and an optional tier that defines the kind of performance provided by the server running underneath the web app.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_168"/>Just as you did in the previous section, you create a resource group to keep all of your resources together; let’s use this command: <span class="codestrong">New-AzResourceGroup -Name 'PowerShellForSysAdmins-App' -Location 'East US'</span>. Once the resource group is created, you create the app service plan and place it inside that resource group.</p>&#13;
<p class="indent">Your web app, called <span class="literal">Automate</span>, will be in the East US region and in the <span class="literal">Free</span> tier of apps. You can see all the code to accomplish those tasks in <a href="ch12.xhtml#ch12list18">Listing 12-18</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-AzAppServicePlan -Name 'Automate' -Location 'East US'&#13;
-ResourceGroupName 'PowerShellForSysAdmins-App' -Tier 'Free'</span></pre>&#13;
<p class="caption" id="ch12list18"><em>Listing 12-18: Creating an Azure app service plan</em></p>&#13;
<p class="indent">Once this command is executed, you’ll have the app service plan created and can move on to creating the web app itself.</p>&#13;
<p class="indent">You may not be surprised to hear that creating an Azure web app with PowerShell is also a single-command process. Just run <span class="literal">New-AzWebApp</span>, and supply it with the now-common parameters of resource group name, name, and location, along with the app service plan this web app will sit on top of.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12list19">Listing 12-19</a> uses the <span class="literal">New-AzWebApp</span> command to create a web app with the name <span class="literal">MyApp</span> inside the <span class="literal">PowerShellForSysAdmins-App</span> resource group using the app service plan <span class="literal">Automate</span> (the one that you created earlier). Note that this starts the app, which may incur billing.</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-AzWebApp -ResourceGroupName 'PowerShellForSysAdmins-App' -Name&#13;
'AutomateApp' -Location 'East US' -AppServicePlan 'Automate'</span></pre>&#13;
<p class="caption" id="ch12list19"><em>Listing 12-19: Creating an Azure web app</em></p>&#13;
<p class="indent">When you run this command, you should see a lot of properties in your output; these are the web app’s various settings.</p>&#13;
<h3 class="h3" id="ch12lev5">Deploying an Azure SQL Database</h3>&#13;
<p class="noindent">Another common Azure task is deploying an Azure SQL database. To deploy an Azure SQL database, you need to do three things: create the Azure SQL server that the database will run on, create the database itself, and then create a SQL Server firewall rule to connect to the database.</p>&#13;
<p class="indent">As in previous sections, you create a resource group to house all your new resources. Run <span class="codestrong">New-AzResourceGroup -Name 'PowerShellForSysAdmins-SQL' -Location 'East US'</span> to do so. Then you’ll create the SQL server that the database will run on.</p>&#13;
<h4 class="h4" id="ch12lev5sec10">Creating an Azure SQL Server</h4>&#13;
<p class="noindent">Creating an Azure SQL server takes yet another single-line command: <span class="literal">New-AzSqlServer</span>. And yet again, you need to provide the name of the resource, <span epub:type="pagebreak" id="page_169"/>the name of the server itself, and the region—but here, you also need the username and password of the SQL administrator user on the server. This requires a little more work. Because you need to create a credential to pass to <span class="literal">New-AzSqlServer</span>, let’s go ahead and do that first. I covered how to create a <span class="literal">PSCredential</span> object in the “Creating a Service Principal” on <a href="ch12.xhtml#page_158">page 158</a>, so we won’t go over that here.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$userName = 'sqladmin'</span>&#13;
PS&gt; <span class="codestrong1">$plainTextPassword = 's3cretp@SSw0rd!'</span>&#13;
PS&gt; <span class="codestrong1">$secPassword = ConvertTo-SecureString -String $plainTextPassword -AsPlainText -Force</span>&#13;
PS&gt; <span class="codestrong1">$credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList&#13;
$userName,$secPassword</span></pre>&#13;
<p class="indent">Once you have a credential, the rest is as easy as putting all the parameters into a hashtable, and passing it into the <span class="literal">New-AzSqlServer</span> function, as shown in <a href="ch12.xhtml#ch12list20">Listing 12-20</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$parameters = @{</span>&#13;
<span class="codestrong1">    ResourceGroupName = 'PowerShellForSysAdmins-SQL'</span>&#13;
<span class="codestrong1">    ServerName = 'powershellforsysadmins-sqlsrv'</span>&#13;
<span class="codestrong1">    Location =  'East US'</span>&#13;
<span class="codestrong1">    SqlAdministratorCredentials = $credential</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">New-AzSqlServer @parameters</span>&#13;
&#13;
ResourceGroupName        : PowerShellForSysAdmins-SQL&#13;
ServerName               : powershellsysadmins-sqlsrv&#13;
Location                 : eastus&#13;
SqlAdministratorLogin    : sqladmin&#13;
SqlAdministratorPassword :&#13;
ServerVersion            : 12.0&#13;
Tags                     :&#13;
Identity                 :&#13;
FullyQualifiedDomainName : powershellsysadmins-sqlsrv.database.windows.net&#13;
ResourceId               : /subscriptions/XXXXXXXXXXXXX/resourceGroups&#13;
                           /PowerShellForSysAdmins-SQL/providers/Microsoft.Sql&#13;
                           /servers/powershellsysadmins-sqlsrv</pre>&#13;
<p class="caption" id="ch12list20"><em>Listing 12-20: Creating the Azure SQL server</em></p>&#13;
<p class="indent">Now that the SQL server has been created, you have the bedrock for your database.</p>&#13;
<h4 class="h4" id="ch12lev5sec11">Creating the Azure SQL Database</h4>&#13;
<p class="noindent">To create the SQL database, use the <span class="literal">New-AzSqlDatabase</span> command, as shown in <a href="ch12.xhtml#ch12list21">Listing 12-21</a>. Along with the common parameter of <span class="literal">ResourceGroupName</span>, pass in the name of the server that you just created and the name of the database you want to create (in this example, <span class="literal">AutomateSQLDb</span>).</p>&#13;
<pre><span epub:type="pagebreak" id="page_170"/>PS&gt; <span class="codestrong1">New-AzSqlDatabase -ResourceGroupName 'PowerShellForSysAdmins-SQL'&#13;
-ServerName 'PowerShellSysAdmins-SQLSrv' -DatabaseName 'AutomateSQLDb'</span>&#13;
&#13;
ResourceGroupName             : PowerShellForSysAdmins-SQL&#13;
ServerName                    : PowerShellSysAdmins-SQLSrv&#13;
DatabaseName                  : AutomateSQLDb&#13;
Location                      : eastus&#13;
DatabaseId                    : 79f3b331-7200-499f-9fba-b09e8c424354&#13;
Edition                       : Standard&#13;
CollationName                 : SQL_Latin1_General_CP1_CI_AS&#13;
CatalogCollation              :&#13;
MaxSizeBytes                  : 268435456000&#13;
Status                        : Online&#13;
CreationDate                  : 9/15/2019 6:48:32 PM&#13;
CurrentServiceObjectiveId     : 00000000-0000-0000-0000-000000000000&#13;
CurrentServiceObjectiveName   : S0&#13;
RequestedServiceObjectiveName : S0&#13;
RequestedServiceObjectiveId   :&#13;
ElasticPoolName               :&#13;
EarliestRestoreDate           : 9/15/2019 7:18:32 PM&#13;
Tags                          :&#13;
ResourceId                    : /subscriptions/XXXXXXX/resourceGroups&#13;
                                /PowerShellForSysAdmins-SQL/providers&#13;
                                /Microsoft.Sql/servers/powershellsysadmin-sqlsrv&#13;
                                /databases/AutomateSQLDb&#13;
CreateMode                    :&#13;
ReadScale                     : Disabled&#13;
ZoneRedundant                 : False&#13;
Capacity                      : 10&#13;
Family                        :&#13;
SkuName                       : Standard&#13;
LicenseType                   :</pre>&#13;
<p class="caption" id="ch12list21"><em>Listing 12-21: Creating an Azure SQL database</em></p>&#13;
<p class="indent">At this point, you have a running SQL database in Azure. But when you try to connect to it, it won’t work. By default, when a new Azure SQL database is created, it’s locked down from any outside connections. You need to create a firewall rule so you can allow connections to your database.</p>&#13;
<h4 class="h4" id="ch12lev5sec12">Creating the SQL Server Firewall Rule</h4>&#13;
<p class="noindent">The command to create a firewall rule is <span class="literal">New-AzSqlServerFirewallRule</span>. The command takes in the resource group name, the name of the server you created earlier, the name for the firewall rule, and start and end IP addresses. The start and end IP addresses allow you to specify a single IP address or a range of IPs to allow into your database. Since you’ll be working on only one local computer to manage Azure, let’s limit the connections to your SQL server to be from only your current computer. To do that, you first need to figure out your public IP address. You can easily do this via a PowerShell one-liner: <span class="codestrong">Invoke-RestMethod http://ipinfo.io/json | Select -ExpandProperty ip</span>. <span epub:type="pagebreak" id="page_171"/>You can then use the public IP address for both the <span class="literal">StartIPAddress</span> and <span class="literal">EndIPAddress</span> parameters. However, note that if your public IP address changes, you’ll need to do all this again.</p>&#13;
<p class="indent">Also, be aware that the server name in <a href="ch12.xhtml#ch12list22">Listing 12-22</a> must be made up of all lowercase letters, hyphens, and/or numbers. Otherwise, you’ll get an error when you attempt to create the firewall rule.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$parameters = @{</span>&#13;
<span class="codestrong1">    ResourceGroupName = 'PowerShellForSysAdmins-SQL'</span>&#13;
<span class="codestrong1">    FirewallRuleName = 'PowerShellForSysAdmins-FwRule'</span>&#13;
<span class="codestrong1">    ServerName = 'powershellsysadmin-sqlsrv'</span>&#13;
<span class="codestrong1">    StartIpAddress = '</span><span class="codeitalicst1">Your Public IP Address</span><span class="codestrong1">'</span>&#13;
<span class="codestrong1">    EndIpAddress = '</span><span class="codeitalicst1">Your Public IP Address</span><span class="codestrong1">'</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">New-AzSqlServerFirewallRule @parameters</span>&#13;
&#13;
ResourceGroupName : PowerShellForSysAdmins-SQL&#13;
ServerName        : powershellsys-sqlsrv&#13;
StartIpAddress    : 0.0.0.0&#13;
EndIpAddress      : 0.0.0.0&#13;
FirewallRuleName  : PowerShellForSysAdmins-FwRule</pre>&#13;
<p class="caption" id="ch12list22"><em>Listing 12-22: Creating an Azure SQL server firewall rule</em></p>&#13;
<p class="indent">That’s it! Your database should be up and running.</p>&#13;
<h4 class="h4" id="ch12lev5sec13">Testing Your SQL Database</h4>&#13;
<p class="noindent">To test your database, let’s make a small function that uses the <span class="literal">System.Data.SqlClient.SqlConnection</span> object’s <span class="literal">Open()</span> method to attempt a simple connection; see <a href="ch12.xhtml#ch12list23">Listing 12-23</a>.</p>&#13;
<pre>function Test-SqlConnection {&#13;
    param(&#13;
        [Parameter(Mandatory)]&#13;
     <span class="ent">❶</span> [string]$ServerName,&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [string]$DatabaseName,&#13;
&#13;
        [Parameter(Mandatory)]&#13;
     <span class="ent">❷</span> [pscredential]$Credential&#13;
    )&#13;
&#13;
    try {&#13;
        $userName = $Credential.UserName&#13;
     <span class="ent">❸</span> $password = $Credential.GetNetworkCredential().Password&#13;
     <span class="ent">❹</span> $connectionString = 'Data Source={0};database={1};User&#13;
        ID={2};Password={3}' -f $ServerName,$DatabaseName,$userName,$password&#13;
        $sqlConnection = New-Object System.Data.SqlClient.SqlConnection&#13;
        $ConnectionString&#13;
     <span class="ent">❺</span> $sqlConnection.Open()&#13;
        $true&#13;
<span epub:type="pagebreak" id="page_172"/>    } catch {&#13;
       if ($_.Exception.Message -match 'cannot open server') {&#13;
           $false&#13;
       } else {&#13;
           throw $_&#13;
       }&#13;
    } finally {&#13;
     <span class="ent">❻</span> $sqlConnection.Close()&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch12list23"><em>Listing 12-23: Testing a SQL connection to the Azure SQL database</em></p>&#13;
<p class="indent">You use the SQL server’s fully qualified domain name created earlier as the <span class="literal">ServerName</span> parameter for this function <span class="ent">❶</span> along with the SQL administrator username and password inside a <span class="literal">PSCredential</span> object <span class="ent">❷</span>.</p>&#13;
<p class="indent">Then you break apart the <span class="literal">PSCredential</span> object into a plaintext username and password <span class="ent">❸</span>, create the connection string to make the database connection <span class="ent">❹</span>, invoke the <span class="literal">Open()</span> method on the <span class="literal">SqlConnection</span> object to attempt to connect to the database <span class="ent">❺</span>, and then finally close the database connection <span class="ent">❻</span>.</p>&#13;
<p class="indent">You can execute this function by running <span class="codestrong">Test-SqlConnection -ServerName</span> <span class="codestrong">'powershellsysadmins-sqlsrv.database.windows.net' -DatabaseName 'AutomateSQLDb' -Credential (Get-Credential)</span>. If you can connect to the database, the function will return <span class="literal">True</span>; otherwise, it will return <span class="literal">False</span> (and further investigation will be needed).</p>&#13;
<p class="indent">You can clean everything up by removing the resource group with the command <span class="codestrong">Remove-AzResourceGroup -ResourceGroupName 'PowerShellForSysAdmins-SQL'</span>.</p>&#13;
<h3 class="h3" id="ch12lev6">Summary</h3>&#13;
<p class="noindent">In this chapter, you dove headfirst into automating Microsoft Azure with PowerShell. You set up noninteractive authentication, and deployed a virtual machine, web app, and SQL database. And you did it all from PowerShell, sparing you any visits to the Azure portal.</p>&#13;
<p class="indent">You couldn’t have done this without the <span class="literal">Az</span> PowerShell module and the hard work of the people who created it. Like other PowerShell cloud modules, all these commands rely on various APIs that are being called under the hood. Thanks to the module, you didn’t have to worry about learning how to call REST methods or use endpoint URLs.</p>&#13;
<p class="indent">In the next chapter, you’ll take a look at using PowerShell to automate Amazon Web Services.</p>&#13;
</body></html>