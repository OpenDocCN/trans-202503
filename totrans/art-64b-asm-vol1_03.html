<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="43" id="Page_43"/>2</span><br/>
<span class="ChapterTitle">Computer Data Representation and Operations</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">A major stumbling block many beginners encounter when attempting to learn assembly language is the common use of the binary and hexadecimal numbering systems. Although hexadecimal numbers are a little strange, their advantages outweigh their disadvantages by a large margin. Understanding the binary and hexadecimal numbering systems is important because their use simplifies the discussion of other topics, including bit operations, signed numeric representation, character codes, and packed data.</p>
<p>This chapter discusses several important concepts, including the following:</p>
<ul>
<li>The binary and hexadecimal numbering systems</li>
<li>Binary data organization (bits, nibbles, bytes, words, and double words)</li>
<li>Signed and unsigned numbering systems</li>
<li>Arithmetic, logical, shift, and rotate operations on binary values</li>
<li><span epub:type="pagebreak" title="44" id="Page_44"/>Bit fields and packed data</li>
<li>Floating-point and binary-code decimal formats</li>
<li>Character data</li>
</ul>
<p>This is basic material, and the remainder of this text depends on your understanding of these concepts. If you are already familiar with these terms from other courses or study, you should at least skim this material before proceeding to the next chapter. If you are unfamiliar with this material, or only vaguely familiar with it, you should study it carefully before proceeding. <em>All of the material in this chapter is important!</em> Do not skip over any material. </p>
<h2 id="h1-501089c02-0001">	2.1	Numbering Systems</h2>
<p class="BodyFirst">Most modern computer systems do not represent numeric values using the decimal (base-10) system. Instead, they typically use a binary, or two’s complement, numbering system.</p>
<h3 id="h2-501089c02-0001">2.1.1	A Review of the Decimal System</h3>
<p class="BodyFirst">You’ve been using the decimal numbering system for so long that you probably take it for granted. When you see a number like 123, you don’t think about the value 123; rather, you generate a mental image of how many items this value represents. In reality, however, the number 123 represents the following:</p>
<ol class="none">
<li>(1 × 10<sup>2</sup>) + (2 × 10<sup>1</sup>) + (3 × 10<sup>0</sup>)</li>
<li>or </li>
<li>100 + 20 + 3</li>
</ol>
<p>In a decimal <em>positional numbering system</em>, each digit appearing to the left of the decimal point represents a value between 0 and 9 times an increasing power of 10. Digits appearing to the right of the decimal point represent a value between 0 and 9 times an increasing negative power of 10. For example, the value 123.456 means this:</p>
<ol class="none">
<li>(1 × 10<sup>2</sup>) + (2 × 10<sup>1</sup>) + (3 × 10<sup>0</sup>) + (4 × 10<sup>-1</sup>) + (5 × 10<sup>-2</sup>) + (6 × 10<sup>-3</sup>)</li>
<li>or</li>
<li>100 + 20 + 3 + 0.4 + 0.05 + 0.006</li>
</ol>
<h3 id="h2-501089c02-0002">2.1.2	The Binary Numbering System</h3>
<p class="BodyFirst">Most modern computer systems operate using <em>binary</em> logic. The computer represents values using two voltage levels (usually 0 V and +2.4 to 5 V). These two levels can represent exactly two unique values. These could be any two different values, but they typically represent the values 0 and 1, the two digits in the binary numbering system.</p>
<p>The binary numbering system works just like the decimal numbering system, except binary allows only the digits 0 and 1 (rather than 0 to 9) and <span epub:type="pagebreak" title="45" id="Page_45"/>uses powers of 2 rather than powers of 10. Therefore, converting a binary number to decimal is easy. For each 1 in a binary string, add 2<sup><em>n</em></sup>, where <em>n</em> is the zero-based position of the binary digit. For example, the binary value 11001010<sub>2</sub> represents the following:</p>
<ol class="none">
<li>(1 × 2<sup>7</sup>) + (1 × 2<sup>6</sup>) + (0 × 2<sup>5</sup>) + (0 × 2<sup>4</sup>) + (1 × 2<sup>3</sup>) + (0 × 2<sup>2</sup>) + (1 × 2<sup>1</sup>) + (0 × 2<sup>0</sup>)</li>
<li>=</li>
<li>128<sub>10</sub> + 64<sub>10</sub> + 8<sub>10</sub> + 2<sub>10</sub> </li>
<li>=</li>
<li>202<sub>10</sub></li>
</ol>
<p>Converting decimal to binary is slightly more difficult. You must find those powers of 2 that, when added together, produce the decimal result.</p>
<p>A simple way to convert decimal to binary is the <em>even/odd—divide-by-two</em> algorithm. This algorithm uses the following steps:</p>
<ol class="decimal">
<li value="1">If the number is even, emit a 0. If the number is odd, emit a 1.</li>
<li value="2">Divide the number by 2 and throw away any fractional component or remainder.</li>
<li value="3">If the quotient is 0, the algorithm is complete.</li>
<li value="4">If the quotient is not 0 and is odd, insert a 1 before the current string; if the number is even, prefix your binary string with 0.</li>
<li value="5">Go back to step 2 and repeat.</li>
</ol>
<p>Binary numbers, although they have little importance in high-level languages, appear everywhere in assembly language programs. So you should be comfortable with them.</p>
<h3 id="h2-501089c02-0003">2.1.3	Binary Conventions</h3>
<p class="BodyFirst">In the purest sense, every binary number contains an infinite number of digits (or <em>bits</em>, which is short for <em>binary digits</em>). For example, we can represent the number 5 by any of the following:</p>
<ol class="none">
<li>101       00000101       0000000000101       . . . 000000000000101</li>
</ol>
<p>Any number of leading-zero digits may precede the binary number without changing its value. Because the x86-64 typically works with groups of 8 bits, we’ll zero-extend all binary numbers to a multiple of 4 or 8 bits. Following this convention, we’d represent the number 5 as 0101<sub>2</sub> or 00000101<sub>2</sub>.</p>
<p>To make larger numbers easier to read, we will separate each group of 4 binary bits with an underscore. For example, we will write the binary value 1010111110110010 as 1010_1111_1011_0010.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	MASM does not allow you to insert underscores into the middle of a binary number. This is a convention adopted in this book for readability purposes.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="46" id="Page_46"/>We’ll number each bit as follows:</p>
<ol class="decimal">
<li value="1">The rightmost bit in a binary number is bit position 0.</li>
<li value="2">Each bit to the left is given the next successive bit number.</li>
</ol>
<p>An 8-bit binary value uses bits 0 to 7:</p>
<ol class="none">
<li><em>X</em><sub>7</sub> <em>X</em><sub>6</sub> <em>X</em><sub>5</sub> <em>X</em><sub>4</sub> <em>X</em><sub>3</sub> <em>X</em><sub>2</sub> <em>X</em><sub>1</sub> <em>X</em><sub>0</sub></li>
</ol>
<p>A 16-bit binary value uses bit positions 0 to 15:</p>
<ol class="none">
<li><em>X</em><sub>15</sub> <em>X</em><sub>14</sub> <em>X</em><sub>13</sub> <em>X</em><sub>12</sub> <em>X</em><sub>11</sub> <em>X</em><sub>10</sub> <em>X</em><sub>9</sub> <em>X</em><sub>8</sub> <em>X</em><sub>7</sub> <em>X</em><sub>6</sub> <em>X</em><sub>5</sub> <em>X</em><sub>4</sub> <em>X</em><sub>3</sub> <em>X</em><sub>2</sub> <em>X</em><sub>1</sub> <em>X</em><sub>0</sub></li>
</ol>
<p>A 32-bit binary value uses bit positions 0 to 31, and so on.</p>
<p>Bit 0 is the <em>low-order (</em><em>LO)</em> bit; some refer to this as the <em>least significant bit</em>. The leftmost bit is called the <em>high-order</em> <em>(</em><em>HO)</em> bit, or the <em>most significant bit</em>. We’ll refer to the intermediate bits by their respective bit numbers.</p>
<p>In MASM, you can specify binary values as a string of 0 or 1 digits ending with the character <code>b</code>. Remember, MASM doesn’t allow underscores in binary numbers.</p>
<h2 id="h1-501089c02-0002">	2.2	The Hexadecimal Numbering System</h2>
<p class="BodyFirst">Unfortunately, binary numbers are verbose. To represent the value 202<sub>10</sub> requires eight binary digits, but only three decimal digits. When dealing with large values, binary numbers quickly become unwieldy. Unfortunately, the computer “thinks” in binary, so most of the time using the binary numbering system is convenient. Although we can convert between decimal and binary, the conversion is not a trivial task.</p>
<p>The hexadecimal (base-16) numbering system solves many of the problems inherent in the binary system: hexadecimal numbers are compact, and it’s simple to convert them to binary, and vice versa. For this reason, most engineers use the hexadecimal numbering system.</p>
<p>Because the <em>radix</em> (base) of a hexadecimal number is 16, each hexadecimal digit to the left of the hexadecimal point represents a certain value multiplied by a successive power of 16. For example, the number 1234<sub>16</sub> is equal to this:</p>
<ol class="none">
<li>(1 × 16<sup>3</sup>) + (2 × 16<sup>2</sup>) + (3 × 16<sup>1</sup>) + (4 × 16<sup>0</sup>)</li>
<li>or</li>
<li>4096 + 512 + 48 + 4 = 4660<sub>10</sub></li>
</ol>
<p>Each hexadecimal digit can represent one of 16 values between 0 and 15<sub>10</sub>. Because there are only 10 decimal digits, we need 6 additional digits to represent the values in the range 10<sub>10</sub> to 15<sub>10</sub>. Rather than create new symbols for these digits, we use the letters A to F. The following are all examples of valid hexadecimal numbers:</p>
<ol class="none">
<li>1234<sub>16</sub>   DEAD<sub>16</sub>   BEEF<sub>16</sub>   0AFB<sub>16</sub>   F001<sub>16</sub>   D8B4<sub>16</sub></li>
</ol>
<p><span epub:type="pagebreak" title="47" id="Page_47"/>Because we’ll often need to enter hexadecimal numbers into the computer system, and on most computer systems you cannot enter a subscript to denote the radix of the associated value, we need a different mechanism for representing hexadecimal numbers. We’ll adopt the following MASM conventions:</p>
<ol class="decimal">
<li value="1">All hexadecimal values begin with a numeric character and have an <em>h</em> suffix; for example, 123A4h and 0DEADh.</li>
<li value="2">All binary values end with a <em>b</em> character; for example, 10010b.</li>
<li value="3">Decimal numbers do not have a suffix character.</li>
<li value="4">If the radix is clear from the context, this book may drop the trailing <em>h</em> or <em>b</em> character.</li>
</ol>
<p>Here are some examples of valid hexadecimal numbers using MASM notation:</p>
<ol class="none">
<li>1234h   0DEADh   0BEEFh   0AFBh   0F001h   0D8B4h</li>
</ol>
<p>As you can see, hexadecimal numbers are compact and easy to read. In addition, you can easily convert between hexadecimal and binary. <a href="#table2-1" id="tableanchor2-1">Table 2-1</a> provides all the information you’ll ever need to convert any hexadecimal number into a binary number, or vice versa.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-1">Table 2-1</a>: Binary/Hexadecimal Conversion</p></figcaption>
<table id="table-501089c02-0001" border="1">
<thead>
<tr>
<td><b>Binary</b></td>
<td><b>Hexadecimal</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>0</td>
</tr>
<tr>
<td>0001</td>
<td>1</td>
</tr>
<tr>
<td>0010</td>
<td>2</td>
</tr>
<tr>
<td>0011</td>
<td>3</td>
</tr>
<tr>
<td>0100</td>
<td>4</td>
</tr>
<tr>
<td>0101</td>
<td>5</td>
</tr>
<tr>
<td>0110</td>
<td>6</td>
</tr>
<tr>
<td>0111</td>
<td>7</td>
</tr>
<tr>
<td>1000</td>
<td>8</td>
</tr>
<tr>
<td>1001</td>
<td>9</td>
</tr>
<tr>
<td>1010</td>
<td>A</td>
</tr>
<tr>
<td>1011</td>
<td>B</td>
</tr>
<tr>
<td>1100</td>
<td>C</td>
</tr>
<tr>
<td>1101</td>
<td>D</td>
</tr>
<tr>
<td>1110</td>
<td>E</td>
</tr>
<tr>
<td>1111</td>
<td>F</td>
</tr>
</tbody>
</table>
</figure>
<p>To convert a hexadecimal number into a binary number, substitute the corresponding 4 bits for each hexadecimal digit in the number. For <span epub:type="pagebreak" title="48" id="Page_48"/>example, to convert 0ABCDh into a binary value, convert each hexadecimal digit according to <a href="#table2-1">Table 2-1</a>, as shown here:</p>
<table id="tabular-501089c02-0002" border="1"><tbody>
<tr>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>Hexadecimal</td>
</tr>
<tr>
<td>1010</td>
<td>1011</td>
<td>1100</td>
<td>1101</td>
<td>Binary</td>
</tr>
</tbody>
</table>
<p>To convert a binary number into hexadecimal format is almost as easy:</p>
<ol class="decimal">
<li value="1">Pad the binary number with 0s to make sure that the number contains a multiple of 4 bits. For example, given the binary number 1011001010, add 2 bits to the left of the number so that it contains 12 bits: 001011001010.</li>
<li value="2">Separate the binary value into groups of 4 bits; for example, 0010_1100_1010.</li>
<li value="3">Look up these binary values in <a href="#table2-1">Table 2-1</a> and substitute the appropriate hexadecimal digits: 2CAh.</li>
</ol>
<p>Contrast this with the difficulty of conversion between decimal and binary, or decimal and hexadecimal!</p>
<p>Because converting between hexadecimal and binary is an operation you will need to perform over and over again, you should take a few minutes to memorize the conversion table. Even if you have a calculator that will do the conversion for you, you’ll find manual conversion to be a lot faster and more convenient.</p>
<h2 id="h1-501089c02-0003">	2.3	A Note About Numbers vs. Representation</h2>
<p class="BodyFirst">Many people confuse numbers and their representation. A common question beginning assembly language students ask is, “I have a binary number in the EAX register. How do I convert that to a hexadecimal number in the EAX register?” The answer is, “You don’t.”</p>
<p>Although a strong argument could be made that numbers in memory or in registers are represented in binary, it is best to view values in memory or in a register as <em>abstract numeric quantities</em>. Strings of symbols like 128, 80h, or 10000000b are not different numbers; they are simply different representations for the same abstract quantity that we refer to as <em>one hundred twenty-eight</em>. Inside the computer, a number is a number regardless of representation; the only time representation matters is when you input or output the value in a human-readable form.</p>
<p>Human-readable forms of numeric quantities are always strings of characters. To print the value 128 in human-readable form, you must convert the numeric value 128 to the three-character sequence 1 followed by 2 followed by 8. This would provide the decimal representation of the numeric quantity. If you prefer, you could convert the numeric value 128 to the three-character sequence 80h. It’s the same number, but we’ve converted it to a different sequence of characters because (presumably) we wanted to view the number using hexadecimal representation rather than decimal. Likewise, if we want to see the number in binary, we must convert this numeric value to a string containing a 1 followed by seven 0 characters.</p>
<p><span epub:type="pagebreak" title="49" id="Page_49"/>Pure assembly language has no generic print or write functions you can call to display numeric quantities as strings on your console. You could write your own procedures to handle this process (and this book considers some of those procedures later). For the time being, the MASM code in this book relies on the C Standard Library <code>printf()</code> function to display numeric values. Consider the program in <a href="#listing2-1" id="listinganchor2-1">Listing 2-1</a>, which converts various values to their hexadecimal equivalents.</p>
<pre><code>; Listing 2-1
 
; Displays some numeric values on the console.

        option  casemap:none

nl      =       10  ; ASCII code for newline

         .data
i        qword  1
j        qword  123
k        qword  456789

titleStr byte   'Listing 2-1', 0

fmtStrI  byte   "i=%d, converted to hex=%x", nl, 0
fmtStrJ  byte   "j=%d, converted to hex=%x", nl, 0
fmtStrK  byte   "k=%d, converted to hex=%x", nl, 0

        .code
        externdef   printf:proc

; Return program title to C++ program:

         public getTitle
getTitle proc

; Load address of "titleStr" into the RAX register (RAX holds
; the function return result) and return back to the caller:

         lea rax, titleStr
         ret
getTitle endp

; Here is the "asmMain" function.

        public  asmMain
asmMain proc
                           
; "Magic" instruction offered without explanation at this point:

        sub     rsp, 56

; Call printf three times to print the three values i, j, and k:
 
; printf("i=%d, converted to hex=%x\n", i, i);

<span epub:type="pagebreak" title="50" id="Page_50"/>        lea     rcx, fmtStrI
        mov     rdx, i
        mov     r8, rdx
        call    printf

; printf("j=%d, converted to hex=%x\n", j, j);

        lea     rcx, fmtStrJ
        mov     rdx, j
        mov     r8, rdx
        call    printf

; printf("k=%d, converted to hex=%x\n", k, k);

        lea     rcx, fmtStrK
        mov     rdx, k
        mov     r8, rdx
        call    printf

; Another "magic" instruction that undoes the effect of the previous
; one before this procedure returns to its caller.
 
        add     rsp, 56
        
        ret     ; Returns to caller
        
asmMain endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing2-1">Listing 2-1</a>: Decimal-to-hexadecimal conversion program</p>
<p><a href="#listing2-1">Listing 2-1</a> uses the generic <em>c.cpp</em> program from <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span> (and the generic <em>build.bat</em> batch file as well). You can compile and run this program by using the following commands at the command line:</p>
<pre><code>C:\&gt;<b>build  listing2-1</b>

C:\&gt;<b>echo off</b>
 Assembling: listing2-1.asm
c.cpp

C:\&gt;<b> listing2-1</b>
Calling Listing 2-1:
i=1, converted to hex=1
j=123, converted to hex=7b
k=456789, converted to hex=6f855
Listing 2-1 terminated</code></pre>
<h2 id="h1-501089c02-0004">	2.4	Data Organization</h2>
<p class="BodyFirst">In pure mathematics, a value’s representation may require an arbitrary number of bits. Computers, on the other hand, generally work with a <span epub:type="pagebreak" title="51" id="Page_51"/>specific number of bits. Common collections are single bits, groups of 4 bits (called <em>nibbles</em>), 8 bits (<em>bytes</em>), 16 bits (<em>words</em>), 32 bits (<em>double words</em>, or <em>dwords</em>), 64 bits (<em>quad words,</em> or <em>qwords</em>), 128 bits (<em>octal words,</em> or <em>owords</em>), and more.</p>
<h3 id="h2-501089c02-0004">2.4.1	Bits</h3>
<p class="BodyFirst">The smallest unit of data on a binary computer is a single <em>bit</em>. With a single bit, you can represent any two distinct items. Examples include 0 or 1, true or false, and right or wrong. However, you are <em>not</em> limited to representing binary data types; you could use a single bit to represent the numbers 723 and 1245 or, perhaps, the colors red and blue, or even the color red and the number 3256. You can represent <em>any</em> <em>two</em> different values with a single bit, but <em>only two</em> values with a single bit.</p>
<p>Different bits can represent different things. For example, you could use 1 bit to represent the values 0 and 1, while a different bit could represent the values true and false. How can you tell by looking at the bits? The answer is that you can’t. This illustrates the whole idea behind computer data structures: <em>data is what you define it to be</em>. If you use a bit to represent a Boolean (true/false) value, then that bit (by your definition) represents true or false. However, you must be consistent. If you’re using a bit to represent true or false at one point in your program, you shouldn’t use that value to represent red or blue later.</p>
<h3 id="h2-501089c02-0005">2.4.2	Nibbles</h3>
<p class="BodyFirst">A nibble is a collection of 4 bits. With a nibble, we can represent up to 16 distinct values because a string of 4 bits has 16 unique combinations:</p>
<pre><code>0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
1010
1011
1100
1101
1110
1111</code></pre>
<p>Nibbles are an interesting data structure because it takes 4 bits to represent a single digit in <em>binary-coded decimal (BCD)</em> numbers<sup class="FootnoteReference"><a id="c02-footnoteref-1" href="#c02-footnote-1">1</a></sup> and hexadecimal numbers. In the case of hexadecimal numbers, the values 0, 1, 2, 3, 4, 5, 6, 7, <span epub:type="pagebreak" title="52" id="Page_52"/>8, 9, A, B, C, D, E, and F are represented with 4 bits. BCD uses 10 different digits (0, 1, 2, 3, 4, 5, 6, 7, 8 and 9) and also requires 4 bits (because we can represent only eight different values with 3 bits, and the additional six values we can represent with 4 bits are never used in BCD representation). In fact, any 16 distinct values can be represented with a nibble, though hexadecimal and BCD digits are the primary items we can represent with a single nibble.</p>
<h3 id="h2-501089c02-0006">2.4.3	Bytes</h3>
<p class="BodyFirst">Without question, the most important data structure used by the x86-64 microprocessor is the byte, which consists of 8 bits. Main memory and I/O addresses on the x86-64 are all byte addresses. This means that the smallest item that can be individually accessed by an x86-64 program is an 8-bit value. To access anything smaller requires that we read the byte containing the data and eliminate the unwanted bits. The bits in a byte are normally numbered from 0 to 7, as shown in <a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a>.</p>
<figure>
<img src="image_fi/501089c02/f02001.png" alt="f02001" class=""/>
<figcaption><p><a id="figure2-1">Figure 2-1</a>: Bit numbering</p></figcaption>
</figure>
<p>Bit 0 is the LO bit, or least significant bit, and bit 7 is the HO bit, or most significant bit of the byte. We’ll refer to all other bits by their number.</p>
<p>A byte contains exactly two nibbles (see <a href="#figure2-2" id="figureanchor2-2">Figure 2-2</a>).</p>
<figure>
<img src="image_fi/501089c02/f02002.png" alt="f02002" class=""/>
<figcaption><p><a id="figure2-2">Figure 2-2</a>: The two nibbles in a byte</p></figcaption>
</figure>
<p>Bits 0 to 3 compose the <em>low-order nibble</em>, and bits 4 to 7 form the <em>high-order nibble</em>. Because a byte contains exactly two nibbles, byte values require two hexadecimal digits.</p>
<p>Because a byte contains 8 bits, it can represent 2<sup>8</sup> (256) different values. Generally, we’ll use a byte to represent numeric values in the range 0 through 255, signed numbers in the range –128 through +127 (see <span class="xref" itemid="xref_target_“Signed and Unsigned Numbers” on page 62">“Signed and Unsigned Numbers” on page 62</span>), ASCII IBM character codes, and other special data types requiring no more than 256 different values. Many data types have fewer than 256 items, so 8 bits are usually sufficient.</p>
<p>Because the x86-64 is a byte-addressable machine, it’s more efficient to manipulate a whole byte than an individual bit or nibble. So it’s more efficient to use a whole byte to represent data types that require no more than 256 items, even if fewer than 8 bits would suffice.</p>
<p>Probably the most important use for a byte is holding a character value. Characters typed at the keyboard, displayed on the screen, and printed on <span epub:type="pagebreak" title="53" id="Page_53"/>the printer all have numeric values. To communicate with the rest of the world, PCs typically use a variant of the <em>ASCII character set </em>or the<em> Unicode character set</em>. The ASCII character set has 128 defined codes.</p>
<p>Bytes are also the smallest variable you can create in a MASM program. To create an arbitrary byte variable, you should use the <code>byte</code> data type, as follows:</p>
<pre><code>         .data
byteVar  byte ?</code></pre>
<p>The <code>byte</code> data type is a partially untyped data type. The only type information associated with a <code>byte</code> object is its size (1 byte).<sup class="FootnoteReference"><a id="c02-footnoteref-2" href="#c02-footnote-2">2</a></sup> You may store any 8-bit value (small signed integers, small unsigned integers, characters, and the like) into a byte variable. It is up to you to keep track of the type of object you’ve put into a byte variable.</p>
<h3 id="h2-501089c02-0007">2.4.4	Words</h3>
<p class="BodyFirst">A word is a group of 16 bits. We’ll number the bits in a word from 0 to 15, as <a href="#figure2-3" id="figureanchor2-3">Figure 2-3</a> shows. Like the byte, bit 0 is the low-order bit. For words, bit 15 is the high-order bit. When referencing the other bits in a word, we’ll use their bit position number.</p>
<figure>
<img src="image_fi/501089c02/f02003.png" alt="f02003" class=""/>
<figcaption><p><a id="figure2-3">Figure 2-3</a>: Bit numbers in a word</p></figcaption>
</figure>
<p>A word contains exactly 2 bytes (and, therefore, four nibbles). Bits 0 to 7 form the low-order byte, and bits 8 to 15 form the high-order byte (see Figures 2-4 and 2-5).</p>
<figure>
<img src="image_fi/501089c02/f02004.png" alt="f02004" class=""/>
<figcaption><p><a id="figure2-4">Figure 2-4</a>: The 2 bytes in a word</p></figcaption>
</figure>
<figure>
<img src="image_fi/501089c02/f02005.png" alt="f02005" class=""/>
<figcaption><p><a id="figure2-5">Figure 2-5</a>: Nibbles in a word</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="54" id="Page_54"/>With 16 bits, you can represent 2<sup>16</sup> (65,536) values. These could be the values in the range 0 to 65,535 or, as is usually the case, the signed values –32,768 to +32,767, or any other data type with no more than 65,536 values.</p>
<p>The three major uses for words are short signed integer values, short unsigned integer values, and Unicode characters. Unsigned numeric values are represented by the binary value corresponding to the bits in the word. Signed numeric values use the two’s complement form for numeric values (see <span class="xref" itemid="xref_target_“Sign Extension and Zero Extension” on page 67">“Sign Extension and Zero Extension” on page 67</span>). As Unicode characters, words can represent up to 65,536 characters, allowing the use of non-Roman character sets in a computer program. Unicode is an international standard, like ASCII, that allows computers to process non-Roman characters such as Kanji, Greek, and Russian characters.</p>
<p>As with bytes, you can also create word variables in a MASM program. To create an arbitrary word variable, use the <code>word</code> data type as follows:</p>
<pre><code>         .data
w        word  ?</code></pre>
<h3 id="h2-501089c02-0008">2.4.5	Double Words</h3>
<p class="BodyFirst">A double word is exactly what its name indicates: a pair of words. Therefore, a double-word quantity is 32 bits long, as shown in <a href="#figure2-6" id="figureanchor2-6">Figure 2-6</a>.</p>
<figure>
<img src="image_fi/501089c02/f02006.png" alt="f02006" class=""/>
<figcaption><p><a id="figure2-6">Figure 2-6</a>: Bit numbers in a double word</p></figcaption>
</figure>
<p>Naturally, this double word can be divided into a high-order word and a low-order word, 4 bytes, or eight different nibbles (see <a href="#figure2-7" id="figureanchor2-7">Figure 2-7</a>).</p>
<p>Double words (dwords) can represent all kinds of things. A common item you will represent with a double word is a 32-bit integer value (which allows unsigned numbers in the range 0 to 4,294,967,295 or signed numbers in the range –2,147,483,648 to 2,147,483,647). 32-bit floating-point values also fit into a double word.</p>
<figure class="graphic">
<img src="image_fi/501089c02/f02007a.png" alt="f02007a"/></figure>

<figure class="graphic">
<img src="image_fi/501089c02/f02007b.png" alt="f02007b"/></figure>

<figure>
<img src="image_fi/501089c02/f02007c.png" alt="f02007c" class=""/>
<figcaption><p><a id="figure2-7">Figure 2-7</a>: Nibbles, bytes, and words in a double word</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="55" id="Page_55"/>You can create an arbitrary double-word variable by using the <code>dword</code> data type, as the following example demonstrates:</p>
<pre><code>      .data
d     dword  ?</code></pre>
<h3 id="h2-501089c02-0009">2.4.6	Quad Words and Octal Words</h3>
<p class="BodyFirst">Quad-word (64-bit) values are also important because 64-bit integers, pointers, and certain floating-point data types require 64 bits. Likewise, the SSE/MMX instruction set of modern x86-64 processors can manipulate 64-bit values. In a similar vein, octal-word (128-bit) values are important because the AVX/SSE instruction set can manipulate 128-bit values. MASM allows the declaration of 64- and 128-bit values by using the <code>qword</code> and <code>oword</code> types, as follows:</p>
<pre><code>      .data
o     oword ?
q     qword ?</code></pre>
<p>You may not directly manipulate 128-bit integer objects using standard instructions like <code>mov</code>, <code>add</code>, and <code>sub</code> because the standard x86-64 integer registers process only 64 bits at a time. In <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, you will see how to manipulate these extended-precision values; <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span> describes how to directly manipulate <code>oword</code> values by using SIMD instructions.</p>
<h2 id="h1-501089c02-0005">	2.5	Logical Operations on Bits</h2>
<p class="BodyFirst">We’ll do four primary logical operations (Boolean functions) with hexadecimal and binary numbers: AND, OR, XOR (exclusive-or), and NOT.</p>
<h3 id="h2-501089c02-0010">2.5.1	The AND Operation</h3>
<p class="BodyFirst">The <em>logical AND operation</em> is a <em>dyadic</em> operation (meaning it accepts exactly two operands).<sup class="FootnoteReference"><a id="c02-footnoteref-3" href="#c02-footnote-3">3</a></sup> These operands are individual binary bits. The AND operation is shown here:</p>
<pre><code>0 and 0 = 0
0 and 1 = 0
1 and 0 = 0
1 and 1 = 1</code></pre>
<p>A compact way to represent the logical AND operation is with a truth table. A <em>truth table</em> takes the form shown in <a href="#table2-2" id="tableanchor2-2">Table 2-2</a>. </p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-2">Table 2-2</a>: AND Truth Table</p></figcaption>
<table id="table-501089c02-0003" border="1">
<thead>
<tr>
<td><b>AND</b></td>
<td><b>0</b></td>
<td><b>1</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="56" id="Page_56"/>This is just like the multiplication tables you’ve encountered in school. The values in the left column correspond to the left operand of the AND operation. The values in the top row correspond to the right operand of the AND operation. The value located at the intersection of the row and column (for a particular pair of input values) is the result of logically ANDing those two values together.</p>
<p>In English, the logical AND operation is, “If the first operand is 1 and the second operand is 1, the result is 1; otherwise, the result is 0.” We could also state this as, “If either or both operands are 0, the result is 0.”</p>
<p>You can use the logical AND operation to force a 0 result: if one of the operands is 0, the result is always 0 regardless of the other operand. In <a href="#table2-2">Table 2-2</a>, for example, the row labeled with a 0 input contains only 0s, and the column labeled with a 0 contains only 0s. Conversely, if one operand contains a 1, the result is exactly the value of the second operand. These results of the AND operation are important, particularly when we want to force bits to 0. We will investigate these uses of the logical AND operation in the next section.</p>
<h3 id="h2-501089c02-0011">2.5.2	The OR Operation</h3>
<p class="BodyFirst">The <em>logical OR operation</em> is also a dyadic operation. Its definition is as follows:</p>
<pre><code>0 or 0 = 0
0 or 1 = 1
1 or 0 = 1
1 or 1 = 1</code></pre>
<p><a href="#table2-3" id="tableanchor2-3">Table 2-3</a> shows the truth table for the OR operation.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-3">Table 2-3</a>: OR Truth Table</p></figcaption>
<table id="table-501089c02-0004" border="1">
<thead>
<tr>
<td><b>OR</b></td>
<td><b>0</b></td>
<td><b>1</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</figure>
<p>Colloquially, the logical OR operation is, “If the first operand or the second operand (or both) is 1, the result is 1; otherwise, the result is 0.” This is also known as the <em>inclusive-or</em> operation.</p>
<p>If one of the operands to the logical OR operation is a 1, the result is always 1 regardless of the second operand’s value. If one operand is 0, the result is always the value of the second operand. Like the logical AND operation, this is an important side effect of the logical OR operation that will prove quite useful.</p>
<p>Note that there is a difference between this form of the inclusive logical OR operation and the standard English meaning. Consider the sentence “I am going to the store <em>or</em> I am going to the park.” Such a statement implies that the speaker is going to the store or to the park, but not to both places. Therefore, the English version of logical OR is slightly different from the inclusive-or operation; indeed, this is the definition of the <em>exclusive-or</em> operation.</p>
<h3 id="h2-501089c02-0012"><span epub:type="pagebreak" title="57" id="Page_57"/>2.5.3	The XOR Operation</h3>
<p class="BodyFirst">The <em>logical </em><em>XOR (</em><em>exclusive-or) operation</em> is also a dyadic operation. Its definition follows:</p>
<pre><code>0 xor 0 = 0
0 xor 1 = 1
1 xor 0 = 1
1 xor 1 = 0</code></pre>
<p><a href="#table2-4" id="tableanchor2-4">Table 2-4</a> shows the truth table for the XOR operation.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-4">Table 2-4</a>: XOR Truth Table</p></figcaption>
<table id="table-501089c02-0005" border="1">
<thead>
<tr>
<td><b>XOR</b></td>
<td><b>0</b></td>
<td><b>1</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</figure>
<p>In English, the logical XOR operation is, “If the first operand or the second operand, but not both, is 1, the result is 1; otherwise, the result is 0.” The exclusive-or operation is closer to the English meaning of the word <em>or</em> than is the logical OR operation.</p>
<p>If one of the operands to the logical exclusive-or operation is a 1, the result is always the <em>inverse</em> of the other operand; that is, if one operand is 1, the result is 0 if the other operand is 1, and the result is 1 if the other operand is 0. If the first operand contains a 0, the result is exactly the value of the second operand. This feature lets you selectively invert bits in a bit string.</p>
<h3 id="h2-501089c02-0013">2.5.4	The NOT Operation</h3>
<p class="BodyFirst">The logical NOT operation is a <em>monadic operation</em> (meaning it accepts only one operand):</p>
<pre><code>not 0 = 1
not 1 = 0</code></pre>
<p>The truth table for the NOT operation appears in <a href="#table2-5" id="tableanchor2-5">Table 2-5</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-5">Table 2-5</a>: NOT Truth Table</p></figcaption>
<table id="table-501089c02-0006" border="1">
<thead>
<tr>
<td><b>NOT</b></td>
<td><b>0</b></td>
<td><b>1</b></td>
</tr>
</thead>
<tbody>
<tr>
<td/>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="h1-501089c02-0006">	2.6	Logical Operations on Binary Numbers and Bit Strings</h2>
<p class="BodyFirst">The previous section defines the logical functions for single-bit operands. Because the x86-64 uses groups of 8, 16, 32, 64, or more bits,<sup class="FootnoteReference"><a id="c02-footnoteref-4" href="#c02-footnote-4">4</a></sup> we need to extend the definition of these functions to deal with more than 2 bits.</p>
<p><span epub:type="pagebreak" title="58" id="Page_58"/>Logical functions on the x86-64 operate on a <em>bit-by-bit</em> (or <em>bitwise</em>) basis. Given two values, these functions operate on bit 0 of each value, producing bit 0 of the result; then they operate on bit 1 of the input values, producing bit 1 of the result, and so on. For example, if you want to compute the logical AND of the following two 8-bit numbers, you would perform the logical AND operation on each column independently of the others:</p>
<pre><code>1011_0101b
1110_1110b
----------
1010_0100b</code></pre>
<p>You may apply this bit-by-bit calculation to the other logical functions as well.</p>
<p>To perform a logical operation on two hexadecimal numbers, you should convert them to binary first.</p>
<p>The ability to force bits to 0 or 1 by using the logical AND/OR operations and the ability to invert bits using the logical XOR operation are very important when working with strings of bits (for example, binary numbers). These operations let you selectively manipulate certain bits within a bit string while leaving other bits unaffected.</p>
<p>For example, if you have an 8-bit binary value <em>X</em> and you want to guarantee that bits 4 to 7 contain 0s, you could logically AND the value <em>X</em> with the binary value 0000_1111b. This bitwise logical AND operation would force the HO 4 bits to 0 and pass the LO 4 bits of <em>X</em> unchanged. Likewise, you could force the LO bit of <em>X</em> to 1 and invert bit 2 of <em>X</em> by logically ORing <em>X</em> with 0000_0001b and logically XORing <em>X</em> with 0000_0100b, respectively.</p>
<p>Using the logical AND, OR, and XOR operations to manipulate bit strings in this fashion is known as <em>masking</em> bit strings. We use the term <em>masking</em> because we can use certain values (1 for AND, 0 for OR/XOR) to mask out or mask in certain bits from the operation when forcing bits to 0, 1, or their inverse.</p>
<p>The x86-64 CPUs support four instructions that apply these bitwise logical operations to their operands. The instructions are <code>and</code>, <code>or</code>, <code>xor</code>, and <code>not</code>. The <code>and</code>, <code>or</code>, and <code>xor</code> instructions use the same syntax as the <code>add</code> and <code>sub</code> instructions:</p>
<pre><code>and  <var>dest</var>, <var>source</var>
or   <var>dest</var>, <var>source</var>
xor  <var>dest</var>, <var>source</var></code></pre>
<p>These operands have the same limitations as the <code>add</code> operands. Specifically, the <var>source</var> operand has to be a constant, memory, or register operand, and the <var>dest</var> operand must be a memory or register operand. Also, the operands must be the same size and cannot both be memory operands. If the destination operand is 64 bits and the source operand is a constant, that constant is limited to 32 bits (or fewer), and the CPU will sign-extend the value to 64 bits (see <span class="xref" itemid="xref_target_“Sign Extension and Zero Extension">“Sign Extension and Zero Extension</span>”<span class="xref" itemid="xref_target_ on page 67"> on page 67</span>).</p>
<p><span epub:type="pagebreak" title="59" id="Page_59"/>These instructions compute the obvious bitwise logical operation via the following equation:</p>
<pre><code>dest = <var>dest</var> <var>operator</var> <var>source</var></code></pre>
<p>The x86-64 logical <code>not</code> instruction, because it has only a single operand, uses a slightly different syntax. This instruction takes the following form:</p>
<pre><code>not  <var>dest</var> </code></pre>
<p>This instruction computes the following result:</p>
<pre><code>dest = not(<var>dest</var>)</code></pre>
<p>The <var>dest</var> operand must be a register or memory operand. This instruction inverts all the bits in the specified destination operand.</p>
<p>The program in <a href="#listing2-2" id="listinganchor2-2">Listing 2-2</a> inputs two hexadecimal values from the user and calculates their logical <code>and</code>, <code>or</code>, <code>xor</code>, and <code>not</code>.</p>
<pre><code>; Listing 2-2
 
; Demonstrate AND, OR, XOR, and NOT logical instructions.

            option  casemap:none

nl          =       10  ; ASCII code for newline

             .data
leftOp       dword   0f0f0f0fh
rightOp1     dword   0f0f0f0f0h
rightOp2     dword   12345678h

titleStr     byte   'Listing 2-2', 0

fmtStr1      byte   "%lx AND %lx = %lx", nl, 0
fmtStr2      byte   "%lx OR  %lx = %lx", nl, 0
fmtStr3      byte   "%lx XOR %lx = %lx", nl, 0
fmtStr4      byte   "NOT %lx = %lx", nl, 0

            .code
            externdef   printf:proc

; Return program title to C++ program:

            public getTitle
getTitle    proc

;  Load address of "titleStr" into the RAX register (RAX holds the
;  function return result) and return back to the caller:
 
            lea rax, titleStr
            ret
getTitle    endp

<span epub:type="pagebreak" title="60" id="Page_60"/>; Here is the "asmMain" function.

            public  asmMain
asmMain     proc

; "Magic" instruction offered without explanation at this point:

            sub     rsp, 56

; Demonstrate the AND instruction:

            lea     rcx, fmtStr1
            mov     edx, leftOp
            mov     r8d, rightOp1
            mov     r9d, edx  ; Compute leftOp
            and     r9d, r8d  ; AND rightOp1
            call    printf

            lea     rcx, fmtStr1
            mov     edx, leftOp
            mov     r8d, rightOp2
            mov     r9d, r8d
            and     r9d, edx
            call    printf

; Demonstrate the OR instruction:

            lea     rcx, fmtStr2
            mov     edx, leftOp
            mov     r8d, rightOp1
            mov     r9d, edx  ; Compute leftOp
            or      r9d, r8d  ; OR rightOp1
            call    printf

            lea     rcx, fmtStr2
            mov     edx, leftOp
            mov     r8d, rightOp2
            mov     r9d, r8d
            or      r9d, edx
            call    printf

; Demonstrate the XOR instruction:

            lea     rcx, fmtStr3
            mov     edx, leftOp
            mov     r8d, rightOp1
            mov     r9d, edx  ; Compute leftOp
            xor     r9d, r8d  ; XOR rightOp1
            call    printf

            lea     rcx, fmtStr3
            mov     edx, leftOp
            mov     r8d, rightOp2
            mov     r9d, r8d
<span epub:type="pagebreak" title="61" id="Page_61"/>            xor     r9d, edx
            call    printf

; Demonstrate the NOT instruction:

            lea     rcx, fmtStr4
            mov     edx, leftOp
            mov     r8d, edx  ; Compute not leftOp
            not     r8d
            call    printf

            lea     rcx, fmtStr4
            mov     edx, rightOp1
            mov     r8d, edx  ; Compute not rightOp1
            not     r8d
            call    printf

            lea     rcx, fmtStr4
            mov     edx, rightOp2
            mov     r8d, edx  ; Compute not rightOp2
            not     r8d
            call    printf

; Another "magic" instruction that undoes the effect of the previous
; one before this procedure returns to its caller.

            add     rsp, 56

            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing2-2">Listing 2-2</a>: <code>and</code>, <code>or</code>, <code>xor</code>, and <code>not</code> example</p>
<p>Here’s the result of building and running this code:</p>
<pre><code>C:\MASM64&gt;<b>build  listing2-2</b>

C:\MASM64&gt;<b>ml64 /nologo /c /Zi /Cp  listing2-2.asm</b>
 Assembling: listing2-2.asm

C:\MASM64&gt;<b>cl /nologo /O2 /Zi /utf-8 /Fe listing2-2.exe c.cpp  listing2-2.obj</b>
c.cpp

C:\MASM64&gt;<b> listing2-2</b>
Calling Listing 2-2:
f0f0f0f AND f0f0f0f0 = 0
f0f0f0f AND 12345678 = 2040608
f0f0f0f OR  f0f0f0f0 = ffffffff
f0f0f0f OR  12345678 = 1f3f5f7f
f0f0f0f XOR f0f0f0f0 = ffffffff
f0f0f0f XOR 12345678 = 1d3b5977
NOT f0f0f0f = f0f0f0f0
NOT f0f0f0f0 = f0f0f0f
<span epub:type="pagebreak" title="62" id="Page_62"/>NOT 12345678 = edcba987
Listing 2-2 terminated</code></pre>
<p>By the way, you will often see the following “magic” instruction:</p>
<pre><code>xor <var>reg</var>, <var>reg</var></code></pre>
<p>XORing a register with itself sets that register to 0. Except for 8-bit registers, the <code>xor</code> instruction is usually more efficient than moving the immediate constant into the register. Consider the following:</p>
<pre><code>xor eax, eax  ; Just 2 bytes long in machine code
mov eax, 0    ; Depending on register, often 6 bytes long</code></pre>
<p>The savings are even greater when dealing with 64-bit registers (as the immediate constant <code>0</code> is 8 bytes long by itself).</p>
<h2 id="h1-501089c02-0007">	2.7	Signed and Unsigned Numbers</h2>
<p class="BodyFirst">Thus far, we’ve treated binary numbers as unsigned values. The binary number . . . 00000 represents 0, . . . 00001 represents 1, . . . 00010 represents 2, and so on toward infinity. With <em>n</em> bits, we can represent 2<sup><em>n</em></sup> unsigned numbers. What about negative numbers? If we assign half of the possible combinations to the negative values, and half to the positive values and 0, with <em>n </em>bits we can represent the signed values in the range –2<sup><em>n</em></sup><sup>-1</sup> to +2<sup><em>n</em></sup><sup>-1</sup> –1. So we can represent the negative values –128 to –1 and the non-negative values 0 to 127 with a single 8-bit byte. With a 16-bit word, we can represent values in the range –32,768 to +32,767. With a 32-bit double word, we can represent values in the range –2,147,483,648 to +2,147,483,647.</p>
<p>In mathematics (and computer science), the <em>complement method</em> encodes negative and non-negative (positive plus zero) numbers into two equal sets in such a way that they can use the same algorithm (or hardware) to perform addition and produce the correct result regardless of the sign. </p>
<p>The x86-64 microprocessor uses the<em> two’s complement </em>notation to represent signed numbers. In this<em> </em>system, the HO bit of a number is a <em>sign bit </em>(dividing the integers into two equal sets). If the sign bit is 0, the number is positive (or zero); if the sign bit is 1, the number is negative (taking a complement form, which I’ll describe in a moment). Following are some examples.</p>
<p>For 16-bit numbers:</p>
<ul>
<li>8000h is negative because the HO bit is 1.</li>
<li>100h is positive because the HO bit is 0.</li>
<li>7FFFh is positive.</li>
<li>0FFFFh is negative.</li>
<li>0FFFh is positive.</li>
</ul>
<p>If the HO bit is 0, the number is positive (or 0) and uses the standard binary format. If the HO bit is 1, the number is negative and uses the two’s <span epub:type="pagebreak" title="63" id="Page_63"/>complement form (which is the magic form that supports addition of negative and non-negative numbers with no special hardware).</p>
<p>To convert a positive number to its negative, two’s complement form, you use the following algorithm:</p>
<ol class="decimal">
<li value="1">Invert all the bits in the number; that is, apply the logical NOT function.</li>
<li value="2">Add 1 to the inverted result and ignore any carry out of the HO bit.</li>
</ol>
<p>This produces a bit pattern that satisfies the mathematical definition of the complement form. In particular, adding negative and non-negative numbers using this form produces the expected result.</p>
<p>For example, to compute the 8-bit equivalent of –5:</p>
<ul>
<li>0000_0101b            5 (in binary).</li>
<li>1111_1010b             Invert all the bits.</li>
<li>1111_1011b             Add 1 to obtain result.</li>
</ul>
<p>If we take –5 and perform the two’s complement operation on it, we get our original value, 0000_0101b, back again:</p>
<ul>
<li>1111_1011b             Two’s complement for –5.</li>
<li>0000_0100b            Invert all the bits.</li>
<li>0000_0101b            Add 1 to obtain result (+5).</li>
</ul>
<p>Note that if we add +5 and –5 together (ignoring any carry out of the HO bit), we get the expected result of 0:</p>
<pre><code>      1111_1011b         Two's complement for -5
    + 0000_0101b         Invert all the bits and add 1
      ----------
  (1) 0000_0000b         Sum is zero, if we ignore carry</code></pre>
<p>The following examples provide some positive and negative 16-bit signed values:</p>
<ul>
<li>7FFFh: +32767, the largest 16-bit positive number</li>
<li>8000h: –32768, the smallest 16-bit negative number</li>
<li>4000h: +16384</li>
</ul>
<p>To convert the preceding numbers to their negative counterpart (that is, to negate them), do the following:</p>
<pre><code>7FFFh:      0111_1111_1111_1111b   +32,767
            1000_0000_0000_0000b   Invert all the bits (8000h)
            1000_0000_0000_0001b   Add 1 (8001h or -32,767)

4000h:      0100_0000_0000_0000b   16,384
            1011_1111_1111_1111b   Invert all the bits (0BFFFh)
            1100_0000_0000_0000b   Add 1 (0C000h or -16,384)

<span epub:type="pagebreak" title="64" id="Page_64"/>8000h:      1000_0000_0000_0000b   -32,768
            0111_1111_1111_1111b   Invert all the bits (7FFFh)
            1000_0000_0000_0000b   Add one (8000h or -32,768)</code></pre>
<p>8000h inverted becomes 7FFFh. After adding 1, we obtain 8000h! Wait, what’s going on here? – (–32,768) is –32,768? Of course not. But the value +32,768 cannot be represented with a 16-bit signed number, so we cannot negate the smallest negative value.</p>
<p>Usually, you will not need to perform the two’s complement operation by hand. The x86-64 microprocessor provides an instruction, <code>neg</code> (<em>negate</em>), that performs this operation for you:</p>
<pre><code>neg <var>dest</var> </code></pre>
<p>This instruction computes <var>dest</var> <code>=</code> <code>-</code><var>dest</var><code>;</code> and the operand must be a memory location or a register. <code>neg</code> operates on byte-, word-, dword-, and qword-sized objects. Because this is a signed integer operation, it only makes sense to operate on signed integer values. The program in <a href="#listing2-3" id="listinganchor2-3">Listing 2-3</a> demonstrates the two’s complement operation and the <code>neg</code> instruction on signed 8-bit integer values.</p>
<pre><code>; Listing 2-3
 
; Demonstrate two's complement operation and input of numeric values.

        option  casemap:none

nl       =      10  ; ASCII code for newline
maxLen   =      256

         .data
titleStr byte   'Listing 2-3', 0

prompt1  byte   "Enter an integer between 0 and 127:", 0
fmtStr1  byte   "Value in hexadecimal: %x", nl, 0
fmtStr2  byte   "Invert all the bits (hexadecimal): %x", nl, 0
fmtStr3  byte   "Add 1 (hexadecimal): %x", nl, 0
fmtStr4  byte   "Output as signed integer: %d", nl, 0
fmtStr5  byte   "Using neg instruction: %d", nl, 0

intValue sqword ?
input    byte   maxLen dup (?)

            .code
            externdef printf:proc
            externdef atoi:proc
            externdef readLine:proc

; Return program title to C++ program:

            public getTitle
getTitle    proc
            lea rax, titleStr
<span epub:type="pagebreak" title="65" id="Page_65"/>            ret
getTitle    endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc

; "Magic" instruction offered without explanation at this point:

            sub     rsp, 56

; Read an unsigned integer from the user: This code will blindly
; assume that the user's input was correct. The atoi function returns
; zero if there was some sort of error on the user input. Later
; chapters in Ao64A will describe how to check for errors from the
; user.

            lea     rcx, prompt1
            call    printf

            lea     rcx, input
            mov     rdx, maxLen
            call    readLine

; Call C stdlib atoi function.
 
; i = atoi(str)
        
            lea     rcx, input
            call    atoi
            and     rax, 0ffh      ; Only keep LO 8 bits
            mov     intValue, rax

; Print the input value (in decimal) as a hexadecimal number:

            lea     rcx, fmtStr1
            mov     rdx, rax
            call    printf

; Perform the two's complement operation on the input number.
; Begin by inverting all the bits (just work with a byte here).

            mov     rdx, intValue
            not     dl             ; Only work with 8-bit values!
            lea     rcx, fmtStr2
            call    printf

; Invert all the bits and add 1 (still working with just a byte).

            mov     rdx, intValue
            not     rdx
            add     rdx, 1
            and     rdx, 0ffh      ; Only keep LO eight bits
<span epub:type="pagebreak" title="66" id="Page_66"/>            lea     rcx, fmtStr3
            call    printf

; Negate the value and print as a signed integer (work with a full
; integer here, because C++ %d format specifier expects a 32-bit
; integer). HO 32 bits of RDX get ignored by C++.

            mov     rdx, intValue
            not     rdx
            add     rdx, 1
            lea     rcx, fmtStr4
            call    printf

; Negate the value using the neg instruction.

            mov     rdx, intValue
            neg     rdx
            lea     rcx, fmtStr5
            call    printf

; Another "magic" instruction that undoes the effect of the previous
; one before this procedure returns to its caller.

            add     rsp, 56
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing2-3">Listing 2-3</a>: Two’s complement example</p>
<p>The following commands build and run the program in <a href="#listing2-3">Listing 2-3</a>:</p>
<pre><code>C:\&gt;<b>build  listing2-3</b>

C:\&gt;<b>echo off</b>
 Assembling: listing2-3.asm
c.cpp

C:\&gt;<b> listing2-3</b>
Calling Listing 2-3:
Enter an integer between 0 and 127:123
Value in hexadecimal: 7b
Invert all the bits (hexadecimal): 84
Add 1 (hexadecimal): 85
Output as signed integer: -123
Using neg instruction: -123
Listing 2-3 terminated</code></pre>
<p>Beyond the two’s complement operation (both by inversion/add 1 and using the <code>neg</code> instruction), this program demonstrates one new feature: user numeric input. <em>Numeric input</em> is accomplished by reading an input string from the user (using the <code>readLine()</code> function that is part of the <em>c.cpp</em> source file) and then calling the C Standard Library <code>atoi()</code> function. This function <span epub:type="pagebreak" title="67" id="Page_67"/>requires a single parameter (passed in RCX) that points to a string containing an integer value. It translates that string to the corresponding integer and returns the integer value in RAX.<sup class="FootnoteReference"><a id="c02-footnoteref-5" href="#c02-footnote-5">5</a></sup> </p>
<h2 id="h1-501089c02-0008">	2.8	Sign Extension and Zero Extension</h2>
<p class="BodyFirst">Converting an 8-bit two’s complement value to 16 bits, and conversely converting a 16-bit value to 8 bits, can be accomplished via <em>sign extension</em> and <em>contraction</em> operations.</p>
<p>To extend a signed value from a certain number of bits to a greater number of bits, copy the sign bit into all the additional bits in the new format. For example, to sign-extend an 8-bit number to a 16-bit number, copy bit 7 of the 8-bit number into bits 8 to 15 of the 16-bit number. To sign-extend a 16-bit number to a double word, copy bit 15 into bits 16 to 31 of the double word.</p>
<p>You must use sign extension when manipulating signed values of varying lengths. For example, to add a byte quantity to a word quantity, you must sign-extend the byte quantity to a word before adding the two values. Other operations (multiplication and division, in particular) may require a sign extension to 32 bits; see <a href="#table2-6" id="tableanchor2-6">Table 2-6</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-6">Table 2-6</a>: Sign Extension</p></figcaption>
<table id="table-501089c02-0007" border="1">
<thead>
<tr>
<td><b>8 Bits</b></td>
<td><b>16 Bits</b></td>
<td><b>32 Bits</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>80h</td>
<td>0FF80h</td>
<td>0FFFFFF80h</td>
</tr>
<tr>
<td>28h</td>
<td>0028h</td>
<td>00000028h</td>
</tr>
<tr>
<td>9Ah</td>
<td>0FF9Ah</td>
<td>0FFFFFF9Ah</td>
</tr>
<tr>
<td>7Fh</td>
<td>007Fh</td>
<td>0000007Fh</td>
</tr>
<tr>
<td/>
<td>1020h</td>
<td>00001020h</td>
</tr>
<tr>
<td/>
<td>8086h</td>
<td>0FFFF8086h</td>
</tr>
</tbody>
</table>
</figure>
<p>To extend an unsigned value to a larger one, you must zero-extend the value, as shown in <a href="#table2-7" id="tableanchor2-7">Table 2-7</a>. <em>Zero extension</em> is easy—just store a 0 into the HO byte(s) of the larger operand. For example, to zero-extend the 8-bit value 82h to 16 bits, you prepend a 0 to the HO byte, yielding 0082h.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-7">Table 2-7</a>: Zero Extension</p></figcaption>
<table id="table-501089c02-0008" border="1">
<thead>
<tr>
<td><b>8 Bits</b></td>
<td><b>16 Bits</b></td>
<td><b>32 Bits</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>80h</td>
<td>0080h</td>
<td>00000080h</td>
</tr>
<tr>
<td>28h</td>
<td>0028h</td>
<td>00000028h</td>
</tr>
<tr>
<td><span epub:type="pagebreak" title="68" id="Page_68"/>9Ah</td>
<td>009Ah</td>
<td>0000009Ah</td>
</tr>
<tr>
<td>7Fh</td>
<td>007Fh</td>
<td>0000007Fh</td>
</tr>
<tr>
<td/>
<td>1020h</td>
<td>00001020h</td>
</tr>
<tr>
<td/>
<td>8086h</td>
<td>00008086h</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="h1-501089c02-0009">	2.9	Sign Contraction and Saturation</h2>
<p class="BodyFirst"><em>Sign</em> <em>contraction</em>, converting a value with a certain number of bits to the identical value with a fewer number of bits, is a little more troublesome. Given an <em>n</em>-bit number, you cannot always convert it to an <em>m</em>-bit number if <em>m</em> &lt; <em>n</em>. For example, consider the value –448. As a 16-bit signed number, its hexadecimal representation is 0FE40h. The magnitude of this number is too large for an 8-bit value, so you cannot sign-contract it to 8 bits (doing so would create an overflow condition). </p>
<p>To properly sign-contract a value, the HO bytes to discard must all contain either 0 or 0FFh, and the HO bit of your resulting value must match <em>every </em>bit you’ve removed from the number. Here are some examples (16 bits to 8 bits):</p>
<ul>
<li>0FF80h can be sign-contracted to 80h.</li>
<li>0040h can be sign-contracted to 40h.</li>
<li>0FE40h cannot be sign-contracted to 8 bits.</li>
<li>0100h cannot be sign-contracted to 8 bits.</li>
</ul>
<p>If you must convert a larger object to a smaller object, and you’re willing to live with loss of precision, you can use <em>saturation</em>. To convert a value via saturation, you copy the larger value to the smaller value if it is not outside the range of the smaller object. If the larger value is outside the range of the smaller value, you <em>clip</em> the value by setting it to the largest (or smallest) value within the range of the smaller object.</p>
<p>For example, when converting a 16-bit signed integer to an 8-bit signed integer, if the 16-bit value is in the range –128 to +127, you copy the LO byte of the 16-bit object to the 8-bit object. If the 16-bit signed value is greater than +127, then you clip the value to +127 and store +127 into the 8-bit object. Likewise, if the value is less than –128, you clip the final 8-bit object to –128.</p>
<p>Although clipping the value to the limits of the smaller object results in loss of precision, sometimes this is acceptable because the alternative is to raise an exception or otherwise reject the calculation. For many applications, such as audio or video processing, the clipped result is still recognizable, so this is a reasonable conversion.</p>
<h2 id="h1-501089c02-0010"><span epub:type="pagebreak" title="69" id="Page_69"/>	2.10	Brief Detour: An Introduction to Control Transfer Instructions</h2>
<p class="BodyFirst">The assembly language examples thus far have limped along without making use of <em>conditional execution</em> (that is, the ability to make decisions while executing code). Indeed, except for the <code>call</code> and <code>ret</code> instructions, you haven’t seen any way to affect the straight-line execution of assembly code. </p>
<p>However, this book is rapidly approaching the point where meaningful examples require the ability to conditionally execute different sections of code. This section provides a brief introduction to the subject of conditional execution and transferring control to other sections of your program.</p>
<h3 id="h2-501089c02-0014">2.10.1	The jmp Instruction</h3>
<p class="BodyFirst">Perhaps the best place to start is with a discussion of the x86-64 unconditional transfer-of-control instruction—the <code>jmp</code> instruction. The <code>jmp</code> instruction takes several forms, but the most common form is</p>
<pre><code>jmp <var>statement_label</var></code></pre>
<p class="BodyContinued">where <var>statement_label</var> is an identifier attached to a machine instruction in your <code>.code</code> section. The <code>jmp</code> instruction immediately transfers control to the statement prefaced by the label. This is semantically equivalent to a <code>goto</code> statement in an HLL.</p>
<p>Here is an example of a statement label in front of a <code>mov</code> instruction:</p>
<pre><code>stmtLbl: mov eax, 55</code></pre>
<p>Like all MASM symbols, statement labels have two major attributes associated with them: an address (which is the memory address of the machine instruction following the label) and a type. The type is <code>label</code>, which is the same type as a <code>proc</code> directive’s identifier.</p>
<p>Statement labels don’t have to be on the same physical source line as a machine instruction. Consider the following example:</p>
<pre><code>anotherLabel:
   mov eax, 55</code></pre>
<p>This example is semantically equivalent to the previous one. The value (address) bound to <code>anotherLabel</code> is the address of the machine instruction following the label. In this case, it’s still the <code>mov</code> instruction even though that <code>mov</code> instruction appears on the next line (it still follows the label without any other MASM statements that would generate code occurring between the label and the <code>mov</code> statement).</p>
<p>Technically, you could also jump to a <code>proc</code> label instead of a statement label. However, the <code>jmp</code> instruction does not set up a return address, so if the procedure executes a <code>ret</code> instruction, the return location may be undefined. (<span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> explores return addresses in greater detail.)</p>
<h3 id="h2-501089c02-0015"><span epub:type="pagebreak" title="70" id="Page_70"/>2.10.2	The Conditional Jump Instructions</h3>
<p class="BodyFirst">Although the common form of the <code>jmp</code> instruction is indispensable in assembly language programs, it doesn’t provide any ability to conditionally execute different sections of code—hence the name <em>unconditional jump</em>.<sup class="FootnoteReference"><a id="c02-footnoteref-6" href="#c02-footnote-6">6</a></sup> Fortunately, the x86-64 CPUs provide a wide array of <em>conditional jump instructions</em> that, as their name suggests, allow conditional execution of code.</p>
<p>These instructions test the condition code bits (see <span class="xref" itemid="xref_target_“An Introduction to the Intel x86-64 CPU Family” in Chapter 1">“An Introduction to the Intel x86-64 CPU Family” in Chapter 1</span>) in the FLAGS register to determine whether a branch should be taken. There are four condition code bits in the FLAGs register that these conditional jump instructions test: the carry, sign, overflow, and zero flags.<sup class="FootnoteReference"><a id="c02-footnoteref-7" href="#c02-footnote-7">7</a></sup></p>
<p>The x86-64 CPUs provide eight instructions that test each of these four flags (see <a href="#table2-8" id="tableanchor2-8">Table 2-8</a>). The basic operation of the conditional jump instructions is that they test a flag to see if it is set (<code>1</code>) or clear (<code>0</code>) and branch to a target label if the test succeeds. If the test fails, the program continues execution with the next instruction following the conditional jump instruction.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-8">Table 2-8</a>: Conditional Jump Instructions That Test the Condition Code Flags</p></figcaption>
<table id="table-501089c02-0009" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Explanation</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>jc </code><var>label</var></td>
<td>Jump if carry set. Jump to label if the carry flag is set (<code>1</code>); fall through if carry is clear (<code>0</code>).</td>
</tr>
<tr>
<td><code>jnc </code><var>label</var></td>
<td>Jump if no carry. Jump to label if the carry flag is clear (<code>0</code>); fall through if carry is set (<code>1</code>).</td>
</tr>
<tr>
<td><code>jo </code><var>label</var></td>
<td>Jump if overflow. Jump to label if the overflow flag is set (<code>1</code>); fall through if overflow is clear (<code>0</code>).</td>
</tr>
<tr>
<td><code>jno </code><var>label</var></td>
<td>Jump if no overflow. Jump to label if the overflow flag is clear (<code>0</code>); fall through if overflow is set (<code>1</code>).</td>
</tr>
<tr>
<td><code>js </code><var>label</var></td>
<td>Jump if sign (negative). Jump to label if the sign flag is set (<code>1</code>); fall through if sign is clear (<code>0</code>).</td>
</tr>
<tr>
<td><code>jns </code><var>label</var></td>
<td>Jump if not sign. Jump to label if the sign flag is clear (<code>0</code>); fall through if sign is set (<code>1</code>).</td>
</tr>
<tr>
<td><code>jz </code><var>label</var></td>
<td>Jump if zero. Jump to label if the zero flag is set (<code>1</code>); fall through if zero is clear (<code>0</code>).</td>
</tr>
<tr>
<td><code>jnz </code><var>label</var></td>
<td>Jump if not zero. Jump to label if the zero flag is clear (<code>0</code>); fall through if zero is set (<code>1</code>).</td>
</tr>
</tbody>
</table>
</figure>
<p>To use a conditional jump instruction, you must first execute an instruction that affects one (or more) of the condition code flags. For example, an unsigned arithmetic overflow will set the carry flag (and <span epub:type="pagebreak" title="71" id="Page_71"/>likewise, if overflow does not occur, the carry flag will be clear). Therefore, you could use the <code>jc</code> and <code>jnc</code> instructions after an <code>add</code> instruction to see if an (unsigned) overflow occurred during the calculation. For example:</p>
<pre><code>    mov eax, int32Var
    add eax, anotherVar
    jc  overflowOccurred

; Continue down here if the addition did not
; produce an overflow.

    .
    .
    .

overflowOccurred:

; Execute this code if the sum of int32Var and anotherVar
; does not fit into 32 bits.</code></pre>
<p>Not all instructions affect the flags. Of all the instructions we’ve looked at thus far (<code>mov</code>, <code>add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code>, and <code>lea</code>), only the <code>add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>xor</code>, and <code>not</code> instructions affect the flags. The <code>add</code> and <code>sub</code> instructions affect the flags as shown in <a href="#table2-9" id="tableanchor2-9">Table 2-9</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-9">Table 2-9</a>: Flag Settings After Executing <code>add</code> or <code>sub</code></p></figcaption>
<table id="table-501089c02-0010" border="1">
<thead>
<tr>
<td><b>Flag</b></td>
<td><b>Explanation</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Carry</td>
<td>Set if an unsigned overflow occurs (for example, adding the byte values 0FFh and 01h). Clear if no overflow occurs. Note that subtracting 1 from 0 will also clear the carry flag (that is, 0 – 1 is equivalent to 0 + (–1), and –1 is 0FFh in two’s complement form).</td>
</tr>
<tr>
<td>Overflow</td>
<td>Set if a signed overflow occurs (for example, adding the byte values 07Fh and 01h). Signed overflow occurs when the next-to-HO-bit overflows into the HO bit (for example, 7Fh becomes 80h, or 0FFh becomes 0, when dealing with byte-sized calculations).</td>
</tr>
<tr>
<td>Sign</td>
<td>The sign flag is set if the HO bit of the result is set. The sign flag is clear otherwise (that is, the sign flag reflects the state of the HO bit of the result).</td>
</tr>
<tr>
<td>Zero</td>
<td>The zero flag is set if the result of a computation produces 0; it is clear otherwise.</td>
</tr>
</tbody>
</table>
</figure>
<p>The logical instructions (<code>and</code>, <code>or</code>, <code>xor</code>, and <code>not</code>) always clear the carry and overflow flags. They copy the HO bit of their result into the sign flag and set/clear the zero flag if they produce a zero/nonzero result.</p>
<p>In addition to the conditional jump instructions, the x86-64 CPUs also provide a set of conditional move instructions. <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> covers those instructions.</p>
<h3 id="h2-501089c02-0016"><span epub:type="pagebreak" title="72" id="Page_72"/>2.10.3	The cmp Instruction and Corresponding Conditional Jumps</h3>
<p class="BodyFirst">The <code>cmp</code> (<em>compare</em>) instruction is probably the most useful instruction to execute prior to a conditional jump. The compare instruction has the same syntax as the <code>sub</code> instruction and, in fact, it also subtracts the second operand from the first operand and sets the condition code flags based on the result of the subtraction.<sup class="FootnoteReference"><a id="c02-footnoteref-8" href="#c02-footnote-8">8</a></sup> But the <code>cmp</code> instruction doesn’t store the difference back into the first (destination) operand. The whole purpose of the <code>cmp</code> instruction is to set the condition code flags based on the result of the subtraction.</p>
<p>Though you could use the <code>jc</code>/<code>jnc</code>, <code>jo</code>/<code>jno</code>, <code>js</code>/<code>jns</code>, and <code>jz</code>/<code>jnz</code> instructions immediately after a <code>cmp</code> instruction (to test how <code>cmp</code> has set the individual flags), the flag names don’t really mean much in the context of the <code>cmp</code> instruction. Logically, when you see the following instruction (note that the <code>cmp</code> instruction’s operand syntax is identical to the <code>add</code>, <code>sub</code>, and <code>mov</code> instructions),</p>
<pre><code>cmp <var>left_operand</var>, <var>right_operand</var></code></pre>
<p class="BodyContinued">you read this instruction as “compare the <var>left_operand</var> to the <var>right_operand</var>.” Questions you would normally ask after such a comparison are as follows:</p>
<ul>
<li>Is the <var>left_operand</var> equal to the <var>right_operand</var>?</li>
<li>Is the <var>left_operand</var> not equal to the <var>right_operand</var>?</li>
<li>Is the <var>left_operand</var> less than the <var>right_operand</var>?</li>
<li>Is the <var>left_operand</var> less than or equal to the <var>right_operand</var>?</li>
<li>Is the <var>left_operand</var> greater than the <var>right_operand</var>?</li>
<li>Is the <var>left_operand</var> greater than or equal to the <var>right_operand</var>?</li>
</ul>
<p>The conditional jump instructions presented thus far don’t (intuitively) answer any of these questions.</p>
<p>The x86-64 CPUs provide an additional set of conditional jump instructions, shown in <a href="#table2-10" id="tableanchor2-10">Table 2-10</a>, that allow you to test for comparison conditions.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-10">Table 2-10</a>: Conditional Jump Instructions for Use After a <code>cmp</code> Instruction</p></figcaption>
<table id="table-501089c02-0011" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Flags tested</b></td>
<td><b>Explanation</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>je </code><var>label</var></td>
<td><code>ZF == 1</code></td>
<td>Jump if equal. Transfers control to target label if the <var>left_operand</var> is equal to the <var>right_operand</var>. This is a synonym for <code>jz</code>, as the zero flag will be set if the two operands are equal (their subtraction produces a 0 result in that case).</td>
</tr>
<tr>
<td><code>jne </code><var>label</var></td>
<td><code>ZF == 0</code></td>
<td>Jump if not equal. Transfers control to target label if the <var>left_operand</var> is not equal to the <var>right_operand</var>. This is a synonym for <code>jnz</code>, as the zero flag will be clear if the two operands are not equal (their subtraction produces a nonzero result in that case).</td>
</tr>
<tr>
<td><code><span epub:type="pagebreak" title="73" id="Page_73"/>ja </code><var>label</var></td>
<td><code>CF == 0</code> and <br/>
<code>ZF == 0</code></td>
<td>Jump if above. Transfers control to target label if the <em>unsigned</em> <var>left_operand</var> is greater than the <em>unsigned</em> <var>right_operand</var>. </td>
</tr>
<tr>
<td><code>jae </code><var>label</var></td>
<td><code>CF == 0 </code></td>
<td>Jump if above or equal. Transfers control to target label if the <em>unsigned</em> <var>left_operand</var> is greater than or equal to the <em>unsigned</em> <var>right_operand</var>. This is a synonym for <code>jnc</code>, as it turns out that an unsigned overflow (well, underflow, actually) will not occur if the <var>left_operand</var> is greater than or equal to the <var>right_operand</var>.</td>
</tr>
<tr>
<td><code>jb </code><var>label</var></td>
<td><code>CF == 1</code></td>
<td>Jump if below. Transfers control to target label if the <em>unsigned</em> <var>left_operand</var> is less than the <em>unsigned</em> <var>right_operand</var>. This is a synonym for <code>jc</code>, as it turns out that an unsigned overflow (well, underflow, actually) occurs if the <var>left_operand</var> is less than the <var>right_operand</var>.</td>
</tr>
<tr>
<td><code>jbe </code><var>label</var></td>
<td><code>CF == 1</code> or <br/>
<code>ZF == 1</code></td>
<td>Jump if below or equal. Transfers control to target label if the <em>unsigned</em> <var>left_operand</var> is less than or equal to the <em>unsigned</em> <var>right_operand</var>.</td>
</tr>
<tr>
<td><code>jg </code><var>label</var></td>
<td><code>SF == OF</code> and <br/>
<code>ZF == 0</code></td>
<td>Jump if greater. Transfers control to target label if the <em>signed</em> <var>left_operand</var> is greater than the <em>signed</em> <var>right_operand</var>. </td>
</tr>
<tr>
<td><code>jge </code><var>label</var></td>
<td><code>SF == OF</code></td>
<td>Jump if greater or equal. Transfers control to target label if the <em>signed</em> <var>left_operand</var> is greater than or equal to the <em>signed</em> <var>right_operand</var>. </td>
</tr>
<tr>
<td><code>jl </code><var>label</var></td>
<td><code>SF ≠ OF</code></td>
<td>Jump if less. Transfers control to target label if the <em>signed</em> <var>left_operand</var> is less than the <em>signed</em> <var>right_operand</var>. </td>
</tr>
<tr>
<td><code>jle </code><var>label</var></td>
<td><code>ZF == 1 </code><br/>
or<br/>
<code>SF ≠ OF</code></td>
<td>Jump if less or equal. Transfers control to target label if the <em>signed</em> <var>left_operand</var> is less than or equal to the <em>signed</em> <var>right_operand</var>.</td>
</tr>
</tbody>
</table>
</figure>
<p>Perhaps the most important thing to note in <a href="#table2-10">Table 2-10</a> is that separate conditional jump instructions test for signed and unsigned comparisons. Consider the two byte values 0FFh and 01h. From an unsigned perspective, 0FFh is greater than 01h. However, when we treat these as signed numbers (using the two’s complement numbering system), 0FFh is actually –1, which is clearly less than 1. They have the same bit representations but two completely different comparison results when treating these values as signed or unsigned numbers.</p>
<h3 id="h2-501089c02-0017">2.10.4	Conditional Jump Synonyms</h3>
<p class="BodyFirst">Some of the instructions are synonyms for other instructions. For example, <code>jb</code> and <code>jc</code> are the same instruction (that is, they have the same numeric <em>machine code</em> encoding). This is done for convenience and readability’s sake. After a <code>cmp</code> instruction, <code>jb</code> is much more meaningful than <code>jc</code>, for example. MASM defines several synonyms for various conditional branch instructions that make coding a little easier. <a href="#table2-11" id="tableanchor2-11">Table 2-11</a> lists many of these synonyms.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-11">Table 2-11</a>: Conditional Jump Synonyms<span epub:type="pagebreak" title="74" id="Page_74"/></p></figcaption>
<table id="table-501089c02-0012" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Equivalents</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>ja</code></td>
<td><code>jnbe</code></td>
<td>Jump if above, jump if not below or equal.</td>
</tr>
<tr>
<td><code>jae</code></td>
<td><code>jnb</code>, <code>jnc</code></td>
<td>Jump if above or equal, jump if not below, jump if no carry.</td>
</tr>
<tr>
<td><code>jb</code></td>
<td><code>jc</code>, <code>jnae</code></td>
<td>Jump if below, jump if carry, jump if not above or equal.</td>
</tr>
<tr>
<td><code>jbe</code></td>
<td><code>jna</code></td>
<td>Jump if below or equal, jump if not above.</td>
</tr>
<tr>
<td><code>jc</code></td>
<td><code>jb</code>, <code>jnae</code></td>
<td>Jump if carry, jump if below, jump if not above or equal.</td>
</tr>
<tr>
<td><code>je</code></td>
<td><code>jz</code></td>
<td>Jump if equal, jump if zero.</td>
</tr>
<tr>
<td><code>jg</code></td>
<td><code>jnle</code></td>
<td>Jump if greater, jump if not less or equal.</td>
</tr>
<tr>
<td><code>jge</code></td>
<td><code>jnl</code></td>
<td>Jump if greater or equal, jump if not less.</td>
</tr>
<tr>
<td><code>jl</code></td>
<td><code>jnge</code></td>
<td>Jump if less, jump if not greater or equal.</td>
</tr>
<tr>
<td><code>jle</code></td>
<td><code>jng</code></td>
<td>Jump if less or equal, jump if not greater.</td>
</tr>
<tr>
<td><code>jna</code></td>
<td><code>jbe</code></td>
<td>Jump if not above, jump if below or equal.</td>
</tr>
<tr>
<td><code>jnae</code></td>
<td><code>jb</code>, <code>jc</code></td>
<td>Jump if not above or equal, jump if below, jump if carry.</td>
</tr>
<tr>
<td><code>jnb</code></td>
<td><code>jae</code>, <code>jnc</code></td>
<td>Jump if not below, jump if above or equal, jump if no carry.</td>
</tr>
<tr>
<td><code>jnbe</code></td>
<td><code>ja</code></td>
<td>Jump if not below or equal, jump if above.</td>
</tr>
<tr>
<td><code>jnc</code></td>
<td><code>jnb</code>, <code>jae</code></td>
<td>Jump if no carry, jump if no below, jump if above or equal.</td>
</tr>
<tr>
<td><code>jne</code></td>
<td><code>jnz</code></td>
<td>Jump if not equal, jump if not zero.</td>
</tr>
<tr>
<td><code>jng</code></td>
<td><code>jle</code></td>
<td>Jump if not greater, jump if less or equal.</td>
</tr>
<tr>
<td><code>jnge</code></td>
<td><code>jl</code></td>
<td>Jump if not greater or equal, jump if less.</td>
</tr>
<tr>
<td><code>jnl</code></td>
<td><code>jge</code></td>
<td>Jump if not less, jump if greater or equal.</td>
</tr>
<tr>
<td><code>jnle</code></td>
<td><code>jg</code></td>
<td>Jump if not less or equal, jump if greater.</td>
</tr>
<tr>
<td><code>jnz</code></td>
<td><code>jne</code></td>
<td>Jump if not zero, jump if not equal.</td>
</tr>
<tr>
<td><code>jz</code></td>
<td><code>je</code></td>
<td>Jump if zero, jump if equal.</td>
</tr>
</tbody>
</table>
</figure>
<p>There is a very important thing to note about the <code>cmp</code> instruction: it sets the flags only for integer comparisons (which will also cover characters and other types you can encode with an integer number). Specifically, it does not compare floating-point values and set the flags as appropriate for a floating-point comparison. To learn more about floating-point arithmetic (and comparisons), see <span class="xref" itemid="xref_target_“Floating-Point Arithmetic” in Chapter 6">“Floating-Point Arithmetic” in Chapter 6</span>.</p>
<h2 id="h1-501089c02-0011">	2.11	Shifts and Rotates</h2>
<p class="BodyFirst">Another set of logical operations that apply<em> </em>to bit strings is the <em>shift</em> and <em>rotate</em> operations. These two categories can be further broken down into left shifts, left rotates, right shifts, and right rotates.</p>
<p><span epub:type="pagebreak" title="75" id="Page_75"/>The <em>shift-left operation</em> moves each bit in a bit string one position to the left, as shown in <a href="#figure2-8" id="figureanchor2-8">Figure 2-8</a>.</p>
<figure>
<img src="image_fi/501089c02/f02008.png" alt="f02008" class=""/>
<figcaption><p><a id="figure2-8">Figure 2-8</a>: Shift-left operation</p></figcaption>
</figure>
<p>Bit 0 moves into bit position 1, the previous value in bit position 1 moves into bit position 2, and so on. We’ll shift a 0 into bit 0, and the previous value of the high-order bit will become the <em>carry </em>out of this operation.</p>
<p>The x86-64 provides a shift-left instruction, <code>shl</code>, that performs this useful operation. The syntax for the <code>shl</code> instruction is shown here:</p>
<pre><code>shl <var>dest</var>, <var>count</var></code></pre>
<p>The <var>count</var> operand is either the CL register or a constant in the range 0 to <em>n</em>, where <em>n</em> is one less than the number of bits in the destination operand (for example, <em>n</em> = 7 for 8-bit operands, <em>n</em> = 15 for 16-bit operands, <em>n</em> = 31 for 32-bit operands, and <em>n</em> = 63 for 64-bit operands). The <var>dest</var> operand is a typical destination operand. It can be either a memory location or a register.</p>
<p>When the <var>count</var> operand is the constant 1, the <code>shl</code> instruction does the operation shown in <a href="#figure2-9" id="figureanchor2-9">Figure 2-9</a>.</p>
<figure>
<img src="image_fi/501089c02/f02009.png" alt="f02009" class=""/>
<figcaption><p><a id="figure2-9">Figure 2-9</a>: <span class="LiteralInCaption"><code>shl</code></span> by 1 operation</p></figcaption>
</figure>
<p>In <a href="#figure2-9">Figure 2-9</a>, the <em>C</em> represents the carry flag—that is, the HO bit shifted out of the operand moves into the carry flag. Therefore, you can test for overflow after a <code>shl </code><var>dest</var><code>, 1 </code>instruction by testing the carry flag immediately after executing the instruction (for example, by using <code>jc</code> and <code>jnc</code>).</p>
<p>The <code>shl</code> instruction sets the zero flag based on the result (<code>z=1</code> if the result is zero, <code>z=0</code> otherwise). The <code>shl</code> instruction sets the sign flag if the HO bit of the result is 1. If the shift count is 1, then <code>shl</code> sets the overflow flag if the HO bit changes (that is, you shift a 0 into the HO bit when it was previously 1, or shift a 1 in when it was previously 0); the overflow flag is undefined for all other shift counts.</p>
<p>Shifting a value to the left one digit is the same thing as multiplying it by its radix (base). For example, shifting a decimal number one position to the left (adding a 0 to the right of the number) effectively multiplies it by 10 (the radix):</p>
<pre><code>1234 shl 1 = 12340</code></pre>
<p>(<code>shl 1</code> means shift one digit position to the left.)</p>
<p><span epub:type="pagebreak" title="76" id="Page_76"/> Because the radix of a binary number is 2, shifting it left multiplies it by 2. If you shift a value to the left <em>n </em>times, you multiply that value by 2<sup><em>n</em></sup>.</p>
<p>A <em>shift-right</em> operation works the same way, except we’re moving the data in the opposite direction. For a byte value, bit 7 moves into bit 6, bit 6 moves into bit 5, bit 5 moves into bit 4, and so on. During a right shift, we’ll move a 0 into bit 7, and bit 0 will be the carry out of the operation (see <a href="#figure2-10" id="figureanchor2-10">Figure 2-10</a>).</p>
<figure>
<img src="image_fi/501089c02/f02010.png" alt="f02010" class=""/>
<figcaption><p><a id="figure2-10">Figure 2-10</a>: Shift-right operation</p></figcaption>
</figure>
<p>As you would probably expect, the x86-64 provides a <code>shr</code> instruction that will shift the bits to the right in a destination operand. The syntax is similar to that of the <code>shl</code> instruction:</p>
<pre><code>shr <var>dest</var>, <var>count</var></code></pre>
<p>This instruction shifts a 0 into the HO bit of the destination operand; it shifts the other bits one place to the right (from a higher bit number to a lower bit number). Finally, bit 0 is shifted into the carry flag. If you specify a count of 1, the <code>shr</code> instruction does the operation shown in <a href="#figure2-11" id="figureanchor2-11">Figure 2-11</a>.</p>
<figure>
<img src="image_fi/501089c02/f02011.png" alt="f02011" class=""/>
<figcaption><p><a id="figure2-11">Figure 2-11</a>: <span class="LiteralInCaption"><code>shr</code></span> by 1 operation</p></figcaption>
</figure>
<p>The <code>shr</code> instruction sets the zero flag based on the result (<code>ZF=1</code> if the result is zero, <code>ZF=0</code> otherwise). The <code>shr</code> instruction clears the sign flag (because the HO bit of the result is always 0). If the shift count is 1, <code>shl</code> sets the overflow flag if the HO bit changes (that is, you shift a 0 into the HO bit when it was previously 1, or shift a 1 in when it was previously 0); the overflow flag is undefined for all other shift counts.</p>
<p>Because a left shift is equivalent to a multiplication by 2, it should come as no surprise that a right shift is roughly comparable to a division by 2 (or, in general, a division by the radix of the number). If you perform <em>n </em>right shifts, you will divide that number by 2<sup><em>n</em></sup>.</p>
<p>However, a shift right is equivalent to only an <em>unsigned</em> division by 2. For example, if you shift the unsigned representation of 254 (0FEh) one place to the right, you get 127 (7Fh), exactly what you would expect. However, if you shift the two’s complement representation of –2 (0FEh) to the right one position, you get 127 (7Fh), which is <em>not </em>correct. This problem occurs because we’re shifting a 0 into bit 7. If bit 7 previously contained a 1, we’re <span epub:type="pagebreak" title="77" id="Page_77"/>changing it from a negative to a positive number. Not a good thing to do when dividing by 2.</p>
<p>To use the shift right as a division operator, we must define a third shift operation: <em>arithmetic shift right</em>.<sup class="FootnoteReference"><a id="c02-footnoteref-9" href="#c02-footnote-9">9</a></sup> This works just like the normal shift-right operation (a logical shift right) except, instead of shifting a 0 into the high-order bit, an arithmetic shift-right operation copies the HO bit back into itself; that is, during the shift operation, it does not modify the HO bit, as <a href="#figure2-12" id="figureanchor2-12">Figure 2-12</a> shows.</p>
<figure>
<img src="image_fi/501089c02/f02012.png" alt="f02012" class=""/>
<figcaption><p><a id="figure2-12">Figure 2-12</a>: Arithmetic shift-right operation</p></figcaption>
</figure>
<p>An arithmetic shift right generally produces the result you expect. For example, if you perform the arithmetic shift-right operation on –2 (0FEh), you get –1 (0FFh). However, this operation always rounds the numbers to the closest integer that is <em>less than or equal to the actual result</em>. For example, if you apply the arithmetic shift-right operation on –1 (0FFh), the result is –1, not 0. Because –1 is less than 0, the arithmetic shift-right operation rounds toward –1. This is not a bug in the arithmetic shift-right operation; it just uses a different (though valid) definition of integer division.</p>
<p>The x86-64 provides an arithmetic shift-right instruction, <code>sar</code> (<em>shift arithmetic right</em>). This instruction’s syntax is nearly identical to that of <code>shl</code> and <code>shr</code>:</p>
<pre><code>sar <var>dest</var>, <var>count</var></code></pre>
<p>The usual limitations on the count and destination operands apply. This instruction operates as shown in <a href="#figure2-13" id="figureanchor2-13">Figure 2-13</a> if the count is 1.</p>
<figure>
<img src="image_fi/501089c02/f02013.png" alt="f02013" class=""/>
<figcaption><p><a id="figure2-13">Figure 2-13</a>: <span class="LiteralInCaption"><code>sar </code></span><var>dest</var><span class="LiteralInCaption"><code>, 1</code></span> operation</p></figcaption>
</figure>
<p>The <code>sar</code> instruction sets the zero flag based on the result (<code>z=1</code> if the result is zero, and <code>z=0</code> otherwise). The <code>sar</code> instruction sets the sign flag to the HO bit of the result. The overflow flag should always be clear after a <code>sar</code> instruction, as signed overflow is impossible with this operation.</p>
<p>The <em>rotate-left</em> and <em>rotate-right</em> operations behave like the shift-left and shift-right operations, except the bit shifted out from one end is shifted back in at the other end. <a href="#figure2-14" id="figureanchor2-14">Figure 2-14</a> diagrams these operations.</p>
<span epub:type="pagebreak" title="78" id="Page_78"/><figure class="graphic">
<img src="image_fi/501089c02/f02014a.png" alt="f02014a"/></figure>

<figure>
<img src="image_fi/501089c02/f02014b.png" alt="f02014b" class=""/>
<figcaption><p><a id="figure2-14">Figure 2-14</a>: Rotate-left and rotate-right operations</p></figcaption>
</figure>
<p>The x86-64 provides <code>rol</code> (rotate left) and <code>ror</code> (rotate right) instructions that do these basic operations on their operands. The syntax for these two instructions is similar to the shift instructions:</p>
<pre><code>rol <var>dest</var>, <var>count</var>
ror <var>dest</var>, <var>count</var></code></pre>
<p>If the shift count is 1, these two instructions copy the bit shifted out of the destination operand into the carry flag, as Figures 2-15 and 2-16 show.</p>
<figure>
<img src="image_fi/501089c02/f02015.png" alt="f02015" class=""/>
<figcaption><p><a id="figure2-15">Figure 2-15</a>: <span class="LiteralInCaption"><code>rol </code></span><var>dest</var><span class="LiteralInCaption"><code>, 1</code></span> operation</p></figcaption>
</figure>
<figure>
<img src="image_fi/501089c02/f02016.png" alt="f02016" class=""/>
<figcaption><p><a id="figure2-16">Figure 2-16</a>: <span class="LiteralInCaption"><code>ror </code></span><var>dest</var><span class="LiteralInCaption"><code>, 1</code></span> operation</p></figcaption>
</figure>
<p>Unlike the shift instructions, the rotate instructions do not affect the settings of the sign or zero flags. The OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing—that is, it affects no flags). For left rotates, the OF flag is set to the exclusive-or of the original HO 2 bits. For right rotates, the OF flag is set to the exclusive-or of the HO 2 bits after the rotate.</p>
<p>It is often more convenient for the rotate operation to shift the output bit through the carry and to shift the previous carry value back into the input bit of the shift operation. The x86-64 <code>rcl</code> (<em>rotate through carry left</em>) and <code/><span epub:type="pagebreak" title="79" id="Page_79"/>rcr (<em>rotate through carry right</em>) instructions achieve this for you. These instructions use the following syntax:</p>
<pre><code>rcl <var>dest</var>, <var>count</var>
rcr <var>dest</var>, <var>count</var></code></pre>
<p>The <var>count</var> operand is either a constant or the CL register, and the <var>dest</var> operand is a memory location or register. The <var>count</var> operand must be a value that is less than the number of bits in the <var>dest</var> operand. For a count value of 1, these two instructions do the rotation shown in <a href="#figure2-17" id="figureanchor2-17">Figure 2-17</a>.</p>
<figure class="graphic">
<img src="image_fi/501089c02/f02017a.png" alt="f02017a"/></figure>

<figure>
<img src="image_fi/501089c02/f02017b.png" alt="f02017b" class=""/>
<figcaption><p><a id="figure2-17">Figure 2-17</a>: <span class="LiteralInCaption"><code>rcl </code></span><var>dest</var><span class="LiteralInCaption"><code>, 1</code></span> and <span class="LiteralInCaption"><code>rcr </code></span><var>dest</var><span class="LiteralInCaption"><code>, 1</code></span> operations</p></figcaption>
</figure>
<p>Unlike the shift instructions, the rotate-through-carry instructions do not affect the settings of the sign or zero flags. The OF flag is defined only for the 1-bit rotates. For left rotates, the OF flag is set if the original HO 2 bits change. For right rotates, the OF flag is set to the exclusive OR of the resultant HO 2 bits.</p>
<h2 id="h1-501089c02-0012">	2.12	Bit Fields and Packed Data</h2>
<p class="BodyFirst">Although the x86-64 operates most efficiently on <code>byte</code>, <code>word</code>, <code>dword</code>, and <code>qword</code> data types, occasionally you’ll need to work with a data type that uses a number of bits other than 8, 16, 32, or 64. You can also zero-extend a nonstandard data size to the next larger power of 2 (such as extending a 22-bit value to a 32-bit value). This turns out to be fast, but if you have a large array of such values, slightly more than 31 percent of the memory is going to waste (10 bits in every 32-bit value). However, suppose you were to repurpose those 10 bits for something else? By <em>packing</em> the separate 22-bit and 10-bit values into a single 32-bit value, you don’t waste any space.</p>
<p>For example, consider a date of the form 04/02/01. Representing this date requires three numeric values: month, day, and year values. Months, of course, take on the values 1 to 12. At least 4 bits (a maximum of 16 different values) are needed to represent the month. Days range from 1 to 31. So it will take 5 bits (a maximum of 32 different values) to represent the day entry. The year value, assuming that we’re working with values in the range <span epub:type="pagebreak" title="80" id="Page_80"/>0 to 99, requires 7 bits (which can be used to represent up to 128 different values). So, 4 + 5 + 7 = 16 bits, or 2 bytes.</p>
<p>In other words, we can pack our date data into 2 bytes rather than the 3 that would be required if we used a separate byte for each of the month, day, and year values. This saves 1 byte of memory for each date stored, which could be a substantial savings if you need to store many dates. The bits could be arranged as shown in <a href="#figure2-18" id="figureanchor2-18">Figure 2-18</a>.</p>
<figure>
<img src="image_fi/501089c02/f02018.png" alt="f02018" class=""/>
<figcaption><p><a id="figure2-18">Figure 2-18</a>: Short packed date format (2 bytes)</p></figcaption>
</figure>
<p><em>MMMM</em> represents the 4 bits making up the month value, <em>DDDDD</em> represents the 5 bits making up the day, and <em>YYYYYYY</em> is the 7 bits composing the year. Each collection of bits representing a data item is a <em>bit field</em>. For example, April 2, 2001, would be represented as 4101h:</p>
<pre><code>0100      00010   0000001      = 0100_0001_0000_0001b or 4101h
 4          2       01</code></pre>
<p>Although packed values are <em>space-efficient</em> (that is, they make efficient use of memory), they are computationally <em>inefficient</em> (slow!). The reason? It takes extra instructions to unpack the data packed into the various bit fields. These extra instructions take additional time to execute (and additional bytes to hold the instructions); hence, you must carefully consider whether packed data fields will save you anything. The sample program in <a href="#listing2-4" id="listinganchor2-4">Listing 2-4</a> demonstrates the effort that must go into packing and unpacking this 16-bit date format.</p>
<pre><code>; Listing 2-4
 
; Demonstrate packed data types.

        option  casemap:none

NULL    =       0
nl      =       10  ; ASCII code for newline
maxLen  =       256

; New data declaration section.
; .const holds data values for read-only constants.

            .const
ttlStr      byte    'Listing 2-4', 0
moPrompt    byte    'Enter current month: ', 0
dayPrompt   byte    'Enter current day: ', 0
yearPrompt  byte    'Enter current year '
            byte    '(last 2 digits only): ', 0
           
packed      byte    'Packed date is %04x', nl, 0
<span epub:type="pagebreak" title="81" id="Page_81"/>theDate     byte    'The date is %02d/%02d/%02d'
            byte    nl, 0
           
badDayStr   byte    'Bad day value was entered '
            byte    '(expected 1-31)', nl, 0
           
badMonthStr byte    'Bad month value was entered '
            byte    '(expected 1-12)', nl, 0
badYearStr  byte    'Bad year value was entered '
            byte    '(expected 00-99)', nl, 0

            .data
month       byte    ?
day         byte    ?
year        byte    ?
date        word    ?

input       byte    maxLen dup (?)

            .code
            externdef printf:proc
            externdef readLine:proc
            externdef atoi:proc

; Return program title to C++ program:

            public getTitle
getTitle    proc
            lea rax, ttlStr
            ret
getTitle    endp

; Here's a user-written function that reads a numeric value from the
; user:
 
; int readNum(char *prompt);
 
; A pointer to a string containing a prompt message is passed in the
; RCX register.
 
; This procedure prints the prompt, reads an input string from the
; user, then converts the input string to an integer and returns the
; integer value in RAX.

readNum     proc

; Must set up stack properly (using this "magic" instruction) before
; we can call any C/C++ functions:

            sub     rsp, 56

; Print the prompt message. Note that the prompt message was passed to
; this procedure in RCX, we're just passing it on to printf:

            call    printf

<span epub:type="pagebreak" title="82" id="Page_82"/>; Set up arguments for readLine and read a line of text from the user.
; Note that readLine returns NULL (0) in RAX if there was an error.

            lea     rcx, input
            mov     rdx, maxLen
            call    readLine

; Test for a bad input string:

            cmp     rax, NULL
            je      badInput

; Okay, good input at this point, try converting the string to an
; integer by calling atoi. The atoi function returns zero if there was
; an error, but zero is a perfectly fine return result, so we ignore
; errors.

            lea     rcx, input      ; Ptr to string
            call    atoi            ; Convert to integer

badInput:
            add     rsp, 56         ; Undo stack setup
            ret
readNum     endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            sub     rsp, 56

; Read the date from the user. Begin by reading the month:

            lea     rcx, moPrompt
            call    readNum

; Verify the month is in the range 1..12:

            cmp     rax, 1
            jl      badMonth
            cmp     rax, 12
            jg      badMonth

; Good month, save it for now:

            mov     month, al       ; 1..12 fits in a byte

; Read the day:

            lea     rcx, dayPrompt
            call    readNum

<span epub:type="pagebreak" title="83" id="Page_83"/>; We'll be lazy here and verify only that the day is in the range
; 1..31.

            cmp     rax, 1
            jl      badDay
            cmp     rax, 31
            jg      badDay

; Good day, save it for now:

            mov     day, al         ; 1..31 fits in a byte

; Read the year:

            lea     rcx, yearPrompt
            call    readNum

; Verify that the year is in the range 0..99.

            cmp     rax, 0
            jl      badYear
            cmp     rax, 99
            jg      badYear

; Good year, save it for now:

            mov     year, al        ; 0..99 fits in a byte

; Pack the data into the following bits:
 
;  15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
;   m  m  m  m  d  d  d  d  d  y  y  y  y  y  y  y

            movzx   ax, month
            shl     ax, 5
            or      al, day
            shl     ax, 7
            or      al, year
            mov     date, ax

; Print the packed date:

            lea     rcx, packed
            movzx   rdx, date
            call    printf

; Unpack the date and print it:

            movzx   rdx, date
            mov     r9, rdx
            and     r9, 7fh         ; Keep LO 7 bits (year)
            shr     rdx, 7          ; Get day in position
            mov     r8, rdx
<span epub:type="pagebreak" title="84" id="Page_84"/>            and     r8, 1fh         ; Keep LO 5 bits
            shr     rdx, 5          ; Get month in position
            lea     rcx, theDate
            call    printf 

            jmp     allDone

; Come down here if a bad day was entered:

badDay:
            lea     rcx, badDayStr
            call    printf
            jmp     allDone

; Come down here if a bad month was entered:

badMonth:
            lea     rcx, badMonthStr
            call    printf
            jmp     allDone

; Come down here if a bad year was entered:

badYear:
            lea     rcx, badYearStr
            call    printf  

allDone:       
            add     rsp, 56
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing2-4">Listing 2-4</a>: Packing and unpacking date data</p>
<p>Here’s the result of building and running this program:</p>
<pre><code>C:\&gt;<b>build  listing2-4</b>

C:\&gt;<b>echo off</b>
 Assembling: listing2-4.asm
c.cpp

C:\&gt;<b> listing2-4</b>
Calling Listing 2-4:
Enter current month: 2
Enter current day: 4
Enter current year (last 2 digits only): 68
Packed date is 2244
The date is 02/04/68
Listing 2-4 terminated</code></pre>
<p><span epub:type="pagebreak" title="85" id="Page_85"/>Of course, having gone through the problems with Y2K (Year 2000),<sup class="FootnoteReference"><a id="c02-footnoteref-10" href="#c02-footnote-10">10</a></sup> you know that using a date format that limits you to 100 years (or even 127 years) would be quite foolish. To future-proof the packed date format, we can extend it to 4 bytes packed into a double-word variable, as shown in <a href="#figure2-19" id="figureanchor2-19">Figure 2-19</a>. (As you will see in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, you should always try to create data objects whose length is an even power of 2—1 byte, 2 bytes, 4 bytes, 8 bytes, and so on—or you will pay a performance penalty.)</p>
<figure>
<img src="image_fi/501089c02/f02019.png" alt="f02019" class=""/>
<figcaption><p><a id="figure2-19">Figure 2-19</a>: Long packed date format (4 bytes)</p></figcaption>
</figure>
<p>The Month and Day fields now consist of 8 bits each, so they can be extracted as a byte object from the double word. This leaves 16 bits for the year, with a range of 65,536 years. By rearranging the bits so the Year field is in the HO bit positions, the Month field is in the middle bit positions, and the Day field is in the LO bit positions, the long date format allows you to easily compare two dates to see if one date is less than, equal to, or greater than another date. Consider the following code:</p>
<pre><code>    mov eax, Date1  ; Assume Date1 and Date2 are dword variables
    cmp eax, Date2  ; using the Long Packed Date format
    jna d1LEd2

            <var>Do something if Date1 &gt; Date2</var>

d1LEd2:</code></pre>
<p>Had you kept the different date fields in separate variables, or organized the fields differently, you would not have been able to compare <code>Date1</code> and <code>Date2</code> as easily as for the short packed data format. Therefore, this example demonstrates another reason for packing data even if you don’t realize any space savings—it can make certain computations more convenient or even more efficient (contrary to what normally happens when you pack data).</p>
<p>Examples of practical packed data types abound. You could pack eight Boolean values into a single byte, you could pack two BCD digits into a byte, and so on.</p>
<p>A classic example of packed data is the RFLAGS register. This register packs nine important Boolean objects (along with seven important system flags) into a single 16-bit register. You will commonly need to access many of these flags. You can test many of the condition code flags by using the conditional jump instructions and manipulate the individual bits in the FLAGS register with the instructions in <a href="#table2-12" id="tableanchor2-12">Table 2-12</a> that directly affect certain flags.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-12">Table 2-12</a>: Instructions That Affect Certain Flags<span epub:type="pagebreak" title="86" id="Page_86"/></p></figcaption>
<table id="table-501089c02-0013" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Explanation</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>cld</code></td>
<td>Clears (sets to <code>0</code>) the direction flag.</td>
</tr>
<tr>
<td><code>std</code></td>
<td>Sets (to <code>1</code>) the direction flag.</td>
</tr>
<tr>
<td><code>cli</code></td>
<td>Clears the interrupt disable flag.</td>
</tr>
<tr>
<td><code>sti</code></td>
<td>Sets the interrupt disable flag.</td>
</tr>
<tr>
<td><code>clc</code></td>
<td>Clears the carry flag.</td>
</tr>
<tr>
<td><code>stc</code></td>
<td>Sets the carry flag.</td>
</tr>
<tr>
<td><code>cmc</code></td>
<td>Complements (inverts) the carry flag.</td>
</tr>
<tr>
<td><code>sahf</code></td>
<td>Stores the AH register into the LO 8 bits of the FLAGS register. (Warning: certain early x86-64 CPUs do not support this instruction.)</td>
</tr>
<tr>
<td><code>lahf</code></td>
<td>Loads AH from the LO 8 bits of the FLAGS register. (Warning: certain early x86-64 CPUs do not support this instruction.)</td>
</tr>
</tbody>
</table>
</figure>
<p>The <code>lahf</code> and <code>sahf</code> instructions provide a convenient way to access the LO 8 bits of the FLAGS register as an 8-bit byte (rather than as eight separate 1-bit values). See <a href="#figure2-20" id="figureanchor2-20">Figure 2-20</a> for a layout of the FLAGS register.</p>
<figure>
<img src="image_fi/501089c02/f02020.png" alt="f02020" class=""/>
<figcaption><p><a id="figure2-20">Figure 2-20</a>: FLAGS register as packed Boolean data</p></figcaption>
</figure>
<p>The <code>lahf</code> (<em>load AH with the LO eight bits of the FLAGS register</em>) and the <code>sahf</code> (<em>store AH into the LO byte of the RFLAGS register</em>) use the following syntax:</p>
<pre><code>        lahf
        sahf</code></pre>
<h2 id="h1-501089c02-0013">	2.13	IEEE Floating-Point Formats</h2>
<p class="BodyFirst">When Intel planned to introduce a floating-point unit (the 8087 FPU) for its new 8086 microprocessor, it hired the best numerical analyst it could find to design a floating-point format. That person then hired two other experts in the field, and the three of them (William Kahan, Jerome Coonen, and Harold Stone) designed Intel’s floating-point format. They <span epub:type="pagebreak" title="87" id="Page_87"/>did such a good job designing the KCS Floating-Point Standard that the Institute of Electrical and Electronics Engineers (IEEE) adopted this format for its floating-point format.<sup class="FootnoteReference"><a id="c02-footnoteref-11" href="#c02-footnote-11">11</a></sup></p>
<p>To handle a wide range of performance and accuracy requirements, Intel actually introduced <em>three</em> floating-point formats: single-precision, double-precision, and extended-precision. The single- and double-precision formats corresponded to C’s float and double types or FORTRAN’s real and double-precision types. The extended-precision format contains 16 extra bits that long chains of computations could use as guard bits before rounding down to a double-precision value when storing the result.</p>
<h3 id="h2-501089c02-0018">2.13.1	Single-Precision Format</h3>
<p class="BodyFirst">The <em>single-precision format</em> uses a<em> </em>one’s complement 24-bit mantissa, an 8-bit excess-127 exponent, and a single sign bit. The <em>mantissa</em> usually represents a value from 1.0 to just under 2.0. The HO bit of the mantissa is always assumed to be 1 and represents a value just to the left of the <em>binary point</em>.<sup class="FootnoteReference"><a id="c02-footnoteref-12" href="#c02-footnote-12">12</a></sup> The remaining 23 mantissa bits appear to the right of the binary point. Therefore, the mantissa represents the value:</p>
<pre><code>1.mmmmmmm mmmmmmmm</code></pre>
<p>The <code>mmmm</code> characters represent the 23 bits of the mantissa. Note that because the HO bit of the mantissa is always 1, the single-precision format doesn’t actually store this bit within the 32 bits of the floating-point number. This is known as an <em>implied bit</em>.</p>
<p>Because we are working with binary numbers, each position to the right of the binary point represents a value (<code>0</code> or <code>1</code>) times a successive negative power of 2. The implied 1 bit is always multiplied by 2<sup>0</sup>, which is 1. This is why the mantissa is always greater than or equal to 1. Even if the other mantissa bits are all 0, the implied 1 bit always gives us the value 1.<sup class="FootnoteReference"><a id="c02-footnoteref-13" href="#c02-footnote-13">13</a></sup> Of course, even if we had an almost infinite number of 1 bits after the binary point, they still would not add up to 2. This is why the mantissa can represent values in the range 1 to just under 2.</p>
<p>Although there is an infinite number of values between 1 and 2, we can represent only 8 million of them because we use a 23-bit mantissa (with the implied 24th bit always 1). This is the reason for inaccuracy in floating-point arithmetic—we are limited to a fixed number of bits in computations involving single-precision floating-point values.</p>
<p>The mantissa uses a <em>one’s </em><em>complement</em> format rather than two’s complement to represent signed values. The 24-bit value of the mantissa is simply <span epub:type="pagebreak" title="88" id="Page_88"/>an unsigned binary number, and the sign bit determines whether that value is positive or negative. One’s complement numbers have the unusual property that there are two representations for 0 (with the sign bit set or clear). Generally, this is important only to the person designing the floating-point software or hardware system. We will assume that the value 0 always has the sign bit clear.</p>
<p>To represent values outside the range 1.0 to just under 2.0, the exponent portion of the floating-point format comes into play. The floating-point format raises 2 to the power specified by the exponent and then multiplies the mantissa by this value. The exponent is 8 bits and is stored in an <em>excess-127</em> format. In excess-127 format, the exponent 0 is represented by the value 127 (7Fh), negative exponents are values in the range 0 to 126, and positive exponents are values in the range 128 to 255. To convert an exponent to excess-127 format, add 127 to the exponent value. The use of excess-127 format makes it easier to compare floating-point values. The single-precision floating-point format takes the form shown in <a href="#figure2-21" id="figureanchor2-21">Figure 2-21</a>.</p>
<figure>
<img src="image_fi/501089c02/f02021.png" alt="f02021" class=""/>
<figcaption><p><a id="figure2-21">Figure 2-21</a>: Single-precision (32-bit) floating-point format</p></figcaption>
</figure>
<p>With a 24-bit mantissa, you will get approximately six and a half (decimal) digits of precision (half a digit of precision means that the first six digits can all be in the range 0 to 9, but the seventh digit can be only in the range 0 to <em>x</em>, where <em>x</em> &lt; 9 and is generally close to 5). With an 8-bit excess-127 exponent, the dynamic range<sup class="FootnoteReference"><a id="c02-footnoteref-14" href="#c02-footnote-14">14</a></sup> of single-precision floating-point numbers is approximately 2<sup>±127</sup>, or about 10<sup>±38</sup>.</p>
<p>Although single-precision floating-point numbers are perfectly suitable for many applications, the precision and dynamic range are somewhat limited and unsuitable for many financial, scientific, and other applications. Furthermore, during long chains of computations, the limited accuracy of the single-precision format may introduce serious error.</p>
<h3 id="h2-501089c02-0019">2.13.2	Double-Precision Format</h3>
<p class="BodyFirst">The <em>double-precision format</em> helps overcome the problems of single-precision floating-point. Using twice the space, the double-precision format has an 11-bit excess-1023 exponent and a 53-bit mantissa (with an implied HO bit of 1) plus a sign bit. This provides a dynamic range of about 10<sup>±308</sup> and 14.5 digits of precision, sufficient for most applications. Double-precision floating-point values take the form shown in <a href="#figure2-22" id="figureanchor2-22">Figure 2-22</a>.</p>
<span epub:type="pagebreak" title="89" id="Page_89"/><figure>
<img src="image_fi/501089c02/f02022.png" alt="f02022" class=""/>
<figcaption><p><a id="figure2-22">Figure 2-22</a>: 64-bit double-precision floating-point format</p></figcaption>
</figure>
<h3 id="h2-501089c02-0020">2.13.3	Extended-Precision Format</h3>
<p class="BodyFirst">To ensure accuracy during long chains of computations involving double-precision floating-point numbers, Intel designed the <em>extended-precision format</em>. It uses 80 bits. Twelve of the additional 16 bits are appended to the mantissa, and 4 of the additional bits are appended to the end of the exponent. Unlike the single- and double-precision values, the extended-precision format’s mantissa does not have an implied HO bit. Therefore, the extended-precision format provides a 64-bit mantissa, a 15-bit excess-16383 exponent, and a 1-bit sign. <a href="#figure2-23" id="figureanchor2-23">Figure 2-23</a> shows the format for the extended-precision floating-point value.</p>
<figure>
<img src="image_fi/501089c02/f02023.png" alt="f02023" class=""/>
<figcaption><p><a id="figure2-23">Figure 2-23</a>: 80-bit extended-precision floating-point format</p></figcaption>
</figure>
<p>On the x86-64 FPU, all computations are done using the extended-precision format. Whenever you load a single- or double-precision value, the FPU automatically converts it to an extended-precision value. Likewise, when you store a single- or double-precision value to memory, the FPU automatically rounds the value down to the appropriate size before storing it. By always working with the extended-precision format, Intel guarantees that a large number of guard bits are present to ensure the accuracy of your computations.</p>
<h3 id="h2-501089c02-0021">2.13.4	Normalized Floating-Point Values</h3>
<p class="BodyFirst">To maintain maximum precision during computation, most computations use normalized values. A <em>normalized floating-point value</em> is one whose HO mantissa bit contains 1. Almost any non-normalized value can be normalized: shift the mantissa bits to the left and decrement the exponent until a 1 appears in the HO bit of the mantissa.</p>
<p>Remember, the exponent is a binary exponent. Each time you increment the exponent, you multiply the floating-point value by 2. Likewise, whenever you decrement the exponent, you divide the floating-point value by 2. By the same token, shifting the mantissa to the left one bit position multiplies the floating-point value by 2; likewise, shifting the mantissa to the right divides the floating-point value by 2. Therefore, shifting the mantissa <span epub:type="pagebreak" title="90" id="Page_90"/>to the left one position <em>and</em> decrementing the exponent does not change the value of the floating-point number at all.</p>
<p>Keeping floating-point numbers normalized is beneficial because it maintains the maximum number of bits of precision for a computation. If the HO <em>n</em> bits of the mantissa are all 0, the mantissa has that many fewer bits of precision available for computation. Therefore, a floating-point computation will be more accurate if it involves only normalized values.</p>
<p>In two important cases, a floating-point number cannot be normalized. Zero is one of these special cases. Obviously, it cannot be normalized because the floating-point representation for 0 has no 1 bits in the mantissa. This, however, is not a problem because we can exactly represent the value 0 with only a single bit. </p>
<p>In the second case, we have some HO bits in the mantissa that are 0, but the biased exponent is also 0 (and we cannot decrement it to normalize the mantissa). Rather than disallow certain small values, whose HO mantissa bits and biased exponent are 0 (the most negative exponent possible), the IEEE standard allows special <em>denormalized</em><em> </em>values to represent these smaller values.<sup class="FootnoteReference"><a id="c02-footnoteref-15" href="#c02-footnote-15">15</a></sup> Although the use of denormalized values allows IEEE floating-point computations to produce better results than if underflow occurred, keep in mind that denormalized values offer fewer bits of precision.</p>
<h3 id="h2-501089c02-0022">2.13.5	Non-Numeric Values</h3>
<p class="BodyFirst">The IEEE floating-point standard recognizes three special non-numeric values: –infinity, +infinity, and a special not-a-number (NaN). For each of these special numbers, the exponent field is filled with all 1 bits.</p>
<p>If the exponent is all 1 bits and the mantissa is all 0 bits, then the value is infinity. The sign bit will be <code>0</code> for +infinity, and <code>1</code> for –infinity.</p>
<p>If the exponent is all 1 bits and the mantissa is not all 0 bits, then the value is an invalid number (known as a <em>not-a-number</em> in IEEE 754 terminology). NaNs represent illegal operations, such as trying to take the square root of a negative number.</p>
<p>Unordered comparisons occur whenever either operand (or both) is a NaN. As NaNs have an indeterminate value, they cannot be compared (that is, they are incomparable). Any attempt to perform an unordered comparison typically results in an exception or some sort of error. Ordered comparisons, on the other hand, involve two operands, neither of which are NaNs.</p>
<h3 id="h2-501089c02-0023">2.13.6	MASM Support for Floating-Point Values</h3>
<p class="BodyFirst">MASM provides several data types to support the use of floating-point data in your assembly language programs. MASM floating-point constants allow the following syntax:</p>
<ul>
<li>An optional <code>+</code> or <code>-</code> symbol, denoting the sign of the mantissa (if this is not present, MASM assumes that the mantissa is positive)</li>
<li>Followed by one or more decimal digits</li>
<li><span epub:type="pagebreak" title="91" id="Page_91"/>Followed by a decimal point and zero or more decimal digits</li>
<li>Optionally followed by an <code>e</code> or <code>E</code>, optionally followed by a sign (<code>+</code> or <code>-</code>) and one or more decimal digits</li>
</ul>
<p>The decimal point or the <code>e</code>/<code>E</code> must be present in order to differentiate this value from an integer or unsigned literal constant. Here are some examples of legal literal floating-point constants:</p>
<pre><code>1.234  3.75e2  -1.0  1.1e-1  1.e+4  0.1  -123.456e+789  +25.0e0  1.e3</code></pre>
<p>A floating-point literal constant must begin with a decimal digit, so you must use, for example, 0.1 to represent .1 in your programs.</p>
<p>To declare a floating-point variable, you use the <code>real4</code>, <code>real8</code>, or <code>real10</code> data types. The number at the end of these data type declarations specifies the number of bytes used for each type’s binary representation. Therefore, you use <code>real4</code> to declare single-precision real values, <code>real8</code> to declare double-precision floating-point values, and <code>real10</code> to declare extended-precision floating-point values. Aside from using these types to declare floating-point variables rather than integers, their use is nearly identical to that of <code>byte</code>, <code>word</code>, <code>dword</code><em>, </em>and so on. The following examples demonstrate these declarations and their syntax:</p>
<pre><code>         .data

fltVar1  real4  ?
fltVar1a real4  2.7
pi       real4  3.14159
DblVar   real8  ?
DblVar2  real8  1.23456789e+10
XPVar    real10 ?
XPVar2   real10 -1.0e-104</code></pre>
<p>As usual, this book uses the C/C++ <code>printf()</code> function to print floating-point values to the console output. Certainly, an assembly language routine could be written to do this same thing, but the C Standard Library provides a convenient way to avoid writing that (complex) code, at least for the time being.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Floating-point arithmetic is different from integer arithmetic; you cannot use the x86-64 <code>add</code> and <code>sub</code> instructions to operate on floating-point values. Floating-point arithmetic is covered in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501089c02-0014">	2.14	Binary-Coded Decimal Representation</h2>
<p class="BodyFirst">Although the integer and floating-point formats cover most of the numeric needs of an average program, in some special cases other numeric representations are convenient. In this section, we’ll discuss the <em>binary-coded decimal (BCD)</em> format because the x86-64 CPU provides a small amount of hardware support for this data representation.</p>
<p><span epub:type="pagebreak" title="92" id="Page_92"/>BCD values are a sequence of nibbles, with each nibble representing a value in the range 0 to 9. With a single byte, we can represent values containing two decimal digits, or values in the range 0 to 99 (see <a href="#figure2-24" id="figureanchor2-24">Figure 2-24</a>).</p>
<figure>
<img src="image_fi/501089c02/f02024.png" alt="f02024" class=""/>
<figcaption><p><a id="figure2-24">Figure 2-24</a>: BCD data representation in memory</p></figcaption>
</figure>
<p>As you can see, BCD storage isn’t particularly memory efficient. For example, an 8-bit BCD variable can represent values in the range 0 to 99, while that same 8 bits, when holding a binary value, can represent values in the range 0 to 255. Likewise, a 16-bit binary value can represent values in the range 0 to 65,535, while a 16-bit BCD value can represent only about one-sixth of those values (0 to 9999).</p>
<p>However, it’s easy to convert BCD values between the internal numeric representation and their string representation, and to encode multi-digit decimal values in hardware (for example, using a thumb wheel or dial) using BCD. For these two reasons, you’re likely to see people using BCD in embedded systems (such as toaster ovens, alarm clocks, and nuclear reactors) but rarely in general-purpose computer software.</p>
<p>The Intel x86-64 floating-point unit supports a pair of instructions for loading and storing BCD values. Internally, however, the FPU converts these BCD values to binary and performs all calculations in binary. It uses BCD only as an external data format (external to the FPU, that is). This generally produces more-accurate results and requires far less silicon than having a separate coprocessor that supports decimal arithmetic.</p>
<h2 id="h1-501089c02-0015">	2.15	Characters</h2>
<p class="BodyFirst">Perhaps the most important data type on a personal computer is the <code>character</code> data type. The term <em>character</em> refers to a human or machine-readable symbol that is typically a non-numeric entity, specifically any symbol that you can normally type on a keyboard (including some symbols that may require multiple keypresses to produce) or display on a video display. Letters (<em>alphabetic characters</em>), punctuation symbols, numeric digits, spaces, tabs, carriage returns (<span class="KeyCaps">enter</span>), other control characters, and other special symbols are all characters. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	<em>Numeric characters </em>are distinct from numbers: the character <code>"</code><code>1</code><code>"</code> is different from the value <code>1</code>. The computer (generally) uses two different internal representations for numeric characters (<code>"</code><code>0"</code>, <code>"</code><code>1"</code>, . . . , <code>"</code><code>9</code><code>"</code>) versus the numeric values 0 to 9.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="93" id="Page_93"/>Most computer systems use a 1- or 2-byte sequence to encode the various characters in binary form. Windows, macOS, FreeBSD, and Linux use either the ASCII or Unicode encodings for characters. This section discusses the ASCII and Unicode character sets and the character declaration facilities that MASM provides.</p>
<h3 id="h2-501089c02-0024">2.15.1	The ASCII Character Encoding</h3>
<p class="BodyFirst">The <em>American Standard Code for Information Interchange (ASCII) character set</em> maps 128 textual characters to the unsigned integer values 0 to 127 (0 to 7Fh). Although the exact mapping of characters to numeric values is arbitrary and unimportant, using a standardized code for this mapping is important because when you communicate with other programs and peripheral devices, you all need to speak the same “language.” ASCII is a standardized code that nearly everyone has agreed on: if you use the ASCII code 65 to represent the character <code>A</code>, then you know that a peripheral device (such as a printer) will correctly interpret this value as the character <code>A</code> whenever you transmit data to that device.</p>
<p>Despite some major shortcomings, ASCII data has become the<em> </em>standard for data interchange across computer systems and programs.<sup class="FootnoteReference"><a id="c02-footnoteref-16" href="#c02-footnote-16">16</a></sup> Most programs can accept ASCII data; likewise, most programs can produce ASCII data. Because you will be dealing with ASCII characters in assembly language, it would be wise to study the layout of the character set and memorize a few key ASCII codes (for example, for <code>0</code>, <code>A</code>, <code>a</code>, and so on). See <span class="xref" itemid="xref_target_Appendix A">Appendix A</span> for a list of all the ASCII character codes.</p>
<p>The ASCII character set is divided into four groups of 32 characters. The first 32 characters, ASCII codes 0 to 1Fh (31), form a special set of nonprinting characters, the <em>control characters</em>. We call them control characters because they perform various printer/display control operations rather than display symbols. Examples include <em>carriage return</em>, which positions the cursor to the left side of the current line of characters;<sup class="FootnoteReference"><a id="c02-footnoteref-17" href="#c02-footnote-17">17</a></sup> line feed, which moves the cursor down one line on the output device; and backspace, which moves the cursor back one position to the left.</p>
<p>Unfortunately, different control characters perform different operations on different output devices. Little standardization exists among output devices. To find out exactly how a control character affects a particular device, you will need to consult its manual.</p>
<p>The second group of 32 ASCII character codes contains various punctuation symbols, special characters, and the numeric digits. The most notable characters in this group include the space character (ASCII code 20h) and the numeric digits (ASCII codes 30h to 39h).</p>
<p><span epub:type="pagebreak" title="94" id="Page_94"/>The third group of 32 ASCII characters contains the uppercase alphabetic characters. The ASCII codes for the characters <code>A</code> to <code>Z</code> lie in the range 41h to 5Ah (65 to 90). Because there are only 26 alphabetic characters, the remaining 6 codes hold various special symbols.</p>
<p>The fourth, and final, group of 32 ASCII character codes represents the lowercase alphabetic symbols, 5 additional special symbols, and another control character (delete). The lowercase character symbols use the ASCII codes 61h to 7Ah. If you convert the codes for the upper- and lowercase characters to binary, you will notice that the uppercase symbols differ from their lowercase equivalents in exactly one bit position. For example, consider the character codes for <code>E</code> and <code>e</code> appearing in <a href="#figure2-25" id="figureanchor2-25">Figure 2-25</a>.</p>
<figure>
<img src="image_fi/501089c02/f02025.png" alt="f02025" class=""/>
<figcaption><p><a id="figure2-25">Figure 2-25</a>: ASCII codes for <em>E</em> and <em>e</em></p></figcaption>
</figure>
<p>The only place these two codes differ is in bit 5. Uppercase characters always contain a 0 in bit 5; lowercase alphabetic characters always contain a 1 in bit 5. You can use this fact to quickly convert between upper- and lowercase. If you have an uppercase character, you can force it to lowercase by setting bit 5 to 1. If you have a lowercase character, you can force it to uppercase by setting bit 5 to 0. You can toggle an alphabetic character between upper- and lowercase by simply inverting bit 5.</p>
<p>Indeed, bits 5 and 6 determine which of the four groups in the ASCII character set you’re in, as <a href="#table2-13" id="tableanchor2-13">Table 2-13</a> shows.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-13">Table 2-13</a>: ASCII Groups</p></figcaption>
<table id="table-501089c02-0014" border="1">
<thead>
<tr>
<td><b>Bit 6</b></td>
<td><b>Bit 5</b></td>
<td><b>Group</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>Control characters</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Digits and punctuation</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>Uppercase and special</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>Lowercase and special</td>
</tr>
</tbody>
</table>
</figure>
<p>So you could, for instance, convert any upper- or lowercase (or corresponding special) character to its equivalent control character by setting bits 5 and 6 to 0. </p>
<p>Consider, for a moment, the ASCII codes of the numeric digit characters appearing in <a href="#table2-14" id="tableanchor2-14">Table 2-14</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-14">Table 2-14</a>: ASCII Codes for Numeric Digits<span epub:type="pagebreak" title="95" id="Page_95"/></p></figcaption>
<table id="table-501089c02-0015" border="1">
<thead>
<tr>
<td><b>Character</b></td>
<td><b>Decimal</b></td>
<td><b>Hexadecimal</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>48</td>
<td>30h</td>
</tr>
<tr>
<td>1</td>
<td>49</td>
<td>31h</td>
</tr>
<tr>
<td>2</td>
<td>50</td>
<td>32h</td>
</tr>
<tr>
<td>3</td>
<td>51</td>
<td>33h</td>
</tr>
<tr>
<td>4</td>
<td>52</td>
<td>34h</td>
</tr>
<tr>
<td>5</td>
<td>53</td>
<td>35h</td>
</tr>
<tr>
<td>6</td>
<td>54</td>
<td>36h</td>
</tr>
<tr>
<td>7</td>
<td>55</td>
<td>37h</td>
</tr>
<tr>
<td>8</td>
<td>56</td>
<td>38h</td>
</tr>
<tr>
<td>9</td>
<td>57</td>
<td>39h</td>
</tr>
</tbody>
</table>
</figure>
<p>The LO nibble of the ASCII code is the binary equivalent of the represented number. By stripping away (that is, setting to <code>0</code>) the HO nibble of a numeric character, you can convert that character code to the corresponding binary representation. Conversely, you can convert a binary value in the range 0 to 9 to its ASCII character representation by simply setting the HO nibble to <code>3</code>. You can use the logical AND operation to force the HO bits to 0; likewise, you can use the logical OR operation to force the HO bits to 0011b (3).</p>
<p>Unfortunately, you <em>cannot</em> convert a string of numeric characters to their equivalent binary representation by simply stripping the HO nibble from each digit in the string. Converting 123 (31h 32h 33h) in this fashion yields 3 bytes, 010203h, but the correct value for 123 is 7Bh. The conversion described in the preceding paragraph works only for single digits.</p>
<h3 id="h2-501089c02-0025">2.15.2	MASM Support for ASCII Characters</h3>
<p class="BodyFirst">MASM provides support for character variables and literals in your assembly language programs. Character literal constants in MASM take one of two forms: a single character surrounded by apostrophes or a single character surrounded by quotes, as follows:</p>
<pre><code>'A'  "A" </code></pre>
<p>Both forms represent the same character (<code>A</code>).</p>
<p>If you wish to represent an apostrophe or a quote within a string, use the other character as the string delimiter. For example:</p>
<pre><code>'A "quotation" appears within this string'
"Can't have quotes in this string" </code></pre>
<p><span epub:type="pagebreak" title="96" id="Page_96"/>Unlike the C/C++ language, MASM doesn’t use different delimiters for single-character objects versus string objects, or differentiate between a character constant and a string constant with a single character. A character literal constant has a single character between the quotes (or apostrophes); a string literal has multiple characters between the delimiters.</p>
<p>To declare a character variable in a MASM program, you use the <code>byte</code> data type. For example, the following declaration demonstrates how to declare a variable named <code>UserInput</code>:</p>
<pre><code>               .data
UserInput      byte ?</code></pre>
<p>This declaration reserves 1 byte of storage that you could use to store any character value (including 8-bit extended ASCII/ANSI characters). You can also initialize character variables as follows:</p>
<pre><code>              .data
TheCharA      byte 'A'
ExtendedChar  byte 128 ; Character code greater than 7Fh</code></pre>
<p>Because character variables are 8-bit objects, you can manipulate them using 8-bit registers. You can move character variables into 8-bit registers, and you can store the value of an 8-bit register into a character variable.</p>
<h2 id="h1-501089c02-0016">	2.16	The Unicode Character Set</h2>
<p class="BodyFirst">The problem with ASCII is that it supports only 128 character codes. Even if you extend the definition to 8 bits (as IBM did on the original PC), you’re limited to 256 characters. This is way too small for modern multinational/multilingual applications. Back in the 1990s, several companies developed an extension to ASCII, known as <em>Unicode</em>, using a 2-byte character size. Therefore, (the original) Unicode supported up to 65,536 character codes.</p>
<p>Alas, as well-thought-out as the original Unicode standard could be, systems engineers discovered that even 65,536 symbols were insufficient. Today, Unicode defines 1,112,064 possible characters, encoded using a variable-length character format.</p>
<h3 id="h2-501089c02-0026">2.16.1	Unicode Code Points</h3>
<p class="BodyFirst">A Unicode <em>code point</em> is an integer value that Unicode associates with a particular character symbol. The convention for Unicode code points is to specify the value in hexadecimal with a preceding U+ prefix; for example, U+0041 is the Unicode code point for the <code>A</code> character (41h is also the ASCII code for <code>A</code>; Unicode code points in the range U+0000 to U+007F correspond to the ASCII character set).</p>
<h3 id="h2-501089c02-0027"><span epub:type="pagebreak" title="97" id="Page_97"/>2.16.2	Unicode Code Planes</h3>
<p class="BodyFirst">The Unicode standard defines code points in the range U+000000 to U+10FFFF (10FFFFh is 1,114,111, which is where most of the 1,112,064 characters in the Unicode character set come from; the remaining 2047 code points are reserved for use as <em>surrogates</em>, which are Unicode extensions).<sup class="FootnoteReference"><a id="c02-footnoteref-18" href="#c02-footnote-18">18</a></sup> The Unicode standard breaks this range up into 17 <em>multilingual planes</em>, each supporting up to 65,536 code points. The HO two hexadecimal digits of the six-digit code point value specify the multilingual plane, and the remaining four digits specify the character within the plane.</p>
<p>The first multilingual plane, U+000000 to U+00FFFF, roughly corresponds to the original 16-bit Unicode definition; the Unicode standard calls this the <em>Basic Multilingual Plane (BMP)</em>. Planes 1 (U+010000 to U+01FFFF), 2 (U+020000 to U+02FFFF), and 14 (U+0E0000 to U+0EFFFF) are supplementary (extension) planes. Unicode reserves planes 3 to 13 for future expansion, and planes 15 and 16 for user-defined character sets.</p>
<p>Obviously, representing Unicode code points outside the BMP requires more than 2 bytes. To reduce memory usage, Unicode (specifically the UTF-16 encoding; see the next section) uses 2 bytes for the Unicode code points in the BMP, and uses 4 bytes to represent code points outside the BMP. Within the BMP, Unicode reserves the surrogate code points (U+D800–U+DFFF) to specify the 16 planes after the BMP. <a href="#figure2-26" id="figureanchor2-26">Figure 2-26</a> shows the encoding.</p>
<figure>
<img src="image_fi/501089c02/f02026.png" alt="f02026" class=""/>
<figcaption><p><a id="figure2-26">Figure 2-26</a>: Surrogate code point encoding for Unicode planes 1 to 16</p></figcaption>
</figure>
<p>Note that the two words (unit 1 and unit 2) always appear together. The unit 1 value (with HO bits 110110b) specifies the upper 10 bits (b<sub>10</sub> to b<sub>19</sub>) of the Unicode scalar, and the unit 2 value (with HO bits 110111b) specifies the lower 10 bits (b<sub>0</sub> to b<sub>9</sub>) of the Unicode scalar. Therefore, bits b<sub>16</sub> to b<sub>19</sub> (plus one) specify Unicode plane 1 to 16. Bits b<sub>0</sub> to b<sub>15</sub> specify the Unicode scalar value within the plane.</p>
<h3 id="h2-501089c02-0028">2.16.3	Unicode Encodings</h3>
<p class="BodyFirst">As of Unicode v2.0, the standard supports a 21-bit character space capable of handling over a million characters (though most of the code points remain reserved for future use). Rather than use a 3-byte (or worse, 4-byte) encoding to allow the larger character set, Unicode, Inc., allowed different encodings, each with its own advantages and disadvantages.</p>
<p><span epub:type="pagebreak" title="98" id="Page_98"/><em>UTF-32</em> uses 32-bit integers to hold Unicode scalars.<sup class="FootnoteReference"><a id="c02-footnoteref-19" href="#c02-footnote-19">19</a></sup> The advantage to this scheme is that a 32-bit integer can represent every Unicode scalar value (which requires only 21 bits). Programs that require random access to characters in strings (without having to search for surrogate pairs) and other constant-time operations are (mostly) possible when using UTF-32. The obvious drawback to UTF-32 is that each Unicode scalar value requires 4 bytes of storage (twice that of the original Unicode definition and four times that of ASCII characters).</p>
<p>The second encoding format the Unicode supports is <em>UTF-16</em>. As the name suggests, UTF-16 uses 16-bit (unsigned) integers to represent Unicode values. To handle scalar values greater than 0FFFFh, UTF-16 uses the surrogate pair scheme to represent values in the range 010000h to 10FFFFh (see the discussion of code planes and surrogate code points in the previous section). Because the vast majority of useful characters fit into 16 bits, most UTF-16 characters require only 2 bytes. For those rare cases where surrogates are necessary, UTF-16 requires two words (32 bits) to represent the character.</p>
<p>The last encoding, and unquestionably the most popular, is <em>UTF-8</em>. The UTF-8 encoding is upward compatible from the ASCII character set. In particular, all ASCII characters have a single-byte representation (their original ASCII code, where the HO bit of the byte containing the character contains a 0 bit). If the UTF-8 HO bit is 1, UTF-8 requires additional bytes (1 to 3 additional bytes) to represent the Unicode code point. <a href="#table2-15" id="tableanchor2-15">Table 2-15</a> provides the UTF-8 encoding schema.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-15">Table 2-15</a>: UTF-8 Encoding</p></figcaption>
<table id="table-501089c02-0016" border="1">
<thead>
<tr>
<td><b>Bytes</b></td>
<td><b>Bits for code point</b></td>
<td><b>First code point</b></td>
<td><b>Last code point</b></td>
<td><b>Byte 1</b></td>
<td><b>Byte 2</b></td>
<td><b>Byte 3</b></td>
<td><b>Byte 4</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>7</td>
<td>U+00</td>
<td>U+7F</td>
<td>0<em>xxxxxxx</em></td>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>2</td>
<td>11</td>
<td>U+80</td>
<td>U+7FF</td>
<td>110<em>xxxxx</em></td>
<td>10<em>xxxxxx</em></td>
<td/>
<td/>
</tr>
<tr>
<td>3</td>
<td>16</td>
<td>U+800</td>
<td>U+FFFF</td>
<td>1110<em>xxxx</em></td>
<td>10<em>xxxxxx</em></td>
<td>10<em>xxxxxx</em></td>
<td/>
</tr>
<tr>
<td>4</td>
<td>21</td>
<td>U+10000</td>
<td>U+10FFFF</td>
<td>11110<em>xxx</em></td>
<td>10<em>xxxxxx</em></td>
<td>10<em>xxxxxx</em></td>
<td>10<em>xxxxxx</em></td>
</tr>
</tbody>
</table>
</figure>
<p>The <var>xxx...</var> bits are the Unicode code point bits. For multi-byte sequences, byte 1 contains the HO bits, byte 2 contains the next HO bits, and so on. For example, the 2-byte sequence 11011111b, 10000001b corresponds to the Unicode scalar 0000_0111_1100_0001b (U+07C1).</p>
<h2 id="h1-501089c02-0017">	2.17	MASM Support for Unicode</h2>
<p class="BodyFirst">Unfortunately, MASM provides almost zero support for Unicode text in a source file. Fortunately, MASM’s macro facilities provide a way for you to create your own Unicode support for strings in MASM. See <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span> for more details on MASM macros. I will also return to this subject in <em>The Art of <span epub:type="pagebreak" title="99" id="Page_99"/>64-Bit Assembly</em>, Volume 2, where I will spend considerable time describing how to force MASM to accept and process Unicode strings in source and resource files.</p>
<h2 id="h1-501089c02-0018">	2.18	For More Information</h2>
<p class="BodyFirst">For general information about data representation and Boolean functions, consider reading my book <em>Write Great Code</em>, Volume 1, Second Edition (No Starch Press, 2020), or a textbook on data structures and algorithms (available at any bookstore).</p>
<p>ASCII, EBCDIC, and Unicode are all international standards. You can find out more about the Extended Binary Coded Decimal Interchange Code (EBCDIC) character set families on IBM’s website (<a href="http://www.ibm.com/" class="LinkURL">http://www.ibm.com/</a>). ASCII and Unicode are both International Organization for Standardization (ISO) standards, and ISO provides reports for both character sets. Generally, those reports cost money, but you can also find out lots of information about the ASCII and Unicode character sets by searching for them by name on the internet. You can also read about Unicode at <a href="http://www.unicode.org/" class="LinkURL">http://www.unicode.org/</a>. <em>Write Great Code </em>also contains additional information on the history, use, and encoding of the Unicode character set.</p>
<h2 id="h1-501089c02-0019">	2.19	Test Yourself</h2>
<ol class="decimal">
<li value="1">What does the decimal value 9384.576 represent (in terms of powers of 10)?</li>
<li value="2">Convert the following binary values to decimal:
<ol class="lower-alpha">
<li value="1">1010</li>
<li value="2">1100</li>
<li value="3">0111</li>
<li value="4">1001</li>
<li value="5">0011</li>
<li value="6">1111</li>
</ol></li>
<li value="3">Convert the following binary values to hexadecimal:
<ol class="lower-alpha">
<li value="1">1010</li>
<li value="2">1110</li>
<li value="3">1011</li>
<li value="4">1101</li>
<li value="5">0010</li>
<li value="6">1100</li>
<li value="7">1100_1111</li>
<li value="8">1001_1000_1101_0001</li>
</ol></li>
<li value="4"><span epub:type="pagebreak" title="100" id="Page_100"/>Convert the following hexadecimal values to binary:
<ol class="lower-alpha">
<li value="1">12AF</li>
<li value="2">9BE7</li>
<li value="3">4A</li>
<li value="4">137F</li>
<li value="5">F00D</li>
<li value="6">BEAD</li>
<li value="7">4938</li>
</ol></li>
<li value="5">Convert the following hexadecimal values to decimal:
<ol class="lower-alpha">
<li value="1">A</li>
<li value="2">B</li>
<li value="3">F</li>
<li value="4">D</li>
<li value="5">E</li>
<li value="6">C</li>
</ol></li>
<li value="6">How many bits are there in a
<ol class="lower-alpha">
<li value="1">Word</li>
<li value="2">Qword</li>
<li value="3">Oword</li>
<li value="4">Dword</li>
<li value="5">BCD digit</li>
<li value="6">Byte</li>
<li value="7">Nibble</li>
</ol></li>
<li value="7">How many bytes are there in a
<ol class="lower-alpha">
<li value="1">Word</li>
<li value="2">Dword</li>
<li value="3">Qword</li>
<li value="4">Oword</li>
</ol></li>
<li value="8">How different values can you represent with a
<ol class="lower-alpha">
<li value="1">Nibble</li>
<li value="2">Byte</li>
<li value="3">Word</li>
<li value="4">Bit</li>
</ol></li>
<li value="9">How many bits does it take to represent a hexadecimal digit?</li>
<li value="10">How are the bits in a byte numbered?</li>
<li value="11"><span epub:type="pagebreak" title="101" id="Page_101"/>Which bit number is the LO bit of a word?</li>
<li value="12">Which bit number is the HO bit of a dword?</li>
<li value="13">Compute the logical AND of the following binary values:
<ol class="lower-alpha">
<li value="1">0 and 0</li>
<li value="2">0 and 1</li>
<li value="3">1 and 0</li>
<li value="4">1 and 1</li>
</ol></li>
<li value="14">Compute the logical OR of the following binary values:
<ol class="lower-alpha">
<li value="1">0 and 0</li>
<li value="2">0 and 1</li>
<li value="3">1 and 0</li>
<li value="4">1 and 1</li>
</ol></li>
<li value="15">Compute the logical XOR of the following binary values:
<ol class="lower-alpha">
<li value="1">0 and 0</li>
<li value="2">0 and 1</li>
<li value="3">1 and 0</li>
<li value="4">1 and 1</li>
</ol></li>
<li value="16">The logical NOT operation is the same as XORing with what value?</li>
<li value="17">Which logical operation would you use to force bits to 0 in a bit string?</li>
<li value="18">Which logical operation would you use to force bits to 1 in a bit string?</li>
<li value="19">Which logical operation would you use to invert all the bits in a bit string?</li>
<li value="20">Which logical operation would you use to invert selected bits in a bit string?</li>
<li value="21">Which machine instruction will invert all the bits in a register?</li>
<li value="22">What is the two’s complement of the 8-bit value 5 (00000101b)?</li>
<li value="23">What is the two’s complement of the signed 8-bit value –2 (11111110)?</li>
<li value="24">Which of the following signed 8-bit values are negative?
<ol class="lower-alpha">
<li value="1">1111_1111b</li>
<li value="2">0111_0001b</li>
<li value="3">1000_0000b</li>
<li value="4">0000_0000b</li>
<li value="5">1000_0001b</li>
<li value="6">0000_0001b</li>
</ol></li>
<li value="25">Which machine instruction takes the two’s complement of a value in a register or memory location?</li>
<li value="26"><span epub:type="pagebreak" title="102" id="Page_102"/>Which of the following 16-bit values can be correctly sign-contracted to 8 bits?
<ol class="lower-alpha">
<li value="1">1111_1111_1111_1111</li>
<li value="2">1000_0000_0000_0000</li>
<li value="3">000_0000_0000_0001</li>
<li value="4">1111_1111_1111_0000</li>
<li value="5">1111_1111_0000_0000</li>
<li value="6">0000_1111_0000_1111</li>
<li value="7">0000_0000_1111_1111</li>
<li value="8">0000_0001_0000_0000</li>
</ol></li>
<li value="27">What machine instruction provides the equivalent of an HLL <code>goto</code> statement?</li>
<li value="28">What is the syntax for a MASM statement label?</li>
<li value="29">What flags are the condition codes?</li>
<li value="30"><em>JE</em> is a synonym for what instruction that tests a condition code?</li>
<li value="31"><em>JB</em> is a synonym for what instruction that tests a condition code?</li>
<li value="32">Which conditional jump instructions transfer control based on an unsigned comparison?</li>
<li value="33">Which conditional jump instructions transfer control based on a signed comparison?</li>
<li value="34">How does the SHL instruction affect the zero flag?</li>
<li value="35">How does the SHL instruction affect the carry flag?</li>
<li value="36">How does the SHL instruction affect the overflow flag?</li>
<li value="37">How does the SHL instruction affect the sign flag?</li>
<li value="38">How does the SHR instruction affect the zero flag?</li>
<li value="39">How does the SHR instruction affect the carry flag?</li>
<li value="40">How does the SHR instruction affect the overflow flag?</li>
<li value="41">How does the SHR instruction affect the sign flag?</li>
<li value="42">How does the SAR instruction affect the zero flag?</li>
<li value="43">How does the SAR instruction affect the carry flag?</li>
<li value="44">How does the SAR instruction affect the overflow flag?</li>
<li value="45">How does the SAR instruction affect the sign flag?</li>
<li value="46">How does the RCL instruction affect the carry flag?</li>
<li value="47">How does the RCL instruction affect the zero flag?</li>
<li value="48">How does the RCR instruction affect the carry flag?</li>
<li value="49">How does the RCR instruction affect the sign flag?</li>
<li value="50">A shift left is equivalent to what arithmetic operation?</li>
<li value="51">A shift right is equivalent to what arithmetic operation?</li>
<li value="52"><span epub:type="pagebreak" title="103" id="Page_103"/>When performing a chain of floating-point addition, subtraction, multiplication, and division operations, which operations should you try to do first?</li>
<li value="53">How should you compare floating-point values for equality?</li>
<li value="54">What is a normalized floating-point value?</li>
<li value="55">How many bits does a (standard) ASCII character require?</li>
<li value="56">What is the hexadecimal representation of the ASCII characters 0 through 9?</li>
<li value="57">What delimiter character(s) does MASM use to define character constants?</li>
<li value="58">What are the three common encodings for Unicode characters?</li>
<li value="59">What is a Unicode code point?</li>
<li value="60">What is a Unicode code plane?</li>
</ol>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-1" href="#c02-footnoteref-1">1.</a></sup> <em>Binary-coded decimal</em> is a numeric scheme used to represent decimal numbers, using 4 bits for each decimal digit.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-2" href="#c02-footnoteref-2">2.</a></sup> For MASM’s HLL statements, the <span class="LiteralFootnote"><code>byte</code></span> directive also notes that the value is an unsigned, rather than signed, value. However, for most normal machine instructions, MASM ignores this extra type information.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-3" href="#c02-footnoteref-3">3.</a></sup> Many texts call this a <em>binary operation</em>. The term <em>dyadic</em> means the same thing and avoids the confusion with the binary numbering system.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-4" href="#c02-footnoteref-4">4.</a></sup> The XMM and YMM registers process up to 128 or 256 bits, respectively. If you have a CPU that supports ZMM registers, it can process 512 bits at a time.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-5" href="#c02-footnoteref-5">5.</a></sup> Technically, <span class="LiteralFootnote"><code>atoi()</code></span> returns a 32-bit integer in EAX. This code goes ahead and uses 64-bit values; the C Standard Library code ignores the HO 32 bits in RAX.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-6" href="#c02-footnoteref-6">6.</a></sup> Note that variants of the <span class="LiteralFootnote"><code>jmp</code></span> instruction, known as <em>indirect jumps</em>, can provide conditional execution capabilities. For more information, see <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-7" href="#c02-footnoteref-7">7.</a></sup> Technically, you can test a fifth condition code flag: the parity flag. This book does not cover its use. See the Intel documentation for more details about the parity flag.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-8" href="#c02-footnoteref-8">8.</a></sup> Immediate operands for 64-bit instructions are also limited to 32 bits, which the CPU sign extends to 64 bits.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-9" href="#c02-footnoteref-9">9.</a></sup> There is no need for an arithmetic shift left. The standard shift-left operation works for both signed and unsigned numbers, assuming no overflow occurs.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-10" href="#c02-footnoteref-10">10.</a></sup> If you’re too young to remember this fiasco, programmers in the middle to late 1900s used to encode only the last two digits of the year in their dates. When the year 2000 rolled around, the programs were incapable of distinguishing dates like 2019 and 1919.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-11" href="#c02-footnoteref-11">11.</a></sup> Minor changes were made to the way certain degenerate operations were handled, but the bit representation remained essentially unchanged.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-12" href="#c02-footnoteref-12">12.</a></sup> The <em>binary point</em> is the same thing as the <em>decimal point</em> except it appears in binary numbers rather than decimal numbers.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-13" href="#c02-footnoteref-13">13.</a></sup> This isn’t necessarily true. The IEEE floating-point format supports <em>denormalized </em>values where the HO bit is not 0. However, we will ignore denormalized values in our discussion.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-14" href="#c02-footnoteref-14">14.</a></sup> The <em>dynamic range</em> is the difference in size between the smallest and largest positive values.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-15" href="#c02-footnoteref-15">15.</a></sup> The alternative would be to underflow the values to 0.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-16" href="#c02-footnoteref-16">16.</a></sup> Today, Unicode (especially the UTF-8 encoding) is rapidly replacing ASCII because the ASCII character set is insufficient for handling international alphabets and other special characters.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-17" href="#c02-footnoteref-17">17.</a></sup> Historically, carriage return refers to the paper carriage used on typewriters: physically moving the carriage all the way to the right enabled the next character typed to appear at the left side of the paper.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-18" href="#c02-footnoteref-18">18.</a></sup> <em>Unicode scalars</em> is another term you might hear. A Unicode scalar is a value from the set of all Unicode code points <em>except</em> the 2047 surrogate code points.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c02-footnote-19" href="#c02-footnoteref-19">19.</a></sup> <em>UTF</em> stands for <em>Universal Transformation Format</em>, if you were wondering.</p></aside>
</section>
</section>
</body></html>