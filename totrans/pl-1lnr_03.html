<html><head></head><body><section class="chapter" title="Chapter&#xA0;4.&#xA0;Calculations" epub:type="chapter" id="calculations"><div class="titlepage"><div><div><h2 class="title">Chapter 4. Calculations</h2></div></div></div><p><a id="idx00051" class="indexterm"/><a id="idx00496" class="indexterm"/>In this chapter, we’ll look at various one-liners for performing calculations, such as finding minimum and maximum elements, counting, shuffling and permuting words, and calculating dates and numbers. You’ll also learn about the <code class="literal">-a</code>, <code class="literal">-M</code>, and <code class="literal">-F</code> command-line arguments, the <code class="literal">$</code>, special variable, and the <code class="literal">@{[ ... ]}</code> construction that lets you run code inside double quotes.</p><div class="sect1" title="4.1 Check if a number is a prime"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_1_check_if_a_number_is_a_prime">4.1 Check if a number is a prime</h2></div></div></div><a id="I_programlisting4_id304508"/><pre class="programlisting">perl -lne '(1x$_) !~ /^1?$|^(11+?)\1+$/ &amp;&amp; print "$_ is prime"'</pre><p>This one-liner uses an ingenious regular expression by Abigail to detect whether a given number is a prime. (Don’t take this regular expression too seriously; I’ve included it for its artistic value. For serious purposes, use the <code class="literal">Math::Primality</code> module from CPAN to see whether a number is prime.)</p><p><a id="idx00016" class="indexterm"/><a id="idx00037" class="indexterm"/><a id="idx00039" class="indexterm"/><a id="idx00049" class="indexterm"/><a id="idx00058" class="indexterm"/><a id="idx00073" class="indexterm"/><a id="idx00105" class="indexterm"/><a id="idx00121" class="indexterm"/><a id="idx00136" class="indexterm"/><a id="idx00220" class="indexterm"/><a id="idx00228" class="indexterm"/><a id="idx00234" class="indexterm"/><a id="idx00378" class="indexterm"/><a id="idx00386" class="indexterm"/><a id="idx00403" class="indexterm"/><a id="idx00442" class="indexterm"/><a id="idx00444" class="indexterm"/><a id="idx00556" class="indexterm"/><a id="idx00591" class="indexterm"/><a id="idx00628" class="indexterm"/>Here’s how this ingenious one-liner works: First, the number is converted into its unary representation by <code class="literal">(1x$_)</code>. For example, <code class="literal">5</code> is converted into <code class="literal">1x5</code>, which is <code class="literal">11111</code> (<code class="literal">1</code> repeated <code class="literal">5</code> times). Next, the unary number is tested against the regular expression. If it doesn’t match, the number is a prime; otherwise it’s a composite. The <code class="literal">!~</code> operator is the opposite of the <code class="literal">=~</code> operator and is true if the regular expression doesn’t match.</p><p>The regular expression consists of two parts: The first part, <code class="literal">^1?$</code>, matches <code class="literal">1</code> and the empty string. The empty string and 1 are clearly not prime numbers, so this part of the regular expression discards them.</p><p>The second part, <code class="literal">^(11+?)\1+$</code>, determines whether two or more <code class="literal">1</code>s repeatedly make up the whole number. If so, the regular expression matches, which means the number is a composite. If not, it’s a prime.</p><p>Now consider how the second part of the regular expression would act on the number 5. The number 5 in unary is 11111, so the <code class="literal">(11+?)</code> matches the first two <code class="literal">1</code>s, the back-reference <code class="literal">\1</code> becomes 11, and the whole regular expression now becomes <code class="literal">^11(11)+$</code>. Because it can’t match five <code class="literal">1</code>s, it fails. Next, it attempts to match the first three <code class="literal">1</code>s. The back-reference becomes 111, and the whole regular expression becomes <code class="literal">^111(111)+$</code>, which doesn’t match. The process repeats for 1111 and 11111, which also don’t match, and as a result the entire regular expression doesn’t match and the number is a prime.</p><p>What about the number 4? The number 4 is 1111 in unary. The <code class="literal">(11+?)</code> matches the first two <code class="literal">1</code>s. The back-reference <code class="literal">\1</code> becomes 11, and the regular expression becomes <code class="literal">^11(11)+$</code>, which matches the original string and confirms that the number is not prime.</p></div><div class="sect1" title="4.2 Print the sum of all fields on each line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_2_print_the_sum_of_all_fields_on_ea">4.2 Print the sum of all fields on each line</h2></div></div></div><a id="I_programlisting4_id304786"/><pre class="programlisting">perl -MList::Util=sum -alne 'print sum @F'</pre><p>This one-liner turns on field <span class="emphasis"><em>auto-splitting</em></span> with the <code class="literal">-a</code> command-line option and imports the <code class="literal">sum</code> function from the <code class="literal">List::Util</code> module with <code class="literal">-Mlist::Util=sum</code>. (<code class="literal">List::Util</code> is part of the Perl core, so you don’t need install it.) Auto-splitting happens on whitespace characters by default, and the resulting fields are put in the <code class="literal">@F</code> variable. For example, the line <code class="literal">1 4 8</code> would be split on each space so that <code class="literal">@F</code> would become <code class="literal">(1, 4, 8)</code>. The <code class="literal">sum @F</code> statement sums the elements in the <code class="literal">@F</code> array, giving you <code class="literal">13</code>.</p><p><a id="idx00126" class="indexterm"/><a id="idx00137" class="indexterm"/><a id="idx00223" class="indexterm"/><a id="idx00273" class="indexterm"/><a id="idx00387" class="indexterm"/><a id="idx00512" class="indexterm"/>The <code class="literal">-Mmodule=arg</code> option imports <code class="literal">arg</code> from <code class="literal">module</code>. It’s the same as writing</p><a id="I_programlisting4_id304907"/><pre class="programlisting">use module qw(arg);</pre><p>This one-liner is equivalent to</p><a id="I_programlisting4_id304914"/><pre class="programlisting">use List::Util qw(sum);
while (&lt;&gt;) {
    @F = split(' ');
    print sum @F, "\n";
}</pre><p>You can change auto-splitting’s default behavior by specifying an argument to the <code class="literal">-F</code> command-line switch. Say you have the following line:</p><a id="I_programlisting4_id304926"/><pre class="programlisting">1:2:3:4:5:6:7:8:9:10</pre><p>And you wish to find the sum of all these numbers. You can simply specify <code class="literal">:</code> as an argument to the <code class="literal">-F</code> switch, like this:</p><a id="I_programlisting4_id304942"/><pre class="programlisting">perl -MList::Util=sum -F: -alne 'print sum @F'</pre><p>This splits the line on the colon character and sums all the numbers. The output is <code class="literal">55</code> because that’s the sum of the numbers 1 through 10.</p></div><div class="sect1" title="4.3 Print the sum of all fields on all lines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_3_print_the_sum_of_all_fields_on_al">4.3 Print the sum of all fields on all lines</h2></div></div></div><a id="I_programlisting4_id304963"/><pre class="programlisting">perl -MList::Util=sum -alne 'push @S,@F; END { print sum @S }'</pre><p>This one-liner keeps pushing the split fields in <code class="literal">@F</code> to the <code class="literal">@S</code> array. Once the input stops and Perl is about to quit, the <code class="literal">END { }</code> block is executed and it outputs the sum of all items in <code class="literal">@S</code>. This sums all fields over all lines.</p><p>Notice how pushing the <code class="literal">@F</code> array to the <code class="literal">@S</code> array actually appends elements to it. This differs from many other languages, where pushing array1 to array2 would put array1 into array2, rather than appending the elements of array1 onto array2. Perl performs list flattening by design.</p><p>Unfortunately, summing all fields on all lines using this solution creates a massive <code class="literal">@S</code> array. A better solution is to keep only the running sum, like this:</p><a id="I_programlisting4_id305008"/><pre class="programlisting">perl -MList::Util=sum -alne '$s += sum @F; END { print $s }'</pre><p><a id="idx00012" class="indexterm"/><a id="idx00024" class="indexterm"/><a id="idx00151" class="indexterm"/><a id="idx00230" class="indexterm"/><a id="idx00232" class="indexterm"/><a id="idx00379" class="indexterm"/><a id="idx00404" class="indexterm"/><a id="idx00548" class="indexterm"/><a id="idx00582" class="indexterm"/><a id="idx00635" class="indexterm"/><a id="idx00673" class="indexterm"/>Here, each line is split into <code class="literal">@F</code> and the values are summed and stored in the running sum variable <code class="literal">$s</code>. Once all input has been processed, the one-liner prints the value of <code class="literal">$s</code>.</p></div><div class="sect1" title="4.4 Shuffle all fields on each line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_4_shuffle_all_fields_on_each_line">4.4 Shuffle all fields on each line</h2></div></div></div><a id="I_programlisting4_id305120"/><pre class="programlisting">perl -MList::Util=shuffle -alne 'print "@{[shuffle @F]}"'</pre><p>The trickiest part of this one-liner is the <code class="literal">@{[shuffle @F]}</code> construction. This construction allows you to execute the code inside the quotation marks. Normally text and variables are placed inside quotation marks, but with the <code class="literal">@{[ ... ]}</code> construction you can run code, too.</p><p>In this one-liner, the code to execute inside of the quotation marks is <code class="literal">shuffle @F</code>, which shuffles the fields and returns the shuffled list. The <code class="literal">[shuffle @F]</code> creates an array reference containing the shuffled fields, and the <code class="literal">@{ ... }</code> dereferences it. You simply create a reference and immediately dereference it. This allows you to run the code inside the quotation marks.</p><p>Let’s look at several examples to understand why I chose to run the code inside the quotation marks. If I had written <code class="literal">print shuffle @F</code>, the fields on the line would be concatenated. Compare the output of this one-liner:</p><a id="I_programlisting4_id305163"/><pre class="programlisting">$ echo a b c d | perl -MList::Util=shuffle -alne 'print "@{[shuffle @F]}"'
b c d a</pre><p>to this:</p><a id="I_programlisting4_id305171"/><pre class="programlisting">$ echo a b c d | perl -MList::Util=shuffle -alne 'print shuffle @F'
bcda</pre><p>In the first example, the array of shuffled fields (inside the double quotation marks) is interpolated, and the array’s elements are separated by a space, so the output is <code class="literal">b c d a</code>. In the second example, interpolation doesn’t happen, and Perl simply dumps out element by element without separating them, and the output is <code class="literal">bcda</code>.</p><p>You can use the <code class="literal">$</code>, special variable to change the separator between array elements when they’re printed. For example, here’s what happens when I change the separator to a colon:</p><a id="I_programlisting4_id305198"/><pre class="programlisting">$ echo a b c d | perl -MList::Util=shuffle -alne '$,=":"; print shuffle @F'
b:c:d:a</pre><p><a id="idx00015" class="indexterm"/><a id="idx00094" class="indexterm"/><a id="idx00152" class="indexterm"/><a id="idx00195" class="indexterm"/><a id="idx00260" class="indexterm"/><a id="idx00330" class="indexterm"/><a id="idx00395" class="indexterm"/>You can also use the <code class="literal">join</code> function to join the elements of <code class="literal">@F</code> with a space:</p><a id="I_programlisting4_id305264"/><pre class="programlisting">perl -MList::Util=shuffle -alne 'print join " ", shuffle @F'</pre><p>Here, the <code class="literal">join</code> function joins the elements of an array using the given separator, but the <code class="literal">@{[ ... ]}</code> construction is the cleanest way to do it.</p></div><div class="sect1" title="4.5 Find the numerically smallest element (minimum element) on each line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_5_find_the_numerically_smallest_ele">4.5 Find the numerically smallest element (minimum element) on each line</h2></div></div></div><a id="I_programlisting4_id305290"/><pre class="programlisting">perl -MList::Util=min -alne 'print min @F'</pre><p>This one-liner is somewhat similar to the previous ones. It uses the <code class="literal">min</code> function from <code class="literal">List::Util</code>. Once the line has been automatically split by <code class="literal">-a</code> and the elements are in the <code class="literal">@F</code> array, the <code class="literal">min</code> function finds the numerically smallest element, which it prints.</p><p>For example, if you have a file that contains these lines:</p><a id="I_programlisting4_id305321"/><pre class="programlisting">-8  9  10 5
7   0  9  3
5  -25 9  999</pre><p>Running this one-liner produces the following output:</p><a id="I_programlisting4_id305329"/><pre class="programlisting">-8
0
-25</pre><p>The smallest number on the first line is <code class="literal">-8</code>; on the second line, the smallest number is <code class="literal">0</code>; and on the third line, <code class="literal">-25</code>.</p></div><div class="sect1" title="4.6 Find the numerically smallest element (minimum element) over all lines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_6_find_the_numerically_smallest_ele">4.6 Find the numerically smallest element (minimum element) over all lines</h2></div></div></div><a id="I_programlisting4_id305361"/><pre class="programlisting">perl -MList::Util=min -alne '@M = (@M, @F); END { print min @M }'</pre><p>This one-liner combines one-liners 4.3 and 4.5. The <code class="literal">@M = (@M, @F)</code> construct is the same as <code class="literal">push @M, @F</code>. It appends the contents of <code class="literal">@F</code> to the <code class="literal">@M</code> array.</p><p><a id="idx00040" class="indexterm"/><a id="idx00046" class="indexterm"/><a id="idx00173" class="indexterm"/><a id="idx00252" class="indexterm"/><a id="idx00383" class="indexterm"/><a id="idx00445" class="indexterm"/><a id="idx00450" class="indexterm"/><a id="idx00473" class="indexterm"/>This one-liner stores all data in memory, and if you run it on a really huge file, Perl will run out of memory. Your best bet is to find the smallest element on every line and compare that element with the smallest element on the previous line. If the element on the current line is less than the previous one, it’s the smallest element so far. Once all lines have been processed, you can just print the smallest element found through the <code class="literal">END</code> block:</p><a id="I_programlisting4_id305448"/><pre class="programlisting">perl -MList::Util=min -alne '
  $min = min @F;
  $rmin = $min unless defined $rmin &amp;&amp; $min &gt; $rmin;
  END { print $rmin }
'</pre><p>Here, you first find the minimum element on the current line and store it in <code class="literal">$min</code>. Then you check to see if the smallest element on the current line is the smallest element so far. If so, assign it to <code class="literal">$rmin</code>. Once you’ve looped over the whole input, the <code class="literal">END</code> block executes and you print the <code class="literal">$rmin</code>.</p><p>Say your file contains these lines:</p><a id="I_programlisting4_id305477"/><pre class="programlisting">-8  9  10 5
7   0  9  3
5  -25 9  999</pre><p>Running this one-liner outputs <code class="literal">-25</code> because that’s the smallest number in the file.</p><p>If you’re using Perl 5.10 or later, you can do the same thing with this one-liner:</p><a id="I_programlisting4_id305492"/><pre class="programlisting">perl -MList::Util=min -alne '$min = min($min // (), @F); END { print $min }'</pre><p>This one-liner uses the <code class="literal">//</code> operator, which is new to Perl 5.10. This operator is similar to the logical OR operator (<code class="literal">||</code>), except that it tests the left side’s definedness rather than the truth. What that means is it tests whether the left side is defined rather than whether it is true or false. In this one-liner, the expression <code class="literal">$min // ()</code> returns <code class="literal">$min</code> if <code class="literal">$min</code> has been defined, or else it returns an empty list <code class="literal">()</code>. The <code class="literal">//</code> operator saves you from having to use <code class="literal">defined</code> to test definedness.</p><p>Consider what happens when this one-liner is run on the previous file. First, Perl reads the line <code class="literal">-8  9  10  5</code>, splits it, and puts the numbers in the <code class="literal">@F</code> array. The <code class="literal">@F</code> array is now <code class="literal">(-8, 9, 10, 5)</code>. Next, it executes <code class="literal">$min = min ($min // (), @F)</code>. Because <code class="literal">$min</code> hasn’t been defined, <code class="literal">$min // ()</code> evaluates to <code class="literal">()</code>, so the whole expression becomes <code class="literal">$min = min ((), (-8, 9, 10, 5))</code>.</p><p><a id="idx00093" class="indexterm"/><a id="idx00194" class="indexterm"/><a id="idx00393" class="indexterm"/>Perl does list flattening by design, so after flattening the arguments to the <code class="literal">min</code> function, the expression becomes <code class="literal">$min = min(-8, 9, 10, 5)</code>. This defines <code class="literal">$min</code>, setting it to <code class="literal">-8</code>. Perl proceeds to the next line, where it sets <code class="literal">@F</code> to <code class="literal">(7, 0, 9, 3)</code> and again evaluates <code class="literal">$min = min($min // (), @F)</code>. Because <code class="literal">$min</code> has now been defined, <code class="literal">$min // ()</code> evaluates to <code class="literal">$min</code> and the expression becomes <code class="literal">$min = min(-8, 7, 0, 9, 3)</code>. At this point, <code class="literal">-8</code> is still the smallest element, so <code class="literal">$min</code> remains <code class="literal">-8</code>. Finally, Perl reads in the last line, and after evaluating <code class="literal">$min = min(-8, 5, -25, 9, 999)</code>, it finds that <code class="literal">-25</code> is the smallest element in the file.</p></div><div class="sect1" title="4.7 Find the numerically largest element (maximum element) on each line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_7_find_the_numerically_largest_elem">4.7 Find the numerically largest element (maximum element) on each line</h2></div></div></div><a id="I_programlisting4_id305669"/><pre class="programlisting">perl -MList::Util=max -alne 'print max @F'</pre><p>This works the same as one-liner 4.5, except that you replace <code class="literal">min</code> with <code class="literal">max</code>.</p></div><div class="sect1" title="4.8 Find the numerically largest element (maximum element) over all lines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_8_find_the_numerically_largest_elem">4.8 Find the numerically largest element (maximum element) over all lines</h2></div></div></div><a id="I_programlisting4_id305697"/><pre class="programlisting">perl -MList::Util=max -alne '@M = (@M, @F); END { print max @M }'</pre><p>This one-liner is similar to one-liners 4.6 and 4.7. In this one-liner, each line is auto-split and put in the <code class="literal">@F</code> array, and then this array is merged with the <code class="literal">@M</code> array. When the input has been processed, the <code class="literal">END</code> block executes and the maximum element is printed.</p><p>Here’s another way to find the maximum element, keeping just the running maximum element instead of all elements in memory:</p><a id="I_programlisting4_id305722"/><pre class="programlisting">perl -MList::Util=max -alne '
  $max = max @F;
  $rmax = $max unless defined $rmax &amp;&amp; $max &lt; $rmax;
  END { print $rmax }
'</pre><p>If you’re using Perl 5.10 or later, you can use the <code class="literal">//</code> operator to shorten this one-liner:</p><a id="I_programlisting4_id305734"/><pre class="programlisting">perl -MList::Util=max -alne '$max = max($max // (), @F); END { print $max }'</pre><p>This is the same as one-liner 4.6, except you replace <code class="literal">min</code> with <code class="literal">max</code>.</p></div><div class="sect1" title="4.9 Replace each field with its absolute value"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_9_replace_each_field_with_its_absol">4.9 Replace each field with its absolute value</h2></div></div></div><a id="I_programlisting4_id305759"/><pre class="programlisting">perl -alne 'print "@{[map { abs } @F]}"'</pre><p><a id="idx00017" class="indexterm"/><a id="idx00052" class="indexterm"/><a id="idx00086" class="indexterm"/><a id="idx00096" class="indexterm"/><a id="idx00193" class="indexterm"/><a id="idx00221" class="indexterm"/><a id="idx00227" class="indexterm"/><a id="idx00229" class="indexterm"/><a id="idx00249" class="indexterm"/><a id="idx00250" class="indexterm"/><a id="idx00267" class="indexterm"/><a id="idx00389" class="indexterm"/><a id="idx00420" class="indexterm"/><a id="idx00498" class="indexterm"/><a id="idx00629" class="indexterm"/><a id="idx00667" class="indexterm"/><a id="idx00668" class="indexterm"/>This one-liner first auto-splits the line using the <code class="literal">-a</code> option. The split fields end up in the <code class="literal">@F</code> variable. Next, it calls the absolute value function <code class="literal">abs</code> on each field with the help of the <code class="literal">map</code> function. Essentially, the <code class="literal">map</code> function applies a given function to each element of the list and returns a new list that contains the results of applying the function. For example, if the list <code class="literal">@F</code> is <code class="literal">(-4, 2, 0)</code>, mapping <code class="literal">abs</code> over it produces the list <code class="literal">(4, 2, 0)</code>. Finally, this one-liner prints the new list of positive values.</p><p>The <code class="literal">@{[ ... ]}</code> construct, introduced in one-liner 4.4, allows you to execute the code inside the quotation marks.</p></div><div class="sect1" title="4.10 Print the total number of fields on each line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_10_print_the_total_number_of_fields">4.10 Print the total number of fields on each line</h2></div></div></div><a id="I_programlisting4_id305955"/><pre class="programlisting">perl -alne 'print scalar @F'</pre><p>This one-liner forces the evaluation of <code class="literal">@F</code> in the scalar context, which in Perl means “the number of elements in <code class="literal">@F</code>.” As a result, it prints the number of elements on each line.</p><p>For example, if your file contains the following lines:</p><a id="I_programlisting4_id305974"/><pre class="programlisting">foo bar baz
foo bar
baz</pre><p>Running this one-liner produces the following output:</p><a id="I_programlisting4_id305982"/><pre class="programlisting">3
2
1</pre><p>The first line has three fields, the second line has two fields, and the last line has one field.</p></div><div class="sect1" title="4.11 Print the total number of fields on each line, followed by the line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_11_print_the_total_number_of_fields">4.11 Print the total number of fields on each line, followed by the line</h2></div></div></div><a id="I_programlisting4_id306000"/><pre class="programlisting">perl -alne 'print scalar @F, " $_"'</pre><p><a id="idx00352" class="indexterm"/><a id="idx00424" class="indexterm"/>This one-liner is the same as one-liner 4.10, with the addition of <code class="literal">$_</code> at the end, which prints the whole line. (Remember that <code class="literal">-n</code> puts each line in the <code class="literal">$_</code> variable.)</p><p>Let’s run this one-liner on the same example file that I used in one-liner 4.10:</p><a id="I_programlisting4_id306043"/><pre class="programlisting">foo bar baz
foo bar
baz</pre><p>Running the one-liner produces the following output:</p><a id="I_programlisting4_id306050"/><pre class="programlisting">3 foo bar baz
2 foo bar
1 baz</pre></div><div class="sect1" title="4.12 Print the total number of fields on all lines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_12_print_the_total_number_of_fields">4.12 Print the total number of fields on all lines</h2></div></div></div><a id="I_programlisting4_id306065"/><pre class="programlisting">perl -alne '$t += @F; END { print $t }'</pre><p>Here, the one-liner keeps adding the number of fields on each line to variable <code class="literal">$t</code> until all lines have been processed. Next, it prints the result, which contains the number of words on all lines. Notice that you add the <code class="literal">@F</code> array to the scalar variable <code class="literal">$t</code>. Because <code class="literal">$t</code> is scalar, the <code class="literal">@F</code> array is evaluated in the scalar context and returns the number of elements it contains.</p><p>Running this one-liner on the following file:</p><a id="I_programlisting4_id306096"/><pre class="programlisting">foo bar baz
foo bar
baz</pre><p>produces the number <code class="literal">6</code> as output because the file contains a total of six words.</p></div><div class="sect1" title="4.13 Print the total number of fields that match a pattern"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_13_print_the_total_number_of_fields">4.13 Print the total number of fields that match a pattern</h2></div></div></div><a id="I_programlisting4_id306120"/><pre class="programlisting">perl -alne 'map { /<span class="emphasis"><em>regex</em></span>/ &amp;&amp; $t++ } @F; END { print $t || 0 }'</pre><p><a id="idx00035" class="indexterm"/><a id="idx00098" class="indexterm"/><a id="idx00155" class="indexterm"/><a id="idx00350" class="indexterm"/><a id="idx00422" class="indexterm"/><a id="idx00510" class="indexterm"/><a id="idx00531" class="indexterm"/>This one-liner uses <code class="literal">map</code> to apply an operation to each element in the <code class="literal">@F</code> array. In this example, the operation checks to see if each element matches <code class="literal">/regex/</code>, and if it does, it increments the <code class="literal">$t</code> variable. It then prints the <code class="literal">$t</code> variable, which contains the number of fields that match the <code class="literal">/regex/</code> pattern. The <code class="literal">$t || 0</code> construct is necessary because if no fields match, <code class="literal">$t</code> wouldn’t exist, so you must provide a default value. Instead of <code class="literal">0</code>, you can provide any other default value, even a string!</p><p>Looping would be a better approach:</p><a id="I_programlisting4_id306234"/><pre class="programlisting">perl -alne '$t += /<span class="emphasis"><em>regex</em></span>/ for @F; END { print $t }'</pre><p>Here, each element in <code class="literal">@F</code> is tested against <code class="literal">/regex/</code>. If it matches, <code class="literal">/regex/</code> returns true; otherwise it returns false. When used numerically, true converts to <code class="literal">1</code> and false converts to <code class="literal">0</code>, so <code class="literal">$t += /regex/</code> adds either <code class="literal">1</code> or <code class="literal">0</code> to the <code class="literal">$t</code> variable. As a result, the number of matches is counted in <code class="literal">$t</code>. You do not need a default value when printing the result in the <code class="literal">END</code> block because the <code class="literal">+=</code> operator is run regardless of whether the field matches. You will always get a value, and sometimes that value will be <code class="literal">0</code>.</p><p>Another way to do this is to use <code class="literal">grep</code> in the scalar context:</p><a id="I_programlisting4_id306305"/><pre class="programlisting">perl -alne '$t += grep /<span class="emphasis"><em>regex</em></span>/, @F; END { print $t }'</pre><p>Here, <code class="literal">grep</code> returns the number of matches because it’s evaluated in the scalar context. In the list context, <code class="literal">grep</code> returns all matching elements, but in the scalar context, it returns the number of matching elements. This number is accumulated in <code class="literal">$t</code> and printed in the <code class="literal">END</code> block. In this case, you don’t need to provide a default value for <code class="literal">$t</code> because <code class="literal">grep</code> returns <code class="literal">0</code> in those situations.</p></div><div class="sect1" title="4.14 Print the total number of lines that match a pattern"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_14_print_the_total_number_of_lines">4.14 Print the total number of lines that match a pattern</h2></div></div></div><a id="I_programlisting4_id306353"/><pre class="programlisting">perl -lne '/<span class="emphasis"><em>regex</em></span>/ &amp;&amp; $t++; END { print $t || 0 }'</pre><p>Here, <code class="literal">/regex/</code> evaluates to true if the current line of input matches this regular expression. Writing <code class="literal">/regex/ &amp;&amp; $t++</code> is the same as writing <code class="literal">if ($_ =~ /regex/) { $t++ }</code>, which increments the <code class="literal">$t</code> variable if the line matches the specified pattern. In the <code class="literal">END</code> block, the <code class="literal">$t</code> variable contains the total number of pattern matches and is printed; but if no lines match, <code class="literal">$t</code> is once again undefined, so you must print a default value.</p></div><div class="sect1" title="4.15 Print the number π"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_15_print_the_number">4.15 Print the number π</h2></div></div></div><a id="I_programlisting4_id306405"/><pre class="programlisting">perl -Mbignum=bpi -le 'print bpi(21)'</pre><p><a id="idx00006" class="indexterm"/><a id="idx00007" class="indexterm"/><a id="idx00082" class="indexterm"/><a id="idx00088" class="indexterm"/><a id="idx00101" class="indexterm"/><a id="idx00149" class="indexterm"/><a id="idx00150" class="indexterm"/><a id="idx00190" class="indexterm"/><a id="idx00205" class="indexterm"/><a id="idx00278" class="indexterm"/><a id="idx00285" class="indexterm"/><a id="idx00398" class="indexterm"/><a id="idx00426" class="indexterm"/><a id="idx00492" class="indexterm"/><a id="idx00601" class="indexterm"/><a id="idx00602" class="indexterm"/><a id="idx00614" class="indexterm"/>The <code class="literal">bignum</code> package exports the <code class="literal">bpi</code> function that calculates the π constant to the desired accuracy. This one-liner prints π to 20 decimal places. (Notice that you need to specify <code class="literal">n+1</code> to print it to an accuracy of <code class="literal">n</code>.)</p><p>The <code class="literal">bignum</code> library also exports the constant π, precomputed to 39 decimal places:</p><a id="I_programlisting4_id306569"/><pre class="programlisting">perl -Mbignum=PI -le 'print PI'</pre></div><div class="sect1" title="4.16 Print the number e"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_16_print_the_number_e">4.16 Print the number <span class="emphasis"><em>e</em></span></h2></div></div></div><a id="I_programlisting4_id306585"/><pre class="programlisting">perl -Mbignum=bexp -le 'print bexp(1,21)'</pre><p>The <code class="literal">bignum</code> library exports the <code class="literal">bexp</code> function, which takes two arguments: the power to raise <span class="emphasis"><em>e</em></span> to, and the desired accuracy. This one-liner prints the constant <span class="emphasis"><em>e</em></span> to 20 decimal places.</p><p>For example, you could print the value of <span class="emphasis"><em>e</em></span><sup>2</sup> to 30 decimal places:</p><a id="I_programlisting4_id306618"/><pre class="programlisting">perl -Mbignum=bexp -le 'print bexp(2,31)'</pre><p>As with π, <code class="literal">bignum</code> also exports the constant <span class="emphasis"><em>e</em></span> precomputed to 39 decimal places:</p><a id="I_programlisting4_id306634"/><pre class="programlisting">perl -Mbignum=e -le 'print e'</pre></div><div class="sect1" title="4.17 Print UNIX time (seconds since January 1, 1970, 00:00:00 UTC)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_17_print_unix_time_seconds_since_ja">4.17 Print UNIX time (seconds since January 1, 1970, 00:00:00 UTC)</h2></div></div></div><a id="I_programlisting4_id306647"/><pre class="programlisting">perl -le 'print time'</pre><p>The built-in <code class="literal">time</code> function returns seconds since the epoch. This one-liner simply prints the time.</p></div><div class="sect1" title="4.18 Print Greenwich Mean Time and local computer time"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_18_print_greenwich_mean_time_and_lo">4.18 Print Greenwich Mean Time and local computer time</h2></div></div></div><a id="I_programlisting4_id306672"/><pre class="programlisting">perl -le 'print scalar gmtime'</pre><p><a id="idx00167" class="indexterm"/><a id="idx00255" class="indexterm"/><a id="idx00265" class="indexterm"/><a id="idx00294" class="indexterm"/><a id="idx00295" class="indexterm"/><a id="idx00298" class="indexterm"/><a id="idx00377" class="indexterm"/><a id="idx00380" class="indexterm"/><a id="idx00381" class="indexterm"/><a id="idx00549" class="indexterm"/><a id="idx00597" class="indexterm"/><a id="idx00599" class="indexterm"/><a id="idx00600" class="indexterm"/>The <code class="literal">gmtime</code> function is a built-in Perl function. When used in the scalar context, it returns the time localized to Greenwich Mean Time (GMT).</p><p>The built-in <code class="literal">localtime</code> function acts like <code class="literal">gmtime</code>, except it returns the computer’s local time when it’s used in the scalar context:</p><a id="I_programlisting4_id306784"/><pre class="programlisting">perl -le 'print scalar localtime'</pre><p>In the list context, both <code class="literal">gmtime</code> and <code class="literal">localtime</code> return a nine-element list (known as <code class="literal">struct tm</code> to UNIX programmers) with the following elements:</p><a id="I_programlisting4_id306804"/><pre class="programlisting">($second,             [0]
$minute,              [1]
$hour,                [2]
$month_day,           [3]
$month,               [4]
$year,                [5]
$week_day,            [6]
$year_day,            [7]
$is_daylight_saving   [8]
)</pre><p>You can <span class="emphasis"><em>slice</em></span> this list (that is, extract elements from it) or print individual elements if you need just some part of the information it contains. For example, to print <code class="literal">H:M:S</code>, slice the elements <code class="literal">2</code>, <code class="literal">1</code>, and <code class="literal">0</code> from <code class="literal">localtime</code>, like this:</p><a id="I_programlisting4_id306837"/><pre class="programlisting">perl -le 'print join ":", (localtime)[2,1,0]'</pre><p>To slice elements individually, specify a list of elements to extract, for instance <code class="literal">[2,1,0]</code>. Or slice them as a range:</p><a id="I_programlisting4_id306849"/><pre class="programlisting">perl -le 'print join ":", (localtime)[2..6]'</pre><p>This one-liner prints the hour, date, month, year, and day of the week.</p><p>You can also use negative indexes to select elements from the opposite end of a list:</p><a id="I_programlisting4_id306861"/><pre class="programlisting">perl -le 'print join ":", (localtime)[-2, -3]'</pre><p>This one-liner prints elements <code class="literal">7</code> and <code class="literal">6</code>, which are the day of the year (for example, the 200th day) and of the week (for example, the 4th day), respectively.</p></div><div class="sect1" title="4.19 Print yesterday’s date"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_19_print_yesterdays_date">4.19 Print yesterday’s date</h2></div></div></div><a id="I_programlisting4_id306886"/><pre class="programlisting">perl -MPOSIX -le '
  @now = localtime;
  $now[3] -= 1;
  print scalar localtime mktime @now
'</pre><p><a id="idx00089" class="indexterm"/><a id="idx00168" class="indexterm"/><a id="idx00225" class="indexterm"/><a id="idx00266" class="indexterm"/><a id="idx00269" class="indexterm"/><a id="idx00382" class="indexterm"/><a id="idx00392" class="indexterm"/><a id="idx00396" class="indexterm"/><a id="idx00405" class="indexterm"/><a id="idx00407" class="indexterm"/><a id="idx00411" class="indexterm"/><a id="idx00493" class="indexterm"/><a id="idx00598" class="indexterm"/><a id="idx00678" class="indexterm"/>Remember that <code class="literal">localtime</code> returns a nine-item list (see one-liner 4.18) of various date elements. The fourth element in the list is the current month’s day. If you subtract 1 from this element, you get yesterday.</p><p>The <code class="literal">mktime</code> function constructs the UNIX epoch time from this modified nine-element list, and the <code class="literal">scalar localtime</code> construct prints the new date, which is yesterday. This one-liner also works in edge cases, such as when the current day is the first day of the month. You need the <code class="literal">POSIX</code> package because it exports the <code class="literal">mktime</code> function.</p><p>For example, if it’s <span class="emphasis"><em>Mon May 20 05:49:55</em></span> right now, running this one-liner prints <span class="emphasis"><em>Sun May 19 05:49:55</em></span>.</p></div><div class="sect1" title="4.20 Print the date 14 months, 9 days, and 7 seconds ago"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_20_print_the_date_14_months_9_days">4.20 Print the date 14 months, 9 days, and 7 seconds ago</h2></div></div></div><a id="I_programlisting4_id307035"/><pre class="programlisting">perl -MPOSIX -le '
  @now = localtime;
  $now[0] -= 7;
  $now[3] -= 9;
  $now[4] -= 14;
  print scalar localtime mktime @now
'</pre><p>This one-liner modifies the first, fourth, and fifth elements of the <code class="literal">@now</code> list. The first element is seconds, the fourth is days, and the fifth is months. The <code class="literal">mktime</code> command generates the UNIX time from this new structure, and <code class="literal">localtime</code>, which is evaluated in the scalar context, prints the date 14 months, 9 days, and 7 seconds ago.</p></div><div class="sect1" title="4.21 Calculate the factorial"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_21_calculate_the_factorial">4.21 Calculate the factorial</h2></div></div></div><a id="I_programlisting4_id307069"/><pre class="programlisting">perl -MMath::BigInt -le 'print Math::BigInt-&gt;new(5)-&gt;bfac()'</pre><p>This one-liner uses the <code class="literal">bfac()</code> function from the <code class="literal">Math::BigInt</code> module in the Perl core. (In other words, you don’t need to install it.) The <code class="literal">Math::BigInt-&gt;new(5)</code> construction creates a new <code class="literal">Math::BigInt</code> object with a value of <code class="literal">5</code>, after which the <code class="literal">bfac()</code> method is called on the newly created object to calculate the factorial of <code class="literal">5</code>. Change <code class="literal">5</code> to any number you wish to find its factorial.</p><p><a id="idx00090" class="indexterm"/><a id="idx00218" class="indexterm"/><a id="idx00283" class="indexterm"/><a id="idx00297" class="indexterm"/>Another way to calculate a factorial is to multiply the numbers from 1 to <span class="emphasis"><em>n</em></span> together:</p><a id="I_programlisting4_id307142"/><pre class="programlisting">perl -le '$f = 1; $f *= $_ for 1..5; print $f'</pre><p>Here, I set <code class="literal">$f</code> to <code class="literal">1</code> and then loop from <code class="literal">1</code> to <code class="literal">5</code> and multiply <code class="literal">$f</code> by each value. The result is <code class="literal">120</code> (<code class="literal">1*2*3*4*5</code>), the factorial of <code class="literal">5</code>.</p></div><div class="sect1" title="4.22 Calculate the greatest common divisor"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_22_calculate_the_greatest_common_di">4.22 Calculate the greatest common divisor</h2></div></div></div><a id="I_programlisting4_id307192"/><pre class="programlisting">perl -MMath::BigInt=bgcd -le 'print bgcd(@list_of_numbers)'</pre><p><code class="literal">Math::BigInt</code> has several other useful math functions including <code class="literal">bgcd</code>, which calculates the <span class="emphasis"><em>greatest common divisor (gcd)</em></span> of a list of numbers. For example, to find the greatest common divisor of <code class="literal">(20, 60, 30)</code>, execute the one-liner like this:</p><a id="I_programlisting4_id307214"/><pre class="programlisting">perl -MMath::BigInt=bgcd -le 'print bgcd(20,60,30)'</pre><p>To calculate the gcd from a file or user’s input, use the <code class="literal">-a</code> command-line argument and pass the <code class="literal">@F</code> array to the <code class="literal">bgcd</code> function:</p><a id="I_programlisting4_id307233"/><pre class="programlisting">perl -MMath::BigInt=bgcd -anle 'print bgcd(@F)'</pre><p>(I explained the <code class="literal">-a</code> argument and the <code class="literal">@F</code> array in one-liner 4.2 on page 30.)</p><p>You could also use Euclid’s algorithm to find the gcd of <code class="literal">$n</code> and <code class="literal">$m</code>. This one-liner does just that and stores the result in <code class="literal">$m</code>:</p><a id="I_programlisting4_id307264"/><pre class="programlisting">perl -le '
  $n = 20; $m = 35;
  ($m,$n) = ($n,$m%$n) while $n;
  print $m
'</pre><p>Euclid’s algorithm is one of the oldest algorithms for finding the gcd.</p></div><div class="sect1" title="4.23 Calculate the least common multiple"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_23_calculate_the_least_common_multi">4.23 Calculate the least common multiple</h2></div></div></div><p><a id="idx00092" class="indexterm"/><a id="idx00274" class="indexterm"/><a id="idx00288" class="indexterm"/><a id="idx00336" class="indexterm"/><a id="idx00337" class="indexterm"/><a id="idx00429" class="indexterm"/><a id="idx00517" class="indexterm"/><a id="idx00519" class="indexterm"/>The <span class="emphasis"><em>least common multiple (lcm)</em></span> function, <code class="literal">blcm</code>, is included in <code class="literal">Math::BigInt</code>. Use this one-liner to find the least common multiple of <code class="literal">(35, 20, 8)</code>:</p><a id="I_programlisting4_id307362"/><pre class="programlisting">perl -MMath::BigInt=blcm -le 'print blcm(35,20,8)'</pre><p>To find the lcm from a file with numbers, use the <code class="literal">-a</code> command-line switch and the <code class="literal">@F</code> array:</p><a id="I_programlisting4_id307377"/><pre class="programlisting">perl -MMath::BigInt=blcm -anle 'print blcm(@F)'</pre><p>If you know a bit of number theory, you may recall that there is a connection between the gcd and the lcm. Given two numbers <code class="literal">$n</code> and <code class="literal">$m</code>, you know that their lcm is <code class="literal">$n*$m/gcd($n,$m)</code>. This one-liner, therefore, follows:</p><a id="I_programlisting4_id307397"/><pre class="programlisting">perl -le '
  $a = $n = 20;
  $b = $m = 35;
  ($m,$n) = ($n,$m%$n) while $n;
  print $a*$b/$m
'</pre></div><div class="sect1" title="4.24 Generate 10 random numbers between 5 and 15 (excluding 15)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_24_generate_10_random_numbers_betwe">4.24 Generate 10 random numbers between 5 and 15 (excluding 15)</h2></div></div></div><a id="I_programlisting4_id307412"/><pre class="programlisting">perl -le 'print join ",", map { int(rand(15-5))+5 } 1..10'</pre><p>This one-liner prints 10 random numbers between 5 and 15. It may look complicated, but it’s actually simple. <code class="literal">int(rand(15-5))</code> is just <code class="literal">int(rand(10))</code>, which returns a random integer from 0 to 9. Adding <code class="literal">5</code> to it makes it return a random integer from 5 to 14. The range <code class="literal">1..10</code> makes it draw 10 random integers.</p><p>You can also write this one-liner more verbosely:</p><a id="I_programlisting4_id307440"/><pre class="programlisting">perl -le '
  $n=10;
  $min=5;
  $max=15;
  $, = " ";
  print map { int(rand($max-$min))+$min } 1..$n;
'</pre><p><a id="idx00064" class="indexterm"/><a id="idx00100" class="indexterm"/><a id="idx00290" class="indexterm"/><a id="idx00375" class="indexterm"/><a id="idx00397" class="indexterm"/><a id="idx00491" class="indexterm"/>Here, all variables are more explicit. To modify this one-liner, change the variables <code class="literal">$n</code>, <code class="literal">$min</code>, and <code class="literal">$max</code>. The <code class="literal">$n</code> variable represents how many random numbers to generate, and <code class="literal">$min-$max</code> is the range of numbers for use in that generation.</p><p>The <code class="literal">$</code>, variable is set to a space because it’s the output field separator for <code class="literal">print</code> and it’s <code class="literal">undef</code> by default. If you didn’t set <code class="literal">$</code>, to a space, the numbers would be printed concatenated. (See one-liner 4.4 on page 32 for a discussion of <code class="literal">$</code>,.)</p></div><div class="sect1" title="4.25 Generate all permutations of a list"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_25_generate_all_permutations_of_a_l">4.25 Generate all permutations of a list</h2></div></div></div><a id="I_programlisting4_id307546"/><pre class="programlisting">perl -MAlgorithm::Permute -le '
  $l = [1,2,3,4,5];
  $p = Algorithm::Permute-&gt;new($l);
  print "@r" while @r = $p-&gt;next
'</pre><p>This one-liner uses the object-oriented interface of the module <code class="literal">Algorithm::Permute</code> to find all permutations of a list, that is, all ways to rearrange items. The constructor of <code class="literal">Algorithm::Permute</code> takes an array reference of elements to permute. In this particular one-liner, the elements are the numbers <code class="literal">1, 2, 3, 4, 5</code>.</p><p>The <code class="literal">next</code> method returns the next permutation. Calling it repeatedly iterates over all permutations, and each permutation is put in the <code class="literal">@r</code> array and then printed. (Beware: The output list gets large really quickly. There are <code class="literal">n!</code> (<span class="emphasis"><em>n</em></span> factorial) permutations for a list of <code class="literal">n</code> elements.)</p><p>Another way to print all permutations is with the <code class="literal">permute</code> subroutine:</p><a id="I_programlisting4_id307601"/><pre class="programlisting">perl -MAlgorithm::Permute -le '
  @l = (1,2,3,4,5);
  Algorithm::Permute::permute { print "@l" } @l
'</pre><p>Here’s what you get if you change <code class="literal">@l</code> to just three elements <code class="literal">(1, 2, 3)</code> and run it:</p><a id="I_programlisting4_id307616"/><pre class="programlisting">1 2 3
1 3 2
3 1 2
2 1 3
2 3 1
3 2 1</pre></div><div class="sect1" title="4.26 Generate the powerset"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_26_generate_the_powerset">4.26 Generate the powerset</h2></div></div></div><a id="I_programlisting4_id307630"/><pre class="programlisting">perl -MList::PowerSet=powerset -le '
  @l = (1,2,3,4,5);
  print "@$_" for @{powerset(@l)}
'</pre><p><a id="idx00061" class="indexterm"/><a id="idx00070" class="indexterm"/><a id="idx00102" class="indexterm"/><a id="idx00160" class="indexterm"/><a id="idx00291" class="indexterm"/><a id="idx00322" class="indexterm"/><a id="idx00325" class="indexterm"/><a id="idx00367" class="indexterm"/><a id="idx00376" class="indexterm"/><a id="idx00402" class="indexterm"/><a id="idx00494" class="indexterm"/><a id="idx00618" class="indexterm"/>This one-liner uses the <code class="literal">List::PowerSet</code> module from CPAN. The module exports the <code class="literal">powerset</code> function, which takes a list of elements and returns a reference to an array containing references to subset arrays. You can install this module by running <code class="literal">cpan List::PowerSet</code> at the command line.</p><p>In the <code class="literal">for</code> loop, you call the <code class="literal">powerset</code> function and pass it the list of elements of <code class="literal">@l</code>. Next, you dereference the return value of <code class="literal">powerset</code>, which is a reference to an array of subsets, and then dereference each individual subset <code class="literal">@$_</code> and print it.</p><p>The <span class="emphasis"><em>powerset</em></span> is the set of all subsets. For a set of <span class="emphasis"><em>n</em></span> elements, there are exactly 2<sup><span class="emphasis"><em>n</em></span></sup> subsets in the powerset. Here’s an example of the powerset of <code class="literal">(1, 2, 3)</code>:</p><a id="I_programlisting4_id307792"/><pre class="programlisting">1 2 3
2 3
1 3
3
1 2
2
1</pre></div><div class="sect1" title="4.27 Convert an IP address to an unsigned integer"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_27_convert_an_ip_address_to_an_unsi">4.27 Convert an IP address to an unsigned integer</h2></div></div></div><a id="I_programlisting4_id307808"/><pre class="programlisting">perl -le '
  $i=3;
  $u += ($_&lt;&lt;8*$i--) for "127.0.0.1" =~ /(\d+)/g;
  print $u
'</pre><p>This one-liner converts the IP address <code class="literal">127.0.0.1</code> into an unsigned integer by first doing a global match of <code class="literal">(\d+)</code> on the IP address. Performing a <code class="literal">for</code> loop over a global match iterates over all the matches, which are the four parts of the IP address: <code class="literal">127</code>, <code class="literal">0</code>, <code class="literal">0</code>, <code class="literal">1</code>.</p><p><a id="idx00258" class="indexterm"/><a id="idx00281" class="indexterm"/><a id="idx00302" class="indexterm"/><a id="idx00318" class="indexterm"/><a id="idx00409" class="indexterm"/><a id="idx00454" class="indexterm"/><a id="idx00552" class="indexterm"/><a id="idx00616" class="indexterm"/>Next, the matches are summed in the <code class="literal">$u</code> variable. The first bit is shifted 8 × 3 = 24 places, the second is shifted 8 × 2 = 16 places, and the third is shifted 8 places. The last is simply added to <code class="literal">$u</code>. The resulting integer happens to be <code class="literal">2130706433</code> (a very geeky number).</p><p>Here are some more one-liners:</p><a id="I_programlisting4_id307918"/><pre class="programlisting">perl -le '
  $ip="127.0.0.1";
  $ip =~ s/(\d+)\.?/sprintf("%02x", $1)/ge;
  print hex($ip)
'</pre><p>This one-liner utilizes the fact that <code class="literal">127.0.0.1</code> can be easily converted to hex. Here, the <code class="literal">$ip</code> is matched against <code class="literal">(\d+)</code>, and each IP part is transformed into a hex number with <code class="literal">sprintf("%02x", $1)</code> inside the <code class="literal">s</code> operator. The <code class="literal">/e</code> flag of the <code class="literal">s</code> operator makes it evaluate the substitution part as a Perl expression. As a result, <code class="literal">127.0.0.1</code> is transformed into <code class="literal">7f000001</code> and then interpreted as a hexadecimal number by Perl’s <code class="literal">hex</code> operator, which converts it to a decimal number.</p><p>You can also use <code class="literal">unpack</code>:</p><a id="I_programlisting4_id307973"/><pre class="programlisting">perl -le 'print unpack("N", 127.0.0.1)'</pre><p>This one-liner is probably as short as possible. It uses <span class="emphasis"><em>vstring literals</em></span> (version strings) to express the IP address. A vstring forms a string literal composed of characters with the specified ordinal values. The newly formed string literal is unpacked into a number from a string in network byte order (big-endian order) and then printed.</p><p>If you have a string with an IP (rather than a vstring), you first have to convert it to byte form with the function <code class="literal">inet_aton</code>:</p><a id="I_programlisting4_id307995"/><pre class="programlisting">perl -MSocket -le 'print unpack("N", inet_aton("127.0.0.1"))'</pre><p>Here, <code class="literal">inet_aton</code> converts the string <code class="literal">127.0.0.1</code> to the byte form (equivalent to the pure vstring <code class="literal">127.0.0.1</code>) and then <code class="literal">unpack</code> unpacks it, as in the previous one-liner.</p></div><div class="sect1" title="4.28 Convert an unsigned integer to an IP address"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="four_28_convert_an_unsigned_integer_to_a">4.28 Convert an unsigned integer to an IP address</h2></div></div></div><a id="I_programlisting4_id308029"/><pre class="programlisting">perl -MSocket -le 'print inet_ntoa(pack("N", 2130706433))'</pre><p><a id="idx00259" class="indexterm"/><a id="idx00270" class="indexterm"/><a id="idx00319" class="indexterm"/><a id="idx00326" class="indexterm"/><a id="idx00479" class="indexterm"/>Here, the integer <code class="literal">2130706433</code> is packed into a number in big-endian byte order and then passed to the <code class="literal">inet_ntoa</code> function that converts a number back to an IP address. (Notice that <code class="literal">inet_ntoa</code> is the opposite of <code class="literal">inet_aton</code>.)</p><p>You can do the same thing like this:</p><a id="I_programlisting4_id308094"/><pre class="programlisting">perl -le '
  $ip = 2130706433;
  print join ".", map { (($ip&gt;&gt;8*($_))&amp;0xFF) } reverse 0..3
'</pre><p>Here, the <code class="literal">$ip</code> is shifted 24 bits to the right and then bitwise ANDed with <code class="literal">0xFF</code> to produce the first part of the IP, which is <code class="literal">127</code>. Next, it’s shifted 16 bits and bitwise ANDed with <code class="literal">0xFF</code>, producing <code class="literal">0</code>, and then shifted 8 bits and bitwise ANDed with <code class="literal">0xFF</code>, producing another <code class="literal">0</code>. Finally, the whole number is bitwise ANDed with <code class="literal">0xFF</code>, producing <code class="literal">1</code>.</p><p>The result from <code class="literal">map { ... }</code> is a list <code class="literal">(127, 0, 0, 1)</code>. That list is now <code class="literal">join</code>ed by a dot <code class="literal">"."</code> to produce the IP address <code class="literal">127.0.0.1</code>.</p><p>You can replace <code class="literal">join</code> with the special variable <code class="literal">$</code>,, which acts as a value separator for the <code class="literal">print</code> statement:</p><a id="I_programlisting4_id308176"/><pre class="programlisting">perl -le '
  $ip = 2130706433;
  $, = ".";
  print map { (($ip&gt;&gt;8*($_))&amp;0xFF) } reverse 0..3
'</pre><p>Because <code class="literal">reverse 0..3</code> is the same as <code class="literal">3,2,1,0</code>, you could also write:</p><a id="I_programlisting4_id308192"/><pre class="programlisting">perl -le '
  $ip = 2130706433;
  $, = ".";
  print map { (($ip&gt;&gt;8*($_))&amp;0xFF) } 3,2,1,0
'</pre></div></section></body></html>