- en: '**16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**16**'
- en: CUSTOMIZING SOFTWARE WITH PORTS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用端口定制软件**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Packages provide the most common configurations of the most desirable programs.
    If you’re building a generic web server, chances are that the official FreeBSD
    package of nginx or lighttpd or whatever your preferred web server is will suffice.
    If you have a special environment or less common needs, that’s where the Ports
    Collection comes in. The Ports Collection is a tool for easily building customized
    versions of many software packages. It combines dependency, licensing, maintainer,
    and all other software information in a standard machine- and human-readable format.
    Ports let you set system options like “forbid third-party GPL-licensed code” (useful
    for embedded vendors), “add LDAP to everything,” or “disable X11.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了最常见配置的最受欢迎的程序。如果你要构建一个通用的web服务器，官方的FreeBSD包，如nginx或lighttpd，或是你偏好的任何web服务器应该就足够了。如果你有一个特殊的环境或更少见的需求，那么Ports
    Collection（端口集合）就派上用场了。Ports Collection是一个可以轻松构建许多软件包定制版本的工具。它将依赖关系、许可证、维护者和所有其他软件信息结合成一个既适合机器处理也适合人类阅读的标准格式。通过端口，你可以设置一些系统选项，比如“禁止第三方GPL许可证代码”（对嵌入式供应商有用）、“为所有软件添加LDAP”或者“禁用X11”。
- en: In the long term, ports are best managed with the poudriere package-building
    system. Before you can use poudriere, though, you must understand how ports work.
    I’d encourage you to explore ports on a test system. Rather than deploying ports
    on your individual servers, though, use poudriere to build your own package repository.
    Manage your servers entirely with packages. Never use the ports tree on a production
    server other than your package builder.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，端口最好通过poudriere包构建系统来管理。然而，在你能够使用poudriere之前，必须了解端口是如何工作的。我鼓励你在测试系统上探索端口。但与其将端口部署到每台单独的服务器上，不如使用poudriere来构建你自己的包存储库。完全通过包来管理你的服务器。除非是你的包构建器，否则永远不要在生产服务器上使用端口树。
- en: Before we dive into ports, let’s talk about building software in general.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论端口之前，让我们先聊聊软件构建的基本概念。
- en: '**Making Software**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**制作软件**'
- en: Traditional software building is complicated because source code must be processed
    very specifically to create a workable, running program—let alone one that works
    well! It’s a completely different process than using, say, a JavaScript compiler.
    While programmers could include installation instructions with each program, full
    of lines like `Now type ar cru .libs/lib20_zlib_``plugin.a istream-zlib.o zlib-plugin.o`,
    this would be downright sadistic. While Unix admins might seem to approve of sadism,
    they categorically disapprove of cruelty directed at themselves; if something
    can be automated, it will be.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的软件构建非常复杂，因为源代码必须被非常具体地处理，才能创建一个可运行的程序——更不用说一个运行良好的程序了！这与使用，比如说，JavaScript编译器的过程完全不同。尽管程序员可以为每个程序提供安装说明，里面充满了像`Now
    type ar cru .libs/lib20_zlib_``plugin.a istream-zlib.o zlib-plugin.o`这样的指令，但这简直是出于极端恶意的设计。虽然Unix管理员似乎会批准这种恶作剧，但他们对对自己施加的残酷行为是坚决反对的；如果可以自动化，那就一定会自动化。
- en: The main tool for building software is make(1). When run, make looks in the
    current directory for a file called *Makefile*, which is full of instructions
    much like that horrid example in the previous paragraph. It reads the instructions
    and carries them out, automating the installation process no matter how complicated
    it might be. You don’t really have to know the internals of a *Makefile*, so we’re
    not going to dissect one.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件的主要工具是make(1)。当运行make时，它会在当前目录中查找一个名为*Makefile*的文件，里面充满了类似于前面段落中那个可怕示例的指令。它读取这些指令并执行，自动化安装过程，无论过程多么复杂。你其实不需要了解*Makefile*的内部细节，因此我们不会对它进行详细分析。
- en: Each *Makefile* includes one or more *targets*, or sets of instructions to carry
    out. For example, typing `make install` tells make(1) to check the *Makefile*
    for a target called *install* and, if found, execute it. A target’s name usually
    relates to the process to be carried out, so you can safely assume that `make
    install` installs the software. You’ll find targets to install, configure, and
    uninstall most software. make(1) handles a huge variety of functions, some of
    which far outstrip the creators’ original intents. But that’s part of the fun
    of Unix!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个*Makefile*都包含一个或多个*targets*，或者说是一组需要执行的指令。例如，输入`make install`指示make(1)查找名为*install*的目标，并在找到时执行它。目标的名称通常与要执行的过程相关，因此你可以放心地认为`make
    install`会安装软件。你会发现有许多目标用于安装、配置和卸载大多数软件。make(1)处理了各种各样的功能，其中一些功能远远超出了创建者的初衷。但这正是Unix的乐趣所在！
- en: '**Source Code and Software**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**源代码和软件**'
- en: Source code is the human-readable instructions for building the actual machine
    code that makes up a runnable program. You’ve probably been exposed to source
    code in some form. If you’ve never seen it, take a look at a few files under */usr/src*
    or at *[https://svnweb.freebsd.org/](https://svnweb.freebsd.org/)*. Even a neophyte
    sysadmin needs to recognize source code two tries out of three.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码是用于构建实际机器代码的可读指令，这些机器代码构成了一个可运行的程序。你可能已经以某种形式接触过源代码。如果你从未见过它，可以查看 */usr/src*
    下的几个文件或* [https://svnweb.freebsd.org/](https://svnweb.freebsd.org/)*。即便是新手系统管理员也需要能在三次中识别源代码两次。
- en: Once you have source code for a program, you build (or *compile*) the program
    on the type of system you want to run it on. (Building software for a foreign
    platform via cross-compiling demands is more complicated when it’s possible.)
    If the program was written for an operating system that’s sufficiently similar
    to the platform you’re building it on, it works. If your platform is too different
    from the original, it fails. Once you’ve successfully built the software on your
    system, you can copy the resulting program (or *binary*) to other identical systems,
    and it should run.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有一个程序的源代码，你就在你希望运行它的系统类型上构建（或*编译*）程序。（通过交叉编译来为外部平台构建软件要复杂得多。）如果程序是为一个与你正在构建的系统足够相似的操作系统编写的，它就能运行。如果你的平台与原始平台差异过大，它就会失败。一旦你在你的系统上成功构建了软件，你可以将生成的程序（或*二进制文件*）复制到其他相同的系统上，并且它应该能正常运行。
- en: Some programs are sufficiently well written that they can be compiled on many
    different platforms. A few programs specifically include support for widely divergent
    platforms; for example, the Apache web server can be compiled on both Windows
    and Unix-like systems. This represents heroic effort by the software authors,
    and even so, you must run a few scripts and configure your environment precisely
    by the directions before building on Windows.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序写得足够好，以至于它们可以在许多不同的平台上进行编译。有一些程序特别支持广泛不同的平台；例如，Apache web 服务器可以在 Windows
    和类 Unix 系统上编译。这代表了软件作者的巨大努力，尽管如此，在 Windows 上进行构建之前，您仍然必须运行一些脚本并严格按照指示配置环境。
- en: Generally speaking, if you can build a program from source, it will probably
    run. It might not run correctly, it might not do anything you expected, but it
    runs. A sufficiently experienced sysadmin can use the source code and error messages
    to learn why a program won’t build or run. In many cases, the problem is simple
    and can be fixed with minimal effort. This is one reason why access to source
    code is important.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你能够从源代码构建程序，它可能会运行。它可能不会正确运行，可能不会做你期望的事情，但它会运行。经验丰富的系统管理员可以利用源代码和错误信息，了解为什么一个程序无法构建或运行。在许多情况下，问题是简单的，并且可以通过最小的努力解决。这也是为什么访问源代码非常重要的原因之一。
- en: Back when every sysadmin was a programmer, debugging software absorbed a major
    part of the admin’s time. Every Unix-like system was slightly different, so every
    sysadmin had to understand his platform, the platform the software was designed
    for, and the differences between the two before he could hope to make a piece
    of code run. The duplication of effort was truly horrendous.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个系统管理员都是程序员的时代，调试软件占用了管理员大量的时间。每个类 Unix 系统都有些许不同，因此每个系统管理员都必须了解自己的平台、软件设计所针对的平台以及两者之间的差异，才能希望使一段代码正常运行。这种重复性的工作真是令人吃惊。
- en: Over the years, programmers developed tools such as autoconf to help address
    these cross-platform issues. Not every program used these tools, and when they
    broke, the sysadmin was kicked back to square one. Sysadmins had to edit the source
    code and *Makefiles* just to have a chance of making the programs work. And *working*
    isn’t nearly the same as *working well*, let alone *working correctly*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，程序员开发了像 autoconf 这样的工具来帮助解决这些跨平台问题。并非每个程序都使用这些工具，而当它们出错时，系统管理员就不得不重新开始。系统管理员必须编辑源代码和*Makefiles*，才能有机会使程序运行。而且，*运行*并不等同于*运行良好*，更别提*正确运行*了。
- en: The FreeBSD Ports Collection was designed to simplify this process for FreeBSD
    users.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD Ports 集合旨在简化这一过程，为 FreeBSD 用户提供便利。
- en: '**The Ports Collection**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Ports 集合**'
- en: The *Ports Collection*, also called the *ports tree* or simply *ports*, contains
    an automated system for compiling software on FreeBSD.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ports 集合*，也叫做*ports 树*或简称*ports*，包含了一个在 FreeBSD 上编译软件的自动化系统。'
- en: The basic idea behind the ports system is that if source code must be modified
    to run on FreeBSD, the modifications should be automated. If you need other software
    to build this program from source code or to run the software, those dependencies
    should be documented and tracked. If you’re going to automate the changes, you
    might as well record what the program includes so you can easily install and uninstall
    it. And since you have a software-building process that produces exactly the same
    result each time, and you’ve recorded everything that the process creates, you
    can copy the binaries and install them on any similar system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 端口系统的基本理念是，如果源代码需要修改才能在FreeBSD上运行，那么这些修改应该是自动化的。如果你需要其他软件来从源代码构建这个程序或运行该软件，那么这些依赖关系应该被记录和跟踪。如果你要自动化这些更改，那么不妨记录下程序所包含的内容，这样你就可以轻松地安装和卸载它。而且，由于你有一个生成每次都能产生相同结果的软件构建过程，并且你已经记录了这个过程创建的所有内容，你可以复制二进制文件并将其安装到任何类似的系统上。
- en: In addition to the information needed to create the packages, the Ports Collection
    contains legal restrictions on building the software, security information, licensing
    details, and more.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建软件包所需的信息外，端口集还包含有关构建软件的法律限制、安全信息、许可详情等。
- en: Ports interoperate with packages. The Ports Collection is used to create packages.
    You can install some software from ports and some from packages as you need, freely
    mixing where you install software from. You’ll need to use the same version of
    the Ports Collection used to build your packages, either a quarterly branch or
    the latest version. Most ports users want the latest software, so we’ll focus
    on that.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 端口与软件包互操作。端口集用于创建软件包。你可以根据需要从端口安装一些软件，从软件包安装其他软件，灵活地混合安装来源。你需要使用与构建软件包时相同版本的端口集，无论是季度分支还是最新版本。大多数端口用户希望获得最新的软件，因此我们将重点关注这一点。
- en: '***Ports***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***端口***'
- en: A *port* is a set of instructions on how to apply fixes to, or *patch*, a set
    of source code files and then build and install those files. A port contains a
    complete record of everything necessary to create the finished software. This
    frees sysadmins from struggling to install programs and lets them struggle to
    configure them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*端口*是一组说明如何修复或*补丁*一组源代码文件，并构建和安装这些文件的指令。一个端口包含创建完成软件所需的所有信息。这使得系统管理员不再为安装程序而苦恼，而是可以将精力集中在配置它们上。'
- en: '**Ports Tree Installation**'
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**端口树安装**'
- en: If you followed the installation instructions in [Chapter 3](ch03.xhtml#ch03),
    you installed the ports tree in */usr/ports*. In that directory, you should find
    several files and a couple dozen directories. If you don’t have anything in */usr/ports*,
    you apparently can’t follow instructions. That’s okay—I can’t either—but you must
    install the ports tree to continue.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照[第3章](ch03.xhtml#ch03)中的安装说明进行操作，你应该已将端口树安装在*/usr/ports*目录中。在该目录下，你应该能找到几个文件和几十个目录。如果你在*/usr/ports*中没有任何内容，显然你没有按照说明操作。没关系——我也没做到——但你必须安装端口树才能继续。
- en: FreeBSD supports a couple different ways to get the ports tree. You can check
    it out using svn(1) or download a copy off the web. The recommended method for
    sysadmins is to use portsnap(8) to download the latest (nonquarterly) version
    of the ports tree.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD支持几种不同的方法来获取端口树。你可以使用svn(1)查看端口树，或者从网上下载一份。对于系统管理员来说，推荐的方法是使用portsnap(8)下载最新的（非季度版）端口树。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, portsnap searches for a mirror of the portsnap files, cryptographically
    verifies the integrity of those files on the portsnap server, downloads the files,
    and verifies the integrity of the download itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，portsnap会搜索portsnap文件的镜像，进行加密验证以确认这些文件在portsnap服务器上的完整性，下载文件，并验证下载本身的完整性。
- en: You now have all the latest versions of all FreeBSD ports. To update an existing
    Ports Tree to the latest version, run `portsnap auto` again.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经拥有了所有FreeBSD端口的最新版本。要将现有的端口树更新到最新版本，只需再次运行`portsnap auto`。
- en: 'If you wish to schedule a regular portsnap update run via cron(1), use the
    `portsnap cron update` command instead of `portsnap auto`. This tells portsnap
    to update the ports tree at some random time within 60 minutes of the command
    running. This helps distribute the load on the FreeBSD portsnap server. Schedule
    a portsnap run at some point between 5 AM and 5:59:59 AM in root’s crontab with
    an entry like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望通过cron(1)定期调度portsnap更新运行，使用`portsnap cron update`命令，而不是`portsnap auto`。这会告诉portsnap在命令运行后60分钟内的某个随机时间更新端口树。这有助于分散FreeBSD
    portsnap服务器的负载。在root的crontab中安排一个在上午5点到5:59:59之间的portsnap运行，可以使用如下条目：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This kicks off the actual update at a random time between 5 AM and 6 AM, which
    is *much* more effective than 1 out of 24 portsnap users hitting the download
    server simultaneously at 5 AM.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在早上5点到6点之间的随机时间启动实际更新，这比24个portsnap用户中1个在早上5点同时访问下载服务器要*有效得多*。
- en: '**Ports Tree Contents**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**端口树内容**'
- en: Most of the directories you see here are software categories. Each category
    contains a further layer of directories, and each of those directories is a piece
    of software. FreeBSD has over 28,000 ports as I write this, so using the directory
    tree and categorizing software properly is vital. Of the files and directories
    in this category that aren’t software categories, the major ones are described
    here.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的大多数目录都是软件类别。每个类别包含进一步的目录层次，而这些目录中的每一个都是一个软件包。截止到我写这篇文章时，FreeBSD有超过28,000个端口，因此使用目录树并正确分类软件至关重要。在这个类别中，不是软件类别的文件和目录中的主要部分在此进行描述。
- en: The *CHANGES* file lists changes made to the FreeBSD ports infrastructure. It’s
    primarily of use to the FreeBSD ports developers and people interested in the
    internals of the Ports Collection.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*CHANGES*文件列出了对FreeBSD端口基础设施所做的更改。它主要供FreeBSD端口开发者和那些对端口集合内部结构感兴趣的人使用。'
- en: The *CONTRIBUTING.md* file exists for FreeBSD source code mirrors on GitHub.
    All FreeBSD source code is mirrored on GitHub for people’s convenience, but FreeBSD
    doesn’t use Git internally. GitHub users traditionally check *CONTRIBUTING.md*
    for information on how to contribute—which, in FreeBSD’s case, is “go to the FreeBSD
    website.” (Work on automatically feeding GitHub pull requests into the FreeBSD
    PR system is ongoing as I write this.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*CONTRIBUTING.md*文件存在于GitHub上的FreeBSD源代码镜像中。所有FreeBSD源代码都镜像在GitHub上，方便用户使用，但FreeBSD内部并不使用Git。GitHub用户通常会查阅*CONTRIBUTING.md*，了解如何贡献——而在FreeBSD的情况下，回答是“访问FreeBSD官网。”（截至我写这篇文章时，将GitHub的拉取请求自动提交到FreeBSD
    PR系统的工作仍在进行中。）'
- en: '*COPYRIGHT* contains the licensing information for the Ports Collection as
    a whole. While each individual piece of software supported by the Ports Collection
    has its own copyright and licensing information, the Ports Collection is licensed
    under the two-clause BSD license.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*COPYRIGHT*包含了整个端口集合的许可信息。虽然端口集合中每个单独的软件都有自己的版权和许可信息，但端口集合本身是根据两条条款的BSD许可证进行许可的。'
- en: The *GIDs* file contains a list of all the group IDs used by software in the
    Ports Collection. Many pieces of software in the collection expect to run as an
    unprivileged user. If each port gets to create a random user, the usernames, user
    IDs, and group IDs will overlap. Instead, ports that need an unprivileged GID
    reserve one in this file. This file records GIDs assigned to Ports Collection.
    GIDs aren’t actually assigned in */etc/passwd* until used.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*GIDs*文件包含了端口集合中所有软件使用的组ID列表。集合中的许多软件期望以无特权用户身份运行。如果每个端口都创建一个随机用户，用户名、用户ID和组ID就会重叠。相反，需要无特权GID的端口在这个文件中预留一个。这个文件记录了分配给端口集合的GID。直到使用时，GID才会在*/etc/passwd*中分配。'
- en: Your */usr/ports* has an *INDEX* file with a suffix named after the version
    of FreeBSD you’re running. This FreeBSD 12 system has */usr/ports/INDEX-12*. The
    ports system’s search and description features use this index. The index is generated
    locally and not stored in Subversion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你的*/usr/ports*中有一个以你运行的FreeBSD版本命名后缀的*INDEX*文件。这个FreeBSD 12系统中有*/usr/ports/INDEX-12*。端口系统的搜索和描述功能使用这个索引。索引是本地生成的，不存储在Subversion中。
- en: The *Keywords* directory contains information for the Universal Configuration
    Language system, discussed in [Chapter 23](ch23.xhtml#ch23).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*Keywords*目录包含了通用配置语言系统的信息，详见[第23章](ch23.xhtml#ch23)。'
- en: '*LEGAL* describes the legal restrictions on any software in the Ports Collection.
    Some pieces of software have specific limitations on them—such as no commercial
    use, no redistribution, no monetary gain, and so on. Individual ports also list
    these restrictions; this is just a master list built from all the ports.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*LEGAL*描述了端口集合中任何软件的法律限制。有些软件有特定的限制——比如不允许商业使用、不允许再分发、不允许盈利等。每个单独的端口也列出了这些限制；这只是从所有端口中汇总的主列表。'
- en: '*MOVED* lists all the ports that have been renamed, moved from one category
    to another, or removed, along with the reason why. Automated management tools
    such as portmaster(8) use this list to find the new home of moved ports. Why move
    a port? When I started with FreeBSD, it had one category for X Windows software.
    The category grew ridiculously huge, so the ports team split it, and split it
    again, until we reached 2017’s nine categories.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*MOVED* 列出了所有已重命名、从一个类别移动到另一个类别或被移除的端口，并附上了原因。自动化管理工具如 portmaster(8) 会使用此列表来查找已移动端口的新位置。为什么要移动端口？当我开始使用
    FreeBSD 时，它有一个用于 X Windows 软件的类别。这个类别变得极其庞大，因此端口团队将其拆分，然后再次拆分，直到我们到了 2017 年的九个类别。'
- en: The *Makefile* contains high-level instructions for the whole Ports Collection.
    You’ll only use this if you want to build every port in the entire Ports Collection.
    You’d be better off using poudriere as discussed in “[Private Package Repositories](ch16.xhtml#lev709)”
    on [page 381](ch16.xhtml#page_381) than just running `make` here.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*Makefile* 包含了整个 Ports Collection 的高级指令。只有当你想构建整个 Ports Collection 中的每一个端口时才会使用它。你最好使用像
    “[Private Package Repositories](ch16.xhtml#lev709)” 在 [381 页](ch16.xhtml#page_381)
    讨论的 poudriere，而不是在这里直接运行 `make`。'
- en: The *Mk* subdirectory contains the logic that drives make(1) in fetching source
    files from the internet, patching them, building them, and installing them. Many
    types of programs expect to integrate together, and these files ensure that different
    parts of the same tool are built and installed in a compatible manner. Some features,
    like LDAP and Emacs, can touch many ports. This directory contains Makefiles like
    *bsd.ldap.mk* and *bsd.emacs.mk* for exactly these functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mk* 子目录包含了驱动 make(1) 从互联网获取源文件、打补丁、构建和安装的逻辑。许多类型的程序期望能够集成在一起，这些文件确保同一工具的不同部分能够以兼容的方式构建和安装。一些功能，如
    LDAP 和 Emacs，可能会影响许多端口。这个目录包含了像 *bsd.ldap.mk* 和 *bsd.emacs.mk* 这样的 Makefiles，专门用于这些功能。'
- en: Beneath the *Mk* subdirectory, you’ll find *Uses*. This directory contains broadly
    used *Makefiles* for other widely used functions or software suites. For example,
    the KDE and GNOME desktop suites include dozens or hundreds of smaller programs,
    and each must be built correctly to interoperate. If you look in *Uses*, you’ll
    see the files *gnome.mk* and *kde.mk* dedicated to configuration of these programs,
    as well as files for GSSAPI, Lua, Varnish, and many other software families.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Mk* 子目录下，你会找到 *Uses* 目录。这个目录包含了广泛使用的 *Makefiles*，用于其他广泛使用的功能或软件套件。例如，KDE
    和 GNOME 桌面套件包括数十个或数百个小程序，每个程序都必须正确构建才能相互协作。如果你查看 *Uses*，你会看到专门配置这些程序的 *gnome.mk*
    和 *kde.mk* 文件，以及 GSSAPI、Lua、Varnish 等许多其他软件系列的文件。
- en: If you really want to learn how the Ports Collection works, read everything
    in */usr/ports/Mk* and */usr/ports/Mk/Uses*. It’s highly educational, even though
    the nature of supporting all these different programs means the *Makefiles* are
    as tangled as a yarn basket attacked by a horde of crazed kittens.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想了解 Ports Collection 是如何工作的，可以阅读 */usr/ports/Mk* 和 */usr/ports/Mk/Uses*
    中的所有内容。这些内容非常具有教育意义，尽管支持这些不同程序的本质意味着 *Makefiles* 像一篮被疯狂小猫攻击过的线团一样纠结。
- en: The *README* file contains a high-level introduction to the Ports Collection.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*README* 文件包含了 Ports Collection 的高层次介绍。'
- en: The *Templates* directory contains skeleton files used by other portions of
    the Ports Collection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*Templates* 目录包含其他部分的 Ports Collection 使用的框架文件。'
- en: The *Tools* directory contains programs, scripts, and other automation, mostly
    used by ports developers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tools* 目录包含了程序、脚本和其他自动化工具，主要供端口开发者使用。'
- en: The *UIDs* file contains unprivileged user IDs used by ports in the system.
    Much like the *GIDs* file, this helps the ports developers avoid conflicts between
    unprivileged users required by ported software.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*UIDs* 文件包含系统中端口使用的非特权用户 ID。与 *GIDs* 文件类似，这有助于端口开发者避免端口软件所需的非特权用户之间的冲突。'
- en: '*UPDATING* contains notes for use when upgrading your software. Updates that
    require special intervention appear here in reverse date order. Before updating
    your software, check this file for important notes that affect you.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*UPDATING* 包含了升级软件时的使用说明。需要特别干预的更新会按日期逆序出现在这里。在更新软件之前，请查看此文件，以获取对你有影响的重要说明。'
- en: The *distfiles* directory contains the original source code for ported software.
    When a port downloads a chunk of source code, that source code is kept under */usr/ports/distfiles*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*distfiles* 目录包含了已移植软件的原始源代码。当一个端口下载一段源代码时，该源代码会保存在 */usr/ports/distfiles*
    下。'
- en: All the other directories are categories of ports. The following shows the contents
    of the *ports/arabic* directory, where software specific to the Arabic language
    is kept. Much software elsewhere in the Ports Collection supports Arabic, but
    this category is for software focused on Arabic—such as fonts, translations of
    certain types of documents, and so on. This category isn’t useful for most people,
    but it has the serious advantage of being small enough to fit in this book. Some
    ports categories have hundreds of entries.^([1](footnote.xhtml#ch16fn1))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他目录都是端口的分类。以下是*ports/arabic*目录的内容，其中包含了专门针对阿拉伯语言的软件。虽然端口集合中的其他软件也支持阿拉伯语，但此类别是针对阿拉伯语的软件——例如字体、某些类型文档的翻译等等。这个类别对大多数人来说并不有用，但它的优势在于它足够小，可以放入这本书中。有些端口类别有数百个条目。^([1](footnote.xhtml#ch16fn1))
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This *Makefile* contains instructions for all the ports in the directory. They’re
    more specific than the global *Makefile* in */usr/ports*, but not as specific
    as individual port Makefiles. The file *Makefile.inc* contains meta-instructions
    for the ports in this directory. All the other directories are individual software
    packages. We’ll dissect one of those directories in “[Installing a Port](ch16.xhtml#lev685)”
    on [page 371](ch16.xhtml#page_371).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*Makefile*包含了该目录中所有端口的指令。它们比*/usr/ports*中的全局*Makefile*更为具体，但没有单个端口的*Makefile*那么具体。文件*Makefile.inc*包含了该目录中端口的元指令。所有其他目录则是独立的软件包。我们将在[第371页](ch16.xhtml#page_371)的“[安装端口](ch16.xhtml#lev685)”中剖析其中一个目录。
- en: Individual ports are often called by their directory in the Ports Collection.
    The gnuplot graphing program might be called math/gnuplot, as its port can be
    found at */usr/ports/math/gnuplot*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 独立端口通常根据它们在端口集合中的目录来命名。gnuplot图形程序可能被称为math/gnuplot，因为它的端口可以在*/usr/ports/math/gnuplot*找到。
- en: '**The Ports Index**'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**端口索引**'
- en: The ports index file contains a list of all ports that build on a particular
    FreeBSD release. On FreeBSD 13, this is */usr/ports/INDEX-13*. The Ports Collection
    uses the index for several purposes, including searching the whole ports tree.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 端口索引文件包含了所有基于特定FreeBSD版本构建的端口列表。在FreeBSD 13中，这是*/usr/ports/INDEX-13*。端口集合使用该索引有多个用途，包括搜索整个端口树。
- en: 'The index file describes each port on a single line, with fields separated
    by pipe symbols (`|`). While this is convenient for system tools, it’s not particularly
    human-readable. Run `make print-index` in */usr/ports* to get a longer, much more
    intelligible index. This index is filled with entries like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 索引文件描述了每个端口的单行信息，字段之间用管道符号(`|`)分隔。虽然这种方式对于系统工具很方便，但对人类并不特别友好。在*/usr/ports*中运行`make
    print-index`可以得到一个更长且更易理解的索引。这个索引包含了如下条目：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The index starts with the port’s name and the full path to the port directory.
    `Info` gives a very brief description of the port. The `Maint` heading lists the
    port’s maintainer, a person or team who has assumed responsibility for this software’s
    integration into the Ports Collection. The `Index` space lists every category
    where this port might be filed. The first category listed is the directory where
    it appears in the Ports Collection. In this case, the port appears in the *archivers*
    directory.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 索引从端口的名称和端口目录的完整路径开始。`Info`提供了端口的简短描述。`Maint`标题列出了端口的维护者，即负责将该软件集成到端口集合中的个人或团队。`Index`部分列出了该端口可能归类的所有类别。列出的第一个类别是该端口在端口集合中的所在目录。在本例中，端口出现在*archivers*目录中。
- en: We then have dependencies. `B-deps` lists the build dependencies—that is, other
    software that must be installed to build this port. `R-deps` lists runtime dependencies,
    software needed for this to actually run. This is a Perl module, so it needs a
    Perl interpreter. Some software must be extracted or decompressed by particular
    tools, specified in `E-deps`. The `P-deps` field lists any dependencies for patching
    the software—rare pieces of software must be patched with a certain tool. The
    `F-deps` field is similar, specifying *fetch dependencies*—that is, any special
    software that must be used to download the software.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是依赖项。`B-deps`列出了构建依赖项——即构建此端口时必须安装的其他软件。`R-deps`列出了运行时依赖项，即实际运行时所需的软件。这是一个Perl模块，因此它需要一个Perl解释器。某些软件必须由特定的工具提取或解压缩，这在`E-deps`中指定。`P-deps`字段列出了用于补丁的软件依赖项——一些稀有的软件必须使用特定工具进行修补。`F-deps`字段类似，指定*fetch依赖项*——即必须使用的特殊软件来下载软件。
- en: Finally, the `WWW` space gives the home page of the software.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`WWW`部分给出了该软件的主页。
- en: '***Searching the Index***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***搜索索引***'
- en: The Ports Collection includes tools to search the index. If you want a particular
    program, you might be better off finding the ports directory with `pkg search`
    or even `locate -i`. Reserve searching the Ports Collection to answer questions
    like “What ports use SNMP?”
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Ports Collection 包括用于搜索索引的工具。如果你需要一个特定程序，可能更好通过`pkg search`或者甚至`locate -i`来找到端口目录。将搜索
    Ports Collection 留给回答类似“哪些端口使用 SNMP？”的问题。
- en: 'If you know the name of a piece of software, search *INDEX* for it with `make
    search`. Here, I look for ports with names that include *net-snmp*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道某个软件的名称，可以使用`make search`在*INDEX*文件中搜索它。这里，我查找包含*net-snmp*名称的端口：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As of this writing, FreeBSD has several ports with *net-snmp* in their name.
    The first is the current standard net-snmp software collection ➊. Others include
    Perl libraries that use SNMP over the network but otherwise have nothing to do
    with the net-snmp suite, old versions of net-snmp that are no longer supported,
    and Tcl/Tk interfaces to net-snmp. The fields in the description are taken straight
    from the *INDEX* file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，FreeBSD 有几个端口名称中包含*net-snmp*。第一个是当前标准的 net-snmp 软件集合➊。其他的包括使用 SNMP 通过网络传输的
    Perl 库，但与 net-snmp 套件无关，已经不再支持的旧版本 net-snmp，以及 Tcl/Tk 接口到 net-snmp。描述中的字段直接来自*INDEX*文件。
- en: If you don’t need this much detail, try `make quicksearch` to get only the port,
    path, info, and (if applicable) notes on reasons why it’s not there anymore.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要这么详细的信息，可以尝试`make quicksearch`，这样只会显示端口、路径、信息和（如果适用）关于为什么它不再存在的备注。
- en: '**Key Searches**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**关键字搜索**'
- en: You can also search using any of the fields in the port description as a key.
    Remove any hyphens from the key name. You want all the ports that have a runtime
    dependency on Perl?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用端口描述中的任意字段作为关键字进行搜索。请去除关键字名称中的任何连字符。你想要查找所有依赖于 Perl 的运行时端口吗？
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can combine multiple search terms in one query. Suppose you want all the
    programs with Apache in the name but with a runtime dependency on Python.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多个搜索词组合在一个查询中。例如，假设你想要查找所有名称中包含 Apache 且依赖于 Python 运行时的程序。
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Exclude a word from the search results by putting an *x* in front of the key.
    Here, we look for everything that has a runtime dependency on Python but *doesn’t*
    have Apache in the name:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在关键字前加上* x *来排除某个单词的搜索结果。在这里，我们查找所有依赖于 Python 运行时但*不*包含 Apache 名称的端口：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These by-field searches don’t work for all software, however. For example, if
    you’re looking for the Midnight Commander file manager, you might search for it
    by name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些按字段搜索并不适用于所有软件。例如，如果你在寻找 Midnight Commander 文件管理器，你可能按名称进行搜索。
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Well, that was less than helpful. Search all the fields for a match with the
    term `key`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个搜索结果并不太有帮助。搜索所有字段，以匹配`key`这个词。
- en: This scans more fields and returns more hits. If you’re searching for a common
    word, however, the `key` search can provide far too much information. Trim the
    output with `quicksearch`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这会扫描更多字段并返回更多结果。不过，如果你正在搜索一个常见词汇，`key`搜索可能会提供过多的信息。使用`quicksearch`来精简输出结果。
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This returns every port with the string `midnight` in its description, name,
    or dependencies. We’ll quickly learn that Midnight Commander can be found under
    */usr/ports/misc/mc*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有描述、名称或依赖中包含`midnight`字符串的端口。我们很快就能发现 Midnight Commander 可以在*/usr/ports/misc/mc*找到。
- en: '**Other Ways to Browse the Ports Collection**'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**浏览 Ports Collection 的其他方式**'
- en: If you prefer using a web browser, build an HTML index. Just go to */usr/ports*
    and, as root, type `make readmes` to generate a *README.html* file with the index
    of your ports tree and a HTML file in every port. You can click through various
    categories and even view detailed descriptions of every port.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用网页浏览器，可以构建一个 HTML 索引。只需进入*/usr/ports*目录，并以 root 用户身份输入`make readmes`，生成一个包含端口树索引的*README.html*文件，以及每个端口的
    HTML 文件。你可以点击浏览不同的类别，甚至查看每个端口的详细描述。
- en: If none of these options work, try the FreeBSD Ports Tree search at *[http://www.freebsd.org/cgi/ports.cgi](http://www.freebsd.org/cgi/ports.cgi)*.
    Also, the FreshPorts search engine at *[http://www.freshports.org/](http://www.freshports.org/)*
    provides a separate but very nice search function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些选项都不适用，可以尝试 FreeBSD Ports Tree 搜索，访问 *[http://www.freebsd.org/cgi/ports.cgi](http://www.freebsd.org/cgi/ports.cgi)*。此外，FreshPorts
    搜索引擎在 *[http://www.freshports.org/](http://www.freshports.org/)* 提供了一个独立的但非常不错的搜索功能。
- en: Between the web browser and the search engine, you should be able to find a
    piece of software to meet your needs. Finding the port you need might well be
    the most difficult part of working with ports.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页浏览器和搜索引擎之间，你应该能够找到满足需求的软件。找到所需的端口可能是使用端口时最困难的部分。
- en: '***Legal Restrictions***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***法律限制***'
- en: While most of the software in the Ports Collection is free for any use, some
    of it has a more restrictive license. The */usr/ports/LEGAL* file lists legal
    restrictions on the contents of the Ports Collection. The most common restriction
    is a prohibition on redistribution; the FreeBSD Project doesn’t include such software
    on its FTP sites or on a CD image but provides instructions on how to build it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数 Ports Collection 中的软件可以用于任何用途，但其中一些软件有更为严格的许可证。*/usr/ports/LEGAL* 文件列出了
    Ports Collection 中的法律限制。最常见的限制是禁止重新分发；FreeBSD 项目不会将此类软件包含在其 FTP 站点或 CD 镜像中，而是提供如何构建它的说明。
- en: Legal restrictions appear in places you might not expect. You can’t download
    a compiled, ready-to-go package for Oracle Java, and the FreeBSD Project can’t
    redistribute the Java source code. FreeBSD can and does distribute instructions
    on how to build the Oracle Java source code on FreeBSD, but the user must go to
    the Oracle site and download the code themselves. Fortunately, OpenJDK has supplanted
    Oracle Java for most software, and FreeBSD has a high-quality package for it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 法律限制出现在你可能没有预料到的地方。你不能下载已编译好的 Oracle Java 软件包，FreeBSD 项目也不能重新分发 Java 源代码。FreeBSD
    可以并且确实会分发关于如何在 FreeBSD 上构建 Oracle Java 源代码的说明，但用户必须自行前往 Oracle 网站下载代码。幸运的是，OpenJDK
    已经取代了 Oracle Java，成为大多数软件的首选，而 FreeBSD 为它提供了高质量的软件包。
- en: Similarly, some pieces of software prohibit commercial use or embedding in commercial
    products. A few cannot be exported from the United States, thanks to Department
    of Commerce rules restricting the export of cryptography.^([2](footnote.xhtml#ch16fn2))
    If you’re building FreeBSD systems for redistribution, export, or commercial use,
    you need to check this file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，一些软件禁止商业使用或嵌入到商业产品中。一些软件由于美国商务部的加密技术出口限制，无法从美国出口。^([2](footnote.xhtml#ch16fn2))
    如果你正在为重新分发、出口或商业用途构建 FreeBSD 系统，你需要查看这个文件。
- en: Fortunately, most of the software in the Ports Collection is free for either
    commercial or noncommercial use. These restricted packages are the exception,
    not the norm.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数 Ports Collection 中的软件可以免费用于商业或非商业用途。这些有限制的软件包是例外，而非常规。
- en: '**What’s In a Port?**'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**端口包含了什么？**'
- en: 'Installing software from ports takes longer than using packages, and the Ports
    Collection requires a live internet connection. In exchange, the Ports Collection
    can produce more optimal results than packages. Let’s take a look at a port. Here’s
    the innards of dns/bind911, version 9.11 of the ISC BIND nameserver:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从端口安装软件比使用包管理工具要花更长时间，而且 Ports Collection 需要一个活跃的互联网连接。作为交换，Ports Collection
    可以比包管理工具生成更优化的结果。让我们来看一个端口。以下是 dns/bind911 的内部结构，这是 ISC BIND 域名服务器的 9.11 版本：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The *Makefile* contains the basic instructions for building the port. If you
    read this file, you’ll quickly find that it’s only a few hundred lines long. That’s
    not a huge amount of instructions for such a complicated piece of software, and
    most *Makefiles* are much shorter. Most of that file is dedicated to customizations
    that are only rarely used. There’s almost no information about BIND itself in
    here and not much about how to build software on FreeBSD. Most of the FreeBSD
    ports system’s *Makefiles* are in */usr/ports/Mk*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*Makefile* 包含了构建端口的基本指令。如果你阅读这个文件，你会发现它只有几百行。对于如此复杂的软件来说，这并不是很多指令，而且大多数 *Makefile*
    都要短得多。这个文件的主要内容是一些很少用到的定制设置。这里几乎没有关于 BIND 本身的信息，也没有多少关于如何在 FreeBSD 上构建软件的内容。大多数
    FreeBSD 端口系统的 *Makefile* 都位于 */usr/ports/Mk* 目录中。'
- en: The *distinfo* file contains checksums for the various files the port downloads
    so that your system can be sure that the file transferred without error and that
    nobody tampered with the file before you got it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*distinfo* 文件包含端口下载的各种文件的校验和，确保你的系统能够确认文件在传输过程中没有出现错误，并且在你获取文件之前没有人篡改它。'
- en: The *files* directory contains all the add-on files and patches required to
    build this port on FreeBSD. BIND 9.11 takes a dozen patches. Most of these patches
    aren’t required for building, as the ISC supports their DNS servers on FreeBSD.
    They provide integration only into the FreeBSD package system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*files* 目录包含了在 FreeBSD 上构建此端口所需的所有附加文件和补丁。BIND 9.11 需要十几个补丁。大多数补丁并不是构建所必需的，因为
    ISC 在 FreeBSD 上支持他们的 DNS 服务器。它们仅提供与 FreeBSD 包管理系统的集成。'
- en: The file *pkg-descr* contains a lengthy description of the software.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*pkg-descr* 文件包含了软件的详细描述。'
- en: A few ports include a *pkg-help* file that offers additional details on how
    to use the port.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一些端口包括 *pkg-help* 文件，提供如何使用该端口的额外细节。
- en: Some ports (not this one) have a *pkg-message* file that contains a template
    used to create the package’s installation message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一些端口（不是这个端口）有一个*pkg-message*文件，包含一个模板，用于创建软件包的安装信息。
- en: Finally, the *pkg-plist* file is a list of all the files installed (the “packing
    list”). The port installs only the files listed in the packing list. Some ports
    (such as Python-related ones) use an automatically generated packing list, so
    don’t be surprised if the packing list is missing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*pkg-plist*文件是一个列出所有已安装文件的清单（“包装清单”）。端口只会安装包装清单中列出的文件。一些端口（如与Python相关的端口）使用自动生成的包装清单，因此如果包装清单缺失，不要感到惊讶。
- en: Combined, these files comprise the tools and instructions needed to build the
    software.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件结合在一起，包含了构建软件所需的工具和指令。
- en: '***Installing a Port***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装端口***'
- en: If you’re familiar with source code, you’ve probably already noticed that a
    port contains very little actual source code. Sure, there are patches to apply
    to the source code and scripts to run on the source code, but no source code for
    the software! You might rightly ask just how building software from source is
    supposed to work without source code?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉源代码，你可能已经注意到一个端口实际上包含的源代码非常少。没错，确实有一些补丁需要应用到源代码上，并且有一些脚本需要在源代码上运行，但没有软件的源代码！你可能会问，既然没有源代码，怎么从源代码构建软件呢？
- en: '**PORTS AND PRODUCTION**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口和生产环境**'
- en: I would strongly encourage you to build your own package repository with poudriere
    and manage your servers’ ports from that repository. Upgrading ports directly
    installed on a host is annoying and difficult. Tools like portmaster and portupgrade
    are obsolete at this moment, and while they might get updated or rewritten, poudriere
    is the eternal method. You have been warned. Explore ports on a disposable test
    system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你使用poudriere构建自己的软件包仓库，并通过该仓库管理服务器的端口。从主机上直接升级已安装的端口既麻烦又困难。像portmaster和portupgrade这样的工具目前已经过时，尽管它们可能会被更新或重写，但poudriere是永恒的方法。你已经被提醒了。请在可丢弃的测试系统上探索端口。
- en: 'When you activate a port, FreeBSD automatically downloads the appropriate source
    code from an included list of sites. The port then checks the downloaded code
    for integrity errors, extracts the code to a temporary working directory, patches
    it, builds it, installs everything, and records the installation in the package
    database. If the port has dependencies, and those dependencies are not installed,
    it interrupts the build of the current port to build the dependencies from source.
    To trigger all this, you just go into the port directory and type:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你激活一个端口时，FreeBSD会自动从包含的站点列表中下载相应的源代码。然后，端口会检查下载的代码是否有完整性错误，将代码提取到临时工作目录，打上补丁，构建它，安装所有内容，并将安装记录到包数据库中。如果该端口有依赖项，并且这些依赖项没有安装，它会中断当前端口的构建，开始从源代码构建依赖项。要触发所有这些操作，你只需要进入端口目录并输入：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You’ll see lots of text scroll down your terminal as the port carries out its
    work, and you’ll get your command prompt back when it finishes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当端口执行其工作时，你会看到大量文本滚动通过终端，完成后你会重新获得命令提示符。
- en: 'As you grow more experienced in building from source, however, you’ll find
    that this all-in-one approach isn’t appropriate for every occasion. Not to worry;
    the Ports Collection provides the ability to take the port-building process exactly
    as far as you like because `make install` actually runs a whole series of subcommands.
    If you specify one of these subcommands, make(1) runs all previous commands as
    well as the one you specify. For example, `make extract` runs `make config`, `make
    fetch`, `make checksum`, `make depends`, and `make extract`. These subcommands
    are, in order:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着你在从源代码构建方面经验的增加，你会发现这种一体化的方法并不适用于所有场合。别担心；端口集合提供了按照你希望的方式进行端口构建的能力，因为`make
    install`实际上会运行一系列子命令。如果你指定其中一个子命令，make(1)会运行所有前面的命令以及你指定的命令。例如，`make extract`会运行`make
    config`、`make fetch`、`make checksum`、`make depends`和`make extract`。这些子命令的顺序如下：
- en: '**make config**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**make config**'
- en: Many ports have optional components. Running `make config` lets you select which
    of those options you wish to support in this port. The options you select are
    saved in */var/db/ports* for future builds of the port. These options affect how
    the port is built—for example, if you choose to build a program with net-snmp
    support, you’re adding a dependency on net-snmp. We discuss `make config` in more
    detail in “[Port Customization Options](ch16.xhtml#lev695)” on [page 373](ch16.xhtml#page_373)
    later in this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 许多端口有可选组件。运行`make config`可以让你选择希望在该端口中支持的选项。你选择的选项会保存在*/var/db/ports*中，以便将来构建该端口时使用。这些选项会影响端口的构建方式——例如，如果你选择使用net-snmp支持来构建一个程序，那么你就在添加对net-snmp的依赖。我们在本章后面的“[端口自定义选项](ch16.xhtml#lev695)”一节中更详细地讨论了`make
    config`，[第373页](ch16.xhtml#page_373)也有相关内容。
- en: '**make fetch**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**make fetch**'
- en: Once you’ve configured the port, the system searches a preconfigured list of
    internet sites for the program source code. The port’s *Makefile* might list the
    authoritative download site for the file, or it might use one of several authoritative
    lists provided by the Ports Collection. When the port finds the source code, it
    downloads it. The original, downloaded source code is called a *distfile* and
    is stored in */usr/ports/distfiles*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好端口后，系统会搜索一个预先配置的互联网站点列表以查找程序源代码。端口的*Makefile*可能会列出该文件的权威下载站点，或者可能使用Ports
    Collection提供的多个权威列表之一。当端口找到源代码时，它会将其下载。原始下载的源代码称为*distfile*，并存储在*/usr/ports/distfiles*中。
- en: If the port requires a particular program to fetch a distfile, the port installs
    that program as part of `make fetch`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端口需要特定的程序来获取distfile，端口会在`make fetch`过程中安装该程序。
- en: '**make checksum**'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**make checksum**'
- en: 'The `make checksum` step computes the distfile’s cryptographic hash and compares
    it to that recorded in the port’s *distinfo* file. Files can be corrupted in any
    number of ways: during download, by malicious intruders on a download site, or
    sheer random what-the-heck. Checksum verification detects file damage from any
    cause and stops the build if the files are corrupt.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`make checksum`步骤计算distfile的加密哈希值，并将其与端口的*distinfo*文件中记录的哈希值进行比较。文件可能会以多种方式损坏：在下载过程中、在下载站点上被恶意入侵者篡改，或由于某种随机的不可预见情况。校验和验证可以检测任何原因导致的文件损坏，并在文件损坏时停止构建。'
- en: This step makes no effort to determine why or how the file was corrupted. For
    the port’s purposes, it doesn’t matter whether the source code was corrupted during
    download or some malicious intruder put his backdoor code into the distfile before
    you downloaded it. Either way, don’t waste time building it, and certainly don’t
    install it!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该步骤不会尝试确定文件为何或如何损坏。对于端口而言，源代码在下载过程中是否损坏，或是某个恶意入侵者在你下载之前将后门代码加入distfile，都无关紧要。无论如何，都不要浪费时间构建它，当然也不要安装它！
- en: '**FOOT-SHOOTING METHOD #839: IGNORING THE CHECKSUM**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**足射法 #839：忽略校验和**'
- en: Software authors, especially free software authors, sometimes make minor changes
    to their code but don’t change the software version or the filename of the distfile.
    The FreeBSD port rightfully notices this problem and doesn’t work after such a
    change. If you’re absolutely certain that the distfile hasn’t been compromised
    or corrupted, you can override this check with `make NO CHECKSUM=yes install`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 软件作者，特别是自由软件作者，有时会对代码做出小的更改，但不会更改软件版本或distfile的文件名。FreeBSD端口会正确地发现这个问题，并在发生此类更改后无法正常工作。如果你完全确定distfile没有被篡改或损坏，你可以通过`make
    NO CHECKSUM=yes install`来覆盖此检查。
- en: I highly recommend consulting the software’s original author—not the port maintainer—before
    doing so. Checking with the author ensures that you’re not installing compromised
    software and also helps educate the software author about the importance of version
    numbers and release engineering.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议在这样做之前，咨询软件的原作者——而不是端口维护者。与作者确认能确保你没有安装被篡改的软件，并有助于教育软件作者理解版本号和发布工程的重要性。
- en: '**make depends**'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**make depends**'
- en: A lot of software is built on top of other software. While FreeBSD includes
    make(1) and a compiler, some software can be compiled only with a particular compiler
    or demands a certain version of make. Maybe the distfile is distributed compressed
    with a rarely used algorithm. Perhaps it needs a third-party library that doesn’t
    come with FreeBSD. At the `make depends` stage, the port checks for missing dependencies
    and attempts to resolve them by building the ports.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件是建立在其他软件之上的。虽然 FreeBSD 包括了 make(1) 和编译器，但有些软件只能用特定的编译器编译，或要求特定版本的 make。也许源代码文件使用了一种罕见的压缩算法分发。可能它需要一个
    FreeBSD 没有提供的第三方库。在 `make depends` 阶段，端口会检查缺失的依赖项，并尝试通过构建端口来解决这些问题。
- en: Dependencies can have their own dependencies. The `make depends` recursively
    processes dependencies until the port has everything it needs to build, install,
    and run.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项可能也有它们自己的依赖项。`make depends` 会递归地处理依赖关系，直到端口拥有构建、安装和运行所需的一切。
- en: '**make extract**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**make extract**'
- en: Once FreeBSD has the port distfiles, it must uncompress and extract them. Most
    source code is compressed with something like gzip(1), bzip(1), or xz(1), and
    collated with tar(1). This command creates a *work* subdirectory in the port and
    extracts the tarball there. If the port requires a particular program to extract
    the distfile, it will install it now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 FreeBSD 拥有了端口的源代码文件，它必须解压并提取它们。大多数源代码会使用类似 gzip(1)、bzip(1) 或 xz(1) 这样的工具压缩，并使用
    tar(1) 归档。此命令会在端口中创建一个 *work* 子目录，并在那里解压 tar 包。如果端口需要特定的程序来提取源代码文件，它会在此时安装该程序。
- en: '**make patch**'
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**make patch**'
- en: This command applies any patches in the port to the extracted source code in
    the *work* subdirectory. If the port requires a special patch program instead
    of the base system’s patch(1), the port installs it now.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将端口中的任何补丁应用到 *work* 子目录中提取的源代码。如果端口需要特定的补丁程序，而不是基础系统中的 patch(1)，它将在此时安装该程序。
- en: '**make configure**'
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**make configure**'
- en: Next, FreeBSD checks to see whether the software has a configure script. This
    isn’t the same as the `make config` step performed by the port. If the software
    came with its own configure script, the port runs it. Some ports interrupt the
    build at this stage to prompt you for information, but most run silently.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，FreeBSD 会检查软件是否有配置脚本。这与端口执行的 `make config` 步骤不同。如果软件自带了配置脚本，端口会运行它。有些端口在这个阶段会中断构建，提示用户输入信息，但大多数会默默运行。
- en: '**make build**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**make build**'
- en: This step compiles the checked, extracted, patched, and configured software.
    Ports that don’t compile anything might have an empty step here. Some ports exist
    only to conveniently package a bunch of other ports.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步编译已检查、解压、打补丁并配置好的软件。那些不需要编译的端口在这里可能没有任何操作。有些端口仅用于方便地打包其他端口。
- en: '**make install**'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**make install**'
- en: Finally, `make install` installs the software and tells the package system to
    record its presence.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`make install` 安装软件并告诉包管理系统记录其存在。
- en: '***Port Customization Options***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***端口自定义选项***'
- en: Many software packages have extensive custom-build features. While enabling
    these features isn’t hard for any individual piece of software, there’s no universal
    method for defining them. With one piece of software, you might have to edit the
    original software’s *Makefile*; with another, you may have to offer flags to the
    configure script. Learning how to make these changes takes time and can be an
    annoyance. The FreeBSD Ports Collection offers two ways to consistently configure
    these options on your system.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件包有大量的自定义构建功能。虽然为任何个别软件启用这些功能并不难，但没有通用的方法来定义它们。对于某些软件，你可能需要编辑原始软件的 *Makefile*；对于另一些，你可能需要向配置脚本提供标志。学习如何进行这些更改需要时间，而且可能会让人烦恼。FreeBSD
    Ports Collection 提供了两种方法来一致地配置系统上的这些选项。
- en: The newer, prettier method is supported by `make config`. This brings up a dialog
    box much like those you saw when you first installed FreeBSD. For example, the
    popular access control system sudo (*[http://www.sudo.ws/](http://www.sudo.ws/)*)
    includes support for LDAP, auditing, and, most vitally, insulting the user when
    they enter their password incorrectly. If you go to */usr/ports/security/sudo*
    and type `make config`, you’ll see a menu much like the one shown in [Figure 16-1](ch16.xhtml#ch16fig1).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 较新且更美观的方法由 `make config` 支持。这会弹出一个对话框，类似于你首次安装 FreeBSD 时看到的界面。例如，流行的访问控制系统 sudo
    (*[http://www.sudo.ws/](http://www.sudo.ws/)*) 支持 LDAP、审计，并且最重要的是，当用户输入错误密码时会侮辱用户。如果你进入
    */usr/ports/security/sudo* 目录并输入 `make config`，你会看到一个类似于 [图 16-1](ch16.xhtml#ch16fig1)
    所示的菜单。
- en: Use the spacebar to select options you like and the arrows and TAB key to move
    around. Hit ENTER over either OK or Cancel to finish. The port records your desired
    options in */var/db/ports/<category>_<portname>/options*. When you have to rebuild
    or upgrade the port, the port reuses those same options unless you run `make config`
    to change them or `make rmconfig` to blow them away.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空格键选择你喜欢的选项，使用箭头键和 TAB 键移动。按 ENTER 键选择 OK 或 Cancel 以完成。端口会将你选择的选项记录在 */var/db/ports/<category>_<portname>/options*
    中。当你需要重建或升级端口时，端口会重复使用这些选项，除非你运行 `make config` 来更改它们，或者运行 `make rmconfig` 来清除它们。
- en: '![image](../images/f0374-01.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0374-01.jpg)'
- en: '*Figure 16-1: Port configuration*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-1：端口配置*'
- en: '**Customizing at the Command Line**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在命令行进行自定义**'
- en: 'Sometimes you don’t want a pretty arrow-select menu but a proper sysadmin interface
    of words on a command line. The Ports Collection lets you skip the menu and give
    all the configuration options in the make(1) command. Before you can do that,
    you’ll want to turn off the pretty menu. Set the environment variable `BATCH=1`
    on the command line to turn off the menu. Here, we build the port with the default
    configuration, exactly as the FreeBSD package cluster does:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你不想要一个漂亮的箭头选择菜单，而是想要一个适合系统管理员使用的命令行界面。Ports Collection 让你跳过菜单，直接在 make(1)
    命令中提供所有配置选项。在你进行此操作之前，你需要关闭漂亮的菜单。在命令行上设置环境变量 `BATCH=1` 来关闭菜单。在这里，我们使用默认配置构建端口，正如
    FreeBSD 包集群所做的那样：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that you’ve ditched the annoying menu, see what configure options the port
    supports. The `make pretty-print-config` command displays the current settings
    in an easily readable format. Let’s check out *security/sudo*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经摆脱了烦人的菜单，看看端口支持的配置选项。`make pretty-print-config` 命令会以易于阅读的格式显示当前设置。让我们来看看
    *security/sudo*。
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each of these represents a configuration option. Options marked with a plus
    are turned on, while those flagged with a minus are turned off. What do these
    options mean? Running `make showconfig` displays all the port’s options and what
    they do.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个选项都代表一个配置选项。标记为加号的选项已启用，而标记为减号的选项已禁用。这些选项意味着什么？运行 `make showconfig` 会显示所有端口的选项及其作用。
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While sudo supports LDAP and SSD and all sorts of complicated information sources,
    what I truly need is for sudo to insult the user any time he enters an incorrect
    password. I want the `INSULTS` option. Use the `WITH` environment variable on
    the command line to set the option. Option names are case-sensitive. Here, I set
    the option and check the configuration again:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 sudo 支持 LDAP、SSD 和各种复杂的信息源，但我真正需要的是让 sudo 在用户输入错误密码时侮辱用户。我想要 `INSULTS` 选项。在命令行上使用
    `WITH` 环境变量来设置该选项。选项名称区分大小写。在这里，我设置了该选项并再次检查配置：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `INSULTS` option is now set.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSULTS` 选项现在已设置。'
- en: Use quotation marks to enable multiple options.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用引号来启用多个选项。
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Similarly, use `WITHOUT` to turn off an option.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用 `WITHOUT` 来禁用一个选项。
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you leave the menu enabled when building the port, the `make config` graphical
    menu appears, but with your selected options set. Remember, turn the menu off
    with the `BATCH` variable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构建端口时保留了菜单启用状态，`make config` 图形菜单将会出现，但会使用你选择的选项。记住，通过设置 `BATCH` 变量来关闭菜单。
- en: '**Using Customizations Globally**'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**全局使用自定义设置**'
- en: You build ports to get specific features in your software. Often, you want that
    feature in all the ports that support it. Consider LDAP for a moment. If your
    enterprise uses LDAP, you probably want all of your software to use it. You’ll
    want LDAP to be the default.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建端口是为了在软件中获取特定功能。通常，你希望在所有支持该功能的端口中都包含这个功能。以 LDAP 为例。如果你的企业使用 LDAP，你可能希望所有软件都能使用它。你会希望
    LDAP 成为默认选项。
- en: FreeBSD stores settings used for every run of make in */etc/make.conf*. Here’s
    where you’d enable LDAP or LibreSSL or other customizations that should appear
    across the system. Put any options you want applied globally in *make.conf*. Unlike
    the command line, *make.conf* uses the variables `OPTIONS_SET` and `OPTIONS_UNSET`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 将每次运行 make 时使用的设置存储在 */etc/make.conf* 中。你可以在这里启用 LDAP 或 LibreSSL 或其他应在系统中全局出现的自定义设置。将任何希望全局应用的选项放入
    *make.conf* 中。与命令行不同，*make.conf* 使用变量 `OPTIONS_SET` 和 `OPTIONS_UNSET`。
- en: 'Here, I want the options LDAP and INSULTS enabled on every port:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我希望在每个端口上启用 LDAP 和 INSULTS 选项：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A *make.conf* setting has no effect on a port that doesn’t support the option.
    Many ports don’t know anything about LDAP. I don’t know whether any ports other
    than sudo include an optional feature to insult my users, but if the feature’s
    available, I *need* it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*make.conf*设置对不支持该选项的端口无效。许多端口根本不认识LDAP。我不知道除了sudo之外是否有其他端口提供侮辱用户的可选功能，但如果有这个功能，我*需要*它。'
- en: Why use separate options in *make.conf* as opposed to the command line? Precedence.
    Options applied using `WITH` override options set using `OPTIONS_SET`. In this
    example, I’ve enabled insults globally. If for some unfathomable reason I needed
    a particular port not to insult the user,^([3](footnote.xhtml#ch16fn3)) I could
    use `WITHOUT=INSULTS` on the command line when building the port to override the
    global default.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在*make.conf*中使用单独的选项而不是命令行？优先级。使用`WITH`设置的选项会覆盖使用`OPTIONS_SET`设置的选项。在这个例子中，我已经全局启用了侮辱功能。如果出于某种难以理解的原因，我需要某个端口不侮辱用户，^([3](footnote.xhtml#ch16fn3))
    我可以在构建该端口时在命令行使用`WITHOUT=INSULTS`来覆盖全局默认设置。
- en: '**/etc/make.conf and Single Ports**'
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/etc/make.conf 和单个端口**'
- en: Perhaps you want to build a particular port with a specific option, but you
    don’t want to specify it on the command line. Use the port category, an underscore,
    the port name, another underscore, and the `SET` variable in */etc/make.conf*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你想用特定选项构建某个端口，但又不想在命令行中指定它。可以在*/etc/make.conf*中使用端口类别、下划线、端口名称、另一个下划线和`SET`变量。
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While the port should cache the configuration, this would provide additional
    protection against fat-finger mistakes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然端口应该缓存配置，但这将提供额外的保护，防止因手误导致的错误。
- en: '**Setting Default Versions**'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置默认版本**'
- en: FreeBSD supports dozens of port customization choices. Not all of them are sensible
    as port options, though. Some options must be used across the entire ports collection
    to be effective. The most common example is the SSL library. You can build all
    of your ports with the base system SSL library, and things will work fine. You
    can build all the ports with an external SSL library and, again, the software
    works. Building some ports with the base system SSL and some with a third-party
    SSL leads to catastrophe. The same applies to, say, different versions of the
    PostgreSQL database server and the Python interpreter. Different SSL libraries
    combined with different database server versions creates the sort of debacle I
    really enjoy handing off to a junior sysadmin who desperately needs an unforgettable
    lesson in how shared libraries work.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD支持多种端口自定义选项。然而，并非所有选项都是合理的端口选项。有些选项必须在整个端口集合中使用才能生效。最常见的例子是SSL库。你可以使用基础系统的SSL库构建所有端口，一切正常。你也可以使用外部SSL库构建所有端口，同样软件可以正常工作。然而，如果部分端口使用基础系统的SSL，另一些使用第三方SSL，则会导致灾难。类似的情况也适用于例如PostgreSQL数据库服务器和Python解释器的不同版本。不同的SSL库与不同版本的数据库服务器结合，常常会引发我非常喜欢交给初级系统管理员的那种灾难，他们急需一次无法忘记的关于共享库如何工作的教训。
- en: The Ports Collection uses the `DEFAULT_VERSIONS` variable to list critical software
    that should be used as the default. This replaces older variables like `DEFAULT_MYSQL_VER`
    and `WITH_BDB_VER`. The only way to get the complete list of variables is to trawl
    through */usr/ports/Mk/*. The file *bsd.default-versions.mk*, *bsd.apache.mk*,
    and the files under *Mk/Uses* are notably useful.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 端口集合使用`DEFAULT_VERSIONS`变量列出应作为默认使用的关键软件。这替代了像`DEFAULT_MYSQL_VER`和`WITH_BDB_VER`这样的旧变量。获取完整的变量列表唯一的方法是通过*/usr/ports/Mk/*进行查找。*bsd.default-versions.mk*、*bsd.apache.mk*和*Mk/Uses*下的文件特别有用。
- en: Here, I’m telling the Ports Collection always to build ports with LibreSSL instead
    of the base system’s OpenSSL library and to use Python 3.7.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我告诉端口集合始终使用LibreSSL构建端口，而不是使用基础系统的OpenSSL库，并使用Python 3.7。
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I list each default version on a separate line and use the `+=` syntax to tell
    the ports system to add this to the list.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我将每个默认版本列在单独的一行，并使用`+=`语法告诉端口系统将其添加到列表中。
- en: I recommend setting default versions before building your first port. Otherwise,
    you’ll wind up rebuilding ports so that they link against your preferred libraries.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在构建第一个端口之前设置默认版本。否则，你最终会重建端口，以便它们链接到你偏好的库。
- en: Don’t mix prebuilt packages with ports built using an alternate `DEFAULT_``VERSIONS`.
    Programs built from packages will use the default libraries, while your ports
    will use your preferred libraries. If your system works afterword, it will be
    only by sheer accident.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将预构建的包与使用替代 `DEFAULT_``VERSIONS` 构建的端口混合使用。通过包构建的程序将使用默认的库，而你的端口将使用你首选的库。如果你的系统在之后能够正常工作，那也只是偶然的结果。
- en: '**Front-Loading Recursion**'
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**预加载递归**'
- en: Sometimes the interactivity in building a port isn’t the problem. Recursion
    is the problem.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，构建一个端口时的交互性并不是问题，递归才是问题。
- en: Suppose you’re building a big port, such as LibreOffice or GNOME. These ports
    had dozens or even hundreds of dependencies. Many of these ports require interactive
    configuration. Perhaps you decide to launch a KDE build before going to bed, thinking
    that you’ll wake up with the latest window manager or at least an amusing error
    message. Instead, you’ll rise to discover a dependency’s `make config` menu that’s
    been patiently awaiting your attention since 30 seconds after you walked away.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个大型端口，例如 LibreOffice 或 GNOME。这些端口有数十个甚至数百个依赖项。许多这些端口需要交互式配置。也许你决定在睡觉前启动一个
    KDE 构建，想着醒来后会看到最新的窗口管理器，或者至少是一个有趣的错误信息。相反，你会发现依赖项的 `make config` 菜单自你离开后 30 秒起就耐心地等待着你的关注。
- en: The point of building software from ports is that you can customize it. For
    these big builds, though, you really want to do all the customizations up front.
    That’s where make `config-recursive` comes in.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从端口构建软件的重点是你可以定制它。然而，对于这些大型构建，你确实希望在一开始就做所有的定制。这就是 `make config-recursive` 发挥作用的地方。
- en: The make `config-recursive` walks through the tree of required ports and runs
    `make config` on each and every one of them. You’ll spend a few minutes selecting
    options in each port or just hitting OK on the ones you don’t care about. Once
    you finish the recursive config, though, you can safely run `make install` on
    the port you actually want and go off to do other things. You’ll return to an
    installed port or a build failure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`make config-recursive` 会遍历所需端口的树，并对每一个端口运行 `make config`。你会花几分钟时间在每个端口中选择选项，或者仅在你不关心的端口上点击
    OK。一旦完成递归配置，你就可以安全地在你实际需要的端口上运行 `make install`，然后去做其他事情。等你回来时，你将看到一个已安装的端口或一个构建失败的结果。'
- en: Changing a port’s build options can add or remove dependencies. If you decide
    to enable, say, SNMP support in LibreOffice,^([4](footnote.xhtml#ch16fn4)) the
    port will need the proper SNMP library. The port for that library will need configuring.
    Re-run `make config-recursive` until none of your decisions change.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 改变一个端口的构建选项可以增加或删除依赖项。如果你决定启用 LibreOffice 中的 SNMP 支持，^([4](footnote.xhtml#ch16fn4))
    该端口将需要适当的 SNMP 库。该库的端口需要配置。重新运行 `make config-recursive`，直到你的所有决定不再变化。
- en: The ports system caches all your configuration choices. To remove that cache
    for a port and all its dependencies, run `make rmconfig-recursive`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 端口系统会缓存你所有的配置选择。要删除一个端口及其所有依赖项的缓存，可以运行 `make rmconfig-recursive`。
- en: If bandwidth timing is the problem, you can download all the distfiles required
    for all the dependencies with `make fetch-recursive`. This is useful if you’re
    in a place like Antarctica, where build time and server cooling is unlimited but
    you have internet only a few hours a day.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果带宽时延是问题，你可以通过 `make fetch-recursive` 下载所有依赖项所需的所有 distfiles。如果你身处像南极这样地方，那里构建时间和服务器冷却无限制，但你每天只有几个小时的互联网连接，这个方法会非常有用。
- en: '**Packaged Dependencies**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**打包依赖**'
- en: Some software has hundreds of dependencies, and you probably don’t want to build
    all of them. While I might want a custom Emacs build, I probably don’t want to
    build gmake and the latest GNU C compiler from source. The `make missing` command
    displays missing dependencies. You can use that command to pick and choose what
    you want to build.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有些软件有数百个依赖项，你可能并不想构建它们所有的部分。虽然我可能想要一个定制的 Emacs 构建，但我可能不想从源代码构建 gmake 和最新的 GNU
    C 编译器。`make missing` 命令会显示缺失的依赖项。你可以使用该命令挑选你想要构建的部分。
- en: If you don’t want to build any dependencies from source but install them all
    from packages instead, you can feed `make missing` into a `pkg` command.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想从源代码构建任何依赖项，而是希望从包中安装它们，你可以将 `make missing` 传递给 `pkg` 命令。
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If a package is available, it’ll be installed. The only things you’ll need to
    install from ports are those available only from ports.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有可用的包，它会被安装。你只需要从端口安装那些只能通过端口获取的东西。
- en: '**Port Flavors**'
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**端口风味**'
- en: Some ports have complicated dependencies. While you can build Ansible with Python
    2 or Python 3, an Ansible package that works with Python 2 is very different than
    one for Python 3\. *Flavors* is a mechanism for expressing these possibilities
    within a single port, and was very recently introduced into the Ports Collection.
    Flavors are not yet pervasive throughout the ports system, but at the time I write
    this, they’ve been implemented for Python, Perl, Qt, and Emacs. You can expect
    to see them more and more frequently.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一些端口有复杂的依赖关系。虽然你可以使用 Python 2 或 Python 3 来构建 Ansible，但一个支持 Python 2 的 Ansible
    软件包与支持 Python 3 的完全不同。*Flavors*是一种在单个端口中表达这些可能性的机制，最近才引入到 Ports 集合中。Flavors 目前还未在整个端口系统中普及，但在我写这篇文章时，它们已经在
    Python、Perl、Qt 和 Emacs 中实现。你可以预期它们会越来越频繁地出现在其他地方。
- en: To see if a port supports any flavors, go to the port directory and run `make
    -V FLAVORS`. Here, I see what flavors of the popular Python packaging toolkit
    Setuptools are available.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看一个端口是否支持任何不同的版本，可以进入端口目录并运行`make -V FLAVORS`。在这里，我查看了流行的 Python 打包工具 Setuptools
    支持的版本。
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: My current ports tree supports Python 2.7, 3.6, 3.5, and 3.4.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我当前的端口树支持 Python 2.7、3.6、3.5 和 3.4。
- en: To build Setuptools for a specific Python version, give the flavor on the command
    line.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定版本的 Python 构建 Setuptools，请在命令行中指定版本。
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you don’t specify a flavor, the port gets built with the current default
    Python. To set the default Python for your system, set `DEFAULT_VERSIONS` in *make.conf*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定版本，端口将使用当前默认的 Python 进行构建。要为系统设置默认的 Python，请在*make.conf*中设置`DEFAULT_VERSIONS`。
- en: '***Building Packages***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建软件包***'
- en: You can create a package from an installed port. You can then copy your customized
    port to other machines and install it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从已安装的端口创建一个软件包。然后，你可以将自定义的端口复制到其他机器并进行安装。
- en: Before creating the package, create the directory */usr/ports/packages*. The
    ports system puts built packages in that directory. Without a *packages* directory,
    the package winds up in the port directory and you wind up with package files
    scattered all over your filesystem.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建软件包之前，创建目录*/usr/ports/packages*。Ports 系统将构建好的软件包放入该目录。如果没有*packages*目录，软件包将会被放到端口目录中，导致软件包文件散布在文件系统各处。
- en: Use `make package` to create a package. If you want to package not only the
    current port but all its dependencies, run `make package-recursive`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make package`创建软件包。如果你想打包当前端口以及所有依赖项，可以运行`make package-recursive`。
- en: People who need a whole bunch of customized ports should consider setting up
    their own repositories with poudriere (discussed later this chapter), but one-off
    package builds are okay if you have special circumstances or you like saving trouble
    for later.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 需要大量定制端口的人应该考虑使用 poudriere 设置自己的仓库（本章稍后会讨论），但如果你有特殊情况或者希望省事，偶尔构建单独的软件包也是可以的。
- en: '***Uninstalling and Reinstalling Ports***'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***卸载和重新安装端口***'
- en: While you can use `pkg remove` to uninstall a port, you can also uninstall a
    port from the port directory. Running `make deinstall` in the port directory removes
    the program from the system but leaves the port compiled and ready to reinstall.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用`pkg remove`来卸载一个端口，但也可以从端口目录中卸载一个端口。在端口目录中运行`make deinstall`将程序从系统中删除，但会保留已编译的端口，随时可以重新安装。
- en: After uninstalling a port, the compiled program and source files still live
    under the *work* subdirectory in the port. Running `make reinstall` reinstalls
    the compiled program. You can uninstall and reinstall as many times as you like.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载端口后，已编译的程序和源文件仍然保存在端口的*work*子目录下。运行`make reinstall`将重新安装已编译的程序。你可以任意多次卸载和重新安装。
- en: '***Tracking Port Build Status***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跟踪端口构建状态***'
- en: 'How does the Ports Collection keep track of what’s already been done? If you
    can run `make extract` and then `make install`, how does FreeBSD know what it
    has already finished? The Ports Collection uses hidden files (files with a name
    beginning with a dot), or *cookies*, to track completed steps. See those files
    by listing all the files in the port’s *work* directory:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Ports 集合如何跟踪已完成的操作？如果你能运行`make extract`然后运行`make install`，那么 FreeBSD 如何知道已经完成了哪些步骤？Ports
    集合使用隐藏文件（以点开头的文件），也就是*cookie*，来跟踪已完成的步骤。可以通过列出端口的*work*目录中的所有文件来查看这些文件：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The file *.configure_done.sudo._usr_local* indicates that the `make configure`
    step is complete.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*.configure_done.sudo._usr_local*表示`make configure`步骤已经完成。
- en: On more than one occasion, after multiple `make install`/`deinstall` cycles,
    I’ve had a port refuse to reinstall itself. That’s generally caused by the hidden
    file indicating that the install has finished. Remove that file, and the reinstall
    can proceed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在多次执行`make install`/`deinstall`循环之后，我曾遇到过端口拒绝重新安装的情况。通常这是由隐藏文件造成的，指示安装已完成。删除该文件后，重新安装即可进行。
- en: '***Cleaning Up Ports***'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***清理端口***'
- en: Ports can take up a lot of disk space. Programs with many dependencies, like
    GNOME, KDE, and LibreOffice, can take dozens of gigabytes! Much of this resides
    in the port’s *work* directory, where the port puts the source code files and
    all the intermediate parts of the completed binaries. Once the port is installed,
    though, you no longer need those files.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 端口可能占用大量磁盘空间。像GNOME、KDE和LibreOffice这样的程序，由于其许多依赖，可能会占用数十GB的空间！大部分内容都存储在端口的*work*目录中，那里存放着源代码文件以及所有中间生成的二进制部分。然而，一旦端口安装完成，你就不再需要这些文件。
- en: Remove the port’s working files with `make clean`. This erases the *work* directory
    of the current port and all dependencies, so be sure you’re happy with your new
    program before doing this. You can also clean a port immediately upon install
    by running `make install clean`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make clean`删除端口的工作文件。这将删除当前端口及所有依赖的*work*目录，因此在执行此操作之前，请确保你对新程序感到满意。你还可以在安装后立即清理端口，方法是运行`make
    install clean`。
- en: You might also want to remove the original distfiles, stored in */usr/ports/distfiles*.
    The `make distclean` command removes the distfiles for the current port and all
    dependencies.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想删除存储在*/usr/ports/distfiles*中的原始distfiles。`make distclean`命令会删除当前端口及所有依赖的distfiles。
- en: To clean the entire ports tree, run `make clean -DNOCLEANDEPENDS` directly under
    */usr/ports*. The `-DNOCLEANDEPENDS` is optional, but it prevents the default
    recursive cleaning. Without it, you’ll clean some popular ports dozens or hundreds
    of times. While there are faster ways to remove every *work* directory in the
    ports tree, this one is directly supported by the FreeBSD Project.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要清理整个端口树，在*/usr/ports*目录下直接运行`make clean -DNOCLEANDEPENDS`。`-DNOCLEANDEPENDS`是可选的，但它防止了默认的递归清理。没有它，你将清理一些热门端口几十次或几百次。虽然有更快速的方法可以删除端口树中的每个*work*目录，但这个方法是FreeBSD项目直接支持的。
- en: '***Read-Only Ports Tree***'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***只读端口树***'
- en: Many people dislike having temporary files and even packages in */usr/ports*.
    You can move the various working directories to other parts of the filesystem
    to keep your */usr/ports* read-only except for updates.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人不喜欢在*/usr/ports*中保留临时文件甚至包文件。你可以将各种工作目录移动到文件系统的其他位置，从而保持*/usr/ports*只读，除了更新之外。
- en: Use the `WRKDIRPREFIX` option in *make.conf* to build ports in a separate directory.
    Many people will set this to a location like */usr/obj*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*make.conf*中的`WRKDIRPREFIX`选项在单独的目录中构建端口。许多人会将此设置为类似*/usr/obj*的位置。
- en: The `PACKAGES` option sets a new package directory other than */usr/ports/packages*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`PACKAGES`选项设置一个新的包目录，而不是*/usr/ports/packages*。'
- en: Finally, `DISTDIR` sets a location to store distfiles other than */usr/ports/distfiles*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`DISTDIR`设置一个存储distfiles的路径，除了*/usr/ports/distfiles*以外。
- en: On a related note, it’s possible to build ports and packages without being root,
    provided the permissions on these directories are set so that the builder can
    write to these directories. Only root can install software, however.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 相关地，尽管必须具有相应目录的写权限才能构建端口和包，但仍然可以在不是root用户的情况下进行构建。然而，只有root用户才能安装软件。
- en: '***Changing the Install Path***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更改安装路径***'
- en: Many environments have standards for how add-on software gets installed. I’ve
    been in organizations where */usr/local* is reserved for files specific to that
    machine and software installs in that directory are forbidden. Instead, software
    installs must go in */opt* or some other mandated location.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 许多环境都有关于附加软件安装的标准。我曾在一些组织中看到，*/usr/local*专用于该机器的特定文件，禁止将软件安装到该目录。相反，软件安装必须放入*/opt*或其他指定位置。
- en: Set an alternate installation location with the `LOCALBASE` and `PREFIX` variables.
    You could do this on the command line, but if you’re complying with an organization
    standard, use *make.conf* instead. Whichever you use, start by building pkg(8)
    itself.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LOCALBASE`和`PREFIX`变量设置备用安装位置。你可以在命令行中执行此操作，但如果你遵循组织标准，建议使用*make.conf*。无论哪种方式，都从构建pkg(8)本身开始。
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The port installs all of its files under this directory. For example, programs
    that normally go into */usr/local/bin* end up in */opt/bin*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该端口将所有文件安装到该目录下。例如，通常会放入*/usr/local/bin*的程序将会放入*/opt/bin*。
- en: Not every port can handle changing `LOCALBASE` and `PREFIX` from */usr/local*.
    Some software has hardcoded dependencies on */usr/local*, while others have undiscovered
    bugs. If a port chokes on changing the install path, file a PR (see [Chapter 24](ch24.xhtml#ch24)).
    Consider taking a look at the port to figure out why it choked. Submitting fixes
    like this is one of the easiest ways to get involved with FreeBSD.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不是每个端口都能处理从*/usr/local*更改`LOCALBASE`和`PREFIX`。一些软件对*/usr/local*有硬编码依赖，而其他软件则可能存在尚未发现的
    bug。如果某个端口在更改安装路径时出现问题，可以提交一个 PR（参见[第24章](ch24.xhtml#ch24)）。考虑检查该端口，找出问题的原因。像这样提交修复是参与
    FreeBSD 项目最简单的方式之一。
- en: '**Private Package Repositories**'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**私有软件包仓库**'
- en: Packages are great, until you need customized versions; then you need ports.
    Similarly, ports are great until you have dozens of machines that all need customized
    ports. What’s easy to build on one host is difficult to maintain on several and
    impossible across a large server farm. When you outgrow ports, you need packages.
    Customized packages, that is.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包很方便，直到你需要定制版本；这时你就需要端口。同样，端口也很有用，直到你有几十台机器都需要定制的端口。在一台主机上容易构建的东西，在多台主机上就很难维护，而在大规模服务器集群中几乎不可能。当你超越端口时，你需要软件包，定制的软件包。
- en: The FreeBSD project uses poudriere (pronounced *poo-DRE-er*) for building packages.
    Why poudriere? It’s French for *powderkeg*. The successor to the “tinderbox” tool,^([5](footnote.xhtml#ch16fn5))
    poudriere is a collection of shell scripts that leverage existing FreeBSD infrastructure,
    such as jails and tmpfs and the Ports Collection.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 项目使用 poudriere（发音为 *poo-DRE-er*）来构建软件包。为什么使用 poudriere？它是法语中的 *powderkeg*（火药桶）的意思。作为“tinderbox”工具的继任者，^([5](footnote.xhtml#ch16fn5))
    poudriere 是一组 shell 脚本，利用现有的 FreeBSD 基础设施，如监狱（jails）、tmpfs 和端口集合（Ports Collection）。
- en: Building packages that work across multiple systems is different than building
    software that works on the local host. Anything managed by human beings accumulates
    cruft. Once my desktop is more than a few months old, I’m pretty confident that
    some minor change I’ve made will make it subtly different than any newly installed
    system. Maybe I saved a shared library after an upgrade. Perhaps I installed something
    by hand and forgot about it. Gremlins could have tampered with the linker, I don’t
    know. The important thing is, my host isn’t pristinely identical to every other
    host running what’s supposed to be the same operating system. A port built and
    packaged on this host might include dependencies, libraries, or who knows what
    that will keep it from working on other hosts.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 构建跨多个系统可用的软件包与在本地主机上构建软件是不同的。任何由人类管理的东西都会积累杂物。当我的桌面使用超过几个月时，我相当自信某些我所做的小改动会让它与任何新安装的系统有所不同。也许我在升级后保存了一个共享库。也许我手动安装了一些东西并忘记了它。也许
    Gremlins（小怪物）篡改了链接器，我也不知道。重要的是，我的主机不再与每个运行相同操作系统的主机保持完美一致。一个在这台主机上构建和打包的端口可能包括依赖关系、库或其他什么，导致它无法在其他主机上运行。
- en: Poudriere evades this problem by building everything in jails it manages itself.
    A poudriere can build packages for any supported FreeBSD release older than the
    host it runs on. You can’t, say, build packages for 13.0-RELEASE on a 12.4-RELEASE
    host, because the kernel lacks the necessary interfaces.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere 通过在它自己管理的监狱（jails）中构建所有内容，避免了这个问题。一个 poudriere 可以为任何支持的 FreeBSD 版本构建软件包，即使该版本比其运行的主机版本要旧。比如，你不能在
    12.4-RELEASE 主机上为 13.0-RELEASE 构建软件包，因为内核缺少必要的接口。
- en: With poudriere, you can build packages on one host and distribute them among
    all of your servers. While poudriere includes many advanced features, getting
    a basic repository running isn’t hard at all.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 poudriere，你可以在一台主机上构建软件包，并在所有服务器之间分发它们。虽然 poudriere 包含许多高级功能，但启动一个基本的仓库并不困难。
- en: '***Poudriere Resources***'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Poudriere 资源***'
- en: Package building takes system resources. You can restrict how many processors
    poudriere uses during builds, which helps reduce its memory use. While poudriere
    itself is only a few megabytes, however, the jails and build environments can
    take up a whole lot of disk space. The official poudriere docs recommend allocating
    at least 4GB of disk for each jail and 3GB of disk space for the ports tree. I
    normally use about 1GB for each using ZFS, but I encourage you to err on the side
    of following the recommendations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件包需要系统资源。你可以限制 poudriere 在构建期间使用的处理器数量，这有助于减少其内存使用。然而，虽然 poudriere 本身只有几兆字节，但监狱（jails）和构建环境可能会占用大量磁盘空间。官方的
    poudriere 文档建议为每个监狱分配至少 4GB 的磁盘空间，为端口树（ports tree）分配 3GB 的磁盘空间。我通常在使用 ZFS 时为每个监狱分配大约
    1GB，但我建议你还是按照推荐配置来分配空间。
- en: Poudriere leverages ZFS clones and snapshots to build jails, vastly reducing
    the needed disk space and, increasingly, performance. You can run poudriere on
    UFS, but it will use more space and run more slowly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere 利用 ZFS 克隆和快照来构建 jail，大大减少了所需的磁盘空间，并且越来越提高了性能。你可以在 UFS 上运行 poudriere，但它会占用更多空间并且运行得更慢。
- en: Of greater concern is the space needed to build the ports. My web servers run
    only a few dozen pieces of software, and many of these are tiny. Poudriere needs
    only a few gigabytes of disk to build them. If you’re building hundreds or thousands
    of packages, you need a whole bunch of disk. How much? Well, are you building
    GnuPG or are you building LibreOffice? To get an estimate, build but don’t clean
    all of your packages using ports, and then see how big */usr/ports* gets.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是构建端口所需的空间。我的 Web 服务器只运行几十个软件包，其中许多非常小。Poudriere 只需要几GB的磁盘来构建它们。如果你在构建成百上千个软件包，你需要大量的磁盘空间。需要多少？嗯，你是在构建
    GnuPG 还是构建 LibreOffice？为了估算，先构建但不要清理你所有的端口软件包，然后查看 */usr/ports* 的大小。
- en: Each host should use only one package repository. Yes, it’s technically possible
    to build your local packages and install them alongside packages from the official
    FreeBSD repository. The problem is that packages are interdependent. You could
    have your host check your repository first and then fall back to the official
    repository. The official repository updates every few days, however. The time
    between updates varies with the hardware available in the build cluster, but a
    few days is a good guess. Are the updates to your poudriere perfectly synchronized
    with the official repository’s slightly irregular updates? Is your ports tree
    exactly identical to the one used on the ports cluster? Packages are meant to
    work as an integrated collection, not a pile of stuff from two different collections.
    Ask any Linux administrator for their horror stories about packages installed
    from multiple repositories and then commit to building all your own packages.
    Plan your disk usage accordingly.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主机应该只使用一个软件包仓库。是的，从技术上讲，你可以构建本地软件包并将它们与官方 FreeBSD 仓库中的软件包一起安装。问题是软件包之间是相互依赖的。你可以让主机首先检查你的仓库，然后再回退到官方仓库。然而，官方仓库每隔几天就会更新。更新之间的时间取决于构建集群中可用的硬件，但几天是一个不错的估计。你的
    poudriere 更新是否与官方仓库的稍微不规律的更新完全同步？你的端口树是否与端口集群使用的完全一致？软件包应该作为一个集成集合来工作，而不是来自两个不同集合的一堆东西。问问任何
    Linux 管理员，他们关于从多个仓库安装软件包的恐怖故事，然后决定自己构建所有的软件包。根据需要合理规划磁盘使用。
- en: Finally, start by building your packages on a host of the same architecture
    that you intend to install them on. If you’re building packages for arm64 systems,
    use an arm64 host for poudriere. You can build i386 packages on amd64, but amd64
    hardware is literally designed to run i386 code. Once you’re comfortable with
    poudriere, you can use the qemu-user-static package to cross-build packages for
    slow platforms.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，首先在你打算安装软件包的相同架构的主机上构建软件包。如果你在为 arm64 系统构建软件包，请使用 arm64 主机来运行 poudriere。你可以在
    amd64 上构建 i386 软件包，但 amd64 硬件设计本身就可以运行 i386 代码。一旦你对 poudriere 熟悉了，你可以使用 qemu-user-static
    包来为较慢的平台交叉构建软件包。
- en: Can you add poudriere to an existing production host? Maybe. A few poudriere
    runs on a test system will provide insight into the resources your environment
    needs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 poudriere 添加到现有的生产主机吗？也许可以。在测试系统上运行几次 poudriere 可以帮助你了解你的环境所需的资源。
- en: '***Installing and Configuring Poudriere***'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装和配置 Poudriere***'
- en: Poudriere has no build options, so install it from packages.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere 没有构建选项，因此从软件包中安装它。
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Configure poudriere in */usr/local/etc*. You’ll find a directory for configuring
    specific package builds, *poudriere.d*, but we’ll start with the generic configuration
    file, *poudriere.conf*. Here’s where you’ll tell poudriere how to behave. While
    you can customize directories and paths, we’ll stick with the defaults.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */usr/local/etc* 中配置 poudriere。你会发现一个用于配置特定软件包构建的目录，*poudriere.d*，但我们将从通用配置文件
    *poudriere.conf* 开始。在这里，你将告诉 poudriere 如何运行。虽然你可以自定义目录和路径，但我们将使用默认设置。
- en: You must tell poudriere where to download FreeBSD install files from by setting
    the `FREEBSD_HOST` variable. If you don’t have a local install mirror, use the
    default of `download.freebsd.org`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须通过设置 `FREEBSD_HOST` 变量来告诉 poudriere 从哪里下载 FreeBSD 安装文件。如果没有本地安装镜像，请使用默认的
    `download.freebsd.org`。
- en: '[PRE27]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Poudriere includes ZFS-aware features. ZFS isn’t necessary for poudriere, of
    course, but if it’s run on ZFS, it will create, clone, and destroy datasets as
    needed. Running on UFS won’t hinder poudriere, but copying files is slower than
    cloning. If you’re using UFS, uncomment the `NO_ZFS=yes` configuration option.
    That’s it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere包含ZFS支持功能。当然，ZFS对poudriere并非必需，但如果在ZFS上运行，它会根据需要创建、克隆和销毁数据集。在UFS上运行不会妨碍poudriere，但复制文件的速度比克隆要慢。如果你使用UFS，取消注释`NO_ZFS=yes`配置选项。就这样。
- en: ZFS users need to specify the ZFS pool poudriere will use. My main operating
    install might be on the pool *zroot*, but that pool’s on a pair of flash SATADOMs
    that I don’t want to abuse too badly. I have a *scratch* pool specifically for
    churning data. Set `ZPOOL` in *poudriere.conf*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ZFS用户需要指定poudriere将使用的ZFS池。我的主操作安装可能在*zroot*池上，但该池位于一对我不想过度使用的闪存SATADOM上。我有一个专门用于处理数据的*scratch*池。在*poudriere.conf*中设置`ZPOOL`。
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before your first poudriere run, create a */usr/local/poudriere* dataset. You’ll
    be happier.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在你第一次运行poudriere之前，创建一个*/usr/local/poudriere*数据集。这样你会更高兴。
- en: All of poudriere’s work files get put under */usr/local/poudriere*. If you’re
    using a separate ZFS pool, the mount points for the datasets on that pool get
    set to various locations under */usr/local/poudriere*. On UFS, it’s a directory
    like any other.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 所有poudriere的工作文件都会放在*/usr/local/poudriere*下。如果你使用的是单独的ZFS池，该池上数据集的挂载点将被设置为*/usr/local/poudriere*下的不同位置。在UFS上，它是一个像其他目录一样的目录。
- en: My examples run on ZFS because I can. Poudriere’s output might look slightly
    different on UFS systems, but the commands you run are identical no matter the
    underlying filesystem.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我的示例运行在ZFS上，因为我可以。poudriere的输出在UFS系统上可能看起来稍有不同，但无论底层文件系统是什么，你运行的命令都是相同的。
- en: We’ll look at a few poudriere customizations later, but this will get you started.
    Now create jails for your packages.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将看看一些poudriere的自定义设置，但这些足以让你入门。现在，创建用于你的包的jails。
- en: '***Poudriere Jail Creation***'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Poudriere Jail创建***'
- en: 'Poudriere can create jails from a whole bunch of different sources. You can
    download from a few different sources, build from a source tree, and more. Read
    poudriere(8) for a full list. Here, I’ll install three different jails from my
    three favorite methods: from the internet, from an install image, and from my
    custom-built */usr/src* and */usr/obj*. All the installation commands use the
    same general syntax. Some installation methods will add a new option, but everything
    starts with these.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere可以从各种不同来源创建jails。你可以从不同的来源下载，或者从源树中构建，等等。请查阅poudriere(8)以获取完整的列表。在这里，我将通过我最喜欢的三种方法安装三个不同的jails：从互联网下载，从安装镜像安装，以及从我自定义构建的*/usr/src*和*/usr/obj*安装。所有安装命令都使用相同的通用语法。某些安装方法会添加新选项，但一切都从这些命令开始。
- en: '[PRE29]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `jail` subcommand tells poudriere to work on a jail. The `-c` flag means
    create, and `-j` lets you assign a name to the jail. A jail can have any name
    that doesn’t include a period. I name my poudriere jails after the architecture
    and release, substituting a dash for any dots. This gives me jails like *amd64-12-0*,
    *amd64-11-4*, and so on. The `-v` flag takes one argument, the FreeBSD version
    from `uname -r` but without any patch level information. If your hosts are currently
    running 12.3-RELEASE-p20, just use 12.3-RELEASE. The patch level will change in
    subsequent poudriere runs—yes, poudriere applies security patches to jails.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`jail`子命令告诉poudriere处理某个jail。`-c`标志表示创建，`-j`允许你为jail分配一个名称。一个jail可以有任何不包含句点的名称。我将我的poudriere
    jails命名为架构和版本号，用连字符替代任何句点。这让我得到了像*amd64-12-0*、*amd64-11-4*这样的jails。`-v`标志需要一个参数，即`uname
    -r`中的FreeBSD版本，但不包括任何补丁级别信息。如果你的主机当前运行的是12.3-RELEASE-p20，只需使用12.3-RELEASE即可。补丁级别会在随后的poudriere运行中发生变化——是的，poudriere会将安全补丁应用到jails中。'
- en: '**Install Jail from Network**'
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从网络安装Jail**'
- en: 'The default jail install grabs the FreeBSD software from the download site
    specified in *poudriere.conf*. FreeBSD’s main download site is geographically
    load balanced, so there’s no need to use any other site unless you have your own
    mirror. Here, I create a jail called *amd64-11-1* for building 11.1 packages:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的jail安装从*poudriere.conf*中指定的下载站点获取FreeBSD软件。FreeBSD的主下载站点是地理负载均衡的，因此除非你有自己的镜像站点，否则不需要使用其他站点。在这里，我创建了一个名为*amd64-11-1*的jail，用于构建11.1包：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Poudriere goes to the website and starts downloading the distribution files.
    Once it has all the files locally, it copies */etc/resolv.conf* into the jail
    and runs `freebsd-update` to get all the latest security patches. The poudriere
    run ends with:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere会访问网站并开始下载发行文件。一旦它将所有文件下载到本地，它会将*/etc/resolv.conf*复制到监狱中，并运行`freebsd-update`以获取所有最新的安全补丁。poudriere的运行以以下内容结束：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can now configure this jail.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以配置这个监狱了。
- en: '**Install Jail from Media**'
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从媒体安装监狱**'
- en: Downloading from the internet is fine, but what if you have the install media
    locally? Why redownload what you already have sitting on an ISO or a memory stick
    image? Extract those distribution files onto your local hard drive and you can
    use them for as many jails as you need. For an ISO, use tar(1).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从互联网上下载没问题，但如果你本地有安装介质怎么办？为什么要重新下载你已经保存在ISO或内存棒镜像中的内容呢？将这些发行文件提取到本地硬盘上，你可以用它们来创建你需要的任意数量的监狱。对于ISO文件，使用tar(1)。
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A memory stick image is slightly more complicated; sadly, libarchive can’t open
    disk images yet. You must attach the image to a memory device and mount it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 内存棒镜像稍微复杂一些；遗憾的是，libarchive目前无法打开磁盘镜像。你必须将镜像附加到内存设备并挂载它。
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you try to mount */dev/md0*, you’ll get an error. It’s not a filesystem;
    it a partitioned disk image. Identify the partitions on the disk.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试挂载*/dev/md0*，会遇到错误。这不是一个文件系统；它是一个分区磁盘镜像。识别磁盘上的分区。
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Partition 3 is a UFS filesystem. That looks promising.^([6](footnote.xhtml#ch16fn6))
    Mount it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 分区3是一个UFS文件系统。这看起来很有前景。^([6](footnote.xhtml#ch16fn6)) 挂载它。
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The distribution files are now available in */mnt/usr/freebsd-dist*. I could
    copy them out or just install from their current location.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 发行文件现在可在*/mnt/usr/freebsd-dist*中找到。我可以将它们复制出来，或者直接从当前位置安装。
- en: Here, I create a jail for building FreeBSD 11.0 packages. It’ll be called *amd64-11-0*
    and use the files from the mounted memory stick. Use the `-m` flag to specify
    where poudriere should grab the files from.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我创建了一个用于构建FreeBSD 11.0软件包的监狱。它将被命名为*amd64-11-0*，并使用从挂载的内存棒获取的文件。使用`-m`标志来指定poudriere应从何处获取文件。
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the argument to `-m` is a URL. I could specify a website here, but
    `file://` is a perfectly valid type of URL. On a Unix host, a `file://` URL has
    a third slash to indicate the filesystem root.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`-m`的参数是一个URL。我可以在这里指定一个网站，但`file://`是完全有效的URL类型。在Unix主机上，`file://` URL通过第三个斜杠来表示文件系统根目录。
- en: '**Install Jail from a Local Build**'
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从本地构建安装监狱**'
- en: I run -current and regularly build from source. I want to build packages for
    my custom build, so the jail needs a version of FreeBSD that matches my host.
    The easy way to get that is to install from the same */usr/src* you built the
    host from. (You could also use Subversion to download a fresh copy of the source
    code you used to build this system, but that requires understanding Subversion.)
    Use -m to give the location to a source directory.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我运行的是-current版本，并定期从源代码构建。我想为我的自定义构建创建软件包，因此监狱需要一个与我的主机匹配的FreeBSD版本。获取它的简单方法是从构建主机时使用的相同*/usr/src*安装。（你也可以使用Subversion下载你用来构建该系统的源代码的新副本，但这需要理解Subversion。）使用-m来指定源目录的位置。
- en: '[PRE37]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Poudriere runs `make installworld` on the prebuilt world in */usr/obj* to create
    your jail. It won’t run `freebsd-update` because -current doesn’t support it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere在*/usr/obj*中预构建的世界上运行`make installworld`来创建你的监狱。它不会运行`freebsd-update`，因为-current版本不支持它。
- en: We’ll use the *amd64-current* jail in all future examples.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在所有未来的示例中使用*amd64-current*监狱。
- en: '**Viewing Jails**'
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查看监狱**'
- en: To see all the jails poudriere has set up, run `poudriere jail -l`. The output
    is very wide, so I can’t reproduce it in this book, but you’ll see the jail’s
    name, the installed version of FreeBSD, the hardware architecture, the method
    used to install, the timestamp of the installation, and the path to the jail.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看poudriere设置的所有监狱，请运行`poudriere jail -l`。输出非常宽，因此我无法在本书中复现，但你会看到监狱的名称、安装的FreeBSD版本、硬件架构、安装方法、安装时间戳以及监狱的路径。
- en: '***Install a Poudriere Ports Tree***'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装Poudriere端口树***'
- en: Poudriere can use different ports trees for different builds. You might use
    a quarterly ports branch for one host, the current ports tree for another, and
    last year’s ports tree for a third. (You need to use Subversion to extract particular
    ports trees from the FreeBSD mirrors, so we won’t cover them.) The possibility
    of supporting multiple ports trees means you must assign a name to each ports
    tree you do install. Multiple jails can share a ports tree. The default is the
    current ports tree.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Use the `poudriere ports` subcommand for all ports-related actions. The `-c`
    flag tells poudriere to create a ports tree, and the `-p` flag lets you assign
    the name.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Poudriere leverages portsnap(8), which we discussed earlier this chapter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: If you install multiple ports trees, view them with `poudriere ports -l`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '***Configuring Poudriere Ports***'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The whole point of building a port is to customize it. You don’t need to build
    the whole ports tree as packages, though—not unless you’re running the FreeBSD
    package building cluster or something analogous! You have to tell poudriere which
    ports to build. Once you have that list, you might need specific options for certain
    ports, but you might also need global options. You’d normally use */etc/make.conf*
    to set those options, but you don’t want poudriere to use the system’s settings.
    Poudriere needs an isolated *make.conf*. Similarly, you might use `make config`
    to set up a port, but how can you do that in poudriere?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '**The Package List**'
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Start by defining the list of packages you want poudriere to build. This list
    usually goes in the file */usr/local/etc/poudriere.d/pkglist*, although you can
    put it anywhere you want. Specify each port by its category and directory. To
    build poudriere itself, use an entry like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The difficult part here is establishing a base package set. You have to build
    all the packages the host needs. A host might need dozens or hundreds of packages.
    Do you really need all of those packages? How did all of those packages get on
    this system anyway?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you probably didn’t choose to install all of those packages. You installed
    an application like Emacs or Apache or LibreOffice, and that application dragged
    in all those dependencies. You care only about those dependencies as they affect
    the software you want. If LibreOffice loses a dependency, you don’t want poudriere
    to build that dependency anymore. Poudriere automatically builds and packages
    dependencies. All you need to specify is the application you want, and let poudriere
    do the rest.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Use pkg-query(8) to get a list of all the nonautomatically installed software
    on one of your production systems.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Use this as a base for your package list. Review it for unneeded stuff. Get
    a similar list from your other production hosts. Use them to assemble your repository’s
    package list.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '**Poudriere make.conf**'
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Poudriere assembles a unique *make.conf* for each jail from files in */usr/local/etc/poudriere.d/*.
    The file */usr/local/etc/poudriere.d/make.conf* contains the global *make.conf*
    options that you want set for all of your jails. Other *make.conf* files can override
    those settings, as discussed in poudriere(8), but we’ll focus on per-jail *make.conf*
    files.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere 为每个监狱环境从 */usr/local/etc/poudriere.d/* 目录中的文件中组装一个独特的 *make.conf*
    文件。文件 */usr/local/etc/poudriere.d/make.conf* 包含了您希望为所有监狱环境设置的全局 *make.conf* 选项。其他
    *make.conf* 文件可以覆盖这些设置，正如 poudriere(8) 中所述，但我们将专注于每个监狱环境的 *make.conf* 文件。
- en: 'Suppose I want LDAP everywhere across my enterprise. Poudriere’s */usr/local/etc/poudriere.d/make.conf*
    would contain:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我希望在我的整个企业中都使用 LDAP。Poudriere 的 */usr/local/etc/poudriere.d/make.conf* 文件将包含：
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Hosts running my custom FreeBSD build all use LibreSSL, though. I would create
    a separate *make.conf* just for that jail, named *amd64-current-make.conf*. It
    would contain the LibreSSL configuration.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我所有运行自定义 FreeBSD 构建的主机都使用 LibreSSL。我会为该监狱环境创建一个单独的 *make.conf* 文件，命名为 *amd64-current-make.conf*。该文件将包含
    LibreSSL 配置。
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: More specific files override general files. Settings in the per-jail files override
    poudriere’s global *make.conf*. I could turn off LDAP on this one jail even as
    I enable LibreSSL.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体的文件会覆盖一般文件。每个监狱环境文件中的设置会覆盖 poudriere 的全局 *make.conf*。即使启用了 LibreSSL，我也可以关闭这个监狱环境中的
    LDAP。
- en: '**Running make config**'
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行 make config**'
- en: Use `poudriere options` to run `make config` for your jail. Each combination
    of jail and ports tree can have its own unique port options, so you need to specify
    them on the command line. You must specify the jail with `-j`, the name of the
    ports tree with `-p`, and the package file with `-f`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `poudriere options` 来为您的监狱环境运行 `make config`。每个监狱环境和端口树的组合可以有自己独特的端口选项，因此您需要在命令行中指定它们。您必须使用
    `-j` 指定监狱环境，使用 `-p` 指定端口树名称，使用 `-f` 指定软件包文件。
- en: '[PRE43]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Poudriere figures out which ports actually get built and all their dependencies.
    It runs you through `make config` for every one of them.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere 会计算出哪些端口实际被构建以及它们的所有依赖关系。它会为每个端口运行 `make config`。
- en: Take note of the options you select; should some of those go into the global
    or per-jail *make.conf*? Setting them as defaults can save you trouble in future
    poudriere runs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 记下您选择的选项；如果其中的一些应该放入全局或每个监狱环境的 *make.conf* 中呢？将它们设置为默认值可以在未来的 poudriere 运行中为您节省麻烦。
- en: You can now build your package repository.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以构建您的软件包仓库。
- en: '***Running Poudriere***'
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行 Poudriere***'
- en: The `poudriere bulk` subcommand builds packages in bulk. Use -j to specify the
    jail, -p to give the ports tree name, and -f to specify the package list file.
    (Yes, those are the same flags as configuring a port; it’s like the poudriere
    designers wanted to be consistent or something.)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`poudriere bulk` 子命令批量构建软件包。使用 -j 指定监狱环境，-p 给出端口树名称，-f 指定软件包列表文件。（是的，这些和配置端口时使用的标志相同；好像
    poudriere 设计者想保持一致性一样。）'
- en: '[PRE44]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Poudriere fires up the jail, mounts all the ports, copies the various configuration
    files into the jail, decides what order to build stuff in, and starts building.
    You’ll see the name of each port as it starts building.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere 启动监狱环境，挂载所有端口，将各种配置文件复制到监狱环境中，决定构建的顺序，并开始构建。您将看到每个端口开始构建时的名称。
- en: Some of those port builds might run quite a while. Hit CTRL-T to get the current
    status, or check the logs to see the current status.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一些端口构建可能需要很长时间。按 CTRL-T 获取当前状态，或检查日志以查看当前状态。
- en: 'At the end of the build, you’ll see the list of any ports that get built and
    a list of ports that failed to build. Here are the results from an itty-bitty
    pkglist:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 构建结束时，您将看到已构建的端口列表和未能构建的端口列表。以下是来自一个小型 pkglist 的结果：
- en: '[PRE45]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The ports `pkg`, `pkgconf`, and `libressl` built fine. They might not run, but
    the ports collection could build and package them. The `obhttpd` package did not
    build, however. If this package is critical, I’ll want to fix this problem before
    letting my clients use this repository.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg`、`pkgconf` 和 `libressl` 端口构建正常。它们可能无法运行，但端口集合能够构建并打包它们。然而，`obhttpd` 包未能构建。如果该包至关重要，我需要在允许我的客户使用这个仓库之前解决这个问题。'
- en: Let’s look at the problems first and then examine the repository.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看问题，然后再检查仓库。
- en: '**Problem Ports**'
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**问题端口**'
- en: After the list of ports that gets built, you’ll see a message pointing out where
    to find the logs.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建的端口列表之后，您将看到一条消息，指示在哪里可以找到日志。
- en: '[PRE46]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The logs go in a directory named after the jail and the ports tree, with a subdirectory
    by date. If you don’t want to type out the date, there’s a convenient *latest*
    that takes you straight to the most recent log directory.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件会放在一个以监狱和端口树命名的目录中，并按日期存放子目录。如果你不想手动输入日期，可以使用方便的 *latest* 目录，它会直接带你到最近的日志目录。
- en: '[PRE47]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You won’t find only logs here; you’ll find a website. If you configure your
    web server to serve up */usr/local/poudriere/data*, you can use a web browser
    to check poudriere builds (as well as to serve repositories to clients). The *logs*
    subdirectory here contains poudriere’s build logs for every port. If you don’t
    want to sort through those, the *logs/errors* subdirectory contains only the logs
    for the failed builds.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不仅有日志文件；还有一个网站。如果你将你的 Web 服务器配置为提供 */usr/local/poudriere/data* 目录，你可以使用 Web
    浏览器检查 poudriere 构建（以及将仓库提供给客户端）。此处的 *logs* 子目录包含每个端口的 poudriere 构建日志。如果你不想一一查看这些日志，可以在
    *logs/errors* 子目录中找到仅包含构建失败日志的文件。
- en: 'Now you need to do something terribly radical: read the error log. Perhaps
    poudriere couldn’t fetch the distfile. Maybe the host ran out of disk space. Perhaps
    something truly weird happened. Or, maybe, the port is actually broken with the
    build options you chose. Not all ports are built with all options all the time;
    it’s very easy for a port maintainer to miss that a rarely used function is busted.
    Remember, though, that poudriere is FreeBSD’s official port-building mechanism.
    If a port fails to build under poudriere, it’s busted and you should consider
    filing a bug (see [Chapter 24](ch24.xhtml#ch24)).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要做一些非常激进的事情：阅读错误日志。也许 poudriere 无法获取 distfile，可能主机磁盘空间不足，或者发生了一些非常奇怪的事情。或者，也许端口本身与所选的构建选项不兼容。并不是所有端口都始终用所有选项构建；端口维护者很容易忽略一些少用的功能可能会出错。不过要记住，poudriere
    是 FreeBSD 的官方端口构建机制。如果某个端口在 poudriere 下构建失败，那它就是坏的，你应该考虑提交一个 bug（见 [第 24 章](ch24.xhtml#ch24)）。
- en: '**Package Repository**'
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**软件包仓库**'
- en: Find your completed packages under */usr/local/poudriere/data/packages*. Each
    combination of jail and ports tree gets its own subdirectory. I build this set
    of packages on the jail amd64-current using the ports tree head, so my new repository
    is in */usr/local/poudriere/data/packages/amd64-current-head*. You’ll find the
    catalogs as the various *.txz* files and the *Latest* subdirectory for the most
    recent packages.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */usr/local/poudriere/data/packages* 目录下查找已完成的包。每个监狱和端口树的组合都有自己的子目录。我在 amd64-current
    监狱上使用端口树的主干构建这组包，因此我的新仓库位于 */usr/local/poudriere/data/packages/amd64-current-head*。你会找到各种
    *.txz* 文件和 *Latest* 子目录，其中存放最新的包。
- en: Congratulations. You have a private package repository. Now to get your clients
    to use it.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你。你已经拥有了一个私有软件包仓库。接下来，应该让你的客户端使用它。
- en: '***Using the Private Repository***'
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用私有仓库***'
- en: The easiest way to use a private repository is on the poudriere host itself.
    Local repository configurations for pkg(8) go in */usr/local/etc/pkg/repos*. That
    directory doesn’t exist by default, so create it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私有仓库的最简单方法是在 poudriere 主机上。pkg(8) 的本地仓库配置文件位于 */usr/local/etc/pkg/repos*。该目录默认不存在，因此需要创建它。
- en: '[PRE48]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Create a *FreeBSD.conf* file therein. Local repository configurations augment
    or override the system defaults—that’s built into UCL. We need to add one setting
    to the default repository configuration in */etc/pkg/FreeBSD.conf*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中创建一个 *FreeBSD.conf* 文件。本地仓库配置会增强或覆盖系统默认设置——这是 UCL 内置的功能。我们需要在默认仓库配置文件 */etc/pkg/FreeBSD.conf*
    中添加一个设置。
- en: '[PRE49]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This leaves the file */etc/pkg/FreeBSD.conf* untouched but sets `enabled` to
    `no` for the repository named *FreeBSD*. The default repository is no more.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会保留 */etc/pkg/FreeBSD.conf* 文件不变，但会将名为 *FreeBSD* 的仓库的 `enabled` 设置为 `no`。默认仓库不再使用。
- en: Now create a separate configuration file for our custom repository. I’m naming
    this repository *amd64-current*, after the jail.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为我们的自定义仓库创建一个单独的配置文件。我将这个仓库命名为 *amd64-current*，与监狱的名称一致。
- en: '[PRE50]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Your host is now ready to use those packages. You’ll want to forcibly reinstall
    all the current packages to stop using the FreeBSD repository’s versions and use
    your local versions.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你的主机现在已经准备好使用这些包了。你需要强制重新安装所有当前的包，以停止使用 FreeBSD 仓库的版本，并使用你本地的版本。
- en: '[PRE51]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The pkg(8) program will download the repository catalog, but the download will
    look a little different than usual.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: pkg(8) 程序将下载仓库目录，但下载的过程会与平时有所不同。
- en: '[PRE52]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Compared to the official repository catalog, this catalog is pretty tiny. It
    extracts the catalog and metadata in one second. The last line shows that this
    repository has only 62 packages. You’re using the new repository. Install your
    custom packages!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与官方仓库目录相比，这个目录相当小。它提取目录和元数据只需要一秒钟。最后一行显示该仓库只有 62 个软件包。你正在使用新的仓库。安装你的自定义软件包！
- en: '**Remote Custom Repositories**'
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**远程自定义仓库**'
- en: The whole point of a package repository is that you build packages once and
    deploy them everywhere. You could use a read-only NFS export to provide packages
    to your local machines, but the internet loves to abuse publicly accessible NFS
    servers. The *pkg.conf* file defines the repository location with a URL. While
    I used a file for the URL, there’s no reason this repository can’t use a website
    instead. Install a web server on your package builder, and have it offer the contents
    of */usr/local/poudriere/data/packages* to your other servers. Then give the other
    hosts that should use that repo their own repository configuration.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 包仓库的核心理念是你只需构建软件包一次，然后将其部署到各地。你可以使用只读 NFS 导出将软件包提供给本地机器，但互联网常常会滥用公开可访问的 NFS
    服务器。*pkg.conf* 文件通过 URL 定义仓库位置。虽然我使用了文件作为 URL，但没有理由这个仓库不能改为使用网站。你可以在包构建器上安装一个
    web 服务器，让它提供 */usr/local/poudriere/data/packages* 中的内容给其他服务器。然后，将应该使用该仓库的其他主机配置其自己的仓库配置。
- en: '[PRE53]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: All our machines now get an identical set of customized ports. This change gets
    my flunky Bert out of building ports on a dozen machines and into polishing my
    car.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的机器现在都得到了一套相同的定制端口。这一改变让我的手下 Bert 不再需要在十几台机器上构建端口，而是开始为我擦车。
- en: '**All Poudrieres, Large and Small**'
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**所有 Poudriere，无论大小**'
- en: Poudriere performs pretty well by default but has a couple options that can
    help on small and large systems.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere 默认运行得相当好，但有几个选项可以在小型和大型系统上提供帮助。
- en: '***Small Systems***'
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***小型系统***'
- en: If you have a resource-constrained host, you don’t want to let poudriere run
    amok. Here’s a couple *poudriere.conf* options to restrain it.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一台资源受限的主机，你不希望让 poudriere 随意运行。这里有一些 *poudriere.conf* 选项来限制它。
- en: Generally speaking, if you can build a port on a host, poudriere can build that
    port. What you don’t want is for multiple simultaneous poudriere runs to overwhelm
    the host. Poudriere normally runs the same number of simultaneous processes as
    the number of processors in the host. Use the `PARALLEL_JOBS` option to limit
    the number of parallel builds.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你能在主机上构建一个端口，poudriere 就能构建该端口。你不希望的是多个同时运行的 poudriere 进程淹没主机。Poudriere
    通常会运行与主机处理器数量相同的并发进程。使用 `PARALLEL_JOBS` 选项来限制并行构建的数量。
- en: '[PRE54]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Other restrictions, like reducing the amount of memory a poudriere build can
    use, are less useful than you might think. A piece of software takes as much memory
    to build as it requires. Building LibreOffice with only 1GB of RAM will not end
    well.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 其他限制，比如减少 poudriere 构建可以使用的内存，比你想象的要少用。软件构建所需的内存与它所需的相同。仅用 1GB 内存构建 LibreOffice
    结果不会好。
- en: Remember that you can also globally deprioritize poudriere runs with nice(1),
    as discussed in [Chapter 21](ch21.xhtml#ch21).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你也可以通过 nice(1) 全局降低 poudriere 进程的优先级，正如 [第21章](ch21.xhtml#ch21) 所讨论的那样。
- en: '***Large Systems***'
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***大型系统***'
- en: Poudriere can take advantage of beefy systems to accelerate builds. You can’t
    speed up the disk, but you can take advantage of memory to use tmpfs(5) for critical
    parts of the build. Set the `USE_TMPFS` option to use memory for the working directory.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere 可以利用强大的系统加速构建。你不能加速磁盘，但可以利用内存使用 tmpfs(5) 来处理构建中的关键部分。设置 `USE_TMPFS`
    选项以使用内存作为工作目录。
- en: '[PRE55]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can use tmpfs(5) for parts of the build beyond the working directory, but
    few of us have *that* much memory. Read the *poudriere.conf.sample* for details.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 tmpfs(5) 来存放工作目录之外的部分构建内容，但我们中的少数人拥有*那样*多的内存。有关详情，请阅读 *poudriere.conf.sample*。
- en: If you build many package repositories, investigate poudriere’s cache (*[https://ccache.samba.org/](https://ccache.samba.org/)*)
    support. You’ll use about 5GB of disk space per jail but save a whole bunch of
    time rebuilding packages.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建许多软件包仓库，可以研究 poudriere 对缓存的支持（*[https://ccache.samba.org/](https://ccache.samba.org/)）。你每个
    jail 大约需要 5GB 的磁盘空间，但能节省大量重建软件包的时间。
- en: '**Updating Poudriere**'
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更新 Poudriere**'
- en: New ports get added all the time, with new options. Other software projects
    continually release new versions, and the FreeBSD port is correspondingly updated.
    You’ll want those new versions on your servers. If you build your ports with poudriere,
    updating is pretty simple. You’ll need to update your jail and your ports tree.
    Before updating either, though, make sure *poudriere.conf* is set up to handle
    updates.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 新的端口不断被添加，并且带有新的选项。其他软件项目也会持续发布新版本，而 FreeBSD 端口会相应地更新。你肯定希望这些新版本能够在你的服务器上使用。如果你使用
    poudriere 构建端口，更新过程会相当简单。你需要更新你的监狱和端口树。然而，在更新之前，确保 *poudriere.conf* 已经设置好以处理更新。
- en: '**/USR/PORTS/UPDATING**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**/USR/PORTS/UPDATING**'
- en: Before updating your ports, check */usr/ports/UPDATING* for any special notes
    that might affect your environment. An unexpected change in the default version
    of Python or Perl can ruin your whole day.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新端口之前，检查 */usr/ports/UPDATING*，看看是否有任何可能影响你环境的特别说明。Python 或 Perl 默认版本的意外变化可能会让你的一整天都泡汤。
- en: Poudriere has two options for handling dependency changes. You’ll want to enable
    both. `CHECK_CHANGED_DEPS` tells poudriere not to trust earlier dependency calculations
    and perform those checks again. This catches changes in underlying Perl, Python,
    and so on. Similarly, `CHECK_CHANGED_OPTIONS` tells poudriere to verify each port’s
    options. Setting this to `verbose` tells poudriere to show you any changes.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere 提供了两种处理依赖关系变化的选项。你需要启用这两者。`CHECK_CHANGED_DEPS` 告诉 poudriere 不要信任之前的依赖关系计算，而是重新执行这些检查。这可以捕捉到底层
    Perl、Python 等的变化。类似地，`CHECK_CHANGED_OPTIONS` 告诉 poudriere 验证每个端口的选项。将其设置为 `verbose`
    会告诉 poudriere 显示任何变化。
- en: '[PRE56]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now you can update your jails and the ports tree. Use the `-u` flag to update
    the jail. Give the jail name with `-j`. Here, I update poudriere’s amd-11-1 jail.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以更新你的监狱和端口树。使用 `-u` 标志来更新监狱。通过 `-j` 指定监狱的名称。在这里，我更新了 poudriere 的 amd-11-1
    监狱。
- en: '[PRE57]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For jails installed from official media, poudriere runs freebsd-update(8) and
    applies any missing security patches. If you installed from source, poudriere
    repeats the install process.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从官方媒体安装的监狱，poudriere 会运行 freebsd-update(8) 并应用任何缺失的安全补丁。如果你是从源代码安装的，poudriere
    会重复安装过程。
- en: Similarly, update the ports tree with `-u`. Specify the name of the ports tree
    with `-p`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用 `-u` 更新端口树。通过 `-p` 指定端口树的名称。
- en: '[PRE58]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You’ll see poudriere use portsnap(8) to grab the latest updates. Now you can
    build the new version of the package repository, exactly as you did the first
    time.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到 poudriere 使用 portsnap(8) 获取最新的更新。现在你可以像第一次那样构建新版本的软件包仓库。
- en: '[PRE59]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Poudriere determines what needs updating and what must be rebuilt and proceeds
    accordingly. Once the build is complete, your clients can upgrade their packages
    from the repository.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere 会确定哪些需要更新，哪些必须重新构建，并相应地执行操作。构建完成后，客户可以从仓库中升级他们的软件包。
- en: '**More Poudriere**'
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更多 Poudriere**'
- en: Poudriere has many more features than what I cover here. You can cryptographically
    sign your packages with the `PKG_REPO_SIGNING_KEY` variable. Package sets let
    you define different build options for different repositories. You want to build
    an experimental package run with the latest Python? Look at package sets. You
    can blacklist ports so that they’re never built, even if called as a dependency.
    See poudriere(8) for all kinds of nifty stuff.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Poudriere 拥有比我在这里介绍的更多功能。你可以通过 `PKG_REPO_SIGNING_KEY` 变量对你的软件包进行加密签名。软件包集合允许你为不同的仓库定义不同的构建选项。想要构建一个实验性的包并运行最新的
    Python 吗？看看软件包集合。你还可以将某些端口列入黑名单，确保它们永远不会被构建，即使它们作为依赖被调用。查看 poudriere(8) 了解更多实用功能。
- en: Between ports and poudriere, you can now customize software any way you need.
    If you really want to get into the nitty-gritty of the Ports Collection, check
    out the FreeBSD Porter’s Handbook on *[https://www.freebsd.org/](https://www.freebsd.org/)*.
    The rest of us will move on to some of FreeBSD’s advanced software features.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在端口和 poudriere 之间，你现在可以根据需要定制软件。如果你真的想深入了解 Ports Collection，查看 FreeBSD Porter’s
    Handbook 在 *[https://www.freebsd.org/](https://www.freebsd.org/)* 上的内容。其他人则可以继续了解
    FreeBSD 的一些高级软件功能。
