<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_145"/><strong><span class="big">15</span></strong><br/><strong>XML ATTACKS</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="image" width="190" height="190"/></div>&#13;
<p class="noindent">With the explosive growth of the internet in the ’90s, organizations began sharing data with each other over the web. Sharing data between computers meant agreeing on a shared data format. Human-readable documents on the web were being marked up with HyperText Markup Language (HTML). Machine-readable files were often stored in an analogous data format called <em>Extensible Markup Language (XML)</em>.</p>&#13;
<p class="indent">XML can be thought of as a more general implementation of HTML: in this form of markup, the tag and attribute names can be chosen by the document author rather than being fixed, as they are in the HTML specification. In <a href="ch15.xhtml#ch15list1">Listing 15-1</a>, you can see an XML file describing a catalog of books, using tags like <code>&lt;catalog&gt;</code>, <code>&lt;book&gt;</code>, and <code>&lt;author&gt;</code>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_146"/>&lt;?xml version="1.0"?&gt;<br/>&lt;catalog&gt;<br/>   &lt;book id="7991728882998"&gt;<br/>      &lt;author&gt;Sponden, Phillis&lt;/author&gt;<br/>      &lt;title&gt;The Evil Horse That Knew Karate&lt;/title&gt;<br/>      &lt;genre&gt;Young Adult Fiction&lt;/genre&gt;<br/>      &lt;description&gt;Three teenagers with very different personalities<br/>team up to defeat a surprising villain.&lt;/description&gt;<br/>   &lt;/book&gt;<br/>   &lt;book id="28299171927772"&gt;<br/>      &lt;author&gt;Chenoworth, Dr. Sebastian&lt;/author&gt;<br/>      &lt;title&gt;Medical Encyclopedia of Elbows, 12th Edition&lt;/title&gt;<br/>      &lt;genre&gt;Medical&lt;/genre&gt;<br/>      &lt;description&gt;The world's foremost forearm expert gives detailed diagnostic<br/>and clinical advice on maintaining everyone's favorite joint.&lt;/description&gt;<br/>   &lt;/book&gt;<br/>&lt;/catalog&gt;</pre>&#13;
<p class="caption"><a id="ch15list1"/><em>Listing 15-1: An XML document describing a catalog of books</em></p>&#13;
<p class="indent">The popularity of this data format, especially in the early days of the web, means that XML <em>parsing</em>—the process of turning an XML file into in-memory code objects—has been implemented in every browser and web server of the past few decades. Unfortunately, XML parsers are a common target for hackers. Even if your site doesn’t handle XML by design, your web server may parse the data format by default. This chapter shows how XML parsers can be attacked and how to defuse these attacks.</p>&#13;
<h3 class="h3" id="ch00lev1sec223"><strong>The Uses of XML</strong></h3>&#13;
<p class="noindent">Much like HTML, XML encloses data items between tags and allows tags to be embedded within one another. The author of an XML document can choose semantically meaningful tag names so that the XML document is self-describing. Because XML is very readable, the data format was widely adopted to encode data for consumption by other applications.</p>&#13;
<p class="indent">The uses of XML are many. Application programming interfaces (APIs) that allow client software to call functions over the internet frequently accept and respond using XML. JavaScript code in web pages that communicates asynchronously back to the server often uses XML. Many types of applications—web servers included—use XML-based configuration files.</p>&#13;
<p class="indent">In the past decade, some of these applications have started using better-suited, less verbose data formats than XML. For example, JSON is a more natural method of encoding data in JavaScript and other scripting languages. The YAML language uses meaningful indentation, making it a simpler format for configuration files. Nevertheless, every web server implements XML parsing in some fashion and needs to be secured against XML attacks.</p>&#13;
<p class="indent">XML vulnerabilities generally occur during the validation process. Let’s take a minute to discuss what validation means in the context of parsing an XML document.</p>&#13;
<h3 class="h3" id="ch00lev1sec224"><span epub:type="pagebreak" id="page_147"/><strong>Validating XML</strong></h3>&#13;
<p class="noindent">Since the author of an XML file is able to choose which tag names are used in the document, any application reading the data needs to know which tags to expect and in what order they will appear. The expected structure of an XML document is often described by a formal grammar against which the document can be <em>validated</em>.</p>&#13;
<p class="indent">A <em>grammar</em> file dictates to a parser which sequences of characters are valid expressions within the language. A programming language grammar might specify, for instance, that variable names can contain only alphanumeric characters, and that certain operators like <code>+</code> require two inputs.</p>&#13;
<p class="indent">XML has two major ways of describing the expected structure of an XML document. A <em>document type definition (DTD)</em> file resembles the <em>Bachus–Naur Form (BNF)</em> notation often used to describe programming language grammars. An <em>XML Schema Definition (XSD)</em> file is a more modern, more expressive alternative, capable of describing a wider set of XML documents; in this case, the grammar itself is described in an XML file. Both methods of XML validation are widely supported by XML parsers. However, DTDs contain a couple of features that can expose the parser to attack, so that’s what we’ll focus on.</p>&#13;
<h4 class="h4" id="ch00lev1sec225"><strong><em>Document Type Definitions</em></strong></h4>&#13;
<p class="noindent">A DTD file describes the structure of an XML file by specifying the tags, subtags, and types of data expected in a document. <a href="ch15.xhtml#ch15list2">Listing 15-2</a> shows a DTD file describing the expected structure of the <code>&lt;catalog&gt;</code> and <code>&lt;book&gt;</code> tags in <a href="ch15.xhtml#ch15list1">Listing 15-1</a>.</p>&#13;
<pre>&lt;!DOCTYPE catalog [<br/>  &lt;!ELEMENT catalog     (book+)&gt;<br/>  &lt;!ELEMENT book        (author,title,genre,description)&gt;<br/>  &lt;!ENTITY  author      (#PCDATA)&gt;<br/>  &lt;!ENTITY  title       (#PCDATA)&gt;<br/>  &lt;!ENTITY  genre       (#PCDATA)&gt;<br/>  &lt;!ENTITY  description (#PCDATA)&gt;<br/>  &lt;!ATTLIST book id CDATA&gt;<br/>]&gt;</pre>&#13;
<p class="caption"><a id="ch15list2"/><em>Listing 15-2: A DTD file describing the format of the XML in <a href="ch15.xhtml#ch15list1">Listing 15-1</a></em></p>&#13;
<p class="indent">This DTD describes that the top-level <code>&lt;catalog&gt;</code> tag is expected to contain zero or more <code>&lt;book&gt;</code> tags (the quantity is denoted by the <code>+</code> sign), and that each <code>&lt;book&gt;</code> tag is expected to contain tags describing the <code>author</code>, <code>title</code>, <code>genre</code>, and <code>description</code>, plus an <code>id</code> attribute. The tags and attribute are expected to contain parsed character data (<code>#PCDATA</code>) or character data (<code>CDATA</code>)—that is, text rather than tags.</p>&#13;
<p class="indent">DTDs can be included within an XML document to make the document self-validating. However, a parser that supports such <em>inline</em> DTDs is vulnerable to attack—because a malicious user uploading such an XML document has control over the contents of the DTD, rather than it being <span epub:type="pagebreak" id="page_148"/>supplied by the parser itself. Hackers have used inline DTDs to exponentially increase the amount of server memory a document consumes during parsing (an XML bomb), and access to other files on the server (an XML external entity attack). Let’s see how these attacks work.</p>&#13;
<h3 class="h3" id="ch00lev1sec226"><strong>XML Bombs</strong></h3>&#13;
<p class="noindent">An <em>XML bomb</em> uses an inline DTD to explode the memory usage of an XML parser. This will take a web server offline by exhausting all the memory available to the server and causing it to crash.</p>&#13;
<p class="indent">XML bombs take advantage of the fact that DTDs can specify simple string substitution macros that are expanded at parse time, called <em>internal entity declarations</em>. If a snippet of text is frequently used in an XML file, you can declare it in the DTD as an internal entity. That way, you don’t have to type it out every time you need it in the document—you just type the entity name as a shorthand. In <a href="ch15.xhtml#ch15list3">Listing 15-3</a>, an XML file containing employee records specifies the company name in the DTD by using an internal entity declaration.</p>&#13;
<pre>&lt;?xml version="1.0"?&gt;<br/>&lt;!DOCTYPE employees [<br/>  &lt;!ELEMENT employees (employee)*&gt;<br/>  &lt;!ELEMENT employee (#PCDATA)&gt;<br/>  &lt;!ENTITY company "Rock and Gravel Company"<span class="ent">❶</span>&gt;<br/>]&gt;<br/>&lt;employees&gt;<br/>  &lt;employee&gt;<br/>    Fred Flintstone, &amp;company;<span class="ent">❷</span><br/>  &lt;/employee&gt;<br/>  &lt;employee&gt;<br/>    Barney Rubble, &amp;company;<span class="ent">❸</span><br/>  &lt;/employee&gt;<br/>&lt;/employees&gt;</pre>&#13;
<p class="caption"><a id="ch15list3"/><em>Listing 15-3: An internal entity declaration</em></p>&#13;
<p class="indent">The string <code>&amp;company;</code> <span class="ent">❷</span> <span class="ent">❸</span> acts as a placeholder for the value <code>Rock and Gravel Company</code> <span class="ent">❶</span>. When the document is parsed, the parser replaces all instances of <code>&amp;company;</code> with <code>Rock and Gravel Company</code> and produces the final document shown in <a href="ch15.xhtml#ch15list4">Listing 15-4</a>.</p>&#13;
<pre>&lt;?xml version="1.0"?&gt;<br/>&lt;employees&gt;<br/>  &lt;employee&gt;<br/>    Fred Flintstone, Rock and Gravel Company<br/>  &lt;/employee&gt;<br/>  &lt;employee&gt;<br/>    Barney Rubble, Rock and Gravel Company<br/>  &lt;/employee&gt;<br/>&lt;/employees&gt;</pre>&#13;
<p class="caption"><a id="ch15list4"/><em>Listing 15-4: The XML document after the parser processes the DTD</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_149"/>Internal entity declarations are useful, if seldom used. Problems occur when internal entity declarations refer to other internal entity declarations. <a href="ch15.xhtml#ch15list5">Listing 15-5</a> shows a nested series of entity declarations that constitute an XML bomb.</p>&#13;
<pre>&lt;?xml version="1.0"?&gt;<br/>&lt;!DOCTYPE lolz [<br/>  &lt;!ENTITY lol "lol"&gt;<br/>  &lt;!ENTITY lol2 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;<br/>  &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;<br/>  &lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"&gt;<br/>  &lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"&gt;<br/>  &lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"&gt;<br/>  &lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"&gt;<br/>  &lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"&gt;<br/>  &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;<br/>]&gt;<br/>&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</pre>&#13;
<p class="caption"><a id="ch15list5"/><em>Listing 15-5: A type of XML bomb known as</em> the billion laughs attack</p>&#13;
<p class="indent">When this XML file is parsed, the <code>&amp;lol9;</code> string is replaced with 10 occurrences of the string <code>&amp;lol8;</code>. Then <em>each</em> occurrence of <code>&amp;lol8;</code> is replaced with 10 occurrences of the string <code>&amp;lol7;</code>. The final form of the XML file consists of a <code>&lt;lolz&gt;</code> tag containing over a <em>billion</em> occurrences of the string <code>lol</code>. This simple XML file will take up over 3GB of memory when the DTD is fully expanded, enough to crash the XML parser!</p>&#13;
<p class="indent">Exhausting the memory available to the XML parser will take your web server offline, which makes XML bombs an effective way for a hacker to launch a denial-of-service attack. All an attacker needs to do is to find a URL on your site that accepts XML uploads, and they can take you offline with a click of a button.</p>&#13;
<p class="indent">XML parsers that accept inline DTDs are also vulnerable to a sneakier type of attack that takes advantage of entity definitions in a different manner.</p>&#13;
<h3 class="h3" id="ch00lev1sec227"><strong>XML External Entity Attacks</strong></h3>&#13;
<p class="noindent">DTDs can include content from external files. If an XML parser is configured to process inline DTDs, an attacker can use these <em>external entity declarations</em> to explore the local filesystem or to trigger network requests from the web server itself.</p>&#13;
<p class="indent">A typical external entity looks like <a href="ch15.xhtml#ch15list6">Listing 15-6</a>.</p>&#13;
<pre>&lt;?xml version="1.0" standalone="no"?&gt;<br/>&lt;!DOCTYPE copyright [<br/>  &lt;!ELEMENT copyright (#PCDATA)&gt;<br/>  &lt;!ENTITY copy PUBLIC "http://www.w3.org/xmlspec/copyright.xml"<span class="ent">❶</span>&gt;<br/>]&gt;<br/>&lt;copyright&gt;&amp;copy;<span class="ent">❷</span> &lt;/copyright&gt;</pre>&#13;
<p class="caption"><a id="ch15list6"/><em>Listing 15-6: Using an external entity to include boilerplate copyright text in an XML file</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_150"/>According to the XML 1.0 specification, a parser is expected to read the contents of the file specified in the external entity and insert that data into the XML document wherever the entity is referenced. In this example, the data hosted at <em>http://www.w3.org/xmlspec/copyright.xml</em> <span class="ent">❶</span> would be inserted into the XML document wherever the text <code>&amp;copy;</code> <span class="ent">❷</span> appears.</p>&#13;
<p class="indent">The URL referenced by the external entity declaration can use various network protocols, depending on the prefix. Our example DTD uses the <em>http://</em> prefix, which will cause the parser to make an HTTP request. The XML specification also supports reading local files on disk, using the <em>file://</em> prefix. For this reason, external entity definitions are a security <em>disaster</em>.</p>&#13;
<h4 class="h4" id="ch00lev1sec228"><strong><em>How Hackers Exploit External Entities</em></strong></h4>&#13;
<p class="noindent">When an XML parser throws an error, the error message will often include the contents of the XML document being parsed. Knowing this, hackers use external entity declarations to read files on a server. A maliciously crafted XML file might include a reference to a file such as <em>file://etc/passwd</em> on a Linux system, for instance. When this external file is inserted into the XML document by the parser, the XML becomes malformed—so parsing fails. The parser then dutifully includes the contents of the file in the error response, allowing the hacker to view the sensitive data within the referenced file. Using this technique, hackers can read sensitive files on a vulnerable web server that contain passwords and other confidential information.</p>&#13;
<p class="indent">External entities can also be used to commit <em>server-side request forgery (SSRF)</em> attacks, whereby an attacker triggers malicious HTTP requests from your server. A naïvely configured XML parser will make a network request whenever it encounters an external entity URL with a network protocol prefix. Being able to trick your web server into making a network request on a URL of their choosing is a boon for an attacker! Hackers have used this feature to probe internal networks, to launch denial-of-service attacks on third parties, and to disguise malicious URL calls. You will learn more about the risks around SSRF attacks in the next chapter.</p>&#13;
<h3 class="h3" id="ch00lev1sec229"><strong>Securing Your XML Parser</strong></h3>&#13;
<p class="noindent">This is a simple fix to protect your parser from XML attacks: disable the processing of inline DTDs in your configuration. DTDs are a legacy technology, and inline DTDs are a bad idea, period. In fact, many modern XML parsers are hardened by default, meaning out of the box they disable features that allow the parser to be attacked, so you might be protected already. If you are unsure, you should check what (if any) XML parsing technology you are using.</p>&#13;
<p class="indent">The following sections describe how to secure your XML parser in some of the major web programming languages. Even if you think your code doesn’t parse XML, the third-party dependencies you use likely use XML in some form. Make sure you analyze your entire dependency tree to see what libraries are loaded into memory when your web server starts up.</p>&#13;
<h4 class="h4" id="ch00lev1sec230"><span epub:type="pagebreak" id="page_151"/><strong><em>Python</em></strong></h4>&#13;
<p class="noindent">The <code>defusedxml</code> library explicitly rejects inline DTDs and is a drop-in replacement for Python’s standard XML parsing library. Use this module in place of Python’s standard library.</p>&#13;
<h4 class="h4" id="ch00lev1sec231"><strong><em>Ruby</em></strong></h4>&#13;
<p class="noindent">The de facto standard for parsing XML in Ruby is the <code>Nokogiri</code> library. This library has been hardened to XML attacks since version 1.5.4, so make sure your code uses that version or higher for parsing.</p>&#13;
<h4 class="h4" id="ch00lev1sec232"><strong><em>Node.js</em></strong></h4>&#13;
<p class="noindent">Node.js has a variety of modules for parsing XML, including <code>xml2js</code>, <code>parse-xml</code>, and <code>node-xml</code>. Most of them omit processing of DTDs by design, so make sure to consult the documentation for the parser you use.</p>&#13;
<h4 class="h4" id="ch00lev1sec233"><strong><em>Java</em></strong></h4>&#13;
<p class="noindent">Java has a variety of methods of parsing XML. Parsers that adhere to Java specifications typically initiate parsing via the class <code>javax.xml.parsers.DocumentBuilderFactory</code>. <a href="ch15.xhtml#ch15list7">Listing 15-7</a> illustrates how to configure secure XML parsing in this class wherever it is instantiated, using the <code>XMLConstants.FEATURE_SECURE_PROCESSING</code> feature.</p>&#13;
<pre>DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();<br/>factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</pre>&#13;
<p class="caption"><a id="ch15list7"/><em>Listing 15-7: Securing a Java XML parsing library</em></p>&#13;
<h4 class="h4" id="ch00lev1sec234"><strong><em>.NET</em></strong></h4>&#13;
<p class="noindent">.NET has a variety of methods of parsing XML, all contained in the <code>System.Xml</code> namespace. <code>XmlDictionaryReader</code>, <code>XmlNodeReader</code>, and <code>XmlReader</code> are safe by default, as are <code>System.Xml.Linq.XElement</code> and <code>System.Xml.Linq.XDocument</code>. <code>System.Xml.XmlDocument</code>, <code>System.Xml.XmlTextReader</code>, and <code>System.Xml.XPath.XPathNavigator</code> have been secured since .NET version 4.5.2. If you are using an earlier version of .NET, you should switch to a secure parser, or disable the processing of inline DTDs. <a href="ch15.xhtml#ch15list8">Listing 15-8</a> shows how to do this by setting the <code>ProhibitDtd</code> attribute flag.</p>&#13;
<pre>XmlTextReader reader = new XmlTextReader(stream);<br/>reader.ProhibitDtd = true;</pre>&#13;
<p class="caption"><a id="ch15list8"/><em>Listing 15-8: Disabling processing of inline DTDs in .NET</em></p>&#13;
<h3 class="h3" id="ch00lev1sec235"><span epub:type="pagebreak" id="page_152"/><strong>Other Considerations</strong></h3>&#13;
<p class="noindent">The threat of external entity attacks illustrates the importance of following the <em>principle of least privilege</em>, which states that software components and processes should be granted the minimal set of permissions required to perform their tasks. There is rarely a good reason for an XML parser to make outbound network requests: consider locking down outbound network requests for your web server as a whole. If you do need outbound network access—for example, if your server code calls third-party APIs—you should whitelist the domains of those APIs in your firewall rules.</p>&#13;
<p class="indent">Similarly, it’s important to restrict the directories on disk that your web server can access. On the Linux operating system, this can be achieved by running your web server process in a <code>chroot</code> jail that ignores any attempts by the running process to change its root directory. On the Windows operating system, you should manually whitelist the directories that the web server can access.</p>&#13;
<h3 class="h3" id="ch00lev1sec236"><strong>Summary</strong></h3>&#13;
<p class="noindent">Extensible Markup Language (XML) is a flexible data format widely used to exchange machine-readable data on the internet. Your XML parser may be vulnerable to attack if it is configured to accept and process inline document type definitions (DTDs). XML bombs use inline DTDs to explode the parser’s memory use, potentially crashing your web server. XML external entity attacks reference local files or network addresses, and can be used to trick the parser into revealing sensitive information or make malicious network requests. Make sure you use a hardened XML parser that disables inline DTD parsing.</p>&#13;
<p class="indent">The next chapter expands on a concept touched on in this chapter: how security flaws in your web server can be leveraged by hackers to launch attacks on third parties. Even when you aren’t the victim directly, it’s important to be a good internet citizen and stop attacks that use your system.</p>&#13;
</div>



  </body></html>